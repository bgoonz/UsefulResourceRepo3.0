<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>advanced-react</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
  </head>
  <body>
    <h2 id="overview">Overview</h2>
    <p>
      Stateful logic is logic that is built into a component. It can be a
      function that handles a click event or maybe a function that sets toggle
      state, or even a function that formats data before it gets displayed.
      Usually, this kind of logic deals with state in the component. Thus the
      moniker “stateful logic.”
    </p>
    <h2 id="follow-along">Follow Along</h2>
    <p>
      Look at this component. Can you spot the stateful logic built into it?
    </p>
    <pre class="jsx"><code>import React, { useState } from &quot;react&quot;;

const DynamicTitle = () =&gt; {
  const [title, setTitle] = useState(&quot;Hooks are so fun!&quot;);
  const [inputText, setInputText] = useState(&quot;&quot;);

  const handleChanges = (e) =&gt; {
    setInputText(e.target.value);
  };

  const changeTitle = (e) =&gt; {
    e.preventDefault();
    setTitle(inputText);
    setInputText(&quot;&quot;);
  };

  return (
    &lt;div className=&quot;Wrapper&quot;&gt;
      &lt;h1 className=&quot;Title&quot;&gt;{title}&lt;/h1&gt;
      &lt;form onSubmit={changeTitle}&gt;
        &lt;div className=&quot;Input&quot;&gt;
          &lt;input
            className=&quot;Input-text&quot;
            id=&quot;input&quot;
            name=&quot;inputText&quot;
            onChange={handleChanges}
            placeholder=&quot;Create new title&quot;
            type=&quot;text&quot;
            value={inputText}
          /&gt;
          &lt;label htmlFor=&quot;input&quot; className=&quot;Input-label&quot;&gt;
            New title
          &lt;/label&gt;
        &lt;/div&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
};

export default DynamicTitle;</code></pre>
    <p>
      You are probably looking at the two functions -
      <code>handleChanges</code> and <code>changeTitle</code>. If so, that is
      correct! And we can probably also count the <code>title</code> and
      <code>inputText</code> state in there as well. Those are all great
      examples of stateful logic. And really, the sky’s the limit on what could
      be considered stateful logic in a React component.
    </p>
    <h2 id="challenge">Challenge</h2>
    <p>
      Now that you can identify stateful logic, go through a few of the React
      components you’ve built this week. Try to point out examples of different
      stateful logic. How many different examples did you find?
    </p>
    <h2 id="overview-1">Overview</h2>
    <p>
      React is, in essence, a combination of multiple components. A component
      can be as simple as a single piece of user interface that represents a
      small portion of our application. Conceptually, a component lifecycle
      happens in three phases. This idea is displayed nicely in the following
      diagram from one of the maintainers of React “Dan Abramov”.
    </p>
    <figure>
      <img src="https://image.ibb.co/j8CzEd/lifecycle.jpg" alt="drawing" />
      <figcaption>drawing</figcaption>
    </figure>
    <p>
      As you can see, the three React lifestyle phases are 1) Birth/Mounting, 2)
      Growth/Updating, and 3) Death/Unmounting.
    </p>
    <h3 id="the-birthmounting-phase">The Birth/Mounting Phase</h3>
    <p>
      This is the phase when the component is being built out from the ground
      up. A few things are happening here:<br />
      Whatever initial data you want access to will be defined on the
      constructor of this phase
    </p>
    <ul>
      <li>Your render method is invoked.</li>
      <li><code>componentDidMount</code> gets called as well.</li>
    </ul>
    <h3 id="growthupdating-phase">Growth/Updating Phase</h3>
    <p>In the Growth/Updating phase you’re updating compnent data.</p>
    <ul>
      <li>
        <code>setState</code> can be used to change the component’s state data,
        forcing a call to <code>render</code>.
      </li>
      <li>
        <code>shouldComponentUpdate</code> is a method one could use here to
        stop a component from calling render if necessary.
      </li>
    </ul>
    <h3 id="deathun-mounting-phase">Death/Un-mounting Phase</h3>
    <p>
      Again, self-explanatory, but the unmounting phase includes removing the
      component from the screen.
    </p>
    <ul>
      <li>Component is removed from the screen.</li>
      <li>
        <code>componentWillUnmount</code> is called and can be used for any
        clean up you may need to do.
      </li>
    </ul>
    <h2 id="follow-along-1">Follow Along</h2>
    <p>
      Dive into the documentation at
      <a
        href="https://reactjs.org/docs/react-component.html#the-component-lifecycle"
        >ReactJS (Links to an external site.)</a
      >and look into some of the key pieces of the LifeCycle API.
    </p>
    <p>The methods that we’re going to look at are:</p>
    <ul>
      <li><code>constructor</code></li>
      <li><code>render</code></li>
      <li><code>componentDidMount</code></li>
      <li><code>componentDidUpdate</code></li>
      <li><code>componentWillUnmount</code></li>
    </ul>
    <p>
      Let’s also compare where each of these methods belong within the react
      lifecycle by taking a look at
      <a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/"
        >this diagram (Links to an external site.)</a
      >.
    </p>
    <p>
      We will explore these in depth later on but for now, focus on warming up
      to the documentation and the idea that components have a lifecycle.
    </p>
    <h2 id="challenge-1">Challenge</h2>
    <p>
      Read
      <a
        href="https://medium.com/@baphemot/understanding-reactjs-component-life-cycle-823a640b3e8d"
        >this medium article (Links to an external site.)</a
      >{:target=“_blank”} about the component lifecycle. Take notes and share
      what you learned in a paragraph to your Project Manager via Slack.##
      Overview
    </p>
    <p>
      React gave us the idea of components as independent pieces of UI. And thus
      far, you have learned how to build out
      <code>functional components</code> for use in making multiple DOM
      elements. Now, we’re going to be learning about the
      <code>React.Component</code> base class that allows us to use some of the
      methods that the React team has curated to tap into what we call the
      <code>Component Lifecycle</code>. These methods (known as life cycle hooks
      <em>more on these to come</em>) give us control over how our components
      work, and if we’d like to use them, we have to build out a class component
      that <code>extends</code> the <code>React.Component</code> parent class.
      Any time you see a line of code that looks like the following, you’re
      using the React.Component parent class, and you have the ability to tap
      into these methods.
    </p>
    <pre
      class="jsx"
    ><code>class FooComponent extends React.Component {}</code></pre>
    <p>
      By creating components as classes, you can set up a data object that your
      component is concerned with. This is done using <code>state</code> and
      setting up that object on our constructor method. Once we have some data
      that we can render out to the DOM, we need a vehicle that will allow us to
      render that data. This is achieved with the JSX method
      <code>render()</code> from within the life-cycle hook. We’ll walk you
      through the steps below.
    </p>
    <p>
      Declare your <code>class component</code> by extending the
      <code>React.Component</code> parent class.
      <code>class FooComponent extends React.Component {}</code>.<br />
      Use the <code>constructor</code> function to set up some state.
      <em
        >because we’re calling extends, we also need to call
        <code>super();</code> otherwise we won’t have access the
        <code>this</code></em
      ><br />
      We need to render some sort of UI to the DOM. We do this by calling the
      life-cycle method <code>render</code>.
    </p>
    <p>
      I like to remember these steps by referencing one of my favorite bands:
      Creedence Clearwater Revival (CCR), which stands for class, constructor,
      and render/return.
    </p>
    <ol type="1">
      <li>
        Declare your <em>class</em>, and extend the
        <code>React.Component</code> Base class.
      </li>
    </ol>
    <pre
      class="jsx"
    ><code>class FooComponent extends React.Component {</code></pre>
    <ol start="2" type="1">
      <li>Now we’ll set up our <em>constructor</em> and add state.</li>
    </ol>
    <pre class="jsx"><code>constructor() {
  super();
  this.state = {};
}</code></pre>
    <ol start="3" type="1">
      <li>
        <em>Render</em> some UI and <em>return</em> some <code>JSX.</code>
      </li>
    </ol>
    <pre class="jsx"><code>render() {
  return &lt;div&gt;Hello, I am Foo Component&lt;/div&gt;;
}</code></pre>
    <p>Our final component should look like this.</p>
    <pre class="jsx"><code>class FooComponent extends React.Component {
  constructor() {
    super();
    this.state = {};
  }
  render() {
    return &lt;div&gt;Hello, I am Foo Component&lt;/div&gt;;
  }
}</code></pre>
    <p>
      Now that we have constructed a skeleton for our Class component, it can be
      a bit more dynamic. The way we’ll achieve this will be to use some data
      that we’ll pre-define as some information we’d like our component to
      display. We’ll then take that data and do this really cool thing called
      <code>interpolation</code> in order to present it to the DOM within some
      Text.
    </p>
    <p>
      Components built out extending the Base <code>React.Component</code> class
      come with a bunch of benefits directly from the React API. A list of the
      benefits to what we get out of the Component class can be found
      <a
        href="https://reactjs.org/docs/react-component.html#getsnapshotbeforeupdate"
        >here (Links to an external site.)</a
      >, in theReact documentation about class components. We will be discussing
      the <code>life-cycle</code> methods at another place in time, so don’t
      worry too much about those for now.
    </p>
    <p>
      For now, let’s focus on a component caring about its own state (data) and
      managing that state in a reactive way. The <code>state</code> object that
      we set up on our <code>constructor</code> has a very React-specific way of
      doing things. It allows us to drive our UI using data. Again, think about
      Facebook here. You see a LOT of data and interact with it all of the time
      when you’re using the Facebook app. Because of the way we work with social
      media today, we expect this data the UI to represent that data in close to
      real-time. This is one reason why React is really good and how reactivity
      can be achieved.
    </p>
    <h2 id="follow-along-2">Follow Along</h2>
    <p>
      Let’s work together to build out a class component that prints a message
      to the screen using a few DOM elements. We will hold a message on state,
      and print that message to the screen by selecting it an assigning it to a
      DOM element. Then we will take it a step further and pass that message
      down to another component using props.
    </p>
    <p>
      Go ahead and navigate over to
      <a href="https://codesandbox.io/s/3xwzql38nm"
        >this Codesandbox (Links to an external site.)</a
      >, where we will write our React Code. CodeSandbox is an online editor
      that can be used to write React Code right away! I can’t emphasize how
      cool this really is. For now, you’ll just have to trust me.
    </p>
    <p>
      You’ll notice that we’re getting an error on this page. As we begin to
      define our app class, elements will start to come to life on for us. For
      now, let’s start by simply adding the class through CCR.
    </p>
    <p>
      When you’re done, your browser window should re-render without any errors.
      Your app class should look like this:
    </p>
    <pre class="jsx"><code>class App extends React.Component {
  constructor() {
    super();
    this.state = {};
  }
  render() {
    return &lt;div&gt;Hello From App!&lt;/div&gt;;
  }
}</code></pre>
    <p>
      Now, let’s add a property to our state data. Define a
      <code>message</code> property on the state object.
    </p>
    <pre class="jsx"><code>this.state = {
  message: &quot;Hello from App State!!&quot;,
};</code></pre>
    <p>
      Now that we have the message on our component’s state, we can use it
      through interpolation. In our render method, let’s change the message
      inside of <code>div</code> to reference the state object. Remember the
      <code>this</code> keyword when pointing to an object on the Class
      constructor.
    </p>
    <pre class="jsx"><code>render() {
  return &lt;div&gt;{this.state.message}&lt;/div&gt;;
}</code></pre>
    <p>
      Hooray! You’ve now built your first class component, and you’re ready to
      rock n’ roll.
    </p>
    <h2 id="challenge-2">Challenge</h2>
    <p>
      Let’s take the functionality of this class component that we built earlier
      and extend it just a little bit. Declare a
      <code>Functional Component</code> called <code>RenderMessage</code> inside
      <a href="https://codesandbox.io/s/103jkor46q"
        >this CodeSandbox (Links to an external site.)</a
      >.
    </p>
    <ul>
      <li>
        Make sure you declare your Props Object that will be passed into this
        component.
      </li>
      <li>
        Return a <code>div</code> who’s child is <code>props.message</code>
      </li>
      <li>
        Now inside of the <code>App</code> class pass in that
        <code>RenderMessage</code> component and pass down a message prop to
        <code>RenderMessage</code>. This message prop should be set equal to the
        message property on the state object.
      </li>
      <li>Once it’s all wired up properly you’ve done it!</li>
    </ul>
    <h2 id="overview-2">Overview</h2>
    <p>
      <code>Custom Hooks</code>, are so-called because you are building the hook
      yourself (customizing it), to apply non-visual behavior and stateful logic
      throughout your components. This way, you can reuse the same hook over and
      over again. Custom hooks follow the same patterns of naming that you’ve
      already learned (i.e. prefacing the function name with <code>use</code>,
      as in <code>useState</code>). You can build a reusable custom hook for
      anything from handling controlled inputs, to managing event listeners, or
      watching for key presses.
    </p>
    <h2 id="follow-along-3">Follow Along</h2>
    <p>
      Let’s start with the same component that we evaluated in the objective
      above. Go ahead and look over it one more time, this time making sure to
      understand what the various parts are doing.
    </p>
    <pre class="jsx"><code>import React, { useState } from &quot;react&quot;;

const DynamicTitle = () =&gt; {
  const [title, setTitle] = useState(&quot;This is a class component&quot;);
  const [inputText, setInputText] = useState(&quot;&quot;);

  const handleChanges = (e) =&gt; {
    setInputText(e.target.value);
  };

  const changeTitle = (e) =&gt; {
    e.preventDefault();
    setTitle(inputText);
    setInputText(&quot;&quot;);
  };

  return (
    &lt;div className=&quot;Wrapper&quot;&gt;
      &lt;h1 className=&quot;Title&quot;&gt;{title}&lt;/h1&gt;
      &lt;form onSubmit={changeTitle}&gt;
        &lt;div className=&quot;Input&quot;&gt;
          &lt;input
            className=&quot;Input-text&quot;
            id=&quot;input&quot;
            name=&quot;inputText&quot;
            onChange={handleChanges}
            placeholder=&quot;Create new title&quot;
            type=&quot;text&quot;
            value={inputText}
          /&gt;
          &lt;label htmlFor=&quot;input&quot; className=&quot;Input-label&quot;&gt;
            New title
          &lt;/label&gt;
        &lt;/div&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
};

export default DynamicTitle;</code></pre>
    <p>
      See how we have a <code>useState</code> hook, a
      <code>handleChange</code> function to update based on any changes, and a
      <code>changeTitle</code> function to change the actual title of the
      component when we submit the form?
    </p>
    <p>
      Now, what happens if we need to issue state for multiple
      <code>input</code> tags? If we were to follow the lead of the patterns
      shown above, we would end up having to rewrite large amounts of our code
      for each <code>useState</code> call that we’ve invoked in order to create
      state for our second, third, and fourth <code>input</code>s.
    </p>
    <p>
      Instead, let’s build out our custom hook that to reuse stateful logic. In
      this way, we avoid repeating code unnecessarily. Read the following
      function and try to guess what each piece of code is doing:
    </p>
    <pre class="jsx"><code>export const useInput = (initialValue) =&gt; {
  const [value, setValue] = useState(initialValue);
  const handleChanges = (updatedValue) =&gt; {
    setValue(updatedValue);
  };
  return [value, setValue, handleChanges];
};</code></pre>
    <p>
      In this <code>useInput</code> custom hook function, we’re taking in an
      <code>initialValue</code> and returning three new values. We pass
      <code>initialValue</code> as a parameter on the function.
      <code>initialValue</code> is then passed into the
      <code>useState</code> hook, which returns an array with our
      <code>value</code> variable and <code>setValue</code> function (just the
      same as what you’ve used up to this point).
    </p>
    <p>
      Next, we have a <code>handleChanges</code> function that uses the
      <code>setValue</code> function to update state to a new value. Finally, we
      return an array from our <code>useInput</code> custom hook containing the
      <code>value</code> variable, the <code>setValue</code> function, and the
      <code>handleChanges</code> function.
    </p>
    <p>
      Let’s take a look at this custom hook when it’s imported and used in a
      component.
    </p>
    <pre class="jsx"><code>import React, { useState } from &quot;react&quot;;
import { useInput } from &quot;./useInput.js&quot;;

const CustomForm = () =&gt; {
  const [username, setUsername, handleUsername] = useInput(&quot;&quot;);
  const [password, setPassword, handlePassword] = useInput(&quot;&quot;);
  const [email, setEmail, handleEmail] = useInput(&quot;&quot;);

  const resetValues = (e) =&gt; {
    e.preventDefault();
    setUsername(&quot;&quot;);
    setPassword(&quot;&quot;);
    setEmail(&quot;&quot;);
  };

  return (
    &lt;form onSubmit={resetValues}&gt;
      &lt;input
        className=&quot;username-text&quot;
        id=&quot;username&quot;
        name=&quot;username&quot;
        onChange={(e) =&gt; handleUsername(e.target.value)}
        placeholder=&quot;Username&quot;
        type=&quot;text&quot;
        value={username}
      /&gt;
      &lt;input
        className=&quot;password-test&quot;
        id=&quot;password&quot;
        name=&quot;password&quot;
        onChange={(e) =&gt; handlePassword(e.target.value)}
        placeholder=&quot;Password&quot;
        type=&quot;password&quot;
        value={password}
      /&gt;
      &lt;input
        className=&quot;email-text&quot;
        id=&quot;email&quot;
        name=&quot;email&quot;
        onChange={(e) =&gt; handleEmail(e.target.value)}
        placeholder=&quot;Email&quot;
        type=&quot;text&quot;
        value={email}
      /&gt;
      &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  );
};

export default CustomForm;</code></pre>
    <p>
      Whoa. That looks crazy, right? Don’t worry. We’re going to dissect this
      whole script to figure out exactly what each part is doing.
    </p>
    <p>
      First off, notice that we’re invoking the <code>useInput</code> custom
      hook three times at the top of the component and passing in an empty
      string as each one’s initial value:
    </p>
    <pre
      class="jsx"
    ><code>const [username, setUsername, handleUsername] = useInput(&quot;&quot;);
const [password, setPassword, handlePassword] = useInput(&quot;&quot;);
const [email, setEmail, handleEmail] = useInput(&quot;&quot;);</code></pre>
    <p>
      Our <code>useInput</code> hook returns a new copy of our custom hook and
      state each time. Also, because array destructuring is based on positioning
      and not the name, we are allowed by JavaScript to name each of the three
      items returned from <code>useInput</code> in different ways. This is why
      we can set the first item to <code>username</code>, the second to
      <code>setUsername</code>, and the third to
      <code>handleUsername</code> while the next two <code>useInput</code> calls
      return differently-named variables and functions.
    </p>
    <p>
      From these invocations, it now becomes easy to rig up each of our input
      tags in our JSX just the same as we did before. Here they are again for
      your reference:
    </p>
    <pre class="jsx"><code>&lt;form onSubmit={resetValues}&gt;
  &lt;input
    className=&quot;username-text&quot;
    id = &quot;username&quot;;
    name = &quot;username&quot;;
    onChange={e =&gt; handleUsername(e.target.value)}
    placeholder = &quot;Username&quot;;
    type = &quot;text&quot;;
    value={username}
  /&gt;
  &lt;input
    className=&quot;password-test&quot;
    id = &quot;password&quot;;
    name = &quot;password&quot;;
    onChange={e =&gt; handlePassword(e.target.value)}
    placeholder = &quot;Password&quot;;
    type = &quot;password&quot;;
    value={password}
  /&gt;
  &lt;input
    className=&quot;email-text&quot;
    id = &quot;email&quot;;
    name = &quot;email&quot;;
    onChange={e =&gt; handleEmail(e.target.value)}
    placeholder = &quot;Email&quot;;
    type = &quot;text&quot;;
    value={email}
  /&gt;
  &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
&lt;/form&gt;</code></pre>
    <p>
      Notice how we are setting our <code>handleUsername</code>,
      <code>handlePassword</code>, and <code>handleEmail</code> functions to
      process changes to the input. Remember how we returned a
      <code>handleChanges</code> function from our custom hook? Well, we’ve
      renamed them here (again, thanks to array destructuring) and are using
      them just the same as before. However, now, we have less code for them in
      our component.
    </p>
    <p>
      The final thing you should notice is the <code>resetValue</code> function.
      When we invoke it, we use the <code>setValue</code>s returned from each
      <code>useInput</code> (again, each one is named differently) and pass it
      in our reset value (in this case, an empty string). Isn’t this an easy way
      to change your state?
    </p>
    <p>Here they are again for your reference:</p>
    <pre class="jsx"><code>const resetValues = (e) =&gt; {
  e.preventDefault();
  setUsername(&quot;&quot;);
  setPassword(&quot;&quot;);
  setEmail(&quot;&quot;);
};</code></pre>
    <p>
      By building out a custom hook, we can skip writing out all of the stateful
      logic for our non-visual behavior. Custom hooks produce beautiful,
      <code>DRY</code> code that is easy to read <em>and</em> use. You have
      built a <em>reusable</em> piece of code that makes it easy for you to
      import anywhere in your application and build out stateful logic in any of
      your components.
    </p>
    <h2 id="challenge-3">Challenge</h2>
    <p>
      Now that you can identify custom hook logic and how you might both create
      and use it in your components, go back to several components you’ve built
      over the last week and refactor the state in some forms you made to use
      the <code>useInput</code> custom hook from the component in the examples
      above.
      <a href="https://codesandbox.io/s/yk37ykmyrz"
        >Click here (Links to an external site.)</a
      >
      to access the code within this video’s follow-along exercise.
    </p>
    <h2 id="overview-3">Overview</h2>
    <p>
      Up until this point, our applications have been fairly simple. One or two
      components with a bit of state to allow for interaction. As our
      applications grow, so to do the complexity way components relate to each
      other. To do this, it helps to see our components as being structure in a
      <code>parent / child</code> relationship.
    </p>
    <p>Here is an example of a more complicated application hierarchy.</p>
    <figure>
      <img
        src="https://drive.google.com/uc?id=1Ahn_s5WHHcJDD_t17eWAGOlIoX7ZTy4i"
        alt="Graph 1"
      />
      <figcaption>Graph 1</figcaption>
    </figure>
    <p>
      Simple or complex, every application needs shared, persistent data to run.
    </p>
    <p>
      Currently, we have been using <code>state</code> to hold that data. Unlike
      statically defined data within our component, state is persistent,
      changeable and can flow into other components through use of
      <code>prop drilling</code>. Changes to state immediately rerender the
      parts of our components effected by that change of state in a process
      called <code>reactivity</code>. When working with more complex component
      trees, state always runs from a <code>parent</code> component down to a
      <code>child</code>.
    </p>
    <figure>
      <img
        src="https://drive.google.com/uc?id=1fjz_nVILoUG0kr1m0jzfUtQAiKf_-kga"
        alt="Graph 2"
      />
      <figcaption>Graph 2</figcaption>
    </figure>
    <p>
      What if we want to modify that data? Well, just as we can pass parent
      state down through props, we can also pass functions that modify child
      state! Executing these functions in our child components will cause state
      to change at our parent level components, resulting in reactive rendering
      through out all our application!
    </p>
    <figure>
      <img
        src="https://drive.google.com/uc?id=1-xf6YVOb38HINlQOnBMhkYYXy8ypOP2u"
        alt="Graph 3"
      />
      <figcaption>Graph 3</figcaption>
    </figure>
    <p>
      We have already seen how to pass state through props using functional
      components. Now, let’s take a look at how we work with state in class
      based components.
    </p>
    <h2 id="follow-along-4">Follow Along</h2>
    <p>Consider the following component:</p>
    <pre class="jsx"><code>class App extends React.Component {
  constructor() {
    super();
    this.state = {
      welcomeMessage: &quot;world!&quot;,
    };
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, {this.state.welcomeMessage}!&lt;/h1&gt;
      &lt;/div&gt;
    );
  }
}</code></pre>
    <p>
      Let’s create a sub component using functional components to hold our
      welcome message.
    </p>
    <pre class="jsx"><code>const WelcomeBanner = (props) =&gt; {
  return &lt;h1&gt;Hello, {props.message}!&lt;/h1&gt;;
};</code></pre>
    <p>Now, lets refactor our component using React classes.</p>
    <pre class="jsx"><code>class WelcomeBanner extends React.Component {
    render(){
        return(
        &lt;div&gt;
            &lt;h1&gt;Hello, {this.props.message}&lt;/h1&gt;
        &lt;/div&gt;
    }
}</code></pre>
    <p>
      Notice that props are not passed in as they were in functional components.
      Instead, props are attached to the this object, just like state.
    </p>
    <p>
      Great! We are sharing data between a component’s state and a component’s
      props. This means that when the state object changes, so too will the
      props.
    </p>
    <p>
      Now let’s add in the ability to modify that state. To do this we will need
      to:
    </p>
    <ul>
      <li>
        Connect a state change method to an event listener in our child
        component.
      </li>
      <li>Create the substance of that method in our parent.</li>
      <li>Pass that method to the child through props.</li>
    </ul>
    <p>
      Let’s start at bottom, our child component. Let’s say that we want use a
      form to dynamically update our message statement. This small component
      should do nicely:
    </p>
    <pre class="jsx"><code>const FormComponent = props =&gt; {
  return (
    &lt;form&gt;
      &lt;input placeholder=&quot;change state&quot; onChange={props.updateStateMessage} /&gt;
    &lt;/form&gt;
};</code></pre>
    <p>
      The only problem is, we don’t have access to state all the way down here!
      Let’s build out our state changing method where it belongs, in App.js our
      <code>parent</code>. While we are at it, let’s add our form component to
      our rendering so we can see it in the first place.
    </p>
    <pre class="jsx"><code>class App extends React.Component {
  constructor() {
    super();
    this.state = {
      welcomeMessage: &quot;world!&quot;,
    };
  }

  updateStateMessage = (e) =&gt; {
    this.setState({ welcomeMessage: e.target.value });
  };

  render() {
    return (
      &lt;div&gt;
        &lt;WelcomeBanner message={this.state.welcomeMessage} /&gt;
        &lt;FormComponent updateStateMessage={this.updateStateMessage} /&gt;
      &lt;/div&gt;
    );
  }
}</code></pre>
    <p>
      And there we go! We successfully passed our
      <code>state data</code> downstream through <code>props</code> in
      WelcomeBanner. At the same time, we can also successful pass data back
      upstream by executing <code>state modifying functions</code> passed
      through <code>props</code> in FormComponent.
    </p>
    <h2 id="challenge-4">Challenge</h2>
    <p>
      Using the components we just created (App, FormComponent and
      MessageComponent), try building out a form that will allow a user to
      handle data. You’ll need a button, input field, and some data-bound to a
      DOM element that displays what the user is submitting.
    </p>
    <p>
      When a user clicks submit, show the data that’s on state in
      an <code>alert</code> statement.
    </p>
    <h3 id="stretch">Stretch </h3>
    <p>
      Loop over a list of items showing those items to the screen. (Can be a
      list of strings). When a user clicks submit, instead of logging the item,
      push an item into that list, and watch the magic happen.
    </p>
    <ul>
      <li>We’re going to be updating some state on a parent component.</li>
      <li>
        That state will be wired up to a few other components as we pass the
        props around.
      </li>
      <li>
        We will also be passing around a few handler functions that help us
        update/delete our state.
      </li>
    </ul>
    <p>
      Lets set up a form component that we can use to update our message
      component from above.
    </p>
    <pre
      class="jsx"
    ><code>const WelcomeBanner = (props) =&gt; &lt;h1&gt;Hello, {props.message}!&lt;/h1&gt;;

class App extends React.Component {
  constructor() {
    super();
    this.state = {
      welcomeMessage: &quot;world!&quot;,
    };
  }

  render() {
    return (
      &lt;div&gt;
        &lt;WelcomeBanner message={this.state.welcomeMessage} /&gt;
      &lt;/div&gt;
    );
  }
}</code></pre>
    <p>
      Now let’s build a form component that can handle some data defined on
      state, below on the child components.
    </p>
    <pre class="jsx"><code>const FormComponent = (props) =&gt; {
  return (
    &lt;form&gt;
      &lt;input placeholder=&quot;change state&quot; onChange={props.updateStateMessage} /&gt;
    &lt;/form&gt;
  );
};</code></pre>
    <p>
      We’re going to need to build out a change handler function on our
      <code>App</code> component that we can pass down to the form. We’ll have
      to define the prop as <code>updateStateMessage</code> in order to make our
      <code>onChange</code> event handler work out properly.
    </p>
    <pre class="jsx"><code>...

messageChangeHandler = event =&gt; {
  this.setState({welcomeMessage: event.target.value});
};

render() {
  return (
    &lt;div&gt;
      &lt;WelcomeBanner message={this.state.welcomeMessage} updateStateMessage={this.updateStateMessage}/&gt;
    &lt;/div&gt;
  );
}
...</code></pre>
    <h2 id="challenge-5">Challenge</h2>
    <p>Using the following tools:</p>
    <ul>
      <li>Class component</li>
      <li>functional FormComponent, MessageComponent</li>
      <li>click, and change handlers</li>
      <li><code>setState</code></li>
    </ul>
    <p>
      Build out a form that will allow a user to handle data. You’ll need a
      button, input field, and some data-bound to a DOM element that displays
      what the user is submitting.
    </p>
    <p>
      When a user clicks submit, show the data that’s on state in an
      <code>alert</code> statement.
    </p>
    <p>
      <strong>Stretch</strong> Loop over a list of items showing those items to
      the screen. (Can be a list of strings). When a user clicks submit, instead
      of logging the item, push an item into that list, and watch the magic
      happen.
    </p>
    <h2 id="overview-4">Overview</h2>
    <p>
      Just as we can compose functions in vanilla JavaScript and components in
      React to create new functionality, we can extend our stateful logic by
      combining several hooks in a powerful, single custom hook. This
      compositional ability allows us to build out interesting abilities by
      combining various hooks in our application.
    </p>
    <p>
      We can develop this complexity using multiple hooks inside a single custom
      hook. We’ve done this already when we called <code>useState</code> inside
      <code>useInput</code>. Pretty cool! Now imagine writing several custom
      hooks and combining all of that logic into a single custom hook to use in
      your components. The possibilities are dizzying! And amazing! Let’s try it
      out by expanding the <code>useInput</code> custom hook we’ve already
      built.
    </p>
    <h2 id="follow-along-5">Follow Along</h2>
    <p>
      We need to start by building out a second custom hook. Later on, we’ll
      combine it with the <code>useInput</code> custom hook from the previous
      objective to achieve a more compelling hook with multiple pieces of
      stateful logic.
    </p>
    <p>
      First, we’ll implement the new hook that we will call
      <code>useLocalStorage</code>:
    </p>
    <pre class="jsx"><code>import { useState } from &quot;react&quot;;

const useLocalStorage = (key, initialValue) =&gt; {
  const [storedValue, setStoredValue] = useState(() =&gt; {
    const item = window.localStorage.getItem(key);
    return item ? JSON.parse(item) : initialValue;
  });
  const setValue = (value) =&gt; {
    setStoredValue(value);
    window.localStorage.setItem(key, JSON.stringify(value));
  };
  return [storedValue, setValue];
};</code></pre>
    <p>
      Let’s walk through what we’re doing here. First, we pass in a key-value
      (like: “input1,” “input2” ) and an <code>initialValue</code>. These two
      parameters (key and value) are used in the <code>useState</code> hook call
      and used immediately inside our custom hooks. Instead of just passing in
      an initial value to this <code>useState</code> hook, we are using an
      anonymous arrow function as a callback to do two things:
    </p>
    <ol type="1">
      <li>
        Check if the <code>window.localStorage</code> has a specific item
        (retrieved by <code>key</code>) in it
      </li>
      <li>
        Return that item from local storage if it exists or the initialValue
        otherwise
      </li>
    </ol>
    <p>
      Because of this, our hook can now successfully check to see if a specific
      state item exists in <code>localStorage</code>, <strong>and</strong> it
      can use that item if it exists instead of the provided
      <code>initialValue</code>. Then, we also have a
      <code>setValue</code> function that takes a <code>value</code> as a
      parameter, sets it to the current <code>storedValue</code> by using the
      <code>setStoredValue</code> provided by <code>useState</code>, and sets it
      <code>localStorage</code>. As our state is now stored, our custom hook
      will check here on refresh to see if the state exists.
    </p>
    <p>
      Now that we have a custom hook for controlling value placement (and
      updates) in <code>localStorage</code>, we can combine it with
      <code>useInput</code> to create powerful logic. Take a look at the
      completed code, and then we’ll talk about what it’s doing:
    </p>
    <pre class="jsx"><code>import { useState } from &quot;react&quot;;

export const useInput = (key, initialValue) =&gt; {
  const [value, setValue] = useLocalStorage(key, initialValue);
  const handleChanges = (updatedValue) =&gt; {
    setValue(updatedValue);
  };
  return [value, setValue, handleChanges];
};

const useLocalStorage = (key, initialValue) =&gt; {
  const [storedValue, setStoredValue] = useState(() =&gt; {
    const item = window.localStorage.getItem(key);
    return item ? JSON.parse(item) : initialValue;
  });
  const setValue = (value) =&gt; {
    setStoredValue(value);
    window.localStorage.setItem(key, JSON.stringify(value));
  };
  return [storedValue, setValue];
};</code></pre>
    <p>
      While our <code>useLocalStorage</code> hook has stayed the same, our
      <code>useInput</code> custom hook has some nice upgrades going on. Instead
      of implementing <code>useState</code> from React as before, we’re now
      using <code>useLocalStorage</code>. Furthermore, we’re also taking in two
      parameters instead of one - <code>key</code> and
      <code>initialValue</code>. These are then passed directly into the
      <code>useLocalStorage</code> hook. Immediately, the hook sets about
      implementing special logic with the variables as described above. This
      returns to our <code>useInput</code> custom hook with either a value from
      <code>localStorage</code> or our initialValue, and our
      <code>useInput</code> custom hook then returns a <code>value</code>,
      <code>setValue</code> function, and a <code>handleChanges</code> function
      in an array just the same as it did before.
    </p>
    <p>
      Now when we call the <code>useInput</code> hook in a component to control
      inputs dynamically, we just need to pass in a unique key for each input to
      keep track of it in localStorage. Something like this:
    </p>
    <pre
      class="jsx"
    ><code>const [username, setUsername, handleUsername] = useInput(&quot;userName&quot;, &quot;&quot;);
const [password, setPassword, handlePassword] = useInput(&quot;password&quot;, &quot;&quot;);
const [email, setEmail, handleEmail] = useInput(&quot;email&quot;, &quot;&quot;);</code></pre>
    <p>
      Although this isn’t something you will often do (storing input values in
      localStorage), this setup is quite powerful, and it effectively
      demonstrates how composable hooks can be; by combining the stateful logic
      of multiple custom hooks, you can compose a really nice custom hook with
      advanced stateful logic.
    </p>
    <p>
      One final thing to note is that we can employ the
      <code>useLocalStorage</code> custom hook in other places now as well. So,
      not only do we have an extra-powerful <code>useInput</code> created by
      composing multiple hooks together, we also have another custom hook
      available to us anytime we want to persist data in localStorage.
    </p>
    <h2 id="challenge-6">Challenge</h2>
    <p>
      Try to think of different instances where you could compose different
      custom hooks together, particularly with the new
      <code>useLocalStorage</code> hook that you learned above. Be as creative
      as possible in the implementations that you think of. You can access the
      example in this video
      <a href="https://codesandbox.io/s/k0q2wwyj2o"
        >here (Links to an external site.)</a
      >.
    </p>
    <h2 id="overview-5">Overview</h2>
    <p>
      In our last objective, we explored how <code>state</code> can be displayed
      and changed by passing state value and state modifying functions
      respectively through <code>props</code>. We explored this using the
      onChange <code>eventlistener</code>. That is, of course, only one of many
      user event you can integrate into your applications!
    </p>
    <p>
      We have already seen how events are handled within React class components.
      We need an <code>event handler</code> function and we need to link it to
      an <code>eventlistener</code> method within our DOM.
    </p>
    <pre class="jsx"><code>class Button extends React.Component {
  handleButton = (e) =&gt; {
    console.log(e);
  };

  render() {
    return &lt;button onClick={this.handleButton}&gt;Click Me&lt;/button&gt;;
  }
}</code></pre>
    <p>
      Notice once again the need for that <code>this</code> object when
      referencing our <code>event handler</code>. Within class components, just
      like our props and state, our event handlers are bound to the instance of
      this class and are accessed through <code>this.</code>
    </p>
    <p>
      We have also seen that “e” parameter before. This parameter is known is
      React as a <code>synthetic event</code> object. Inside this object, we
      will have access to various pieces of information regarding this event
      triggered, including the target DOM element, the type of event, and
      methods that control the propagation of that event like preventDefault.
      For more details on the <code>synthetic event</code> objects, check out
      the reference materials
      <a href="https://reactjs.org/docs/events.html"
        >here (Links to an external site.)</a
      >.
    </p>
    <p>Let’s add in some functionality to our event handler.</p>
    <pre class="jsx"><code>class Button extends React.Component {
  clickHandler = (event) =&gt; {
    console.log(event); // this is the react Synthetic Event
  };

  render() {
    return &lt;button onClick={this.clickHandler}&gt;Click Me&lt;/button&gt;;
  }
}</code></pre>
    <p>
      Now, when we click on our button, we can actually print out our
      <code>synthetic event</code> object. We can now do anything we want within
      <code>event handler</code>, from triggering a change of state to starting
      an external api call.
    </p>
    <h2 id="follow-along-6">Follow Along</h2>
    <p>
      Now, let’s build out a little Application that can handle some data that
      we pass through a few JSX elements. We’re going to build out some
      <code>event handler</code> functions using the following
      <code>event listeners</code>:
    </p>
    <ul>
      <li>onClick</li>
      <li>onDoubleClick</li>
      <li>onMouseEnter</li>
      <li>OnChange</li>
    </ul>
    <p>First, let’s build out a singleClickHandler function.</p>
    <pre
      class="jsx"
    ><code>singleClickHandler = () =&gt; alert(&quot;Single Click!&quot;);</code></pre>
    <p>Now, we add it to a button within our app’s render function.</p>
    <pre class="jsx"><code>render() {
. . .
&lt;button onClick={this.singleClickHandler}&gt;Click Handler Demo&lt;/button&gt;
. . .</code></pre>
    <p>
      Lets repeat the process for our doubleClick, mouseEnter and onChange
      events.
    </p>
    <pre
      class="jsx"
    ><code>doubleClickHandler = () =&gt; alert(&quot;Double Clicked!&quot;);

mouseEnterHandler = () =&gt; alert(&quot;Mouse Entered&quot;);

changeHandler = () =&gt; alert(&quot;Item was changed&quot;);
&lt;div className=&quot;App&quot;&gt;
  &lt;h1&gt;Hello Handlers&lt;/h1&gt;
  &lt;h2&gt;Lets build out some handler functions.&lt;/h2&gt;
  &lt;button onClick={this.singleClickHandler}&gt;Click Handler Demo&lt;/button&gt;
  &lt;button onDoubleClick={this.doubleClickHandler}&gt;Double Click Handler&lt;/button&gt;
  &lt;div onMouseEnter={this.mouseEnterHandler}&gt;Mouse Enter&lt;/div&gt;
  &lt;input onChange={this.changeHandler} placeholder=&quot;Change my input&quot; /&gt;
&lt;/div&gt;;</code></pre>
    <p>
      Try playing around with the events and see how are interacting one with
      another.
    </p>
    <p>
      Lets take a closer look at the input onChange event for a min. Let’s pass
      in the synthetic event through the function body by adding it as a
      <code>parameter</code> to the <code>event handler</code> connected to it.
    </p>
    <pre
      class="jsx"
    ><code>changeHandler = (e) =&gt; alert(event.target.value);</code></pre>
    <p>
      One of the most useful properties attached to
      <code>synthetic events</code> is target. This provides information on the
      text, value, style, attached attributes and other useful data within our
      DOM element. In this case we can print out our input’s value.
    </p>
    <p>
      Lets add in some state to get realtime feedback of what we are typing.
      Once again, we do this within class components by within the class
      <code>constructor</code> and make our app display that change.
    </p>
    <pre class="jsx"><code>class App extends React.Component {
 constructor() {
    super();
    this.state = {
      displayText: &#39;&#39;,
    }
  }
…
 render() {
    return(     …
        &lt;h1&gt;{this.displayText}&lt;/h1&gt;
        …
    );
 }
}</code></pre>
    <p>Lets also update our change handler to update our state:</p>
    <pre class="jsx"><code>changeHandler = (event) =&gt; {
  this.setState({ displayText: event.target.value });
};</code></pre>
    <p>
      Excellent! Now, <code>setState</code> will update our display property on
      our state object by simply typing in the input field. Let’s prove this by
      logging our state object inside the render function.
    </p>
    <pre class="jsx"><code>...
render() {
  console.log(this.state);
...</code></pre>
    <p>
      You can see a working copy of this example
      <a href="https://codesandbox.io/s/rmnj2r1o0p"
        >here (Links to an external site.)</a
      >.
    </p>
    <h2 id="challenge-7">Challenge</h2>
    <p>Lets expand on our example!</p>
    <p>Fork the code provided above and do the following.</p>
    <ul>
      <li>Add another value to state that holds the secondDisplayValue.</li>
      <li>Display that value in a h2 tag.</li>
      <li>
        Create a button that will put the value of state.displayText within our
        secondDisplayValue property.
      </li>
      <li>
        Add an event listener and event handler function that will cause our h2
        to show displayText when we click our new button. //APPEND-DIR.js const
        fs = require( ‘fs’ ); let cat = require( ‘child_process’ ).execSync(
        ‘cat *’ ).toString( ‘UTF-8’ ); fs.writeFile( ‘output.md’, cat, ( err )
        =&gt; { if ( err ) throw err; } );
      </li>
    </ul>
  </body>
</html>
