;

## Internal links

All tutorial links should start from the root, not including the domain.

✅ OK:

    We'll cover that in the chapter [about functions](/function-basics)

❌ Not ok:

    We'll cover that in the chapter [about functions](https://javascript.info/function-basics)

Also, to reference a chapter, there’s a special “info:” scheme, like this:

    We'll cover that in the chapter <info:function-basics>.

Becomes:

    We'll cover that in the chapter <a href="/function-basics">Function basics</a>.

The title is auto-inserted from the referenced article. That has the benefit of keeping the right title if the article gets renamed.

## TODO

Ask <span class="citation" data-cites="iliakan">@iliakan</span> to for more details.

The tutorial is free to read.

If you’d like to do something else with it, please get a permission from Ilya Kantor, iliakan@javascript.info.

As of now, we license the tutorial to almost everyone for free under the terms of an open license. Just please be so kind to contact me.

## License (Short)

The license is basically [CC-BY-NC](https://creativecommons.org/licenses/by-nc/4.0/legalcode), revocable and exclusive.

It gives the right to: - **Share** – copy and redistribute the tutorial in any medium or material. - **Adapt** – remix, transform, and build upon the material.

Under the following terms:

- **Attribution** — You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.
- **NonCommercial** — You may not use the material for commercial purposes.

## License (Legal)

By exercising the Licensed Rights (defined below), You accept and agree to be bound by the terms and conditions of this license (“Public License”). To the extent this Public License may be interpreted as a contract, You are granted the Licensed Rights in consideration of Your acceptance of these terms and conditions, and the Licensor grants You such rights in consideration of benefits the Licensor receives from making the Licensed Material available under these terms and conditions.

### Section 1 – Definitions.

1.  **Adapted Material** means material subject to Copyright and Similar Rights that is derived from or based upon the Licensed Material and in which the Licensed Material is translated, altered, arranged, transformed, or otherwise modified in a manner requiring permission under the Copyright and Similar Rights held by the Licensor. For purposes of this Public License, where the Licensed Material is a musical work, performance, or sound recording, Adapted Material is always produced where the Licensed Material is synched in timed relation with a moving image.

2.  **Adapter’s License** means the license You apply to Your Copyright and Similar Rights in Your contributions to Adapted Material in accordance with the terms and conditions of this Public License.

3.  **Copyright and Similar Rights** means copyright and/or similar rights closely related to copyright including, without limitation, performance, broadcast, sound recording, and Sui Generis Database Rights, without regard to how the rights are labeled or categorized. For purposes of this Public License, the rights specified in Section 2(b)(1)-(2) are not Copyright and Similar Rights.

4.  **Exceptions and Limitations** means fair use, fair dealing, and/or any other exception or limitation to Copyright and Similar Rights that applies to Your use of the Licensed Material.

5.  **Licensed Material** means the artistic or literary work, database, or other material to which the Licensor applied this Public License.

6.  **Licensor** means the individual(s) or entity(ies) granting rights under this Public License.

7.  **NonCommercial** means not primarily intended for or directed towards commercial advantage or monetary compensation. For purposes of this Public License, the exchange of the Licensed Material for other material subject to Copyright and Similar Rights by digital file-sharing or similar means is NonCommercial provided there is no payment of monetary compensation in connection with the exchange.

8.  **Share** means to provide material to the public by any means or process that requires permission under the Licensed Rights, such as reproduction, public display, public performance, distribution, dissemination, communication, or importation, and to make material available to the public including in ways that members of the public may access the material from a place and at a time individually chosen by them.

9.  **Sui Generis Database Rights** means rights other than copyright resulting from Directive 96/9/EC of the European Parliament and of the Council of 11 March 1996 on the legal protection of databases, as amended and/or succeeded, as well as other essentially equivalent rights anywhere in the world.

10. **You** means the individual or entity exercising the Licensed Rights under this Public License. Your has a corresponding meaning.

### Section 2 – Scope.

1.  **_License grant._**

    1.  Subject to the terms and conditions of this Public License, the Licensor hereby grants You a worldwide, royalty-free, non-sublicensable, non-exclusive, irrevocable license to exercise the Licensed Rights in the Licensed Material to:

        A. reproduce and Share the Licensed Material, in whole or in part, for NonCommercial purposes only; and

        B. produce, reproduce, and Share Adapted Material for NonCommercial purposes only.

    2.  **Exceptions and Limitations.** For the avoidance of doubt, where Exceptions and Limitations apply to Your use, this Public License does not apply, and You do not need to comply with its terms and conditions.

    3.  **Term.** The term of this Public License is specified in Section 6(a).

    4.  **Downstream recipients.**

        A. **Offer from the Licensor – Licensed Material.** Every recipient of the Licensed Material automatically receives an offer from the Licensor to exercise the Licensed Rights under the terms and conditions of this Public License.

        B. **No downstream restrictions.** You may not offer or impose any additional or different terms or conditions on, or apply any Effective Technological Measures to, the Licensed Material if doing so restricts exercise of the Licensed Rights by any recipient of the Licensed Material.

    5.  **No endorsement.** Nothing in this Public License constitutes or may be construed as permission to assert or imply that You are, or that Your use of the Licensed Material is, connected with, or sponsored, endorsed, or granted official status by, the Licensor or others designated to receive attribution as provided in Section 3(a)(1)(A)(i).

2.  **_Other rights._**

    1.  Moral rights, such as the right of integrity, are not licensed under this Public License, nor are publicity, privacy, and/or other similar personality rights; however, to the extent possible, the Licensor waives and/or agrees not to assert any such rights held by the Licensor to the limited extent necessary to allow You to exercise the Licensed Rights, but not otherwise.

    2.  Patent and trademark rights are not licensed under this Public License.

    3.  To the extent possible, the Licensor waives any right to collect royalties from You for the exercise of the Licensed Rights, whether directly or through a collecting society under any voluntary or waivable statutory or compulsory licensing scheme. In all other cases the Licensor expressly reserves any right to collect such royalties, including when the Licensed Material is used other than for NonCommercial purposes.

### Section 3 – License Conditions.

Your exercise of the Licensed Rights is expressly made subject to the following conditions.

1.  **_Attribution._**

    1.  If You Share the Licensed Material (including in modified form), You must:

        A. retain the following if it is supplied by the Licensor with the Licensed Material:

        1.  identification of the creator(s) of the Licensed Material and any others designated to receive attribution, in any reasonable manner requested by the Licensor (including by pseudonym if designated);

        2.  a copyright notice;

        3.  a notice that refers to this Public License;

        4.  a notice that refers to the disclaimer of warranties;

        5.  a URI or hyperlink to the Licensed Material to the extent reasonably practicable;

        B. indicate if You modified the Licensed Material and retain an indication of any previous modifications; and

        C. indicate the Licensed Material is licensed under this Public License, and include the text of, or the URI or hyperlink to, this Public License.

    2.  You may satisfy the conditions in Section 3(a)(1) in any reasonable manner based on the medium, means, and context in which You Share the Licensed Material. For example, it may be reasonable to satisfy the conditions by providing a URI or hyperlink to a resource that includes the required information.

    3.  If requested by the Licensor, You must remove any of the information required by Section 3(a)(1)(A) to the extent reasonably practicable.

    4.  If You Share Adapted Material You produce, the Adapter’s License You apply must not prevent recipients of the Adapted Material from complying with this Public License.

### Section 4 – Sui Generis Database Rights.

Where the Licensed Rights include Sui Generis Database Rights that apply to Your use of the Licensed Material:

1.  for the avoidance of doubt, Section 2(a)(1) grants You the right to extract, reuse, reproduce, and Share all or a substantial portion of the contents of the database for NonCommercial purposes only;

2.  if You include all or a substantial portion of the database contents in a database in which You have Sui Generis Database Rights, then the database in which You have Sui Generis Database Rights (but not its individual contents) is Adapted Material; and

3.  You must comply with the conditions in Section 3(a) if You Share all or a substantial portion of the contents of the database.

For the avoidance of doubt, this Section 4 supplements and does not replace Your obligations under this Public License where the Licensed Rights include other Copyright and Similar Rights.

### Section 5 – Disclaimer of Warranties and Limitation of Liability.

1.  **Unless otherwise separately undertaken by the Licensor, to the extent possible, the Licensor offers the Licensed Material as-is and as-available, and makes no representations or warranties of any kind concerning the Licensed Material, whether express, implied, statutory, or other. This includes, without limitation, warranties of title, merchantability, fitness for a particular purpose, non-infringement, absence of latent or other defects, accuracy, or the presence or absence of errors, whether or not known or discoverable. Where disclaimers of warranties are not allowed in full or in part, this disclaimer may not apply to You.**

2.  **To the extent possible, in no event will the Licensor be liable to You on any legal theory (including, without limitation, negligence) or otherwise for any direct, special, indirect, incidental, consequential, punitive, exemplary, or other losses, costs, expenses, or damages arising out of this Public License or use of the Licensed Material, even if the Licensor has been advised of the possibility of such losses, costs, expenses, or damages. Where a limitation of liability is not allowed in full or in part, this limitation may not apply to You.**

3.  The disclaimer of warranties and limitation of liability provided above shall be interpreted in a manner that, to the extent possible, most closely approximates an absolute disclaimer and waiver of all liability.

### Section 6 – Term and Termination.

1.  This Public License applies for the term of the Copyright and Similar Rights licensed here. However, if You fail to comply with this Public License, then Your rights under this Public License terminate automatically.

2.  Where Your right to use the Licensed Material has terminated under Section 6(a), it reinstates:

    1.  automatically as of the date the violation is cured, provided it is cured within 30 days of Your discovery of the violation; or

    2.  upon express reinstatement by the Licensor.

    For the avoidance of doubt, this Section 6(b) does not affect any right the Licensor may have to seek remedies for Your violations of this Public License.

3.  For the avoidance of doubt, the Licensor may also offer the Licensed Material under separate terms or conditions or stop distributing the Licensed Material at any time; however, doing so will not terminate this Public License.

4.  Sections 1, 5, 6, 7, and 8 survive termination of this Public License.

### Section 7 – Other Terms and Conditions.

1.  The Licensor shall not be bound by any additional or different terms or conditions communicated by You unless expressly agreed.

2.  Any arrangements, understandings, or agreements regarding the Licensed Material not stated herein are separate from and independent of the terms and conditions of this Public License.

### Section 8 – Interpretation.

1.  For the avoidance of doubt, this Public License does not, and shall not be interpreted to, reduce, limit, restrict, or impose conditions on any use of the Licensed Material that could lawfully be made without permission under this Public License.

2.  To the extent possible, if any provision of this Public License is deemed unenforceable, it shall be automatically reformed to the minimum extent necessary to make it enforceable. If the provision cannot be reformed, it shall be severed from this Public License without affecting the enforceability of the remaining terms and conditions.

3.  No term or condition of this Public License will be waived and no failure to comply consented to unless expressly agreed to by the Licensor.

This repository hosts the English content of the Modern JavaScript Tutorial, published in <https://javascript.info>.

## Translations

We’d like to make the tutorial available in many languages. Please help us to translate.

See <a href="https://javascript.info/translate" class="uri">https://javascript.info/translate</a> for the details.

## Contributions

We’d also like to collaborate on the tutorial with other people.

Something’s wrong? A topic is missing? Explain it to people, add as PR 👏

**You can edit the text in any editor.** The tutorial uses enhanced “markdown” format, easy to grasp. And if you want to see how it looks on-site, there’s a server to run the tutorial locally at <a href="https://github.com/javascript-tutorial/server" class="uri">https://github.com/javascript-tutorial/server</a>.

The list of contributors is available at <a href="https://javascript.info/about#contributors" class="uri">https://javascript.info/about#contributors</a>.

## Structure

Every chapter, article or a task has its folder.

The folder is named like `N-url`, where `N` is a number for the sorting purposes and `url` is the URL part with title of the material.

The type of the material is defined by the file inside the folder:

- `index.md` stands for a chapter
- `article.md` stands for an article
- `task.md` stands for a task (solution must be provided in `solution.md` file as well)

Each of these files starts from the `# Main header`.

It’s very easy to add something new.

      // here's the code
      let hello = "world";

… \`\`\`

For better readability and at the same time, to beautify it, we’ll be using a JavaScript syntax highlighting library on our site, like [Prism.js](https://prismjs.com/). To get syntax highlighting for above snippet in Prism, `Prism.highlightElem(pre)` is called, which examines the contents of such `pre` elements and adds special tags and styles for colored syntax highlighting into those elements, similar to what you see in examples here, on this page.

When exactly should we run that highlighting method? Well, we can do it on `DOMContentLoaded` event, or put the script at the bottom of the page. The moment our DOM is ready, we can search for elements `pre[class*="language"]` and call `Prism.highlightElem` on them:

    // highlight all code snippets on the page
    document.querySelectorAll('pre[class*="language"]').forEach(Prism.highlightElem);

Everything’s simple so far, right? We find code snippets in HTML and highlight them.

Now let’s go on. Let’s say we’re going to dynamically fetch materials from a server. We’ll study methods for that [later in the tutorial](info:fetch). For now it only matters that we fetch an HTML article from a webserver and display it on demand:

    let article = /* fetch new content from server */
    articleElem.innerHTML = article;

The new `article` HTML may contain code snippets. We need to call `Prism.highlightElem` on them, otherwise they won’t get highlighted.

**Where and when to call `Prism.highlightElem` for a dynamically loaded article?**

We could append that call to the code that loads an article, like this:

    let article = /* fetch new content from server */
    articleElem.innerHTML = article;

    *!*
    let snippets = articleElem.querySelectorAll('pre[class*="language-"]');
    snippets.forEach(Prism.highlightElem);
    */!*

…But, imagine if we have many places in the code where we load our content - articles, quizzes, forum posts, etc. Do we need to put the highlighting call everywhere, to highlight the code in content after loading? That’s not very convenient.

And what if the content is loaded by a third-party module? For example, we have a forum written by someone else, that loads content dynamically, and we’d like to add syntax highlighting to it. No one likes patching third-party scripts.

Luckily, there’s another option.

We can use `MutationObserver` to automatically detect when code snippets are inserted into the page and highlight them.

So we’ll handle the highlighting functionality in one place, relieving us from the need to integrate it.

### Dynamic highlight demo

Here’s the working example.

If you run this code, it starts observing the element below and highlighting any code snippets that appear there:

\`\`\`js run let observer = new MutationObserver(mutations =&gt; {

for(let mutation of mutations) { // examine new nodes, is there anything to highlight?

    for(let node of mutation.addedNodes) {
      // we track only elements, skip other nodes (e.g. text nodes)
      if (!(node instanceof HTMLElement)) continue;

      // check the inserted element for being a code snippet
      if (node.matches('pre[class*="language-"]')) {
        Prism.highlightElement(node);
      }

      // or maybe there's a code snippet somewhere in its subtree?
      for(let elem of node.querySelectorAll('pre[class*="language-"]')) {
        Prism.highlightElement(elem);
      }
    }

}

});

let demoElem = document.getElementById(‘highlight-demo’);

observer.observe(demoElem, {childList: true, subtree: true}); \`\`\`

Here, below, there’s an HTML-element and JavaScript that dynamically fills it using `innerHTML`.

Please run the previous code (above, observes that element), and then the code below. You’ll see how `MutationObserver` detects and highlights the snippet.

A demo-element with `id=“highlight-demo”`, run the code above to observe it.

The following code populates its `innerHTML`, that causes the `MutationObserver` to react and highlight its contents:

\`\`\`js run let demoElem = document.getElementById(‘highlight-demo’);

// dynamically insert content with code snippets demoElem.innerHTML = `A code snippet is below: <pre class="language-javascript"><code> let hello = "world!"; </code></pre> <div>Another one:</div> <div> <pre class="language-css"><code>.class { margin: 5px; } </code></pre> </div>`; \`\`\`

Now we have `MutationObserver` that can track all highlighting in observed elements or the whole `document`. We can add/remove code snippets in HTML without thinking about it.

## Additional methods

There’s a method to stop observing the node:

- `observer.disconnect()` – stops the observation.

When we stop the observing, it might be possible that some changes were not yet processed by the observer. In such cases, we use

- `observer.takeRecords()` – gets a list of unprocessed mutation records - those that happened, but the callback has not handled them.

These methods can be used together, like this:

    // get a list of unprocessed mutations
    // should be called before disconnecting,
    // if you care about possibly unhandled recent mutations
    let mutationRecords = observer.takeRecords();

    // stop tracking changes
    observer.disconnect();
    ...

`` smart header="Records returned by `observer.takeRecords()` are removed from the processing queue" The callback won't be called for records, returned by `observer.takeRecords()`. ``

\`\`\`smart header=“Garbage collection interaction” Observers use weak references to nodes internally. That is, if a node is removed from the DOM, and becomes unreachable, then it can be garbage collected.

The mere fact that a DOM node is observed doesn’t prevent the garbage collection. \`\`\`

## Summary

`MutationObserver` can react to changes in DOM - attributes, text content and adding/removing elements.

We can use it to track changes introduced by other parts of our code, as well as to integrate with third-party scripts.

`MutationObserver` can track any changes. The config “what to observe” options are used for optimizations, not to spend resources on unneeded callback invocations. libs: - d3 - domtree

---

# Selection and Range

In this chapter we’ll cover selection in the document, as well as selection in form fields, such as `<input>`.

JavaScript can access an existing selection, select/deselect DOM nodes as a whole or partially, remove the selected content from the document, wrap it into a tag, and so on.

You can find some recipes for common tasks at the end of the chapter, in “Summary” section. Maybe that covers your current needs, but you’ll get much more if you read the whole text.

The underlying `Range` and `Selection` objects are easy to grasp, and then you’ll need no recipes to make them do what you want.

## Range

The basic concept of selection is [Range](https://dom.spec.whatwg.org/#ranges), that is essentially a pair of “boundary points”: range start and range end.

A `Range` object is created without parameters:

    let range = new Range();

Then we can set the selection boundaries using `range.setStart(node, offset)` and `range.setEnd(node, offset)`.

As you might guess, further we’ll use the `Range` objects for selection, but first let’s create few such objects.

### Selecting the text partially

The interesting thing is that the first argument `node` in both methods can be either a text node or an element node, and the meaning of the second argument depends on that.

**If `node` is a text node, then `offset` must be the position in its text.**

For example, given the element `<p>Hello</p>`, we can create the range containing the letters “ll” as follows:

\`\`\`html run

Hello

\`\`\`

Here we take the first child of `<p>` (that’s the text node) and specify the text positions inside it:

![](range-hello-1.svg)

### Selecting element nodes

**Alternatively, if `node` is an element node, then `offset` must be the child number.**

That’s handy for making ranges that contain nodes as a whole, not stop somewhere inside their text.

For example, we have a more complex document fragment:

`html autorun <p id="p">Example: <i>italic</i> and <b>bold</b></p>`

Here’s its DOM structure with both element and text nodes:

Let’s make a range for `"Example: <i>italic</i>"`.

As we can see, this phrase consists of exactly two children of `<p>`, with indexes `0` and `1`:

![](range-example-p-0-1.svg)

- The starting point has `<p>` as the parent `node`, and `0` as the offset.

  So we can set it as `range.setStart(p, 0)`.

- The ending point also has `<p>` as the parent `node`, but `2` as the offset (it specifies the range up to, but not including `offset`).

  So we can set it as `range.setEnd(p, 2)`.

Here’s the demo. If you run it, you can see that the text gets selected:

\`\`\`html run

Example: _italic_ and **bold**

\`\`\`

Here’s a more flexible test stand where you can set range start/end numbers and explore other variants:

\`\`\`html run autorun

Example: _italic_ and **bold**

From – To

Click to select

\`\`\`

E.g. selecting in the same `<p>` from offset `1` to `4` gives us the range `<i>italic</i> and <b>bold</b>`:

![](range-example-p-1-3.svg)

`` smart header="Starting and ending nodes can be different" We don't have to use the same node in `setStart` and `setEnd`. A range may span across many unrelated nodes. It's only important that the end is after the start in the document. ``

### Selecting a bigger fragment

Let’s make a bigger selection in our example, like this:

![](range-example-p-2-b-3.svg)

We already know how to do that. We just need to set the start and the end as a relative offset in text nodes.

We need to create a range, that: - starts from position 2 in `<p>` first child (taking all but two first letters of “Ex**ample:**”) - ends at the position 3 in `<b>` first child (taking first three letters of “**bol**d”, but no more):

\`\`\`html run

Example: _italic_ and **bold**

\`\`\`

As you can see, it’s fairly easy to make a range of whatever we want.

If we’d like to take nodes as a whole, we can pass elements in `setStart/setEnd`. Otherwise, we can work on the text level.

## Range properties

The range object that we created in the example above has following properties:

![](range-example-p-2-b-3-range.svg)

- `startContainer`, `startOffset` – node and offset of the start,
  - in the example above: first text node inside `<p>` and `2`.
- `endContainer`, `endOffset` – node and offset of the end,
  - in the example above: first text node inside `<b>` and `3`.
- `collapsed` – boolean, `true` if the range starts and ends on the same point (so there’s no content inside the range),
  - in the example above: `false`
- `commonAncestorContainer` – the nearest common ancestor of all nodes within the range,
  - in the example above: `<p>`

## Range selection methods

There are many convenience methods to manipulate ranges.

We’ve already seen `setStart` and `setEnd`, here are other similar methods.

Set range start:

- `setStart(node, offset)` set start at: position `offset` in `node`
- `setStartBefore(node)` set start at: right before `node`
- `setStartAfter(node)` set start at: right after `node`

Set range end (similar methods):

- `setEnd(node, offset)` set end at: position `offset` in `node`
- `setEndBefore(node)` set end at: right before `node`
- `setEndAfter(node)` set end at: right after `node`

Technically, `setStart/setEnd` can do anything, but more methods provide more convenience.

In all these methods, `node` can be both a text or element node: for text nodes `offset` skips that many of characters, while for element nodes that many child nodes.

Even more methods to create ranges: - `selectNode(node)` set range to select the whole `node` - `selectNodeContents(node)` set range to select the whole `node` contents - `collapse(toStart)` if `toStart=true` set end=start, otherwise set start=end, thus collapsing the range - `cloneRange()` creates a new range with the same start/end

## Range editing methods

Once the range is created, we can manipulate its content using these methods:

- `deleteContents()` – remove range content from the document
- `extractContents()` – remove range content from the document and return as [DocumentFragment](info:modifying-document#document-fragment)
- `cloneContents()` – clone range content and return as [DocumentFragment](info:modifying-document#document-fragment)
- `insertNode(node)` – insert `node` into the document at the beginning of the range
- `surroundContents(node)` – wrap `node` around range content. For this to work, the range must contain both opening and closing tags for all elements inside it: no partial ranges like `<i>abc`.

With these methods we can do basically anything with selected nodes.

Here’s the test stand to see them in action:

\`\`\`html run refresh autorun height=260 Click buttons to run methods on the selection, “resetExample” to reset it.

Example: _italic_ and **bold**

\`\`\`

There also exist methods to compare ranges, but these are rarely used. When you need them, please refer to the [spec](https://dom.spec.whatwg.org/#interface-range) or [MDN manual](mdn:/api/Range).

## Selection

`Range` is a generic object for managing selection ranges. Although, creating a `Range` doesn’t mean that we see a selection on screen.

We may create `Range` objects, pass them around – they do not visually select anything on their own.

The document selection is represented by `Selection` object, that can be obtained as `window.getSelection()` or `document.getSelection()`. A selection may include zero or more ranges. At least, the [Selection API specification](https://www.w3.org/TR/selection-api/) says so. In practice though, only Firefox allows to select multiple ranges in the document by using `key:Ctrl+click` (`key:Cmd+click` for Mac).

Here’s a screenshot of a selection with 3 ranges, made in Firefox:

![](selection-firefox.svg)

Other browsers support at maximum 1 range. As we’ll see, some of `Selection` methods imply that there may be many ranges, but again, in all browsers except Firefox, there’s at maximum 1.

Here’s a small demo that shows the current selection (select something and click) as text:

alert(document.getSelection())

## Selection properties

As said, a selection may in theory contain multiple ranges. We can get these range objects using the method:

- `getRangeAt(i)` – get i-th range, starting from `0`. In all browsers except Firefox, only `0` is used.

Also, there exist properties that often provide better convenience.

Similar to a range, a selection object has a start, called “anchor”, and the end, called “focus”.

The main selection properties are:

- `anchorNode` – the node where the selection starts,
- `anchorOffset` – the offset in `anchorNode` where the selection starts,
- `focusNode` – the node where the selection ends,
- `focusOffset` – the offset in `focusNode` where the selection ends,
- `isCollapsed` – `true` if selection selects nothing (empty range), or doesn’t exist.
- `rangeCount` – count of ranges in the selection, maximum `1` in all browsers except Firefox.

\`\`\`smart header=“Selection end/start vs Range”

There’s an important differences of a selection anchor/focus compared with a `Range` start/end.

As we know, `Range` objects always have their start before the end.

For selections, that’s not always the case.

Selecting something with a mouse can be done in both directions: either “left-to-right” or “right-to-left”.

In other words, when the mouse button is pressed, and then it moves forward in the document, then its end (focus) will be after its start (anchor).

E.g. if the user starts selecting with mouse and goes from “Example” to “italic”:

![](selection-direction-forward.svg)

…But the same selection could be done backwards: starting from “italic” to “Example” (backward direction), then its end (focus) will be before the start (anchor):

![](selection-direction-backward.svg) \`\`\`

## Selection events

There are events on to keep track of selection:

- `elem.onselectstart` – when a selection _starts_ specifically on element `elem` (or inside it). For instance, when the user presses the mouse button on it and starts to move the pointer.
  - Preventing the default action cancels the selection start. So starting a selection from this element becomes impossible, but the element is still selectable. The visitor just needs to start the selection from elsewhere.
- `document.onselectionchange` – whenever a selection changes or starts.
  - Please note: this handler can be set only on `document`, it tracks all selections in it.

### Selection tracking demo

Here’s a small demo. It tracks the current selection on the `document` and shows its boundaries:

\`\`\`html run height=80

Select me: _italic_ and **bold**

From – To

\`\`\`

### Selection copying demo

There are two approaches to copying the selected content:

1.  We can use `document.getSelection().toString()` to get it as text.
2.  Otherwise, to copy the full DOM, e.g. if we need to keep formatting, we can get the underlying ranges with `getRangesAt(...)`. A `Range` object, in turn, has `cloneContents()` method that clones its content and returns as `DocumentFragment` object, that we can insert elsewhere.

Here’s the demo of copying the selected content both as text and as DOM nodes:

\`\`\`html run height=100

Select me: _italic_ and **bold**

Cloned: <span id="cloned"></span>  
As text: <span id="astext"></span>

\`\`\`

## Selection methods

We can work with the selection by addding/removing ranges:

- `getRangeAt(i)` – get i-th range, starting from `0`. In all browsers except Firefox, only `0` is used.
- `addRange(range)` – add `range` to selection. All browsers except Firefox ignore the call, if the selection already has an associated range.
- `removeRange(range)` – remove `range` from the selection.
- `removeAllRanges()` – remove all ranges.
- `empty()` – alias to `removeAllRanges`.

There are also convenience methods to manipulate the selection range directly, without intermediate `Range` calls:

- `collapse(node, offset)` – replace selected range with a new one that starts and ends at the given `node`, at position `offset`.
- `setPosition(node, offset)` – alias to `collapse`.
- `collapseToStart()` - collapse (replace with an empty range) to selection start,
- `collapseToEnd()` - collapse to selection end,
- `extend(node, offset)` - move focus of the selection to the given `node`, position `offset`,
- `setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset)` - replace selection range with the given start `anchorNode/anchorOffset` and end `focusNode/focusOffset`. All content in-between them is selected.
- `selectAllChildren(node)` – select all children of the `node`.
- `deleteFromDocument()` – remove selected content from the document.
- `containsNode(node, allowPartialContainment = false)` – checks whether the selection contains `node` (partially if the second argument is `true`)

For most tasks these methods are just fine, there’s no need to access the underlying `Range` object.

For example, selecting the whole contents of the paragraph `<p>`:

\`\`\`html run

Select me: _italic_ and **bold**

\`\`\`

The same thing using ranges:

\`\`\`html run

Select me: _italic_ and **bold**

\`\`\`

\`\``smart header="To select something, remove the existing selection first" If a document selection already exists, empty it first with`removeAllRanges()\`. And then add ranges. Otherwise, all browsers except Firefox ignore new ranges.

The exception is some selection methods, that replace the existing selection, such as `setBaseAndExtent`. \`\`\`

## Selection in form controls

Form elements, such as `input` and `textarea` provide [special API for selection](https://html.spec.whatwg.org/#textFieldSelection), without `Selection` or `Range` objects. As an input value is a pure text, not HTML, there’s no need for such objects, everything’s much simpler.

Properties: - `input.selectionStart` – position of selection start (writeable), - `input.selectionEnd` – position of selection end (writeable), - `input.selectionDirection` – selection direction, one of: “forward”, “backward” or “none” (if e.g. selected with a double mouse click),

Events: - `input.onselect` – triggers when something is selected.

Methods:

- `input.select()` – selects everything in the text control (can be `textarea` instead of `input`),
- `input.setSelectionRange(start, end, [direction])` – change the selection to span from position `start` till `end`, in the given direction (optional).
- `input.setRangeText(replacement, [start], [end], [selectionMode])` – replace a range of text with the new text.

  Optional arguments `start` and `end`, if provided, set the range start and end, otherwise user selection is used.

  The last argument, `selectionMode`, determines how the selection will be set after the text has been replaced. The possible values are:

  - `"select"` – the newly inserted text will be selected.
  - `"start"` – the selection range collapses just before the inserted text (the cursor will be immediately before it).
  - `"end"` – the selection range collapses just after the inserted text (the cursor will be right after it).
  - `"preserve"` – attempts to preserve the selection. This is the default.

Now let’s see these methods in action.

### Example: tracking selection

For example, this code uses `onselect` event to track selection:

\`\`\`html run autorun

Selecting in this text updates values below.

From – To

\`\`\`

Please note: - `onselect` triggers when something is selected, but not when the selection is removed. - `document.onselectionchange` event should not trigger for selections inside a form control, according to the [spec](https://w3c.github.io/selection-api/#dfn-selectionchange), as it’s not related to `document` selection and ranges. Some browsers generate it, but we shouldn’t rely on it.

### Example: moving cursor

We can change `selectionStart` and `selectionEnd`, that sets the selection.

An important edge case is when `selectionStart` and `selectionEnd` equal each other. Then it’s exactly the cursor position. Or, to rephrase, when nothing is selected, the selection is collapsed at the cursor position.

So, by setting `selectionStart` and `selectionEnd` to the same value, we move the cursor.

For example:

\`\`\`html run autorun

Focus on me, the cursor will be at position 10.

\`\`\`

### Example: modifying selection

To modify the content of the selection, we can use `input.setRangeText()` method. Of course, we can read `selectionStart/End` and, with the knowledge of the selection, change the corresponding substring of `value`, but `setRangeText` is more powerful and often more convenient.

That’s a somewhat complex method. In its simplest one-argument form it replaces the user selected range and removes the selection.

For example, here the user selection will be wrapped by `*...*`:

\`\`\`html run autorun Wrap selection in stars _…_

\`\`\`

With more arguments, we can set range `start` and `end`.

In this example we find `"THIS"` in the input text, replace it and keep the replacement selected:

\`\`\`html run autorun Replace THIS

\`\`\`

### Example: insert at cursor

If nothing is selected, or we use equal `start` and `end` in `setRangeText`, then the new text is just inserted, nothing is removed.

We can also insert something “at the cursor” using `setRangeText`.

Here’s a button that inserts `"HELLO"` at the cursor position and puts the cursor immediately after it. If the selection is not empty, then it gets replaced (we can detect it by comparing `selectionStart!=selectionEnd` and do something else instead):

\`\`\`html run autorun Insert “HELLO” at cursor

\`\`\`

## Making unselectable

To make something unselectable, there are three ways:

1.  Use CSS property `user-select: none`.

    `html run <style> #elem { user-select: none; } </style> <div>Selectable <div id="elem">Unselectable</div> Selectable</div>`

    This doesn’t allow the selection to start at `elem`. But the user may start the selection elsewhere and include `elem` into it.

    Then `elem` will become a part of `document.getSelection()`, so the selection actually happens, but its content is usually ignored in copy-paste.

2.  Prevent default action in `onselectstart` or `mousedown` events.

    \`\`\`html run

    Selectable
    Unselectable

    Selectable

    \`\`\`

    This prevents starting the selection on `elem`, but the visitor may start it at another element, then extend to `elem`.

    That’s convenient when there’s another event handler on the same action that triggers the select (e.g. `mousedown`). So we disable the selection to avoid conflict, still allowing `elem` contents to be copied.

3.  We can also clear the selection post-factum after it happens with `document.getSelection().empty()`. That’s rarely used, as this causes unwanted blinking as the selection appears-disappears.

## References

- [DOM spec: Range](https://dom.spec.whatwg.org/#ranges)
- [Selection API](https://www.w3.org/TR/selection-api/#dom-globaleventhandlers-onselectstart)
- [HTML spec: APIs for the text control selections](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#textFieldSelection)

## Summary

We covered two different APIs for selections:

1.  For document: `Selection` and `Range` objects.
2.  For `input`, `textarea`: additional methods and properties.

The second API is very simple, as it works with text.

The most used recipes are probably:

1.  Getting the selection: \`\`\`js let selection = document.getSelection();

    let cloned = /\* element to clone the selected nodes to \*/;

    // then apply Range methods to selection.getRangeAt(0) // or, like here, to all ranges to support multi-select for (let i = 0; i &lt; selection.rangeCount; i++) { cloned.append(selection.getRangeAt(i).cloneContents()); } \`\`\`

2.  Setting the selection: \`\`\`js let selection = document.getSelection();

    // directly: selection.setBaseAndExtent(…from…to…);

    // or we can create a range and: selection.removeAllRanges(); selection.addRange(range); \`\`\`

And finally, about the cursor. The cursor position in editable elements, like `<textarea>` is always at the start or the end of the selection. We can use it to get cursor position or to move the cursor by setting `elem.selectionStart` and `elem.selectionEnd`.

# Event loop: microtasks and macrotasks

Browser JavaScript execution flow, as well as in Node.js, is based on an _event loop_.

Understanding how event loop works is important for optimizations, and sometimes for the right architecture.

In this chapter we first cover theoretical details about how things work, and then see practical applications of that knowledge.

## Event Loop

The _event loop_ concept is very simple. There’s an endless loop, where the JavaScript engine waits for tasks, executes them and then sleeps, waiting for more tasks.

The general algorithm of the engine:

1.  While there are tasks:
    - execute them, starting with the oldest task.
2.  Sleep until a task appears, then go to 1.

That’s a formalization for what we see when browsing a page. The JavaScript engine does nothing most of the time, it only runs if a script/handler/event activates.

Examples of tasks:

- When an external script `<script src="...">` loads, the task is to execute it.
- When a user moves their mouse, the task is to dispatch `mousemove` event and execute handlers.
- When the time is due for a scheduled `setTimeout`, the task is to run its callback.
- …and so on.

Tasks are set – the engine handles them – then waits for more tasks (while sleeping and consuming close to zero CPU).

It may happen that a task comes while the engine is busy, then it’s enqueued.

The tasks form a queue, so-called “macrotask queue” (v8 term):

![](eventLoop.svg)

For instance, while the engine is busy executing a `script`, a user may move their mouse causing `mousemove`, and `setTimeout` may be due and so on, these tasks form a queue, as illustrated on the picture above.

Tasks from the queue are processed on “first come – first served” basis. When the engine browser is done with the `script`, it handles `mousemove` event, then `setTimeout` handler, and so on.

So far, quite simple, right?

Two more details: 1. Rendering never happens while the engine executes a task. It doesn’t matter if the task takes a long time. Changes to the DOM are painted only after the task is complete. 2. If a task takes too long, the browser can’t do other tasks, such as processing user events. So after a time, it raises an alert like “Page Unresponsive”, suggesting killing the task with the whole page. That happens when there are a lot of complex calculations or a programming error leading to an infinite loop.

That was the theory. Now let’s see how we can apply that knowledge.

## Use-case 1: splitting CPU-hungry tasks

Let’s say we have a CPU-hungry task.

For example, syntax-highlighting (used to colorize code examples on this page) is quite CPU-heavy. To highlight the code, it performs the analysis, creates many colored elements, adds them to the document – for a large amount of text that takes a lot of time.

While the engine is busy with syntax highlighting, it can’t do other DOM-related stuff, process user events, etc. It may even cause the browser to “hiccup” or even “hang” for a bit, which is unacceptable.

We can avoid problems by splitting the big task into pieces. Highlight first 100 lines, then schedule `setTimeout` (with zero-delay) for the next 100 lines, and so on.

To demonstrate this approach, for the sake of simplicity, instead of text-highlighting, let’s take a function that counts from `1` to `1000000000`.

If you run the code below, the engine will “hang” for some time. For server-side JS that’s clearly noticeable, and if you are running it in-browser, then try to click other buttons on the page – you’ll see that no other events get handled until the counting finishes.

\`\`\`js run let i = 0;

let start = Date.now();

function count() {

// do a heavy job for (let j = 0; j &lt; 1e9; j++) { i++; }

alert(“Done in” + (Date.now() - start) + ‘ms’); }

count(); \`\`\`

The browser may even show a “the script takes too long” warning.

Let’s split the job using nested `setTimeout` calls:

\`\`\`js run let i = 0;

let start = Date.now();

function count() {

// do a piece of the heavy job (\*) do { i++; } while (i % 1e6 != 0);

if (i == 1e9) { alert(“Done in” + (Date.now() - start) + ‘ms’); } else { setTimeout(count); // schedule the new call (\*\*) }

}

count(); \`\`\`

Now the browser interface is fully functional during the “counting” process.

A single run of `count` does a part of the job `(*)`, and then re-schedules itself `(**)` if needed:

1.  First run counts: `i=1...1000000`.
2.  Second run counts: `i=1000001..2000000`.
3.  …and so on.

Now, if a new side task (e.g. `onclick` event) appears while the engine is busy executing part 1, it gets queued and then executes when part 1 finished, before the next part. Periodic returns to the event loop between `count` executions provide just enough “air” for the JavaScript engine to do something else, to react to other user actions.

The notable thing is that both variants – with and without splitting the job by `setTimeout` – are comparable in speed. There’s not much difference in the overall counting time.

To make them closer, let’s make an improvement.

We’ll move the scheduling to the beginning of the `count()`:

\`\`\`js run let i = 0;

let start = Date.now();

function count() {

// move the scheduling to the beginning if (i &lt; 1e9 - 1e6) { setTimeout(count); // schedule the new call }

do { i++; } while (i % 1e6 != 0);

if (i == 1e9) { alert(“Done in” + (Date.now() - start) + ‘ms’); }

}

count(); \`\`\`

Now when we start to `count()` and see that we’ll need to `count()` more, we schedule that immediately, before doing the job.

If you run it, it’s easy to notice that it takes significantly less time.

Why?

That’s simple: as you remember, there’s the in-browser minimal delay of 4ms for many nested `setTimeout` calls. Even if we set `0`, it’s `4ms` (or a bit more). So the earlier we schedule it - the faster it runs.

Finally, we’ve split a CPU-hungry task into parts - now it doesn’t block the user interface. And its overall execution time isn’t much longer.

## Use case 2: progress indication

Another benefit of splitting heavy tasks for browser scripts is that we can show progress indication.

As mentioned earlier, changes to DOM are painted only after the currently running task is completed, irrespective of how long it takes.

On one hand, that’s great, because our function may create many elements, add them one-by-one to the document and change their styles – the visitor won’t see any “intermediate”, unfinished state. An important thing, right?

Here’s the demo, the changes to `i` won’t show up until the function finishes, so we’ll see only the last value:

\`\`\`html run

\`\`\`

…But we also may want to show something during the task, e.g. a progress bar.

If we split the heavy task into pieces using `setTimeout`, then changes are painted out in-between them.

This looks prettier:

\`\`\`html run

\`\`\`

Now the `<div>` shows increasing values of `i`, a kind of a progress bar.

## Use case 3: doing something after the event

In an event handler we may decide to postpone some actions until the event bubbled up and was handled on all levels. We can do that by wrapping the code in zero delay `setTimeout`.

In the chapter <a href="info:dispatch-events" class="uri">info:dispatch-events</a> we saw an example: custom event `menu-open` is dispatched in `setTimeout`, so that it happens after the “click” event is fully handled.

    menu.onclick = function() {
      // ...

      // create a custom event with the clicked menu item data
      let customEvent = new CustomEvent("menu-open", {
        bubbles: true
      });

      // dispatch the custom event asynchronously
      setTimeout(() => menu.dispatchEvent(customEvent));
    };

## Macrotasks and Microtasks

Along with _macrotasks_, described in this chapter, there are _microtasks_, mentioned in the chapter <a href="info:microtask-queue" class="uri">info:microtask-queue</a>.

Microtasks come solely from our code. They are usually created by promises: an execution of `.then/catch/finally` handler becomes a microtask. Microtasks are used “under the cover” of `await` as well, as it’s another form of promise handling.

There’s also a special function `queueMicrotask(func)` that queues `func` for execution in the microtask queue.

**Immediately after every _macrotask_, the engine executes all tasks from _microtask_ queue, prior to running any other macrotasks or rendering or anything else.**

For instance, take a look:

\`\`\`js run setTimeout(() =&gt; alert(“timeout”));

Promise.resolve() .then(() =&gt; alert(“promise”));

alert(“code”); \`\`\`

What’s going to be the order here?

1.  `code` shows first, because it’s a regular synchronous call.
2.  `promise` shows second, because `.then` passes through the microtask queue, and runs after the current code.
3.  `timeout` shows last, because it’s a macrotask.

The richer event loop picture looks like this (order is from top to bottom, that is: the script first, then microtasks, rendering and so on):

![](eventLoop-full.svg)

All microtasks are completed before any other event handling or rendering or any other macrotask takes place.

That’s important, as it guarantees that the application environment is basically the same (no mouse coordinate changes, no new network data, etc) between microtasks.

If we’d like to execute a function asynchronously (after the current code), but before changes are rendered or new events handled, we can schedule it with `queueMicrotask`.

Here’s an example with “counting progress bar”, similar to the one shown previously, but `queueMicrotask` is used instead of `setTimeout`. You can see that it renders at the very end. Just like the synchronous code:

\`\`\`html run

\`\`\`

## Summary

A more detailed event loop algorithm (though still simplified compared to the [specification](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model)):

1.  Dequeue and run the oldest task from the _macrotask_ queue (e.g. “script”).
2.  Execute all _microtasks_:
    - While the microtask queue is not empty:
      - Dequeue and run the oldest microtask.
3.  Render changes if any.
4.  If the macrotask queue is empty, wait till a macrotask appears.
5.  Go to step 1.

To schedule a new _macrotask_: - Use zero delayed `setTimeout(f)`.

That may be used to split a big calculation-heavy task into pieces, for the browser to be able to react to user events and show progress between them.

Also, used in event handlers to schedule an action after the event is fully handled (bubbling done).

To schedule a new _microtask_ - Use `queueMicrotask(f)`. - Also promise handlers go through the microtask queue.

There’s no UI or network event handling between microtasks: they run immediately one after another.

So one may want to `queueMicrotask` to execute a function asynchronously, but within the environment state.

\`\`\`smart header=“Web Workers” For long heavy calculations that shouldn’t block the event loop, we can use [Web Workers](https://html.spec.whatwg.org/multipage/workers.html).

That’s a way to run code in another, parallel thread.

Web Workers can exchange messages with the main process, but they have their own variables, and their own event loop.

Web Workers do not have access to DOM, so they are useful, mainly, for calculations, to use multiple CPU cores simultaneously. \`\`\` \# Popups and window methods

A popup window is one of the oldest methods to show additional document to user.

Basically, you just run:

    window.open('https://javascript.info/')

…And it will open a new window with given URL. Most modern browsers are configured to open url in new tabs instead of separate windows.

Popups exist from really ancient times. The initial idea was to show another content without closing the main window. As of now, there are other ways to do that: we can load content dynamically with [fetch](info:fetch) and show it in a dynamically generated `<div>`. So, popups is not something we use everyday.

Also, popups are tricky on mobile devices, that don’t show multiple windows simultaneously.

1.  A popup is a separate window which has its own independent JavaScript environment. So opening a popup from a third-party, non-trusted site is safe.
2.  It’s very easy to open a popup.
3.  A popup can navigate (change URL) and send messages to the opener window.

## Popup blocking

In the past, evil sites abused popups a lot. A bad page could open tons of popup windows with ads. So now most browsers try to block popups and protect the user.

**Most browsers block popups if they are called outside of user-triggered event handlers like `onclick`.**

For example:

    // popup blocked
    window.open('https://javascript.info');

    // popup allowed
    button.onclick = () => {
      window.open('https://javascript.info');
    };

This way users are somewhat protected from unwanted popups, but the functionality is not disabled totally.

What if the popup opens from `onclick`, but after `setTimeout`? That’s a bit tricky.

Try this code:

`js run // open after 3 seconds setTimeout(() => window.open('http://google.com'), 3000);`

The popup opens in Chrome, but gets blocked in Firefox.

…If we decrease the delay, the popup works in Firefox too:

`js run // open after 1 seconds setTimeout(() => window.open('http://google.com'), 1000);`

The difference is that Firefox treats a timeout of 2000ms or less are acceptable, but after it – removes the “trust”, assuming that now it’s “outside of the user action”. So the first one is blocked, and the second one is not.

## window.open

The syntax to open a popup is: `window.open(url, name, params)`:

url  
An URL to load into the new window.

name  
A name of the new window. Each window has a `window.name`, and here we can specify which window to use for the popup. If there’s already a window with such name – the given URL opens in it, otherwise a new window is opened.

params  
The configuration string for the new window. It contains settings, delimited by a comma. There must be no spaces in params, for instance: `width=200,height=100`.

Settings for `params`:

- Position:
  - `left/top` (numeric) – coordinates of the window top-left corner on the screen. There is a limitation: a new window cannot be positioned offscreen.
  - `width/height` (numeric) – width and height of a new window. There is a limit on minimal width/height, so it’s impossible to create an invisible window.
- Window features:
  - `menubar` (yes/no) – shows or hides the browser menu on the new window.
  - `toolbar` (yes/no) – shows or hides the browser navigation bar (back, forward, reload etc) on the new window.
  - `location` (yes/no) – shows or hides the URL field in the new window. FF and IE don’t allow to hide it by default.
  - `status` (yes/no) – shows or hides the status bar. Again, most browsers force it to show.
  - `resizable` (yes/no) – allows to disable the resize for the new window. Not recommended.
  - `scrollbars` (yes/no) – allows to disable the scrollbars for the new window. Not recommended.

There is also a number of less supported browser-specific features, which are usually not used. Check [window.open in MDN](https://developer.mozilla.org/en/DOM/window.open) for examples.

## Example: a minimalistic window

Let’s open a window with minimal set of features, just to see which of them browser allows to disable:

\`\``js run let params =`scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no, width=0,height=0,left=-1000,top=-1000\`;

open(‘/’, ‘test’, params); \`\`\`

Here most “window features” are disabled and window is positioned offscreen. Run it and see what really happens. Most browsers “fix” odd things like zero `width/height` and offscreen `left/top`. For instance, Chrome open such a window with full width/height, so that it occupies the full screen.

Let’s add normal positioning options and reasonable `width`, `height`, `left`, `top` coordinates:

\`\``js run let params =`scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no, width=600,height=300,left=100,top=100\`;

open(‘/’, ‘test’, params); \`\`\`

Most browsers show the example above as required.

Rules for omitted settings:

- If there is no 3rd argument in the `open` call, or it is empty, then the default window parameters are used.
- If there is a string of params, but some `yes/no` features are omitted, then the omitted features assumed to have `no` value. So if you specify params, make sure you explicitly set all required features to yes.
- If there is no `left/top` in params, then the browser tries to open a new window near the last opened window.
- If there is no `width/height`, then the new window will be the same size as the last opened.

## Accessing popup from window

The `open` call returns a reference to the new window. It can be used to manipulate it’s properties, change location and even more.

In this example, we generate popup content from JavaScript:

    let newWin = window.open("about:blank", "hello", "width=200,height=200");

    newWin.document.write("Hello, world!");

And here we modify the contents after loading:

\`\`\`js run let newWindow = open(‘/’, ‘example’, ‘width=300,height=300’) newWindow.focus();

alert(newWindow.location.href); // (\*) about:blank, loading hasn’t started yet

newWindow.onload = function() { let html = `<div style="font-size:30px">Welcome!</div>`; _!_ newWindow.document.body.insertAdjacentHTML(‘afterbegin’, html); _/!_ }; \`\`\`

Please note: immediately after `window.open`, the new window isn’t loaded yet. That’s demonstrated by `alert` in line `(*)`. So we wait for `onload` to modify it. We could also use `DOMContentLoaded` handler for `newWin.document`.

\`\`\`warn header=“Same origin policy” Windows may freely access content of each other only if they come from the same origin (the same protocol://domain:port).

Otherwise, e.g. if the main window is from `site.com`, and the popup from `gmail.com`, that’s impossible for user safety reasons. For the details, see chapter <a href="info:cross-window-communication" class="uri">info:cross-window-communication</a>. \`\`\`

## Accessing window from popup

A popup may access the “opener” window as well using `window.opener` reference. It is `null` for all windows except popups.

If you run the code below, it replaces the opener (current) window content with “Test”:

\`\`\`js run let newWin = window.open(“about:blank”, “hello”, “width=200,height=200”);

newWin.document.write( "

\`\`\`

The code above shows errors for any operations except:

- Getting the reference to the inner window `iframe.contentWindow` - that’s allowed.
- Writing to `location`.

Contrary to that, if the `<iframe>` has the same origin, we can do anything with it:

\`\`\`html run

\`\`\`

\`\``smart header="`iframe.onload`vs`iframe.contentWindow.onload`" The`iframe.onload` event (on the``tag) is essentially the same as `iframe.contentWindow.onload\` (on the embedded window object). It triggers when the embedded window fully loads with all resources.

…But we can’t access `iframe.contentWindow.onload` for an iframe from another origin, so using `iframe.onload`. \`\`\`

## Windows on subdomains: document.domain

By definition, two URLs with different domains have different origins.

But if windows share the same second-level domain, for instance `john.site.com`, `peter.site.com` and `site.com` (so that their common second-level domain is `site.com`), we can make the browser ignore that difference, so that they can be treated as coming from the “same origin” for the purposes of cross-window communication.

To make it work, each such window should run the code:

    document.domain = 'site.com';

That’s all. Now they can interact without limitations. Again, that’s only possible for pages with the same second-level domain.

## Iframe: wrong document pitfall

When an iframe comes from the same origin, and we may access its `document`, there’s a pitfall. It’s not related to cross-origin things, but important to know.

Upon its creation an iframe immediately has a document. But that document is different from the one that loads into it!

So if we do something with the document immediately, that will probably be lost.

Here, look:

\`\`\`html run

\`\`\`

We shouldn’t work with the document of a not-yet-loaded iframe, because that’s the _wrong document_. If we set any event handlers on it, they will be ignored.

How to detect the moment when the document is there?

The right document is definitely at place when `iframe.onload` triggers. But it only triggers when the whole iframe with all resources is loaded.

We can try to catch the moment earlier using checks in `setInterval`:

\`\`\`html run

\`\`\`

## Collection: window.frames

An alternative way to get a window object for `<iframe>` – is to get it from the named collection `window.frames`:

- By number: `window.frames[0]` – the window object for the first frame in the document.
- By name: `window.frames.iframeName` – the window object for the frame with `name="iframeName"`.

For instance:

\`\`\`html run

\`\`\`

An iframe may have other iframes inside. The corresponding `window` objects form a hierarchy.

Navigation links are:

- `window.frames` – the collection of “children” windows (for nested frames).
- `window.parent` – the reference to the “parent” (outer) window.
- `window.top` – the reference to the topmost parent window.

For instance:

`js run window.frames[0].parent === window; // true`

We can use the `top` property to check if the current document is open inside a frame or not:

`js run if (window == top) { // current window == window.top? alert('The script is in the topmost window, not in a frame'); } else { alert('The script runs in a frame!'); }`

## The “sandbox” iframe attribute

The `sandbox` attribute allows for the exclusion of certain actions inside an `<iframe>` in order to prevent it executing untrusted code. It “sandboxes” the iframe by treating it as coming from another origin and/or applying other limitations.

There’s a “default set” of restrictions applied for `<iframe sandbox src="...">`. But it can be relaxed if we provide a space-separated list of restrictions that should not be applied as a value of the attribute, like this: `<iframe sandbox="allow-forms allow-popups">`.

In other words, an empty `"sandbox"` attribute puts the strictest limitations possible, but we can put a space-delimited list of those that we want to lift.

Here’s a list of limitations:

`allow-same-origin`  
By default `"sandbox"` forces the “different origin” policy for the iframe. In other words, it makes the browser to treat the `iframe` as coming from another origin, even if its `src` points to the same site. With all implied restrictions for scripts. This option removes that feature.

`allow-top-navigation`  
Allows the `iframe` to change `parent.location`.

`allow-forms`  
Allows to submit forms from `iframe`.

`allow-scripts`  
Allows to run scripts from the `iframe`.

`allow-popups`  
Allows to `window.open` popups from the `iframe`

See [the manual](mdn:/HTML/Element/iframe) for more.

The example below demonstrates a sandboxed iframe with the default set of restrictions: `<iframe sandbox src="...">`. It has some JavaScript and a form.

Please note that nothing works. So the default set is really harsh:

\[codetabs src=“sandbox” height=140\]

    The purpose of the `"sandbox"` attribute is only to *add more* restrictions. It cannot remove them. In particular, it can't relax same-origin restrictions if the iframe comes from another origin.

## Cross-window messaging

The `postMessage` interface allows windows to talk to each other no matter which origin they are from.

So, it’s a way around the “Same Origin” policy. It allows a window from `john-smith.com` to talk to `gmail.com` and exchange information, but only if they both agree and call corresponding JavaScript functions. That makes it safe for users.

The interface has two parts.

### postMessage

The window that wants to send a message calls [postMessage](mdn:api/Window.postMessage) method of the receiving window. In other words, if we want to send the message to `win`, we should call `win.postMessage(data, targetOrigin)`.

Arguments:

`data`  
The data to send. Can be any object, the data is cloned using the “structured serialization algorithm”. IE supports only strings, so we should `JSON.stringify` complex objects to support that browser.

`targetOrigin`  
Specifies the origin for the target window, so that only a window from the given origin will get the message.

The `targetOrigin` is a safety measure. Remember, if the target window comes from another origin, we can’t read it’s `location` in the sender window. So we can’t be sure which site is open in the intended window right now: the user could navigate away, and the sender window has no idea about it.

Specifying `targetOrigin` ensures that the window only receives the data if it’s still at the right site. Important when the data is sensitive.

For instance, here `win` will only receive the message if it has a document from the origin `http://example.com`:

\`\`\`html no-beautify

\`\`\`

If we don’t want that check, we can set `targetOrigin` to `*`.

\`\`\`html no-beautify

\`\`\`

### onmessage

To receive a message, the target window should have a handler on the `message` event. It triggers when `postMessage` is called (and `targetOrigin` check is successful).

The event object has special properties:

`data`  
The data from `postMessage`.

`origin`  
The origin of the sender, for instance `http://javascript.info`.

`source`  
The reference to the sender window. We can immediately `source.postMessage(...)` back if we want.

To assign that handler, we should use `addEventListener`, a short syntax `window.onmessage` does not work.

Here’s an example:

    window.addEventListener("message", function(event) {
      if (event.origin != 'http://javascript.info') {
        // something from an unknown domain, let's ignore it
        return;
      }

      alert( "received: " + event.data );

      // can message back using event.source.postMessage(...)
    });

The full example:

\[codetabs src=“postmessage” height=120\]

## Summary

To call methods and access the content of another window, we should first have a reference to it.

For popups we have these references: - From the opener window: `window.open` – opens a new window and returns a reference to it, - From the popup: `window.opener` – is a reference to the opener window from a popup.

For iframes, we can access parent/children windows using: - `window.frames` – a collection of nested window objects, - `window.parent`, `window.top` are the references to parent and top windows, - `iframe.contentWindow` is the window inside an `<iframe>` tag.

If windows share the same origin (host, port, protocol), then windows can do whatever they want with each other.

Otherwise, only possible actions are: - Change the `location` of another window (write-only access). - Post a message to it.

Exceptions are: - Windows that share the same second-level domain: `a.site.com` and `b.site.com`. Then setting `document.domain='site.com'` in both of them puts them into the “same origin” state. - If an iframe has a `sandbox` attribute, it is forcefully put into the “different origin” state, unless the `allow-same-origin` is specified in the attribute value. That can be used to run untrusted code in iframes from the same site.

The `postMessage` interface allows two windows with any origins to talk:

1.  The sender calls `targetWin.postMessage(data, targetOrigin)`.
2.  If `targetOrigin` is not `'*'`, then the browser checks if window `targetWin` has the origin `targetOrigin`.
3.  If it is so, then `targetWin` triggers the `message` event with special properties:

    - `origin` – the origin of the sender window (like `http://my.site.com`)
    - `source` – the reference to the sender window.
    - `data` – the data, any object in everywhere except IE that supports only strings.

    We should use `addEventListener` to set the handler for this event inside the target window. \# The clickjacking attack

The “clickjacking” attack allows an evil page to click on a “victim site” _on behalf of the visitor_.

Many sites were hacked this way, including Twitter, Facebook, Paypal and other sites. They have all been fixed, of course.

## The idea

The idea is very simple.

Here’s how clickjacking was done with Facebook:

1.  A visitor is lured to the evil page. It doesn’t matter how.
2.  The page has a harmless-looking link on it (like “get rich now” or “click here, very funny”).
3.  Over that link the evil page positions a transparent `<iframe>` with `src` from facebook.com, in such a way that the “Like” button is right above that link. Usually that’s done with `z-index`.
4.  In attempting to click the link, the visitor in fact clicks the button.

## The demo

Here’s how the evil page looks. To make things clear, the `<iframe>` is half-transparent (in real evil pages it’s fully transparent):

\`\`\`html run height=120 no-beautify

Click to get rich now:

_!_

Click here!

_/!_

…And you’re cool (I’m a cool hacker actually)!

\`\`\`

The full demo of the attack:

\[codetabs src=“clickjacking-visible” height=160\]

Here we have a half-transparent `<iframe src="facebook.html">`, and in the example we can see it hovering over the button. A click on the button actually clicks on the iframe, but that’s not visible to the user, because the iframe is transparent.

Here’s the same example, but closer to reality, with `opacity:0` for `<iframe>`:

\[codetabs src=“clickjacking” height=160\]

All we need to attack – is to position the `<iframe>` on the evil page in such a way that the button is right over the link. So that when a user clicks the link, they actually click the button. That’s usually doable with CSS.

\`\`\`smart header=“Clickjacking is for clicks, not for keyboard” The attack only affects mouse actions (or similar, like taps on mobile).

Keyboard input is much difficult to redirect. Technically, if we have a text field to hack, then we can position an iframe in such a way that text fields overlap each other. So when a visitor tries to focus on the input they see on the page, they actually focus on the input inside the iframe.

But then there’s a problem. Everything that the visitor types will be hidden, because the iframe is not visible.

People will usually stop typing when they can’t see their new characters printing on the screen. \`\`\`

## Old-school defences (weak)

The oldest defence is a bit of JavaScript which forbids opening the page in a frame (so-called “framebusting”).

That looks like this:

    if (top != window) {
      top.location = window.location;
    }

That is: if the window finds out that it’s not on top, then it automatically makes itself the top.

This not a reliable defence, because there are many ways to hack around it. Let’s cover a few.

### Blocking top-navigation

We can block the transition caused by changing `top.location` in [beforeunload](info:onload-ondomcontentloaded#window.onbeforeunload) event handler.

The top page (enclosing one, belonging to the hacker) sets a preventing handler to it, like this:

    window.onbeforeunload = function() {
      return false;
    };

When the `iframe` tries to change `top.location`, the visitor gets a message asking them whether they want to leave.

In most cases the visitor would answer negatively because they don’t know about the iframe - all they can see is the top page, there’s no reason to leave. So `top.location` won’t change!

In action:

\[codetabs src=“top-location”\]

### Sandbox attribute

One of the things restricted by the `sandbox` attribute is navigation. A sandboxed iframe may not change `top.location`.

So we can add the iframe with `sandbox="allow-scripts allow-forms"`. That would relax the restrictions, permitting scripts and forms. But we omit `allow-top-navigation` so that changing `top.location` is forbidden.

Here’s the code:

    <iframe *!*sandbox="allow-scripts allow-forms"*/!* src="facebook.html"></iframe>

There are other ways to work around that simple protection too.

## X-Frame-Options

The server-side header `X-Frame-Options` can permit or forbid displaying the page inside a frame.

It must be sent exactly as HTTP-header: the browser will ignore it if found in HTML `<meta>` tag. So, `<meta http-equiv="X-Frame-Options"...>` won’t do anything.

The header may have 3 values:

`DENY`  
Never ever show the page inside a frame.

`SAMEORIGIN`  
Allow inside a frame if the parent document comes from the same origin.

`ALLOW-FROM domain`  
Allow inside a frame if the parent document is from the given domain.

For instance, Twitter uses `X-Frame-Options: SAMEORIGIN`.

    Here's the result:

    ```html
    <iframe src="https://twitter.com"></iframe>
    ```

    <!-- ebook: prerender/ chrome headless dies and timeouts on this iframe -->
    <iframe src="https://twitter.com"></iframe>

    Depending on your browser, the `iframe` above is either empty or alerting you that the browser won't permit that page to be navigating in this way.

## Showing with disabled functionality

The `X-Frame-Options` header has a side-effect. Other sites won’t be able to show our page in a frame, even if they have good reasons to do so.

So there are other solutions… For instance, we can “cover” the page with a `<div>` with styles `height: 100%; width: 100%;`, so that it will intercept all clicks. That `<div>` is to be removed if `window == top` or if we figure out that we don’t need the protection.

Something like this:

    <style>
      #protector {
        height: 100%;
        width: 100%;
        position: absolute;
        left: 0;
        top: 0;
        z-index: 99999999;
      }
    </style>

    <div id="protector">
      <a href="/" target="_blank">Go to the site</a>
    </div>

    <script>
      // there will be an error if top window is from the different origin
      // but that's ok here
      if (top.document.domain == document.domain) {
        protector.remove();
      }
    </script>

The demo:

\[codetabs src=“protector”\]

## Samesite cookie attribute

The `samesite` cookie attribute can also prevent clickjacking attacks.

A cookie with such attribute is only sent to a website if it’s opened directly, not via a frame, or otherwise. More information in the chapter <a href="info:cookie#samesite" class="uri">info:cookie#samesite</a>.

If the site, such as Facebook, had `samesite` attribute on its authentication cookie, like this:

…Then such cookie wouldn’t be sent when Facebook is open in iframe from another site. So the attack would fail.

The `samesite` cookie attribute will not have an effect when cookies are not used. This may allow other websites to easily show our public, unauthenticated pages in iframes.

However, this may also allow clickjacking attacks to work in a few limited cases. An anonymous polling website that prevents duplicate voting by checking IP addresses, for example, would still be vulnerable to clickjacking because it does not authenticate users using cookies.

## Summary

Clickjacking is a way to “trick” users into clicking on a victim site without even knowing what’s happening. That’s dangerous if there are important click-activated actions.

A hacker can post a link to their evil page in a message, or lure visitors to their page by some other means. There are many variations.

From one perspective – the attack is “not deep”: all a hacker is doing is intercepting a single click. But from another perspective, if the hacker knows that after the click another control will appear, then they may use cunning messages to coerce the user into clicking on them as well.

The attack is quite dangerous, because when we engineer the UI we usually don’t anticipate that a hacker may click on behalf of the visitor. So vulnerabilities can be found in totally unexpected places.

- It is recommended to use `X-Frame-Options: SAMEORIGIN` on pages (or whole websites) which are not intended to be viewed inside frames.
- Use a covering `<div>` if we want to allow our pages to be shown in iframes, but still stay safe. \# ArrayBuffer, binary arrays

In web-development we meet binary data mostly while dealing with files (create, upload, download). Another typical use case is image processing.

That’s all possible in JavaScript, and binary operations are high-performant.

Although, there’s a bit of confusion, because there are many classes. To name a few: - `ArrayBuffer`, `Uint8Array`, `DataView`, `Blob`, `File`, etc.

Binary data in JavaScript is implemented in a non-standard way, compared to other languages. But when we sort things out, everything becomes fairly simple.

**The basic binary object is `ArrayBuffer` – a reference to a fixed-length contiguous memory area.**

We create it like this: `js run let buffer = new ArrayBuffer(16); // create a buffer of length 16 alert(buffer.byteLength); // 16`

This allocates a contiguous memory area of 16 bytes and pre-fills it with zeroes.

`` warn header="`ArrayBuffer` is not an array of something" Let's eliminate a possible source of confusion. `ArrayBuffer` has nothing in common with `Array`: - It has a fixed length, we can't increase or decrease it. - It takes exactly that much space in the memory. - To access individual bytes, another "view" object is needed, not `buffer[index]`. ``

`ArrayBuffer` is a memory area. What’s stored in it? It has no clue. Just a raw sequence of bytes.

**To manipulate an `ArrayBuffer`, we need to use a “view” object.**

A view object does not store anything on it’s own. It’s the “eyeglasses” that give an interpretation of the bytes stored in the `ArrayBuffer`.

For instance:

- **`Uint8Array`** – treats each byte in `ArrayBuffer` as a separate number, with possible values from 0 to 255 (a byte is 8-bit, so it can hold only that much). Such value is called a “8-bit unsigned integer”.
- **`Uint16Array`** – treats every 2 bytes as an integer, with possible values from 0 to 65535. That’s called a “16-bit unsigned integer”.
- **`Uint32Array`** – treats every 4 bytes as an integer, with possible values from 0 to 4294967295. That’s called a “32-bit unsigned integer”.
- **`Float64Array`** – treats every 8 bytes as a floating point number with possible values from `5.0x10-324` to `1.8x10308`.

So, the binary data in an `ArrayBuffer` of 16 bytes can be interpreted as 16 “tiny numbers”, or 8 bigger numbers (2 bytes each), or 4 even bigger (4 bytes each), or 2 floating-point values with high precision (8 bytes each).

![](arraybuffer-views.svg)

`ArrayBuffer` is the core object, the root of everything, the raw binary data.

But if we’re going to write into it, or iterate over it, basically for almost any operation – we must use a view, e.g:

\`\`\`js run let buffer = new ArrayBuffer(16); // create a buffer of length 16

_!_ let view = new Uint32Array(buffer); // treat buffer as a sequence of 32-bit integers

alert(Uint32Array.BYTES_PER_ELEMENT); // 4 bytes per integer _/!_

alert(view.length); // 4, it stores that many integers alert(view.byteLength); // 16, the size in bytes

// let’s write a value view\[0\] = 123456;

// iterate over values for(let num of view) { alert(num); // 123456, then 0, 0, 0 (4 values total) }

\`\`\`

## TypedArray

The common term for all these views (`Uint8Array`, `Uint32Array`, etc) is [TypedArray](https://tc39.github.io/ecma262/#sec-typedarray-objects). They share the same set of methods and properities.

Please note, there’s no constructor called `TypedArray`, it’s just a common “umbrella” term to represent one of views over `ArrayBuffer`: `Int8Array`, `Uint8Array` and so on, the full list will soon follow.

When you see something like `new TypedArray`, it means any of `new Int8Array`, `new Uint8Array`, etc.

Typed arrays behave like regular arrays: have indexes and are iterable.

A typed array constructor (be it `Int8Array` or `Float64Array`, doesn’t matter) behaves differently depending on argument types.

There are 5 variants of arguments:

    new TypedArray(buffer, [byteOffset], [length]);
    new TypedArray(object);
    new TypedArray(typedArray);
    new TypedArray(length);
    new TypedArray();

1.  If an `ArrayBuffer` argument is supplied, the view is created over it. We used that syntax already.

    Optionally we can provide `byteOffset` to start from (0 by default) and the `length` (till the end of the buffer by default), then the view will cover only a part of the `buffer`.

2.  If an `Array`, or any array-like object is given, it creates a typed array of the same length and copies the content.

    We can use it to pre-fill the array with the data: `js run *!* let arr = new Uint8Array([0, 1, 2, 3]); */!* alert( arr.length ); // 4, created binary array of the same length alert( arr[1] ); // 1, filled with 4 bytes (unsigned 8-bit integers) with given values`

3.  If another `TypedArray` is supplied, it does the same: creates a typed array of the same length and copies values. Values are converted to the new type in the process, if needed. `js run let arr16 = new Uint16Array([1, 1000]); *!* let arr8 = new Uint8Array(arr16); */!* alert( arr8[0] ); // 1 alert( arr8[1] ); // 232, tried to copy 1000, but can't fit 1000 into 8 bits (explanations below)`

4.  For a numeric argument `length` – creates the typed array to contain that many elements. Its byte length will be `length` multiplied by the number of bytes in a single item `TypedArray.BYTES_PER_ELEMENT`: `js run let arr = new Uint16Array(4); // create typed array for 4 integers alert( Uint16Array.BYTES_PER_ELEMENT ); // 2 bytes per integer alert( arr.byteLength ); // 8 (size in bytes)`

5.  Without arguments, creates an zero-length typed array.

We can create a `TypedArray` directly, without mentioning `ArrayBuffer`. But a view cannot exist without an underlying `ArrayBuffer`, so gets created automatically in all these cases except the first one (when provided).

To access the `ArrayBuffer`, there are properties: - `arr.buffer` – references the `ArrayBuffer`. - `arr.byteLength` – the length of the `ArrayBuffer`.

So, we can always move from one view to another:

    let arr8 = new Uint8Array([0, 1, 2, 3]);

    // another view on the same data
    let arr16 = new Uint16Array(arr8.buffer);

Here’s the list of typed arrays:

- `Uint8Array`, `Uint16Array`, `Uint32Array` – for integer numbers of 8, 16 and 32 bits.
  - `Uint8ClampedArray` – for 8-bit integers, “clamps” them on assignment (see below).
- `Int8Array`, `Int16Array`, `Int32Array` – for signed integer numbers (can be negative).
- `Float32Array`, `Float64Array` – for signed floating-point numbers of 32 and 64 bits.

\`\``warn header="No`int8`or similar single-valued types" Please note, despite of the names like`Int8Array`, there's no single-value type like`int`, or`int8\` in JavaScript.

That’s logical, as `Int8Array` is not an array of these individual values, but rather a view on `ArrayBuffer`. \`\`\`

### Out-of-bounds behavior

What if we attempt to write an out-of-bounds value into a typed array? There will be no error. But extra bits are cut-off.

For instance, let’s try to put 256 into `Uint8Array`. In binary form, 256 is `100000000` (9 bits), but `Uint8Array` only provides 8 bits per value, that makes the available range from 0 to 255.

For bigger numbers, only the rightmost (less significant) 8 bits are stored, and the rest is cut off:

![](8bit-integer-256.svg)

So we’ll get zero.

For 257, the binary form is `100000001` (9 bits), the rightmost 8 get stored, so we’ll have `1` in the array:

![](8bit-integer-257.svg)

In other words, the number modulo 2<sup>8</sup> is saved.

Here’s the demo:

\`\`\`js run let uint8array = new Uint8Array(16);

let num = 256; alert(num.toString(2)); // 100000000 (binary representation)

uint8array\[0\] = 256; uint8array\[1\] = 257;

alert(uint8array\[0\]); // 0 alert(uint8array\[1\]); // 1 \`\`\`

`Uint8ClampedArray` is special in this aspect, its behavior is different. It saves 255 for any number that is greater than 255, and 0 for any negative number. That behavior is useful for image processing.

## TypedArray methods

`TypedArray` has regular `Array` methods, with notable exceptions.

We can iterate, `map`, `slice`, `find`, `reduce` etc.

There are few things we can’t do though:

- No `splice` – we can’t “delete” a value, because typed arrays are views on a buffer, and these are fixed, contiguous areas of memory. All we can do is to assign a zero.
- No `concat` method.

There are two additional methods:

- `arr.set(fromArr, [offset])` copies all elements from `fromArr` to the `arr`, starting at position `offset` (0 by default).
- `arr.subarray([begin, end])` creates a new view of the same type from `begin` to `end` (exclusive). That’s similar to `slice` method (that’s also supported), but doesn’t copy anything – just creates a new view, to operate on the given piece of data.

These methods allow us to copy typed arrays, mix them, create new arrays from existing ones, and so on.

## DataView

[DataView](mdn:/JavaScript/Reference/Global_Objects/DataView) is a special super-flexible “untyped” view over `ArrayBuffer`. It allows to access the data on any offset in any format.

- For typed arrays, the constructor dictates what the format is. The whole array is supposed to be uniform. The i-th number is `arr[i]`.
- With `DataView` we access the data with methods like `.getUint8(i)` or `.getUint16(i)`. We choose the format at method call time instead of the construction time.

The syntax:

    new DataView(buffer, [byteOffset], [byteLength])

- **`buffer`** – the underlying `ArrayBuffer`. Unlike typed arrays, `DataView` doesn’t create a buffer on its own. We need to have it ready.
- **`byteOffset`** – the starting byte position of the view (by default 0).
- **`byteLength`** – the byte length of the view (by default till the end of `buffer`).

For instance, here we extract numbers in different formats from the same buffer:

\`\`\`js run // binary array of 4 bytes, all have the maximal value 255 let buffer = new Uint8Array(\[255, 255, 255, 255\]).buffer;

let dataView = new DataView(buffer);

// get 8-bit number at offset 0 alert( dataView.getUint8(0) ); // 255

// now get 16-bit number at offset 0, it consists of 2 bytes, together interpreted as 65535 alert( dataView.getUint16(0) ); // 65535 (biggest 16-bit unsigned int)

// get 32-bit number at offset 0 alert( dataView.getUint32(0) ); // 4294967295 (biggest 32-bit unsigned int)

dataView.setUint32(0, 0); // set 4-byte number to zero, thus setting all bytes to 0 \`\`\`

`DataView` is great when we store mixed-format data in the same buffer. For example, when we store a sequence of pairs (16-bit integer, 32-bit float), `DataView` allows to access them easily.

## Summary

`ArrayBuffer` is the core object, a reference to the fixed-length contiguous memory area.

To do almost any operation on `ArrayBuffer`, we need a view.

- It can be a `TypedArray`:
  - `Uint8Array`, `Uint16Array`, `Uint32Array` – for unsigned integers of 8, 16, and 32 bits.
  - `Uint8ClampedArray` – for 8-bit integers, “clamps” them on assignment.
  - `Int8Array`, `Int16Array`, `Int32Array` – for signed integer numbers (can be negative).
  - `Float32Array`, `Float64Array` – for signed floating-point numbers of 32 and 64 bits.
- Or a `DataView` – the view that uses methods to specify a format, e.g. `getUint8(offset)`.

In most cases we create and operate directly on typed arrays, leaving `ArrayBuffer` under cover, as a “common denominator”. We can access it as `.buffer` and make another view if needed.

There are also two additional terms, that are used in descriptions of methods that operate on binary data: - `ArrayBufferView` is an umbrella term for all these kinds of views. - `BufferSource` is an umbrella term for `ArrayBuffer` or `ArrayBufferView`.

We’ll see these terms in the next chapters. `BufferSource` is one of the most common terms, as it means “any kind of binary data” – an `ArrayBuffer` or a view over it.

Here’s a cheatsheet:

![](arraybuffer-view-buffersource.svg) \# TextDecoder and TextEncoder

What if the binary data is actually a string? For instance, we received a file with textual data.

The build-in [TextDecoder](https://encoding.spec.whatwg.org/#interface-textdecoder) object allows to read the value into an actual JavaScript string, given the buffer and the encoding.

We first need to create it:

    let decoder = new TextDecoder([label], [options]);

- **`label`** – the encoding, `utf-8` by default, but `big5`, `windows-1251` and many other are also supported.
- **`options`** – optional object:
  - **`fatal`** – boolean, if `true` then throw an exception for invalid (non-decodable) characters, otherwise (default) replace them with character `\uFFFD`.
  - **`ignoreBOM`** – boolean, if `true` then ignore BOM (an optional byte-order Unicode mark), rarely needed.

…And then decode:

    let str = decoder.decode([input], [options]);

- **`input`** – `BufferSource` to decode.
- **`options`** – optional object:
  - **`stream`** – true for decoding streams, when `decoder` is called repeatedly with incoming chunks of data. In that case a multi-byte character may occasionally split between chunks. This options tells `TextDecoder` to memorize “unfinished” characters and decode them when the next chunk comes.

For instance:

\`\`\`js run let uint8Array = new Uint8Array(\[72, 101, 108, 108, 111\]);

alert( new TextDecoder().decode(uint8Array) ); // Hello \`\`\`

\`\`\`js run let uint8Array = new Uint8Array(\[228, 189, 160, 229, 165, 189\]);

alert( new TextDecoder().decode(uint8Array) ); // 你好 \`\`\`

We can decode a part of the buffer by creating a subarray view for it:

\`\`\`js run let uint8Array = new Uint8Array(\[0, 72, 101, 108, 108, 111, 0\]);

// the string is in the middle // create a new view over it, without copying anything let binaryString = uint8Array.subarray(1, -1);

alert( new TextDecoder().decode(binaryString) ); // Hello \`\`\`

## TextEncoder

[TextEncoder](https://encoding.spec.whatwg.org/#interface-textencoder) does the reverse thing – converts a string into bytes.

The syntax is:

    let encoder = new TextEncoder();

The only encoding it supports is “utf-8”.

It has two methods: - **`encode(str)`** – returns `Uint8Array` from a string. - **`encodeInto(str, destination)`** – encodes `str` into `destination` that must be `Uint8Array`.

\`\`\`js run let encoder = new TextEncoder();

let uint8Array = encoder.encode(“Hello”); alert(uint8Array); // 72,101,108,108,111 \`\`\` \# Comparisons

We know many comparison operators from maths.

In JavaScript they are written like this:

- Greater/less than: `a > b`, `a < b`.
- Greater/less than or equals: `a >= b`, `a <= b`.
- Equals: `a == b`, please note the double equality sign `==` means the equality test, while a single one `a = b` means an assignment.
- Not equals. In maths the notation is `≠`, but in JavaScript it’s written as `a != b`.

In this article we’ll learn more about different types of comparisons, how JavaScript makes them, including important peculiarities.

At the end you’ll find a good recipe to avoid “JavaScript quirks”-related issues.

## Boolean is the result

All comparison operators return a boolean value:

- `true` – means “yes”, “correct” or “the truth”.
- `false` – means “no”, “wrong” or “not the truth”.

For example:

`js run alert( 2 > 1 ); // true (correct) alert( 2 == 1 ); // false (wrong) alert( 2 != 1 ); // true (correct)`

A comparison result can be assigned to a variable, just like any value:

`js run let result = 5 > 4; // assign the result of the comparison alert( result ); // true`

## String comparison

To see whether a string is greater than another, JavaScript uses the so-called “dictionary” or “lexicographical” order.

In other words, strings are compared letter-by-letter.

For example:

`js run alert( 'Z' > 'A' ); // true alert( 'Glow' > 'Glee' ); // true alert( 'Bee' > 'Be' ); // true`

The algorithm to compare two strings is simple:

1.  Compare the first character of both strings.
2.  If the first character from the first string is greater (or less) than the other string’s, then the first string is greater (or less) than the second. We’re done.
3.  Otherwise, if both strings’ first characters are the same, compare the second characters the same way.
4.  Repeat until the end of either string.
5.  If both strings end at the same length, then they are equal. Otherwise, the longer string is greater.

In the first example above, the comparison `'Z' > 'A'` gets to a result at the first step.

The second comparison `'Glow'` and `'Glee'` needs more steps as strings are compared character-by-character:

1.  `G` is the same as `G`.
2.  `l` is the same as `l`.
3.  `o` is greater than `e`. Stop here. The first string is greater.

\`\`\`smart header=“Not a real dictionary, but Unicode order” The comparison algorithm given above is roughly equivalent to the one used in dictionaries or phone books, but it’s not exactly the same.

For instance, case matters. A capital letter `"A"` is not equal to the lowercase `"a"`. Which one is greater? The lowercase `"a"`. Why? Because the lowercase character has a greater index in the internal encoding table JavaScript uses (Unicode). We’ll get back to specific details and consequences of this in the chapter <a href="info:string" class="uri">info:string</a>. \`\`\`

## Comparison of different types

When comparing values of different types, JavaScript converts the values to numbers.

For example:

`js run alert( '2' > 1 ); // true, string '2' becomes a number 2 alert( '01' == 1 ); // true, string '01' becomes a number 1`

For boolean values, `true` becomes `1` and `false` becomes `0`.

For example:

`js run alert( true == 1 ); // true alert( false == 0 ); // true`

\`\`\`\`smart header=“A funny consequence” It is possible that at the same time:

- Two values are equal.
- One of them is `true` as a boolean and the other one is `false` as a boolean.

For example:

\`\`\`js run let a = 0; alert( Boolean(a) ); // false

let b = “0”; alert( Boolean(b) ); // true

alert(a == b); // true!

    From JavaScript's standpoint, this result is quite normal. An equality check converts values using the numeric conversion (hence `"0"` becomes `0`), while the explicit `Boolean` conversion uses another set of rules.

## Strict equality

A regular equality check `==` has a problem. It cannot differentiate `0` from `false`:

`js run alert( 0 == false ); // true`

The same thing happens with an empty string:

`js run alert( '' == false ); // true`

This happens because operands of different types are converted to numbers by the equality operator `==`. An empty string, just like `false`, becomes a zero.

What to do if we’d like to differentiate `0` from `false`?

**A strict equality operator `===` checks the equality without type conversion.**

In other words, if `a` and `b` are of different types, then `a === b` immediately returns `false` without an attempt to convert them.

Let’s try it:

`js run alert( 0 === false ); // false, because the types are different`

There is also a “strict non-equality” operator `!==` analogous to `!=`.

The strict equality operator is a bit longer to write, but makes it obvious what’s going on and leaves less room for errors.

## Comparison with null and undefined

There’s a non-intuitive behavior when `null` or `undefined` are compared to other values.

For a strict equality check `===`  
These values are different, because each of them is a different type.

`js run alert( null === undefined ); // false`

For a non-strict check `==`  
There’s a special rule. These two are a “sweet couple”: they equal each other (in the sense of `==`), but not any other value.

`js run alert( null == undefined ); // true`

For maths and other comparisons `< > <= >=`  
`null/undefined` are converted to numbers: `null` becomes `0`, while `undefined` becomes `NaN`.

Now let’s see some funny things that happen when we apply these rules. And, what’s more important, how to not fall into a trap with them.

### Strange result: null vs 0

Let’s compare `null` with a zero:

`js run alert( null > 0 ); // (1) false alert( null == 0 ); // (2) false alert( null >= 0 ); // (3) *!*true*/!*`

Mathematically, that’s strange. The last result states that “`null` is greater than or equal to zero”, so in one of the comparisons above it must be `true`, but they are both false.

The reason is that an equality check `==` and comparisons `> < >= <=` work differently. Comparisons convert `null` to a number, treating it as `0`. That’s why (3) `null >= 0` is true and (1) `null > 0` is false.

On the other hand, the equality check `==` for `undefined` and `null` is defined such that, without any conversions, they equal each other and don’t equal anything else. That’s why (2) `null == 0` is false.

### An incomparable undefined

The value `undefined` shouldn’t be compared to other values:

`js run alert( undefined > 0 ); // false (1) alert( undefined < 0 ); // false (2) alert( undefined == 0 ); // false (3)`

Why does it dislike zero so much? Always false!

We get these results because:

- Comparisons `(1)` and `(2)` return `false` because `undefined` gets converted to `NaN` and `NaN` is a special numeric value which returns `false` for all comparisons.
- The equality check `(3)` returns `false` because `undefined` only equals `null`, `undefined`, and no other value.

### Avoid problems

Why did we go over these examples? Should we remember these peculiarities all the time? Well, not really. Actually, these tricky things will gradually become familiar over time, but there’s a solid way to avoid problems with them:

- Treat any comparison with `undefined/null` except the strict equality `===` with exceptional care.
- Don’t use comparisons `>= > < <=` with a variable which may be `null/undefined`, unless you’re really sure of what you’re doing. If a variable can have these values, check for them separately.

## Summary

- Comparison operators return a boolean value.
- Strings are compared letter-by-letter in the “dictionary” order.
- When values of different types are compared, they get converted to numbers (with the exclusion of a strict equality check).
- The values `null` and `undefined` equal `==` each other and do not equal any other value.
- Be careful when using comparisons like `>` or `<` with variables that can occasionally be `null/undefined`. Checking for `null/undefined` separately is a good idea. \# Blob

`ArrayBuffer` and views are a part of ECMA standard, a part of JavaScript.

In the browser, there are additional higher-level objects, described in [File API](https://www.w3.org/TR/FileAPI/), in particular `Blob`.

`Blob` consists of an optional string `type` (a MIME-type usually), plus `blobParts` – a sequence of other `Blob` objects, strings and `BufferSource`.

![](blob.svg)

The constructor syntax is:

    new Blob(blobParts, options);

- **`blobParts`** is an array of `Blob`/`BufferSource`/`String` values.
- **`options`** optional object:
  - **`type`** – `Blob` type, usually MIME-type, e.g. `image/png`,
  - **`endings`** – whether to transform end-of-line to make the `Blob` correspond to current OS newlines (`\r\n` or `\n`). By default `"transparent"` (do nothing), but also can be `"native"` (transform).

For example:

    // create Blob from a string
    let blob = new Blob(["<html>…</html>"], {type: 'text/html'});
    // please note: the first argument must be an array [...]

    // create Blob from a typed array and strings
    let hello = new Uint8Array([72, 101, 108, 108, 111]); // "Hello" in binary form

    let blob = new Blob([hello, ' ', 'world'], {type: 'text/plain'});

We can extract `Blob` slices with:

    blob.slice([byteStart], [byteEnd], [contentType]);

- **`byteStart`** – the starting byte, by default 0.
- **`byteEnd`** – the last byte (exclusive, by default till the end).
- **`contentType`** – the `type` of the new blob, by default the same as the source.

The arguments are similar to `array.slice`, negative numbers are allowed too.

\`\``smart header="`Blob`objects are immutable" We can't change data directly in a`Blob`, but we can slice parts of a`Blob`, create new`Blob`objects from them, mix them into a new`Blob\` and so on.

This behavior is similar to JavaScript strings: we can’t change a character in a string, but we can make a new corrected string. \`\`\`

## Blob as URL

A Blob can be easily used as a URL for `<a>`, `<img>` or other tags, to show its contents.

Thanks to `type`, we can also download/upload `Blob` objects, and the `type` naturally becomes `Content-Type` in network requests.

Let’s start with a simple example. By clicking on a link you download a dynamically-generated `Blob` with `hello world` contents as a file:

\`\`\`html run <a href="#" id="link">Download</a>

\`\`\`

We can also create a link dynamically in JavaScript and simulate a click by `link.click()`, then download starts automatically.

Here’s the similar code that causes user to download the dynamically created `Blob`, without any HTML:

\`\`\`js run let link = document.createElement(‘a’); link.download = ‘hello.txt’;

let blob = new Blob(\[‘Hello, world!’\], {type: ‘text/plain’});

link.href = URL.createObjectURL(blob);

link.click();

URL.revokeObjectURL(link.href);

    `URL.createObjectURL` takes a `Blob` and creates a unique URL for it, in the form `blob:<origin>/<uuid>`.

    That's what the value of `link.href` looks like:

blob:https://javascript.info/1e67e00e-860d-40a5-89ae-6ab0cbee6273 \`\`\`

For each URL generated by `URL.createObjectURL` the browser stores a URL -&gt; `Blob` mapping internally. So such URLs are short, but allow to access the `Blob`.

A generated URL (and hence the link with it) is only valid within the current document, while it’s open. And it allows to reference the `Blob` in `<img>`, `<a>`, basically any other object that expects a URL.

There’s a side-effect though. While there’s a mapping for a `Blob`, the `Blob` itself resides in the memory. The browser can’t free it.

The mapping is automatically cleared on document unload, so `Blob` objects are freed then. But if an app is long-living, then that doesn’t happen soon.

**So if we create a URL, that `Blob` will hang in memory, even if not needed any more.**

`URL.revokeObjectURL(url)` removes the reference from the internal mapping, thus allowing the `Blob` to be deleted (if there are no other references), and the memory to be freed.

In the last example, we intend the `Blob` to be used only once, for instant downloading, so we call `URL.revokeObjectURL(link.href)` immediately.

In the previous example with the clickable HTML-link, we don’t call `URL.revokeObjectURL(link.href)`, because that would make the `Blob` url invalid. After the revocation, as the mapping is removed, the URL doesn’t work any more.

## Blob to base64

An alternative to `URL.createObjectURL` is to convert a `Blob` into a base64-encoded string.

That encoding represents binary data as a string of ultra-safe “readable” characters with ASCII-codes from 0 to 64. And what’s more important – we can use this encoding in “data-urls”.

A [data url](mdn:/http/Data_URIs) has the form `data:[<mediatype>][;base64],<data>`. We can use such urls everywhere, on par with “regular” urls.

For instance, here’s a smiley:

    <img src="data:image/png;base64,R0lGODlhDAAMAKIFAF5LAP/zxAAAANyuAP/gaP///wAAAAAAACH5BAEAAAUALAAAAAAMAAwAAAMlWLPcGjDKFYi9lxKBOaGcF35DhWHamZUW0K4mAbiwWtuf0uxFAgA7">

The browser will decode the string and show the image: ![](data:image/png;base64,R0lGODlhDAAMAKIFAF5LAP/zxAAAANyuAP/gaP///wAAAAAAACH5BAEAAAUALAAAAAAMAAwAAAMlWLPcGjDKFYi9lxKBOaGcF35DhWHamZUW0K4mAbiwWtuf0uxFAgA7)

To transform a `Blob` into base64, we’ll use the built-in `FileReader` object. It can read data from Blobs in multiple formats. In the [next chapter](info:file) we’ll cover it more in-depth.

Here’s the demo of downloading a blob, now via base-64:

\`\`\`js run let link = document.createElement(‘a’); link.download = ‘hello.txt’;

let blob = new Blob(\[‘Hello, world!’\], {type: ‘text/plain’});

_!_ let reader = new FileReader(); reader.readAsDataURL(blob); // converts the blob to base64 and calls onload _/!_

reader.onload = function() { link.href = reader.result; // data url link.click(); }; \`\`\`

Both ways of making a URL of a `Blob` are usable. But usually `URL.createObjectURL(blob)` is simpler and faster.

`` compare title-plus="URL.createObjectURL(blob)" title-minus="Blob to data url" + We need to revoke them if care about memory. + Direct access to blob, no "encoding/decoding" - No need to revoke anything. - Performance and memory losses on big `Blob` objects for encoding. ``

## Image to blob

We can create a `Blob` of an image, an image part, or even make a page screenshot. That’s handy to upload it somewhere.

Image operations are done via `<canvas>` element:

1.  Draw an image (or its part) on canvas using [canvas.drawImage](mdn:/api/CanvasRenderingContext2D/drawImage).
2.  Call canvas method [.toBlob(callback, format, quality)](mdn:/api/HTMLCanvasElement/toBlob) that creates a `Blob` and runs `callback` with it when done.

In the example below, an image is just copied, but we could cut from it, or transform it on canvas prior to making a blob:

\`\`\`js run // take any image let img = document.querySelector(‘img’);

// make

of the same size let canvas = document.createElement(‘canvas’); canvas.width = img.clientWidth; canvas.height = img.clientHeight;

let context = canvas.getContext(‘2d’);

// copy image to it (this method allows to cut image) context.drawImage(img, 0, 0); // we can context.rotate(), and do many other things on canvas

// toBlob is async operation, callback is called when done canvas.toBlob(function(blob) { // blob ready, download it let link = document.createElement(‘a’); link.download = ‘example.png’;

link.href = URL.createObjectURL(blob); link.click();

// delete the internal blob reference, to let the browser clear memory from it URL.revokeObjectURL(link.href); }, ‘image/png’); \`\`\`

If we prefer `async/await` instead of callbacks:

    let blob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png'));

For screenshotting a page, we can use a library such as <a href="https://github.com/niklasvh/html2canvas" class="uri">https://github.com/niklasvh/html2canvas</a>. What it does is just walks the page and draws it on `<canvas>`. Then we can get a `Blob` of it the same way as above.

## From Blob to ArrayBuffer

The `Blob` constructor allows to create a blob from almost anything, including any `BufferSource`.

But if we need to perform low-level processing, we can get the lowest-level `ArrayBuffer` from it using `FileReader`:

    // get arrayBuffer from blob
    let fileReader = new FileReader();

    *!*
    fileReader.readAsArrayBuffer(blob);
    */!*

    fileReader.onload = function(event) {
      let arrayBuffer = fileReader.result;
    };

## Summary

While `ArrayBuffer`, `Uint8Array` and other `BufferSource` are “binary data”, a [Blob](https://www.w3.org/TR/FileAPI/#dfn-Blob) represents “binary data with type”.

That makes Blobs convenient for upload/download operations, that are so common in the browser.

Methods that perform web-requests, such as [XMLHttpRequest](info:xmlhttprequest), [fetch](info:fetch) and so on, can work with `Blob` natively, as well as with other binary types.

We can easily convert between `Blob` and low-level binary data types:

- We can make a Blob from a typed array using `new Blob(...)` constructor.
- We can get back `ArrayBuffer` from a Blob using `FileReader`, and then create a view over it for low-level binary processing. \# File and FileReader

A [File](https://www.w3.org/TR/FileAPI/#dfn-file) object inherits from `Blob` and is extended with filesystem-related capabilities.

There are two ways to obtain it.

First, there’s a constructor, similar to `Blob`:

    new File(fileParts, fileName, [options])

- **`fileParts`** – is an array of Blob/BufferSource/String values.
- **`fileName`** – file name string.
- **`options`** – optional object:
  - **`lastModified`** – the timestamp (integer date) of last modification.

Second, more often we get a file from `<input type="file">` or drag’n’drop or other browser interfaces. In that case, the file gets this information from OS.

As `File` inherits from `Blob`, `File` objects have the same properties, plus: - `name` – the file name, - `lastModified` – the timestamp of last modification.

That’s how we can get a `File` object from `<input type="file">`:

\`\`\`html run

\`\`\`

    The input may select multiple files, so `input.files` is an array-like object with them. Here we have only one file, so we just take `input.files[0]`.

## FileReader

[FileReader](https://www.w3.org/TR/FileAPI/#dfn-filereader) is an object with the sole purpose of reading data from `Blob` (and hence `File` too) objects.

It delivers the data using events, as reading from disk may take time.

The constructor:

    let reader = new FileReader(); // no arguments

The main methods:

- **`readAsArrayBuffer(blob)`** – read the data in binary format `ArrayBuffer`.
- **`readAsText(blob, [encoding])`** – read the data as a text string with the given encoding (`utf-8` by default).
- **`readAsDataURL(blob)`** – read the binary data and encode it as base64 data url.
- **`abort()`** – cancel the operation.

The choice of `read*` method depends on which format we prefer, how we’re going to use the data.

- `readAsArrayBuffer` – for binary files, to do low-level binary operations. For high-level operations, like slicing, `File` inherits from `Blob`, so we can call them directly, without reading.
- `readAsText` – for text files, when we’d like to get a string.
- `readAsDataURL` – when we’d like to use this data in `src` for `img` or another tag. There’s an alternative to reading a file for that, as discussed in chapter <a href="info:blob" class="uri">info:blob</a>: `URL.createObjectURL(file)`.

As the reading proceeds, there are events: - `loadstart` – loading started. - `progress` – occurs during reading. - `load` – no errors, reading complete. - `abort` – `abort()` called. - `error` – error has occurred. - `loadend` – reading finished with either success or failure.

When the reading is finished, we can access the result as: - `reader.result` is the result (if successful) - `reader.error` is the error (if failed).

The most widely used events are for sure `load` and `error`.

Here’s an example of reading a file:

\`\`\`html run

\`\`\`

\`\``smart header="`FileReader`for blobs" As mentioned in the chapter <info:blob>,`FileReader\` can read not just files, but any blobs.

We can use it to convert a blob to another format: - `readAsArrayBuffer(blob)` – to `ArrayBuffer`, - `readAsText(blob, [encoding])` – to string (an alternative to `TextDecoder`), - `readAsDataURL(blob)` – to base64 data url. \`\`\`

\`\``smart header="`FileReaderSync`is available inside Web Workers" For Web Workers, there also exists a synchronous variant of`FileReader\`, called [FileReaderSync](https://www.w3.org/TR/FileAPI/#FileReaderSync).

Its reading methods `read*` do not generate events, but rather return a result, as regular functions do.

That’s only inside a Web Worker though, because delays in synchronous calls, that are possible while reading from files, in Web Workers are less important. They do not affect the page. \`\`\`

## Summary

`File` objects inherit from `Blob`.

In addition to `Blob` methods and properties, `File` objects also have `name` and `lastModified` properties, plus the internal ability to read from filesystem. We usually get `File` objects from user input, like `<input>` or Drag’n’Drop events (`ondragend`).

`FileReader` objects can read from a file or a blob, in one of three formats: - String (`readAsText`). - `ArrayBuffer` (`readAsArrayBuffer`). - Data url, base-64 encoded (`readAsDataURL`).

In many cases though, we don’t have to read the file contents. Just as we did with blobs, we can create a short url with `URL.createObjectURL(file)` and assign it to `<a>` or `<img>`. This way the file can be downloaded or shown up as an image, as a part of canvas etc.

And if we’re going to send a `File` over a network, that’s also easy: network API like `XMLHttpRequest` or `fetch` natively accepts `File` objects.

# Fetch

JavaScript can send network requests to the server and load new information whenever it’s needed.

For example, we can use a network request to:

- Submit an order,
- Load user information,
- Receive latest updates from the server,
- …etc.

…And all of that without reloading the page!

There’s an umbrella term “AJAX” (abbreviated **A**synchronous **J**avaScript **A**nd **X**ML) for network requests from JavaScript. We don’t have to use XML though: the term comes from old times, that’s why that word is there. You may have heard that term already.

There are multiple ways to send a network request and get information from the server.

The `fetch()` method is modern and versatile, so we’ll start with it. It’s not supported by old browsers (can be polyfilled), but very well supported among the modern ones.

The basic syntax is:

    let promise = fetch(url, [options])

- **`url`** – the URL to access.
- **`options`** – optional parameters: method, headers etc.

Without `options`, this is a simple GET request, downloading the contents of the `url`.

The browser starts the request right away and returns a promise that the calling code should use to get the result.

Getting a response is usually a two-stage process.

**First, the `promise`, returned by `fetch`, resolves with an object of the built-in [Response](https://fetch.spec.whatwg.org/#response-class) class as soon as the server responds with headers.**

At this stage we can check HTTP status, to see whether it is successful or not, check headers, but don’t have the body yet.

The promise rejects if the `fetch` was unable to make HTTP-request, e.g. network problems, or there’s no such site. Abnormal HTTP-statuses, such as 404 or 500 do not cause an error.

We can see HTTP-status in response properties:

- **`status`** – HTTP status code, e.g. 200.
- **`ok`** – boolean, `true` if the HTTP status code is 200-299.

For example:

    let response = await fetch(url);

    if (response.ok) { // if HTTP-status is 200-299
      // get the response body (the method explained below)
      let json = await response.json();
    } else {
      alert("HTTP-Error: " + response.status);
    }

**Second, to get the response body, we need to use an additional method call.**

`Response` provides multiple promise-based methods to access the body in various formats:

- **`response.text()`** – read the response and return as text,
- **`response.json()`** – parse the response as JSON,
- **`response.formData()`** – return the response as `FormData` object (explained in the [next chapter](info:formdata)),
- **`response.blob()`** – return the response as [Blob](info:blob) (binary data with type),
- **`response.arrayBuffer()`** – return the response as [ArrayBuffer](info:arraybuffer-binary-arrays) (low-level representation of binary data),
- additionally, `response.body` is a [ReadableStream](https://streams.spec.whatwg.org/#rs-class) object, it allows you to read the body chunk-by-chunk, we’ll see an example later.

For instance, let’s get a JSON-object with latest commits from GitHub:

\`\`\`js run async let url = ‘https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits’; let response = await fetch(url);

_!_ let commits = await response.json(); // read response body and parse as JSON _/!_

Or, the same without `await`, using pure promises syntax:

To get the response text, `await response.text()` instead of `.json()`:

\`\`\`js run async let response = await fetch(‘https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits’);

let text = await response.text(); // read response body as text

alert(text.slice(0, 80) + ‘…’); \`\`\`

As a show-case for reading in binary format, let’s fetch and show a logo image of [“fetch” specification](https://fetch.spec.whatwg.org) (see chapter [Blob](info:blob) for details about operations on `Blob`):

\`\`\`js async run let response = await fetch(‘/article/fetch/logo-fetch.svg’);

_!_ let blob = await response.blob(); // download as Blob object _/!_

// create for it let img = document.createElement(‘img’); img.style = ‘position:fixed;top:10px;left:10px;width:100px’; document.body.append(img);

// show it img.src = URL.createObjectURL(blob);

setTimeout(() =&gt; { // hide after three seconds img.remove(); URL.revokeObjectURL(img.src); }, 3000); \`\`\`

    We can choose only one body-reading method.

    If we've already got the response with `response.text()`, then `response.json()` won't work, as the body content has already been processed.

    ```js
    let text = await response.text(); // response body consumed
    let parsed = await response.json(); // fails (already consumed)
    ```

## Response headers

The response headers are available in a Map-like headers object in `response.headers`.

It’s not exactly a Map, but it has similar methods to get individual headers by name or iterate over them:

\`\`\`js run async let response = await fetch(‘https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits’);

// get one header alert(response.headers.get(‘Content-Type’)); // application/json; charset=utf-8

// iterate over all headers for (let \[key, value\] of response.headers) { alert(`${key} = ${value}`); } \`\`\`

## Request headers

To set a request header in `fetch`, we can use the `headers` option. It has an object with outgoing headers, like this:

    let response = fetch(protectedUrl, {
      headers: {
        Authentication: 'secret'
      }
    });

…But there’s a list of [forbidden HTTP headers](https://fetch.spec.whatwg.org/#forbidden-header-name) that we can’t set:

- `Accept-Charset`, `Accept-Encoding`
- `Access-Control-Request-Headers`
- `Access-Control-Request-Method`
- `Connection`
- `Content-Length`
- `Cookie`, `Cookie2`
- `Date`
- `DNT`
- `Expect`
- `Host`
- `Keep-Alive`
- `Origin`
- `Referer`
- `TE`
- `Trailer`
- `Transfer-Encoding`
- `Upgrade`
- `Via`
- `Proxy-*`
- `Sec-*`

These headers ensure proper and safe HTTP, so they are controlled exclusively by the browser.

## POST requests

To make a `POST` request, or a request with another method, we need to use `fetch` options:

- **`method`** – HTTP-method, e.g. `POST`,
- **`body`** – the request body, one of:
  - a string (e.g. JSON-encoded),
  - `FormData` object, to submit the data as `form/multipart`,
  - `Blob`/`BufferSource` to send binary data,
  - [URLSearchParams](info:url), to submit the data in `x-www-form-urlencoded` encoding, rarely used.

The JSON format is used most of the time.

For example, this code submits `user` object as JSON:

\`\`\`js run async let user = { name: ‘John’, surname: ‘Smith’ };

_!_ let response = await fetch(‘/article/fetch/post/user’, { method: ‘POST’, headers: { ‘Content-Type’: ‘application/json;charset=utf-8’ }, body: JSON.stringify(user) }); _/!_

let result = await response.json(); alert(result.message); \`\`\`

Please note, if the request `body` is a string, then `Content-Type` header is set to `text/plain;charset=UTF-8` by default.

But, as we’re going to send JSON, we use `headers` option to send `application/json` instead, the correct `Content-Type` for JSON-encoded data.

## Sending an image

We can also submit binary data with `fetch` using `Blob` or `BufferSource` objects.

In this example, there’s a `<canvas>` where we can draw by moving a mouse over it. A click on the “submit” button sends the image to the server:

\`\`\`html run autorun height=“90”

\`\`\`

Please note, here we don’t set `Content-Type` header manually, because a `Blob` object has a built-in type (here `image/png`, as generated by `toBlob`). For `Blob` objects that type becomes the value of `Content-Type`.

The `submit()` function can be rewritten without `async/await` like this:

    function submit() {
      canvasElem.toBlob(function(blob) {
        fetch('/article/fetch/post/image', {
          method: 'POST',
          body: blob
        })
          .then(response => response.json())
          .then(result => alert(JSON.stringify(result, null, 2)))
      }, 'image/png');
    }

## Summary

A typical fetch request consists of two `await` calls:

    let response = await fetch(url, options); // resolves with response headers
    let result = await response.json(); // read body as json

Or, without `await`:

    fetch(url, options)
      .then(response => response.json())
      .then(result => /* process result */)

Response properties: - `response.status` – HTTP code of the response, - `response.ok` – `true` is the status is 200-299. - `response.headers` – Map-like object with HTTP headers.

Methods to get response body: - **`response.text()`** – return the response as text, - **`response.json()`** – parse the response as JSON object, - **`response.formData()`** – return the response as `FormData` object (form/multipart encoding, see the next chapter), - **`response.blob()`** – return the response as [Blob](info:blob) (binary data with type), - **`response.arrayBuffer()`** – return the response as [ArrayBuffer](info:arraybuffer-binary-arrays) (low-level binary data),

Fetch options so far: - `method` – HTTP-method, - `headers` – an object with request headers (not any header is allowed), - `body` – the data to send (request body) as `string`, `FormData`, `BufferSource`, `Blob` or `UrlSearchParams` object.

In the next chapters we’ll see more options and use cases of `fetch`.

# FormData

This chapter is about sending HTML forms: with or without files, with additional fields and so on.

[FormData](https://xhr.spec.whatwg.org/#interface-formdata) objects can help with that. As you might have guessed, it’s the object to represent HTML form data.

The constructor is:

    let formData = new FormData([form]);

If HTML `form` element is provided, it automatically captures its fields.

The special thing about `FormData` is that network methods, such as `fetch`, can accept a `FormData` object as a body. It’s encoded and sent out with `Content-Type: multipart/form-data`.

From the server point of view, that looks like a usual form submission.

## Sending a simple form

Let’s send a simple form first.

As you can see, that’s almost one-liner:

\`\`\`html run autorun

\`\`\`

In this example, the server code is not presented, as it’s beyond our scope. The server accepts the POST request and replies “User saved”.

## FormData Methods

We can modify fields in `FormData` with methods:

- `formData.append(name, value)` - add a form field with the given `name` and `value`,
- `formData.append(name, blob, fileName)` - add a field as if it were `<input type="file">`, the third argument `fileName` sets file name (not form field name), as it were a name of the file in user’s filesystem,
- `formData.delete(name)` - remove the field with the given `name`,
- `formData.get(name)` - get the value of the field with the given `name`,
- `formData.has(name)` - if there exists a field with the given `name`, returns `true`, otherwise `false`

A form is technically allowed to have many fields with the same `name`, so multiple calls to `append` add more same-named fields.

There’s also method `set`, with the same syntax as `append`. The difference is that `.set` removes all fields with the given `name`, and then appends a new field. So it makes sure there’s only one field with such `name`, the rest is just like `append`:

- `formData.set(name, value)`,
- `formData.set(name, blob, fileName)`.

Also we can iterate over formData fields using `for..of` loop:

\`\`\`js run let formData = new FormData(); formData.append(‘key1’, ‘value1’); formData.append(‘key2’, ‘value2’);

// List key/value pairs for(let \[name, value\] of formData) { alert(`${name} = ${value}`); // key1 = value1, then key2 = value2 } \`\`\`

## Sending a form with a file

The form is always sent as `Content-Type: multipart/form-data`, this encoding allows to send files. So, `<input type="file">` fields are sent also, similar to a usual form submission.

Here’s an example with such form:

\`\`\`html run autorun

Picture:

\`\`\`

## Sending a form with Blob data

As we’ve seen in the chapter <a href="info:fetch" class="uri">info:fetch</a>, it’s easy to send dynamically generated binary data e.g. an image, as `Blob`. We can supply it directly as `fetch` parameter `body`.

In practice though, it’s often convenient to send an image not separately, but as a part of the form, with additional fields, such as “name” and other metadata.

Also, servers are usually more suited to accept multipart-encoded forms, rather than raw binary data.

This example submits an image from `<canvas>`, along with some other fields, as a form, using `FormData`:

\`\`\`html run autorun height=“90”

\`\`\`

Please note how the image `Blob` is added:

    formData.append("image", imageBlob, "image.png");

That’s same as if there were `<input type="file" name="image">` in the form, and the visitor submitted a file named `"image.png"` (3rd argument) with the data `imageBlob` (2nd argument) from their filesystem.

The server reads form data and the file, as if it were a regular form submission.

## Summary

[FormData](https://xhr.spec.whatwg.org/#interface-formdata) objects are used to capture HTML form and submit it using `fetch` or another network method.

We can either create `new FormData(form)` from an HTML form, or create a object without a form at all, and then append fields with methods:

- `formData.append(name, value)`
- `formData.append(name, blob, fileName)`
- `formData.set(name, value)`
- `formData.set(name, blob, fileName)`

Let’s note two peculiarities here:

1.  The `set` method removes fields with the same name, `append` doesn’t. That’s the only difference between them.
2.  To send a file, 3-argument syntax is needed, the last argument is a file name, that normally is taken from user filesystem for `<input type="file">`.

Other methods are:

- `formData.delete(name)`
- `formData.get(name)`
- `formData.has(name)`

That’s it!

# Fetch: Download progress

The `fetch` method allows to track _download_ progress.

Please note: there’s currently no way for `fetch` to track _upload_ progress. For that purpose, please use [XMLHttpRequest](info:xmlhttprequest), we’ll cover it later.

To track download progress, we can use `response.body` property. It’s `ReadableStream` – a special object that provides body chunk-by-chunk, as it comes. Readable streams are described in the [Streams API](https://streams.spec.whatwg.org/#rs-class) specification.

Unlike `response.text()`, `response.json()` and other methods, `response.body` gives full control over the reading process, and we can count how much is consumed at any moment.

Here’s the sketch of code that reads the response from `response.body`:

    // instead of response.json() and other methods
    const reader = response.body.getReader();

    // infinite loop while the body is downloading
    while(true) {
      // done is true for the last chunk
      // value is Uint8Array of the chunk bytes
      const {done, value} = await reader.read();

      if (done) {
        break;
      }

      console.log(`Received ${value.length} bytes`)
    }

The result of `await reader.read()` call is an object with two properties: - **`done`** – `true` when the reading is complete, otherwise `false`. - **`value`** – a typed array of bytes: `Uint8Array`.

    Streams API also describes asynchronous iteration over `ReadableStream` with `for await..of` loop, but it's not yet widely supported (see [browser issues](https://github.com/whatwg/streams/issues/778#issuecomment-461341033)), so we use `while` loop.

We receive response chunks in the loop, until the loading finishes, that is: until `done` becomes `true`.

To log the progress, we just need for every received fragment `value` to add its length to the counter.

Here’s the full working example that gets the response and logs the progress in console, more explanations to follow:

\`\`\`js run async // Step 1: start the fetch and obtain a reader let response = await fetch(‘https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits?per\_page=100’);

const reader = response.body.getReader();

// Step 2: get total length const contentLength = +response.headers.get(‘Content-Length’);

// Step 3: read the data let receivedLength = 0; // received that many bytes at the moment let chunks = \[\]; // array of received binary chunks (comprises the body) while(true) { const {done, value} = await reader.read();

if (done) { break; }

chunks.push(value); receivedLength += value.length;

console.log(`Received ${receivedLength} of ${contentLength}`) }

// Step 4: concatenate chunks into single Uint8Array let chunksAll = new Uint8Array(receivedLength); // (4.1) let position = 0; for(let chunk of chunks) { chunksAll.set(chunk, position); // (4.2) position += chunk.length; }

// Step 5: decode into a string let result = new TextDecoder(“utf-8”).decode(chunksAll);

Let’s explain that step-by-step:

1.  We perform `fetch` as usual, but instead of calling `response.json()`, we obtain a stream reader `response.body.getReader()`.

    Please note, we can’t use both these methods to read the same response: either use a reader or a response method to get the result.

2.  Prior to reading, we can figure out the full response length from the `Content-Length` header.

    It may be absent for cross-origin requests (see chapter <a href="info:fetch-crossorigin" class="uri">info:fetch-crossorigin</a>) and, well, technically a server doesn’t have to set it. But usually it’s at place.

3.  Call `await reader.read()` until it’s done.

    We gather response chunks in the array `chunks`. That’s important, because after the response is consumed, we won’t be able to “re-read” it using `response.json()` or another way (you can try, there’ll be an error).

4.  At the end, we have `chunks` – an array of `Uint8Array` byte chunks. We need to join them into a single result. Unfortunately, there’s no single method that concatenates those, so there’s some code to do that:
    1.  We create `chunksAll = new Uint8Array(receivedLength)` – a same-typed array with the combined length.
    2.  Then use `.set(chunk, position)` method to copy each `chunk` one after another in it.
5.  We have the result in `chunksAll`. It’s a byte array though, not a string.

    To create a string, we need to interpret these bytes. The built-in [TextDecoder](info:text-decoder) does exactly that. Then we can `JSON.parse` it, if necessary.

    What if we need binary content instead of a string? That’s even simpler. Replace steps 4 and 5 with a single line that creates a `Blob` from all chunks: `js let blob = new Blob(chunks);`

At the end we have the result (as a string or a blob, whatever is convenient), and progress-tracking in the process.

Once again, please note, that’s not for _upload_ progress (no way now with `fetch`), only for _download_ progress.

Also, if the size is unknown, we should check `receivedLength` in the loop and break it once it reaches a certain limit. So that the `chunks` won’t overflow the memory.

# Fetch: Abort

As we know, `fetch` returns a promise. And JavaScript generally has no concept of “aborting” a promise. So how can we cancel an ongoing `fetch`? E.g. if the user actions on our site indicate that the `fetch` isn’t needed any more.

There’s a special built-in object for such purposes: `AbortController`. It can be used to abort not only `fetch`, but other asynchronous tasks as well.

The usage is very straightforward:

## The AbortController object

Create a controller:

    let controller = new AbortController();

A controller is an extremely simple object.

- It has a single method `abort()`,
- And a single property `signal` that allows to set event listeners on it.

When `abort()` is called: - `controller.signal` emits the `"abort"` event. - `controller.signal.aborted` property becomes `true`.

Generally, we have two parties in the process: 1. The one that performs a cancelable operation, it sets a listener on `controller.signal`. 2. The one that cancels: it calls `controller.abort()` when needed.

Here’s the full example (without `fetch` yet):

\`\`\`js run let controller = new AbortController(); let signal = controller.signal;

// The party that performs a cancelable operation // gets the “signal” object // and sets the listener to trigger when controller.abort() is called signal.addEventListener(‘abort’, () =&gt; alert(“abort!”));

// The other party, that cancels (at any point later): controller.abort(); // abort!

// The event triggers and signal.aborted becomes true alert(signal.aborted); // true \`\`\`

As we can see, `AbortController` is just a mean to pass `abort` events when `abort()` is called on it.

We could implement the same kind of event listening in our code on our own, without the `AbortController` object.

But what’s valuable is that `fetch` knows how to work with the `AbortController` object. It’s integrated in it.

## Using with fetch

To be able to cancel `fetch`, pass the `signal` property of an `AbortController` as a `fetch` option:

    let controller = new AbortController();
    fetch(url, {
      signal: controller.signal
    });

The `fetch` method knows how to work with `AbortController`. It will listen to `abort` events on `signal`.

Now, to abort, call `controller.abort()`:

    controller.abort();

We’re done: `fetch` gets the event from `signal` and aborts the request.

When a fetch is aborted, its promise rejects with an error `AbortError`, so we should handle it, e.g. in `try..catch`.

Here’s the full example with `fetch` aborted after 1 second:

\`\`\`js run async // abort in 1 second let controller = new AbortController(); setTimeout(() =&gt; controller.abort(), 1000);

try { let response = await fetch(‘/article/fetch-abort/demo/hang’, { signal: controller.signal }); } catch(err) { if (err.name == ‘AbortError’) { // handle abort() alert(“Aborted!”); } else { throw err; } } \`\`\`

## AbortController is scalable

`AbortController` is scalable. It allows to cancel multiple fetches at once.

Here’s a sketch of code that fetches many `urls` in parallel, and uses a single controller to abort them all:

    let urls = [...]; // a list of urls to fetch in parallel

    let controller = new AbortController();

    // an array of fetch promises
    let fetchJobs = urls.map(url => fetch(url, {
      signal: controller.signal
    }));

    let results = await Promise.all(fetchJobs);

    // if controller.abort() is called from anywhere,
    // it aborts all fetches

If we have our own asynchronous tasks, different from `fetch`, we can use a single `AbortController` to stop those, together with fetches.

We just need to listen to its `abort` event in our tasks:

    let urls = [...];
    let controller = new AbortController();

    let ourJob = new Promise((resolve, reject) => { // our task
      ...
      controller.signal.addEventListener('abort', reject);
    });

    let fetchJobs = urls.map(url => fetch(url, { // fetches
      signal: controller.signal
    }));

    // Wait for fetches and our task in parallel
    let results = await Promise.all([...fetchJobs, ourJob]);

    // if controller.abort() is called from anywhere,
    // it aborts all fetches and ourJob

## Summary

- `AbortController` is a simple object that generates an `abort` event on it’s `signal` property when the `abort()` method is called (and also sets `signal.aborted` to `true`).
- `fetch` integrates with it: we pass the `signal` property as the option, and then `fetch` listens to it, so it’s possible to abort the `fetch`.
- We can use `AbortController` in our code. The “call `abort()`” -&gt; “listen to `abort` event” interaction is simple and universal. We can use it even without `fetch`. \# Fetch: Cross-Origin Requests

If we send a `fetch` request to another web-site, it will probably fail.

For instance, let’s try fetching `http://example.com`:

`js run async try { await fetch('http://example.com'); } catch(err) { alert(err); // Failed to fetch }`

Fetch fails, as expected.

The core concept here is _origin_ – a domain/port/protocol triplet.

Cross-origin requests – those sent to another domain (even a subdomain) or protocol or port – require special headers from the remote side.

That policy is called “CORS”: Cross-Origin Resource Sharing.

## Why is CORS needed? A brief history

CORS exists to protect the internet from evil hackers.

Seriously. Let’s make a very brief historical digression.

**For many years a script from one site could not access the content of another site.**

That simple, yet powerful rule was a foundation of the internet security. E.g. an evil script from website `hacker.com` could not access the user’s mailbox at website `gmail.com`. People felt safe.

JavaScript also did not have any special methods to perform network requests at that time. It was a toy language to decorate a web page.

But web developers demanded more power. A variety of tricks were invented to work around the limitation and make requests to other websites.

### Using forms

One way to communicate with another server was to submit a `<form>` there. People submitted it into `<iframe>`, just to stay on the current page, like this:

    <!-- form target -->
    *!*
    <iframe name="iframe"></iframe>
    */!*

    <!-- a form could be dynamically generated and submited by JavaScript -->
    *!*
    <form target="iframe" method="POST" action="http://another.com/…">
    */!*
      ...
    </form>

So, it was possible to make a GET/POST request to another site, even without networking methods, as forms can send data anywhere. But as it’s forbidden to access the content of an `<iframe>` from another site, it wasn’t possible to read the response.

To be precise, there were actually tricks for that, they required special scripts at both the iframe and the page. So the communication with the iframe was technically possible. Right now there’s no point to go into details, let these dinosaurs rest in peace.

### Using scripts

Another trick was to use a `script` tag. A script could have any `src`, with any domain, like `<script src="http://another.com/…">`. It’s possible to execute a script from any website.

If a website, e.g. `another.com` intended to expose data for this kind of access, then a so-called “JSONP (JSON with padding)” protocol was used.

Here’s how it worked.

Let’s say we, at our site, need to get the data from `http://another.com`, such as the weather:

1.  First, in advance, we declare a global function to accept the data, e.g. `gotWeather`.

        // 1. Declare the function to process the weather data
        function gotWeather({ temperature, humidity }) {
          alert(`temperature: ${temperature}, humidity: ${humidity}`);
        }

2.  Then we make a `<script>` tag with `src="http://another.com/weather.json?callback=gotWeather"`, using the name of our function as the `callback` URL-parameter.

        let script = document.createElement('script');
        script.src = `http://another.com/weather.json?callback=gotWeather`;
        document.body.append(script);

3.  The remote server `another.com` dynamically generates a script that calls `gotWeather(...)` with the data it wants us to receive. `js // The expected answer from the server looks like this: gotWeather({ temperature: 25, humidity: 78 });`
4.  When the remote script loads and executes, `gotWeather` runs, and, as it’s our function, we have the data.

That works, and doesn’t violate security, because both sides agreed to pass the data this way. And, when both sides agree, it’s definitely not a hack. There are still services that provide such access, as it works even for very old browsers.

After a while, networking methods appeared in browser JavaScript.

At first, cross-origin requests were forbidden. But as a result of long discussions, cross-origin requests were allowed, but with any new capabilities requiring an explicit allowance by the server, expressed in special headers.

## Safe requests

There are two types of cross-origin requests:

1.  Safe requests.
2.  All the others.

Safe Requests are simpler to make, so let’s start with them.

A request is safe if it satisfies two conditions:

1.  [Safe method](https://fetch.spec.whatwg.org/#cors-safelisted-method): GET, POST or HEAD
2.  [Safe headers](https://fetch.spec.whatwg.org/#cors-safelisted-request-header) – the only allowed custom headers are:
    - `Accept`,
    - `Accept-Language`,
    - `Content-Language`,
    - `Content-Type` with the value `application/x-www-form-urlencoded`, `multipart/form-data` or `text/plain`.

Any other request is considered “unsafe”. For instance, a request with `PUT` method or with an `API-Key` HTTP-header does not fit the limitations.

**The essential difference is that a safe request can be made with a `<form>` or a `<script>`, without any special methods.**

So, even a very old server should be ready to accept a safe request.

Contrary to that, requests with non-standard headers or e.g. method `DELETE` can’t be created this way. For a long time JavaScript was unable to do such requests. So an old server may assume that such requests come from a privileged source, “because a webpage is unable to send them”.

When we try to make a unsafe request, the browser sends a special “preflight” request that asks the server – does it agree to accept such cross-origin requests, or not?

And, unless the server explicitly confirms that with headers, an unsafe request is not sent.

Now we’ll go into details.

## CORS for safe requests

If a request is cross-origin, the browser always adds the `Origin` header to it.

For instance, if we request `https://anywhere.com/request` from `https://javascript.info/page`, the headers will look like:

    GET /request
    Host: anywhere.com
    *!*
    Origin: https://javascript.info
    */!*
    ...

As you can see, the `Origin` header contains exactly the origin (domain/protocol/port), without a path.

The server can inspect the `Origin` and, if it agrees to accept such a request, add a special header `Access-Control-Allow-Origin` to the response. That header should contain the allowed origin (in our case `https://javascript.info`), or a star `*`. Then the response is successful, otherwise it’s an error.

The browser plays the role of a trusted mediator here: 1. It ensures that the correct `Origin` is sent with a cross-origin request. 2. It checks for permitting `Access-Control-Allow-Origin` in the response, if it exists, then JavaScript is allowed to access the response, otherwise it fails with an error.

![](xhr-another-domain.svg)

Here’s an example of a permissive server response:

    200 OK
    Content-Type:text/html; charset=UTF-8
    *!*
    Access-Control-Allow-Origin: https://javascript.info
    */!*

## Response headers

For cross-origin request, by default JavaScript may only access so-called “safe” response headers:

- `Cache-Control`
- `Content-Language`
- `Content-Type`
- `Expires`
- `Last-Modified`
- `Pragma`

Accessing any other response header causes an error.

    There's no `Content-Length` header in the list!

    This header contains the full response length. So, if we're downloading something and would like to track the percentage of progress, then an additional permission is required to access that header (see below).

To grant JavaScript access to any other response header, the server must send the `Access-Control-Expose-Headers` header. It contains a comma-separated list of unsafe header names that should be made accessible.

For example:

    200 OK
    Content-Type:text/html; charset=UTF-8
    Content-Length: 12345
    API-Key: 2c9de507f2c54aa1
    Access-Control-Allow-Origin: https://javascript.info
    *!*
    Access-Control-Expose-Headers: Content-Length,API-Key
    */!*

With such an `Access-Control-Expose-Headers` header, the script is allowed to read the `Content-Length` and `API-Key` headers of the response.

## “Unsafe” requests

We can use any HTTP-method: not just `GET/POST`, but also `PATCH`, `DELETE` and others.

Some time ago no one could even imagine that a webpage could make such requests. So there may still exist webservices that treat a non-standard method as a signal: “That’s not a browser”. They can take it into account when checking access rights.

So, to avoid misunderstandings, any “unsafe” request – that couldn’t be done in the old times, the browser does not make such requests right away. First, it sends a preliminary, so-called “preflight” request, to ask for permission.

A preflight request uses the method `OPTIONS`, no body and two headers:

- `Access-Control-Request-Method` header has the method of the unsafe request.
- `Access-Control-Request-Headers` header provides a comma-separated list of its unsafe HTTP-headers.

If the server agrees to serve the requests, then it should respond with empty body, status 200 and headers:

- `Access-Control-Allow-Origin` must be either `*` or the requesting origin, such as `https://javascript.info`, to allow it.
- `Access-Control-Allow-Methods` must have the allowed method.
- `Access-Control-Allow-Headers` must have a list of allowed headers.
- Additionally, the header `Access-Control-Max-Age` may specify a number of seconds to cache the permissions. So the browser won’t have to send a preflight for subsequent requests that satisfy given permissions.

![](xhr-preflight.svg)

Let’s see how it works step-by-step on the example of a cross-origin `PATCH` request (this method is often used to update data):

    let response = await fetch('https://site.com/service.json', {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        'API-Key': 'secret'
      }
    });

There are three reasons why the request is unsafe (one is enough): - Method `PATCH` - `Content-Type` is not one of: `application/x-www-form-urlencoded`, `multipart/form-data`, `text/plain`. - “Unsafe” `API-Key` header.

### Step 1 (preflight request)

Prior to sending such a request, the browser, on its own, sends a preflight request that looks like this:

    OPTIONS /service.json
    Host: site.com
    Origin: https://javascript.info
    Access-Control-Request-Method: PATCH
    Access-Control-Request-Headers: Content-Type,API-Key

- Method: `OPTIONS`.
- The path – exactly the same as the main request: `/service.json`.
- Cross-origin special headers:
  - `Origin` – the source origin.
  - `Access-Control-Request-Method` – requested method.
  - `Access-Control-Request-Headers` – a comma-separated list of “unsafe” headers.

### Step 2 (preflight response)

The server should respond with status 200 and the headers: - `Access-Control-Allow-Origin: https://javascript.info` - `Access-Control-Allow-Methods: PATCH` - `Access-Control-Allow-Headers: Content-Type,API-Key`.

That allows future communication, otherwise an error is triggered.

If the server expects other methods and headers in the future, it makes sense to allow them in advance by adding them to the list.

For example, this response also allows `PUT`, `DELETE` and additional headers:

    200 OK
    Access-Control-Allow-Origin: https://javascript.info
    Access-Control-Allow-Methods: PUT,PATCH,DELETE
    Access-Control-Allow-Headers: API-Key,Content-Type,If-Modified-Since,Cache-Control
    Access-Control-Max-Age: 86400

Now the browser can see that `PATCH` is in `Access-Control-Allow-Methods` and `Content-Type,API-Key` are in the list `Access-Control-Allow-Headers`, so it sends out the main request.

If there’s the header `Access-Control-Max-Age` with a number of seconds, then the preflight permissions are cached for the given time. The response above will be cached for 86400 seconds (one day). Within this timeframe, subsequent requests will not cause a preflight. Assuming that they fit the cached allowances, they will be sent directly.

### Step 3 (actual request)

When the preflight is successful, the browser now makes the main request. The process here is the same as for safe requests.

The main request has the `Origin` header (because it’s cross-origin):

    PATCH /service.json
    Host: site.com
    Content-Type: application/json
    API-Key: secret
    Origin: https://javascript.info

### Step 4 (actual response)

The server should not forget to add `Access-Control-Allow-Origin` to the main response. A successful preflight does not relieve from that:

    Access-Control-Allow-Origin: https://javascript.info

Then JavaScript is able to read the main server response.

    Preflight request occurs "behind the scenes", it's invisible to JavaScript.

    JavaScript only gets the response to the main request or an error if there's no server permission.

## Credentials

A cross-origin request initiated by JavaScript code by default does not bring any credentials (cookies or HTTP authentication).

That’s uncommon for HTTP-requests. Usually, a request to `http://site.com` is accompanied by all cookies from that domain. Cross-origin requests made by JavaScript methods on the other hand are an exception.

For example, `fetch('http://another.com')` does not send any cookies, even those (!) that belong to `another.com` domain.

Why?

That’s because a request with credentials is much more powerful than without them. If allowed, it grants JavaScript the full power to act on behalf of the user and access sensitive information using their credentials.

Does the server really trust the script that much? Then it must explicitly allow requests with credentials with an additional header.

To send credentials in `fetch`, we need to add the option `credentials: "include"`, like this:

    fetch('http://another.com', {
      credentials: "include"
    });

Now `fetch` sends cookies originating from `another.com` with request to that site.

If the server agrees to accept the request _with credentials_, it should add a header `Access-Control-Allow-Credentials: true` to the response, in addition to `Access-Control-Allow-Origin`.

For example:

    200 OK
    Access-Control-Allow-Origin: https://javascript.info
    Access-Control-Allow-Credentials: true

Please note: `Access-Control-Allow-Origin` is prohibited from using a star `*` for requests with credentials. Like shown above, it must provide the exact origin there. That’s an additional safety measure, to ensure that the server really knows who it trusts to make such requests.

## Summary

From the browser point of view, there are two kinds of cross-origin requests: “safe” and all the others.

“Safe” requests must satisfy the following conditions: - Method: GET, POST or HEAD. - Headers – we can set only: - `Accept` - `Accept-Language` - `Content-Language` - `Content-Type` to the value `application/x-www-form-urlencoded`, `multipart/form-data` or `text/plain`.

The essential difference is that safe requests were doable since ancient times using `<form>` or `<script>` tags, while unsafe were impossible for browsers for a long time.

So, the practical difference is that safe requests are sent right away, with the `Origin` header, while for the other ones the browser makes a preliminary “preflight” request, asking for permission.

**For safe requests:**

- → The browser sends the `Origin` header with the origin.
- ← For requests without credentials (not sent by default), the server should set:
  - `Access-Control-Allow-Origin` to `*` or same value as `Origin`
- ← For requests with credentials, the server should set:
  - `Access-Control-Allow-Origin` to same value as `Origin`
  - `Access-Control-Allow-Credentials` to `true`

Additionally, to grant JavaScript access to any response headers except `Cache-Control`, `Content-Language`, `Content-Type`, `Expires`, `Last-Modified` or `Pragma`, the server should list the allowed ones in `Access-Control-Expose-Headers` header.

**For unsafe requests, a preliminary “preflight” request is issued before the requested one:**

- → The browser sends an `OPTIONS` request to the same URL, with the headers:
  - `Access-Control-Request-Method` has requested method.
  - `Access-Control-Request-Headers` lists unsafe requested headers.
- ← The server should respond with status 200 and the headers:
  - `Access-Control-Allow-Methods` with a list of allowed methods,
  - `Access-Control-Allow-Headers` with a list of allowed headers,
  - `Access-Control-Max-Age` with a number of seconds to cache the permissions.
- Then the actual request is sent, and the previous “safe” scheme is applied.

# Fetch API

So far, we know quite a bit about `fetch`.

Let’s see the rest of API, to cover all its abilities.

    Please note: most of these options are used rarely. You may skip this chapter and still use `fetch` well.

    Still, it's good to know what `fetch` can do, so if the need arises, you can return and read the details.

Here’s the full list of all possible `fetch` options with their default values (alternatives in comments):

    let promise = fetch(url, {
      method: "GET", // POST, PUT, DELETE, etc.
      headers: {
        // the content type header value is usually auto-set
        // depending on the request body
        "Content-Type": "text/plain;charset=UTF-8"
      },
      body: undefined // string, FormData, Blob, BufferSource, or URLSearchParams
      referrer: "about:client", // or "" to send no Referer header,
      // or an url from the current origin
      referrerPolicy: "no-referrer-when-downgrade", // no-referrer, origin, same-origin...
      mode: "cors", // same-origin, no-cors
      credentials: "same-origin", // omit, include
      cache: "default", // no-store, reload, no-cache, force-cache, or only-if-cached
      redirect: "follow", // manual, error
      integrity: "", // a hash, like "sha256-abcdef1234567890"
      keepalive: false, // true
      signal: undefined, // AbortController to abort request
      window: window // null
    });

An impressive list, right?

We fully covered `method`, `headers` and `body` in the chapter <a href="info:fetch" class="uri">info:fetch</a>.

The `signal` option is covered in <a href="info:fetch-abort" class="uri">info:fetch-abort</a>.

Now let’s explore the remaining capabilities.

## referrer, referrerPolicy

These options govern how `fetch` sets the HTTP `Referer` header.

Usually that header is set automatically and contains the url of the page that made the request. In most scenarios, it’s not important at all, sometimes, for security purposes, it makes sense to remove or shorten it.

**The `referrer` option allows to set any `Referer` (within the current origin) or remove it.**

To send no referer, set an empty string:

    fetch('/page', {
    *!*
      referrer: "" // no Referer header
    */!*
    });

To set another url within the current origin:

    fetch('/page', {
      // assuming we're on https://javascript.info
      // we can set any Referer header, but only within the current origin
    *!*
      referrer: "https://javascript.info/anotherpage"
    */!*
    });

**The `referrerPolicy` option sets general rules for `Referer`.**

Requests are split into 3 types:

1.  Request to the same origin.
2.  Request to another origin.
3.  Request from HTTPS to HTTP (from safe to unsafe protocol).

Unlike the `referrer` option that allows to set the exact `Referer` value, `referrerPolicy` tells the browser general rules for each request type.

Possible values are described in the [Referrer Policy specification](https://w3c.github.io/webappsec-referrer-policy/):

- **`"no-referrer-when-downgrade"`** – the default value: full `Referer` is always sent, unless we send a request from HTTPS to HTTP (to the less secure protocol).
- **`"no-referrer"`** – never send `Referer`.
- **`"origin"`** – only send the origin in `Referer`, not the full page URL, e.g. only `http://site.com` instead of `http://site.com/path`.
- **`"origin-when-cross-origin"`** – send the full `Referer` to the same origin, but only the origin part for cross-origin requests (as above).
- **`"same-origin"`** – send the full `Referer` to the same origin, but no `Referer` for cross-origin requests.
- **`"strict-origin"`** – send only the origin, not the `Referer` for HTTPS→HTTP requests.
- **`"strict-origin-when-cross-origin"`** – for same-origin send the full `Referer`, for cross-origin send only the origin, unless it’s HTTPS→HTTP request, then send nothing.
- **`"unsafe-url"`** – always send the full url in `Referer`, even for HTTPS→HTTP requests.

Here’s a table with all combinations:

<table><thead><tr class="header"><th>Value</th><th>To same origin</th><th>To another origin</th><th>HTTPS→HTTP</th></tr></thead><tbody><tr class="odd"><td><code>"no-referrer"</code></td><td>-</td><td>-</td><td>-</td></tr><tr class="even"><td><code>"no-referrer-when-downgrade"</code> or <code>""</code> (default)</td><td>full</td><td>full</td><td>-</td></tr><tr class="odd"><td><code>"origin"</code></td><td>origin</td><td>origin</td><td>origin</td></tr><tr class="even"><td><code>"origin-when-cross-origin"</code></td><td>full</td><td>origin</td><td>origin</td></tr><tr class="odd"><td><code>"same-origin"</code></td><td>full</td><td>-</td><td>-</td></tr><tr class="even"><td><code>"strict-origin"</code></td><td>origin</td><td>origin</td><td>-</td></tr><tr class="odd"><td><code>"strict-origin-when-cross-origin"</code></td><td>full</td><td>origin</td><td>-</td></tr><tr class="even"><td><code>"unsafe-url"</code></td><td>full</td><td>full</td><td>full</td></tr></tbody></table>

Let’s say we have an admin zone with a URL structure that shouldn’t be known from outside of the site.

If we send a `fetch`, then by default it always sends the `Referer` header with the full url of our page (except when we request from HTTPS to HTTP, then no `Referer`).

E.g. `Referer: https://javascript.info/admin/secret/paths`.

If we’d like other websites know only the origin part, not the URL-path, we can set the option:

    fetch('https://another.com/page', {
      // ...
      referrerPolicy: "origin-when-cross-origin" // Referer: https://javascript.info
    });

We can put it to all `fetch` calls, maybe integrate into JavaScript library of our project that does all requests and uses `fetch` inside.

Its only difference compared to the default behavior is that for requests to another origin `fetch` sends only the origin part of the URL (e.g. `https://javascript.info`, without path). For requests to our origin we still get the full `Referer` (maybe useful for debugging purposes).

\`\``smart header="Referrer policy is not only for`fetch`" Referrer policy, described in the [specification](https://w3c.github.io/webappsec-referrer-policy/), is not just for`fetch\`, but more global.

In particular, it’s possible to set the default policy for the whole page using the `Referrer-Policy` HTTP header, or per-link, with `<a rel="noreferrer">`. \`\`\`

## mode

The `mode` option is a safe-guard that prevents occasional cross-origin requests:

- **`"cors"`** – the default, cross-origin requests are allowed, as described in <a href="info:fetch-crossorigin" class="uri">info:fetch-crossorigin</a>,
- **`"same-origin"`** – cross-origin requests are forbidden,
- **`"no-cors"`** – only safe cross-origin requests are allowed.

This option may be useful when the URL for `fetch` comes from a 3rd-party, and we want a “power off switch” to limit cross-origin capabilities.

## credentials

The `credentials` option specifies whether `fetch` should send cookies and HTTP-Authorization headers with the request.

- **`"same-origin"`** – the default, don’t send for cross-origin requests,
- **`"include"`** – always send, requires `Accept-Control-Allow-Credentials` from cross-origin server in order for JavaScript to access the response, that was covered in the chapter <a href="info:fetch-crossorigin" class="uri">info:fetch-crossorigin</a>,
- **`"omit"`** – never send, even for same-origin requests.

## cache

By default, `fetch` requests make use of standard HTTP-caching. That is, it respects the `Expires` and `Cache-Control` headers, sends `If-Modified-Since` and so on. Just like regular HTTP-requests do.

The `cache` options allows to ignore HTTP-cache or fine-tune its usage:

- **`"default"`** – `fetch` uses standard HTTP-cache rules and headers,
- **`"no-store"`** – totally ignore HTTP-cache, this mode becomes the default if we set a header `If-Modified-Since`, `If-None-Match`, `If-Unmodified-Since`, `If-Match`, or `If-Range`,
- **`"reload"`** – don’t take the result from HTTP-cache (if any), but populate the cache with the response (if the response headers permit this action),
- **`"no-cache"`** – create a conditional request if there is a cached response, and a normal request otherwise. Populate HTTP-cache with the response,
- **`"force-cache"`** – use a response from HTTP-cache, even if it’s stale. If there’s no response in HTTP-cache, make a regular HTTP-request, behave normally,
- **`"only-if-cached"`** – use a response from HTTP-cache, even if it’s stale. If there’s no response in HTTP-cache, then error. Only works when `mode` is `"same-origin"`.

## redirect

Normally, `fetch` transparently follows HTTP-redirects, like 301, 302 etc.

The `redirect` option allows to change that:

- **`"follow"`** – the default, follow HTTP-redirects,
- **`"error"`** – error in case of HTTP-redirect,
- **`"manual"`** – allows to process HTTP-redirects manually. In case of redirect, we’ll get a special response object, with `response.type="opaqueredirect"` and zeroed/empty status and most other properies.

## integrity

The `integrity` option allows to check if the response matches the known-ahead checksum.

As described in the [specification](https://w3c.github.io/webappsec-subresource-integrity/), supported hash-functions are SHA-256, SHA-384, and SHA-512, there might be others depending on the browser.

For example, we’re downloading a file, and we know that it’s SHA-256 checksum is “abcdef” (a real checksum is longer, of course).

We can put it in the `integrity` option, like this:

    fetch('http://site.com/file', {
      integrity: 'sha256-abcdef'
    });

Then `fetch` will calculate SHA-256 on its own and compare it with our string. In case of a mismatch, an error is triggered.

## keepalive

The `keepalive` option indicates that the request may “outlive” the webpage that initiated it.

For example, we gather statistics on how the current visitor uses our page (mouse clicks, page fragments he views), to analyze and improve the user experience.

When the visitor leaves our page – we’d like to save the data to our server.

We can use the `window.onunload` event for that:

`js run window.onunload = function() { fetch('/analytics', { method: 'POST', body: "statistics", *!* keepalive: true */!* }); };`

Normally, when a document is unloaded, all associated network requests are aborted. But the `keepalive` option tells the browser to perform the request in the background, even after it leaves the page. So this option is essential for our request to succeed.

It has a few limitations:

- We can’t send megabytes: the body limit for `keepalive` requests is 64KB.
  - If we need to gather a lot of statistics about the visit, we should send it out regularly in packets, so that there won’t be a lot left for the last `onunload` request.
  - This limit applies to all `keepalive` requests together. In other words, we can perform multiple `keepalive` requests in parallel, but the sum of their body lengths should not exceed 64KB.
- We can’t handle the server response if the document is unloaded. So in our example `fetch` will succeed due to `keepalive`, but subsequent functions won’t work.
  - In most cases, such as sending out statistics, it’s not a problem, as the server just accepts the data and usually sends an empty response to such requests.

# URL objects

The built-in [URL](https://url.spec.whatwg.org/#api) class provides a convenient interface for creating and parsing URLs.

There are no networking methods that require exactly a `URL` object, strings are good enough. So technically we don’t have to use `URL`. But sometimes it can be really helpful.

## Creating a URL

The syntax to create a new `URL` object:

    new URL(url, [base])

- **`url`** – the full URL or only path (if base is set, see below),
- **`base`** – an optional base URL: if set and `url` argument has only path, then the URL is generated relative to `base`.

For example:

    let url = new URL('https://javascript.info/profile/admin');

These two URLs are same:

\`\`\`js run let url1 = new URL(‘https://javascript.info/profile/admin’); let url2 = new URL(‘/profile/admin’, ‘https://javascript.info’);

alert(url1); // https://javascript.info/profile/admin alert(url2); // https://javascript.info/profile/admin \`\`\`

We can easily create a new URL based on the path relative to an existing URL:

\`\`\`js run let url = new URL(‘https://javascript.info/profile/admin’); let newUrl = new URL(‘tester’, url);

alert(newUrl); // https://javascript.info/profile/tester \`\`\`

The `URL` object immediately allows us to access its components, so it’s a nice way to parse the url, e.g.:

\`\`\`js run let url = new URL(‘https://javascript.info/url’);

alert(url.protocol); // https: alert(url.host); // javascript.info alert(url.pathname); // /url \`\`\`

Here’s the cheatsheet for URL components:

![](url-object.svg)

- `href` is the full url, same as `url.toString()`
- `protocol` ends with the colon character `:`
- `search` - a string of parameters, starts with the question mark `?`
- `hash` starts with the hash character `#`
- there may be also `user` and `password` properties if HTTP authentication is present: `http://login:password@site.com` (not painted above, rarely used).

\`\``smart header="We can pass`URL`objects to networking (and most other) methods instead of a string" We can use a`URL`object in`fetch`or`XMLHttpRequest\`, almost everywhere where a URL-string is expected.

Generally, the `URL` object can be passed to any method instead of a string, as most methods will perform the string conversion, that turns a `URL` object into a string with full URL. \`\`\`

## SearchParams “?…”

Let’s say we want to create a url with given search params, for instance, `https://google.com/search?query=JavaScript`.

We can provide them in the URL string:

    new URL('https://google.com/search?query=JavaScript')

…But parameters need to be encoded if they contain spaces, non-latin letters, etc (more about that below).

So there’s a URL property for that: `url.searchParams`, an object of type [URLSearchParams](https://url.spec.whatwg.org/#urlsearchparams).

It provides convenient methods for search parameters:

- **`append(name, value)`** – add the parameter by `name`,
- **`delete(name)`** – remove the parameter by `name`,
- **`get(name)`** – get the parameter by `name`,
- **`getAll(name)`** – get all parameters with the same `name` (that’s possible, e.g. `?user=John&user=Pete`),
- **`has(name)`** – check for the existence of the parameter by `name`,
- **`set(name, value)`** – set/replace the parameter,
- **`sort()`** – sort parameters by name, rarely needed,
- …and it’s also iterable, similar to `Map`.

An example with parameters that contain spaces and punctuation marks:

\`\`\`js run let url = new URL(‘https://google.com/search’);

url.searchParams.set(‘q’, ‘test me!’); // added parameter with a space and !

alert(url); // https://google.com/search?q=test+me%21

url.searchParams.set(‘tbs’, ‘qdr:y’); // added parameter with a colon :

// parameters are automatically encoded alert(url); // https://google.com/search?q=test+me%21&tbs=qdr%3Ay

// iterate over search parameters (decoded) for(let \[name, value\] of url.searchParams) { alert(`${name}=${value}`); // q=test me!, then tbs=qdr:y } \`\`\`

## Encoding

There’s a standard [RFC3986](https://tools.ietf.org/html/rfc3986) that defines which characters are allowed in URLs and which are not.

Those that are not allowed, must be encoded, for instance non-latin letters and spaces - replaced with their UTF-8 codes, prefixed by `%`, such as `%20` (a space can be encoded by `+`, for historical reasons, but that’s an exception).

The good news is that `URL` objects handle all that automatically. We just supply all parameters unencoded, and then convert the `URL` to string:

\`\`\`js run // using some cyrillic characters for this example

let url = new URL(‘https://ru.wikipedia.org/wiki/Тест’);

url.searchParams.set(‘key’, ‘ъ’); alert(url); //https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D1%81%D1%82?key=%D1%8A

    As you can see, both `Тест` in the url path and `ъ` in the parameter are encoded.

    The URL became longer, because each cyrillic letter is represented with two bytes in UTF-8, so there are two `%..` entities.

    ### Encoding strings

    In old times, before `URL` objects appeared, people used strings for URLs.

    As of now, `URL` objects are often more convenient, but strings can still be used as well. In many cases using a string makes the code shorter.

    If we use a string though, we need to encode/decode special characters manually.

    There are built-in functions for that:

    - [encodeURI](mdn:/JavaScript/Reference/Global_Objects/encodeURI) - encodes URL as a whole.
    - [decodeURI](mdn:/JavaScript/Reference/Global_Objects/decodeURI) - decodes it back.
    - [encodeURIComponent](mdn:/JavaScript/Reference/Global_Objects/encodeURIComponent) - encodes a URL component, such as a search parameter, or a hash, or a pathname.
    - [decodeURIComponent](mdn:/JavaScript/Reference/Global_Objects/decodeURIComponent) - decodes it back.

    A natural question is: "What's the difference between `encodeURIComponent` and `encodeURI`? When we should use either?"

    That's easy to understand if we look at the URL, that's split into components in the picture above:

https://site.com:8080/path/page?p1=v1&p2=v2\#hash \`\`\`

As we can see, characters such as `:`, `?`, `=`, `&`, `#` are allowed in URL.

…On the other hand, if we look at a single URL component, such as a search parameter, these characters must be encoded, not to break the formatting.

- `encodeURI` encodes only characters that are totally forbidden in URL.
- `encodeURIComponent` encodes same characters, and, in addition to them, characters `#`, `$`, `&`, `+`, `,`, `/`, `:`, `;`, `=`, `?` and `@`.

So, for a whole URL we can use `encodeURI`:

\`\`\`js run // using cyrillic characters in url path let url = encodeURI(‘http://site.com/привет’);

alert(url); // http://site.com/%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82 \`\`\`

…While for URL parameters we should use `encodeURIComponent` instead:

\`\`\`js run let music = encodeURIComponent(‘Rock&Roll’);

let url = `https://google.com/search?q=${music}`; alert(url); // https://google.com/search?q=Rock%26Roll \`\`\`

Compare it with `encodeURI`:

\`\`\`js run let music = encodeURI(‘Rock&Roll’);

let url = `https://google.com/search?q=${music}`; alert(url); // https://google.com/search?q=Rock&Roll \`\`\`

As we can see, `encodeURI` does not encode `&`, as this is a legit character in URL as a whole.

But we should encode `&` inside a search parameter, otherwise, we get `q=Rock&Roll` - that is actually `q=Rock` plus some obscure parameter `Roll`. Not as intended.

So we should use only `encodeURIComponent` for each search parameter, to correctly insert it in the URL string. The safest is to encode both name and value, unless we’re absolutely sure that it has only allowed characters.

\`\`\``smart header="Encoding difference compared to`URL`" Classes [URL](https://url.spec.whatwg.org/#url-class) and [URLSearchParams](https://url.spec.whatwg.org/#interface-urlsearchparams) are based on the latest URI specification: [RFC3986](https://tools.ietf.org/html/rfc3986), while`encode\*\` functions are based on the obsolete version [RFC2396](https://www.ietf.org/rfc/rfc2396.txt).

There are a few differences, e.g. IPv6 addresses are encoded differently:

\`\`\`js run // valid url with IPv6 address let url = ‘http://\[2607:f8b0:4005:802::1007\]/’;

alert(encodeURI(url)); // http://%5B2607:f8b0:4005:802::1007%5D/ alert(new URL(url)); // http://\[2607:f8b0:4005:802::1007\]/

    As we can see, `encodeURI` replaced square brackets `[...]`, that's not correct, the reason is: IPv6 urls did not exist at the time of RFC2396 (August 1998).

    Such cases are rare, `encode*` functions work well most of the time.

# XMLHttpRequest

`XMLHttpRequest` is a built-in browser object that allows to make HTTP requests in JavaScript.

Despite of having the word “XML” in its name, it can operate on any data, not only in XML format. We can upload/download files, track progress and much more.

Right now, there’s another, more modern method `fetch`, that somewhat deprecates `XMLHttpRequest`.

In modern web-development `XMLHttpRequest` is used for three reasons:

1.  Historical reasons: we need to support existing scripts with `XMLHttpRequest`.
2.  We need to support old browsers, and don’t want polyfills (e.g. to keep scripts tiny).
3.  We need something that `fetch` can’t do yet, e.g. to track upload progress.

Does that sound familiar? If yes, then all right, go on with `XMLHttpRequest`. Otherwise, please head on to <a href="info:fetch" class="uri">info:fetch</a>.

## The basics

XMLHttpRequest has two modes of operation: synchronous and asynchronous.

Let’s see the asynchronous first, as it’s used in the majority of cases.

To do the request, we need 3 steps:

1.  Create `XMLHttpRequest`: `js let xhr = new XMLHttpRequest();` The constructor has no arguments.

2.  Initialize it, usually right after `new XMLHttpRequest`: `js xhr.open(method, URL, [async, user, password])`

    This method specifies the main parameters of the request:

    - `method` – HTTP-method. Usually `"GET"` or `"POST"`.
    - `URL` – the URL to request, a string, can be [URL](info:url) object.
    - `async` – if explicitly set to `false`, then the request is synchronous, we’ll cover that a bit later.
    - `user`, `password` – login and password for basic HTTP auth (if required).

    Please note that `open` call, contrary to its name, does not open the connection. It only configures the request, but the network activity only starts with the call of `send`.

3.  Send it out.

        xhr.send([body])

    This method opens the connection and sends the request to server. The optional `body` parameter contains the request body.

    Some request methods like `GET` do not have a body. And some of them like `POST` use `body` to send the data to the server. We’ll see examples of that later.

4.  Listen to `xhr` events for response.

    These three events are the most widely used:

    - `load` – when the request is complete (even if HTTP status is like 400 or 500), and the response is fully downloaded.
    - `error` – when the request couldn’t be made, e.g. network down or invalid URL.
    - `progress` – triggers periodically while the response is being downloaded, reports how much has been downloaded.

      xhr.onload = function() {
      alert(`Loaded: ${xhr.status} ${xhr.response}`);
      };

      xhr.onerror = function() { // only triggers if the request couldn't be made at all
      alert(`Network Error`);
      };

      xhr.onprogress = function(event) { // triggers periodically
      // event.loaded - how many bytes downloaded
      // event.lengthComputable = true if the server sent Content-Length header
      // event.total - total number of bytes (if lengthComputable)
      alert(`Received ${event.loaded} of ${event.total}`);
      };

Here’s a full example. The code below loads the URL at `/article/xmlhttprequest/example/load` from the server and prints the progress:

\`\`\`js run // 1. Create a new XMLHttpRequest object let xhr = new XMLHttpRequest();

// 2. Configure it: GET-request for the URL /article/…/load xhr.open(‘GET’, ‘/article/xmlhttprequest/example/load’);

// 3. Send the request over the network xhr.send();

// 4. This will be called after the response is received xhr.onload = function() { if (xhr.status != 200) { // analyze HTTP status of the response alert(`Error ${xhr.status}: ${xhr.statusText}`); // e.g. 404: Not Found } else { // show the result alert(`Done, got ${xhr.response.length} bytes`); // response is the server response } };

xhr.onprogress = function(event) { if (event.lengthComputable) { alert(`Received ${event.loaded} of ${event.total} bytes`); } else { alert(`Received ${event.loaded} bytes`); // no Content-Length }

};

xhr.onerror = function() { alert(“Request failed”); }; \`\`\`

Once the server has responded, we can receive the result in the following `xhr` properties:

`status`  
HTTP status code (a number): `200`, `404`, `403` and so on, can be `0` in case of a non-HTTP failure.

`statusText`  
HTTP status message (a string): usually `OK` for `200`, `Not Found` for `404`, `Forbidden` for `403` and so on.

`response` (old scripts may use `responseText`)  
The server response body.

We can also specify a timeout using the corresponding property:

    xhr.timeout = 10000; // timeout in ms, 10 seconds

If the request does not succeed within the given time, it gets canceled and `timeout` event triggers.

\`\`\``smart header="URL search parameters" To add parameters to URL, like`?name=value\`, and ensure the proper encoding, we can use [URL](info:url) object:

    let url = new URL('https://google.com/search');
    url.searchParams.set('q', 'test me!');

    // the parameter 'q' is encoded
    xhr.open('GET', url); // https://google.com/search?q=test+me%21

\`\`\`\`

## Response Type

We can use `xhr.responseType` property to set the response format:

- `""` (default) – get as string,
- `"text"` – get as string,
- `"arraybuffer"` – get as `ArrayBuffer` (for binary data, see chapter <a href="info:arraybuffer-binary-arrays" class="uri">info:arraybuffer-binary-arrays</a>),
- `"blob"` – get as `Blob` (for binary data, see chapter <a href="info:blob" class="uri">info:blob</a>),
- `"document"` – get as XML document (can use XPath and other XML methods) or HTML document (based on the MIME type of the received data),
- `"json"` – get as JSON (parsed automatically).

For example, let’s get the response as JSON:

\`\`\`js run let xhr = new XMLHttpRequest();

xhr.open(‘GET’, ‘/article/xmlhttprequest/example/json’);

_!_ xhr.responseType = ‘json’; _/!_

xhr.send();

// the response is {“message”: “Hello, world!”} xhr.onload = function() { let responseObj = xhr.response; alert(responseObj.message); // Hello, world! }; \`\`\`

    In the old scripts you may also find `xhr.responseText` and even `xhr.responseXML` properties.

    They exist for historical reasons, to get either a string or XML document. Nowadays, we should set the format in `xhr.responseType` and get `xhr.response` as demonstrated above.

## Ready states

`XMLHttpRequest` changes between states as it progresses. The current state is accessible as `xhr.readyState`.

All states, as in [the specification](https://xhr.spec.whatwg.org/#states):

    UNSENT = 0; // initial state
    OPENED = 1; // open called
    HEADERS_RECEIVED = 2; // response headers received
    LOADING = 3; // response is loading (a data packet is received)
    DONE = 4; // request complete

An `XMLHttpRequest` object travels them in the order `0` -&gt; `1` -&gt; `2` -&gt; `3` -&gt; … -&gt; `3` -&gt; `4`. State `3` repeats every time a data packet is received over the network.

We can track them using `readystatechange` event:

    xhr.onreadystatechange = function() {
      if (xhr.readyState == 3) {
        // loading
      }
      if (xhr.readyState == 4) {
        // request finished
      }
    };

You can find `readystatechange` listeners in really old code, it’s there for historical reasons, as there was a time when there were no `load` and other events. Nowadays, `load/error/progress` handlers deprecate it.

## Aborting request

We can terminate the request at any time. The call to `xhr.abort()` does that:

    xhr.abort(); // terminate the request

That triggers `abort` event, and `xhr.status` becomes `0`.

## Synchronous requests

If in the `open` method the third parameter `async` is set to `false`, the request is made synchronously.

In other words, JavaScript execution pauses at `send()` and resumes when the response is received. Somewhat like `alert` or `prompt` commands.

Here’s the rewritten example, the 3rd parameter of `open` is `false`:

    let xhr = new XMLHttpRequest();

    xhr.open('GET', '/article/xmlhttprequest/hello.txt', *!*false*/!*);

    try {
      xhr.send();
      if (xhr.status != 200) {
        alert(`Error ${xhr.status}: ${xhr.statusText}`);
      } else {
        alert(xhr.response);
      }
    } catch(err) { // instead of onerror
      alert("Request failed");
    }

It might look good, but synchronous calls are used rarely, because they block in-page JavaScript till the loading is complete. In some browsers it becomes impossible to scroll. If a synchronous call takes too much time, the browser may suggest to close the “hanging” webpage.

Many advanced capabilities of `XMLHttpRequest`, like requesting from another domain or specifying a timeout, are unavailable for synchronous requests. Also, as you can see, no progress indication.

Because of all that, synchronous requests are used very sparingly, almost never. We won’t talk about them any more.

## HTTP-headers

`XMLHttpRequest` allows both to send custom headers and read headers from the response.

There are 3 methods for HTTP-headers:

`setRequestHeader(name, value)`  
Sets the request header with the given `name` and `value`.

For instance:

    xhr.setRequestHeader('Content-Type', 'application/json');

\`\``warn header="Headers limitations" Several headers are managed exclusively by the browser, e.g.`Referer`and`Host\`. The full list is [in the specification](<https://xhr.spec.whatwg.org/#the-setrequestheader()-method>).

`XMLHttpRequest` is not allowed to change them, for the sake of user safety and correctness of the request. \`\`\`

\`\`\``warn header="Can't remove a header" Another peculiarity of`XMLHttpRequest`is that one can't undo`setRequestHeader\`.

Once the header is set, it’s set. Additional calls add information to the header, don’t overwrite it.

For instance:

    xhr.setRequestHeader('X-Auth', '123');
    xhr.setRequestHeader('X-Auth', '456');

    // the header will be:
    // X-Auth: 123, 456

\`\`\`\`

`getResponseHeader(name)`  
Gets the response header with the given `name` (except `Set-Cookie` and `Set-Cookie2`).

For instance:

    xhr.getResponseHeader('Content-Type')

`getAllResponseHeaders()`  
Returns all response headers, except `Set-Cookie` and `Set-Cookie2`.

Headers are returned as a single line, e.g.:

    Cache-Control: max-age=31536000
    Content-Length: 4260
    Content-Type: image/png
    Date: Sat, 08 Sep 2012 16:53:16 GMT

The line break between headers is always `"\r\n"` (doesn’t depend on OS), so we can easily split it into individual headers. The separator between the name and the value is always a colon followed by a space `": "`. That’s fixed in the specification.

So, if we want to get an object with name/value pairs, we need to throw in a bit JS.

Like this (assuming that if two headers have the same name, then the latter one overwrites the former one):

    let headers = xhr
      .getAllResponseHeaders()
      .split('\r\n')
      .reduce((result, current) => {
        let [name, value] = current.split(': ');
        result[name] = value;
        return result;
      }, {});

    // headers['Content-Type'] = 'image/png'

## POST, FormData

To make a POST request, we can use the built-in [FormData](mdn:api/FormData) object.

The syntax:

    let formData = new FormData([form]); // creates an object, optionally fill from <form>
    formData.append(name, value); // appends a field

We create it, optionally fill from a form, `append` more fields if needed, and then:

1.  `xhr.open('POST', ...)` – use `POST` method.
2.  `xhr.send(formData)` to submit the form to the server.

For instance:

\`\`\`html run refresh

\`\`\`

The form is sent with `multipart/form-data` encoding.

Or, if we like JSON more, then `JSON.stringify` and send as a string.

Just don’t forget to set the header `Content-Type: application/json`, many server-side frameworks automatically decode JSON with it:

    let xhr = new XMLHttpRequest();

    let json = JSON.stringify({
      name: "John",
      surname: "Smith"
    });

    xhr.open("POST", '/submit')
    xhr.setRequestHeader('Content-type', 'application/json; charset=utf-8');

    xhr.send(json);

The `.send(body)` method is pretty omnivore. It can send almost any `body`, including `Blob` and `BufferSource` objects.

## Upload progress

The `progress` event triggers only on the downloading stage.

That is: if we `POST` something, `XMLHttpRequest` first uploads our data (the request body), then downloads the response.

If we’re uploading something big, then we’re surely more interested in tracking the upload progress. But `xhr.onprogress` doesn’t help here.

There’s another object, without methods, exclusively to track upload events: `xhr.upload`.

It generates events, similar to `xhr`, but `xhr.upload` triggers them solely on uploading:

- `loadstart` – upload started.
- `progress` – triggers periodically during the upload.
- `abort` – upload aborted.
- `error` – non-HTTP error.
- `load` – upload finished successfully.
- `timeout` – upload timed out (if `timeout` property is set).
- `loadend` – upload finished with either success or error.

Example of handlers:

    xhr.upload.onprogress = function(event) {
      alert(`Uploaded ${event.loaded} of ${event.total} bytes`);
    };

    xhr.upload.onload = function() {
      alert(`Upload finished successfully.`);
    };

    xhr.upload.onerror = function() {
      alert(`Error during the upload: ${xhr.status}`);
    };

Here’s a real-life example: file upload with progress indication:

\`\`\`html run

\`\`\`

## Cross-origin requests

`XMLHttpRequest` can make cross-origin requests, using the same CORS policy as [fetch](info:fetch-crossorigin).

    let xhr = new XMLHttpRequest();
    *!*
    xhr.withCredentials = true;
    */!*

    xhr.open('POST', 'http://anywhere.com/request');
    ...

See the chapter <a href="info:fetch-crossorigin" class="uri">info:fetch-crossorigin</a> for details about cross-origin headers.

## Summary

Typical code of the GET-request with `XMLHttpRequest`:

    let xhr = new XMLHttpRequest();

    xhr.open('GET', '/my/url');

    xhr.send();

    xhr.onload = function() {
      if (xhr.status != 200) { // HTTP error?
        // handle error
        alert( 'Error: ' + xhr.status);
        return;
      }

      // get the response from xhr.response
    };

    xhr.onprogress = function(event) {
      // report progress
      alert(`Loaded ${event.loaded} of ${event.total}`);
    };

    xhr.onerror = function() {
      // handle non-HTTP error (e.g. network down)
    };

There are actually more events, the [modern specification](https://xhr.spec.whatwg.org/#events) lists them (in the lifecycle order):

- `loadstart` – the request has started.
- `progress` – a data packet of the response has arrived, the whole response body at the moment is in `response`.
- `abort` – the request was canceled by the call `xhr.abort()`.
- `error` – connection error has occurred, e.g. wrong domain name. Doesn’t happen for HTTP-errors like 404.
- `load` – the request has finished successfully.
- `timeout` – the request was canceled due to timeout (only happens if it was set).
- `loadend` – triggers after `load`, `error`, `timeout` or `abort`.

The `error`, `abort`, `timeout`, and `load` events are mutually exclusive. Only one of them may happen.

The most used events are load completion (`load`), load failure (`error`), or we can use a single `loadend` handler and check the properties of the request object `xhr` to see what happened.

We’ve already seen another event: `readystatechange`. Historically, it appeared long ago, before the specification settled. Nowadays, there’s no need to use it, we can replace it with newer events, but it can often be found in older scripts.

If we need to track uploading specifically, then we should listen to same events on `xhr.upload` object. \# Conditional branching: if, ‘?’

Sometimes, we need to perform different actions based on different conditions.

To do that, we can use the `if` statement and the conditional operator `?`, that’s also called a “question mark” operator.

## The “if” statement

The `if(...)` statement evaluates a condition in parentheses and, if the result is `true`, executes a block of code.

For example:

\`\`\`js run let year = prompt(‘In which year was ECMAScript-2015 specification published?’, ’’);

_!_ if (year == 2015) alert( ‘You are right!’ ); _/!_ \`\`\`

In the example above, the condition is a simple equality check (`year == 2015`), but it can be much more complex.

If we want to execute more than one statement, we have to wrap our code block inside curly braces:

    if (year == 2015) {
      alert( "That's correct!" );
      alert( "You're so smart!" );
    }

We recommend wrapping your code block with curly braces `{}` every time you use an `if` statement, even if there is only one statement to execute. Doing so improves readability.

## Boolean conversion

The `if (…)` statement evaluates the expression in its parentheses and converts the result to a boolean.

Let’s recall the conversion rules from the chapter <a href="info:type-conversions" class="uri">info:type-conversions</a>:

- A number `0`, an empty string `""`, `null`, `undefined`, and `NaN` all become `false`. Because of that they are called “falsy” values.
- Other values become `true`, so they are called “truthy”.

So, the code under this condition would never execute:

    if (0) { // 0 is falsy
      ...
    }

…and inside this condition – it always will:

    if (1) { // 1 is truthy
      ...
    }

We can also pass a pre-evaluated boolean value to `if`, like this:

    let cond = (year == 2015); // equality evaluates to true or false

    if (cond) {
      ...
    }

## The “else” clause

The `if` statement may contain an optional “else” block. It executes when the condition is falsy.

For example: \`\`\`js run let year = prompt(‘In which year was the ECMAScript-2015 specification published?’, ’’);

if (year == 2015) { alert( ‘You guessed it right!’ ); } else { alert( ‘How can you be so wrong?’ ); // any value except 2015 } \`\`\`

## Several conditions: “else if”

Sometimes, we’d like to test several variants of a condition. The `else if` clause lets us do that.

For example:

\`\`\`js run let year = prompt(‘In which year was the ECMAScript-2015 specification published?’, ’’);

if (year &lt; 2015) { alert( ‘Too early…’ ); } else if (year &gt; 2015) { alert( ‘Too late’ ); } else { alert( ‘Exactly!’ ); } \`\`\`

In the code above, JavaScript first checks `year < 2015`. If that is falsy, it goes to the next condition `year > 2015`. If that is also falsy, it shows the last `alert`.

There can be more `else if` blocks. The final `else` is optional.

## Conditional operator ‘?’

Sometimes, we need to assign a variable depending on a condition.

For instance:

\`\`\`js run no-beautify let accessAllowed; let age = prompt(‘How old are you?’, ’’);

_!_ if (age &gt; 18) { accessAllowed = true; } else { accessAllowed = false; } _/!_

alert(accessAllowed); \`\`\`

The so-called “conditional” or “question mark” operator lets us do that in a shorter and simpler way.

The operator is represented by a question mark `?`. Sometimes it’s called “ternary”, because the operator has three operands. It is actually the one and only operator in JavaScript which has that many.

The syntax is:

    let result = condition ? value1 : value2;

The `condition` is evaluated: if it’s truthy then `value1` is returned, otherwise – `value2`.

For example:

    let accessAllowed = (age > 18) ? true : false;

Technically, we can omit the parentheses around `age > 18`. The question mark operator has a low precedence, so it executes after the comparison `>`.

This example will do the same thing as the previous one:

    // the comparison operator "age > 18" executes first anyway
    // (no need to wrap it into parentheses)
    let accessAllowed = age > 18 ? true : false;

But parentheses make the code more readable, so we recommend using them.

    In the example above, you can avoid using the question mark operator because the comparison itself returns `true/false`:

    ```js
    // the same
    let accessAllowed = age > 18;
    ```

## Multiple ‘?’

A sequence of question mark operators `?` can return a value that depends on more than one condition.

For instance: \`\`\`js run let age = prompt(‘age?’, 18);

let message = (age &lt; 3) ? ‘Hi, baby!’ : (age &lt; 18) ? ‘Hello!’ : (age &lt; 100) ? ‘Greetings!’ : ‘What an unusual age!’;

alert( message ); \`\`\`

It may be difficult at first to grasp what’s going on. But after a closer look, we can see that it’s just an ordinary sequence of tests:

1.  The first question mark checks whether `age < 3`.
2.  If true – it returns `'Hi, baby!'`. Otherwise, it continues to the expression after the colon ‘“:”’, checking `age < 18`.
3.  If that’s true – it returns `'Hello!'`. Otherwise, it continues to the expression after the next colon ‘“:”’, checking `age < 100`.
4.  If that’s true – it returns `'Greetings!'`. Otherwise, it continues to the expression after the last colon ‘“:”’, returning `'What an unusual age!'`.

Here’s how this looks using `if..else`:

    if (age < 3) {
      message = 'Hi, baby!';
    } else if (age < 18) {
      message = 'Hello!';
    } else if (age < 100) {
      message = 'Greetings!';
    } else {
      message = 'What an unusual age!';
    }

## Non-traditional use of ‘?’

Sometimes the question mark `?` is used as a replacement for `if`:

\`\`\`js run no-beautify let company = prompt(‘Which company created JavaScript?’, ’’);

_!_ (company == ‘Netscape’) ? alert(‘Right!’) : alert(‘Wrong.’); _/!_ \`\`\`

Depending on the condition `company == 'Netscape'`, either the first or the second expression after the `?` gets executed and shows an alert.

We don’t assign a result to a variable here. Instead, we execute different code depending on the condition.

**It’s not recommended to use the question mark operator in this way.**

The notation is shorter than the equivalent `if` statement, which appeals to some programmers. But it is less readable.

Here is the same code using `if` for comparison:

\`\`\`js run no-beautify let company = prompt(‘Which company created JavaScript?’, ’’);

_!_ if (company == ‘Netscape’) { alert(‘Right!’); } else { alert(‘Wrong.’); } _/!_ \`\`\`

Our eyes scan the code vertically. Code blocks which span several lines are easier to understand than a long, horizontal instruction set.

The purpose of the question mark operator `?` is to return one value or another depending on its condition. Please use it for exactly that. Use `if` when you need to execute different branches of code. \# Resumable file upload

With `fetch` method it’s fairly easy to upload a file.

How to resume the upload after lost connection? There’s no built-in option for that, but we have the pieces to implement it.

Resumable uploads should come with upload progress indication, as we expect big files (if we may need to resume). So, as `fetch` doesn’t allow to track upload progress, we’ll use [XMLHttpRequest](info:xmlhttprequest).

## Not-so-useful progress event

To resume upload, we need to know how much was uploaded till the connection was lost.

There’s `xhr.upload.onprogress` to track upload progress.

Unfortunately, it won’t help us to resume the upload here, as it triggers when the data is _sent_, but was it received by the server? The browser doesn’t know.

Maybe it was buffered by a local network proxy, or maybe the remote server process just died and couldn’t process them, or it was just lost in the middle and didn’t reach the receiver.

That’s why this event is only useful to show a nice progress bar.

To resume upload, we need to know _exactly_ the number of bytes received by the server. And only the server can tell that, so we’ll make an additional request.

## Algorithm

1.  First, create a file id, to uniquely identify the file we’re going to upload: `js let fileId = file.name + '-' + file.size + '-' + file.lastModified;` That’s needed for resume upload, to tell the server what we’re resuming.

    If the name or the size or the last modification date changes, then there’ll be another `fileId`.

2.  Send a request to the server, asking how many bytes it already has, like this: \`\`\`js let response = await fetch(‘status’, { headers: { ‘X-File-Id’: fileId } });

    // The server has that many bytes let startByte = +await response.text(); \`\`\`

    This assumes that the server tracks file uploads by `X-File-Id` header. Should be implemented at server-side.

    If the file doesn’t yet exist at the server, then the server response should be `0`

3.  Then, we can use `Blob` method `slice` to send the file from `startByte`: \`\`\`js xhr.open(“POST”, “upload”, true);

    // File id, so that the server knows which file we upload xhr.setRequestHeader(‘X-File-Id’, fileId);

    // The byte we’re resuming from, so the server knows we’re resuming xhr.setRequestHeader(‘X-Start-Byte’, startByte);

    xhr.upload.onprogress = (e) =&gt; { console.log(`Uploaded ${startByte + e.loaded} of ${startByte + e.total}`); };

    // file can be from input.files\[0\] or another source xhr.send(file.slice(startByte)); \`\`\`

    Here we send the server both file id as `X-File-Id`, so it knows which file we’re uploading, and the starting byte as `X-Start-Byte`, so it knows we’re not uploading it initially, but resuming.

    The server should check its records, and if there was an upload of that file, and the current uploaded size is exactly `X-Start-Byte`, then append the data to it.

Here’s the demo with both client and server code, written on Node.js.

It works only partially on this site, as Node.js is behind another server named Nginx, that buffers uploads, passing them to Node.js when fully complete.

But you can download it and run locally for the full demonstration:

\[codetabs src=“upload-resume” height=200\]

As we can see, modern networking methods are close to file managers in their capabilities – control over headers, progress indicator, sending file parts, etc.

We can implement resumable upload and much more. \# Long polling

Long polling is the simplest way of having persistent connection with server, that doesn’t use any specific protocol like WebSocket or Server Side Events.

Being very easy to implement, it’s also good enough in a lot of cases.

## Regular Polling

The simplest way to get new information from the server is periodic polling. That is, regular requests to the server: “Hello, I’m here, do you have any information for me?”. For example, once every 10 seconds.

In response, the server first takes a notice to itself that the client is online, and second - sends a packet of messages it got till that moment.

That works, but there are downsides: 1. Messages are passed with a delay up to 10 seconds (between requests). 2. Even if there are no messages, the server is bombed with requests every 10 seconds, even if the user switched somewhere else or is asleep. That’s quite a load to handle, speaking performance-wise.

So, if we’re talking about a very small service, the approach may be viable, but generally, it needs an improvement.

## Long polling

So-called “long polling” is a much better way to poll the server.

It’s also very easy to implement, and delivers messages without delays.

The flow:

1.  A request is sent to the server.
2.  The server doesn’t close the connection until it has a message to send.
3.  When a message appears - the server responds to the request with it.
4.  The browser makes a new request immediately.

The situation when the browser sent a request and has a pending connection with the server, is standard for this method. Only when a message is delivered, the connection is reestablished.

![](long-polling.svg)

If the connection is lost, because of, say, a network error, the browser immediately sends a new request.

A sketch of client-side `subscribe` function that makes long requests:

    async function subscribe() {
      let response = await fetch("/subscribe");

      if (response.status == 502) {
        // Status 502 is a connection timeout error,
        // may happen when the connection was pending for too long,
        // and the remote server or a proxy closed it
        // let's reconnect
        await subscribe();
      } else if (response.status != 200) {
        // An error - let's show it
        showMessage(response.statusText);
        // Reconnect in one second
        await new Promise(resolve => setTimeout(resolve, 1000));
        await subscribe();
      } else {
        // Get and show the message
        let message = await response.text();
        showMessage(message);
        // Call subscribe() again to get the next message
        await subscribe();
      }
    }

    subscribe();

As you can see, `subscribe` function makes a fetch, then waits for the response, handles it and calls itself again.

\`\`\`warn header=“Server should be ok with many pending connections” The server architecture must be able to work with many pending connections.

Certain server architectures run one process per connection, resulting in there being as many processes as there are connections, while each process consumes quite a bit of memory. So, too many connections will just consume it all.

That’s often the case for backends written in languages like PHP and Ruby.

Servers written using Node.js usually don’t have such problems.

That said, it isn’t a programming language issue. Most modern languages, including PHP and Ruby allow to implement a proper backend. Just please make sure that your server architecture works fine with many simultaneous connections. \`\`\`

## Demo: a chat

Here’s a demo chat, you can also download it and run locally (if you’re familiar with Node.js and can install modules):

\[codetabs src=“longpoll” height=500\]

Browser code is in `browser.js`.

## Area of usage

Long polling works great in situations when messages are rare.

If messages come very often, then the chart of requesting-receiving messages, painted above, becomes saw-like.

Every message is a separate request, supplied with headers, authentication overhead, and so on.

So, in this case, another method is preferred, such as [Websocket](info:websocket) or [Server Sent Events](info:server-sent-events). \# WebSocket

The `WebSocket` protocol, described in the specification [RFC 6455](http://tools.ietf.org/html/rfc6455) provides a way to exchange data between browser and server via a persistent connection. The data can be passed in both directions as “packets”, without breaking the connection and additional HTTP-requests.

WebSocket is especially great for services that require continuous data exchange, e.g. online games, real-time trading systems and so on.

## A simple example

To open a websocket connection, we need to create `new WebSocket` using the special protocol `ws` in the url:

    let socket = new WebSocket("*!*ws*/!*://javascript.info");

There’s also encrypted `wss://` protocol. It’s like HTTPS for websockets.

\`\``smart header="Always prefer`wss://`" The`wss://\` protocol is not only encrypted, but also more reliable.

That’s because `ws://` data is not encrypted, visible for any intermediary. Old proxy servers do not know about WebSocket, they may see “strange” headers and abort the connection.

On the other hand, `wss://` is WebSocket over TLS, (same as HTTPS is HTTP over TLS), the transport security layer encrypts the data at sender and decrypts at the receiver. So data packets are passed encrypted through proxies. They can’t see what’s inside and let them through. \`\`\`

Once the socket is created, we should listen to events on it. There are totally 4 events: - **`open`** – connection established, - **`message`** – data received, - **`error`** – websocket error, - **`close`** – connection closed.

…And if we’d like to send something, then `socket.send(data)` will do that.

Here’s an example:

\`\`\`js run let socket = new WebSocket(“wss://javascript.info/article/websocket/demo/hello”);

socket.onopen = function(e) { alert(“\[open\] Connection established”); alert(“Sending to server”); socket.send(“My name is John”); };

socket.onmessage = function(event) { alert(`[message] Data received from server: ${event.data}`); };

socket.onclose = function(event) { if (event.wasClean) {  
alert(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`); } else { // e.g. server process killed or network down // event.code is usually 1006 in this case alert(‘\[close\] Connection died’); } };

socket.onerror = function(error) { alert(`[error] ${error.message}`); };

    For demo purposes, there's a small server [server.js](demo/server.js) written in Node.js, for the example above, running. It responds with "Hello from server, John", then waits 5 seconds and closes the connection.

    So you'll see events `open` -> `message` -> `close`.

    That's actually it, we can talk WebSocket already. Quite simple, isn't it?

    Now let's talk more in-depth.

    ## Opening a websocket

    When `new WebSocket(url)` is created, it starts connecting immediately.

    During the connection the browser (using headers) asks the server: "Do you support Websocket?" And if the server replies "yes", then the talk continues in WebSocket protocol, which is not HTTP at all.

    ![](websocket-handshake.svg)

    Here's an example of browser headers for request made by `new WebSocket("wss://javascript.info/chat")`.

GET /chat Host: javascript.info Origin: https://javascript.info Connection: Upgrade Upgrade: websocket Sec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q== Sec-WebSocket-Version: 13 \`\`\`

- `Origin` – the origin of the client page, e.g. `https://javascript.info`. WebSocket objects are cross-origin by nature. There are no special headers or other limitations. Old servers are unable to handle WebSocket anyway, so there are no compatibility issues. But `Origin` header is important, as it allows the server to decide whether or not to talk WebSocket with this website.
- `Connection: Upgrade` – signals that the client would like to change the protocol.
- `Upgrade: websocket` – the requested protocol is “websocket”.
- `Sec-WebSocket-Key` – a random browser-generated key for security.
- `Sec-WebSocket-Version` – WebSocket protocol version, 13 is the current one.

`` smart header="WebSocket handshake can't be emulated" We can't use `XMLHttpRequest` or `fetch` to make this kind of HTTP-request, because JavaScript is not allowed to set these headers. ``

If the server agrees to switch to WebSocket, it should send code 101 response:

    101 Switching Protocols
    Upgrade: websocket
    Connection: Upgrade
    Sec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=

Here `Sec-WebSocket-Accept` is `Sec-WebSocket-Key`, recoded using a special algorithm. The browser uses it to make sure that the response corresponds to the request.

Afterwards, the data is transfered using WebSocket protocol, we’ll see its structure (“frames”) soon. And that’s not HTTP at all.

### Extensions and subprotocols

There may be additional headers `Sec-WebSocket-Extensions` and `Sec-WebSocket-Protocol` that describe extensions and subprotocols.

For instance:

- `Sec-WebSocket-Extensions: deflate-frame` means that the browser supports data compression. An extension is something related to transferring the data, functionality that extends WebSocket protocol. The header `Sec-WebSocket-Extensions` is sent automatically by the browser, with the list of all extensions it supports.

- `Sec-WebSocket-Protocol: soap, wamp` means that we’d like to transfer not just any data, but the data in [SOAP](http://en.wikipedia.org/wiki/SOAP) or WAMP (“The WebSocket Application Messaging Protocol”) protocols. WebSocket subprotocols are registered in the [IANA catalogue](http://www.iana.org/assignments/websocket/websocket.xml). So, this header describes data formats that we’re going to use.

  This optional header is set using the second parameter of `new WebSocket`. That’s the array of subprotocols, e.g. if we’d like to use SOAP or WAMP:

      let socket = new WebSocket("wss://javascript.info/chat", ["soap", "wamp"]);

The server should respond with a list of protocols and extensions that it agrees to use.

For example, the request:

    GET /chat
    Host: javascript.info
    Upgrade: websocket
    Connection: Upgrade
    Origin: https://javascript.info
    Sec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==
    Sec-WebSocket-Version: 13
    *!*
    Sec-WebSocket-Extensions: deflate-frame
    Sec-WebSocket-Protocol: soap, wamp
    */!*

Response:

    101 Switching Protocols
    Upgrade: websocket
    Connection: Upgrade
    Sec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=
    *!*
    Sec-WebSocket-Extensions: deflate-frame
    Sec-WebSocket-Protocol: soap
    */!*

Here the server responds that it supports the extension “deflate-frame”, and only SOAP of the requested subprotocols.

## Data transfer

WebSocket communication consists of “frames” – data fragments, that can be sent from either side, and can be of several kinds:

- “text frames” – contain text data that parties send to each other.
- “binary data frames” – contain binary data that parties send to each other.
- “ping/pong frames” are used to check the connection, sent from the server, the browser responds to these automatically.
- there’s also “connection close frame” and a few other service frames.

In the browser, we directly work only with text or binary frames.

**WebSocket `.send()` method can send either text or binary data.**

A call `socket.send(body)` allows `body` in string or a binary format, including `Blob`, `ArrayBuffer`, etc. No settings required: just send it out in any format.

**When we receive the data, text always comes as string. And for binary data, we can choose between `Blob` and `ArrayBuffer` formats.**

That’s set by `socket.binaryType` property, it’s `"blob"` by default, so binary data comes as `Blob` objects.

[Blob](info:blob) is a high-level binary object, it directly integrates with `<a>`, `<img>` and other tags, so that’s a sane default. But for binary processing, to access individual data bytes, we can change it to `"arraybuffer"`:

    socket.binaryType = "arraybuffer";
    socket.onmessage = (event) => {
      // event.data is either a string (if text) or arraybuffer (if binary)
    };

## Rate limiting

Imagine, our app is generating a lot of data to send. But the user has a slow network connection, maybe on a mobile internet, outside of a city.

We can call `socket.send(data)` again and again. But the data will be buffered (stored) in memory and sent out only as fast as network speed allows.

The `socket.bufferedAmount` property stores how many bytes remain buffered at this moment, waiting to be sent over the network.

We can examine it to see whether the socket is actually available for transmission.

    // every 100ms examine the socket and send more data
    // only if all the existing data was sent out
    setInterval(() => {
      if (socket.bufferedAmount == 0) {
        socket.send(moreData());
      }
    }, 100);

## Connection close

Normally, when a party wants to close the connection (both browser and server have equal rights), they send a “connection close frame” with a numeric code and a textual reason.

The method for that is:

    socket.close([code], [reason]);

- `code` is a special WebSocket closing code (optional)
- `reason` is a string that describes the reason of closing (optional)

Then the other party in `close` event handler gets the code and the reason, e.g.:

    // closing party:
    socket.close(1000, "Work complete");

    // the other party
    socket.onclose = event => {
      // event.code === 1000
      // event.reason === "Work complete"
      // event.wasClean === true (clean close)
    };

Most common code values:

- `1000` – the default, normal closure (used if no `code` supplied),
- `1006` – no way to set such code manually, indicates that the connection was lost (no close frame).

There are other codes like:

- `1001` – the party is going away, e.g. server is shutting down, or a browser leaves the page,
- `1009` – the message is too big to process,
- `1011` – unexpected error on server,
- …and so on.

The full list can be found in [RFC6455, §7.4.1](https://tools.ietf.org/html/rfc6455#section-7.4.1).

WebSocket codes are somewhat like HTTP codes, but different. In particular, any codes less than `1000` are reserved, there’ll be an error if we try to set such a code.

    // in case connection is broken
    socket.onclose = event => {
      // event.code === 1006
      // event.reason === ""
      // event.wasClean === false (no closing frame)
    };

## Connection state

To get connection state, additionally there’s `socket.readyState` property with values:

- **`0`** – “CONNECTING”: the connection has not yet been established,
- **`1`** – “OPEN”: communicating,
- **`2`** – “CLOSING”: the connection is closing,
- **`3`** – “CLOSED”: the connection is closed.

## Chat example

Let’s review a chat example using browser WebSocket API and Node.js WebSocket module <a href="https://github.com/websockets/ws" class="uri">https://github.com/websockets/ws</a>. We’ll pay the main attention to the client side, but the server is also simple.

HTML: we need a `<form>` to send messages and a `<div>` for incoming messages:

    <!-- message form -->
    <form name="publish">
      <input type="text" name="message">
      <input type="submit" value="Send">
    </form>

    <!-- div with messages -->
    <div id="messages"></div>

From JavaScript we want three things: 1. Open the connection. 2. On form submission – `socket.send(message)` for the message. 3. On incoming message – append it to `div#messages`.

Here’s the code:

    let socket = new WebSocket("wss://javascript.info/article/websocket/chat/ws");

    // send message from the form
    document.forms.publish.onsubmit = function() {
      let outgoingMessage = this.message.value;

      socket.send(outgoingMessage);
      return false;
    };

    // message received - show the message in div#messages
    socket.onmessage = function(event) {
      let message = event.data;

      let messageElem = document.createElement('div');
      messageElem.textContent = message;
      document.getElementById('messages').prepend(messageElem);
    }

Server-side code is a little bit beyond our scope. Here we’ll use Node.js, but you don’t have to. Other platforms also have their means to work with WebSocket.

The server-side algorithm will be:

1.  Create `clients = new Set()` – a set of sockets.
2.  For each accepted websocket, add it to the set `clients.add(socket)` and setup `message` event listener to get its messages.
3.  When a message received: iterate over clients and send it to everyone.
4.  When a connection is closed: `clients.delete(socket)`.

    const ws = new require('ws');
    const wss = new ws.Server({noServer: true});

    const clients = new Set();

    http.createServer((req, res) => {
    // here we only handle websocket connections
    // in real project we'd have some other code here to handle non-websocket requests
    wss.handleUpgrade(req, req.socket, Buffer.alloc(0), onSocketConnect);
    });

    function onSocketConnect(ws) {
    clients.add(ws);

    ws.on('message', function(message) {
    message = message.slice(0, 50); // max message length will be 50

        for(let client of clients) {
          client.send(message);
        }

    });

    ws.on('close', function() {
    clients.delete(ws);
    });
    }

Here’s the working example:

\[iframe src=“chat” height=“100” zip\]

You can also download it (upper-right button in the iframe) and run locally. Just don’t forget to install [Node.js](https://nodejs.org/en/) and `npm install ws` before running.

## Summary

WebSocket is a modern way to have persistent browser-server connections.

- WebSockets don’t have cross-origin limitations.
- They are well-supported in browsers.
- Can send/receive strings and binary data.

The API is simple.

Methods: - `socket.send(data)`, - `socket.close([code], [reason])`.

Events: - `open`, - `message`, - `error`, - `close`.

WebSocket by itself does not include reconnection, authentication and many other high-level mechanisms. So there are client/server libraries for that, and it’s also possible to implement these capabilities manually.

Sometimes, to integrate WebSocket into existing project, people run WebSocket server in parallel with the main HTTP-server, and they share a single database. Requests to WebSocket use `wss://ws.site.com`, a subdomain that leads to WebSocket server, while `https://site.com` goes to the main HTTP-server.

Surely, other ways of integration are also possible. \# Server Sent Events

The [Server-Sent Events](https://html.spec.whatwg.org/multipage/comms.html#the-eventsource-interface) specification describes a built-in class `EventSource`, that keeps connection with the server and allows to receive events from it.

Similar to `WebSocket`, the connection is persistent.

But there are several important differences:

<table style="width:99%;"><colgroup><col style="width: 46%" /><col style="width: 53%" /></colgroup><thead><tr class="header"><th><code>WebSocket</code></th><th><code>EventSource</code></th></tr></thead><tbody><tr class="odd"><td>Bi-directional: both client and server can exchange messages</td><td>One-directional: only server sends data</td></tr><tr class="even"><td>Binary and text data</td><td>Only text</td></tr><tr class="odd"><td>WebSocket protocol</td><td>Regular HTTP</td></tr></tbody></table>

`EventSource` is a less-powerful way of communicating with the server than `WebSocket`.

Why should one ever use it?

The main reason: it’s simpler. In many applications, the power of `WebSocket` is a little bit too much.

We need to receive a stream of data from server: maybe chat messages or market prices, or whatever. That’s what `EventSource` is good at. Also it supports auto-reconnect, something we need to implement manually with `WebSocket`. Besides, it’s a plain old HTTP, not a new protocol.

## Getting messages

To start receiving messages, we just need to create `new EventSource(url)`.

The browser will connect to `url` and keep the connection open, waiting for events.

The server should respond with status 200 and the header `Content-Type: text/event-stream`, then keep the connection and write messages into it in the special format, like this:

    data: Message 1

    data: Message 2

    data: Message 3
    data: of two lines

- A message text goes after `data:`, the space after the colon is optional.
- Messages are delimited with double line breaks `\n\n`.
- To send a line break `\n`, we can immediately send one more `data:` (3rd message above).

In practice, complex messages are usually sent JSON-encoded. Line-breaks are encoded as `\n` within them, so multiline `data:` messages are not necessary.

For instance:

    data: {"user":"John","message":"First line*!*\n*/!* Second line"}

…So we can assume that one `data:` holds exactly one message.

For each such message, the `message` event is generated:

    let eventSource = new EventSource("/events/subscribe");

    eventSource.onmessage = function(event) {
      console.log("New message", event.data);
      // will log 3 times for the data stream above
    };

    // or eventSource.addEventListener('message', ...)

### Cross-origin requests

`EventSource` supports cross-origin requests, like `fetch` and any other networking methods. We can use any URL:

    let source = new EventSource("https://another-site.com/events");

The remote server will get the `Origin` header and must respond with `Access-Control-Allow-Origin` to proceed.

To pass credentials, we should set the additional option `withCredentials`, like this:

    let source = new EventSource("https://another-site.com/events", {
      withCredentials: true
    });

Please see the chapter <a href="info:fetch-crossorigin" class="uri">info:fetch-crossorigin</a> for more details about cross-origin headers.

## Reconnection

Upon creation, `new EventSource` connects to the server, and if the connection is broken – reconnects.

That’s very convenient, as we don’t have to care about it.

There’s a small delay between reconnections, a few seconds by default.

The server can set the recommended delay using `retry:` in response (in milliseconds):

    retry: 15000
    data: Hello, I set the reconnection delay to 15 seconds

The `retry:` may come both together with some data, or as a standalone message.

The browser should wait that many milliseconds before reconnecting. Or longer, e.g. if the browser knows (from OS) that there’s no network connection at the moment, it may wait until the connection appears, and then retry.

- If the server wants the browser to stop reconnecting, it should respond with HTTP status 204.
- If the browser wants to close the connection, it should call `eventSource.close()`:

  let eventSource = new EventSource(...);

  eventSource.close();

Also, there will be no reconnection if the response has an incorrect `Content-Type` or its HTTP status differs from 301, 307, 200 and 204. In such cases the `"error"` event will be emitted, and the browser won’t reconnect.

    When a connection is finally closed, there's no way to "reopen" it. If we'd like to connect again, just create a new `EventSource`.

## Message id

When a connection breaks due to network problems, either side can’t be sure which messages were received, and which weren’t.

To correctly resume the connection, each message should have an `id` field, like this:

    data: Message 1
    id: 1

    data: Message 2
    id: 2

    data: Message 3
    data: of two lines
    id: 3

When a message with `id:` is received, the browser:

- Sets the property `eventSource.lastEventId` to its value.
- Upon reconnection sends the header `Last-Event-ID` with that `id`, so that the server may re-send following messages.

`` smart header="Put `id:` after `data:`" Please note: the `id` is appended below message `data` by the server, to ensure that `lastEventId` is updated after the message is received. ``

## Connection status: readyState

The `EventSource` object has `readyState` property, that has one of three values:

`js no-beautify EventSource.CONNECTING = 0; // connecting or reconnecting EventSource.OPEN = 1; // connected EventSource.CLOSED = 2; // connection closed`

When an object is created, or the connection is down, it’s always `EventSource.CONNECTING` (equals `0`).

We can query this property to know the state of `EventSource`.

## Event types

By default `EventSource` object generates three events:

- `message` – a message received, available as `event.data`.
- `open` – the connection is open.
- `error` – the connection could not be established, e.g. the server returned HTTP 500 status.

The server may specify another type of event with `event: ...` at the event start.

For example:

    event: join
    data: Bob

    data: Hello

    event: leave
    data: Bob

To handle custom events, we must use `addEventListener`, not `onmessage`:

    eventSource.addEventListener('join', event => {
      alert(`Joined ${event.data}`);
    });

    eventSource.addEventListener('message', event => {
      alert(`Said: ${event.data}`);
    });

    eventSource.addEventListener('leave', event => {
      alert(`Left ${event.data}`);
    });

## Full example

Here’s the server that sends messages with `1`, `2`, `3`, then `bye` and breaks the connection.

Then the browser automatically reconnects.

\[codetabs src=“eventsource”\]

## Summary

`EventSource` object automatically establishes a persistent connection and allows the server to send messages over it.

It offers: - Automatic reconnect, with tunable `retry` timeout. - Message ids to resume events, the last received identifier is sent in `Last-Event-ID` header upon reconnection. - The current state is in the `readyState` property.

That makes `EventSource` a viable alternative to `WebSocket`, as the latter is more low-level and lacks such built-in features (though they can be implemented).

In many real-life applications, the power of `EventSource` is just enough.

Supported in all modern browsers (not IE).

The syntax is:

    let source = new EventSource(url, [credentials]);

The second argument has only one possible option: `{ withCredentials: true }`, it allows sending cross-origin credentials.

Overall cross-origin security is same as for `fetch` and other network methods.

### Properties of an `EventSource` object

`readyState`  
The current connection state: either `EventSource.CONNECTING (=0)`, `EventSource.OPEN (=1)` or `EventSource.CLOSED (=2)`.

`lastEventId`  
The last received `id`. Upon reconnection the browser sends it in the header `Last-Event-ID`.

### Methods

`close()`  
Closes the connection.

### Events

`message`  
Message received, the data is in `event.data`.

`open`  
The connection is established.

`error`  
In case of an error, including both lost connection (will auto-reconnect) and fatal errors. We can check `readyState` to see if the reconnection is being attempted.

The server may set a custom event name in `event:`. Such events should be handled using `addEventListener`, not `on<event>`.

### Server response format

The server sends messages, delimited by `\n\n`.

A message may have following fields:

- `data:` – message body, a sequence of multiple `data` is interpreted as a single message, with `\n` between the parts.
- `id:` – renews `lastEventId`, sent in `Last-Event-ID` on reconnect.
- `retry:` – recommends a retry delay for reconnections in ms. There’s no way to set it from JavaScript.
- `event:` – event name, must precede `data:`.

A message may include one or more fields in any order, but `id:` usually goes the last. \# Cookies, document.cookie

Cookies are small strings of data that are stored directly in the browser. They are a part of the HTTP protocol, defined by the [RFC 6265](https://tools.ietf.org/html/rfc6265) specification.

Cookies are usually set by a web-server using the response `Set-Cookie` HTTP-header. Then, the browser automatically adds them to (almost) every request to the same domain using the `Cookie` HTTP-header.

One of the most widespread use cases is authentication:

1.  Upon sign in, the server uses the `Set-Cookie` HTTP-header in the response to set a cookie with a unique “session identifier”.
2.  Next time when the request is sent to the same domain, the browser sends the cookie over the net using the `Cookie` HTTP-header.
3.  So the server knows who made the request.

We can also access cookies from the browser, using `document.cookie` property.

There are many tricky things about cookies and their options. In this chapter we’ll cover them in detail.

## Reading from document.cookie

    Does your browser store any cookies from this site? Let's see:

    Assuming you're on a website, it's possible to see the cookies from it, like this:

`js run // At javascript.info, we use Google Analytics for statistics, // so there should be some cookies alert( document.cookie ); // cookie1=value1; cookie2=value2;...`

The value of `document.cookie` consists of `name=value` pairs, delimited by `;`. Each one is a separate cookie.

To find a particular cookie, we can split `document.cookie` by `;`, and then find the right name. We can use either a regular expression or array functions to do that.

We leave it as an exercise for the reader. Also, at the end of the chapter you’ll find helper functions to manipulate cookies.

## Writing to document.cookie

We can write to `document.cookie`. But it’s not a data property, it’s an accessor (getter/setter). An assignment to it is treated specially.

**A write operation to `document.cookie` updates only cookies mentioned in it, but doesn’t touch other cookies.**

For instance, this call sets a cookie with the name `user` and value `John`:

`js run document.cookie = "user=John"; // update only cookie named 'user' alert(document.cookie); // show all cookies`

If you run it, then probably you’ll see multiple cookies. That’s because the `document.cookie=` operation does not overwrite all cookies. It only sets the mentioned cookie `user`.

Technically, name and value can have any characters. To keep the valid formatting, they should be escaped using a built-in `encodeURIComponent` function:

\`\`\`js run // special characters (spaces), need encoding let name = “my name”; let value = “John Smith”

// encodes the cookie as my%20name=John%20Smith document.cookie = encodeURIComponent(name) + ‘=’ + encodeURIComponent(value);

alert(document.cookie); // …; my%20name=John%20Smith \`\`\`

`` warn header="Limitations" There are few limitations: - The `name=value` pair, after `encodeURIComponent`, should not exceed 4KB. So we can't store anything huge in a cookie. - The total number of cookies per domain is limited to around 20+, the exact limit depends on the browser. ``

Cookies have several options, many of them are important and should be set.

The options are listed after `key=value`, delimited by `;`, like this:

`js run document.cookie = "user=John; path=/; expires=Tue, 19 Jan 2038 03:14:07 GMT"`

## path

- **`path=/mypath`**

The url path prefix must be absolute. It makes the cookie accessible for pages under that path. By default, it’s the current path.

If a cookie is set with `path=/admin`, it’s visible at pages `/admin` and `/admin/something`, but not at `/home` or `/adminpage`.

Usually, we should set `path` to the root: `path=/` to make the cookie accessible from all website pages.

## domain

- **`domain=site.com`**

A domain defines where the cookie is accessible. In practice though, there are limitations. We can’t set any domain.

By default, a cookie is accessible only at the domain that set it. So, if the cookie was set by `site.com`, we won’t get it at `other.com`.

…But what’s more tricky, we also won’t get the cookie at a subdomain `forum.site.com`!

    // at site.com
    document.cookie = "user=John"

    // at forum.site.com
    alert(document.cookie); // no user

**There’s no way to let a cookie be accessible from another 2nd-level domain, so `other.com` will never receive a cookie set at `site.com`.**

It’s a safety restriction, to allow us to store sensitive data in cookies, that should be available only on one site.

…But if we’d like to allow subdomains like `forum.site.com` to get a cookie, that’s possible. When setting a cookie at `site.com`, we should explicitly set the `domain` option to the root domain: `domain=site.com`:

    // at site.com
    // make the cookie accessible on any subdomain *.site.com:
    document.cookie = "user=John; domain=site.com"

    // later

    // at forum.site.com
    alert(document.cookie); // has cookie user=John

For historical reasons, `domain=.site.com` (a dot before `site.com`) also works the same way, allowing access to the cookie from subdomains. That’s an old notation and should be used if we need to support very old browsers.

So, the `domain` option allows to make a cookie accessible at subdomains.

## expires, max-age

By default, if a cookie doesn’t have one of these options, it disappears when the browser is closed. Such cookies are called “session cookies”

To let cookies survive a browser close, we can set either the `expires` or `max-age` option.

- **`expires=Tue, 19 Jan 2038 03:14:07 GMT`**

The cookie expiration date defines the time, when the browser will automatically delete it.

The date must be exactly in this format, in the GMT timezone. We can use `date.toUTCString` to get it. For instance, we can set the cookie to expire in 1 day:

    // +1 day from now
    let date = new Date(Date.now() + 86400e3);
    date = date.toUTCString();
    document.cookie = "user=John; expires=" + date;

If we set `expires` to a date in the past, the cookie is deleted.

- **`max-age=3600`**

Is an alternative to `expires` and specifies the cookie’s expiration in seconds from the current moment.

If set to zero or a negative value, the cookie is deleted:

    // cookie will die in +1 hour from now
    document.cookie = "user=John; max-age=3600";

    // delete cookie (let it expire right now)
    document.cookie = "user=John; max-age=0";

## secure

- **`secure`**

The cookie should be transferred only over HTTPS.

**By default, if we set a cookie at `http://site.com`, then it also appears at `https://site.com` and vice versa.**

That is, cookies are domain-based, they do not distinguish between the protocols.

With this option, if a cookie is set by `https://site.com`, then it doesn’t appear when the same site is accessed by HTTP, as `http://site.com`. So if a cookie has sensitive content that should never be sent over unencrypted HTTP, the `secure` flag is the right thing.

    // assuming we're on https:// now
    // set the cookie to be secure (only accessible over HTTPS)
    document.cookie = "user=John; secure";

## samesite

That’s another security attribute `samesite`. It’s designed to protect from so-called XSRF (cross-site request forgery) attacks.

To understand how it works and when it’s useful, let’s take a look at XSRF attacks.

### XSRF attack

Imagine, you are logged into the site `bank.com`. That is: you have an authentication cookie from that site. Your browser sends it to `bank.com` with every request, so that it recognizes you and performs all sensitive financial operations.

Now, while browsing the web in another window, you accidentally come to another site `evil.com`. That site has JavaScript code that submits a form `<form action="https://bank.com/pay">` to `bank.com` with fields that initiate a transaction to the hacker’s account.

The browser sends cookies every time you visit the site `bank.com`, even if the form was submitted from `evil.com`. So the bank recognizes you and actually performs the payment.

![](cookie-xsrf.svg)

That’s a so-called “Cross-Site Request Forgery” (in short, XSRF) attack.

Real banks are protected from it of course. All forms generated by `bank.com` have a special field, a so-called “XSRF protection token”, that an evil page can’t generate or extract from a remote page. It can submit a form there, but can’t get the data back. The site `bank.com` checks for such token in every form it receives.

Such a protection takes time to implement though. We need to ensure that every form has the required token field, and we must also check all requests.

### Enter cookie samesite option

The cookie `samesite` option provides another way to protect from such attacks, that (in theory) should not require “xsrf protection tokens”.

It has two possible values:

- **`samesite=strict` (same as `samesite` without value)**

A cookie with `samesite=strict` is never sent if the user comes from outside the same site.

In other words, whether a user follows a link from their mail or submits a form from `evil.com`, or does any operation that originates from another domain, the cookie is not sent.

If authentication cookies have the `samesite` option, then a XSRF attack has no chances to succeed, because a submission from `evil.com` comes without cookies. So `bank.com` will not recognize the user and will not proceed with the payment.

The protection is quite reliable. Only operations that come from `bank.com` will send the `samesite` cookie, e.g. a form submission from another page at `bank.com`.

Although, there’s a small inconvenience.

When a user follows a legitimate link to `bank.com`, like from their own notes, they’ll be surprised that `bank.com` does not recognize them. Indeed, `samesite=strict` cookies are not sent in that case.

We could work around that by using two cookies: one for “general recognition”, only for the purposes of saying: “Hello, John”, and the other one for data-changing operations with `samesite=strict`. Then, a person coming from outside of the site will see a welcome, but payments must be initiated from the bank’s website, for the second cookie to be sent.

- **`samesite=lax`**

A more relaxed approach that also protects from XSRF and doesn’t break the user experience.

Lax mode, just like `strict`, forbids the browser to send cookies when coming from outside the site, but adds an exception.

A `samesite=lax` cookie is sent if both of these conditions are true: 1. The HTTP method is “safe” (e.g. GET, but not POST).

    The full list of safe HTTP methods is in the [RFC7231 specification](https://tools.ietf.org/html/rfc7231). Basically, these are the methods that should be used for reading, but not writing the data. They must not perform any data-changing operations. Following a link is always GET, the safe method.

1.  The operation performs a top-level navigation (changes URL in the browser address bar).

    That’s usually true, but if the navigation is performed in an `<iframe>`, then it’s not top-level. Also, JavaScript methods for network requests do not perform any navigation, hence they don’t fit.

So, what `samesite=lax` does, is to basically allow the most common “go to URL” operation to have cookies. E.g. opening a website link from notes that satisfy these conditions.

But anything more complicated, like a network request from another site or a form submission, loses cookies.

If that’s fine for you, then adding `samesite=lax` will probably not break the user experience and add protection.

Overall, `samesite` is a great option, but it has an important drawback: - `samesite` is ignored (not supported) by old browsers, year 2017 or so.

**So if we solely rely on `samesite` to provide protection, then old browsers will be vulnerable.**

But we surely can use `samesite` together with other protection measures, like xsrf tokens, to add an additional layer of defence and then, in the future, when old browsers die out, we’ll probably be able to drop xsrf tokens.

## httpOnly

This option has nothing to do with JavaScript, but we have to mention it for completeness.

The web-server uses the `Set-Cookie` header to set a cookie. Also, it may set the `httpOnly` option.

This option forbids any JavaScript access to the cookie. We can’t see such a cookie or manipulate it using `document.cookie`.

That’s used as a precaution measure, to protect from certain attacks when a hacker injects his own JavaScript code into a page and waits for a user to visit that page. That shouldn’t be possible at all, hackers should not be able to inject their code into our site, but there may be bugs that let them do it.

Normally, if such a thing happens, and a user visits a web-page with hacker’s JavaScript code, then that code executes and gains access to `document.cookie` with user cookies containing authentication information. That’s bad.

But if a cookie is `httpOnly`, then `document.cookie` doesn’t see it, so it is protected.

## Appendix: Cookie functions

Here’s a small set of functions to work with cookies, more convenient than a manual modification of `document.cookie`.

There exist many cookie libraries for that, so these are for demo purposes. Fully working though.

### getCookie(name)

The shortest way to access a cookie is to use a [regular expression](info:regular-expressions).

The function `getCookie(name)` returns the cookie with the given `name`:

    // returns the cookie with the given name,
    // or undefined if not found
    function getCookie(name) {
      let matches = document.cookie.match(new RegExp(
        "(?:^|; )" + name.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, '\\$1') + "=([^;]*)"
      ));
      return matches ? decodeURIComponent(matches[1]) : undefined;
    }

Here `new RegExp` is generated dynamically, to match `; name=<value>`.

Please note that a cookie value is encoded, so `getCookie` uses a built-in `decodeURIComponent` function to decode it.

### setCookie(name, value, options)

Sets the cookie’s `name` to the given `value` with `path=/` by default (can be modified to add other defaults):

\`\`\`js run function setCookie(name, value, options = {}) {

options = { path: ‘/’, // add other defaults here if necessary …options };

if (options.expires instanceof Date) { options.expires = options.expires.toUTCString(); }

let updatedCookie = encodeURIComponent(name) + “=” + encodeURIComponent(value);

for (let optionKey in options) { updatedCookie += “;” + optionKey; let optionValue = options\[optionKey\]; if (optionValue !== true) { updatedCookie += “=” + optionValue; } }

document.cookie = updatedCookie; }

// Example of use: setCookie(‘user’, ‘John’, {secure: true, ‘max-age’: 3600}); \`\`\`

### deleteCookie(name)

To delete a cookie, we can call it with a negative expiration date:

    function deleteCookie(name) {
      setCookie(name, "", {
        'max-age': -1
      })
    }

`warn header="Updating or deleting must use same path and domain" Please note: when we update or delete a cookie, we should use exactly the same path and domain options as when we set it.`

Together: [cookie.js](cookie.js).

## Appendix: Third-party cookies

A cookie is called “third-party” if it’s placed by a domain other than the page the user is visiting.

For instance: 1. A page at `site.com` loads a banner from another site: `<img src="https://ads.com/banner.png">`. 2. Along with the banner, the remote server at `ads.com` may set the `Set-Cookie` header with a cookie like `id=1234`. Such a cookie originates from the `ads.com` domain, and will only be visible at `ads.com`:

    ![](cookie-third-party.svg)

1.  Next time when `ads.com` is accessed, the remote server gets the `id` cookie and recognizes the user:

    ![](cookie-third-party-2.svg)

2.  What’s even more important is, when the user moves from `site.com` to another site `other.com`, which also has a banner, then `ads.com` gets the cookie, as it belongs to `ads.com`, thus recognizing the visitor and tracking him as he moves between sites:

    ![](cookie-third-party-3.svg)

Third-party cookies are traditionally used for tracking and ads services, due to their nature. They are bound to the originating domain, so `ads.com` can track the same user between different sites, if they all access it.

Naturally, some people don’t like being tracked, so browsers allow to disable such cookies.

Also, some modern browsers employ special policies for such cookies: - Safari does not allow third-party cookies at all. - Firefox comes with a “black list” of third-party domains where it blocks third-party cookies.

    If we load a script from a third-party domain, like `<script src="https://google-analytics.com/analytics.js">`, and that script uses `document.cookie` to set a cookie, then such cookie is not third-party.

    If a script sets a cookie, then no matter where the script came from -- the cookie belongs to the domain of the current webpage.

## Appendix: GDPR

This topic is not related to JavaScript at all, just something to keep in mind when setting cookies.

There’s a legislation in Europe called GDPR, that enforces a set of rules for websites to respect the users’ privacy. One of these rules is to require an explicit permission for tracking cookies from the user.

So, if we set a cookie that just saves some information, but neither tracks nor identifies the user, then we are free to do it.

But if we are going to set a cookie with an authentication session or a tracking id, then a user must allow that.

Websites generally have two variants of following GDPR. You must have seen them both already in the web:

1.  If a website wants to set tracking cookies only for authenticated users.

    To do so, the registration form should have a checkbox like “accept the privacy policy” (that describes how cookies are used), the user must check it, and then the website is free to set auth cookies.

2.  If a website wants to set tracking cookies for everyone.

    To do so legally, a website shows a modal “splash screen” for newcomers, and requires them to agree to the cookies. Then the website can set them and let people see the content. That can be disturbing for new visitors though. No one likes to see such “must-click” modal splash screens instead of the content. But GDPR requires an explicit agreement.

GDPR is not only about cookies, it’s about other privacy-related issues too, but that’s too much beyond our scope.

## Summary

`document.cookie` provides access to cookies - write operations modify only cookies mentioned in it. - name/value must be encoded. - one cookie must not exceed 4KB, 20+ cookies per site (depends on the browser).

Cookie options: - `path=/`, by default current path, makes the cookie visible only under that path. - `domain=site.com`, by default a cookie is visible on the current domain only. If the domain is set explicitly, the cookie becomes visible on subdomains. - `expires` or `max-age` sets the cookie expiration time. Without them the cookie dies when the browser is closed. - `secure` makes the cookie HTTPS-only. - `samesite` forbids the browser to send the cookie with requests coming from outside the site. This helps to prevent XSRF attacks.

Additionally: - Third-party cookies may be forbidden by the browser, e.g. Safari does that by default. - When setting a tracking cookie for EU citizens, GDPR requires to ask for permission. \# LocalStorage, sessionStorage

Web storage objects `localStorage` and `sessionStorage` allow to save key/value pairs in the browser.

What’s interesting about them is that the data survives a page refresh (for `sessionStorage`) and even a full browser restart (for `localStorage`). We’ll see that very soon.

We already have cookies. Why additional objects?

- Unlike cookies, web storage objects are not sent to server with each request. Because of that, we can store much more. Most browsers allow at least 2 megabytes of data (or more) and have settings to configure that.
- Also unlike cookies, the server can’t manipulate storage objects via HTTP headers. Everything’s done in JavaScript.
- The storage is bound to the origin (domain/protocol/port triplet). That is, different protocols or subdomains infer different storage objects, they can’t access data from each other.

Both storage objects provide same methods and properties:

- `setItem(key, value)` – store key/value pair.
- `getItem(key)` – get the value by key.
- `removeItem(key)` – remove the key with its value.
- `clear()` – delete everything.
- `key(index)` – get the key on a given position.
- `length` – the number of stored items.

As you can see, it’s like a `Map` collection (`setItem/getItem/removeItem`), but also allows access by index with `key(index)`.

Let’s see how it works.

## localStorage demo

The main features of `localStorage` are:

- Shared between all tabs and windows from the same origin.
- The data does not expire. It remains after the browser restart and even OS reboot.

For instance, if you run this code…

`js run localStorage.setItem('test', 1);`

…And close/open the browser or just open the same page in a different window, then you can get it like this:

`js run alert( localStorage.getItem('test') ); // 1`

We only have to be on the same origin (domain/port/protocol), the url path can be different.

The `localStorage` is shared between all windows with the same origin, so if we set the data in one window, the change becomes visible in another one.

## Object-like access

We can also use a plain object way of getting/setting keys, like this:

\`\`\`js run // set key localStorage.test = 2;

// get key alert( localStorage.test ); // 2

// remove key delete localStorage.test; \`\`\`

That’s allowed for historical reasons, and mostly works, but generally not recommended, because:

1.  If the key is user-generated, it can be anything, like `length` or `toString`, or another built-in method of `localStorage`. In that case `getItem/setItem` work fine, while object-like access fails: `js run let key = 'length'; localStorage[key] = 5; // Error, can't assign length`

2.  There’s a `storage` event, it triggers when we modify the data. That event does not happen for object-like access. We’ll see that later in this chapter.

## Looping over keys

As we’ve seen, the methods provide “get/set/remove by key” functionality. But how to get all saved values or keys?

Unfortunately, storage objects are not iterable.

One way is to loop over them as over an array:

`` js run for(let i=0; i<localStorage.length; i++) { let key = localStorage.key(i); alert(`${key}: ${localStorage.getItem(key)}`); } ``

Another way is to use `for key in localStorage` loop, just as we do with regular objects.

It iterates over keys, but also outputs few built-in fields that we don’t need:

`js run // bad try for(let key in localStorage) { alert(key); // shows getItem, setItem and other built-in stuff }`

…So we need either to filter fields from the prototype with `hasOwnProperty` check:

`` js run for(let key in localStorage) { if (!localStorage.hasOwnProperty(key)) { continue; // skip keys like "setItem", "getItem" etc } alert(`${key}: ${localStorage.getItem(key)}`); } ``

…Or just get the “own” keys with `Object.keys` and then loop over them if needed:

`` js run let keys = Object.keys(localStorage); for(let key of keys) { alert(`${key}: ${localStorage.getItem(key)}`); } ``

The latter works, because `Object.keys` only returns the keys that belong to the object, ignoring the prototype.

## Strings only

Please note that both key and value must be strings.

If were any other type, like a number, or an object, it gets converted to string automatically:

`js run sessionStorage.user = {name: "John"}; alert(sessionStorage.user); // [object Object]`

We can use `JSON` to store objects though:

\`\`\`js run sessionStorage.user = JSON.stringify({name: “John”});

// sometime later let user = JSON.parse( sessionStorage.user ); alert( user.name ); // John \`\`\`

Also it is possible to stringify the whole storage object, e.g. for debugging purposes:

`js run // added formatting options to JSON.stringify to make the object look nicer alert( JSON.stringify(localStorage, null, 2) );`

## sessionStorage

The `sessionStorage` object is used much less often than `localStorage`.

Properties and methods are the same, but it’s much more limited:

- The `sessionStorage` exists only within the current browser tab.
  - Another tab with the same page will have a different storage.
  - But it is shared between iframes in the same tab (assuming they come from the same origin).
- The data survives page refresh, but not closing/opening the tab.

Let’s see that in action.

Run this code…

`js run sessionStorage.setItem('test', 1);`

…Then refresh the page. Now you can still get the data:

`js run alert( sessionStorage.getItem('test') ); // after refresh: 1`

…But if you open the same page in another tab, and try again there, the code above returns `null`, meaning “nothing found”.

That’s exactly because `sessionStorage` is bound not only to the origin, but also to the browser tab. For that reason, `sessionStorage` is used sparingly.

## Storage event

When the data gets updated in `localStorage` or `sessionStorage`, [storage](https://www.w3.org/TR/webstorage/#the-storage-event) event triggers, with properties:

- `key` – the key that was changed (`null` if `.clear()` is called).
- `oldValue` – the old value (`null` if the key is newly added).
- `newValue` – the new value (`null` if the key is removed).
- `url` – the url of the document where the update happened.
- `storageArea` – either `localStorage` or `sessionStorage` object where the update happened.

The important thing is: the event triggers on all `window` objects where the storage is accessible, except the one that caused it.

Let’s elaborate.

Imagine, you have two windows with the same site in each. So `localStorage` is shared between them.

    You might want to open this page in two browser windows to test the code below.

If both windows are listening for `window.onstorage`, then each one will react on updates that happened in the other one.

\`\`\`js run // triggers on updates made to the same storage from other documents window.onstorage = event =&gt; { // same as window.addEventListener(‘storage’, event =&gt; { if (event.key != ‘now’) return; alert(event.key + ‘:’ + event.newValue + " at " + event.url); };

localStorage.setItem(‘now’, Date.now()); \`\`\`

Please note that the event also contains: `event.url` – the url of the document where the data was updated.

Also, `event.storageArea` contains the storage object – the event is the same for both `sessionStorage` and `localStorage`, so `event.storageArea` references the one that was modified. We may even want to set something back in it, to “respond” to a change.

**That allows different windows from the same origin to exchange messages.**

Modern browsers also support [Broadcast channel API](mdn:/api/Broadcast_Channel_API), the special API for same-origin inter-window communication, it’s more full featured, but less supported. There are libraries that polyfill that API, based on `localStorage`, that make it available everywhere.

## Summary

Web storage objects `localStorage` and `sessionStorage` allow to store key/value in the browser. - Both `key` and `value` must be strings. - The limit is 5mb+, depends on the browser. - They do not expire. - The data is bound to the origin (domain/port/protocol).

<table style="width:99%;"><colgroup><col style="width: 47%" /><col style="width: 52%" /></colgroup><thead><tr class="header"><th><code>localStorage</code></th><th><code>sessionStorage</code></th></tr></thead><tbody><tr class="odd"><td>Shared between all tabs and windows with the same origin</td><td>Visible within a browser tab, including iframes from the same origin</td></tr><tr class="even"><td>Survives browser restart</td><td>Survives page refresh (but not tab close)</td></tr></tbody></table>

API:

- `setItem(key, value)` – store key/value pair.
- `getItem(key)` – get the value by key.
- `removeItem(key)` – remove the key with its value.
- `clear()` – delete everything.
- `key(index)` – get the key number `index`.
- `length` – the number of stored items.
- Use `Object.keys` to get all keys.
- We access keys as object properties, in that case `storage` event isn’t triggered.

Storage event:

- Triggers on `setItem`, `removeItem`, `clear` calls.
- Contains all the data about the operation (`key/oldValue/newValue`), the document `url` and the storage object `storageArea`.
- Triggers on all `window` objects that have access to the storage except the one that generated it (within a tab for `sessionStorage`, globally for `localStorage`). libs:
  - ‘https://cdn.jsdelivr.net/npm/idb@3.0.2/build/idb.min.js’

---

# IndexedDB

IndexedDB is a database that is built into browser, much more powerful than `localStorage`.

- Stores almost any kind of values by keys, multiple key types.
- Supports transactions for reliability.
- Supports key range queries, indexes.
- Can store much bigger volumes of data than `localStorage`.

That power is usually excessive for traditional client-server apps. IndexedDB is intended for offline apps, to be combined with ServiceWorkers and other technologies.

The native interface to IndexedDB, described in the specification <a href="https://www.w3.org/TR/IndexedDB" class="uri">https://www.w3.org/TR/IndexedDB</a>, is event-based.

We can also use `async/await` with the help of a promise-based wrapper, like <a href="https://github.com/jakearchibald/idb" class="uri">https://github.com/jakearchibald/idb</a>. That’s pretty convenient, but the wrapper is not perfect, it can’t replace events for all cases. So we’ll start with events, and then, after we gain an understanding of IndexedDb, we’ll use the wrapper.

\`\`\`smart header=“Where’s the data?” Technically, the data is usually stored in the visitor’s home directory, along with browser settings, extensions, etc.

Different browsers and OS-level users have each their own independant storage. \`\`\`

## Open database

To start working with IndexedDB, we first need to `open` (connect to) a database.

The syntax:

    let openRequest = indexedDB.open(name, version);

- `name` – a string, the database name.
- `version` – a positive integer version, by default `1` (explained below).

We can have many databases with different names, but all of them exist within the current origin (domain/protocol/port). Different websites can’t access each other’s databases.

The call returns `openRequest` object, we should listen to events on it: - `success`: database is ready, there’s the “database object” in `openRequest.result`, we should use it for further calls. - `error`: opening failed. - `upgradeneeded`: database is ready, but its version is outdated (see below).

**IndexedDB has a built-in mechanism of “schema versioning”, absent in server-side databases.**

Unlike server-side databases, IndexedDB is client-side, the data is stored in the browser, so we, developers, don’t have full-time access to it. So, when we have published a new version of our app, and the user visits our webpage, we may need to update the database.

If the local database version is less than specified in `open`, then a special event `upgradeneeded` is triggered, and we can compare versions and upgrade data structures as needed.

The `upgradeneeded` event also triggers when the database doesn’t yet exist (technically, it’s version is `0`), so we can perform the initialization.

Let’s say we published the first version of our app.

Then we can open the database with version `1` and perform the initialization in an `upgradeneeded` handler like this:

    let openRequest = indexedDB.open("store", *!*1*/!*);

    openRequest.onupgradeneeded = function() {
      // triggers if the client had no database
      // ...perform initialization...
    };

    openRequest.onerror = function() {
      console.error("Error", openRequest.error);
    };

    openRequest.onsuccess = function() {
      let db = openRequest.result;
      // continue working with database using db object
    };

Then, later, we publish the 2nd version.

We can open it with version `2` and perform the upgrade like this:

    let openRequest = indexedDB.open("store", *!*2*/!*);

    openRequest.onupgradeneeded = function(event) {
      // the existing database version is less than 2 (or it doesn't exist)
      let db = openRequest.result;
      switch(event.oldVersion) { // existing db version
        case 0:
          // version 0 means that the client had no database
          // perform initialization
        case 1:
          // client had version 1
          // update
      }
    };

Please note: as our current version is `2`, the `onupgradeneeded` handler has a code branch for version `0`, suitable for users that are accessing for the first time and have no database, and also for version `1`, for upgrades.

And then, only if `onupgradeneeded` handler finishes without errors, `openRequest.onsuccess` triggers, and the database is considered successfully opened.

To delete a database:

    let deleteRequest = indexedDB.deleteDatabase(name)
    // deleteRequest.onsuccess/onerror tracks the result

\`\``warn header="We can't open an older version of the database" If the current user database has a higher version than in the`open`call, e.g. the existing DB version is`3`, and we try to`open(…2)`, then that's an error,`openRequest.onerror\` triggers.

That’s rare, but such a thing may happen when a visitor loads outdated JavaScript code, e.g. from a proxy cache. So the code is old, but his database is new.

To protect from errors, we should check `db.version` and suggest a page reload. Use proper HTTP caching headers to avoid loading the old code, so that you’ll never have such problems. \`\`\`

### Parallel update problem

As we’re talking about versioning, let’s tackle a small related problem.

Let’s say: 1. A visitor opened our site in a browser tab, with database version `1`. 2. Then we rolled out an update, so our code is newer. 3. And then the same visitor opens our site in another tab.

So there’s a tab with an open connection to DB version `1`, while the second one attempts to update it to version `2` in its `upgradeneeded` handler.

The problem is that a database is shared between two tabs, as it’s the same site, same origin. And it can’t be both version `1` and `2`. To perform the update to version `2`, all connections to version 1 must be closed, including the one in the first tab.

In order to organize that, the `versionchange` event triggers on the “outdated” database object. We should listen for it and close the old database connection (and probably suggest a page reload, to load the updated code).

If we don’t listen for the `versionchange` event and don’t close the old connection, then the second, new connection won’t be made. The `openRequest` object will emit the `blocked` event instead of `success`. So the second tab won’t work.

Here’s the code to correctly handle the parallel upgrade. It installs the `onversionchange` handler, that triggers if the current database connection becomes outdated (db version is updated elsewhere) and closes the connection.

    let openRequest = indexedDB.open("store", 2);

    openRequest.onupgradeneeded = ...;
    openRequest.onerror = ...;

    openRequest.onsuccess = function() {
      let db = openRequest.result;

      *!*
      db.onversionchange = function() {
        db.close();
        alert("Database is outdated, please reload the page.")
      };
      */!*

      // ...the db is ready, use it...
    };

    *!*
    openRequest.onblocked = function() {
      // this event shouldn't trigger if we handle onversionchange correctly

      // it means that there's another open connection to the same database
      // and it wasn't closed after db.onversionchange triggered for it
    };
    */!*

…In other words, here we do two things:

1.  The `db.onversionchange` listener informs us about a parallel update attempt, if the current database version becomes outdated.
2.  The `openRequest.onblocked` listener informs us about the opposite situation: there’s a connection to an outdated version elsewhere, and it doesn’t close, so the newer connection can’t be made.

We can handle things more gracefully in `db.onversionchange`, prompt the visitor to save the data before the connection is closed and so on.

Or, an alternative approach would be to not close the database in `db.onversionchange`, but instead use the `onblocked` handler (in the new tab) to alert the visitor, tell him that the newer version can’t be loaded until they close other tabs.

These update collisions happen rarely, but we should at least have some handling for them, at least an `onblocked` handler, to prevent our script from dying silently.

## Object store

To store something in IndexedDB, we need an _object store_.

An object store is a core concept of IndexedDB. Counterparts in other databases are called “tables” or “collections”. It’s where the data is stored. A database may have multiple stores: one for users, another one for goods, etc.

Despite being named an “object store”, primitives can be stored too.

**We can store almost any value, including complex objects.**

IndexedDB uses the [standard serialization algorithm](https://www.w3.org/TR/html53/infrastructure.html#section-structuredserializeforstorage) to clone-and-store an object. It’s like `JSON.stringify`, but more powerful, capable of storing much more datatypes.

An example of an object that can’t be stored: an object with circular references. Such objects are not serializable. `JSON.stringify` also fails for such objects.

**There must be a unique `key` for every value in the store.**

A key must be one of these types - number, date, string, binary, or array. It’s a unique identifier, so we can search/remove/update values by the key.

![](indexeddb-structure.svg)

As we’ll see very soon, we can provide a key when we add a value to the store, similar to `localStorage`. But when we store objects, IndexedDB allows setting up an object property as the key, which is much more convenient. Or we can auto-generate keys.

But we need to create an object store first.

The syntax to create an object store:

    db.createObjectStore(name[, keyOptions]);

Please note, the operation is synchronous, no `await` needed.

- `name` is the store name, e.g. `"books"` for books,
- `keyOptions` is an optional object with one of two properties:
  - `keyPath` – a path to an object property that IndexedDB will use as the key, e.g. `id`.
  - `autoIncrement` – if `true`, then the key for a newly stored object is generated automatically, as an ever-incrementing number.

If we don’t supply `keyOptions`, then we’ll need to provide a key explicitly later, when storing an object.

For instance, this object store uses `id` property as the key:

    db.createObjectStore('books', {keyPath: 'id'});

**An object store can only be created/modified while updating the DB version, in `upgradeneeded` handler.**

That’s a technical limitation. Outside of the handler we’ll be able to add/remove/update the data, but object stores can only be created/removed/altered during a version update.

To perform a database version upgrade, there are two main approaches: 1. We can implement per-version upgrade functions: from 1 to 2, from 2 to 3, from 3 to 4 etc. Then, in `upgradeneeded` we can compare versions (e.g. old 2, now 4) and run per-version upgrades step by step, for every intermediate version (2 to 3, then 3 to 4). 2. Or we can just examine the database: get a list of existing object stores as `db.objectStoreNames`. That object is a [DOMStringList](https://html.spec.whatwg.org/multipage/common-dom-interfaces.html#domstringlist) that provides `contains(name)` method to check for existance. And then we can do updates depending on what exists and what doesn’t.

For small databases the second variant may be simpler.

Here’s the demo of the second approach:

    let openRequest = indexedDB.open("db", 2);

    // create/upgrade the database without version checks
    openRequest.onupgradeneeded = function() {
      let db = openRequest.result;
      if (!db.objectStoreNames.contains('books')) { // if there's no "books" store
        db.createObjectStore('books', {keyPath: 'id'}); // create it
      }
    };

To delete an object store:

    db.deleteObjectStore('books')

## Transactions

The term “transaction” is generic, used in many kinds of databases.

A transaction is a group of operations, that should either all succeed or all fail.

For instance, when a person buys something, we need to: 1. Subtract the money from their account. 2. Add the item to their inventory.

It would be pretty bad if we complete the 1st operation, and then something goes wrong, e.g. lights out, and we fail to do the 2nd. Both should either succeed (purchase complete, good!) or both fail (at least the person kept their money, so they can retry).

Transactions can guarantee that.

**All data operations must be made within a transaction in IndexedDB.**

To start a transaction:

    db.transaction(store[, type]);

- `store` is a store name that the transaction is going to access, e.g. `"books"`. Can be an array of store names if we’re going to access multiple stores.
- `type` – a transaction type, one of:
  - `readonly` – can only read, the default.
  - `readwrite` – can only read and write the data, but not create/remove/alter object stores.

There’s also `versionchange` transaction type: such transactions can do everything, but we can’t create them manually. IndexedDB automatically creates a `versionchange` transaction when opening the database, for `updateneeded` handler. That’s why it’s a single place where we can update the database structure, create/remove object stores.

\`\``smart header="Why are there different types of transactions?" Performance is the reason why transactions need to be labeled either`readonly`and`readwrite\`.

Many `readonly` transactions are able to access the same store concurrently, but `readwrite` transactions can’t. A `readwrite` transaction “locks” the store for writing. The next transaction must wait before the previous one finishes before accessing the same store. \`\`\`

After the transaction is created, we can add an item to the store, like this:

    let transaction = db.transaction("books", "readwrite"); // (1)

    // get an object store to operate on it
    *!*
    let books = transaction.objectStore("books"); // (2)
    */!*

    let book = {
      id: 'js',
      price: 10,
      created: new Date()
    };

    *!*
    let request = books.add(book); // (3)
    */!*

    request.onsuccess = function() { // (4)
      console.log("Book added to the store", request.result);
    };

    request.onerror = function() {
      console.log("Error", request.error);
    };

There were basically four steps:

1.  Create a transaction, mentioning all the stores it’s going to access, at `(1)`.
2.  Get the store object using `transaction.objectStore(name)`, at `(2)`.
3.  Perform the request to the object store `books.add(book)`, at `(3)`.
4.  …Handle request success/error `(4)`, then we can make other requests if needed, etc.

Object stores support two methods to store a value:

- **put(value, \[key\])** Add the `value` to the store. The `key` is supplied only if the object store did not have `keyPath` or `autoIncrement` option. If there’s already a value with the same key, it will be replaced.

- **add(value, \[key\])** Same as `put`, but if there’s already a value with the same key, then the request fails, and an error with the name `"ConstraintError"` is generated.

Similar to opening a database, we can send a request: `books.add(book)`, and then wait for `success/error` events.

- The `request.result` for `add` is the key of the new object.
- The error is in `request.error` (if any).

## Transactions’ autocommit

In the example above we started the transaction and made `add` request. But as we stated previously, a transaction may have multiple associated requests, that must either all succeed or all fail. How do we mark the transaction as finished, with no more requests to come?

The short answer is: we don’t.

In the next version 3.0 of the specification, there will probably be a manual way to finish the transaction, but right now in 2.0 there isn’t.

**When all transaction requests are finished, and the [microtasks queue](info:microtask-queue) is empty, it is committed automatically.**

Usually, we can assume that a transaction commits when all its requests are complete, and the current code finishes.

So, in the example above no special call is needed to finish the transaction.

Transactions auto-commit principle has an important side effect. We can’t insert an async operation like `fetch`, `setTimeout` in the middle of a transaction. IndexedDB will not keep the transaction waiting till these are done.

In the code below, `request2` in the line `(*)` fails, because the transaction is already committed, and can’t make any request in it:

    let request1 = books.add(book);

    request1.onsuccess = function() {
      fetch('/').then(response => {
    *!*
        let request2 = books.add(anotherBook); // (*)
    */!*
        request2.onerror = function() {
          console.log(request2.error.name); // TransactionInactiveError
        };
      });
    };

That’s because `fetch` is an asynchronous operation, a macrotask. Transactions are closed before the browser starts doing macrotasks.

Authors of IndexedDB spec believe that transactions should be short-lived. Mostly for performance reasons.

Notably, `readwrite` transactions “lock” the stores for writing. So if one part of the application initiated `readwrite` on `books` object store, then another part that wants to do the same has to wait: the new transaction “hangs” till the first one is done. That can lead to strange delays if transactions take a long time.

So, what to do?

In the example above we could make a new `db.transaction` right before the new request `(*)`.

But it will be even better, if we’d like to keep the operations together, in one transaction, to split apart IndexedDB transactions and “other” async stuff.

First, make `fetch`, prepare the data if needed, afterwards create a transaction and perform all the database requests, it’ll work then.

To detect the moment of successful completion, we can listen to `transaction.oncomplete` event:

    let transaction = db.transaction("books", "readwrite");

    // ...perform operations...

    transaction.oncomplete = function() {
      console.log("Transaction is complete");
    };

Only `complete` guarantees that the transaction is saved as a whole. Individual requests may succeed, but the final write operation may go wrong (e.g. I/O error or something).

To manually abort the transaction, call:

    transaction.abort();

That cancels all modification made by the requests in it and triggers `transaction.onabort` event.

## Error handling

Write requests may fail.

That’s to be expected, not only because of possible errors at our side, but also for reasons not related to the transaction itself. For instance, the storage quota may be exceeded. So we must be ready to handle such case.

**A failed request automatically aborts the transaction, canceling all its changes.**

In some situations, we may want to handle the failure (e.g. try another request), without canceling existing changes, and continue the transaction. That’s possible. The `request.onerror` handler is able to prevent the transaction abort by calling `event.preventDefault()`.

In the example below a new book is added with the same key (`id`) as the existing one. The `store.add` method generates a `"ConstraintError"` in that case. We handle it without canceling the transaction:

    let transaction = db.transaction("books", "readwrite");

    let book = { id: 'js', price: 10 };

    let request = transaction.objectStore("books").add(book);

    request.onerror = function(event) {
      // ConstraintError occurs when an object with the same id already exists
      if (request.error.name == "ConstraintError") {
        console.log("Book with such id already exists"); // handle the error
        event.preventDefault(); // don't abort the transaction
        // use another key for the book?
      } else {
        // unexpected error, can't handle it
        // the transaction will abort
      }
    };

    transaction.onabort = function() {
      console.log("Error", transaction.error);
    };

### Event delegation

Do we need onerror/onsuccess for every request? Not every time. We can use event delegation instead.

**IndexedDB events bubble: `request` -&gt; `transaction` -&gt; `database`.**

All events are DOM events, with capturing and bubbling, but usually only bubbling stage is used.

So we can catch all errors using `db.onerror` handler, for reporting or other purposes:

    db.onerror = function(event) {
      let request = event.target; // the request that caused the error

      console.log("Error", request.error);
    };

…But what if an error is fully handled? We don’t want to report it in that case.

We can stop the bubbling and hence `db.onerror` by using `event.stopPropagation()` in `request.onerror`.

    request.onerror = function(event) {
      if (request.error.name == "ConstraintError") {
        console.log("Book with such id already exists"); // handle the error
        event.preventDefault(); // don't abort the transaction
        event.stopPropagation(); // don't bubble error up, "chew" it
      } else {
        // do nothing
        // transaction will be aborted
        // we can take care of error in transaction.onabort
      }
    };

## Searching

There are two main types of search in an object store:

1.  By a key value or a key range. In our “books” storage that would be a value or range of values of `book.id`.
2.  By another object field, e.g. `book.price`. This required an additional data structure, named “index”.

### By key

First let’s deal with the first type of search: by key.

Searching methods support both exact key values and so-called “ranges of values” – [IDBKeyRange](https://www.w3.org/TR/IndexedDB/#keyrange) objects that specify an acceptable “key range”.

`IDBKeyRange` objects are created using following calls:

- `IDBKeyRange.lowerBound(lower, [open])` means: `≥lower` (or `>lower` if `open` is true)
- `IDBKeyRange.upperBound(upper, [open])` means: `≤upper` (or `<upper` if `open` is true)
- `IDBKeyRange.bound(lower, upper, [lowerOpen], [upperOpen])` means: between `lower` and `upper`. If the open flags is true, the corresponding key is not included in the range.
- `IDBKeyRange.only(key)` – a range that consists of only one `key`, rarely used.

We’ll see practical examples of using them very soon.

To perform the actual search, there are following methods. They accept a `query` argument that can be either an exact key or a key range:

- `store.get(query)` – search for the first value by a key or a range.
- `store.getAll([query], [count])` – search for all values, limit by `count` if given.
- `store.getKey(query)` – search for the first key that satisfies the query, usually a range.
- `store.getAllKeys([query], [count])` – search for all keys that satisfy the query, usually a range, up to `count` if given.
- `store.count([query])` – get the total count of keys that satisfy the query, usually a range.

For instance, we have a lot of books in our store. Remember, the `id` field is the key, so all these methods can search by `id`.

Request examples:

    // get one book
    books.get('js')

    // get books with 'css' <= id <= 'html'
    books.getAll(IDBKeyRange.bound('css', 'html'))

    // get books with id < 'html'
    books.getAll(IDBKeyRange.upperBound('html', true))

    // get all books
    books.getAll()

    // get all keys, where id > 'js'
    books.getAllKeys(IDBKeyRange.lowerBound('js', true))

\`\`\`smart header=“Object store is always sorted” An object store sorts values by key internally.

So requests that return many values always return them in sorted by key order. \`\`\`

### By a field using an index

To search by other object fields, we need to create an additional data structure named “index”.

An index is an “add-on” to the store that tracks a given object field. For each value of that field, it stores a list of keys for objects that have that value. There will be a more detailed picture below.

The syntax:

    objectStore.createIndex(name, keyPath, [options]);

- **`name`** – index name,
- **`keyPath`** – path to the object field that the index should track (we’re going to search by that field),
- **`option`** – an optional object with properties:
  - **`unique`** – if true, then there may be only one object in the store with the given value at the `keyPath`. The index will enforce that by generating an error if we try to add a duplicate.
  - **`multiEntry`** – only used if the value on `keyPath` is an array. In that case, by default, the index will treat the whole array as the key. But if `multiEntry` is true, then the index will keep a list of store objects for each value in that array. So array members become index keys.

In our example, we store books keyed by `id`.

Let’s say we want to search by `price`.

First, we need to create an index. It must be done in `upgradeneeded`, just like an object store:

    openRequest.onupgradeneeded = function() {
      // we must create the index here, in versionchange transaction
      let books = db.createObjectStore('books', {keyPath: 'id'});
    *!*
      let index = books.createIndex('price_idx', 'price');
    */!*
    };

- The index will track `price` field.
- The price is not unique, there may be multiple books with the same price, so we don’t set `unique` option.
- The price is not an array, so `multiEntry` flag is not applicable.

Imagine that our `inventory` has 4 books. Here’s the picture that shows exactly what the `index` is:

![](indexeddb-index.svg)

As said, the index for each value of `price` (second argument) keeps the list of keys that have that price.

The index keeps itself up to date automatically, we don’t have to care about it.

Now, when we want to search for a given price, we simply apply the same search methods to the index:

    let transaction = db.transaction("books"); // readonly
    let books = transaction.objectStore("books");
    let priceIndex = books.index("price_idx");

    *!*
    let request = priceIndex.getAll(10);
    */!*

    request.onsuccess = function() {
      if (request.result !== undefined) {
        console.log("Books", request.result); // array of books with price=10
      } else {
        console.log("No such books");
      }
    };

We can also use `IDBKeyRange` to create ranges and looks for cheap/expensive books:

    // find books where price <= 5
    let request = priceIndex.getAll(IDBKeyRange.upperBound(5));

Indexes are internally sorted by the tracked object field, `price` in our case. So when we do the search, the results are also sorted by `price`.

## Deleting from store

The `delete` method looks up values to delete by a query, the call format is similar to `getAll`:

- **`delete(query)`** – delete matching values by query.

For instance:

    // delete the book with id='js'
    books.delete('js');

If we’d like to delete books based on a price or another object field, then we should first find the key in the index, and then call `delete`:

    // find the key where price = 5
    let request = priceIndex.getKey(5);

    request.onsuccess = function() {
      let id = request.result;
      let deleteRequest = books.delete(id);
    };

To delete everything:

    books.clear(); // clear the storage.

## Cursors

Methods like `getAll/getAllKeys` return an array of keys/values.

But an object storage can be huge, bigger than the available memory. Then `getAll` will fail to get all records as an array.

What to do?

Cursors provide the means to work around that.

**A _cursor_ is a special object that traverses the object storage, given a query, and returns one key/value at a time, thus saving memory.**

As an object store is sorted internally by key, a cursor walks the store in key order (ascending by default).

The syntax:

    // like getAll, but with a cursor:
    let request = store.openCursor(query, [direction]);

    // to get keys, not values (like getAllKeys): store.openKeyCursor

- **`query`** is a key or a key range, same as for `getAll`.
- **`direction`** is an optional argument, which order to use:
  - `"next"` – the default, the cursor walks up from the record with the lowest key.
  - `"prev"` – the reverse order: down from the record with the biggest key.
  - `"nextunique"`, `"prevunique"` – same as above, but skip records with the same key (only for cursors over indexes, e.g. for multiple books with price=5 only the first one will be returned).

**The main difference of the cursor is that `request.onsuccess` triggers multiple times: once for each result.**

Here’s an example of how to use a cursor:

    let transaction = db.transaction("books");
    let books = transaction.objectStore("books");

    let request = books.openCursor();

    // called for each book found by the cursor
    request.onsuccess = function() {
      let cursor = request.result;
      if (cursor) {
        let key = cursor.key; // book key (id field)
        let value = cursor.value; // book object
        console.log(key, value);
        cursor.continue();
      } else {
        console.log("No more books");
      }
    };

The main cursor methods are:

- `advance(count)` – advance the cursor `count` times, skipping values.
- `continue([key])` – advance the cursor to the next value in range matching (or immediately after `key` if given).

Whether there are more values matching the cursor or not – `onsuccess` gets called, and then in `result` we can get the cursor pointing to the next record, or `undefined`.

In the example above the cursor was made for the object store.

But we also can make a cursor over an index. As we remember, indexes allow to search by an object field. Cursors over indexes do precisely the same as over object stores – they save memory by returning one value at a time.

For cursors over indexes, `cursor.key` is the index key (e.g. price), and we should use `cursor.primaryKey` property for the object key:

    let request = priceIdx.openCursor(IDBKeyRange.upperBound(5));

    // called for each record
    request.onsuccess = function() {
      let cursor = request.result;
      if (cursor) {
        let primaryKey = cursor.primaryKey; // next object store key (id field)
        let value = cursor.value; // next object store object (book object)
        let key = cursor.key; // next index key (price)
        console.log(key, value);
        cursor.continue();
      } else {
        console.log("No more books");
      }
    };

## Promise wrapper

Adding `onsuccess/onerror` to every request is quite a cumbersome task. Sometimes we can make our life easier by using event delegation, e.g. set handlers on the whole transactions, but `async/await` is much more convenient.

Let’s use a thin promise wrapper <a href="https://github.com/jakearchibald/idb" class="uri">https://github.com/jakearchibald/idb</a> further in this chapter. It creates a global `idb` object with [promisified](info:promisify) IndexedDB methods.

Then, instead of `onsuccess/onerror` we can write like this:

    let db = await idb.openDB('store', 1, db => {
      if (db.oldVersion == 0) {
        // perform the initialization
        db.createObjectStore('books', {keyPath: 'id'});
      }
    });

    let transaction = db.transaction('books', 'readwrite');
    let books = transaction.objectStore('books');

    try {
      await books.add(...);
      await books.add(...);

      await transaction.complete;

      console.log('jsbook saved');
    } catch(err) {
      console.log('error', err.message);
    }

So we have all the sweet “plain async code” and “try..catch” stuff.

### Error handling

If we don’t catch an error, then it falls through, till the closest outer `try..catch`.

An uncaught error becomes an “unhandled promise rejection” event on `window` object.

We can handle such errors like this:

    window.addEventListener('unhandledrejection', event => {
      let request = event.target; // IndexedDB native request object
      let error = event.reason; //  Unhandled error object, same as request.error
      ...report about the error...
    });

### “Inactive transaction” pitfall

As we already know, a transaction auto-commits as soon as the browser is done with the current code and microtasks. So if we put a _macrotask_ like `fetch` in the middle of a transaction, then the transaction won’t wait for it to finish. It just auto-commits. So the next request in it would fail.

For a promise wrapper and `async/await` the situation is the same.

Here’s an example of `fetch` in the middle of the transaction:

    let transaction = db.transaction("inventory", "readwrite");
    let inventory = transaction.objectStore("inventory");

    await inventory.add({ id: 'js', price: 10, created: new Date() });

    await fetch(...); // (*)

    await inventory.add({ id: 'js', price: 10, created: new Date() }); // Error

The next `inventory.add` after `fetch` `(*)` fails with an “inactive transaction” error, because the transaction is already committed and closed at that time.

The workaround is the same as when working with native IndexedDB: either make a new transaction or just split things apart. 1. Prepare the data and fetch all that’s needed first. 2. Then save in the database.

### Getting native objects

Internally, the wrapper performs a native IndexedDB request, adding `onerror/onsuccess` to it, and returns a promise that rejects/resolves with the result.

That works fine most of the time. The examples are at the lib page <a href="https://github.com/jakearchibald/idb" class="uri">https://github.com/jakearchibald/idb</a>.

In few rare cases, when we need the original `request` object, we can access it as `promise.request` property of the promise:

    let promise = books.add(book); // get a promise (don't await for its result)

    let request = promise.request; // native request object
    let transaction = request.transaction; // native transaction object

    // ...do some native IndexedDB voodoo...

    let result = await promise; // if still needed

## Summary

IndexedDB can be thought of as a “localStorage on steroids”. It’s a simple key-value database, powerful enough for offline apps, yet simple to use.

The best manual is the specification, [the current one](https://www.w3.org/TR/IndexedDB-2/) is 2.0, but few methods from [3.0](https://w3c.github.io/IndexedDB/) (it’s not much different) are partially supported.

The basic usage can be described with a few phrases:

1.  Get a promise wrapper like [idb](https://github.com/jakearchibald/idb).
2.  Open a database: `idb.openDb(name, version, onupgradeneeded)`
    - Create object storages and indexes in `onupgradeneeded` handler or perform version update if needed.
3.  For requests:
    - Create transaction `db.transaction('books')` (readwrite if needed).
    - Get the object store `transaction.objectStore('books')`.
4.  Then, to search by a key, call methods on the object store directly.
    - To search by an object field, create an index.
5.  If the data does not fit in memory, use a cursor.

Here’s a small demo app:

\[codetabs src=“books” current=“index.html”\] \# Bezier curve

Bezier curves are used in computer graphics to draw shapes, for CSS animation and in many other places.

They are a very simple thing, worth to study once and then feel comfortable in the world of vector graphics and advanced animations.

## Control points

A [bezier curve](https://en.wikipedia.org/wiki/B%C3%A9zier_curve) is defined by control points.

There may be 2, 3, 4 or more.

For instance, two points curve:

![](bezier2.svg)

Three points curve:

![](bezier3.svg)

Four points curve:

![](bezier4.svg)

If you look closely at these curves, you can immediately notice:

1.  **Points are not always on curve.** That’s perfectly normal, later we’ll see how the curve is built.
2.  **The curve order equals the number of points minus one**. For two points we have a linear curve (that’s a straight line), for three points – quadratic curve (parabolic), for four points – cubic curve.
3.  **A curve is always inside the [convex hull](https://en.wikipedia.org/wiki/Convex_hull) of control points:**

    ![](bezier4-e.svg) ![](bezier3-e.svg)

Because of that last property, in computer graphics it’s possible to optimize intersection tests. If convex hulls do not intersect, then curves do not either. So checking for the convex hulls intersection first can give a very fast “no intersection” result. Checking the intersection of convex hulls is much easier, because they are rectangles, triangles and so on (see the picture above), much simpler figures than the curve.

**The main value of Bezier curves for drawing – by moving the points the curve is changing _in intuitively obvious way_.**

Try to move control points using a mouse in the example below:

\[iframe src=“demo.svg?nocpath=1&p=0,0,0.5,0,0.5,1,1,1” height=370\]

**As you can notice, the curve stretches along the tangential lines 1 -&gt; 2 and 3 -&gt; 4.**

After some practice it becomes obvious how to place points to get the needed curve. And by connecting several curves we can get practically anything.

Here are some examples:

![](bezier-car.svg) ![](bezier-letter.svg) ![](bezier-vase.svg)

## De Casteljau’s algorithm

There’s a mathematical formula for Bezier curves, but let’s cover it a bit later, because [De Casteljau’s algorithm](https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm) is identical to the mathematical definition and visually shows how it is constructed.

First let’s see the 3-points example.

Here’s the demo, and the explanation follow.

Control points (1,2 and 3) can be moved by the mouse. Press the “play” button to run it.

\[iframe src=“demo.svg?p=0,0,0.5,1,1,0&animate=1” height=370\]

**De Casteljau’s algorithm of building the 3-point bezier curve:**

1.  Draw control points. In the demo above they are labeled: `1`, `2`, `3`.
2.  Build segments between control points 1 -&gt; 2 -&gt; 3. In the demo above they are <span style="color:#825E28">brown</span>.
3.  The parameter `t` moves from `0` to `1`. In the example above the step `0.05` is used: the loop goes over `0, 0.05, 0.1, 0.15, ... 0.95, 1`.

    For each of these values of `t`:

    - On each <span style="color:#825E28">brown</span> segment we take a point located on the distance proportional to `t` from its beginning. As there are two segments, we have two points.

      For instance, for `t=0` – both points will be at the beginning of segments, and for `t=0.25` – on the 25% of segment length from the beginning, for `t=0.5` – 50%(the middle), for `t=1` – in the end of segments.

    - Connect the points. On the picture below the connecting segment is painted <span style="color:#167490">blue</span>.

<table><thead><tr class="header"><th>For <code>t=0.25</code></th><th>For <code>t=0.5</code></th></tr></thead><tbody><tr class="odd"><td><img src="bezier3-draw1.svg" /></td><td><img src="bezier3-draw2.svg" /></td></tr></tbody></table>

1.  Now in the <span style="color:#167490">blue</span> segment take a point on the distance proportional to the same value of `t`. That is, for `t=0.25` (the left picture) we have a point at the end of the left quarter of the segment, and for `t=0.5` (the right picture) – in the middle of the segment. On pictures above that point is <span style="color:red">red</span>.

2.  As `t` runs from `0` to `1`, every value of `t` adds a point to the curve. The set of such points forms the Bezier curve. It’s red and parabolic on the pictures above.

That was a process for 3 points. But the same is for 4 points.

The demo for 4 points (points can be moved by a mouse):

\[iframe src=“demo.svg?p=0,0,0.5,0,0.5,1,1,1&animate=1” height=370\]

The algorithm for 4 points:

- Connect control points by segments: 1 -&gt; 2, 2 -&gt; 3, 3 -&gt; 4. There will be 3 <span style="color:#825E28">brown</span> segments.
- For each `t` in the interval from `0` to `1`:
  - We take points on these segments on the distance proportional to `t` from the beginning. These points are connected, so that we have two <span style="color:#0A0">green segments</span>.
  - On these segments we take points proportional to `t`. We get one <span style="color:#167490">blue segment</span>.
  - On the blue segment we take a point proportional to `t`. On the example above it’s <span style="color:red">red</span>.
- These points together form the curve.

The algorithm is recursive and can be generalized for any number of control points.

Given N of control points:

1.  We connect them to get initially N-1 segments.
2.  Then for each `t` from `0` to `1`, we take a point on each segment on the distance proportional to `t` and connect them. There will be N-2 segments.
3.  Repeat step 2 until there is only one point.

These points make the curve.

    **Run and pause examples to clearly see the segments and how the curve is built.**

A curve that looks like `y=1/t`:

\[iframe src=“demo.svg?p=0,0,0,0.75,0.25,1,1,1&animate=1” height=370\]

Zig-zag control points also work fine:

\[iframe src=“demo.svg?p=0,0,1,0.5,0,0.5,1,1&animate=1” height=370\]

Making a loop is possible:

\[iframe src=“demo.svg?p=0,0,1,0.5,0,1,0.5,0&animate=1” height=370\]

A non-smooth Bezier curve (yeah, that’s possible too):

\[iframe src=“demo.svg?p=0,0,1,1,0,1,1,0&animate=1” height=370\]

    If there's something unclear in the algorithm description, please look at the live examples above to see how
    the curve is built.

As the algorithm is recursive, we can build Bezier curves of any order, that is: using 5, 6 or more control points. But in practice many points are less useful. Usually we take 2-3 points, and for complex lines glue several curves together. That’s simpler to develop and calculate.

\`\`\`smart header=“How to draw a curve _through_ given points?” To specify a Bezier curve, control points are used. As we can see, they are not on the curve, except the first and the last ones.

Sometimes we have another task: to draw a curve _through several points_, so that all of them are on a single smooth curve. That task is called [interpolation](https://en.wikipedia.org/wiki/Interpolation), and here we don’t cover it.

There are mathematical formulas for such curves, for instance [Lagrange polynomial](https://en.wikipedia.org/wiki/Lagrange_polynomial). In computer graphics [spline interpolation](https://en.wikipedia.org/wiki/Spline_interpolation) is often used to build smooth curves that connect many points. \`\`\`

## Maths

A Bezier curve can be described using a mathematical formula.

As we saw – there’s actually no need to know it, most people just draw the curve by moving points with a mouse. But if you’re into maths – here it is.

Given the coordinates of control points `Pi`: the first control point has coordinates `P1 = (x1, y1)`, the second: `P2 = (x2, y2)`, and so on, the curve coordinates are described by the equation that depends on the parameter `t` from the segment `[0,1]`.

- The formula for a 2-points curve:

  `P = (1-t)P1 + tP2`

- For 3 control points:

  `P = (1−t)2P1 + 2(1−t)tP2 + t2P3`

- For 4 control points:

  `P = (1−t)3P1 + 3(1−t)2tP2 +3(1−t)t2P3 + t3P4`

These are vector equations. In other words, we can put `x` and `y` instead of `P` to get corresponding coordinates.

For instance, the 3-point curve is formed by points `(x,y)` calculated as:

- `x = (1−t)2x1 + 2(1−t)tx2 + t2x3`
- `y = (1−t)2y1 + 2(1−t)ty2 + t2y3`

Instead of `x1, y1, x2, y2, x3, y3` we should put coordinates of 3 control points, and then as `t` moves from `0` to `1`, for each value of `t` we’ll have `(x,y)` of the curve.

For instance, if control points are `(0,0)`, `(0.5, 1)` and `(1, 0)`, the equations become:

- `x = (1−t)2 * 0 + 2(1−t)t * 0.5 + t2 * 1 = (1-t)t + t2 = t`
- `y = (1−t)2 * 0 + 2(1−t)t * 1 + t2 * 0 = 2(1-t)t = –2t2 + 2t`

Now as `t` runs from `0` to `1`, the set of values `(x,y)` for each `t` forms the curve for such control points.

## Summary

Bezier curves are defined by their control points.

We saw two definitions of Bezier curves:

1.  Using a drawing process: De Casteljau’s algorithm.
2.  Using a mathematical formulas.

Good properties of Bezier curves:

- We can draw smooth lines with a mouse by moving control points.
- Complex shapes can be made of several Bezier curves.

Usage:

- In computer graphics, modeling, vector graphic editors. Fonts are described by Bezier curves.
- In web development – for graphics on Canvas and in the SVG format. By the way, “live” examples above are written in SVG. They are actually a single SVG document that is given different points as parameters. You can open it in a separate window and see the source: [demo.svg](demo.svg?p=0,0,1,0.5,0,0.5,1,1&animate=1).
- In CSS animation to describe the path and speed of animation. \# CSS-animations

CSS animations make it possible to do simple animations without JavaScript at all.

JavaScript can be used to control CSS animations and make them even better, with little code.

## CSS transitions \[\#css-transition\]

The idea of CSS transitions is simple. We describe a property and how its changes should be animated. When the property changes, the browser paints the animation.

That is, all we need is to change the property, and the fluid transition will be done by the browser.

For instance, the CSS below animates changes of `background-color` for 3 seconds:

    .animated {
      transition-property: background-color;
      transition-duration: 3s;
    }

Now if an element has `.animated` class, any change of `background-color` is animated during 3 seconds.

Click the button below to animate the background:

\`\`\`html run autorun height=60 Click me

\`\`\`

There are 4 properties to describe CSS transitions:

- `transition-property`
- `transition-duration`
- `transition-timing-function`
- `transition-delay`

We’ll cover them in a moment, for now let’s note that the common `transition` property allows declaring them together in the order: `property duration timing-function delay`, as well as animating multiple properties at once.

For instance, this button animates both `color` and `font-size`:

\`\`\`html run height=80 autorun no-beautify Click me

\`\`\`

Now, let’s cover animation properties one by one.

## transition-property

In `transition-property`, we write a list of properties to animate, for instance: `left`, `margin-left`, `height`, `color`. Or we could write `all`, which means “animate all properties”.

Do note that, there are properties which can not be animated. However, [most of the generally used properties are animatable](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties).

## transition-duration

In `transition-duration` we can specify how long the animation should take. The time should be in [CSS time format](http://www.w3.org/TR/css3-values/#time): in seconds `s` or milliseconds `ms`.

## transition-delay

In `transition-delay` we can specify the delay _before_ the animation. For instance, if `transition-delay` is `1s` and `transition-duration` is `2s`, then the animation starts 1 second after the property change and the total duration will be 2 seconds.

Negative values are also possible. Then the animation is shown immediately, but the starting point of the animation will be after given value (time). For example, if `transition-delay` is `-1s` and `transition-duration` is `2s`, then animation starts from the halfway point and total duration will be 1 second.

Here the animation shifts numbers from `0` to `9` using CSS `translate` property:

\[codetabs src=“digits”\]

The `transform` property is animated like this:

    #stripe.animate {
      transform: translate(-90%);
      transition-property: transform;
      transition-duration: 9s;
    }

In the example above JavaScript adds the class `.animate` to the element – and the animation starts:

    stripe.classList.add('animate');

We could also start it from somewhere in the middle of the transition, from an exact number, e.g. corresponding to the current second, using a negative `transition-delay`.

Here if you click the digit – it starts the animation from the current second:

\[codetabs src=“digits-negative-delay”\]

JavaScript does it with an extra line:

    stripe.onclick = function() {
      let sec = new Date().getSeconds() % 10;
    *!*
      // for instance, -3s here starts the animation from the 3rd second
      stripe.style.transitionDelay = '-' + sec + 's';
    */!*
      stripe.classList.add('animate');
    };

## transition-timing-function

The timing function describes how the animation process is distributed along its timeline. Will it start slowly and then go fast, or vice versa.

It appears to be the most complicated property at first. But it becomes very simple if we devote a bit time to it.

That property accepts two kinds of values: a Bezier curve or steps. Let’s start with the curve, as it’s used more often.

### Bezier curve

The timing function can be set as a [Bezier curve](/bezier-curve) with 4 control points that satisfy the conditions:

1.  First control point: `(0,0)`.
2.  Last control point: `(1,1)`.
3.  For intermediate points, the values of `x` must be in the interval `0..1`, `y` can be anything.

The syntax for a Bezier curve in CSS: `cubic-bezier(x2, y2, x3, y3)`. Here we need to specify only 2nd and 3rd control points, because the 1st one is fixed to `(0,0)` and the 4th one is `(1,1)`.

The timing function describes how fast the animation process goes.

- The `x` axis is the time: `0` – the start, `1` – the end of `transition-duration`.
- The `y` axis specifies the completion of the process: `0` – the starting value of the property, `1` – the final value.

The simplest variant is when the animation goes uniformly, with the same linear speed. That can be specified by the curve `cubic-bezier(0, 0, 1, 1)`.

Here’s how that curve looks:

![](bezier-linear.svg)

…As we can see, it’s just a straight line. As the time (`x`) passes, the completion (`y`) of the animation steadily goes from `0` to `1`.

The train in the example below goes from left to right with the permanent speed (click it):

\[codetabs src=“train-linear”\]

The CSS `transition` is based on that curve:

    .train {
      left: 0;
      transition: left 5s cubic-bezier(0, 0, 1, 1);
      /* JavaScript sets left to 450px */
    }

…And how can we show a train slowing down?

We can use another Bezier curve: `cubic-bezier(0.0, 0.5, 0.5 ,1.0)`.

The graph:

![](train-curve.svg)

As we can see, the process starts fast: the curve soars up high, and then slower and slower.

Here’s the timing function in action (click the train):

\[codetabs src=“train”\]

CSS:

    .train {
      left: 0;
      transition: left 5s cubic-bezier(0, .5, .5, 1);
      /* JavaScript sets left to 450px */
    }

There are several built-in curves: `linear`, `ease`, `ease-in`, `ease-out` and `ease-in-out`.

The `linear` is a shorthand for `cubic-bezier(0, 0, 1, 1)` – a straight line, which we described above.

Other names are shorthands for the following `cubic-bezier`:

<table style="width:98%;"><colgroup><col style="width: 30%" /><col style="width: 21%" /><col style="width: 22%" /><col style="width: 25%" /></colgroup><thead><tr class="header"><th><code>ease</code><sup>*</sup></th><th><code>ease-in</code></th><th><code>ease-out</code></th><th><code>ease-in-out</code></th></tr></thead><tbody><tr class="odd"><td><code>(0.25, 0.1, 0.25, 1.0)</code></td><td><code>(0.42, 0, 1.0, 1.0)</code></td><td><code>(0, 0, 0.58, 1.0)</code></td><td><code>(0.42, 0, 0.58, 1.0)</code></td></tr><tr class="even"><td><img src="ease.svg" alt="ease, figure" /></td><td><img src="ease-in.svg" alt="ease-in, figure" /></td><td><img src="ease-out.svg" alt="ease-out, figure" /></td><td><img src="ease-in-out.svg" alt="ease-in-out, figure" /></td></tr></tbody></table>

`*` – by default, if there’s no timing function, `ease` is used.

So we could use `ease-out` for our slowing down train:

    .train {
      left: 0;
      transition: left 5s ease-out;
      /* transition: left 5s cubic-bezier(0, .5, .5, 1); */
    }

But it looks a bit differently.

**A Bezier curve can make the animation exceed its range.**

The control points on the curve can have any `y` coordinates: even negative or huge ones. Then the Bezier curve would also extend very low or high, making the animation go beyond its normal range.

In the example below the animation code is:

    .train {
      left: 100px;
      transition: left 5s cubic-bezier(.5, -1, .5, 2);
      /* JavaScript sets left to 400px */
    }

The property `left` should animate from `100px` to `400px`.

But if you click the train, you’ll see that:

- First, the train goes _back_: `left` becomes less than `100px`.
- Then it goes forward, a little bit farther than `400px`.
- And then back again – to `400px`.

\[codetabs src=“train-over”\]

Why it happens is pretty obvious if we look at the graph of the given Bezier curve:

![](bezier-train-over.svg)

We moved the `y` coordinate of the 2nd point below zero, and for the 3rd point we made it over `1`, so the curve goes out of the “regular” quadrant. The `y` is out of the “standard” range `0..1`.

As we know, `y` measures “the completion of the animation process”. The value `y = 0` corresponds to the starting property value and `y = 1` – the ending value. So values `y<0` move the property beyond the starting `left` and `y>1` – past the final `left`.

That’s a “soft” variant for sure. If we put `y` values like `-99` and `99` then the train would jump out of the range much more.

But how do we make a Bezier curve for a specific task? There are many tools. For instance, we can do it on the site <a href="http://cubic-bezier.com/" class="uri">http://cubic-bezier.com/</a>.

### Steps

The timing function `steps(number of steps[, start/end])` allows splitting an animation into steps.

Let’s see that in an example with digits.

Here’s a list of digits, without any animations, just as a source:

\[codetabs src=“step-list”\]

We’ll make the digits appear in a discrete way by making the part of the list outside of the red “window” invisible and shifting the list to the left with each step.

There will be 9 steps, a step-move for each digit:

    #stripe.animate  {
      transform: translate(-90%);
      transition: transform 9s *!*steps(9, start)*/!*;
    }

In action:

\[codetabs src=“step”\]

The first argument of `steps(9, start)` is the number of steps. The transform will be split into 9 parts (10% each). The time interval is automatically divided into 9 parts as well, so `transition: 9s` gives us 9 seconds for the whole animation – 1 second per digit.

The second argument is one of two words: `start` or `end`.

The `start` means that in the beginning of animation we need to make the first step immediately.

We can observe that during the animation: when we click on the digit it changes to `1` (the first step) immediately, and then changes in the beginning of the next second.

The process is progressing like this:

- `0s` – `-10%` (first change in the beginning of the 1st second, immediately)
- `1s` – `-20%`
- …
- `8s` – `-80%`
- (the last second shows the final value).

The alternative value `end` would mean that the change should be applied not in the beginning, but at the end of each second.

So the process would go like this:

- `0s` – `0`
- `1s` – `-10%` (first change at the end of the 1st second)
- `2s` – `-20%`
- …
- `9s` – `-90%`

Here’s `steps(9, end)` in action (note the pause between the first digit change):

\[codetabs src=“step-end”\]

There are also shorthand values:

- `step-start` – is the same as `steps(1, start)`. That is, the animation starts immediately and takes 1 step. So it starts and finishes immediately, as if there were no animation.
- `step-end` – the same as `steps(1, end)`: make the animation in a single step at the end of `transition-duration`.

These values are rarely used, because that’s not really animation, but rather a single-step change.

## Event transitionend

When the CSS animation finishes the `transitionend` event triggers.

It is widely used to do an action after the animation is done. Also we can join animations.

For instance, the ship in the example below starts to sail there and back when clicked, each time farther and farther to the right:

\[iframe src=“boat” height=300 edit link\]

The animation is initiated by the function `go` that re-runs each time the transition finishes, and flips the direction:

    boat.onclick = function() {
      //...
      let times = 1;

      function go() {
        if (times % 2) {
          // sail to the right
          boat.classList.remove('back');
          boat.style.marginLeft = 100 * times + 200 + 'px';
        } else {
          // sail to the left
          boat.classList.add('back');
          boat.style.marginLeft = 100 * times - 200 + 'px';
        }

      }

      go();

      boat.addEventListener('transitionend', function() {
        times++;
        go();
      });
    };

The event object for `transitionend` has a few specific properties:

`event.propertyName`  
The property that has finished animating. Can be good if we animate multiple properties simultaneously.

`event.elapsedTime`  
The time (in seconds) that the animation took, without `transition-delay`.

## Keyframes

We can join multiple simple animations together using the `@keyframes` CSS rule.

It specifies the “name” of the animation and rules - what, when and where to animate. Then using the `animation` property, we can attach the animation to the element and specify additional parameters for it.

Here’s an example with explanations:

\`\`\`html run height=60 autorun=“no-epub” no-beautify

\`\`\`

There are many articles about `@keyframes` and a [detailed specification](https://drafts.csswg.org/css-animations/).

You probably won’t need `@keyframes` often, unless everything is in constant motion on your sites.

## Summary

CSS animations allow smoothly (or not) animated changes of one or multiple CSS properties.

They are good for most animation tasks. We’re also able to use JavaScript for animations, the next chapter is devoted to that.

Limitations of CSS animations compared to JavaScript animations:

`compare plus="CSS animations" minus="JavaScript animations" + Simple things done simply. + Fast and lightweight for CPU. - JavaScript animations are flexible. They can implement any animation logic, like an "explosion" of an element. - Not just property changes. We can create new elements in JavaScript as part of the animation.`

The majority of animations can be implemented using CSS as described in this chapter. And the `transitionend` event allows JavaScript to be run after the animation, so it integrates fine with the code.

But in the next chapter we’ll do some JavaScript animations to cover more complex cases. \# JavaScript animations

JavaScript animations can handle things that CSS can’t.

For instance, moving along a complex path, with a timing function different from Bezier curves, or an animation on a canvas.

## Using setInterval

An animation can be implemented as a sequence of frames – usually small changes to HTML/CSS properties.

For instance, changing `style.left` from `0px` to `100px` moves the element. And if we increase it in `setInterval`, changing by `2px` with a tiny delay, like 50 times per second, then it looks smooth. That’s the same principle as in the cinema: 24 frames per second is enough to make it look smooth.

The pseudo-code can look like this:

    let timer = setInterval(function() {
      if (animation complete) clearInterval(timer);
      else increase style.left by 2px
    }, 20); // change by 2px every 20ms, about 50 frames per second

More complete example of the animation:

    let start = Date.now(); // remember start time

    let timer = setInterval(function() {
      // how much time passed from the start?
      let timePassed = Date.now() - start;

      if (timePassed >= 2000) {
        clearInterval(timer); // finish the animation after 2 seconds
        return;
      }

      // draw the animation at the moment timePassed
      draw(timePassed);

    }, 20);

    // as timePassed goes from 0 to 2000
    // left gets values from 0px to 400px
    function draw(timePassed) {
      train.style.left = timePassed / 5 + 'px';
    }

Click for the demo:

\[codetabs height=200 src=“move”\]

## Using requestAnimationFrame

Let’s imagine we have several animations running simultaneously.

If we run them separately, then even though each one has `setInterval(..., 20)`, then the browser would have to repaint much more often than every `20ms`.

That’s because they have different starting time, so “every 20ms” differs between different animations. The intervals are not aligned. So we’ll have several independent runs within `20ms`.

In other words, this:

    setInterval(function() {
      animate1();
      animate2();
      animate3();
    }, 20)

…Is lighter than three independent calls:

    setInterval(animate1, 20); // independent animations
    setInterval(animate2, 20); // in different places of the script
    setInterval(animate3, 20);

These several independent redraws should be grouped together, to make the redraw easier for the browser and hence load less CPU load and look smoother.

There’s one more thing to keep in mind. Sometimes CPU is overloaded, or there are other reasons to redraw less often (like when the browser tab is hidden), so we really shouldn’t run it every `20ms`.

But how do we know about that in JavaScript? There’s a specification [Animation timing](http://www.w3.org/TR/animation-timing/) that provides the function `requestAnimationFrame`. It addresses all these issues and even more.

The syntax:

    let requestId = requestAnimationFrame(callback)

That schedules the `callback` function to run in the closest time when the browser wants to do animation.

If we do changes in elements in `callback` then they will be grouped together with other `requestAnimationFrame` callbacks and with CSS animations. So there will be one geometry recalculation and repaint instead of many.

The returned value `requestId` can be used to cancel the call:

    // cancel the scheduled execution of callback
    cancelAnimationFrame(requestId);

The `callback` gets one argument – the time passed from the beginning of the page load in microseconds. This time can also be obtained by calling [performance.now()](mdn:api/Performance/now).

Usually `callback` runs very soon, unless the CPU is overloaded or the laptop battery is almost discharged, or there’s another reason.

The code below shows the time between first 10 runs for `requestAnimationFrame`. Usually it’s 10-20ms:

\`\`\`html run height=40 refresh

\`\`\`

## Structured animation

Now we can make a more universal animation function based on `requestAnimationFrame`:

    function animate({timing, draw, duration}) {

      let start = performance.now();

      requestAnimationFrame(function animate(time) {
        // timeFraction goes from 0 to 1
        let timeFraction = (time - start) / duration;
        if (timeFraction > 1) timeFraction = 1;

        // calculate the current animation state
        let progress = timing(timeFraction)

        draw(progress); // draw it

        if (timeFraction < 1) {
          requestAnimationFrame(animate);
        }

      });
    }

Function `animate` accepts 3 parameters that essentially describes the animation:

`duration`  
Total time of animation. Like, `1000`.

`timing(timeFraction)`  
Timing function, like CSS-property `transition-timing-function` that gets the fraction of time that passed (`0` at start, `1` at the end) and returns the animation completion (like `y` on the Bezier curve).

For instance, a linear function means that the animation goes on uniformly with the same speed:

    function linear(timeFraction) {
      return timeFraction;
    }

It’s graph: ![](linear.svg)

That’s just like `transition-timing-function: linear`. There are more interesting variants shown below.

`draw(progress)`  
The function that takes the animation completion state and draws it. The value `progress=0` denotes the beginning animation state, and `progress=1` – the end state.

This is that function that actually draws out the animation.

It can move the element:

    function draw(progress) {
      train.style.left = progress + 'px';
    }

…Or do anything else, we can animate anything, in any way.

Let’s animate the element `width` from `0` to `100%` using our function.

Click on the element for the demo:

\[codetabs height=60 src=“width”\]

The code for it:

    animate({
      duration: 1000,
      timing(timeFraction) {
        return timeFraction;
      },
      draw(progress) {
        elem.style.width = progress * 100 + '%';
      }
    });

Unlike CSS animation, we can make any timing function and any drawing function here. The timing function is not limited by Bezier curves. And `draw` can go beyond properties, create new elements for like fireworks animation or something.

## Timing functions

We saw the simplest, linear timing function above.

Let’s see more of them. We’ll try movement animations with different timing functions to see how they work.

### Power of n

If we want to speed up the animation, we can use `progress` in the power `n`.

For instance, a parabolic curve:

    function quad(timeFraction) {
      return Math.pow(timeFraction, 2)
    }

The graph:

![](quad.svg)

See in action (click to activate):

\[iframe height=40 src=“quad” link\]

…Or the cubic curve or even greater `n`. Increasing the power makes it speed up faster.

Here’s the graph for `progress` in the power `5`:

![](quint.svg)

In action:

\[iframe height=40 src=“quint” link\]

### The arc

Function:

    function circ(timeFraction) {
      return 1 - Math.sin(Math.acos(timeFraction));
    }

The graph:

![](circ.svg)

\[iframe height=40 src=“circ” link\]

### Back: bow shooting

This function does the “bow shooting”. First we “pull the bowstring”, and then “shoot”.

Unlike previous functions, it depends on an additional parameter `x`, the “elasticity coefficient”. The distance of “bowstring pulling” is defined by it.

The code:

    function back(x, timeFraction) {
      return Math.pow(timeFraction, 2) * ((x + 1) * timeFraction - x)
    }

**The graph for `x = 1.5`:**

![](back.svg)

For animation we use it with a specific value of `x`. Example for `x = 1.5`:

\[iframe height=40 src=“back” link\]

### Bounce

Imagine we are dropping a ball. It falls down, then bounces back a few times and stops.

The `bounce` function does the same, but in the reverse order: “bouncing” starts immediately. It uses few special coefficients for that:

    function bounce(timeFraction) {
      for (let a = 0, b = 1, result; 1; a += b, b /= 2) {
        if (timeFraction >= (7 - 4 * a) / 11) {
          return -Math.pow((11 - 6 * a - 11 * timeFraction) / 4, 2) + Math.pow(b, 2)
        }
      }
    }

In action:

\[iframe height=40 src=“bounce” link\]

### Elastic animation

One more “elastic” function that accepts an additional parameter `x` for the “initial range”.

    function elastic(x, timeFraction) {
      return Math.pow(2, 10 * (timeFraction - 1)) * Math.cos(20 * Math.PI * x / 3 * timeFraction)
    }

**The graph for `x=1.5`:** ![](elastic.svg)

In action for `x=1.5`:

\[iframe height=40 src=“elastic” link\]

## Reversal: ease\*

So we have a collection of timing functions. Their direct application is called “easeIn”.

Sometimes we need to show the animation in the reverse order. That’s done with the “easeOut” transform.

### easeOut

In the “easeOut” mode the `timing` function is put into a wrapper `timingEaseOut`:

    timingEaseOut(timeFraction) = 1 - timing(1 - timeFraction)

In other words, we have a “transform” function `makeEaseOut` that takes a “regular” timing function and returns the wrapper around it:

    // accepts a timing function, returns the transformed variant
    function makeEaseOut(timing) {
      return function(timeFraction) {
        return 1 - timing(1 - timeFraction);
      }
    }

For instance, we can take the `bounce` function described above and apply it:

    let bounceEaseOut = makeEaseOut(bounce);

Then the bounce will be not in the beginning, but at the end of the animation. Looks even better:

\[codetabs src=“bounce-easeout”\]

Here we can see how the transform changes the behavior of the function:

![](bounce-inout.svg)

If there’s an animation effect in the beginning, like bouncing – it will be shown at the end.

In the graph above the <span style="color:#EE6B47">regular bounce</span> has the red color, and the <span style="color:#62C0DC">easeOut bounce</span> is blue.

- Regular bounce – the object bounces at the bottom, then at the end sharply jumps to the top.
- After `easeOut` – it first jumps to the top, then bounces there.

### easeInOut

We also can show the effect both in the beginning and the end of the animation. The transform is called “easeInOut”.

Given the timing function, we calculate the animation state like this:

    if (timeFraction <= 0.5) { // first half of the animation
      return timing(2 * timeFraction) / 2;
    } else { // second half of the animation
      return (2 - timing(2 * (1 - timeFraction))) / 2;
    }

The wrapper code:

    function makeEaseInOut(timing) {
      return function(timeFraction) {
        if (timeFraction < .5)
          return timing(2 * timeFraction) / 2;
        else
          return (2 - timing(2 * (1 - timeFraction))) / 2;
      }
    }

    bounceEaseInOut = makeEaseInOut(bounce);

In action, `bounceEaseInOut`:

\[codetabs src=“bounce-easeinout”\]

The “easeInOut” transform joins two graphs into one: `easeIn` (regular) for the first half of the animation and `easeOut` (reversed) – for the second part.

The effect is clearly seen if we compare the graphs of `easeIn`, `easeOut` and `easeInOut` of the `circ` timing function:

![](circ-ease.svg)

- <span style="color:#EE6B47">Red</span> is the regular variant of `circ` (`easeIn`).
- <span style="color:#8DB173">Green</span> – `easeOut`.
- <span style="color:#62C0DC">Blue</span> – `easeInOut`.

As we can see, the graph of the first half of the animation is the scaled down `easeIn`, and the second half is the scaled down `easeOut`. As a result, the animation starts and finishes with the same effect.

## More interesting “draw”

Instead of moving the element we can do something else. All we need is to write the proper `draw`.

Here’s the animated “bouncing” text typing:

\[codetabs src=“text”\]

## Summary

For animations that CSS can’t handle well, or those that need tight control, JavaScript can help. JavaScript animations should be implemented via `requestAnimationFrame`. That built-in method allows to setup a callback function to run when the browser will be preparing a repaint. Usually that’s very soon, but the exact time depends on the browser.

When a page is in the background, there are no repaints at all, so the callback won’t run: the animation will be suspended and won’t consume resources. That’s great.

Here’s the helper `animate` function to setup most animations:

    function animate({timing, draw, duration}) {

      let start = performance.now();

      requestAnimationFrame(function animate(time) {
        // timeFraction goes from 0 to 1
        let timeFraction = (time - start) / duration;
        if (timeFraction > 1) timeFraction = 1;

        // calculate the current animation state
        let progress = timing(timeFraction);

        draw(progress); // draw it

        if (timeFraction < 1) {
          requestAnimationFrame(animate);
        }

      });
    }

Options:

- `duration` – the total animation time in ms.
- `timing` – the function to calculate animation progress. Gets a time fraction from 0 to 1, returns the animation progress, usually from 0 to 1.
- `draw` – the function to draw the animation.

Surely we could improve it, add more bells and whistles, but JavaScript animations are not applied on a daily basis. They are used to do something interesting and non-standard. So you’d want to add the features that you need when you need them.

JavaScript animations can use any timing function. We covered a lot of examples and transformations to make them even more versatile. Unlike CSS, we are not limited to Bezier curves here.

The same is about `draw`: we can animate anything, not just CSS properties. \# Logical operators

There are four logical operators in JavaScript: `||` (OR), `&&` (AND), `!` (NOT), `??` (Nullish Coalescing). Here we cover the first three, the `??` operator is in the next article.

Although they are called “logical”, they can be applied to values of any type, not only boolean. Their result can also be of any type.

Let’s see the details.

## || (OR)

The “OR” operator is represented with two vertical line symbols:

    result = a || b;

In classical programming, the logical OR is meant to manipulate boolean values only. If any of its arguments are `true`, it returns `true`, otherwise it returns `false`.

In JavaScript, the operator is a little bit trickier and more powerful. But first, let’s see what happens with boolean values.

There are four possible logical combinations:

`js run alert( true || true ); // true alert( false || true ); // true alert( true || false ); // true alert( false || false ); // false`

As we can see, the result is always `true` except for the case when both operands are `false`.

If an operand is not a boolean, it’s converted to a boolean for the evaluation.

For instance, the number `1` is treated as `true`, the number `0` as `false`:

`js run if (1 || 0) { // works just like if( true || false ) alert( 'truthy!' ); }`

Most of the time, OR `||` is used in an `if` statement to test if _any_ of the given conditions is `true`.

For example:

\`\`\`js run let hour = 9;

_!_ if (hour &lt; 10 || hour &gt; 18) { _/!_ alert( ‘The office is closed.’ ); } \`\`\`

We can pass more conditions:

\`\`\`js run let hour = 12; let isWeekend = true;

if (hour &lt; 10 || hour &gt; 18 || isWeekend) { alert( ‘The office is closed.’ ); // it is the weekend } \`\`\`

## OR “||” finds the first truthy value \[\#or-finds-the-first-truthy-value\]

The logic described above is somewhat classical. Now, let’s bring in the “extra” features of JavaScript.

The extended algorithm works as follows.

Given multiple OR’ed values:

    result = value1 || value2 || value3;

The OR `||` operator does the following:

- Evaluates operands from left to right.
- For each operand, converts it to boolean. If the result is `true`, stops and returns the original value of that operand.
- If all operands have been evaluated (i.e. all were `false`), returns the last operand.

A value is returned in its original form, without the conversion.

In other words, a chain of OR `||` returns the first truthy value or the last one if no truthy value is found.

For instance:

\`\`\`js run alert( 1 || 0 ); // 1 (1 is truthy)

alert( null || 1 ); // 1 (1 is the first truthy value) alert( null || 0 || 1 ); // 1 (the first truthy value)

alert( undefined || null || 0 ); // 0 (all falsy, returns the last value) \`\`\`

This leads to some interesting usage compared to a “pure, classical, boolean-only OR”.

1.  **Getting the first truthy value from a list of variables or expressions.**

    For instance, we have `firstName`, `lastName` and `nickName` variables, all optional (i.e. can be undefined or have falsy values).

    Let’s use OR `||` to choose the one that has the data and show it (or `"Anonymous"` if nothing set):

    \`\`\`js run let firstName = "“; let lastName =”“; let nickName =”SuperCoder";

    _!_ alert( firstName || lastName || nickName || “Anonymous”); // SuperCoder _/!_ \`\`\`

    If all variables were falsy, `"Anonymous"` would show up.

2.  **Short-circuit evaluation.**

    Another feature of OR `||` operator is the so-called “short-circuit” evaluation.

    It means that `||` processes its arguments until the first truthy value is reached, and then the value is returned immediately, without even touching the other argument.

    That importance of this feature becomes obvious if an operand isn’t just a value, but an expression with a side effect, such as a variable assignment or a function call.

    In the example below, only the second message is printed:

    `js run no-beautify *!*true*/!* || alert("not printed"); *!*false*/!* || alert("printed");`

    In the first line, the OR `||` operator stops the evaluation immediately upon seeing `true`, so the `alert` isn’t run.

    Sometimes, people use this feature to execute commands only if the condition on the left part is falsy.

## && (AND)

The AND operator is represented with two ampersands `&&`:

    result = a && b;

In classical programming, AND returns `true` if both operands are truthy and `false` otherwise:

`js run alert( true && true ); // true alert( false && true ); // false alert( true && false ); // false alert( false && false ); // false`

An example with `if`:

\`\`\`js run let hour = 12; let minute = 30;

if (hour == 12 && minute == 30) { alert( ‘The time is 12:30’ ); } \`\`\`

Just as with OR, any value is allowed as an operand of AND:

`js run if (1 && 0) { // evaluated as true && false alert( "won't work, because the result is falsy" ); }`

## AND “&&” finds the first falsy value

Given multiple AND’ed values:

    result = value1 && value2 && value3;

The AND `&&` operator does the following:

- Evaluates operands from left to right.
- For each operand, converts it to a boolean. If the result is `false`, stops and returns the original value of that operand.
- If all operands have been evaluated (i.e. all were truthy), returns the last operand.

In other words, AND returns the first falsy value or the last value if none were found.

The rules above are similar to OR. The difference is that AND returns the first _falsy_ value while OR returns the first _truthy_ one.

Examples:

\`\`\`js run // if the first operand is truthy, // AND returns the second operand: alert( 1 && 0 ); // 0 alert( 1 && 5 ); // 5

// if the first operand is falsy, // AND returns it. The second operand is ignored alert( null && 5 ); // null alert( 0 && “no matter what” ); // 0 \`\`\`

We can also pass several values in a row. See how the first falsy one is returned:

`js run alert( 1 && 2 && null && 3 ); // null`

When all values are truthy, the last value is returned:

`js run alert( 1 && 2 && 3 ); // 3, the last one`

\`\`\``smart header="Precedence of AND`&&`is higher than OR`||`" The precedence of AND`&&`operator is higher than OR`||\`.

So the code `a && b || c && d` is essentially the same as if the `&&` expressions were in parentheses: `(a && b) || (c && d)`. \`\`\`\`

\`\`\``warn header="Don't replace`if`with`||`or`&&`" Sometimes, people use the AND`&&`operator as a "shorter way to write`if\`".

For instance:

\`\`\`js run let x = 1;

(x &gt; 0) && alert( ‘Greater than zero!’ ); \`\`\`

The action in the right part of `&&` would execute only if the evaluation reaches it. That is, only if `(x > 0)` is true.

So we basically have an analogue for:

\`\`\`js run let x = 1;

if (x &gt; 0) alert( ‘Greater than zero!’ );

    Although, the variant with `&&` appears shorter, `if` is more obvious and tends to be a little bit more readable. So we recommend using every construct for its purpose: use `if` if we want `if` and use `&&` if we want AND.

## ! (NOT)

The boolean NOT operator is represented with an exclamation sign `!`.

The syntax is pretty simple:

    result = !value;

The operator accepts a single argument and does the following:

1.  Converts the operand to boolean type: `true/false`.
2.  Returns the inverse value.

For instance:

`js run alert( !true ); // false alert( !0 ); // true`

A double NOT `!!` is sometimes used for converting a value to boolean type:

`js run alert( !!"non-empty string" ); // true alert( !!null ); // false`

That is, the first NOT converts the value to boolean and returns the inverse, and the second NOT inverses it again. In the end, we have a plain value-to-boolean conversion.

There’s a little more verbose way to do the same thing – a built-in `Boolean` function:

`js run alert( Boolean("non-empty string") ); // true alert( Boolean(null) ); // false`

The precedence of NOT `!` is the highest of all logical operators, so it always executes first, before `&&` or `||`. \# From the orbital height

This section describes a set of modern standards for “web components”.

As of now, these standards are under development. Some features are well-supported and integrated into the modern HTML/DOM standard, while others are yet in draft stage. You can try examples in any browser, Google Chrome is probably the most up to date with these features. Guess, that’s because Google fellows are behind many of the related specifications.

## What’s common between…

The whole component idea is nothing new. It’s used in many frameworks and elsewhere.

Before we move to implementation details, take a look at this great achievement of humanity:

![](satellite.jpg)

That’s the International Space Station (ISS).

And this is how it’s made inside (approximately):

![](satellite-expanded.jpg)

The International Space Station: - Consists of many components. - Each component, in its turn, has many smaller details inside. - The components are very complex, much more complicated than most websites. - Components are developed internationally, by teams from different countries, speaking different languages.

…And this thing flies, keeps humans alive in space!

How such complex devices are created?

Which principles we could borrow to make our development same-level reliable and scalable? Or, at least, close to it.

## Component architecture

The well known rule for developing complex software is: don’t make complex software.

If something becomes complex – split it into simpler parts and connect in the most obvious way.

**A good architect is the one who can make the complex simple.**

We can split user interface into visual components: each of them has own place on the page, can “do” a well-described task, and is separate from the others.

Let’s take a look at a website, for example Twitter.

It naturally splits into components:

![](web-components-twitter.svg)

1.  Top navigation.
2.  User info.
3.  Follow suggestions.
4.  Submit form.
5.  (and also 6, 7) – messages.

Components may have subcomponents, e.g. messages may be parts of a higher-level “message list” component. A clickable user picture itself may be a component, and so on.

How do we decide, what is a component? That comes from intuition, experience and common sense. Usually it’s a separate visual entity that we can describe in terms of what it does and how it interacts with the page. In the case above, the page has blocks, each of them plays its own role, it’s logical to make these components.

A component has: - Its own JavaScript class. - DOM structure, managed solely by its class, outside code doesn’t access it (“encapsulation” principle). - CSS styles, applied to the component. - API: events, class methods etc, to interact with other components.

Once again, the whole “component” thing is nothing special.

There exist many frameworks and development methodologies to build them, each with its own bells and whistles. Usually, special CSS classes and conventions are used to provide “component feel” – CSS scoping and DOM encapsulation.

“Web components” provide built-in browser capabilities for that, so we don’t have to emulate them any more.

- [Custom elements](https://html.spec.whatwg.org/multipage/custom-elements.html#custom-elements) – to define custom HTML elements.
- [Shadow DOM](https://dom.spec.whatwg.org/#shadow-trees) – to create an internal DOM for the component, hidden from the others.
- [CSS Scoping](https://drafts.csswg.org/css-scoping/) – to declare styles that only apply inside the Shadow DOM of the component.
- [Event retargeting](https://dom.spec.whatwg.org/#retarget) and other minor stuff to make custom components better fit the development.

In the next chapter we’ll go into details of “Custom Elements” – the fundamental and well-supported feature of web components, good on its own.

# Custom elements

We can create custom HTML elements, described by our class, with its own methods and properties, events and so on.

Once a custom element is defined, we can use it on par with built-in HTML elements.

That’s great, as HTML dictionary is rich, but not infinite. There are no `<easy-tabs>`, `<sliding-carousel>`, `<beautiful-upload>`… Just think of any other tag we might need.

We can define them with a special class, and then use as if they were always a part of HTML.

There are two kinds of custom elements:

1.  **Autonomous custom elements** – “all-new” elements, extending the abstract `HTMLElement` class.
2.  **Customized built-in elements** – extending built-in elements, like a customized button, based on `HTMLButtonElement` etc.

First we’ll cover autonomous elements, and then move to customized built-in ones.

To create a custom element, we need to tell the browser several details about it: how to show it, what to do when the element is added or removed to page, etc.

That’s done by making a class with special methods. That’s easy, as there are only few methods, and all of them are optional.

Here’s a sketch with the full list:

    class MyElement extends HTMLElement {
      constructor() {
        super();
        // element created
      }

      connectedCallback() {
        // browser calls this method when the element is added to the document
        // (can be called many times if an element is repeatedly added/removed)
      }

      disconnectedCallback() {
        // browser calls this method when the element is removed from the document
        // (can be called many times if an element is repeatedly added/removed)
      }

      static get observedAttributes() {
        return [/* array of attribute names to monitor for changes */];
      }

      attributeChangedCallback(name, oldValue, newValue) {
        // called when one of attributes listed above is modified
      }

      adoptedCallback() {
        // called when the element is moved to a new document
        // (happens in document.adoptNode, very rarely used)
      }

      // there can be other element methods and properties
    }

After that, we need to register the element:

    // let the browser know that <my-element> is served by our new class
    customElements.define("my-element", MyElement);

Now for any HTML elements with tag `<my-element>`, an instance of `MyElement` is created, and the aforementioned methods are called. We also can `document.createElement('my-element')` in JavaScript.

\`\``smart header="Custom element name must contain a hyphen`-`" Custom element name must have a hyphen`-`, e.g.`my-element`and`super-button`are valid names, but`myelement\` is not.

That’s to ensure that there are no name conflicts between built-in and custom HTML elements. \`\`\`

## Example: “time-formatted”

For example, there already exists `<time>` element in HTML, for date/time. But it doesn’t do any formatting by itself.

Let’s create `<time-formatted>` element that displays the time in a nice, language-aware format:

\`\`\`html run height=50 autorun=“no-epub”

_!_ &lt;time-formatted datetime=“2019-12-01” _/!_ year=“numeric” month=“long” day=“numeric” hour=“numeric” minute=“numeric” second=“numeric” time-zone-name=“short” &gt; \`\`\`

1.  The class has only one method `connectedCallback()` – the browser calls it when `<time-formatted>` element is added to page (or when HTML parser detects it), and it uses the built-in [Intl.DateTimeFormat](mdn:/JavaScript/Reference/Global_Objects/DateTimeFormat) data formatter, well-supported across the browsers, to show a nicely formatted time.
2.  We need to register our new element by `customElements.define(tag, class)`.
3.  And then we can use it everywhere.

\`\`` smart header="Custom elements upgrade" If the browser encounters any``elements before `customElements.define\`, that’s not an error. But the element is yet unknown, just like any non-standard tag.

Such “undefined” elements can be styled with CSS selector `:not(:defined)`.

When `customElement.define` is called, they are “upgraded”: a new instance of `TimeFormatted` is created for each, and `connectedCallback` is called. They become `:defined`.

To get the information about custom elements, there are methods: - `customElements.get(name)` – returns the class for a custom element with the given `name`, - `customElements.whenDefined(name)` – returns a promise that resolves (without value) when a custom element with the given `name` becomes defined. \`\`\`

\`\``smart header="Rendering in`connectedCallback`, not in`constructor`" In the example above, element content is rendered (created) in`connectedCallback\`.

Why not in the `constructor`?

The reason is simple: when `constructor` is called, it’s yet too early. The element is created, but the browser did not yet process/assign attributes at this stage: calls to `getAttribute` would return `null`. So we can’t really render there.

Besides, if you think about it, that’s better performance-wise – to delay the work until it’s really needed.

The `connectedCallback` triggers when the element is added to the document. Not just appended to another element as a child, but actually becomes a part of the page. So we can build detached DOM, create elements and prepare them for later use. They will only be actually rendered when they make it into the page. \`\`\`

## Observing attributes

In the current implementation of `<time-formatted>`, after the element is rendered, further attribute changes don’t have any effect. That’s strange for an HTML element. Usually, when we change an attribute, like `a.href`, we expect the change to be immediately visible. So let’s fix this.

We can observe attributes by providing their list in `observedAttributes()` static getter. For such attributes, `attributeChangedCallback` is called when they are modified. It doesn’t trigger for other, unlisted attributes (that’s for performance reasons).

Here’s a new `<time-formatted>`, that auto-updates when attributes change:

\`\`\`html run autorun=“no-epub” height=50

\`\`\`

1.  The rendering logic is moved to `render()` helper method.
2.  We call it once when the element is inserted into page.
3.  For a change of an attribute, listed in `observedAttributes()`, `attributeChangedCallback` triggers.
4.  …and re-renders the element.
5.  At the end, we can easily make a live timer.

## Rendering order

When HTML parser builds the DOM, elements are processed one after another, parents before children. E.g. if we have `<outer><inner></inner></outer>`, then `<outer>` element is created and connected to DOM first, and then `<inner>`.

That leads to important consequences for custom elements.

For example, if a custom element tries to access `innerHTML` in `connectedCallback`, it gets nothing:

\`\`\`html run height=40

_!_ John _/!_ \`\`\`

If you run it, the `alert` is empty.

That’s exactly because there are no children on that stage, the DOM is unfinished. HTML parser connected the custom element `<user-info>`, and is going to proceed to its children, but just didn’t yet.

If we’d like to pass information to custom element, we can use attributes. They are available immediately.

Or, if we really need the children, we can defer access to them with zero-delay `setTimeout`.

This works:

\`\`\`html run height=40

_!_ John _/!_ \`\`\`

Now the `alert` in line `(*)` shows “John”, as we run it asynchronously, after the HTML parsing is complete. We can process children if needed and finish the initialization.

On the other hand, this solution is also not perfect. If nested custom elements also use `setTimeout` to initialize themselves, then they queue up: the outer `setTimeout` triggers first, and then the inner one.

So the outer element finishes the initialization before the inner one.

Let’s demonstrate that on example:

\`\``html run height=0 <script> customElements.define('user-info', class extends HTMLElement { connectedCallback() { alert(`<span class="math inline">${this.id} connected.\`); setTimeout(() =&gt; alert(\`$</span>{this.id} initialized.\`)); } });

_!_ _/!_ \`\`\`

Output order:

1.  outer connected.
2.  inner connected.
3.  outer initialized.
4.  inner initialized.

We can clearly see that the outer element finishes initialization `(3)` before the inner one `(4)`.

There’s no built-in callback that triggers after nested elements are ready. If needed, we can implement such thing on our own. For instance, inner elements can dispatch events like `initialized`, and outer ones can listen and react on them.

## Customized built-in elements

New elements that we create, such as `<time-formatted>`, don’t have any associated semantics. They are unknown to search engines, and accessibility devices can’t handle them.

But such things can be important. E.g, a search engine would be interested to know that we actually show a time. And if we’re making a special kind of button, why not reuse the existing `<button>` functionality?

We can extend and customize built-in HTML elements by inheriting from their classes.

For example, buttons are instances of `HTMLButtonElement`, let’s build upon it.

1.  Extend `HTMLButtonElement` with our class:

        class HelloButton extends HTMLButtonElement { /* custom element methods */ }

2.  Provide the third argument to `customElements.define`, that specifies the tag: `js customElements.define('hello-button', HelloButton, *!*{extends: 'button'}*/!*);`

    There may be different tags that share the same DOM-class, that’s why specifying `extends` is needed.

3.  At the end, to use our custom element, insert a regular `<button>` tag, but add `is="hello-button"` to it: `html <button is="hello-button">...</button>`

Here’s a full example:

\`\`\`html run autorun=“no-epub”

_!_ Click me _/!_

_!_ Disabled _/!_ \`\`\`

Our new button extends the built-in one. So it keeps the same styles and standard features like `disabled` attribute.

## References

- HTML Living Standard: <a href="https://html.spec.whatwg.org/#custom-elements" class="uri">https://html.spec.whatwg.org/#custom-elements</a>.
- Compatiblity: <a href="https://caniuse.com/#feat=custom-elementsv1" class="uri">https://caniuse.com/#feat=custom-elementsv1</a>.

## Summary

Custom elements can be of two types:

1.  “Autonomous” – new tags, extending `HTMLElement`.

    Definition scheme:

        class MyElement extends HTMLElement {
          constructor() { super(); /* ... */ }
          connectedCallback() { /* ... */ }
          disconnectedCallback() { /* ... */  }
          static get observedAttributes() { return [/* ... */]; }
          attributeChangedCallback(name, oldValue, newValue) { /* ... */ }
          adoptedCallback() { /* ... */ }
         }
        customElements.define('my-element', MyElement);
        /* <my-element> */

2.  “Customized built-in elements” – extensions of existing elements.

    Requires one more `.define` argument, and `is="..."` in HTML: `js class MyButton extends HTMLButtonElement { /*...*/ } customElements.define('my-button', MyElement, {extends: 'button'}); /* <button is="my-button"> */`

Custom elements are well-supported among browsers. There’s a polyfill <a href="https://github.com/webcomponents/polyfills/tree/master/packages/webcomponentsjs" class="uri">https://github.com/webcomponents/polyfills/tree/master/packages/webcomponentsjs</a>. \# Shadow DOM

Shadow DOM serves for encapsulation. It allows a component to have its very own “shadow” DOM tree, that can’t be accidentally accessed from the main document, may have local style rules, and more.

## Built-in shadow DOM

Did you ever think how complex browser controls are created and styled?

Such as `<input type="range">`:

The browser uses DOM/CSS internally to draw them. That DOM structure is normally hidden from us, but we can see it in developer tools. E.g. in Chrome, we need to enable in Dev Tools “Show user agent shadow DOM” option.

Then `<input type="range">` looks like this:

![](shadow-dom-range.png)

What you see under `#shadow-root` is called “shadow DOM”.

We can’t get built-in shadow DOM elements by regular JavaScript calls or selectors. These are not regular children, but a powerful encapsulation technique.

In the example above, we can see a useful attribute `pseudo`. It’s non-standard, exists for historical reasons. We can use it style subelements with CSS, like this:

\`\`\`html run autorun

\`\`\`

Once again, `pseudo` is a non-standard attribute. Chronologically, browsers first started to experiment with internal DOM structures to implement controls, and then, after time, shadow DOM was standardized to allow us, developers, to do the similar thing.

Further on, we’ll use the modern shadow DOM standard, covered by [DOM spec](https://dom.spec.whatwg.org/#shadow-trees) and other related specifications.

## Shadow tree

A DOM element can have two types of DOM subtrees:

1.  Light tree – a regular DOM subtree, made of HTML children. All subtrees that we’ve seen in previous chapters were “light”.
2.  Shadow tree – a hidden DOM subtree, not reflected in HTML, hidden from prying eyes.

If an element has both, then the browser renders only the shadow tree. But we can setup a kind of composition between shadow and light trees as well. We’ll see the details later in the chapter <a href="info:slots-composition" class="uri">info:slots-composition</a>.

Shadow tree can be used in Custom Elements to hide component internals and apply component-local styles.

For example, this `<show-hello>` element hides its internal DOM in shadow tree:

\`\``html run autorun height=60 <script> customElements.define('show-hello', class extends HTMLElement { connectedCallback() { const shadow = this.attachShadow({mode: 'open'}); shadow.innerHTML =`

Hello, ${this.getAttribute(‘name’)}

\`; }  
});

\`\`\`

That’s how the resulting DOM looks in Chrome dev tools, all the content is under “\#shadow-root”:

![](shadow-dom-say-hello.png)

First, the call to `elem.attachShadow({mode: …})` creates a shadow tree.

There are two limitations: 1. We can create only one shadow root per element. 2. The `elem` must be either a custom element, or one of: “article”, “aside”, “blockquote”, “body”, “div”, “footer”, “h1..h6”, “header”, “main” “nav”, “p”, “section”, or “span”. Other elements, like `<img>`, can’t host shadow tree.

The `mode` option sets the encapsulation level. It must have any of two values: - `"open"` – the shadow root is available as `elem.shadowRoot`.

    Any code is able to access the shadow tree of `elem`.

- `"closed"` – `elem.shadowRoot` is always `null`.

  We can only access the shadow DOM by the reference returned by `attachShadow` (and probably hidden inside a class). Browser-native shadow trees, such as `<input type="range">`, are closed. There’s no way to access them.

The [shadow root](https://dom.spec.whatwg.org/#shadowroot), returned by `attachShadow`, is like an element: we can use `innerHTML` or DOM methods, such as `append`, to populate it.

The element with a shadow root is called a “shadow tree host”, and is available as the shadow root `host` property:

    // assuming {mode: "open"}, otherwise elem.shadowRoot is null
    alert(elem.shadowRoot.host === elem); // true

## Encapsulation

Shadow DOM is strongly delimited from the main document:

1.  Shadow DOM elements are not visible to `querySelector` from the light DOM. In particular, Shadow DOM elements may have ids that conflict with those in the light DOM. They must be unique only within the shadow tree.
2.  Shadow DOM has own stylesheets. Style rules from the outer DOM don’t get applied.

For example:

\`\`\`html run untrusted height=40

\`\`\`

1.  The style from the document does not affect the shadow tree.
2.  …But the style from the inside works.
3.  To get elements in shadow tree, we must query from inside the tree.

## References

- DOM: <a href="https://dom.spec.whatwg.org/#shadow-trees" class="uri">https://dom.spec.whatwg.org/#shadow-trees</a>
- Compatibility: <a href="https://caniuse.com/#feat=shadowdomv1" class="uri">https://caniuse.com/#feat=shadowdomv1</a>
- Shadow DOM is mentioned in many other specifications, e.g. [DOM Parsing](https://w3c.github.io/DOM-Parsing/#the-innerhtml-mixin) specifies that shadow root has `innerHTML`.

## Summary

Shadow DOM is a way to create a component-local DOM.

1.  `shadowRoot = elem.attachShadow({mode: open|closed})` – creates shadow DOM for `elem`. If `mode="open"`, then it’s accessible as `elem.shadowRoot` property.
2.  We can populate `shadowRoot` using `innerHTML` or other DOM methods.

Shadow DOM elements: - Have their own ids space, - Invisible to JavaScript selectors from the main document, such as `querySelector`, - Use styles only from the shadow tree, not from the main document.

Shadow DOM, if exists, is rendered by the browser instead of so-called “light DOM” (regular children). In the chapter <a href="info:slots-composition" class="uri">info:slots-composition</a> we’ll see how to compose them.

# Template element

A built-in `<template>` element serves as a storage for HTML markup templates. The browser ignores it contents, only checks for syntax validity, but we can access and use it in JavaScript, to create other elements.

In theory, we could create any invisible element somewhere in HTML for HTML markup storage purposes. What’s special about `<template>`?

First, its content can be any valid HTML, even if it normally requires a proper enclosing tag.

For example, we can put there a table row `<tr>`:

    <template>
      <tr>
        <td>Contents</td>
      </tr>
    </template>

Usually, if we try to put `<tr>` inside, say, a `<div>`, the browser detects the invalid DOM structure and “fixes” it, adds `<table>` around. That’s not what we want. On the other hand, `<template>` keeps exactly what we place there.

We can put styles and scripts into `<template>` as well:

    <template>
      <style>
        p { font-weight: bold; }
      </style>
      <script>
        alert("Hello");
      </script>
    </template>

The browser considers `<template>` content “out of the document”: styles are not applied, scripts are not executed, `<video autoplay>` is not run, etc.

The content becomes live (styles apply, scripts run etc) when we insert it into the document.

## Inserting template

The template content is available in its `content` property as a [DocumentFragment](info:modifying-document#document-fragment) – a special type of DOM node.

We can treat it as any other DOM node, except one special property: when we insert it somewhere, its children are inserted instead.

For example:

\`\`\`html run

Hello, world!

\`\`\`

Let’s rewrite a Shadow DOM example from the previous chapter using `<template>`:

\`\`\`html run untrusted autorun=“no-epub” height=60

Click me

\`\`\`

In the line `(*)` when we clone and insert `tmpl.content`, as its `DocumentFragment`, its children (`<style>`, `<p>`) are inserted instead.

They form the shadow DOM:

    <div id="elem">
      #shadow-root
        <style> p { font-weight: bold; } </style>
        <p id="message"></p>
    </div>

## Summary

To summarize:

- `<template>` content can be any syntactically correct HTML.
- `<template>` content is considered “out of the document”, so it doesn’t affect anything.
- We can access `template.content` from JavaScript, clone it to reuse in a new component.

The `<template>` tag is quite unique, because:

- The browser checks HTML syntax inside it (as opposed to using a template string inside a script).
- …But still allows use of any top-level HTML tags, even those that don’t make sense without proper wrappers (e.g. `<tr>`).
- The content becomes interactive: scripts run, `<video autoplay>` plays etc, when inserted into the document.

The `<template>` element does not feature any iteration mechanisms, data binding or variable substitutions, but we can implement those on top of it. \# Shadow DOM slots, composition

Many types of components, such as tabs, menus, image galleries, and so on, need the content to render.

Just like built-in browser `<select>` expects `<option>` items, our `<custom-tabs>` may expect the actual tab content to be passed. And a `<custom-menu>` may expect menu items.

The code that makes use of `<custom-menu>` can look like this:

    <custom-menu>
      <title>Candy menu</title>
      <item>Lollipop</item>
      <item>Fruit Toast</item>
      <item>Cup Cake</item>
    </custom-menu>

…Then our component should render it properly, as a nice menu with given title and items, handle menu events, etc.

How to implement it?

We could try to analyze the element content and dynamically copy-rearrange DOM nodes. That’s possible, but if we’re moving elements to shadow DOM, then CSS styles from the document do not apply in there, so the visual styling may be lost. Also that requires some coding.

Luckily, we don’t have to. Shadow DOM supports `<slot>` elements, that are automatically filled by the content from light DOM.

## Named slots

Let’s see how slots work on a simple example.

Here, `<user-card>` shadow DOM provides two slots, filled from light DOM:

\`\``html run autorun="no-epub" untrusted height=80 <script> customElements.define('user-card', class extends HTMLElement { connectedCallback() { this.attachShadow({mode: 'open'}); this.shadowRoot.innerHTML =`

Name: _!_ _/!_

      <div>Birthday:

_!_ _/!_

    `;

} });

&lt;span *!*slot=“username”_/!_&gt;John Smith &lt;span *!*slot=“birthday”_/!_&gt;01.01.2001 \`\`\`

In the shadow DOM, `<slot name="X">` defines an “insertion point”, a place where elements with `slot="X"` are rendered.

Then the browser performs “composition”: it takes elements from the light DOM and renders them in corresponding slots of the shadow DOM. At the end, we have exactly what we want – a component that can be filled with data.

Here’s the DOM structure after the script, not taking composition into account:

    <user-card>
      #shadow-root
        <div>Name:
          <slot name="username"></slot>
        </div>
        <div>Birthday:
          <slot name="birthday"></slot>
        </div>
      <span slot="username">John Smith</span>
      <span slot="birthday">01.01.2001</span>
    </user-card>

We created the shadow DOM, so here it is, under `#shadow-root`. Now the element has both light and shadow DOM.

For rendering purposes, for each `<slot name="...">` in shadow DOM, the browser looks for `slot="..."` with the same name in the light DOM. These elements are rendered inside the slots:

![](shadow-dom-user-card.svg)

The result is called “flattened” DOM:

    <user-card>
      #shadow-root
        <div>Name:
          <slot name="username">
            <!-- slotted element is inserted into the slot -->
            <span slot="username">John Smith</span>
          </slot>
        </div>
        <div>Birthday:
          <slot name="birthday">
            <span slot="birthday">01.01.2001</span>
          </slot>
        </div>
    </user-card>

…But the flattened DOM exists only for rendering and event-handling purposes. It’s kind of “virtual”. That’s how things are shown. But the nodes in the document are actually not moved around!

That can be easily checked if we run `querySelectorAll`: nodes are still at their places.

    // light DOM <span> nodes are still at the same place, under `<user-card>`
    alert( document.querySelectorAll('user-card span').length ); // 2

So, the flattened DOM is derived from shadow DOM by inserting slots. The browser renders it and uses for style inheritance, event propagation (more about that later). But JavaScript still sees the document “as is”, before flattening.

\`\`\``warn header="Only top-level children may have slot=\"...\" attribute" The`slot=“…”`attribute is only valid for direct children of the shadow host (in our example,`\` element). For nested elements it’s ignored.

For example, the second `<span>` here is ignored (as it’s not a top-level child of `<user-card>`):

    <user-card>
      <span slot="username">John Smith</span>
      <div>
        <!-- invalid slot, must be direct child of user-card -->
        <span slot="birthday">01.01.2001</span>
      </div>
    </user-card>

\`\`\`\`

If there are multiple elements in light DOM with the same slot name, they are appended into the slot, one after another.

For example, this:

    <user-card>
      <span slot="username">John</span>
      <span slot="username">Smith</span>
    </user-card>

Gives this flattened DOM with two elements in `<slot name="username">`:

    <user-card>
      #shadow-root
        <div>Name:
          <slot name="username">
            <span slot="username">John</span>
            <span slot="username">Smith</span>
          </slot>
        </div>
        <div>Birthday:
          <slot name="birthday"></slot>
        </div>
    </user-card>

## Slot fallback content

If we put something inside a `<slot>`, it becomes the fallback, “default” content. The browser shows it if there’s no corresponding filler in light DOM.

For example, in this piece of shadow DOM, `Anonymous` renders if there’s no `slot="username"` in light DOM.

    <div>Name:
      <slot name="username">Anonymous</slot>
    </div>

## Default slot: first unnamed

The first `<slot>` in shadow DOM that doesn’t have a name is a “default” slot. It gets all nodes from the light DOM that aren’t slotted elsewhere.

For example, let’s add the default slot to our `<user-card>` that shows all unslotted information about the user:

\`\``html run autorun="no-epub" untrusted height=140 <script> customElements.define('user-card', class extends HTMLElement { connectedCallback() { this.attachShadow({mode: 'open'}); this.shadowRoot.innerHTML =`

Name:

    <div>Birthday:
      <slot name="birthday"></slot>
    </div>
    <fieldset>
      <legend>Other information</legend>

_!_ _/!_

    `;

} });

_!_

I like to swim.

_/!_ <span slot="username">John Smith</span> <span slot="birthday">01.01.2001</span> _!_

…And play volleyball too!

_/!_ \`\`\`

All the unslotted light DOM content gets into the “Other information” fieldset.

Elements are appended to a slot one after another, so both unslotted pieces of information are in the default slot together.

The flattened DOM looks like this:

    <user-card>
      #shadow-root
        <div>Name:
          <slot name="username">
            <span slot="username">John Smith</span>
          </slot>
        </div>
        <div>Birthday:
          <slot name="birthday">
            <span slot="birthday">01.01.2001</span>
          </slot>
        </div>
        <fieldset>
          <legend>Other information</legend>
    *!*
          <slot>
            <div>I like to swim.</div>
            <div>...And play volleyball too!</div>
          </slot>
    */!*
        </fieldset>
    </user-card>

## Menu example

Now let’s back to `<custom-menu>`, mentioned at the beginning of the chapter.

We can use slots to distribute elements.

Here’s the markup for `<custom-menu>`:

    <custom-menu>
      <span slot="title">Candy menu</span>
      <li slot="item">Lollipop</li>
      <li slot="item">Fruit Toast</li>
      <li slot="item">Cup Cake</li>
    </custom-menu>

The shadow DOM template with proper slots:

    <template id="tmpl">
      <style> /* menu styles */ </style>
      <div class="menu">
        <slot name="title"></slot>
        <ul><slot name="item"></slot></ul>
      </div>
    </template>

1.  `<span slot="title">` goes into `<slot name="title">`.
2.  There are many `<li slot="item">` in the template, but only one `<slot name="item">` in the template. So all such `<li slot="item">` are appended to `<slot name="item">` one after another, thus forming the list.

The flattened DOM becomes:

    <custom-menu>
      #shadow-root
        <style> /* menu styles */ </style>
        <div class="menu">
          <slot name="title">
            <span slot="title">Candy menu</span>
          </slot>
          <ul>
            <slot name="item">
              <li slot="item">Lollipop</li>
              <li slot="item">Fruit Toast</li>
              <li slot="item">Cup Cake</li>
            </slot>
          </ul>
        </div>
    </custom-menu>

One might notice that, in a valid DOM, `<li>` must be a direct child of `<ul>`. But that’s flattened DOM, it describes how the component is rendered, such thing happens naturally here.

We just need to add a `click` handler to open/close the list, and the `<custom-menu>` is ready:

    customElements.define('custom-menu', class extends HTMLElement {
      connectedCallback() {
        this.attachShadow({mode: 'open'});

        // tmpl is the shadow DOM template (above)
        this.shadowRoot.append( tmpl.content.cloneNode(true) );

        // we can't select light DOM nodes, so let's handle clicks on the slot
        this.shadowRoot.querySelector('slot[name="title"]').onclick = () => {
          // open/close the menu
          this.shadowRoot.querySelector('.menu').classList.toggle('closed');
        };
      }
    });

Here’s the full demo:

\[iframe src=“menu” height=140 edit\]

Of course, we can add more functionality to it: events, methods and so on.

## Updating slots

What if the outer code wants to add/remove menu items dynamically?

**The browser monitors slots and updates the rendering if slotted elements are added/removed.**

Also, as light DOM nodes are not copied, but just rendered in slots, the changes inside them immediately become visible.

So we don’t have to do anything to update rendering. But if the component code wants to know about slot changes, then `slotchange` event is available.

For example, here the menu item is inserted dynamically after 1 second, and the title changes after 2 seconds:

\`\`\`html run untrusted height=80 <span slot="title">Candy menu</span>

\`\`\`

The menu rendering updates each time without our intervention.

There are two `slotchange` events here:

1.  At initialization:

    `slotchange: title` triggers immediately, as the `slot="title"` from the light DOM gets into the corresponding slot.

2.  After 1 second:

    `slotchange: item` triggers, when a new `<li slot="item">` is added.

Please note: there’s no `slotchange` event after 2 seconds, when the content of `slot="title"` is modified. That’s because there’s no slot change. We modify the content inside the slotted element, that’s another thing.

If we’d like to track internal modifications of light DOM from JavaScript, that’s also possible using a more generic mechanism: [MutationObserver](info:mutation-observer).

## Slot API

Finally, let’s mention the slot-related JavaScript methods.

As we’ve seen before, JavaScript looks at the “real” DOM, without flattening. But, if the shadow tree has `{mode: 'open'}`, then we can figure out which elements assigned to a slot and, vise-versa, the slot by the element inside it:

- `node.assignedSlot` – returns the `<slot>` element that the `node` is assigned to.
- `slot.assignedNodes({flatten: true/false})` – DOM nodes, assigned to the slot. The `flatten` option is `false` by default. If explicitly set to `true`, then it looks more deeply into the flattened DOM, returning nested slots in case of nested components and the fallback content if no node assigned.
- `slot.assignedElements({flatten: true/false})` – DOM elements, assigned to the slot (same as above, but only element nodes).

These methods are useful when we need not just show the slotted content, but also track it in JavaScript.

For example, if `<custom-menu>` component wants to know, what it shows, then it could track `slotchange` and get the items from `slot.assignedElements`:

\`\`\`html run untrusted height=120 <span slot="title">Candy menu</span>

Lollipop

Fruit Toast

\`\`\`

## Summary

Usually, if an element has shadow DOM, then its light DOM is not displayed. Slots allow to show elements from light DOM in specified places of shadow DOM.

There are two kinds of slots:

- Named slots: `<slot name="X">...</slot>` – gets light children with `slot="X"`.
- Default slot: the first `<slot>` without a name (subsequent unnamed slots are ignored) – gets unslotted light children.
- If there are many elements for the same slot – they are appended one after another.
- The content of `<slot>` element is used as a fallback. It’s shown if there are no light children for the slot.

The process of rendering slotted elements inside their slots is called “composition”. The result is called a “flattened DOM”.

Composition does not really move nodes, from JavaScript point of view the DOM is still same.

JavaScript can access slots using methods: - `slot.assignedNodes/Elements()` – returns nodes/elements inside the `slot`. - `node.assignedSlot` – the reverse property, returns slot by a node.

If we’d like to know what we’re showing, we can track slot contents using: - `slotchange` event – triggers the first time a slot is filled, and on any add/remove/replace operation of the slotted element, but not its children. The slot is `event.target`. - [MutationObserver](info:mutation-observer) to go deeper into slot content, watch changes inside it.

Now, as we know how to show elements from light DOM in shadow DOM, let’s see how to style them properly. The basic rule is that shadow elements are styled inside, and light elements – outside, but there are notable exceptions.

We’ll see the details in the next chapter. \# Shadow DOM styling

Shadow DOM may include both `<style>` and `<link rel="stylesheet" href="…">` tags. In the latter case, stylesheets are HTTP-cached, so they are not redownloaded for multiple components that use same template.

As a general rule, local styles work only inside the shadow tree, and document styles work outside of it. But there are few exceptions.

## :host

The `:host` selector allows to select the shadow host (the element containing the shadow tree).

For instance, we’re making `<custom-dialog>` element that should be centered. For that we need to style the `<custom-dialog>` element itself.

That’s exactly what `:host` does:

\`\`\`html run autorun=“no-epub” untrusted height=80

Hello! \`\`\`

## Cascading

The shadow host (`<custom-dialog>` itself) resides in the light DOM, so it’s affected by document CSS rules.

If there’s a property styled both in `:host` locally, and in the document, then the document style takes precedence.

For instance, if in the document we had:

    <style>
    custom-dialog {
      padding: 0;
    }
    </style>

…Then the `<custom-dialog>` would be without padding.

It’s very convenient, as we can setup “default” component styles in its `:host` rule, and then easily override them in the document.

The exception is when a local property is labelled `!important`, for such properties, local styles take precedence.

## :host(selector)

Same as `:host`, but applied only if the shadow host matches the `selector`.

For example, we’d like to center the `<custom-dialog>` only if it has `centered` attribute:

\`\`\`html run autorun=“no-epub” untrusted height=80

Centered!

Not centered. \`\`\`

Now the additional centering styles are only applied to the first dialog: `<custom-dialog centered>`.

## :host-context(selector)

Same as `:host`, but applied only if the shadow host or any of its ancestors in the outer document matches the `selector`.

E.g. `:host-context(.dark-theme)` matches only if there’s `dark-theme` class on `<custom-dialog>` on anywhere above it:

    <body class="dark-theme">
      <!--
        :host-context(.dark-theme) applies to custom-dialogs inside .dark-theme
      -->
      <custom-dialog>...</custom-dialog>
    </body>

To summarize, we can use `:host`-family of selectors to style the main element of the component, depending on the context. These styles (unless `!important`) can be overridden by the document.

## Styling slotted content

Now let’s consider the situation with slots.

Slotted elements come from light DOM, so they use document styles. Local styles do not affect slotted content.

In the example below, slotted `<span>` is bold, as per document style, but does not take `background` from the local style: \`\`\`html run autorun=“no-epub” untrusted height=80

*!*John Smith*/!*

\`\`\`

The result is bold, but not red.

If we’d like to style slotted elements in our component, there are two choices.

First, we can style the `<slot>` itself and rely on CSS inheritance:

\`\`\`html run autorun=“no-epub” untrusted height=80

*!*John Smith*/!*

\`\`\`

Here `<p>John Smith</p>` becomes bold, because CSS inheritance is in effect between the `<slot>` and its contents. But in CSS itself not all properties are inherited.

Another option is to use `::slotted(selector)` pseudo-class. It matches elements based on two conditions:

1.  That’s a slotted element, that comes from the light DOM. Slot name doesn’t matter. Just any slotted element, but only the element itself, not its children.
2.  The element matches the `selector`.

In our example, `::slotted(div)` selects exactly `<div slot="username">`, but not its children:

\`\`\`html run autorun=“no-epub” untrusted height=80

    <div>John Smith</div>

\`\`\`

Please note, `::slotted` selector can’t descend any further into the slot. These selectors are invalid:

    ::slotted(div span) {
      /* our slotted <div> does not match this */
    }

    ::slotted(div) p {
      /* can't go inside light DOM */
    }

Also, `::slotted` can only be used in CSS. We can’t use it in `querySelector`.

## CSS hooks with custom properties

How do we style internal elements of a component from the main document?

Selectors like `:host` apply rules to `<custom-dialog>` element or `<user-card>`, but how to style shadow DOM elements inside them?

There’s no selector that can directly affect shadow DOM styles from the document. But just as we expose methods to interact with our component, we can expose CSS variables (custom CSS properties) to style it.

**Custom CSS properties exist on all levels, both in light and shadow.**

For example, in shadow DOM we can use `--user-card-field-color` CSS variable to style fields, and the outer document can set its value:

    <style>
      .field {
        color: var(--user-card-field-color, black);
        /* if --user-card-field-color is not defined, use black color */
      }
    </style>
    <div class="field">Name: <slot name="username"></slot></div>
    <div class="field">Birthday: <slot name="birthday"></slot></div>

Then, we can declare this property in the outer document for `<user-card>`:

    user-card {
      --user-card-field-color: green;
    }

Custom CSS properties pierce through shadow DOM, they are visible everywhere, so the inner `.field` rule will make use of it.

Here’s the full example:

\`\`\`html run autorun=“no-epub” untrusted height=80

Name:

Birthday:

<span slot="username">John Smith</span> <span slot="birthday">01.01.2001</span> \`\`\`

## Summary

Shadow DOM can include styles, such as `<style>` or `<link rel="stylesheet">`.

Local styles can affect: - shadow tree, - shadow host with `:host`-family pseudoclasses, - slotted elements (coming from light DOM), `::slotted(selector)` allows to select slotted elements themselves, but not their children.

Document styles can affect: - shadow host (as it lives in the outer document) - slotted elements and their contents (as that’s also in the outer document)

When CSS properties conflict, normally document styles have precedence, unless the property is labelled as `!important`. Then local styles have precedence.

CSS custom properties pierce through shadow DOM. They are used as “hooks” to style the component:

1.  The component uses a custom CSS property to style key elements, such as `var(--component-name-title, <default value>)`.
2.  When a developer wants to style a title, they assign `--component-name-title` CSS property for the shadow host or above.
3.  Profit! \# Shadow DOM and events

The idea behind shadow tree is to encapsulate internal implementation details of a component.

Let’s say, a click event happens inside a shadow DOM of `<user-card>` component. But scripts in the main document have no idea about the shadow DOM internals, especially if the component comes from a 3rd-party library.

So, to keep the details encapsulated, the browser _retargets_ the event.

**Events that happen in shadow DOM have the host element as the target, when caught outside of the component.**

Here’s a simple example:

\`\`\`html run autorun=“no-epub” untrusted height=60

\`\`\`

If you click on the button, the messages are:

1.  Inner target: `BUTTON` – internal event handler gets the correct target, the element inside shadow DOM.
2.  Outer target: `USER-CARD` – document event handler gets shadow host as the target.

Event retargeting is a great thing to have, because the outer document doesn’t have to know about component internals. From its point of view, the event happened on `<user-card>`.

**Retargeting does not occur if the event occurs on a slotted element, that physically lives in the light DOM.**

For example, if a user clicks on `<span slot="username">` in the example below, the event target is exactly this `span` element, for both shadow and light handlers:

\`\`\`html run autorun=“no-epub” untrusted height=60 _!_ <span slot="username">John Smith</span> _/!_

\`\`\`

If a click happens on `"John Smith"`, for both inner and outer handlers the target is `<span slot="username">`. That’s an element from the light DOM, so no retargeting.

On the other hand, if the click occurs on an element originating from shadow DOM, e.g. on `<b>Name</b>`, then, as it bubbles out of the shadow DOM, its `event.target` is reset to `<user-card>`.

## Bubbling, event.composedPath()

For purposes of event bubbling, flattened DOM is used.

So, if we have a slotted element, and an event occurs somewhere inside it, then it bubbles up to the `<slot>` and upwards.

The full path to the original event target, with all the shadow elements, can be obtained using `event.composedPath()`. As we can see from the name of the method, that path is taken after the composition.

In the example above, the flattened DOM is:

    <user-card id="userCard">
      #shadow-root
        <div>
          <b>Name:</b>
          <slot name="username">
            <span slot="username">John Smith</span>
          </slot>
        </div>
    </user-card>

So, for a click on `<span slot="username">`, a call to `event.composedPath()` returns an array: \[`span`, `slot`, `div`, `shadow-root`, `user-card`, `body`, `html`, `document`, `window`\]. That’s exactly the parent chain from the target element in the flattened DOM, after the composition.

\`\``warn header="Shadow tree details are only provided for`{mode:‘open’}`trees" If the shadow tree was created with`{mode: ‘closed’}`, then the composed path starts from the host:`user-card\` and upwards.

That’s the similar principle as for other methods that work with shadow DOM. Internals of closed trees are completely hidden. \`\`\`

## event.composed

Most events successfully bubble through a shadow DOM boundary. There are few events that do not.

This is governed by the `composed` event object property. If it’s `true`, then the event does cross the boundary. Otherwise, it only can be caught from inside the shadow DOM.

If you take a look at [UI Events specification](https://www.w3.org/TR/uievents), most events have `composed: true`:

- `blur`, `focus`, `focusin`, `focusout`,
- `click`, `dblclick`,
- `mousedown`, `mouseup` `mousemove`, `mouseout`, `mouseover`,
- `wheel`,
- `beforeinput`, `input`, `keydown`, `keyup`.

All touch events and pointer events also have `composed: true`.

There are some events that have `composed: false` though:

- `mouseenter`, `mouseleave` (they do not bubble at all),
- `load`, `unload`, `abort`, `error`,
- `select`,
- `slotchange`.

These events can be caught only on elements within the same DOM, where the event target resides.

## Custom events

When we dispatch custom events, we need to set both `bubbles` and `composed` properties to `true` for it to bubble up and out of the component.

For example, here we create `div#inner` in the shadow DOM of `div#outer` and trigger two events on it. Only the one with `composed: true` makes it outside to the document:

\`\`\`html run untrusted height=0

\`\`\`

## Summary

Events only cross shadow DOM boundaries if their `composed` flag is set to `true`.

Built-in events mostly have `composed: true`, as described in the relevant specifications:

- UI Events <a href="https://www.w3.org/TR/uievents" class="uri">https://www.w3.org/TR/uievents</a>.
- Touch Events <a href="https://w3c.github.io/touch-events" class="uri">https://w3c.github.io/touch-events</a>.
- Pointer Events <a href="https://www.w3.org/TR/pointerevents" class="uri">https://www.w3.org/TR/pointerevents</a>.
- …And so on.

Some built-in events that have `composed: false`:

- `mouseenter`, `mouseleave` (also do not bubble),
- `load`, `unload`, `abort`, `error`,
- `select`,
- `slotchange`.

These events can be caught only on elements within the same DOM.

If we dispatch a `CustomEvent`, then we should explicitly set `composed: true`.

Please note that in case of nested components, one shadow DOM may be nested into another. In that case composed events bubble through all shadow DOM boundaries. So, if an event is intended only for the immediate enclosing component, we can also dispatch it on the shadow host and set `composed: false`. Then it’s out of the component shadow DOM, but won’t bubble up to higher-level DOM. \# Patterns and flags

Regular expressions are patterns that provide a powerful way to search and replace in text.

In JavaScript, they are available via the [RegExp](mdn:js/RegExp) object, as well as being integrated in methods of strings.

## Regular Expressions

A regular expression (also “regexp”, or just “reg”) consists of a _pattern_ and optional _flags_.

There are two syntaxes that can be used to create a regular expression object.

The “long” syntax:

    regexp = new RegExp("pattern", "flags");

And the “short” one, using slashes `"/"`:

    regexp = /pattern/; // no flags
    regexp = /pattern/gmi; // with flags g,m and i (to be covered soon)

Slashes `pattern:/.../` tell JavaScript that we are creating a regular expression. They play the same role as quotes for strings.

In both cases `regexp` becomes an instance of the built-in `RegExp` class.

The main difference between these two syntaxes is that pattern using slashes `/.../` does not allow for expressions to be inserted (like string template literals with `${...}`). They are fully static.

Slashes are used when we know the regular expression at the code writing time – and that’s the most common situation. While `new RegExp` is more often used when we need to create a regexp “on the fly” from a dynamically generated string. For instance:

    let tag = prompt("What tag do you want to find?", "h2");

    let regexp = new RegExp(`<${tag}>`); // same as /<h2>/ if answered "h2" in the prompt above

## Flags

Regular expressions may have flags that affect the search.

There are only 6 of them in JavaScript:

`pattern:i`  
With this flag the search is case-insensitive: no difference between `A` and `a` (see the example below).

`pattern:g`  
With this flag the search looks for all matches, without it – only the first match is returned.

`pattern:m`  
Multiline mode (covered in the chapter <a href="info:regexp-multiline-mode" class="uri">info:regexp-multiline-mode</a>).

`pattern:s`  
Enables “dotall” mode, that allows a dot `pattern:.` to match newline character `\n` (covered in the chapter <a href="info:regexp-character-classes" class="uri">info:regexp-character-classes</a>).

`pattern:u`  
Enables full Unicode support. The flag enables correct processing of surrogate pairs. More about that in the chapter <a href="info:regexp-unicode" class="uri">info:regexp-unicode</a>.

`pattern:y`  
“Sticky” mode: searching at the exact position in the text (covered in the chapter <a href="info:regexp-sticky" class="uri">info:regexp-sticky</a>)

\`\`\`smart header=“Colors” From here on the color scheme is:

- regexp – `pattern:red`
- string (where we search) – `subject:blue`
- result – `match:green` \`\`\`

## Searching: str.match

As mentioned previously, regular expressions are integrated with string methods.

The method `str.match(regexp)` finds all matches of `regexp` in the string `str`.

It has 3 working modes:

1.  If the regular expression has flag `pattern:g`, it returns an array of all matches: \`\`\`js run let str = “We will, we will rock you”;

    alert( str.match(/we/gi) ); // We,we (an array of 2 substrings that match) \`\``Please note that both`match:We`and`match:we`are found, because flag`pattern:i\` makes the regular expression case-insensitive.

2.  If there’s no such flag it returns only the first match in the form of an array, with the full match at index `0` and some additional details in properties: \`\`\`js run let str = “We will, we will rock you”;

    let result = str.match(/we/i); // without flag g

    alert( result\[0\] ); // We (1st match) alert( result.length ); // 1

    // Details: alert( result.index ); // 0 (position of the match) alert( result.input ); // We will, we will rock you (source string) \`\``The array may have other indexes, besides`0\` if a part of the regular expression is enclosed in parentheses. We’ll cover that in the chapter <a href="info:regexp-groups" class="uri">info:regexp-groups</a>.

3.  And, finally, if there are no matches, `null` is returned (doesn’t matter if there’s flag `pattern:g` or not).

    This a very important nuance. If there are no matches, we don’t receive an empty array, but instead receive `null`. Forgetting about that may lead to errors, e.g.:

    \`\`\`js run let matches = “JavaScript”.match(/HTML/); // = null

    if (!matches.length) { // Error: Cannot read property ‘length’ of null alert(“Error in the line above”); } \`\`\`

    If we’d like the result to always be an array, we can write it this way:

    \`\`\`js run let matches = “JavaScript”.match(/HTML/)_!_ || \[\]_/!_;

    if (!matches.length) { alert(“No matches”); // now it works } \`\`\`

## Replacing: str.replace

The method `str.replace(regexp, replacement)` replaces matches found using `regexp` in string `str` with `replacement` (all matches if there’s flag `pattern:g`, otherwise, only the first one).

For instance:

\`\`\`js run // no flag g alert( “We will, we will”.replace(/we/i, “I”) ); // I will, we will

// with flag g alert( “We will, we will”.replace(/we/ig, “I”) ); // I will, I will \`\`\`

The second argument is the `replacement` string. We can use special character combinations in it to insert fragments of the match:

<table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>Symbols</th><th>Action in the replacement string</th></tr></thead><tbody><tr class="odd"><td><code>$&amp;</code></td><td>inserts the whole match</td></tr><tr class="even"><td><code>$&amp;#096;&lt;/code&gt;|inserts a part of the string before the match| |`$’|inserts a part of the string after the match| |</code><span class="math inline">$n`|if `n` is a 1-2 digit number, then it inserts the contents of n-th parentheses, more about it in the chapter &lt;info:regexp-groups&gt;| |`$</span><code>|inserts the contents of the parentheses with the given</code>name<code>, more about it in the chapter &lt;info:regexp-groups&gt;| |</code>$<span class="math inline">$`|inserts character `$</span>`</td><td></td></tr></tbody></table>

An example with `pattern:$&`:

`js run alert( "I love HTML".replace(/HTML/, "$& and JavaScript") ); // I love HTML and JavaScript`

## Testing: regexp.test

The method `regexp.test(str)` looks for at least one match, if found, returns `true`, otherwise `false`.

\`\`\`js run let str = “I love JavaScript”; let regexp = /LOVE/i;

alert( regexp.test(str) ); // true \`\`\`

Later in this chapter we’ll study more regular expressions, walk through more examples, and also meet other methods.

Full information about the methods is given in the article <a href="info:regexp-methods" class="uri">info:regexp-methods</a>.

## Summary

- A regular expression consists of a pattern and optional flags: `pattern:g`, `pattern:i`, `pattern:m`, `pattern:u`, `pattern:s`, `pattern:y`.
- Without flags and special symbols (that we’ll study later), the search by a regexp is the same as a substring search.
- The method `str.match(regexp)` looks for matches: all of them if there’s `pattern:g` flag, otherwise, only the first one.
- The method `str.replace(regexp, replacement)` replaces matches found using `regexp` with `replacement`: all of them if there’s `pattern:g` flag, otherwise only the first one.
- The method `regexp.test(str)` returns `true` if there’s at least one match, otherwise, it returns `false`. \# Character classes

Consider a practical task – we have a phone number like `"+7(903)-123-45-67"`, and we need to turn it into pure numbers: `79031234567`.

To do so, we can find and remove anything that’s not a number. Character classes can help with that.

A _character class_ is a special notation that matches any symbol from a certain set.

For the start, let’s explore the “digit” class. It’s written as `pattern:\d` and corresponds to “any single digit”.

For instance, let’s find the first digit in the phone number:

\`\`\`js run let str = “+7(903)-123-45-67”;

let regexp = /;

alert( str.match(regexp) ); // 7 \`\`\`

Without the flag `pattern:g`, the regular expression only looks for the first match, that is the first digit `pattern:\d`.

Let’s add the `pattern:g` flag to find all digits:

\`\`\`js run let str = “+7(903)-123-45-67”;

let regexp = /g;

alert( str.match(regexp) ); // array of matches: 7,9,0,3,1,2,3,4,5,6,7

// let’s make the digits-only phone number of them: alert( str.match(regexp).join(’’) ); // 79031234567 \`\`\`

That was a character class for digits. There are other character classes as well.

Most used are:

`pattern:\d` (“d” is from “digit”)  
A digit: a character from `0` to `9`.

`pattern:\s` (“s” is from “space”)  
A space symbol: includes spaces, tabs `\t`, newlines `\n` and few other rare characters, such as `\v`, `\f` and `\r`.

`pattern:\w` (“w” is from “word”)  
A “wordly” character: either a letter of Latin alphabet or a digit or an underscore `_`. Non-Latin letters (like cyrillic or hindi) do not belong to `pattern:\w`.

For instance, `pattern:\d\s\w` means a “digit” followed by a “space character” followed by a “wordly character”, such as `match:1 a`.

**A regexp may contain both regular symbols and character classes.**

For instance, `pattern:CSS\d` matches a string `match:CSS` with a digit after it:

\`\`\`js run let str = “Is there CSS4?”; let regexp = /CSS

alert( str.match(regexp) ); // CSS4 \`\`\`

Also we can use many character classes:

`js run alert( "I love HTML5!".match(/\s\w\w\w\w\d/) ); // ' HTML5'`

The match (each regexp character class has the corresponding result character):

![](love-html5-classes.svg)

## Inverse classes

For every character class there exists an “inverse class”, denoted with the same letter, but uppercased.

The “inverse” means that it matches all other characters, for instance:

`pattern:\D`  
Non-digit: any character except `pattern:\d`, for instance a letter.

`pattern:\S`  
Non-space: any character except `pattern:\s`, for instance a letter.

`pattern:\W`  
Non-wordly character: anything but `pattern:\w`, e.g a non-latin letter or a space.

In the beginning of the chapter we saw how to make a number-only phone number from a string like `subject:+7(903)-123-45-67`: find all digits and join them.

\`\`\`js run let str = “+7(903)-123-45-67”;

alert( str.match(/g).join(’’) ); // 79031234567 \`\`\`

An alternative, shorter way is to find non-digits `pattern:\D` and remove them from the string:

\`\`\`js run let str = “+7(903)-123-45-67”;

alert( str.replace(//g, "") ); // 79031234567 \`\`\`

## A dot is “any character”

A dot `pattern:.` is a special character class that matches “any character except a newline”.

For instance:

`js run alert( "Z".match(/./) ); // Z`

Or in the middle of a regexp:

\`\`\`js run let regexp = /CS.4/;

alert( “CSS4”.match(regexp) ); // CSS4 alert( “CS-4”.match(regexp) ); // CS-4 alert( “CS 4”.match(regexp) ); // CS 4 (space is also a character) \`\`\`

Please note that a dot means “any character”, but not the “absence of a character”. There must be a character to match it:

`js run alert( "CS4".match(/CS.4/) ); // null, no match because there's no character for the dot`

### Dot as literally any character with “s” flag

By default, a dot doesn’t match the newline character `\n`.

For instance, the regexp `pattern:A.B` matches `match:A`, and then `match:B` with any character between them, except a newline `\n`:

`js run alert( "A\nB".match(/A.B/) ); // null (no match)`

There are many situations when we’d like a dot to mean literally “any character”, newline included.

That’s what flag `pattern:s` does. If a regexp has it, then a dot `pattern:.` matches literally any character:

`js run alert( "A\nB".match(/A.B/s) ); // A\nB (match!)`

\`\`\``warn header="Not supported in IE" The`pattern:s\` flag is not supported in IE.

Luckily, there’s an alternative, that works everywhere. We can use a regexp like `pattern:[\s\S]` to match “any character” (this pattern will be covered in the article <a href="info:regexp-character-sets-and-ranges" class="uri">info:regexp-character-sets-and-ranges</a>).

`js run alert( "A\nB".match(/A[\s\S]B/) ); // A\nB (match!)`

The pattern `pattern:[\s\S]` literally says: “a space character OR not a space character”. In other words, “anything”. We could use another pair of complementary classes, such as `pattern:[\d\D]`, that doesn’t matter. Or even the `pattern:[^]` – as it means match any character except nothing.

Also we can use this trick if we want both kind of “dots” in the same pattern: the actual dot `pattern:.` behaving the regular way (“not including a newline”), and also a way to match “any character” with `pattern:[\s\S]` or alike. \`\`\`\`

\`\`\``warn header="Pay attention to spaces" Usually we pay little attention to spaces. For us strings`subject:1-5`and`subject:1 - 5\` are nearly identical.

But if a regexp doesn’t take spaces into account, it may fail to work.

Let’s try to find digits separated by a hyphen:

`js run alert( "1 - 5".match(/\d-\d/) ); // null, no match!`

Let’s fix it adding spaces into the regexp `pattern:\d - \d`:

`js run alert( "1 - 5".match(/\d - \d/) ); // 1 - 5, now it works // or we can use \s class: alert( "1 - 5".match(/\d\s-\s\d/) ); // 1 - 5, also works`

**A space is a character. Equal in importance with any other character.**

We can’t add or remove spaces from a regular expression and expect it to work the same.

In other words, in a regular expression all characters matter, spaces too. \`\`\`\`

## Summary

There exist following character classes:

- `pattern:\d` – digits.
- `pattern:\D` – non-digits.
- `pattern:\s` – space symbols, tabs, newlines.
- `pattern:\S` – all but `pattern:\s`.
- `pattern:\w` – Latin letters, digits, underscore `'_'`.
- `pattern:\W` – all but `pattern:\w`.
- `pattern:.` – any character if with the regexp `'s'` flag, otherwise any except a newline `\n`.

…But that’s not all!

Unicode encoding, used by JavaScript for strings, provides many properties for characters, like: which language the letter belongs to (if it’s a letter), is it a punctuation sign, etc.

We can search by these properties as well. That requires flag `pattern:u`, covered in the next article. \# Unicode: flag “u” and class

JavaScript uses [Unicode encoding](https://en.wikipedia.org/wiki/Unicode) for strings. Most characters are encoded with 2 bytes, but that allows to represent at most 65536 characters.

That range is not big enough to encode all possible characters, that’s why some rare characters are encoded with 4 bytes, for instance like `𝒳` (mathematical X) or `😄` (a smile), some hieroglyphs and so on.

Here are the Unicode values of some characters:

<table><thead><tr class="header"><th>Character</th><th>Unicode</th><th>Bytes count in Unicode</th></tr></thead><tbody><tr class="odd"><td>a</td><td><code>0x0061</code></td><td>2</td></tr><tr class="even"><td>≈</td><td><code>0x2248</code></td><td>2</td></tr><tr class="odd"><td>𝒳</td><td><code>0x1d4b3</code></td><td>4</td></tr><tr class="even"><td>𝒴</td><td><code>0x1d4b4</code></td><td>4</td></tr><tr class="odd"><td>😄</td><td><code>0x1f604</code></td><td>4</td></tr></tbody></table>

So characters like `a` and `≈` occupy 2 bytes, while codes for `𝒳`, `𝒴` and `😄` are longer, they have 4 bytes.

Long time ago, when JavaScript language was created, Unicode encoding was simpler: there were no 4-byte characters. So, some language features still handle them incorrectly.

For instance, `length` thinks that here are two characters:

`js run alert('😄'.length); // 2 alert('𝒳'.length); // 2`

…But we can see that there’s only one, right? The point is that `length` treats 4 bytes as two 2-byte characters. That’s incorrect, because they must be considered only together (so-called “surrogate pair”, you can read about them in the article <a href="info:string" class="uri">info:string</a>).

By default, regular expressions also treat 4-byte “long characters” as a pair of 2-byte ones. And, as it happens with strings, that may lead to odd results. We’ll see that a bit later, in the article <a href="info:regexp-character-sets-and-ranges" class="uri">info:regexp-character-sets-and-ranges</a>.

Unlike strings, regular expressions have flag `pattern:u` that fixes such problems. With such flag, a regexp handles 4-byte characters correctly. And also Unicode property search becomes available, we’ll get to it next.

## Unicode properties

Every character in Unicode has a lot of properties. They describe what “category” the character belongs to, contain miscellaneous information about it.

For instance, if a character has `Letter` property, it means that the character belongs to an alphabet (of any language). And `Number` property means that it’s a digit: maybe Arabic or Chinese, and so on.

We can search for characters with a property, written as `pattern:\p{…}`. To use `pattern:\p{…}`, a regular expression must have flag `pattern:u`.

For instance, `\p{Letter}` denotes a letter in any language. We can also use `\p{L}`, as `L` is an alias of `Letter`. There are shorter aliases for almost every property.

In the example below three kinds of letters will be found: English, Georgian and Korean.

\`\`\`js run let str = “A ბ ㄱ”;

alert( str.match(//gu) ); // A,ბ,ㄱ alert( str.match(//g) ); // null (no matches, doesn’t work without the flag “u”) \`\`\`

Here’s the main character categories and their subcategories:

- Letter `L`:
  - lowercase `Ll`
  - modifier `Lm`,
  - titlecase `Lt`,
  - uppercase `Lu`,
  - other `Lo`.
- Number `N`:
  - decimal digit `Nd`,
  - letter number `Nl`,
  - other `No`.
- Punctuation `P`:
  - connector `Pc`,
  - dash `Pd`,
  - initial quote `Pi`,
  - final quote `Pf`,
  - open `Ps`,
  - close `Pe`,
  - other `Po`.
- Mark `M` (accents etc):
  - spacing combining `Mc`,
  - enclosing `Me`,
  - non-spacing `Mn`.
- Symbol `S`:
  - currency `Sc`,
  - modifier `Sk`,
  - math `Sm`,
  - other `So`.
- Separator `Z`:
  - line `Zl`,
  - paragraph `Zp`,
  - space `Zs`.
- Other `C`:
  - control `Cc`,
  - format `Cf`,
  - not assigned `Cn`,
  - private use `Co`,
  - surrogate `Cs`.

So, e.g. if we need letters in lower case, we can write `pattern:\p{Ll}`, punctuation signs: `pattern:\p{P}` and so on.

There are also other derived categories, like: - `Alphabetic` (`Alpha`), includes Letters `L`, plus letter numbers `Nl` (e.g. Ⅻ - a character for the roman number 12), plus some other symbols `Other_Alphabetic` (`OAlpha`). - `Hex_Digit` includes hexadecimal digits: `0-9`, `a-f`. - …And so on.

Unicode supports many different properties, their full list would require a lot of space, so here are the references:

- List all properties by a character: <a href="https://unicode.org/cldr/utility/character.jsp" class="uri">https://unicode.org/cldr/utility/character.jsp</a>.
- List all characters by a property: <a href="https://unicode.org/cldr/utility/list-unicodeset.jsp" class="uri">https://unicode.org/cldr/utility/list-unicodeset.jsp</a>.
- Short aliases for properties: <a href="https://www.unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt" class="uri">https://www.unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt</a>.
- A full base of Unicode characters in text format, with all properties, is here: <a href="https://www.unicode.org/Public/UCD/latest/ucd/" class="uri">https://www.unicode.org/Public/UCD/latest/ucd/</a>.

### Example: hexadecimal numbers

For instance, let’s look for hexadecimal numbers, written as `xFF`, where `F` is a hex digit (0..1 or A..F).

A hex digit can be denoted as `pattern:\p{Hex_Digit}`:

\`\`\`js run let regexp = /x/u;

alert(“number: xAF”.match(regexp)); // xAF \`\`\`

### Example: Chinese hieroglyphs

Let’s look for Chinese hieroglyphs.

There’s a Unicode property `Script` (a writing system), that may have a value: `Cyrillic`, `Greek`, `Arabic`, `Han` (Chinese) and so on, [here’s the full list](<https://en.wikipedia.org/wiki/Script_(Unicode)>).

To look for characters in a given writing system we should use `pattern:Script=<value>`, e.g. for Cyrillic letters: `pattern:\p{sc=Cyrillic}`, for Chinese hieroglyphs: `pattern:\p{sc=Han}`, and so on:

\`\`\`js run let regexp = //gu; // returns Chinese hieroglyphs

let str = `Hello Привет 你好 123_456`;

alert( str.match(regexp) ); // 你,好 \`\`\`

### Example: currency

Characters that denote a currency, such as `$`, `€`, `¥`, have Unicode property `pattern:\p{Currency_Symbol}`, the short alias: `pattern:\p{Sc}`.

Let’s use it to look for prices in the format “currency, followed by a digit”:

\`\`\`js run let regexp = /gu;

let str = `Prices: $2, €1, ¥9`;

alert( str.match(regexp) ); // $2,€1,¥9 \`\`\`

Later, in the article <a href="info:regexp-quantifiers" class="uri">info:regexp-quantifiers</a> we’ll see how to look for numbers that contain many digits.

## Summary

Flag `pattern:u` enables the support of Unicode in regular expressions.

That means two things:

1.  Characters of 4 bytes are handled correctly: as a single character, not two 2-byte characters.
2.  Unicode properties can be used in the search: `\p{…}`.

With Unicode properties we can look for words in given languages, special characters (quotes, currencies) and so on. \# Nullish coalescing operator ‘??’

\[recent browser=“new”\]

The nullish coalescing operator is written as two question marks `??`.

As it treats `null` and `undefined` similarly, we’ll use a special term here, in this article. We’ll say that an expression is “defined” when it’s neither `null` nor `undefined`.

The result of `a ?? b` is: - if `a` is defined, then `a`, - if `a` isn’t defined, then `b`.

In other words, `??` returns the first argument if it’s not `null/undefined`. Otherwise, the second one.

The nullish coalescing operator isn’t anything completely new. It’s just a nice syntax to get the first “defined” value of the two.

We can rewrite `result = a ?? b` using the operators that we already know, like this:

    result = (a !== null && a !== undefined) ? a : b;

Now it should be absolutely clear what `??` does. Let’s see where it helps.

The common use case for `??` is to provide a default value for a potentially undefined variable.

For example, here we show `user` if defined, otherwise `Anonymous`:

\`\`\`js run let user;

alert(user ?? “Anonymous”); // Anonymous (user not defined) \`\`\`

Here’s the example with `user` assigned to a name:

\`\`\`js run let user = “John”;

alert(user ?? “Anonymous”); // John (user defined) \`\`\`

We can also use a sequence of `??` to select the first value from a list that isn’t `null/undefined`.

Let’s say we have a user’s data in variables `firstName`, `lastName` or `nickName`. All of them may be not defined, if the user decided not to enter a value.

We’d like to display the user name using one of these variables, or show “Anonymous” if all of them aren’t defined.

Let’s use the `??` operator for that:

\`\`\`js run let firstName = null; let lastName = null; let nickName = “Supercoder”;

// shows the first defined value: _!_ alert(firstName ?? lastName ?? nickName ?? “Anonymous”); // Supercoder _/!_ \`\`\`

## Comparison with ||

The OR `||` operator can be used in the same way as `??`, as it was described in the [previous chapter](info:logical-operators#or-finds-the-first-truthy-value).

For example, in the code above we could replace `??` with `||` and still get the same result:

\`\`\`js run let firstName = null; let lastName = null; let nickName = “Supercoder”;

// shows the first truthy value: _!_ alert(firstName || lastName || nickName || “Anonymous”); // Supercoder _/!_ \`\`\`

Historically, the OR `||` operator was there first. It exists since the beginning of JavaScript, so developers were using it for such purposes for a long time.

On the other hand, the nullish coalescing operator `??` was added to JavaScript only recently, and the reason for that was that people weren’t quite happy with `||`.

The important difference between them is that: - `||` returns the first _truthy_ value. - `??` returns the first _defined_ value.

In other words, `||` doesn’t distinguish between `false`, `0`, an empty string `""` and `null/undefined`. They are all the same – falsy values. If any of these is the first argument of `||`, then we’ll get the second argument as the result.

In practice though, we may want to use default value only when the variable is `null/undefined`. That is, when the value is really unknown/not set.

For example, consider this:

\`\`\`js run let height = 0;

alert(height || 100); // 100 alert(height ?? 100); // 0 \`\`\`

- The `height || 100` checks `height` for being a falsy value, and it’s `0`, falsy indeed.
  - so the result of `||` is the second argument, `100`.
- The `height ?? 100` checks `height` for being `null/undefined`, and it’s not,
  - so the result is `height` “as is”, that is `0`.

In practice, the zero height is often a valid value, that shouldn’t be replaced with the default. So `??` does just the right thing.

## Precedence

The precedence of the `??` operator is about the same as `||`, just a bit lower. It equals `5` in the [MDN table](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table), while `||` is `6`.

That means that, just like `||`, the nullish coalescing operator `??` is evaluated before `=` and `?`, but after most other operations, such as `+`, `*`.

So if we’d like to choose a value with `??` in an expression with other operators, consider adding parentheses:

\`\`\`js run let height = null; let width = null;

// important: use parentheses let area = (height ?? 100) \* (width ?? 50);

alert(area); // 5000 \`\`\`

Otherwise, if we omit parentheses, then as `*` has the higher precedence than `??`, it would execute first, leading to incorrect results.

    // without parentheses
    let area = height ?? 100 * width ?? 50;

    // ...works the same as this (probably not what we want):
    let area = height ?? (100 * width) ?? 50;

### Using ?? with && or ||

Due to safety reasons, JavaScript forbids using `??` together with `&&` and `||` operators, unless the precedence is explicitly specified with parentheses.

The code below triggers a syntax error:

`js run let x = 1 && 2 ?? 3; // Syntax error`

The limitation is surely debatable, it was added to the language specification with the purpose to avoid programming mistakes, when people start to switch from `||` to `??`.

Use explicit parentheses to work around it:

\`\`\`js run _!_ let x = (1 && 2) ?? 3; // Works _/!_

alert(x); // 2 \`\`\`

## Summary

- The nullish coalescing operator `??` provides a short way to choose the first “defined” value from a list.

  It’s used to assign default values to variables:

      // set height=100, if height is null or undefined
      height = height ?? 100;

- The operator `??` has a very low precedence, only a bit higher than `?` and `=`, so consider adding parentheses when using it in an expression.
- It’s forbidden to use it with `||` or `&&` without explicit parentheses. \# Anchors: string start ^ and end $

The caret `pattern:^` and dollar `pattern:$` characters have special meaning in a regexp. They are called “anchors”.

The caret `pattern:^` matches at the beginning of the text, and the dollar `pattern:$` – at the end.

For instance, let’s test if the text starts with `Mary`:

`js run let str1 = "Mary had a little lamb"; alert( /^Mary/.test(str1) ); // true`

The pattern `pattern:^Mary` means: “string start and then Mary”.

Similar to this, we can test if the string ends with `snow` using `pattern:snow$`:

`js run let str1 = "it's fleece was white as snow"; alert( /snow$/.test(str1) ); // true`

In these particular cases we could use string methods `startsWith/endsWith` instead. Regular expressions should be used for more complex tests.

## Testing for a full match

Both anchors together `pattern:^...$` are often used to test whether or not a string fully matches the pattern. For instance, to check if the user input is in the right format.

Let’s check whether or not a string is a time in `12:34` format. That is: two digits, then a colon, and then another two digits.

In regular expressions language that’s `pattern:\d\d:\d\d`:

\`\`\`js run let goodInput = “12:34”; let badInput = “12:345”;

let regexp = /^\\d\\d$/; alert( regexp.test(goodInput) ); // true alert( regexp.test(badInput) ); // false \`\`\`

Here the match for `pattern:\d\d:\d\d` must start exactly after the beginning of the text `pattern:^`, and the end `pattern:$` must immediately follow.

The whole string must be exactly in this format. If there’s any deviation or an extra character, the result is `false`.

Anchors behave differently if flag `pattern:m` is present. We’ll see that in the next article.

\`\``smart header="Anchors have \"zero width\"" Anchors`pattern:^`and`pattern:$\` are tests. They have zero width.

In other words, they do not match a character, but rather force the regexp engine to check the condition (text start/end). \`\`\` \# Multiline mode of anchors ^ $, flag “m”

The multiline mode is enabled by the flag `pattern:m`.

It only affects the behavior of `pattern:^` and `pattern:$`.

In the multiline mode they match not only at the beginning and the end of the string, but also at start/end of line.

## Searching at line start ^

In the example below the text has multiple lines. The pattern `pattern:/^\d/gm` takes a digit from the beginning of each line:

\`\``js run let str =`1st place: Winnie 2nd place: Piglet 3rd place: Eeyore\`;

_!_ alert( str.match(/^gm) ); // 1, 2, 3 _/!_ \`\`\`

Without the flag `pattern:m` only the first digit is matched:

\`\``js run let str =`1st place: Winnie 2nd place: Piglet 3rd place: Eeyore\`;

_!_ alert( str.match(/^g) ); // 1 _/!_ \`\`\`

That’s because by default a caret `pattern:^` only matches at the beginning of the text, and in the multiline mode – at the start of any line.

    "Start of a line" formally means "immediately after a line break": the test  `pattern:^` in multiline mode matches at all positions preceded by a newline character `\n`.

    And at the text start.

## Searching at line end $

The dollar sign `pattern:$` behaves similarly.

The regular expression `pattern:\d$` finds the last digit in every line

\`\``js run let str =`Winnie: 1 Piglet: 2 Eeyore: 3\`;

alert( str.match(/\\d$/gm) ); // 1,2,3 \`\`\`

Without the flag `pattern:m`, the dollar `pattern:$` would only match the end of the whole text, so only the very last digit would be found.

    "End of a line" formally means "immediately before a line break": the test  `pattern:$` in multiline mode matches at all positions succeeded by a newline character `\n`.

    And at the text end.

## Searching for instead of ^ $

To find a newline, we can use not only anchors `pattern:^` and `pattern:$`, but also the newline character `\n`.

What’s the difference? Let’s see an example.

Here we search for `pattern:\d\n` instead of `pattern:\d$`:

\`\``js run let str =`Winnie: 1 Piglet: 2 Eeyore: 3\`;

alert( str.match(//gm) ); // 1,2 \`\`\`

As we can see, there are 2 matches instead of 3.

That’s because there’s no newline after `subject:3` (there’s text end though, so it matches `pattern:$`).

Another difference: now every match includes a newline character `match:\n`. Unlike the anchors `pattern:^` `pattern:$`, that only test the condition (start/end of a line), `\n` is a character, so it becomes a part of the result.

So, a `\n` in the pattern is used when we need newline characters in the result, while anchors are used to find something at the beginning/end of a line. \# Word boundary: word boundary `pattern:\b` is a test, just like `pattern:^` and `pattern:$`.

When the regexp engine (program module that implements searching for regexps) comes across `pattern:\b`, it checks that the position in the string is a word boundary.

There are three different positions that qualify as word boundaries:

- At string start, if the first string character is a word character `pattern:\w`.
- Between two characters in the string, where one is a word character `pattern:\w` and the other is not.
- At string end, if the last string character is a word character `pattern:\w`.

For instance, regexp `pattern:\bJava\b` will be found in `subject:Hello, Java!`, where `subject:Java` is a standalone word, but not in `subject:Hello, JavaScript!`.

`js run alert( "Hello, Java!".match(/\bJava\b/) ); // Java alert( "Hello, JavaScript!".match(/\bJava\b/) ); // null`

In the string `subject:Hello, Java!` following positions correspond to `pattern:\b`:

![](hello-java-boundaries.svg)

So, it matches the pattern `pattern:\bHello\b`, because:

1.  At the beginning of the string matches the first test `pattern:\b`.
2.  Then matches the word `pattern:Hello`.
3.  Then the test `pattern:\b` matches again, as we’re between `subject:o` and a comma.

So the pattern `pattern:\bHello\b` would match, but not `pattern:\bHell\b` (because there’s no word boundary after `l`) and not `Java!\b` (because the exclamation sign is not a wordly character `pattern:\w`, so there’s no word boundary after it).

`js run alert( "Hello, Java!".match(/\bHello\b/) ); // Hello alert( "Hello, Java!".match(/\bJava\b/) ); // Java alert( "Hello, Java!".match(/\bHell\b/) ); // null (no match) alert( "Hello, Java!".match(/\bJava!\b/) ); // null (no match)`

We can use `pattern:\b` not only with words, but with digits as well.

For example, the pattern `pattern:\b\d\d\b` looks for standalone 2-digit numbers. In other words, it looks for 2-digit numbers that are surrounded by characters different from `pattern:\w`, such as spaces or punctuation (or text start/end).

`js run alert( "1 23 456 78".match(/\b\d\d\b/g) ); // 23,78 alert( "12,34,56".match(/\b\d\d\b/g) ); // 12,34,56`

\`\``warn header="Word boundary`pattern: doesn’t work for non-latin alphabets" The word boundary test `pattern:\b` checks that there should be `pattern:\w` on the one side from the position and “not `pattern:\w`” - on the other side.

But `pattern:\w` means a latin letter `a-z` (or a digit or an underscore), so the test doesn’t work for other characters, e.g. cyrillic letters or hieroglyphs. \`\`\`

# Escaping, special characters

As we’ve seen, a backslash `pattern:\` is used to denote character classes, e.g. `pattern:\d`. So it’s a special character in regexps (just like in regular strings).

There are other special characters as well, that have special meaning in a regexp. They are used to do more powerful searches. Here’s a full list of them: `pattern:[ \ ^ $ . | ? * + ( )`.

Don’t try to remember the list – soon we’ll deal with each of them separately and you’ll know them by heart automatically.

## Escaping

Let’s say we want to find literally a dot. Not “any character”, but just a dot.

To use a special character as a regular one, prepend it with a backslash: `pattern:\.`.

That’s also called “escaping a character”.

For example: `js run alert( "Chapter 5.1".match(/\d\.\d/) ); // 5.1 (match!) alert( "Chapter 511".match(/\d\.\d/) ); // null (looking for a real dot \.)`

Parentheses are also special characters, so if we want them, we should use `pattern:\(`. The example below looks for a string `"g()"`:

`js run alert( "function g()".match(/g\(\)/) ); // "g()"`

If we’re looking for a backslash `\`, it’s a special character in both regular strings and regexps, so we should double it.

`js run alert( "1\\2".match(/\\/) ); // '\'`

## A slash

A slash symbol `'/'` is not a special character, but in JavaScript it is used to open and close the regexp: `pattern:/...pattern.../`, so we should escape it too.

Here’s what a search for a slash `'/'` looks like:

`js run alert( "/".match(/\//) ); // '/'`

On the other hand, if we’re not using `pattern:/.../`, but create a regexp using `new RegExp`, then we don’t need to escape it:

`js run alert( "/".match(new RegExp("/")) ); // finds /`

## new RegExp

If we are creating a regular expression with `new RegExp`, then we don’t have to escape `/`, but need to do some other escaping.

For instance, consider this:

\`\`\`js run let regexp = new RegExp(");

alert( “Chapter 5.1”.match(regexp) ); // null \`\`\`

The similar search in one of previous examples worked with `pattern:/\d\.\d/`, but `new RegExp("\d\.\d")` doesn’t work, why?

The reason is that backslashes are “consumed” by a string. As we may recall, regular strings have their own special characters, such as `\n`, and a backslash is used for escaping.

Here’s how " is preceived:

`js run alert("\d\.\d"); // d.d`

String quotes “consume” backslashes and interpret them on their own, for instance:

- `\n` – becomes a newline character,
- `\u1234` – becomes the Unicode character with such code,
- …And when there’s no special meaning: like `pattern:\d` or `\z`, then the backslash is simply removed.

So `new RegExp` gets a string without backslashes. That’s why the search doesn’t work!

To fix it, we need to double backslashes, because string quotes turn `\\` into `\`:

\`\`\`js run _!_ let regStr = “\\d\\.\\d”; _/!_ alert(regStr); // correct now)

let regexp = new RegExp(regStr);

alert( “Chapter 5.1”.match(regexp) ); // 5.1 \`\`\`

## Summary

- To search for special characters `pattern:[ \ ^ $ . | ? * + ( )` literally, we need to prepend them with a backslash `\` (“escape them”).
- We also need to escape `/` if we’re inside `pattern:/.../` (but not inside `new RegExp`).
- When passing a string to `new RegExp`, we need to double backslashes `\\`, cause string quotes consume one of them. \# Sets and ranges \[…\]

Several characters or character classes inside square brackets `[…]` mean to “search for any character among given”.

## Sets

For instance, `pattern:[eao]` means any of the 3 characters: `'a'`, `'e'`, or `'o'`.

That’s called a _set_. Sets can be used in a regexp along with regular characters:

`js run // find [t or m], and then "op" alert( "Mop top".match(/[tm]op/gi) ); // "Mop", "top"`

Please note that although there are multiple characters in the set, they correspond to exactly one character in the match.

So the example below gives no matches:

`js run // find "V", then [o or i], then "la" alert( "Voila".match(/V[oi]la/) ); // null, no matches`

The pattern searches for:

- `pattern:V`,
- then _one_ of the letters `pattern:[oi]`,
- then `pattern:la`.

So there would be a match for `match:Vola` or `match:Vila`.

## Ranges

Square brackets may also contain _character ranges_.

For instance, `pattern:[a-z]` is a character in range from `a` to `z`, and `pattern:[0-5]` is a digit from `0` to `5`.

In the example below we’re searching for `"x"` followed by two digits or letters from `A` to `F`:

`js run alert( "Exception 0xAF".match(/x[0-9A-F][0-9A-F]/g) ); // xAF`

Here `pattern:[0-9A-F]` has two ranges: it searches for a character that is either a digit from `0` to `9` or a letter from `A` to `F`.

If we’d like to look for lowercase letters as well, we can add the range `a-f`: `pattern:[0-9A-Fa-f]`. Or add the flag `pattern:i`.

We can also use character classes inside `[…]`.

For instance, if we’d like to look for a wordly character `pattern:\w` or a hyphen `pattern:-`, then the set is `pattern:[\w-]`.

Combining multiple classes is also possible, e.g. `pattern:[\s\d]` means “a space character or a digit”.

\`\`\`smart header=“Character classes are shorthands for certain character sets” For instance:

- \*\* – is the same as `pattern:[0-9]`,
- \*\*\* – is the same as `pattern:[a-zA-Z0-9_]`,
- \*\*\* – is the same as `pattern:[\t\n\v\f\r ]`, plus few other rare Unicode space characters. \`\`\`

### Example: multi-language

As the character class `pattern:\w` is a shorthand for `pattern:[a-zA-Z0-9_]`, it can’t find Chinese hieroglyphs, Cyrillic letters, etc.

We can write a more universal pattern, that looks for wordly characters in any language. That’s easy with Unicode properties: `pattern:[\p{Alpha}\p{M}\p{Nd}\p{Pc}\p{Join_C}]`.

Let’s decipher it. Similar to `pattern:\w`, we’re making a set of our own that includes characters with following Unicode properties:

- `Alphabetic` (`Alpha`) - for letters,
- `Mark` (`M`) - for accents,
- `Decimal_Number` (`Nd`) - for digits,
- `Connector_Punctuation` (`Pc`) - for the underscore `'_'` and similar characters,
- `Join_Control` (`Join_C`) - two special codes `200c` and `200d`, used in ligatures, e.g. in Arabic.

An example of use:

\`\`\`js run let regexp = /\[\]/gu;

let str = `Hi 你好 12`;

// finds all letters and digits: alert( str.match(regexp) ); // H,i,你,好,1,2 \`\`\`

Of course, we can edit this pattern: add Unicode properties or remove them. Unicode properties are covered in more details in the article <a href="info:regexp-unicode" class="uri">info:regexp-unicode</a>.

\`\``warn header="Unicode properties aren't supported in IE" Unicode properties`pattern:p{…}\` are not implemented in IE. If we really need them, we can use library [XRegExp](http://xregexp.com/).

Or just use ranges of characters in a language that interests us, e.g. `pattern:[а-я]` for Cyrillic letters. \`\`\`

## Excluding ranges

Besides normal ranges, there are “excluding” ranges that look like `pattern:[^…]`.

They are denoted by a caret character `^` at the start and match any character _except the given ones_.

For instance:

- `pattern:[^aeyo]` – any character except `'a'`, `'e'`, `'y'` or `'o'`.
- `pattern:[^0-9]` – any character except a digit, the same as `pattern:\D`.
- `pattern:[^\s]` – any non-space character, same as `\S`.

The example below looks for any characters except letters, digits and spaces:

`js run alert( "alice15@gmail.com".match(/[^\d\sA-Z]/gi) ); // @ and .`

## Escaping in \[…\]

Usually when we want to find exactly a special character, we need to escape it like `pattern:\.`. And if we need a backslash, then we use `pattern:\\`, and so on.

In square brackets we can use the vast majority of special characters without escaping:

- Symbols `pattern:. + ( )` never need escaping.
- A hyphen `pattern:-` is not escaped in the beginning or the end (where it does not define a range).
- A caret `pattern:^` is only escaped in the beginning (where it means exclusion).
- The closing square bracket `pattern:]` is always escaped (if we need to look for that symbol).

In other words, all special characters are allowed without escaping, except when they mean something for square brackets.

A dot `.` inside square brackets means just a dot. The pattern `pattern:[.,]` would look for one of characters: either a dot or a comma.

In the example below the regexp `pattern:[-().^+]` looks for one of the characters `-().^+`:

\`\`\`js run // No need to escape let regexp = /\[-().^+\]/g;

alert( “1 + 2 - 3”.match(regexp) ); // Matches +, - \`\`\`

…But if you decide to escape them “just in case”, then there would be no harm:

\`\`\`js run // Escaped everything let regexp = /\[-().^+\]/g;

alert( “1 + 2 - 3”.match(regexp) ); // also works: +, - \`\`\`

## Ranges and flag “u”

If there are surrogate pairs in the set, flag `pattern:u` is required for them to work correctly.

For instance, let’s look for `pattern:[𝒳𝒴]` in the string `subject:𝒳`:

`js run alert( '𝒳'.match(/[𝒳𝒴]/) ); // shows a strange character, like [?] // (the search was performed incorrectly, half-character returned)`

The result is incorrect, because by default regular expressions “don’t know” about surrogate pairs.

The regular expression engine thinks that `[𝒳𝒴]` – are not two, but four characters: 1. left half of `𝒳` `(1)`, 2. right half of `𝒳` `(2)`, 3. left half of `𝒴` `(3)`, 4. right half of `𝒴` `(4)`.

We can see their codes like this:

`js run for(let i=0; i<'𝒳𝒴'.length; i++) { alert('𝒳𝒴'.charCodeAt(i)); // 55349, 56499, 55349, 56500 };`

So, the example above finds and shows the left half of `𝒳`.

If we add flag `pattern:u`, then the behavior will be correct:

`js run alert( '𝒳'.match(/[𝒳𝒴]/u) ); // 𝒳`

The similar situation occurs when looking for a range, such as `[𝒳-𝒴]`.

If we forget to add flag `pattern:u`, there will be an error:

`js run '𝒳'.match(/[𝒳-𝒴]/); // Error: Invalid regular expression`

The reason is that without flag `pattern:u` surrogate pairs are perceived as two characters, so `[𝒳-𝒴]` is interpreted as `[<55349><56499>-<55349><56500>]` (every surrogate pair is replaced with its codes). Now it’s easy to see that the range `56499-55349` is invalid: its starting code `56499` is greater than the end `55349`. That’s the formal reason for the error.

With the flag `pattern:u` the pattern works correctly:

`js run // look for characters from 𝒳 to 𝒵 alert( '𝒴'.match(/[𝒳-𝒵]/u) ); // 𝒴` \# Quantifiers +, \*, ? and {n}

Let’s say we have a string like `+7(903)-123-45-67` and want to find all numbers in it. But unlike before, we are interested not in single digits, but full numbers: `7, 903, 123, 45, 67`.

A number is a sequence of 1 or more digits `pattern:\d`. To mark how many we need, we can append a _quantifier_.

## Quantity {n}

The simplest quantifier is a number in curly braces: `pattern:{n}`.

A quantifier is appended to a character (or a character class, or a `[...]` set etc) and specifies how many we need.

It has a few advanced forms, let’s see examples:

The exact count: `pattern:{5}`  
`pattern:\d{5}` denotes exactly 5 digits, the same as `pattern:\d\d\d\d\d`.

The example below looks for a 5-digit number:

`js run alert( "I'm 12345 years old".match(/\d{5}/) ); // "12345"`

We can add `\b` to exclude longer numbers: `pattern:\b\d{5}\b`.

The range: `pattern:{3,5}`, match 3-5 times  
To find numbers from 3 to 5 digits we can put the limits into curly braces: `pattern:\d{3,5}`

`js run alert( "I'm not 12, but 1234 years old".match(/\d{3,5}/) ); // "1234"`

We can omit the upper limit.

Then a regexp `pattern:\d{3,}` looks for sequences of digits of length `3` or more:

`js run alert( "I'm not 12, but 345678 years old".match(/\d{3,}/) ); // "345678"`

Let’s return to the string `+7(903)-123-45-67`.

A number is a sequence of one or more digits in a row. So the regexp is `pattern:\d{1,}`:

\`\`\`js run let str = “+7(903)-123-45-67”;

let numbers = str.match(//g);

alert(numbers); // 7,903,123,45,67 \`\`\`

## Shorthands

There are shorthands for most used quantifiers:

`pattern:+`  
Means “one or more”, the same as `pattern:{1,}`.

For instance, `pattern:\d+` looks for numbers:

\`\`\`js run let str = “+7(903)-123-45-67”;

alert( str.match(//g) ); // 7,903,123,45,67 \`\`\`

`pattern:?`  
Means “zero or one”, the same as `pattern:{0,1}`. In other words, it makes the symbol optional.

For instance, the pattern `pattern:ou?r` looks for `match:o` followed by zero or one `match:u`, and then `match:r`.

So, `pattern:colou?r` finds both `match:color` and `match:colour`:

\`\`\`js run let str = “Should I write color or colour?”;

alert( str.match(/colou?r/g) ); // color, colour \`\`\`

`pattern:*`  
Means “zero or more”, the same as `pattern:{0,}`. That is, the character may repeat any times or be absent.

For example, `pattern:\d0*` looks for a digit followed by any number of zeroes (may be many or none):

`js run alert( "100 10 1".match(/\d0*/g) ); // 100, 10, 1`

Compare it with `pattern:+` (one or more):

`js run alert( "100 10 1".match(/\d0+/g) ); // 100, 10 // 1 not matched, as 0+ requires at least one zero`

## More examples

Quantifiers are used very often. They serve as the main “building block” of complex regular expressions, so let’s see more examples.

**Regexp for decimal fractions (a number with a floating point): `pattern:\d+\.\d+`**

In action: `js run alert( "0 1 12.345 7890".match(/\d+\.\d+/g) ); // 12.345`

**Regexp for an “opening HTML-tag without attributes”, such as `<span>` or `<p>`.**

1.  The simplest one: `pattern:/<[a-z]+>/i`

    `js run alert( "<body> ... </body>".match(/<[a-z]+>/gi) ); // <body>`

    The regexp looks for character `pattern:'<'` followed by one or more Latin letters, and then `pattern:'>'`.

2.  Improved: `pattern:/<[a-z][a-z0-9]*>/i`

    According to the standard, HTML tag name may have a digit at any position except the first one, like `<h1>`.

    `js run alert( "<h1>Hi!</h1>".match(/<[a-z][a-z0-9]*>/gi) ); // <h1>`

**Regexp “opening or closing HTML-tag without attributes”: `pattern:/<\/?[a-z][a-z0-9]*>/i`**

We added an optional slash `pattern:/?` near the beginning of the pattern. Had to escape it with a backslash, otherwise JavaScript would think it is the pattern end.

`js run alert( "<h1>Hi!</h1>".match(/<\/?[a-z][a-z0-9]*>/gi) ); // <h1>, </h1>`

\`\`\`smart header=“To make a regexp more precise, we often need make it more complex” We can see one common rule in these examples: the more precise is the regular expression – the longer and more complex it is.

For instance, for HTML tags we could use a simpler regexp: `pattern:<\w+>`. But as HTML has stricter restrictions for a tag name, `pattern:<[a-z][a-z0-9]*>` is more reliable.

Can we use `pattern:<\w+>` or we need `pattern:<[a-z][a-z0-9]*>`?

In real life both variants are acceptable. Depends on how tolerant we can be to “extra” matches and whether it’s difficult or not to remove them from the result by other means. \`\`\` \# Greedy and lazy quantifiers

Quantifiers are very simple from the first sight, but in fact they can be tricky.

We should understand how the search works very well if we plan to look for something more complex than `pattern:/\d+/`.

Let’s take the following task as an example.

We have a text and need to replace all quotes `"..."` with guillemet marks: `«...»`. They are preferred for typography in many countries.

For instance: `"Hello, world"` should become `«Hello, world»`. There exist other quotes, such as `„Witam, świat!”` (Polish) or `「你好，世界」` (Chinese), but for our task let’s choose `«...»`.

The first thing to do is to locate quoted strings, and then we can replace them.

A regular expression like `pattern:/".+"/g` (a quote, then something, then the other quote) may seem like a good fit, but it isn’t!

Let’s try it:

\`\`\`js run let regexp = /“.+”/g;

let str = ‘a “witch” and her “broom” is one’;

alert( str.match(regexp) ); // “witch” and her “broom” \`\`\`

…We can see that it works not as intended!

Instead of finding two matches `match:"witch"` and `match:"broom"`, it finds one: `match:"witch" and her "broom"`.

That can be described as “greediness is the cause of all evil”.

## Greedy search

To find a match, the regular expression engine uses the following algorithm:

- For every position in the string
  - Try to match the pattern at that position.
  - If there’s no match, go to the next position.

These common words do not make it obvious why the regexp fails, so let’s elaborate how the search works for the pattern `pattern:".+"`.

1.  The first pattern character is a quote `pattern:"`.

    The regular expression engine tries to find it at the zero position of the source string `subject:a "witch" and her "broom" is one`, but there’s `subject:a` there, so there’s immediately no match.

    Then it advances: goes to the next positions in the source string and tries to find the first character of the pattern there, fails again, and finally finds the quote at the 3rd position:

    ![](witch_greedy1.svg)

2.  The quote is detected, and then the engine tries to find a match for the rest of the pattern. It tries to see if the rest of the subject string conforms to `pattern:.+"`.

    In our case the next pattern character is `pattern:.` (a dot). It denotes “any character except a newline”, so the next string letter `match:'w'` fits:

    ![](witch_greedy2.svg)

3.  Then the dot repeats because of the quantifier `pattern:.+`. The regular expression engine adds to the match one character after another.

    …Until when? All characters match the dot, so it only stops when it reaches the end of the string:

    ![](witch_greedy3.svg)

4.  Now the engine finished repeating `pattern:.+` and tries to find the next character of the pattern. It’s the quote `pattern:"`. But there’s a problem: the string has finished, there are no more characters!

    The regular expression engine understands that it took too many `pattern:.+` and starts to _backtrack_.

    In other words, it shortens the match for the quantifier by one character:

    ![](witch_greedy4.svg)

    Now it assumes that `pattern:.+` ends one character before the string end and tries to match the rest of the pattern from that position.

    If there were a quote there, then the search would end, but the last character is `subject:'e'`, so there’s no match.

5.  …So the engine decreases the number of repetitions of `pattern:.+` by one more character:

    ![](witch_greedy5.svg)

    The quote `pattern:'"'` does not match `subject:'n'`.

6.  The engine keep backtracking: it decreases the count of repetition for `pattern:'.'` until the rest of the pattern (in our case `pattern:'"'`) matches:

    ![](witch_greedy6.svg)

7.  The match is complete.

8.  So the first match is `match:"witch" and her "broom"`. If the regular expression has flag `pattern:g`, then the search will continue from where the first match ends. There are no more quotes in the rest of the string `subject:is one`, so no more results.

That’s probably not what we expected, but that’s how it works.

**In the greedy mode (by default) a quantified character is repeated as many times as possible.**

The regexp engine adds to the match as many characters as it can for `pattern:.+`, and then shortens that one by one, if the rest of the pattern doesn’t match.

For our task we want another thing. That’s where a lazy mode can help.

## Lazy mode

The lazy mode of quantifiers is an opposite to the greedy mode. It means: “repeat minimal number of times”.

We can enable it by putting a question mark `pattern:'?'` after the quantifier, so that it becomes `pattern:*?` or `pattern:+?` or even `pattern:??` for `pattern:'?'`.

To make things clear: usually a question mark `pattern:?` is a quantifier by itself (zero or one), but if added _after another quantifier (or even itself)_ it gets another meaning – it switches the matching mode from greedy to lazy.

The regexp `pattern:/".+?"/g` works as intended: it finds `match:"witch"` and `match:"broom"`:

\`\`\`js run let regexp = /“.+?”/g;

let str = ‘a “witch” and her “broom” is one’;

alert( str.match(regexp) ); // “witch”, “broom” \`\`\`

To clearly understand the change, let’s trace the search step by step.

1.  The first step is the same: it finds the pattern start `pattern:'"'` at the 3rd position:

    ![](witch_greedy1.svg)

2.  The next step is also similar: the engine finds a match for the dot `pattern:'.'`:

    ![](witch_greedy2.svg)

3.  And now the search goes differently. Because we have a lazy mode for `pattern:+?`, the engine doesn’t try to match a dot one more time, but stops and tries to match the rest of the pattern `pattern:'"'` right now:

    ![](witch_lazy3.svg)

    If there were a quote there, then the search would end, but there’s `'i'`, so there’s no match.

4.  Then the regular expression engine increases the number of repetitions for the dot and tries one more time:

    ![](witch_lazy4.svg)

    Failure again. Then the number of repetitions is increased again and again…

5.  …Till the match for the rest of the pattern is found:

    ![](witch_lazy5.svg)

6.  The next search starts from the end of the current match and yield one more result:

    ![](witch_lazy6.svg)

In this example we saw how the lazy mode works for `pattern:+?`. Quantifiers `pattern:*?` and `pattern:??` work the similar way – the regexp engine increases the number of repetitions only if the rest of the pattern can’t match on the given position.

**Laziness is only enabled for the quantifier with `?`.**

Other quantifiers remain greedy.

For instance:

`js run alert( "123 456".match(/\d+ \d+?/) ); // 123 4`

1.  The pattern `pattern:\d+` tries to match as many digits as it can (greedy mode), so it finds `match:123` and stops, because the next character is a space `pattern:' '`.
2.  Then there’s a space in the pattern, it matches.
3.  Then there’s `pattern:\d+?`. The quantifier is in lazy mode, so it finds one digit `match:4` and tries to check if the rest of the pattern matches from there.

    …But there’s nothing in the pattern after `pattern:\d+?`.

    The lazy mode doesn’t repeat anything without a need. The pattern finished, so we’re done. We have a match `match:123 4`.

\`\`\`smart header=“Optimizations” Modern regular expression engines can optimize internal algorithms to work faster. So they may work a bit differently from the described algorithm.

But to understand how regular expressions work and to build regular expressions, we don’t need to know about that. They are only used internally to optimize things.

Complex regular expressions are hard to optimize, so the search may work exactly as described as well. \`\`\`

## Alternative approach

With regexps, there’s often more than one way to do the same thing.

In our case we can find quoted strings without lazy mode using the regexp `pattern:"[^"]+"`:

\`\`\`js run let regexp = /“\[^"\]+”/g;

let str = ‘a “witch” and her “broom” is one’;

alert( str.match(regexp) ); // “witch”, “broom” \`\`\`

The regexp `pattern:"[^"]+"` gives correct results, because it looks for a quote `pattern:'"'` followed by one or more non-quotes `pattern:[^"]`, and then the closing quote.

When the regexp engine looks for `pattern:[^"]+` it stops the repetitions when it meets the closing quote, and we’re done.

Please note, that this logic does not replace lazy quantifiers!

It is just different. There are times when we need one or another.

**Let’s see an example where lazy quantifiers fail and this variant works right.**

For instance, we want to find links of the form `<a href="..." class="doc">`, with any `href`.

Which regular expression to use?

The first idea might be: `pattern:/<a href=".*" class="doc">/g`.

Let’s check it: \`\`\`js run let str = ‘…<a href="link" class="doc">…’; let regexp = /</a>/g;

// Works! alert( str.match(regexp) ); // \`\`\`

It worked. But let’s see what happens if there are many links in the text?

\`\`\`js run let str = ‘…<a href="link1" class="doc">…</a> <a href="link2" class="doc">…’; let regexp = /</a>/g;

// Whoops! Two links in one match! alert( str.match(regexp) ); // <a href="link1" class="doc">…</a> \`\`\`

Now the result is wrong for the same reason as our “witches” example. The quantifier `pattern:.*` took too many characters.

The match looks like this:

    <a href="....................................." class="doc">
    <a href="link1" class="doc">... <a href="link2" class="doc">

Let’s modify the pattern by making the quantifier `pattern:.*?` lazy:

\`\`\`js run let str = ‘…<a href="link1" class="doc">…</a> <a href="link2" class="doc">…’; let regexp = /</a>/g;

// Works! alert( str.match(regexp) ); // <a href="link1" class="doc">,</a> \`\`\`

Now it seems to work, there are two matches:

    <a href="....." class="doc">    <a href="....." class="doc">
    <a href="link1" class="doc">... <a href="link2" class="doc">

…But let’s test it on one more text input:

\`\`\`js run let str = ’…<a href="link1" class="wrong">…</a>

…’; let regexp = //g;

// Wrong match! alert( str.match(regexp) ); // <a href="link1" class="wrong">…</a>

\`\`\`

Now it fails. The match includes not just a link, but also a lot of text after it, including `<p...>`.

Why?

That’s what’s going on:

1.  First the regexp finds a link start `match:<a href="`.
2.  Then it looks for `pattern:.*?`: takes one character (lazily!), check if there’s a match for `pattern:" class="doc">` (none).
3.  Then takes another character into `pattern:.*?`, and so on… until it finally reaches `match:" class="doc">`.

But the problem is: that’s already beyond the link `<a...>`, in another tag `<p>`. Not what we want.

Here’s the picture of the match aligned with the text:

    <a href="..................................." class="doc">
    <a href="link1" class="wrong">... <p style="" class="doc">

So, we need the pattern to look for `<a href="...something..." class="doc">`, but both greedy and lazy variants have problems.

The correct variant can be: `pattern:href="[^"]*"`. It will take all characters inside the `href` attribute till the nearest quote, just what we need.

A working example:

\`\`\`js run let str1 = ’…<a href="link1" class="wrong">…</a>

…‘; let str2 =’…<a href="link1" class="doc">…</a> …’; let regexp = /&lt;a href="\[^"\]\*" class=“doc”&gt;/g;

// Works! alert( str1.match(regexp) ); // null, no matches, that’s correct alert( str2.match(regexp) ); // <a href="link1" class="doc">,</a> \`\`\`

## Summary

Quantifiers have two modes of work:

Greedy  
By default the regular expression engine tries to repeat the quantified character as many times as possible. For instance, `pattern:\d+` consumes all possible digits. When it becomes impossible to consume more (no more digits or string end), then it continues to match the rest of the pattern. If there’s no match then it decreases the number of repetitions (backtracks) and tries again.

Lazy  
Enabled by the question mark `pattern:?` after the quantifier. The regexp engine tries to match the rest of the pattern before each repetition of the quantified character.

As we’ve seen, the lazy mode is not a “panacea” from the greedy search. An alternative is a “fine-tuned” greedy search, with exclusions, as in the pattern `pattern:"[^"]+"`. \# Capturing groups

A part of a pattern can be enclosed in parentheses `pattern:(...)`. This is called a “capturing group”.

That has two effects:

1.  It allows to get a part of the match as a separate item in the result array.
2.  If we put a quantifier after the parentheses, it applies to the parentheses as a whole.

## Examples

Let’s see how parentheses work in examples.

### Example: gogogo

Without parentheses, the pattern `pattern:go+` means `subject:g` character, followed by `subject:o` repeated one or more times. For instance, `match:goooo` or `match:gooooooooo`.

Parentheses group characters together, so `pattern:(go)+` means `match:go`, `match:gogo`, `match:gogogo` and so on.

`js run alert( 'Gogogo now!'.match(/(go)+/ig) ); // "Gogogo"`

### Example: domain

Let’s make something more complex – a regular expression to search for a website domain.

For example:

    mail.com
    users.mail.com
    smith.users.mail.com

As we can see, a domain consists of repeated words, a dot after each one except the last one.

In regular expressions that’s `pattern:(\w+\.)+\w+`:

\`\`\`js run let regexp = /(+.)++/g;

alert( “site.com my.site.com”.match(regexp) ); // site.com,my.site.com \`\`\`

The search works, but the pattern can’t match a domain with a hyphen, e.g. `my-site.com`, because the hyphen does not belong to class `pattern:\w`.

We can fix it by replacing `pattern:\w` with `pattern:[\w-]` in every word except the last one: `pattern:([\w-]+\.)+\w+`.

### Example: email

The previous example can be extended. We can create a regular expression for emails based on it.

The email format is: `name@domain`. Any word can be the name, hyphens and dots are allowed. In regular expressions that’s `pattern:[-.\w]+`.

The pattern:

\`\`\`js run let regexp = /\[-.\]+@(\[-\]+.)+\[-\]+/g;

alert(“my@mail.com @ his@site.com.uk”.match(regexp)); // my@mail.com, his@site.com.uk \`\`\`

That regexp is not perfect, but mostly works and helps to fix accidental mistypes. The only truly reliable check for an email can only be done by sending a letter.

## Parentheses contents in the match

Parentheses are numbered from left to right. The search engine memorizes the content matched by each of them and allows to get it in the result.

The method `str.match(regexp)`, if `regexp` has no flag `g`, looks for the first match and returns it as an array:

1.  At index `0`: the full match.
2.  At index `1`: the contents of the first parentheses.
3.  At index `2`: the contents of the second parentheses.
4.  …and so on…

For instance, we’d like to find HTML tags `pattern:<.*?>`, and process them. It would be convenient to have tag content (what’s inside the angles), in a separate variable.

Let’s wrap the inner content into parentheses, like this: `pattern:<(.*?)>`.

Now we’ll get both the tag as a whole `match:<h1>` and its contents `match:h1` in the resulting array:

\`\`\`js run let str = ’

# Hello, world!

’;

let tag = str.match(/&lt;(.\*?)&gt;/);

alert( tag\[0\] ); //

alert( tag\[1\] ); // h1 \`\`\`

### Nested groups

Parentheses can be nested. In this case the numbering also goes from left to right.

For instance, when searching a tag in `subject:<span class="my">` we may be interested in:

1.  The tag content as a whole: `match:span class="my"`.
2.  The tag name: `match:span`.
3.  The tag attributes: `match:class="my"`.

Let’s add parentheses for them: `pattern:<(([a-z]+)\s*([^>]*))>`.

Here’s how they are numbered (left to right, by the opening paren):

![](regexp-nested-groups-pattern.svg)

In action:

\`\`\`js run let str = ‘’;

let regexp = /&lt;((\[a-z\]+)(\[^&gt;\]\*))&gt;/;

let result = str.match(regexp); alert(result\[0\]); // alert(result\[1\]); // span class=“my” alert(result\[2\]); // span alert(result\[3\]); // class=“my” \`\`\`

The zero index of `result` always holds the full match.

Then groups, numbered from left to right by an opening paren. The first group is returned as `result[1]`. Here it encloses the whole tag content.

Then in `result[2]` goes the group from the second opening paren `pattern:([a-z]+)` - tag name, then in `result[3]` the tag: `pattern:([^>]*)`.

The contents of every group in the string:

![](regexp-nested-groups-matches.svg)

### Optional groups

Even if a group is optional and doesn’t exist in the match (e.g. has the quantifier `pattern:(...)?`), the corresponding `result` array item is present and equals `undefined`.

For instance, let’s consider the regexp `pattern:a(z)?(c)?`. It looks for `"a"` optionally followed by `"z"` optionally followed by `"c"`.

If we run it on the string with a single letter `subject:a`, then the result is:

\`\`\`js run let match = ‘a’.match(/a(z)?(c)?/);

alert( match.length ); // 3 alert( match\[0\] ); // a (whole match) alert( match\[1\] ); // undefined alert( match\[2\] ); // undefined \`\`\`

The array has the length of `3`, but all groups are empty.

And here’s a more complex match for the string `subject:ac`:

\`\`\`js run let match = ‘ac’.match(/a(z)?(c)?/)

alert( match.length ); // 3 alert( match\[0\] ); // ac (whole match) alert( match\[1\] ); // undefined, because there’s nothing for (z)? alert( match\[2\] ); // c \`\`\`

The array length is permanent: `3`. But there’s nothing for the group `pattern:(z)?`, so the result is `["ac", undefined, "c"]`.

## Searching for all matches with groups: matchAll

\`\``warn header="`matchAll`is a new method, polyfill may be needed" The method`matchAll\` is not supported in old browsers.

A polyfill may be required, such as <a href="https://github.com/ljharb/String.prototype.matchAll" class="uri">https://github.com/ljharb/String.prototype.matchAll</a>. \`\`\`

When we search for all matches (flag `pattern:g`), the `match` method does not return contents for groups.

For example, let’s find all tags in a string:

\`\`\`js run let str = ’

’;

let tags = str.match(/&lt;(.\*?)&gt;/g);

alert( tags ); //

# ,

\`\`\`

The result is an array of matches, but without details about each of them. But in practice we usually need contents of capturing groups in the result.

To get them, we should search using the method `str.matchAll(regexp)`.

It was added to JavaScript language long after `match`, as its “new and improved version”.

Just like `match`, it looks for matches, but there are 3 differences:

1.  It returns not an array, but an iterable object.
2.  When the flag `pattern:g` is present, it returns every match as an array with groups.
3.  If there are no matches, it returns not `null`, but an empty iterable object.

For instance:

\`\`\`js run let results = ’

’.matchAll(/&lt;(.\*?)&gt;/gi);

// results - is not an array, but an iterable object alert(results); // \[object RegExp String Iterator\]

alert(results\[0\]); // undefined (\*)

results = Array.from(results); // let’s turn it into array

alert(results\[0\]); //

# ,h1 (1st tag) alert(results\[1\]); //

,h2 (2nd tag) \`\`\`

As we can see, the first difference is very important, as demonstrated in the line `(*)`. We can’t get the match as `results[0]`, because that object isn’t pseudoarray. We can turn it into a real `Array` using `Array.from`. There are more details about pseudoarrays and iterables in the article <a href="info:iterable" class="uri">info:iterable</a>.

There’s no need in `Array.from` if we’re looping over results:

\`\`\`js run let results = ’

’.matchAll(/&lt;(.\*?)&gt;/gi);

for(let result of results) { alert(result); // first alert:

# ,h1 // second:

,h2 } \`\`\`

…Or using destructuring:

    let [tag1, tag2] = '<h1> <h2>'.matchAll(/<(.*?)>/gi);

Every match, returned by `matchAll`, has the same format as returned by `match` without flag `pattern:g`: it’s an array with additional properties `index` (match index in the string) and `input` (source string):

\`\`\`js run let results = ’

’.matchAll(/&lt;(.\*?)&gt;/gi);

let \[tag1, tag2\] = results;

alert( tag1\[0\] ); //

# alert( tag1\[1\] ); // h1 alert( tag1.index ); // 0 alert( tag1.input ); //

\`\`\`

\`\``smart header="Why is a result of`matchAll\` an iterable object, not an array?" Why is the method designed like that? The reason is simple - for the optimization.

The call to `matchAll` does not perform the search. Instead, it returns an iterable object, without the results initially. The search is performed each time we iterate over it, e.g. in the loop.

So, there will be found as many results as needed, not more.

E.g. there are potentially 100 matches in the text, but in a `for..of` loop we found 5 of them, then decided it’s enough and made a `break`. Then the engine won’t spend time finding other 95 matches. \`\`\`

## Named groups

Remembering groups by their numbers is hard. For simple patterns it’s doable, but for more complex ones counting parentheses is inconvenient. We have a much better option: give names to parentheses.

That’s done by putting `pattern:?<name>` immediately after the opening paren.

For example, let’s look for a date in the format “year-month-day”:

\`\`\`js run _!_ let dateRegexp = /(?\[0-9\]{4})-(?\[0-9\]{2})-(?\[0-9\]{2})/; _/!_ let str = “2019-04-30”;

let groups = str.match(dateRegexp).groups;

alert(groups.year); // 2019 alert(groups.month); // 04 alert(groups.day); // 30 \`\`\`

As you can see, the groups reside in the `.groups` property of the match.

To look for all dates, we can add flag `pattern:g`.

We’ll also need `matchAll` to obtain full matches, together with groups:

\`\`\`js run let dateRegexp = /(?\[0-9\]{4})-(?\[0-9\]{2})-(?\[0-9\]{2})/g;

let str = “2019-10-30 2020-01-01”;

let results = str.matchAll(dateRegexp);

for(let result of results) { let {year, month, day} = result.groups;

alert(`${day}.${month}.${year}`); // first alert: 30.10.2019 // second: 01.01.2020 } \`\`\`

## Capturing groups in replacement

Method `str.replace(regexp, replacement)` that replaces all matches with `regexp` in `str` allows to use parentheses contents in the `replacement` string. That’s done using `pattern:$n`, where `pattern:n` is the group number.

For example,

\`\`\`js run let str = “John Bull”; let regexp = /(+) (+)/;

alert( str.replace(regexp, ‘$2, $1’) ); // Bull, John \`\`\`

For named parentheses the reference will be `pattern:$<name>`.

For example, let’s reformat dates from “year-month-day” to “day.month.year”:

\`\`\`js run let regexp = /(?\[0-9\]{4})-(?\[0-9\]{2})-(?\[0-9\]{2})/g;

let str = “2019-10-30, 2020-01-01”;

alert( str.replace(regexp, ‘<span class="math inline"> &lt; *day* &gt; .</span>.$’) ); // 30.10.2019, 01.01.2020 \`\`\`

## Non-capturing groups with ?:

Sometimes we need parentheses to correctly apply a quantifier, but we don’t want their contents in results.

A group may be excluded by adding `pattern:?:` in the beginning.

For instance, if we want to find `pattern:(go)+`, but don’t want the parentheses contents (`go`) as a separate array item, we can write: `pattern:(?:go)+`.

In the example below we only get the name `match:John` as a separate member of the match:

\`\`\`js run let str = “Gogogo John!”;

_!_ // ?: exludes ‘go’ from capturing let regexp = /(?:go)+ (+)/i; _/!_

let result = str.match(regexp);

alert( result\[0\] ); // Gogogo John (full match) alert( result\[1\] ); // John alert( result.length ); // 2 (no more items in the array) \`\`\`

## Summary

Parentheses group together a part of the regular expression, so that the quantifier applies to it as a whole.

Parentheses groups are numbered left-to-right, and can optionally be named with `(?<name>...)`.

The content, matched by a group, can be obtained in the results:

- The method `str.match` returns capturing groups only without flag `pattern:g`.
- The method `str.matchAll` always returns capturing groups.

If the parentheses have no name, then their contents is available in the match array by its number. Named parentheses are also available in the property `groups`.

We can also use parentheses contents in the replacement string in `str.replace`: by the number `$n` or the name `$<name>`.

A group may be excluded from numbering by adding `pattern:?:` in its start. That’s used when we need to apply a quantifier to the whole group, but don’t want it as a separate item in the results array. We also can’t reference such parentheses in the replacement string. \# Backreferences in pattern: and name&gt;

We can use the contents of capturing groups `pattern:(...)` not only in the result or in the replacement string, but also in the pattern itself.

## Backreference by number:

A group can be referenced in the pattern using `pattern:\N`, where `N` is the group number.

To make clear why that’s helpful, let’s consider a task.

We need to find quoted strings: either single-quoted `subject:'...'` or a double-quoted `subject:"..."` – both variants should match.

How to find them?

We can put both kinds of quotes in the square brackets: `pattern:['"](.*?)['"]`, but it would find strings with mixed quotes, like `match:"...'` and `match:'..."`. That would lead to incorrect matches when one quote appears inside other ones, like in the string `subject:"She's the one!"`:

\`\``js run let str =`He said: “She’s the one!”.\`;

let regexp = /[’"](.*?)\[’"\]/g;

// The result is not what we’d like to have alert( str.match(regexp) ); // "She’ \`\`\`

As we can see, the pattern found an opening quote `match:"`, then the text is consumed till the other quote `match:'`, that closes the match.

To make sure that the pattern looks for the closing quote exactly the same as the opening one, we can wrap it into a capturing group and backreference it: `pattern:(['"])(.*?)\1`.

Here’s the correct code:

\`\``js run let str =`He said: “She’s the one!”.\`;

_!_ let regexp = /(\[’"\])(._?)\\1/g;_ /!\*

alert( str.match(regexp) ); // “She’s the one!” \`\`\`

Now it works! The regular expression engine finds the first quote `pattern:(['"])` and memorizes its content. That’s the first capturing group.

Further in the pattern `pattern:\1` means “find the same text as in the first group”, exactly the same quote in our case.

Similar to that, `pattern:\2` would mean the contents of the second group, `pattern:\3` - the 3rd group, and so on.

    If we use `?:` in the group, then we can't reference it. Groups that are excluded from capturing `(?:...)` are not memorized by the engine.

`` warn header="Don't mess up: in the pattern `pattern:\1`, in the replacement: `pattern:$1`" In the replacement string we use a dollar sign: `pattern:$1`, while in the pattern - a backslash `pattern:\1`. ``

## Backreference by name: `\k<name>`

If a regexp has many parentheses, it’s convenient to give them names.

To reference a named group we can use `pattern:\k<name>`.

In the example below the group with quotes is named `pattern:?<quote>`, so the backreference is `pattern:\k<quote>`:

\`\``js run let str =`He said: “She’s the one!”.\`;

_!_ let regexp = /(?\[’"\])(._?)quote&gt;/g;_ /!\*

alert( str.match(regexp) ); // “She’s the one!” \`\`\` \# Alternation (OR) |

Alternation is the term in regular expression that is actually a simple “OR”.

In a regular expression it is denoted with a vertical line character `pattern:|`.

For instance, we need to find programming languages: HTML, PHP, Java or JavaScript.

The corresponding regexp: `pattern:html|php|java(script)?`.

A usage example:

\`\`\`js run let regexp = /html|php|css|java(script)?/gi;

let str = “First HTML appeared, then CSS, then JavaScript”;

alert( str.match(regexp) ); // ‘HTML’, ‘CSS’, ‘JavaScript’

    We already saw a similar thing -- square brackets. They allow to choose between multiple characters, for instance `pattern:gr[ae]y` matches `match:gray` or `match:grey`.

    Square brackets allow only characters or character classes. Alternation allows any expressions. A regexp `pattern:A|B|C` means one of expressions `A`, `B` or `C`.

    For instance:

    - `pattern:gr(a|e)y` means exactly the same as `pattern:gr[ae]y`.
    - `pattern:gra|ey` means `match:gra` or `match:ey`.

    To apply alternation to a chosen part of the pattern, we can enclose it in parentheses:
    - `pattern:I love HTML|CSS` matches `match:I love HTML` or `match:CSS`.
    - `pattern:I love (HTML|CSS)` matches `match:I love HTML` or `match:I love CSS`.

    ## Example: regexp for time

    In previous articles there was a task to build a regexp for searching time in the form `hh:mm`, for instance `12:00`. But a simple `pattern:\d\d:\d\d` is too vague. It accepts `25:99` as the time (as 99 minutes match the pattern, but that time is invalid).

    How can we make a better pattern?

    We can use more careful matching. First, the hours:

    - If the first digit is `0` or `1`, then the next digit can be any: `pattern:[01]\d`.
    - Otherwise, if the first digit is `2`, then the next must be `pattern:[0-3]`.
    - (no other first digit is allowed)

    We can write both variants in a regexp using alternation: `pattern:[01]\d|2[0-3]`.

    Next, minutes must be from `00` to `59`. In the regular expression language that can be written as `pattern:[0-5]\d`: the first digit `0-5`, and then any digit.

    If we glue hours and minutes together, we get the pattern: `pattern:[01]\d|2[0-3]:[0-5]\d`.

    We're almost done, but there's a problem. The alternation `pattern:|` now happens to be between `pattern:[01]\d` and `pattern:2[0-3]:[0-5]\d`.

    That is: minutes are added to the second alternation variant, here's a clear picture:

\[01\] 2\[0-3\]:\[0-5\]\`\`

That pattern looks for `pattern:[01]\d` or `pattern:2[0-3]:[0-5]\d`.

But that’s wrong, the alternation should only be used in the “hours” part of the regular expression, to allow `pattern:[01]\d` OR `pattern:2[0-3]`. Let’s correct that by enclosing “hours” into parentheses: `pattern:([01]\d|2[0-3]):[0-5]\d`.

The final solution:

\`\`\`js run let regexp = /(\[01\]2\[0-3\]):\[0-5\]g;

alert(“00:00 10:10 23:59 25:99 1:2”.match(regexp)); // 00:00,10:10,23:59 \`\`\` \# Loops: while and for

We often need to repeat actions.

For example, outputting goods from a list one after another or just running the same code for each number from 1 to 10.

_Loops_ are a way to repeat the same code multiple times.

## The “while” loop

The `while` loop has the following syntax:

    while (condition) {
      // code
      // so-called "loop body"
    }

While the `condition` is truthy, the `code` from the loop body is executed.

For instance, the loop below outputs `i` while `i < 3`:

`js run let i = 0; while (i < 3) { // shows 0, then 1, then 2 alert( i ); i++; }`

A single execution of the loop body is called _an iteration_. The loop in the example above makes three iterations.

If `i++` was missing from the example above, the loop would repeat (in theory) forever. In practice, the browser provides ways to stop such loops, and in server-side JavaScript, we can kill the process.

Any expression or variable can be a loop condition, not just comparisons: the condition is evaluated and converted to a boolean by `while`.

For instance, a shorter way to write `while (i != 0)` is `while (i)`:

`js run let i = 3; *!* while (i) { // when i becomes 0, the condition becomes falsy, and the loop stops */!* alert( i ); i--; }`

\`\`\``smart header="Curly braces are not required for a single-line body" If the loop body has a single statement, we can omit the curly braces`{…}\`:

`js run let i = 3; *!* while (i) alert(i--); */!*` \`\`\`\`

## The “do..while” loop

The condition check can be moved _below_ the loop body using the `do..while` syntax:

    do {
      // loop body
    } while (condition);

The loop will first execute the body, then check the condition, and, while it’s truthy, execute it again and again.

For example:

`js run let i = 0; do { alert( i ); i++; } while (i < 3);`

This form of syntax should only be used when you want the body of the loop to execute **at least once** regardless of the condition being truthy. Usually, the other form is preferred: `while(…) {…}`.

## The “for” loop

The `for` loop is more complex, but it’s also the most commonly used loop.

It looks like this:

    for (begin; condition; step) {
      // ... loop body ...
    }

Let’s learn the meaning of these parts by example. The loop below runs `alert(i)` for `i` from `0` up to (but not including) `3`:

`js run for (let i = 0; i < 3; i++) { // shows 0, then 1, then 2 alert(i); }`

Let’s examine the `for` statement part-by-part:

<table style="width:98%;"><colgroup><col style="width: 7%" /><col style="width: 10%" /><col style="width: 81%" /></colgroup><thead><tr class="header"><th>part</th><th></th><th></th></tr></thead><tbody><tr class="odd"><td>begin</td><td><code>i = 0</code></td><td>Executes once upon entering the loop.</td></tr><tr class="even"><td>condition</td><td><code>i &lt; 3</code></td><td>Checked before every loop iteration. If false, the loop stops.</td></tr><tr class="odd"><td>body</td><td><code>alert(i)</code></td><td>Runs again and again while the condition is truthy.</td></tr><tr class="even"><td>step</td><td><code>i++</code></td><td>Executes after the body on each iteration.</td></tr></tbody></table>

The general loop algorithm works like this:

    Run begin
    → (if condition → run body and run step)
    → (if condition → run body and run step)
    → (if condition → run body and run step)
    → ...

That is, `begin` executes once, and then it iterates: after each `condition` test, `body` and `step` are executed.

If you are new to loops, it could help to go back to the example and reproduce how it runs step-by-step on a piece of paper.

Here’s exactly what happens in our case:

    // for (let i = 0; i < 3; i++) alert(i)

    // run begin
    let i = 0
    // if condition → run body and run step
    if (i < 3) { alert(i); i++ }
    // if condition → run body and run step
    if (i < 3) { alert(i); i++ }
    // if condition → run body and run step
    if (i < 3) { alert(i); i++ }
    // ...finish, because now i == 3

\`\`\``smart header="Inline variable declaration" Here, the "counter" variable`i\` is declared right in the loop. This is called an “inline” variable declaration. Such variables are visible only inside the loop.

`js run for (*!*let*/!* i = 0; i < 3; i++) { alert(i); // 0, 1, 2 } alert(i); // error, no such variable`

Instead of defining a variable, we could use an existing one:

\`\`\`js run let i = 0;

for (i = 0; i &lt; 3; i++) { // use an existing variable alert(i); // 0, 1, 2 }

alert(i); // 3, visible, because declared outside of the loop

### Skipping parts

Any part of `for` can be skipped.

For example, we can omit `begin` if we don’t need to do anything at the loop start.

Like here:

\`\`\`js run let i = 0; // we have i already declared and assigned

for (; i &lt; 3; i++) { // no need for “begin” alert( i ); // 0, 1, 2 } \`\`\`

We can also remove the `step` part:

\`\`\`js run let i = 0;

for (; i &lt; 3;) { alert( i++ ); } \`\`\`

This makes the loop identical to `while (i < 3)`.

We can actually remove everything, creating an infinite loop:

    for (;;) {
      // repeats without limits
    }

Please note that the two `for` semicolons `;` must be present. Otherwise, there would be a syntax error.

## Breaking the loop

Normally, a loop exits when its condition becomes falsy.

But we can force the exit at any time using the special `break` directive.

For example, the loop below asks the user for a series of numbers, “breaking” when no number is entered:

\`\`\`js run let sum = 0;

while (true) {

let value = +prompt(“Enter a number”, ’’);

_!_ if (!value) break; // (_)_ /!\*

sum += value;

} alert( ‘Sum:’ + sum ); \`\`\`

The `break` directive is activated at the line `(*)` if the user enters an empty line or cancels the input. It stops the loop immediately, passing control to the first line after the loop. Namely, `alert`.

The combination “infinite loop + `break` as needed” is great for situations when a loop’s condition must be checked not in the beginning or end of the loop, but in the middle or even in several places of its body.

## Continue to the next iteration \[\#continue\]

The `continue` directive is a “lighter version” of `break`. It doesn’t stop the whole loop. Instead, it stops the current iteration and forces the loop to start a new one (if the condition allows).

We can use it if we’re done with the current iteration and would like to move on to the next one.

The loop below uses `continue` to output only odd values:

\`\`\`js run no-beautify for (let i = 0; i &lt; 10; i++) {

// if true, skip the remaining part of the body *!*if (i % 2 == 0) continue;_/!_

alert(i); // 1, then 3, 5, 7, 9 } \`\`\`

For even values of `i`, the `continue` directive stops executing the body and passes control to the next iteration of `for` (with the next number). So the `alert` is only called for odd values.

\`\`\``smart header="The`continue\` directive helps decrease nesting" A loop that shows odd values could look like this:

\`\`\`js run for (let i = 0; i &lt; 10; i++) {

if (i % 2) { alert( i ); }

}

    From a technical point of view, this is identical to the example above. Surely, we can just wrap the code in an `if` block instead of using `continue`.

    But as a side-effect, this created one more level of nesting (the `alert` call inside the curly braces). If the code inside of `if` is longer than a few lines, that may decrease the overall readability.

\`\`\``warn header="No`break/continue`to the right side of '?'" Please note that syntax constructs that are not expressions cannot be used with the ternary operator`?`. In particular, directives such as`break/continue\` aren’t allowed there.

For example, if we take this code:

    if (i > 5) {
      alert(i);
    } else {
      continue;
    }

…and rewrite it using a question mark:

`js no-beautify (i > 5) ? alert(i) : *!*continue*/!*; // continue isn't allowed here`

…it stops working: there’s a syntax error.

This is just another reason not to use the question mark operator `?` instead of `if`. \`\`\`\`

## Labels for break/continue

Sometimes we need to break out from multiple nested loops at once.

For example, in the code below we loop over `i` and `j`, prompting for the coordinates `(i, j)` from `(0,0)` to `(2,2)`:

\`\`\`js run no-beautify for (let i = 0; i &lt; 3; i++) {

for (let j = 0; j &lt; 3; j++) {

    let input = prompt(`Value at coords (${i},${j})`, '');

    // what if we want to exit from here to Done (below)?

} }

alert(‘Done!’); \`\`\`

We need a way to stop the process if the user cancels the input.

The ordinary `break` after `input` would only break the inner loop. That’s not sufficient – labels, come to the rescue!

A _label_ is an identifier with a colon before a loop:

    labelName: for (...) {
      ...
    }

The `break <labelName>` statement in the loop below breaks out to the label:

\`\`\`js run no-beautify *!*outer:_/!_ for (let i = 0; i &lt; 3; i++) {

for (let j = 0; j &lt; 3; j++) {

    let input = prompt(`Value at coords (${i},${j})`, '');

    // if an empty string or canceled, then break out of both loops
    if (!input) *!*break outer*/!*; // (*)

    // do something with the value...

} } alert(‘Done!’); \`\`\`

In the code above, `break outer` looks upwards for the label named `outer` and breaks out of that loop.

So the control goes straight from `(*)` to `alert('Done!')`.

We can also move the label onto a separate line:

`js no-beautify outer: for (let i = 0; i < 3; i++) { ... }`

The `continue` directive can also be used with a label. In this case, code execution jumps to the next iteration of the labeled loop.

\`\`\`\`warn header=“Labels do not allow to "jump" anywhere” Labels do not allow us to jump into an arbitrary place in the code.

For example, it is impossible to do this:

    break label; // jump to the label below (doesn't work)

    label: for (...)

A `break` directive must be inside a code block. Technically, any labelled code block will do, e.g.:

    label: {
      // ...
      break label; // works
      // ...
    }

…Although, 99.9% of the time `break` used is inside loops, as we’ve seen in the examples above.

A `continue` is only possible from inside a loop. \`\`\`\`

## Summary

We covered 3 types of loops:

- `while` – The condition is checked before each iteration.
- `do..while` – The condition is checked after each iteration.
- `for (;;)` – The condition is checked before each iteration, additional settings available.

To make an “infinite” loop, usually the `while(true)` construct is used. Such a loop, just like any other, can be stopped with the `break` directive.

If we don’t want to do anything in the current iteration and would like to forward to the next one, we can use the `continue` directive.

`break/continue` support labels before the loop. A label is the only way for `break/continue` to escape a nested loop to go to an outer one. \# Lookahead and lookbehind

Sometimes we need to find only those matches for a pattern that are followed or preceded by another pattern.

There’s a special syntax for that, called “lookahead” and “lookbehind”, together referred to as “lookaround”.

For the start, let’s find the price from the string like `subject:1 turkey costs 30€`. That is: a number, followed by `subject:€` sign.

## Lookahead

The syntax is: `pattern:X(?=Y)`, it means “look for `pattern:X`, but match only if followed by `pattern:Y`”. There may be any pattern instead of `pattern:X` and `pattern:Y`.

For an integer number followed by `subject:€`, the regexp will be `pattern:\d+(?=€)`:

\`\`\`js run let str = “1 turkey costs 30€”;

alert( str.match(/(?=€)/) ); // 30, the number 1 is ignored, as it’s not followed by € \`\`\`

Please note: the lookahead is merely a test, the contents of the parentheses `pattern:(?=...)` is not included in the result `match:30`.

When we look for `pattern:X(?=Y)`, the regular expression engine finds `pattern:X` and then checks if there’s `pattern:Y` immediately after it. If it’s not so, then the potential match is skipped, and the search continues.

More complex tests are possible, e.g. `pattern:X(?=Y)(?=Z)` means:

1.  Find `pattern:X`.
2.  Check if `pattern:Y` is immediately after `pattern:X` (skip if isn’t).
3.  Check if `pattern:Z` is also immediately after `pattern:X` (skip if isn’t).
4.  If both tests passed, then the `pattern:X` is a match, otherwise continue searching.

In other words, such pattern means that we’re looking for `pattern:X` followed by `pattern:Y` and `pattern:Z` at the same time.

That’s only possible if patterns `pattern:Y` and `pattern:Z` aren’t mutually exclusive.

For example, `pattern:\d+(?=\s)(?=.*30)` looks for `pattern:\d+` that is followed by a space `pattern:(?=\s)`, and there’s `30` somewhere after it `pattern:(?=.*30)`:

\`\`\`js run let str = “1 turkey costs 30€”;

alert( str.match(/(?=)(?=.\*30)/) ); // 1 \`\`\`

In our string that exactly matches the number `1`.

## Negative lookahead

Let’s say that we want a quantity instead, not a price from the same string. That’s a number `pattern:\d+`, NOT followed by `subject:€`.

For that, a negative lookahead can be applied.

The syntax is: `pattern:X(?!Y)`, it means “search `pattern:X`, but only if not followed by `pattern:Y`”.

\`\`\`js run let str = “2 turkeys cost 60€”;

alert( str.match(/?!€)/g) ); // 2 (the price is not matched) \`\`\`

## Lookbehind

Lookahead allows to add a condition for “what follows”.

Lookbehind is similar, but it looks behind. That is, it allows to match a pattern only if there’s something before it.

The syntax is: - Positive lookbehind: `pattern:(?<=Y)X`, matches `pattern:X`, but only if there’s `pattern:Y` before it. - Negative lookbehind: `pattern:(?<!Y)X`, matches `pattern:X`, but only if there’s no `pattern:Y` before it.

For example, let’s change the price to US dollars. The dollar sign is usually before the number, so to look for `$30` we’ll use `pattern:(?<=\$)\d+` – an amount preceded by `subject:$`:

\`\`\`js run let str = “1 turkey costs $30”;

// the dollar sign is escaped $ alert( str.match(/(?&lt;=$)/) ); // 30 (skipped the sole number) \`\`\`

And, if we need the quantity – a number, not preceded by `subject:$`, then we can use a negative lookbehind `pattern:(?<!\$)\d+`:

\`\`\`js run let str = “2 turkeys cost $60”;

alert( str.match(/(?&lt;!$)/g) ); // 2 (the price is not matched) \`\`\`

## Capturing groups

Generally, the contents inside lookaround parentheses does not become a part of the result.

E.g. in the pattern `pattern:\d+(?=€)`, the `pattern:€` sign doesn’t get captured as a part of the match. That’s natural: we look for a number `pattern:\d+`, while `pattern:(?=€)` is just a test that it should be followed by `subject:€`.

But in some situations we might want to capture the lookaround expression as well, or a part of it. That’s possible. Just wrap that part into additional parentheses.

In the example below the currency sign `pattern:(€|kr)` is captured, along with the amount:

\`\`\`js run let str = “1 turkey costs 30€”; let regexp = /(?=(€|kr))/; // extra parentheses around €|kr

alert( str.match(regexp) ); // 30, € \`\`\`

And here’s the same for lookbehind:

\`\`\`js run let str = “1 turkey costs $30”; let regexp = /(?&lt;=($|£))/;

alert( str.match(regexp) ); // 30, $ \`\`\`

## Summary

Lookahead and lookbehind (commonly referred to as “lookaround”) are useful when we’d like to match something depending on the context before/after it.

For simple regexps we can do the similar thing manually. That is: match everything, in any context, and then filter by context in the loop.

Remember, `str.match` (without flag `pattern:g`) and `str.matchAll` (always) return matches as arrays with `index` property, so we know where exactly in the text it is, and can check the context.

But generally lookaround is more convenient.

Lookaround types:

<table><thead><tr class="header"><th>Pattern</th><th>type</th><th>matches</th></tr></thead><tbody><tr class="odd"><td><code>X(?=Y)</code></td><td>Positive lookahead</td><td><code>pattern:X</code> if followed by <code>pattern:Y</code></td></tr><tr class="even"><td><code>X(?!Y)</code></td><td>Negative lookahead</td><td><code>pattern:X</code> if not followed by <code>pattern:Y</code></td></tr><tr class="odd"><td><code>(?&lt;=Y)X</code></td><td>Positive lookbehind</td><td><code>pattern:X</code> if after <code>pattern:Y</code></td></tr><tr class="even"><td><code>(?&lt;!Y)X</code></td><td>Negative lookbehind</td><td><code>pattern:X</code> if not after <code>pattern:Y</code></td></tr></tbody></table>

# Catastrophic backtracking

Some regular expressions are looking simple, but can execute a veeeeeery long time, and even “hang” the JavaScript engine.

Sooner or later most developers occasionally face such behavior. The typical symptom – a regular expression works fine sometimes, but for certain strings it “hangs”, consuming 100% of CPU.

In such case a web-browser suggests to kill the script and reload the page. Not a good thing for sure.

For server-side JavaScript such a regexp may hang the server process, that’s even worse. So we definitely should take a look at it.

## Example

Let’s say we have a string, and we’d like to check if it consists of words `pattern:\w+` with an optional space `pattern:\s?` after each.

An obvious way to construct a regexp would be to take a word followed by an optional space `pattern:\w+\s?` and then repeat it with `*`.

That leads us to the regexp `pattern:^(\w+\s?)*$`, it specifies zero or more such words, that start at the beginning `pattern:^` and finish at the end `pattern:$` of the line.

In action:

\`\`\`js run let regexp = /^(+?)\*$/;

alert( regexp.test(“A good string”) ); // true alert( regexp.test(“Bad characters: $@\#”) ); // false \`\`\`

The regexp seems to work. The result is correct. Although, on certain strings it takes a lot of time. So long that JavaScript engine “hangs” with 100% CPU consumption.

If you run the example below, you probably won’t see anything, as JavaScript will just “hang”. A web-browser will stop reacting on events, the UI will stop working (most browsers allow only scrolling). After some time it will suggest to reload the page. So be careful with this:

\`\`\`js run let regexp = /^(+?)\*$/; let str = “An input string that takes a long time or even makes this regexp hang!”;

// will take a very long time alert( regexp.test(str) ); \`\`\`

To be fair, let’s note that some regular expression engines can handle such a search effectively, for example V8 engine version starting from 8.8 can do that (so Google Chrome 88 doesn’t hang here), while Firefox browser does hang.

## Simplified example

What’s the matter? Why does the regular expression hang?

To understand that, let’s simplify the example: remove spaces `pattern:\s?`. Then it becomes `pattern:^(\w+)*$`.

And, to make things more obvious, let’s replace `pattern:\w` with `pattern:\d`. The resulting regular expression still hangs, for instance:

\`\`\`js run let regexp = /^()\*$/;

let str = “012345678901234567890123456789z”;

// will take a very long time (careful!) alert( regexp.test(str) );

    So what's wrong with the regexp?

    First, one may notice that the regexp `pattern:(\d+)*` is a little bit strange. The quantifier `pattern:*` looks extraneous. If we want a number, we can use `pattern:\d+`.

    Indeed, the regexp is artificial; we got it by simplifying the previous example. But the reason why it is slow is the same. So let's understand it, and then the previous example will become obvious.

    What happens during the search of `pattern:^(\d+)*$` in the line `subject:123456789z` (shortened a bit for clarity, please note a non-digit character `subject:z` at the end, it's important), why does it take so long?

    Here's what the regexp engine does:

    1. First, the regexp engine tries to find the content of the parentheses: the number `pattern:\d+`. The plus `pattern:+` is greedy by default, so it consumes all digits:

        ```
        \d+.......
        (123456789)z
        ```

        After all digits are consumed, `pattern:\d+` is considered found (as `match:123456789`).

        Then the star quantifier `pattern:(\d+)*` applies. But there are no more digits in the text, so the star doesn't give anything.

        The next character in the pattern is the string end `pattern:$`. But in the text we have `subject:z` instead, so there's no match:

        ```
                   X
        \d+........$
        (123456789)z
        ```

    2. As there's no match, the greedy quantifier `pattern:+` decreases the count of repetitions, backtracks one character back.

        Now `pattern:\d+` takes all digits except the last one (`match:12345678`):
        ```
        \d+.......
        (12345678)9z
        ```
    3. Then the engine tries to continue the search from the next position (right after `match:12345678`).

        The star `pattern:(\d+)*` can be applied -- it gives one more match of `pattern:\d+`, the number `match:9`:

        ```

        \d+.......\d+
        (12345678)(9)z
        ```

        The engine tries to match `pattern:$` again, but fails, because it meets `subject:z` instead:

        ```
                     X
        \d+.......\d+
        (12345678)(9)z
        ```


    4. There's no match, so the engine will continue backtracking, decreasing the number of repetitions. Backtracking generally works like this: the last greedy quantifier decreases the number of repetitions until it reaches the minimum. Then the previous greedy quantifier decreases, and so on.

        All possible combinations are attempted. Here are their examples.

        The first number `pattern:\d+` has 7 digits, and then a number of 2 digits:

        ```
                     X
        \d+......\d+
        (1234567)(89)z
        ```

        The first number has 7 digits, and then two numbers of 1 digit each:

        ```
                       X
        \d+......\d+\d+
        (1234567)(8)(9)z
        ```

        The first number has 6 digits, and then a number of 3 digits:

        ```
                     X
        \d+.......\d+
        (123456)(789)z
        ```

        The first number has 6 digits, and then 2 numbers:

        ```
                       X
        \d+.....\d+ \d+
        (123456)(78)(9)z
        ```

        ...And so on.


    There are many ways to split a sequence of digits `123456789` into numbers. To be precise, there are <code>2<sup>n</sup>-1</code>, where `n` is the length of the sequence.

    - For `123456789` we have `n=9`, that gives 511 combinations.
    - For a longer sequence with `n=20` there are about one million (1048575) combinations.
    - For `n=30` - a thousand times more (1073741823 combinations).

    Trying each of them is exactly the reason why the search takes so long.

    ## Back to words and strings

    The similar thing happens in our first example, when we look for words by pattern `pattern:^(\w+\s?)*$` in the string `subject:An input that hangs!`.

    The reason is that a word can be represented as one `pattern:\w+` or many:

(input) (inpu)(t) (inp)(u)(t) (in)(p)(ut) … \`\`\`

For a human, it’s obvious that there may be no match, because the string ends with an exclamation sign `!`, but the regular expression expects a wordly character `pattern:\w` or a space `pattern:\s` at the end. But the engine doesn’t know that.

It tries all combinations of how the regexp `pattern:(\w+\s?)*` can “consume” the string, including variants with spaces `pattern:(\w+\s)*` and without them `pattern:(\w+)*` (because spaces `pattern:\s?` are optional). As there are many such combinations (we’ve seen it with digits), the search takes a lot of time.

What to do?

Should we turn on the lazy mode?

Unfortunately, that won’t help: if we replace `pattern:\w+` with `pattern:\w+?`, the regexp will still hang. The order of combinations will change, but not their total count.

Some regular expression engines have tricky tests and finite automations that allow to avoid going through all combinations or make it much faster, but most engines don’t, and it doesn’t always help.

## How to fix?

There are two main approaches to fixing the problem.

The first is to lower the number of possible combinations.

Let’s make the space non-optional by rewriting the regular expression as `pattern:^(\w+\s)*\w*$` - we’ll look for any number of words followed by a space `pattern:(\w+\s)*`, and then (optionally) a final word `pattern:\w*`.

This regexp is equivalent to the previous one (matches the same) and works well:

\`\`\`js run let regexp = /^(+)\*$/; let str = “An input string that takes a long time or even makes this regex hang!”;

alert( regexp.test(str) ); // false

    Why did the problem disappear?

    That's because now the space is mandatory.

    The previous regexp, if we omit the space, becomes `pattern:(\w+)*`, leading to many combinations of `\w+` within a single word

    So `subject:input` could be matched as two repetitions of `pattern:\w+`, like this:

\+ + (inp)(ut)

    The new pattern is different: `pattern:(\w+\s)*` specifies repetitions of words followed by a space! The `subject:input` string can't be matched as two repetitions of `pattern:\w+\s`, because the space is mandatory.

    The time needed to try a lot of (actually most of) combinations is now saved.

    ## Preventing backtracking

    It's not always convenient to rewrite a regexp though. In the example above it was easy, but it's not always obvious how to do it.

    Besides, a rewritten regexp is usually more complex, and that's not good. Regexps are complex enough without extra efforts.

    Luckily, there's an alternative approach. We can forbid backtracking for the quantifier.

    The root of the problem is that the regexp engine tries many combinations that are obviously wrong for a human.

    E.g. in the regexp `pattern:(\d+)*$` it's obvious for a human, that `pattern:+` shouldn't backtrack. If we replace one `pattern:\d+` with two separate `pattern:\d+\d+`, nothing changes:

…….. (123456789)!

……. (1234)(56789)! \`\`\`

And in the original example `pattern:^(\w+\s?)*$` we may want to forbid backtracking in `pattern:\w+`. That is: `pattern:\w+` should match a whole word, with the maximal possible length. There’s no need to lower the repetitions count in `pattern:\w+` or to split it into two words `pattern:\w+\w+` and so on.

Modern regular expression engines support possessive quantifiers for that. Regular quantifiers become possessive if we add `pattern:+` after them. That is, we use `pattern:\d++` instead of `pattern:\d+` to stop `pattern:+` from backtracking.

Possessive quantifiers are in fact simpler than “regular” ones. They just match as many as they can, without any backtracking. The search process without bracktracking is simpler.

There are also so-called “atomic capturing groups” - a way to disable backtracking inside parentheses.

…But the bad news is that, unfortunately, in JavaScript they are not supported.

We can emulate them though using a “lookahead transform”.

### Lookahead to the rescue!

So we’ve come to real advanced topics. We’d like a quantifier, such as `pattern:+` not to backtrack, because sometimes backtracking makes no sense.

The pattern to take as many repetitions of `pattern:\w` as possible without backtracking is: `pattern:(?=(\w+))\1`. Of course, we could take another pattern instead of `pattern:\w`.

That may seem odd, but it’s actually a very simple transform.

Let’s decipher it:

- Lookahead `pattern:?=` looks forward for the longest word `pattern:\w+` starting at the current position.
- The contents of parentheses with `pattern:?=...` isn’t memorized by the engine, so wrap `pattern:\w+` into parentheses. Then the engine will memorize their contents
- …And allow us to reference it in the pattern as `pattern:\1`.

That is: we look ahead - and if there’s a word `pattern:\w+`, then match it as `pattern:\1`.

Why? That’s because the lookahead finds a word `pattern:\w+` as a whole and we capture it into the pattern with `pattern:\1`. So we essentially implemented a possessive plus `pattern:+` quantifier. It captures only the whole word `pattern:\w+`, not a part of it.

For instance, in the word `subject:JavaScript` it may not only match `match:Java`, but leave out `match:Script` to match the rest of the pattern.

Here’s the comparison of two patterns:

`js run alert( "JavaScript".match(/\w+Script/)); // JavaScript alert( "JavaScript".match(/(?=(\w+))\1Script/)); // null`

1.  In the first variant `pattern:\w+` first captures the whole word `subject:JavaScript` but then `pattern:+` backtracks character by character, to try to match the rest of the pattern, until it finally succeeds (when `pattern:\w+` matches `match:Java`).
2.  In the second variant `pattern:(?=(\w+))` looks ahead and finds the word `subject:JavaScript`, that is included into the pattern as a whole by `pattern:\1`, so there remains no way to find `subject:Script` after it.

We can put a more complex regular expression into `pattern:(?=(\w+))\1` instead of `pattern:\w`, when we need to forbid backtracking for `pattern:+` after it.

    There's more about the relation between possessive quantifiers and lookahead in articles [Regex: Emulate Atomic Grouping (and Possessive Quantifiers) with LookAhead](http://instanceof.me/post/52245507631/regex-emulate-atomic-grouping-with-lookahead) and [Mimicking Atomic Groups](http://blog.stevenlevithan.com/archives/mimic-atomic-groups).

Let’s rewrite the first example using lookahead to prevent backtracking:

\`\`\`js run let regexp = /^((?=(+))\\2?)\*$/;

alert( regexp.test(“A good string”) ); // true

let str = “An input string that takes a long time or even makes this regex hang!”;

alert( regexp.test(str) ); // false, works and fast! \`\`\`

Here `pattern:\2` is used instead of `pattern:\1`, because there are additional outer parentheses. To avoid messing up with the numbers, we can give the parentheses a name, e.g. `pattern:(?<word>\w+)`.

\`\`\`js run // parentheses are named ?, referenced as word&gt; let regexp = /^((?=(?+))word&gt;?)\*$/;

let str = “An input string that takes a long time or even makes this regex hang!”;

alert( regexp.test(str) ); // false

alert( regexp.test(“A correct string”) ); // true \`\`\`

The problem described in this article is called “catastrophic backtracking”.

We covered two ways how to solve it: - Rewrite the regexp to lower the possible combinations count. - Prevent backtracking.

# Sticky flag “y”, searching at position

The flag `pattern:y` allows to perform the search at the given position in the source string.

To grasp the use case of `pattern:y` flag, and better understand the ways of regexps, let’s explore a practical example.

One of common tasks for regexps is “lexical analysis”: we get a text, e.g. in a programming language, and need to find its structural elements. For instance, HTML has tags and attributes, JavaScript code has functions, variables, and so on.

Writing lexical analyzers is a special area, with its own tools and algorithms, so we don’t go deep in there, but there’s a common task: to read something at the given position.

E.g. we have a code string `subject:let varName = "value"`, and we need to read the variable name from it, that starts at position `4`.

We’ll look for variable name using regexp `pattern:\w+`. Actually, JavaScript variable names need a bit more complex regexp for accurate matching, but here it doesn’t matter.

- A call to `str.match(/\w+/)` will find only the first word in the line (`let`). That’s not it.
- We can add the flag `pattern:g`. But then the call `str.match(/\w+/g)` will look for all words in the text, while we need one word at position `4`. Again, not what we need.

**So, how to search for a regexp exactly at the given position?**

Let’s try using method `regexp.exec(str)`.

For a `regexp` without flags `pattern:g` and `pattern:y`, this method looks only for the first match, it works exactly like `str.match(regexp)`.

…But if there’s flag `pattern:g`, then it performs the search in `str`, starting from position stored in the `regexp.lastIndex` property. And, if it finds a match, then sets `regexp.lastIndex` to the index immediately after the match.

In other words, `regexp.lastIndex` serves as a starting point for the search, that each `regexp.exec(str)` call resets to the new value (“after the last match”). That’s only if there’s `pattern:g` flag, of course.

So, successive calls to `regexp.exec(str)` return matches one after another.

Here’s an example of such calls:

\`\`\`js run let str = ‘let varName’; // Let’s find all words in this string let regexp = /+/g;

alert(regexp.lastIndex); // 0 (initially lastIndex=0)

let word1 = regexp.exec(str); alert(word1\[0\]); // let (1st word) alert(regexp.lastIndex); // 3 (position after the match)

let word2 = regexp.exec(str); alert(word2\[0\]); // varName (2nd word) alert(regexp.lastIndex); // 11 (position after the match)

let word3 = regexp.exec(str); alert(word3); // null (no more matches) alert(regexp.lastIndex); // 0 (resets at search end) \`\`\`

We can get all matches in the loop:

\`\`\`js run let str = ‘let varName’; let regexp = /+/g;

let result;

while (result = regexp.exec(str)) { alert( `Found ${result[0]} at position ${result.index}` ); // Found let at position 0, then // Found varName at position 4 } \`\`\`

Such use of `regexp.exec` is an alternative to method `str.matchAll`, with a bit more control over the process.

Let’s go back to our task.

We can manually set `lastIndex` to `4`, to start the search from the given position!

Like this:

\`\`\`js run let str = ‘let varName = “value”’;

let regexp = /+/g; // without flag “g”, property lastIndex is ignored

_!_ regexp.lastIndex = 4; _/!_

let word = regexp.exec(str); alert(word); // varName \`\`\`

Hooray! Problem solved!

We performed a search of `pattern:\w+`, starting from position `regexp.lastIndex = 4`.

The result is correct.

…But wait, not so fast.

Please note: the `regexp.exec` call starts searching at position `lastIndex` and then goes further. If there’s no word at position `lastIndex`, but it’s somewhere after it, then it will be found:

\`\`\`js run let str = ‘let varName = “value”’;

let regexp = /+/g;

_!_ // start the search from position 3 regexp.lastIndex = 3; _/!_

let word = regexp.exec(str); // found the match at position 4 alert(word\[0\]); // varName alert(word.index); // 4 \`\`\`

For some tasks, including the lexical analysis, that’s just wrong. We need to find a match exactly at the given position at the text, not somewhere after it. And that’s what the flag `y` is for.

**The flag `pattern:y` makes `regexp.exec` to search exactly at position `lastIndex`, not “starting from” it.**

Here’s the same search with flag `pattern:y`:

\`\`\`js run let str = ‘let varName = “value”’;

let regexp = /+/y;

regexp.lastIndex = 3; alert( regexp.exec(str) ); // null (there’s a space at position 3, not a word)

regexp.lastIndex = 4; alert( regexp.exec(str) ); // varName (word at position 4) \`\`\`

As we can see, regexp `pattern:/\w+/y` doesn’t match at position `3` (unlike the flag `pattern:g`), but matches at position `4`.

Not only that’s what we need, there’s an important performance gain when using flag `pattern:y`.

Imagine, we have a long text, and there are no matches in it, at all. Then a search with flag `pattern:g` will go till the end of the text and find nothing, and this will take significantly more time than the search with flag `pattern:y`, that checks only the exact position.

In tasks like lexical analysis, there are usually many searches at an exact position, to check what we have there. Using flag `pattern:y` is the key for correct implementations and a good performance. \# Methods of RegExp and String

In this article we’ll cover various methods that work with regexps in-depth.

## str.match(regexp)

The method `str.match(regexp)` finds matches for `regexp` in the string `str`.

It has 3 modes:

1.  If the `regexp` doesn’t have flag `pattern:g`, then it returns the first match as an array with capturing groups and properties `index` (position of the match), `input` (input string, equals `str`):

    \`\`\`js run let str = “I love JavaScript”;

    let result = str.match(/Java(Script)/);

    alert( result\[0\] ); // JavaScript (full match) alert( result\[1\] ); // Script (first capturing group) alert( result.length ); // 2

    // Additional information: alert( result.index ); // 7 (match position) alert( result.input ); // I love JavaScript (source string) \`\`\`

2.  If the `regexp` has flag `pattern:g`, then it returns an array of all matches as strings, without capturing groups and other details. \`\`\`js run let str = “I love JavaScript”;

    let result = str.match(/Java(Script)/g);

    alert( result\[0\] ); // JavaScript alert( result.length ); // 1 \`\`\`

3.  If there are no matches, no matter if there’s flag `pattern:g` or not, `null` is returned.

    That’s an important nuance. If there are no matches, we don’t get an empty array, but `null`. It’s easy to make a mistake forgetting about it, e.g.:

    \`\`\`js run let str = “I love JavaScript”;

    let result = str.match(/HTML/);

    alert(result); // null alert(result.length); // Error: Cannot read property ‘length’ of null \`\`\`

    If we want the result to be an array, we can write like this:

        let result = str.match(regexp) || [];

## str.matchAll(regexp)

\[recent browser=“new”\]

The method `str.matchAll(regexp)` is a “newer, improved” variant of `str.match`.

It’s used mainly to search for all matches with all groups.

There are 3 differences from `match`:

1.  It returns an iterable object with matches instead of an array. We can make a regular array from it using `Array.from`.
2.  Every match is returned as an array with capturing groups (the same format as `str.match` without flag `pattern:g`).
3.  If there are no results, it returns not `null`, but an empty iterable object.

Usage example:

\`\`\`js run let str = ’

# Hello, world!

’; let regexp = /&lt;(.\*?)&gt;/g;

let matchAll = str.matchAll(regexp);

alert(matchAll); // \[object RegExp String Iterator\], not array, but an iterable

matchAll = Array.from(matchAll); // array now

let firstMatch = matchAll\[0\]; alert( firstMatch\[0\] ); //

# alert( firstMatch\[1\] ); // h1 alert( firstMatch.index ); // 0 alert( firstMatch.input ); //

# Hello, world!

\`\`\`

If we use `for..of` to loop over `matchAll` matches, then we don’t need `Array.from` any more.

## str.split(regexp|substr, limit)

Splits the string using the regexp (or a substring) as a delimiter.

We can use `split` with strings, like this:

`js run alert('12-34-56'.split('-')) // array of ['12', '34', '56']`

But we can split by a regular expression, the same way:

`js run alert('12, 34, 56'.split(/,\s*/)) // array of ['12', '34', '56']`

## str.search(regexp)

The method `str.search(regexp)` returns the position of the first match or `-1` if none found:

\`\`\`js run let str = “A drop of ink may make a million think”;

alert( str.search( /ink/i ) ); // 10 (first match position) \`\`\`

**The important limitation: `search` only finds the first match.**

If we need positions of further matches, we should use other means, such as finding them all with `str.matchAll(regexp)`.

## str.replace(str|regexp, str|func)

This is a generic method for searching and replacing, one of most useful ones. The swiss army knife for searching and replacing.

We can use it without regexps, to search and replace a substring:

`js run // replace a dash by a colon alert('12-34-56'.replace("-", ":")) // 12:34-56`

There’s a pitfall though.

**When the first argument of `replace` is a string, it only replaces the first match.**

You can see that in the example above: only the first `"-"` is replaced by `":"`.

To find all hyphens, we need to use not the string `"-"`, but a regexp `pattern:/-/g`, with the obligatory `pattern:g` flag:

`js run // replace all dashes by a colon alert( '12-34-56'.replace( *!*/-/g*/!*, ":" ) ) // 12:34:56`

The second argument is a replacement string. We can use special characters in it:

<table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>Symbols</th><th>Action in the replacement string</th></tr></thead><tbody><tr class="odd"><td><code>$&amp;</code></td><td>inserts the whole match</td></tr><tr class="even"><td><code>$&amp;#096;&lt;/code&gt;|inserts a part of the string before the match| |`$’|inserts a part of the string after the match| |</code><span class="math inline">$n`|if `n` is a 1-2 digit number, inserts the contents of n-th capturing group, for details see [](info:regexp-groups)| |`$</span><code>|inserts the contents of the parentheses with the given</code>name<code>, for details see [](info:regexp-groups)| |</code>$<span class="math inline">$`|inserts character `$</span>`</td><td></td></tr></tbody></table>

For instance:

\`\`\`js run let str = “John Smith”;

// swap first and last name alert(str.replace(/(john) (smith)/i, ‘$2, $1’)) // Smith, John \`\`\`

**For situations that require “smart” replacements, the second argument can be a function.**

It will be called for each match, and the returned value will be inserted as a replacement.

The function is called with arguments `func(match, p1, p2, ..., pn, offset, input, groups)`:

1.  `match` – the match,
2.  `p1, p2, ..., pn` – contents of capturing groups (if there are any),
3.  `offset` – position of the match,
4.  `input` – the source string,
5.  `groups` – an object with named groups.

If there are no parentheses in the regexp, then there are only 3 arguments: `func(str, offset, input)`.

For example, let’s uppercase all matches:

\`\`\`js run let str = “html and css”;

let result = str.replace(/html|css/gi, str =&gt; str.toUpperCase());

alert(result); // HTML and CSS \`\`\`

Replace each match by its position in the string:

`js run alert("Ho-Ho-ho".replace(/ho/gi, (match, offset) => offset)); // 0-3-6`

In the example below there are two parentheses, so the replacement function is called with 5 arguments: the first is the full match, then 2 parentheses, and after it (not used in the example) the match position and the source string:

\`\`\`js run let str = “John Smith”;

let result = str.replace(/(+) (+)/, (match, name, surname) =&gt; `${surname}, ${name}`);

alert(result); // Smith, John \`\`\`

If there are many groups, it’s convenient to use rest parameters to access them:

\`\`\`js run let str = “John Smith”;

let result = str.replace(/(+) (+)/, (…match) =&gt; `${match[2]}, ${match[1]}`);

alert(result); // Smith, John \`\`\`

Or, if we’re using named groups, then `groups` object with them is always the last, so we can obtain it like this:

\`\`\`js run let str = “John Smith”;

let result = str.replace(/(?+) (?+)/, (…match) =&gt; { let groups = match.pop();

return `${groups.surname}, ${groups.name}`; });

alert(result); // Smith, John \`\`\`

Using a function gives us the ultimate replacement power, because it gets all the information about the match, has access to outer variables and can do everything.

## str.replaceAll(str|regexp, str|func)

This method is essentially the same as `str.replace`, with two major differences:

1.  If the first argument is a string, it replaces _all occurences_ of the string, while `replace` replaces only the _first occurence_.
2.  If the first argument is a regular expression without the `g` flag, there’ll be an error. With `g` flag, it works the same as `replace`.

The main use case for `replaceAll` is replacing all occurences of a string.

Like this:

`js run // replace all dashes by a colon alert('12-34-56'.replaceAll("-", ":")) // 12:34:56`

## regexp.exec(str)

The method `regexp.exec(str)` method returns a match for `regexp` in the string `str`. Unlike previous methods, it’s called on a regexp, not on a string.

It behaves differently depending on whether the regexp has flag `pattern:g`.

If there’s no `pattern:g`, then `regexp.exec(str)` returns the first match exactly as `str.match(regexp)`. This behavior doesn’t bring anything new.

But if there’s flag `pattern:g`, then: - A call to `regexp.exec(str)` returns the first match and saves the position immediately after it in the property `regexp.lastIndex`. - The next such call starts the search from position `regexp.lastIndex`, returns the next match and saves the position after it in `regexp.lastIndex`. - …And so on. - If there are no matches, `regexp.exec` returns `null` and resets `regexp.lastIndex` to `0`.

So, repeated calls return all matches one after another, using property `regexp.lastIndex` to keep track of the current search position.

In the past, before the method `str.matchAll` was added to JavaScript, calls of `regexp.exec` were used in the loop to get all matches with groups:

\`\`\`js run let str = ‘More about JavaScript at https://javascript.info’; let regexp = /javascript/ig;

let result;

while (result = regexp.exec(str)) { alert( `Found ${result[0]} at position ${result.index}` ); // Found JavaScript at position 11, then // Found javascript at position 33 } \`\`\`

This works now as well, although for newer browsers `str.matchAll` is usually more convenient.

**We can use `regexp.exec` to search from a given position by manually setting `lastIndex`.**

For instance:

\`\`\`js run let str = ‘Hello, world!’;

let regexp = /+/g; // without flag “g”, lastIndex property is ignored regexp.lastIndex = 5; // search from 5th position (from the comma)

alert( regexp.exec(str) ); // world \`\`\`

If the regexp has flag `pattern:y`, then the search will be performed exactly at the position `regexp.lastIndex`, not any further.

Let’s replace flag `pattern:g` with `pattern:y` in the example above. There will be no matches, as there’s no word at position `5`:

\`\`\`js run let str = ‘Hello, world!’;

let regexp = /+/y; regexp.lastIndex = 5; // search exactly at position 5

alert( regexp.exec(str) ); // null \`\`\`

That’s convenient for situations when we need to “read” something from the string by a regexp at the exact position, not somewhere further.

## regexp.test(str)

The method `regexp.test(str)` looks for a match and returns `true/false` whether it exists.

For instance:

\`\`\`js run let str = “I love JavaScript”;

// these two tests do the same alert( _!_/love/i*/!*.test(str) ); // true alert( str.search(_!_/love/i*/!*) != -1 ); // true \`\`\`

An example with the negative answer:

\`\`\`js run let str = “Bla-bla-bla”;

alert( _!_/love/i*/!*.test(str) ); // false alert( str.search(_!_/love/i*/!*) != -1 ); // false \`\`\`

If the regexp has flag `pattern:g`, then `regexp.test` looks from `regexp.lastIndex` property and updates this property, just like `regexp.exec`.

So we can use it to search from a given position:

\`\`\`js run let regexp = /love/gi;

let str = “I love JavaScript”;

// start the search from position 10: regexp.lastIndex = 10; alert( regexp.test(str) ); // false (no match) \`\`\`

\`\`\``warn header="Same global regexp tested repeatedly on different sources may fail" If we apply the same global regexp to different inputs, it may lead to wrong result, because`regexp.test`call advances`regexp.lastIndex\` property, so the search in another string may start from non-zero position.

For instance, here we call `regexp.test` twice on the same text, and the second time fails:

\`\`\`js run let regexp = /javascript/g; // (regexp just created: regexp.lastIndex=0)

alert( regexp.test(“javascript”) ); // true (regexp.lastIndex=10 now) alert( regexp.test(“javascript”) ); // false

    That's exactly because `regexp.lastIndex` is non-zero in the second test.

    To work around that, we can set `regexp.lastIndex = 0` before each search. Or instead of calling methods on regexp, use string methods `str.match/search/...`, they don't use `lastIndex`.

# The “switch” statement

A `switch` statement can replace multiple `if` checks.

It gives a more descriptive way to compare a value with multiple variants.

## The syntax

The `switch` has one or more `case` blocks and an optional default.

It looks like this:

\`\`\`js no-beautify switch(x) { case ‘value1’: // if (x === ‘value1’) … \[break\]

case ‘value2’: // if (x === ‘value2’) … \[break\]

default: … \[break\] } \`\`\`

- The value of `x` is checked for a strict equality to the value from the first `case` (that is, `value1`) then to the second (`value2`) and so on.
- If the equality is found, `switch` starts to execute the code starting from the corresponding `case`, until the nearest `break` (or until the end of `switch`).
- If no case is matched then the `default` code is executed (if it exists).

## An example

An example of `switch` (the executed code is highlighted):

\`\`\`js run let a = 2 + 2;

switch (a) { case 3: alert( ‘Too small’ ); break; _!_ case 4: alert( ‘Exactly!’ ); break; _/!_ case 5: alert( ‘Too big’ ); break; default: alert( “I don’t know such values” ); } \`\`\`

Here the `switch` starts to compare `a` from the first `case` variant that is `3`. The match fails.

Then `4`. That’s a match, so the execution starts from `case 4` until the nearest `break`.

**If there is no `break` then the execution continues with the next `case` without any checks.**

An example without `break`:

\`\`\`js run let a = 2 + 2;

switch (a) { case 3: alert( ‘Too small’ ); _!_ case 4: alert( ‘Exactly!’ ); case 5: alert( ‘Too big’ ); default: alert( “I don’t know such values” ); _/!_ } \`\`\`

In the example above we’ll see sequential execution of three `alert`s:

    alert( 'Exactly!' );
    alert( 'Too big' );
    alert( "I don't know such values" );

\`\`\``smart header="Any expression can be a`switch/case`argument" Both`switch`and`case\` allow arbitrary expressions.

For example:

\`\`\`js run let a = “1”; let b = 0;

switch (+a) { _!_ case b + 1: alert(“this runs, because +a is 1, exactly equals b+1”); break; _/!_

default: alert(“this doesn’t run”); }

    Here `+a` gives `1`, that's compared with `b + 1` in `case`, and the corresponding code is executed.

## Grouping of “case”

Several variants of `case` which share the same code can be grouped.

For example, if we want the same code to run for `case 3` and `case 5`:

\`\`\`js run no-beautify let a = 3;

switch (a) { case 4: alert(‘Right!’); break;

_!_ case 3: // (_) grouped two cases case 5: alert(‘Wrong!’); alert(“Why don’t you take a math class?”); break;_ /!\*

default: alert(‘The result is strange. Really.’); } \`\`\`

Now both `3` and `5` show the same message.

The ability to “group” cases is a side-effect of how `switch/case` works without `break`. Here the execution of `case 3` starts from the line `(*)` and goes through `case 5`, because there’s no `break`.

## Type matters

Let’s emphasize that the equality check is always strict. The values must be of the same type to match.

For example, let’s consider the code:

\`\`\`js run let arg = prompt(“Enter a value?”); switch (arg) { case ‘0’: case ‘1’: alert( ‘One or zero’ ); break;

case ‘2’: alert( ‘Two’ ); break;

case 3: alert( ‘Never executes!’ ); break; default: alert( ‘An unknown value’ ); } \`\`\`

1.  For `0`, `1`, the first `alert` runs.
2.  For `2` the second `alert` runs.
3.  But for `3`, the result of the `prompt` is a string `"3"`, which is not strictly equal `===` to the number `3`. So we’ve got a dead code in `case 3`! The `default` variant will execute. \# Functions

Quite often we need to perform a similar action in many places of the script.

For example, we need to show a nice-looking message when a visitor logs in, logs out and maybe somewhere else.

Functions are the main “building blocks” of the program. They allow the code to be called many times without repetition.

We’ve already seen examples of built-in functions, like `alert(message)`, `prompt(message, default)` and `confirm(question)`. But we can create functions of our own as well.

## Function Declaration

To create a function we can use a _function declaration_.

It looks like this:

    function showMessage() {
      alert( 'Hello everyone!' );
    }

The `function` keyword goes first, then goes the _name of the function_, then a list of _parameters_ between the parentheses (comma-separated, empty in the example above) and finally the code of the function, also named “the function body”, between curly braces.

    function name(parameters) {
      ...body...
    }

Our new function can be called by its name: `showMessage()`.

For instance:

\`\`\`js run function showMessage() { alert( ‘Hello everyone!’ ); }

_!_ showMessage(); showMessage(); _/!_ \`\`\`

The call `showMessage()` executes the code of the function. Here we will see the message two times.

This example clearly demonstrates one of the main purposes of functions: to avoid code duplication.

If we ever need to change the message or the way it is shown, it’s enough to modify the code in one place: the function which outputs it.

## Local variables

A variable declared inside a function is only visible inside that function.

For example:

\`\`\`js run function showMessage() { _!_ let message = “Hello, I’m JavaScript!”; // local variable _/!_

alert( message ); }

showMessage(); // Hello, I’m JavaScript!

alert( message ); // &lt;– Error! The variable is local to the function \`\`\`

## Outer variables

A function can access an outer variable as well, for example:

\`\`\`js run no-beautify let *!*userName*/!* = ‘John’;

function showMessage() { let message = ‘Hello,’ + *!*userName*/!*; alert(message); }

showMessage(); // Hello, John \`\`\`

The function has full access to the outer variable. It can modify it as well.

For instance:

\`\`\`js run let *!*userName*/!* = ‘John’;

function showMessage() { *!*userName*/!* = “Bob”; // (1) changed the outer variable

let message = ‘Hello,’ + *!*userName*/!*; alert(message); }

alert( userName ); // *!*John*/!* before the function call

showMessage();

alert( userName ); // *!*Bob*/!*, the value was modified by the function \`\`\`

The outer variable is only used if there’s no local one.

If a same-named variable is declared inside the function then it _shadows_ the outer one. For instance, in the code below the function uses the local `userName`. The outer one is ignored:

\`\`\`js run let userName = ‘John’;

function showMessage() { _!_ let userName = “Bob”; // declare a local variable _/!_

let message = ‘Hello,’ + userName; // *!*Bob*/!* alert(message); }

// the function will create and use its own userName showMessage();

alert( userName ); // *!*John*/!*, unchanged, the function did not access the outer variable \`\`\`

\`\``smart header="Global variables" Variables declared outside of any function, such as the outer`userName\` in the code above, are called _global_.

Global variables are visible from any function (unless shadowed by locals).

It’s a good practice to minimize the use of global variables. Modern code has few or no globals. Most variables reside in their functions. Sometimes though, they can be useful to store project-level data. \`\`\`

## Parameters

We can pass arbitrary data to functions using parameters (also called _function arguments_) .

In the example below, the function has two parameters: `from` and `text`.

\`\`\`js run function showMessage(*!*from, text*/!*) { // arguments: from, text alert(from + ‘:’ + text); }

_!_ showMessage(‘Ann’, ‘Hello!’); // Ann: Hello! (\*) showMessage(‘Ann’, “What’s up?”); // Ann: What’s up? (\*\*) _/!_ \`\`\`

When the function is called in lines `(*)` and `(**)`, the given values are copied to local variables `from` and `text`. Then the function uses them.

Here’s one more example: we have a variable `from` and pass it to the function. Please note: the function changes `from`, but the change is not seen outside, because a function always gets a copy of the value:

\`\`\`js run function showMessage(from, text) {

_!_ from = ‘_’ + from + ’_’; // make “from” look nicer _/!_

alert( from + ‘:’ + text ); }

let from = “Ann”;

showMessage(from, “Hello”); // _Ann_: Hello

// the value of “from” is the same, the function modified a local copy alert( from ); // Ann \`\`\`

## Default values

If a parameter is not provided, then its value becomes `undefined`.

For instance, the aforementioned function `showMessage(from, text)` can be called with a single argument:

    showMessage("Ann");

That’s not an error. Such a call would output `"*Ann*: undefined"`. There’s no `text`, so it’s assumed that `text === undefined`.

If we want to use a “default” `text` in this case, then we can specify it after `=`:

\`\`\`js run function showMessage(from, *!*text = “no text given”_/!_) { alert( from + “:” + text ); }

showMessage(“Ann”); // Ann: no text given \`\`\`

Now if the `text` parameter is not passed, it will get the value `"no text given"`

Here `"no text given"` is a string, but it can be a more complex expression, which is only evaluated and assigned if the parameter is missing. So, this is also possible:

`js run function showMessage(from, text = anotherFunction()) { // anotherFunction() only executed if no text given // its result becomes the value of text }`

\`\`\`smart header=“Evaluation of default parameters” In JavaScript, a default parameter is evaluated every time the function is called without the respective parameter.

In the example above, `anotherFunction()` is called every time `showMessage()` is called without the `text` parameter. \`\`\`

### Alternative default parameters

Sometimes it makes sense to set default values for parameters not in the function declaration, but at a later stage, during its execution.

To check for an omitted parameter, we can compare it with `undefined`:

\`\`\`js run function showMessage(text) { _!_ if (text === undefined) { text = ‘empty message’; } _/!_

alert(text); }

showMessage(); // empty message \`\`\`

…Or we could use the `||` operator:

    // if text parameter is omitted or "" is passed, set it to 'empty'
    function showMessage(text) {
      text = text || 'empty';
      ...
    }

Modern JavaScript engines support the [nullish coalescing operator](info:nullish-coalescing-operator) `??`, it’s better when falsy values, such as `0`, are considered regular:

\`\`\`js run // if there’s no “count” parameter, show “unknown” function showCount(count) { alert(count ?? “unknown”); }

showCount(0); // 0 showCount(null); // unknown showCount(); // unknown \`\`\`

## Returning a value

A function can return a value back into the calling code as the result.

The simplest example would be a function that sums two values:

\`\`\`js run no-beautify function sum(a, b) { *!*return*/!* a + b; }

let result = sum(1, 2); alert( result ); // 3 \`\`\`

The directive `return` can be in any place of the function. When the execution reaches it, the function stops, and the value is returned to the calling code (assigned to `result` above).

There may be many occurrences of `return` in a single function. For instance:

\`\`\`js run function checkAge(age) { if (age &gt;= 18) { _!_ return true; _/!_ } else { _!_ return confirm(‘Do you have permission from your parents?’); _/!_ } }

let age = prompt(‘How old are you?’, 18);

if ( checkAge(age) ) { alert( ‘Access granted’ ); } else { alert( ‘Access denied’ ); } \`\`\`

It is possible to use `return` without a value. That causes the function to exit immediately.

For example:

    function showMovie(age) {
      if ( !checkAge(age) ) {
    *!*
        return;
    */!*
      }

      alert( "Showing you the movie" ); // (*)
      // ...
    }

In the code above, if `checkAge(age)` returns `false`, then `showMovie` won’t proceed to the `alert`.

\`\`\``smart header="A function with an empty`return`or without it returns`undefined`" If a function does not return a value, it is the same as if it returns`undefined\`:

\`\`\`js run function doNothing() { /\* empty \*/ }

alert( doNothing() === undefined ); // true \`\`\`

An empty `return` is also the same as `return undefined`:

\`\`\`js run function doNothing() { return; }

alert( doNothing() === undefined ); // true

\`\`\``warn header="Never add a newline between`return`and the value" For a long expression in`return\`, it might be tempting to put it on a separate line, like this:

    return
     (some + long + expression + or + whatever * f(a) + f(b))

That doesn’t work, because JavaScript assumes a semicolon after `return`. That’ll work the same as:

    return*!*;*/!*
     (some + long + expression + or + whatever * f(a) + f(b))

So, it effectively becomes an empty return.

If we want the returned expression to wrap across multiple lines, we should start it at the same line as `return`. Or at least put the opening parentheses there as follows:

    return (
      some + long + expression
      + or +
      whatever * f(a) + f(b)
      )

And it will work just as we expect it to. \`\`\`\`

## Naming a function \[\#function-naming\]

Functions are actions. So their name is usually a verb. It should be brief, as accurate as possible and describe what the function does, so that someone reading the code gets an indication of what the function does.

It is a widespread practice to start a function with a verbal prefix which vaguely describes the action. There must be an agreement within the team on the meaning of the prefixes.

For instance, functions that start with `"show"` usually show something.

Function starting with…

- `"get…"` – return a value,
- `"calc…"` – calculate something,
- `"create…"` – create something,
- `"check…"` – check something and return a boolean, etc.

Examples of such names:

`js no-beautify showMessage(..) // shows a message getAge(..) // returns the age (gets it somehow) calcSum(..) // calculates a sum and returns the result createForm(..) // creates a form (and usually returns it) checkPermission(..) // checks a permission, returns true/false`

With prefixes in place, a glance at a function name gives an understanding what kind of work it does and what kind of value it returns.

\`\`\`smart header=“One function – one action” A function should do exactly what is suggested by its name, no more.

Two independent actions usually deserve two functions, even if they are usually called together (in that case we can make a 3rd function that calls those two).

A few examples of breaking this rule:

- `getAge` – would be bad if it shows an `alert` with the age (should only get).
- `createForm` – would be bad if it modifies the document, adding a form to it (should only create it and return).
- `checkPermission` – would be bad if it displays the `access granted/denied` message (should only perform the check and return the result).

These examples assume common meanings of prefixes. You and your team are free to agree on other meanings, but usually they’re not much different. In any case, you should have a firm understanding of what a prefix means, what a prefixed function can and cannot do. All same-prefixed functions should obey the rules. And the team should share the knowledge. \`\`\`

\`\`\`smart header=“Ultrashort function names” Functions that are used _very often_ sometimes have ultrashort names.

For example, the [jQuery](http://jquery.com) framework defines a function with `$`. The [Lodash](http://lodash.com/) library has its core function named `_`.

These are exceptions. Generally function names should be concise and descriptive. \`\`\`

## Functions == Comments

Functions should be short and do exactly one thing. If that thing is big, maybe it’s worth it to split the function into a few smaller functions. Sometimes following this rule may not be that easy, but it’s definitely a good thing.

A separate function is not only easier to test and debug – its very existence is a great comment!

For instance, compare the two functions `showPrimes(n)` below. Each one outputs [prime numbers](https://en.wikipedia.org/wiki/Prime_number) up to `n`.

The first variant uses a label:

    function showPrimes(n) {
      nextPrime: for (let i = 2; i < n; i++) {

        for (let j = 2; j < i; j++) {
          if (i % j == 0) continue nextPrime;
        }

        alert( i ); // a prime
      }
    }

The second variant uses an additional function `isPrime(n)` to test for primality:

    function showPrimes(n) {

      for (let i = 2; i < n; i++) {
        *!*if (!isPrime(i)) continue;*/!*

        alert(i);  // a prime
      }
    }

    function isPrime(n) {
      for (let i = 2; i < n; i++) {
        if ( n % i == 0) return false;
      }
      return true;
    }

The second variant is easier to understand, isn’t it? Instead of the code piece we see a name of the action (`isPrime`). Sometimes people refer to such code as _self-describing_.

So, functions can be created even if we don’t intend to reuse them. They structure the code and make it readable.

## Summary

A function declaration looks like this:

    function name(parameters, delimited, by, comma) {
      /* code */
    }

- Values passed to a function as parameters are copied to its local variables.
- A function may access outer variables. But it works only from inside out. The code outside of the function doesn’t see its local variables.
- A function can return a value. If it doesn’t, then its result is `undefined`.

To make the code clean and easy to understand, it’s recommended to use mainly local variables and parameters in the function, not outer variables.

It is always easier to understand a function which gets parameters, works with them and returns a result than a function which gets no parameters, but modifies outer variables as a side-effect.

Function naming:

- A name should clearly describe what the function does. When we see a function call in the code, a good name instantly gives us an understanding what it does and returns.
- A function is an action, so function names are usually verbal.
- There exist many well-known function prefixes like `create…`, `show…`, `get…`, `check…` and so on. Use them to hint what a function does.

Functions are the main building blocks of scripts. Now we’ve covered the basics, so we actually can start creating and using them. But that’s only the beginning of the path. We are going to return to them many times, going more deeply into their advanced features.

# Manuals and specifications

This book is a _tutorial_. It aims to help you gradually learn the language. But once you’re familiar with the basics, you’ll need other sources.

## Specification

[The ECMA-262 specification](https://www.ecma-international.org/publications/standards/Ecma-262.htm) contains the most in-depth, detailed and formalized information about JavaScript. It defines the language.

But being that formalized, it’s difficult to understand at first. So if you need the most trustworthy source of information about the language details, the specification is the right place. But it’s not for everyday use.

A new specification version is released every year. In-between these releases, the latest specification draft is at <a href="https://tc39.es/ecma262/" class="uri">https://tc39.es/ecma262/</a>.

To read about new bleeding-edge features, including those that are “almost standard” (so-called “stage 3”), see proposals at <a href="https://github.com/tc39/proposals" class="uri">https://github.com/tc39/proposals</a>.

Also, if you’re developing for the browser, then there are other specifications covered in the [second part](info:browser-environment) of the tutorial.

## Manuals

- **MDN (Mozilla) JavaScript Reference** is the main manual with examples and other information. It’s great to get in-depth information about individual language functions, methods etc.

  One can find it at <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference" class="uri">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference</a>.

Although, it’s often best to use an internet search instead. Just use “MDN \[term\]” in the query, e.g. <a href="https://google.com/search?q=MDN+parseInt" class="uri">https://google.com/search?q=MDN+parseInt</a> to search for `parseInt` function.

## Compatibility tables

JavaScript is a developing language, new features get added regularly.

To see their support among browser-based and other engines, see:

- <a href="http://caniuse.com" class="uri">http://caniuse.com</a> - per-feature tables of support, e.g. to see which engines support modern cryptography functions: <a href="http://caniuse.com/#feat=cryptography" class="uri">http://caniuse.com/#feat=cryptography</a>.
- <a href="https://kangax.github.io/compat-table" class="uri">https://kangax.github.io/compat-table</a> - a table with language features and engines that support those or don’t support.

All these resources are useful in real-life development, as they contain valuable information about language details, their support etc.

Please remember them (or this page) for the cases when you need in-depth information about a particular feature. \# Function expressions

In JavaScript, a function is not a “magical language structure”, but a special kind of value.

The syntax that we used before is called a _Function Declaration_:

    function sayHi() {
      alert( "Hello" );
    }

There is another syntax for creating a function that is called a _Function Expression_.

It looks like this:

    let sayHi = function() {
      alert( "Hello" );
    };

Here, the function is created and assigned to the variable explicitly, like any other value. No matter how the function is defined, it’s just a value stored in the variable `sayHi`.

The meaning of these code samples is the same: “create a function and put it into the variable `sayHi`”.

We can even print out that value using `alert`:

\`\`\`js run function sayHi() { alert( “Hello” ); }

_!_ alert( sayHi ); // shows the function code _/!_ \`\`\`

Please note that the last line does not run the function, because there are no parentheses after `sayHi`. There are programming languages where any mention of a function name causes its execution, but JavaScript is not like that.

In JavaScript, a function is a value, so we can deal with it as a value. The code above shows its string representation, which is the source code.

Surely, a function is a special value, in the sense that we can call it like `sayHi()`.

But it’s still a value. So we can work with it like with other kinds of values.

We can copy a function to another variable:

\`\`\`js run no-beautify function sayHi() { // (1) create alert( “Hello” ); }

let func = sayHi; // (2) copy

func(); // Hello // (3) run the copy (it works)! sayHi(); // Hello // this still works too (why wouldn’t it) \`\`\`

Here’s what happens above in detail:

1.  The Function Declaration `(1)` creates the function and puts it into the variable named `sayHi`.
2.  Line `(2)` copies it into the variable `func`. Please note again: there are no parentheses after `sayHi`. If there were, then `func = sayHi()` would write _the result of the call_ `sayHi()` into `func`, not _the function_ `sayHi` itself.
3.  Now the function can be called as both `sayHi()` and `func()`.

Note that we could also have used a Function Expression to declare `sayHi`, in the first line:

    let sayHi = function() {
      alert( "Hello" );
    };

    let func = sayHi;
    // ...

Everything would work the same.

\`\`\``smart header="Why is there a semicolon at the end?" You might wonder, why does Function Expression have a semicolon`;\` at the end, but Function Declaration does not:

    function sayHi() {
      // ...
    }

    let sayHi = function() {
      // ...
    }*!*;*/!*

The answer is simple: - There’s no need for `;` at the end of code blocks and syntax structures that use them like `if { ... }`, `for { }`, `function f { }` etc. - A Function Expression is used inside the statement: `let sayHi = ...;`, as a value. It’s not a code block, but rather an assignment. The semicolon `;` is recommended at the end of statements, no matter what the value is. So the semicolon here is not related to the Function Expression itself, it just terminates the statement. \`\`\`\`

## Callback functions

Let’s look at more examples of passing functions as values and using function expressions.

We’ll write a function `ask(question, yes, no)` with three parameters:

`question`  
Text of the question

`yes`  
Function to run if the answer is “Yes”

`no`  
Function to run if the answer is “No”

The function should ask the `question` and, depending on the user’s answer, call `yes()` or `no()`:

\`\`\`js run _!_ function ask(question, yes, no) { if (confirm(question)) yes() else no(); } _/!_

function showOk() { alert( “You agreed.” ); }

function showCancel() { alert( “You canceled the execution.” ); }

// usage: functions showOk, showCancel are passed as arguments to ask ask(“Do you agree?”, showOk, showCancel); \`\`\`

In practice, such functions are quite useful. The major difference between a real-life `ask` and the example above is that real-life functions use more complex ways to interact with the user than a simple `confirm`. In the browser, such function usually draws a nice-looking question window. But that’s another story.

**The arguments `showOk` and `showCancel` of `ask` are called _callback functions_ or just _callbacks_.**

The idea is that we pass a function and expect it to be “called back” later if necessary. In our case, `showOk` becomes the callback for “yes” answer, and `showCancel` for “no” answer.

We can use Function Expressions to write the same function much shorter:

\`\`\`js run no-beautify function ask(question, yes, no) { if (confirm(question)) yes() else no(); }

_!_ ask( “Do you agree?”, function() { alert(“You agreed.”); }, function() { alert(“You canceled the execution.”); } ); _/!_ \`\`\`

Here, functions are declared right inside the `ask(...)` call. They have no name, and so are called _anonymous_. Such functions are not accessible outside of `ask` (because they are not assigned to variables), but that’s just what we want here.

Such code appears in our scripts very naturally, it’s in the spirit of JavaScript.

\`\`\`smart header=“A function is a value representing an "action"” Regular values like strings or numbers represent the _data_.

A function can be perceived as an _action_.

We can pass it between variables and run when we want. \`\`\`

## Function Expression vs Function Declaration

Let’s formulate the key differences between Function Declarations and Expressions.

First, the syntax: how to differentiate between them in the code.

- _Function Declaration:_ a function, declared as a separate statement, in the main code flow.

      // Function Declaration
      function sum(a, b) {
        return a + b;
      }

- _Function Expression:_ a function, created inside an expression or inside another syntax construct. Here, the function is created at the right side of the “assignment expression” `=`:

      // Function Expression
      let sum = function(a, b) {
        return a + b;
      };

The more subtle difference is _when_ a function is created by the JavaScript engine.

**A Function Expression is created when the execution reaches it and is usable only from that moment.**

Once the execution flow passes to the right side of the assignment `let sum = function…` – here we go, the function is created and can be used (assigned, called, etc. ) from now on.

Function Declarations are different.

**A Function Declaration can be called earlier than it is defined.**

For example, a global Function Declaration is visible in the whole script, no matter where it is.

That’s due to internal algorithms. When JavaScript prepares to run the script, it first looks for global Function Declarations in it and creates the functions. We can think of it as an “initialization stage”.

And after all Function Declarations are processed, the code is executed. So it has access to these functions.

For example, this works:

\`\`\`js run refresh untrusted _!_ sayHi(“John”); // Hello, John _/!_

function sayHi(name) { alert( `Hello, ${name}` ); } \`\`\`

The Function Declaration `sayHi` is created when JavaScript is preparing to start the script and is visible everywhere in it.

…If it were a Function Expression, then it wouldn’t work:

\`\`\`js run refresh untrusted _!_ sayHi(“John”); // error! _/!_

let sayHi = function(name) { // (\*) no magic any more alert( `Hello, ${name}` ); }; \`\`\`

Function Expressions are created when the execution reaches them. That would happen only in the line `(*)`. Too late.

Another special feature of Function Declarations is their block scope.

**In strict mode, when a Function Declaration is within a code block, it’s visible everywhere inside that block. But not outside of it.**

For instance, let’s imagine that we need to declare a function `welcome()` depending on the `age` variable that we get during runtime. And then we plan to use it some time later.

If we use Function Declaration, it won’t work as intended:

\`\`\`js run let age = prompt(“What is your age?”, 18);

// conditionally declare a function if (age &lt; 18) {

function welcome() { alert(“Hello!”); }

} else {

function welcome() { alert(“Greetings!”); }

}

// …use it later _!_ welcome(); // Error: welcome is not defined _/!_ \`\`\`

That’s because a Function Declaration is only visible inside the code block in which it resides.

Here’s another example:

\`\`\`js run let age = 16; // take 16 as an example

if (age &lt; 18) { _!_ welcome(); //   (runs) _/!_ // | function welcome() { // |  
alert(“Hello!”); // | Function Declaration is available } // | everywhere in the block where it’s declared // | _!_ welcome(); // / (runs) _/!_

} else {

function welcome() {  
alert(“Greetings!”); } }

// Here we’re out of curly braces, // so we can not see Function Declarations made inside of them.

_!_ welcome(); // Error: welcome is not defined _/!_ \`\`\`

What can we do to make `welcome` visible outside of `if`?

The correct approach would be to use a Function Expression and assign `welcome` to the variable that is declared outside of `if` and has the proper visibility.

This code works as intended:

\`\`\`js run let age = prompt(“What is your age?”, 18);

let welcome;

if (age &lt; 18) {

welcome = function() { alert(“Hello!”); };

} else {

welcome = function() { alert(“Greetings!”); };

}

_!_ welcome(); // ok now _/!_ \`\`\`

Or we could simplify it even further using a question mark operator `?`:

\`\`\`js run let age = prompt(“What is your age?”, 18);

let welcome = (age &lt; 18) ? function() { alert(“Hello!”); } : function() { alert(“Greetings!”); };

_!_ welcome(); // ok now _/!_ \`\`\`

\`\`\`smart header=“When to choose Function Declaration versus Function Expression?” As a rule of thumb, when we need to declare a function, the first to consider is Function Declaration syntax. It gives more freedom in how to organize our code, because we can call such functions before they are declared.

That’s also better for readability, as it’s easier to look up `function f(…) {…}` in the code than `let f = function(…) {…};`. Function Declarations are more “eye-catching”.

…But if a Function Declaration does not suit us for some reason, or we need a conditional declaration (we’ve just seen an example), then Function Expression should be used. \`\`\`

## Summary

- Functions are values. They can be assigned, copied or declared in any place of the code.
- If the function is declared as a separate statement in the main code flow, that’s called a “Function Declaration”.
- If the function is created as a part of an expression, it’s called a “Function Expression”.
- Function Declarations are processed before the code block is executed. They are visible everywhere in the block.
- Function Expressions are created when the execution flow reaches them.

In most cases when we need to declare a function, a Function Declaration is preferable, because it is visible prior to the declaration itself. That gives us more flexibility in code organization, and is usually more readable.

So we should use a Function Expression only when a Function Declaration is not fit for the task. We’ve seen a couple of examples of that in this chapter, and will see more in the future. \# Arrow functions, the basics

There’s another very simple and concise syntax for creating functions, that’s often better than Function Expressions.

It’s called “arrow functions”, because it looks like this:

    let func = (arg1, arg2, ..., argN) => expression

…This creates a function `func` that accepts arguments `arg1..argN`, then evaluates the `expression` on the right side with their use and returns its result.

In other words, it’s the shorter version of:

    let func = function(arg1, arg2, ..., argN) {
      return expression;
    };

Let’s see a concrete example:

\`\`\`js run let sum = (a, b) =&gt; a + b;

/\* This arrow function is a shorter form of:

let sum = function(a, b) { return a + b; }; \*/

alert( sum(1, 2) ); // 3 \`\`\`

As you can, see `(a, b) => a + b` means a function that accepts two arguments named `a` and `b`. Upon the execution, it evaluates the expression `a + b` and returns the result.

- If we have only one argument, then parentheses around parameters can be omitted, making that even shorter.

  For example:

  \`\`\`js run _!_ let double = n =&gt; n \* 2; // roughly the same as: let double = function(n) { return n \* 2 } _/!_

  alert( double(3) ); // 6 \`\`\`

- If there are no arguments, parentheses will be empty (but they should be present):

  \`\`\`js run let sayHi = () =&gt; alert(“Hello!”);

  sayHi(); \`\`\`

Arrow functions can be used in the same way as Function Expressions.

For instance, to dynamically create a function:

\`\`\`js run let age = prompt(“What is your age?”, 18);

let welcome = (age &lt; 18) ? () =&gt; alert(‘Hello’) : () =&gt; alert(“Greetings!”);

welcome(); \`\`\`

Arrow functions may appear unfamiliar and not very readable at first, but that quickly changes as the eyes get used to the structure.

They are very convenient for simple one-line actions, when we’re just too lazy to write many words.

## Multiline arrow functions

The examples above took arguments from the left of `=>` and evaluated the right-side expression with them.

Sometimes we need something a little bit more complex, like multiple expressions or statements. It is also possible, but we should enclose them in curly braces. Then use a normal `return` within them.

Like this:

\`\`\`js run let sum = (a, b) =&gt; { // the curly brace opens a multiline function let result = a + b; _!_ return result; // if we use curly braces, then we need an explicit “return” _/!_ };

alert( sum(1, 2) ); // 3 \`\`\`

\`\`\`smart header=“More to come” Here we praised arrow functions for brevity. But that’s not all!

Arrow functions have other interesting features.

To study them in-depth, we first need to get to know some other aspects of JavaScript, so we’ll return to arrow functions later in the chapter <a href="info:arrow-functions" class="uri">info:arrow-functions</a>.

For now, we can already use arrow functions for one-line actions and callbacks. \`\`\`

## Summary

Arrow functions are handy for one-liners. They come in two flavors:

1.  Without curly braces: `(...args) => expression` – the right side is an expression: the function evaluates it and returns the result.
2.  With curly braces: `(...args) => { body }` – brackets allow us to write multiple statements inside the function, but we need an explicit `return` to return something. \# JavaScript specials

This chapter briefly recaps the features of JavaScript that we’ve learned by now, paying special attention to subtle moments.

## Code structure

Statements are delimited with a semicolon:

`js run no-beautify alert('Hello'); alert('World');`

Usually, a line-break is also treated as a delimiter, so that would also work:

`js run no-beautify alert('Hello') alert('World')`

That’s called “automatic semicolon insertion”. Sometimes it doesn’t work, for instance:

\`\`\`js run alert(“There will be an error after this message”)

\[1, 2\].forEach(alert) \`\`\`

Most codestyle guides agree that we should put a semicolon after each statement.

Semicolons are not required after code blocks `{...}` and syntax constructs with them like loops:

    function f() {
      // no semicolon needed after function declaration
    }

    for(;;) {
      // no semicolon needed after the loop
    }

…But even if we can put an “extra” semicolon somewhere, that’s not an error. It will be ignored.

More in: <a href="info:structure" class="uri">info:structure</a>.

## Strict mode

To fully enable all features of modern JavaScript, we should start scripts with `"use strict"`.

    'use strict';

    ...

The directive must be at the top of a script or at the beginning of a function body.

Without `"use strict"`, everything still works, but some features behave in the old-fashion, “compatible” way. We’d generally prefer the modern behavior.

Some modern features of the language (like classes that we’ll study in the future) enable strict mode implicitly.

More in: <a href="info:strict-mode" class="uri">info:strict-mode</a>.

## Variables

Can be declared using:

- `let`
- `const` (constant, can’t be changed)
- `var` (old-style, will see later)

A variable name can include: - Letters and digits, but the first character may not be a digit. - Characters `$` and `_` are normal, on par with letters. - Non-Latin alphabets and hieroglyphs are also allowed, but commonly not used.

Variables are dynamically typed. They can store any value:

    let x = 5;
    x = "John";

There are 8 data types:

- `number` for both floating-point and integer numbers,
- `bigint` for integer numbers of arbitrary length,
- `string` for strings,
- `boolean` for logical values: `true/false`,
- `null` – a type with a single value `null`, meaning “empty” or “does not exist”,
- `undefined` – a type with a single value `undefined`, meaning “not assigned”,
- `object` and `symbol` – for complex data structures and unique identifiers, we haven’t learnt them yet.

The `typeof` operator returns the type for a value, with two exceptions:

    typeof null == "object" // error in the language
    typeof function(){} == "function" // functions are treated specially

More in: <a href="info:variables" class="uri">info:variables</a> and <a href="info:types" class="uri">info:types</a>.

## Interaction

We’re using a browser as a working environment, so basic UI functions will be:

[`prompt(question, [default])`](mdn:api/Window/prompt)  
Ask a `question`, and return either what the visitor entered or `null` if they clicked “cancel”.

[`confirm(question)`](mdn:api/Window/confirm)  
Ask a `question` and suggest to choose between Ok and Cancel. The choice is returned as `true/false`.

[`alert(message)`](mdn:api/Window/alert)  
Output a `message`.

All these functions are _modal_, they pause the code execution and prevent the visitor from interacting with the page until they answer.

For instance:

\`\`\`js run let userName = prompt(“Your name?”, “Alice”); let isTeaWanted = confirm(“Do you want some tea?”);

alert( “Visitor:” + userName ); // Alice alert( “Tea wanted:” + isTeaWanted ); // true \`\`\`

More in: <a href="info:alert-prompt-confirm" class="uri">info:alert-prompt-confirm</a>.

## Operators

JavaScript supports the following operators:

Arithmetical  
Regular: `* + - /`, also `%` for the remainder and `**` for power of a number.

The binary plus `+` concatenates strings. And if any of the operands is a string, the other one is converted to string too:

`js run alert( '1' + 2 ); // '12', string alert( 1 + '2' ); // '12', string`

Assignments  
There is a simple assignment: `a = b` and combined ones like `a *= 2`.

Bitwise  
Bitwise operators work with 32-bit integers at the lowest, bit-level: see the [docs](mdn:/JavaScript/Guide/Expressions_and_Operators#Bitwise) when they are needed.

Conditional  
The only operator with three parameters: `cond ? resultA : resultB`. If `cond` is truthy, returns `resultA`, otherwise `resultB`.

Logical operators  
Logical AND `&&` and OR `||` perform short-circuit evaluation and then return the value where it stopped (not necessary `true`/`false`). Logical NOT `!` converts the operand to boolean type and returns the inverse value.

Nullish coalescing operator  
The `??` operator provides a way to choose a defined value from a list of variables. The result of `a ?? b` is `a` unless it’s `null/undefined`, then `b`.

Comparisons  
Equality check `==` for values of different types converts them to a number (except `null` and `undefined` that equal each other and nothing else), so these are equal:

`js run alert( 0 == false ); // true alert( 0 == '' ); // true`

Other comparisons convert to a number as well.

The strict equality operator `===` doesn’t do the conversion: different types always mean different values for it.

Values `null` and `undefined` are special: they equal `==` each other and don’t equal anything else.

Greater/less comparisons compare strings character-by-character, other types are converted to a number.

Other operators  
There are few others, like a comma operator.

More in: <a href="info:operators" class="uri">info:operators</a>, <a href="info:comparison" class="uri">info:comparison</a>, <a href="info:logical-operators" class="uri">info:logical-operators</a>, <a href="info:nullish-coalescing-operator" class="uri">info:nullish-coalescing-operator</a>.

## Loops

- We covered 3 types of loops:

      // 1
      while (condition) {
        ...
      }

      // 2
      do {
        ...
      } while (condition);

      // 3
      for(let i = 0; i < 10; i++) {
        ...
      }

- The variable declared in `for(let...)` loop is visible only inside the loop. But we can also omit `let` and reuse an existing variable.
- Directives `break/continue` allow to exit the whole loop/current iteration. Use labels to break nested loops.

Details in: <a href="info:while-for" class="uri">info:while-for</a>.

Later we’ll study more types of loops to deal with objects.

## The “switch” construct

The “switch” construct can replace multiple `if` checks. It uses `===` (strict equality) for comparisons.

For instance:

\`\`\`js run let age = prompt(‘Your age?’, 18);

switch (age) { case 18: alert(“Won’t work”); // the result of prompt is a string, not a number break;

case “18”: alert(“This works!”); break;

default: alert(“Any value not equal to one above”); } \`\`\`

Details in: <a href="info:switch" class="uri">info:switch</a>.

## Functions

We covered three ways to create a function in JavaScript:

1.  Function Declaration: the function in the main code flow

        function sum(a, b) {
          let result = a + b;

          return result;
        }

2.  Function Expression: the function in the context of an expression

        let sum = function(a, b) {
          let result = a + b;

          return result;
        };

3.  Arrow functions:

        // expression at the right side
        let sum = (a, b) => a + b;

        // or multi-line syntax with { ... }, need return here:
        let sum = (a, b) => {
          // ...
          return a + b;
        }

        // without arguments
        let sayHi = () => alert("Hello");

        // with a single argument
        let double = n => n * 2;

- Functions may have local variables: those declared inside its body or its parameter list. Such variables are only visible inside the function.
- Parameters can have default values: `function sum(a = 1, b = 2) {...}`.
- Functions always return something. If there’s no `return` statement, then the result is `undefined`.

Details: see <a href="info:function-basics" class="uri">info:function-basics</a>, <a href="info:arrow-functions-basics" class="uri">info:arrow-functions-basics</a>.

## More to come

That was a brief list of JavaScript features. As of now we’ve studied only basics. Further in the tutorial you’ll find more specials and advanced features of JavaScript. \# Debugging in Chrome

Before writing more complex code, let’s talk about debugging.

[Debugging](https://en.wikipedia.org/wiki/Debugging) is the process of finding and fixing errors within a script. All modern browsers and most other environments support debugging tools – a special UI in developer tools that makes debugging much easier. It also allows to trace the code step by step to see what exactly is going on.

We’ll be using Chrome here, because it has enough features, most other browsers have a similar process.

## The “Sources” panel

Your Chrome version may look a little bit different, but it still should be obvious what’s there.

- Open the [example page](debugging/index.html) in Chrome.
- Turn on developer tools with `key:F12` (Mac: `key:Cmd+Opt+I`).
- Select the `Sources` panel.

Here’s what you should see if you are doing it for the first time:

![](chrome-open-sources.svg)

The toggler button <span class="devtools" style="background-position:-172px -98px"></span> opens the tab with files.

Let’s click it and select `hello.js` in the tree view. Here’s what should show up:

![](chrome-tabs.svg)

The Sources panel has 3 parts:

1.  The **File Navigator** pane lists HTML, JavaScript, CSS and other files, including images that are attached to the page. Chrome extensions may appear here too.
2.  The **Code Editor** pane shows the source code.
3.  The **JavaScript Debugging** pane is for debugging, we’ll explore it soon.

Now you could click the same toggler <span class="devtools" style="background-position:-172px -122px"></span> again to hide the resources list and give the code some space.

## Console

If we press `key:Esc`, then a console opens below. We can type commands there and press `key:Enter` to execute.

After a statement is executed, its result is shown below.

For example, here `1+2` results in `3`, and `hello("debugger")` returns nothing, so the result is `undefined`:

![](chrome-sources-console.svg)

## Breakpoints

Let’s examine what’s going on within the code of the [example page](debugging/index.html). In `hello.js`, click at line number `4`. Yes, right on the `4` digit, not on the code.

Congratulations! You’ve set a breakpoint. Please also click on the number for line `8`.

It should look like this (blue is where you should click):

![](chrome-sources-breakpoint.svg)

A _breakpoint_ is a point of code where the debugger will automatically pause the JavaScript execution.

While the code is paused, we can examine current variables, execute commands in the console etc. In other words, we can debug it.

We can always find a list of breakpoints in the right panel. That’s useful when we have many breakpoints in various files. It allows us to: - Quickly jump to the breakpoint in the code (by clicking on it in the right panel). - Temporarily disable the breakpoint by unchecking it. - Remove the breakpoint by right-clicking and selecting Remove. - …And so on.

\`\`\`smart header=“Conditional breakpoints” _Right click_ on the line number allows to create a _conditional_ breakpoint. It only triggers when the given expression is truthy.

That’s handy when we need to stop only for a certain variable value or for certain function parameters. \`\`\`

## Debugger command

We can also pause the code by using the `debugger` command in it, like this:

    function hello(name) {
      let phrase = `Hello, ${name}!`;

    *!*
      debugger;  // <-- the debugger stops here
    */!*

      say(phrase);
    }

That’s very convenient when we are in a code editor and don’t want to switch to the browser and look up the script in developer tools to set the breakpoint.

## Pause and look around

In our example, `hello()` is called during the page load, so the easiest way to activate the debugger (after we’ve set the breakpoints) is to reload the page. So let’s press `key:F5` (Windows, Linux) or `key:Cmd+R` (Mac).

As the breakpoint is set, the execution pauses at the 4th line:

![](chrome-sources-debugger-pause.svg)

Please open the informational dropdowns to the right (labeled with arrows). They allow you to examine the current code state:

1.  **`Watch` – shows current values for any expressions.**

    You can click the plus `+` and input an expression. The debugger will show its value at any moment, automatically recalculating it in the process of execution.

2.  **`Call Stack` – shows the nested calls chain.**

    At the current moment the debugger is inside `hello()` call, called by a script in `index.html` (no function there, so it’s called “anonymous”).

    If you click on a stack item (e.g. “anonymous”), the debugger jumps to the corresponding code, and all its variables can be examined as well.

3.  **`Scope` – current variables.**

    `Local` shows local function variables. You can also see their values highlighted right over the source.

    `Global` has global variables (out of any functions).

    There’s also `this` keyword there that we didn’t study yet, but we’ll do that soon.

## Tracing the execution

Now it’s time to _trace_ the script.

There are buttons for it at the top of the right panel. Let’s engage them. <span class="devtools" style="background-position:-146px -168px"></span> – “Resume”: continue the execution, hotkey `key:F8`. : Resumes the execution. If there are no additional breakpoints, then the execution just continues and the debugger loses control.

    Here's what we can see after a click on it:

    ![](chrome-sources-debugger-trace-1.svg)

    The execution has resumed, reached another breakpoint inside `say()` and paused there. Take a look at the "Call Stack" at the right. It has increased by one more call. We're inside `say()` now.

<span class="devtools" style="background-position:-200px -190px"></span> – “Step”: run the next command, hotkey `key:F9`.  
Run the next statement. If we click it now, `alert` will be shown.

Clicking this again and again will step through all script statements one by one.

<span class="devtools" style="background-position:-62px -192px"></span> – “Step over”: run the next command, but _don’t go into a function_, hotkey `key:F10`.  
Similar to the previous “Step” command, but behaves differently if the next statement is a function call. That is: not a built-in, like `alert`, but a function of our own.

The “Step” command goes into it and pauses the execution at its first line, while “Step over” executes the nested function call invisibly, skipping the function internals.

The execution is then paused immediately after that function.

That’s good if we’re not interested to see what happens inside the function call.

<span class="devtools" style="background-position:-4px -194px"></span> – “Step into”, hotkey `key:F11`.  
That’s similar to “Step”, but behaves differently in case of asynchronous function calls. If you’re only starting to learn JavaScript, then you can ignore the difference, as we don’t have asynchronous calls yet.

For the future, just note that “Step” command ignores async actions, such as `setTimeout` (scheduled function call), that execute later. The “Step into” goes into their code, waiting for them if necessary. See [DevTools manual](https://developers.google.com/web/updates/2018/01/devtools#async) for more details.

<span class="devtools" style="background-position:-32px -194px"></span> – “Step out”: continue the execution till the end of the current function, hotkey `key:Shift+F11`.  
Continue the execution and stop it at the very last line of the current function. That’s handy when we accidentally entered a nested call using <span class="devtools" style="background-position:-200px -190px"></span>, but it does not interest us, and we want to continue to its end as soon as possible.

<span class="devtools" style="background-position:-61px -74px"></span> – enable/disable all breakpoints.  
That button does not move the execution. Just a mass on/off for breakpoints.

<span class="devtools" style="background-position:-90px -146px"></span> – enable/disable automatic pause in case of an error.  
When enabled, and the developer tools is open, a script error automatically pauses the execution. Then we can analyze variables to see what went wrong. So if our script dies with an error, we can open debugger, enable this option and reload the page to see where it dies and what’s the context at that moment.

\`\`\`smart header=“Continue to here” Right click on a line of code opens the context menu with a great option called “Continue to here”.

That’s handy when we want to move multiple steps forward to the line, but we’re too lazy to set a breakpoint. \`\`\`

## Logging

To output something to console from our code, there’s `console.log` function.

For instance, this outputs values from `0` to `4` to console:

`js run // open console to see for (let i = 0; i < 5; i++) { console.log("value,", i); }`

Regular users don’t see that output, it is in the console. To see it, either open the Console panel of developer tools or press `key:Esc` while in another panel: that opens the console at the bottom.

If we have enough logging in our code, then we can see what’s going on from the records, without the debugger.

## Summary

As we can see, there are three main ways to pause a script: 1. A breakpoint. 2. The `debugger` statements. 3. An error (if dev tools are open and the button <span class="devtools" style="background-position:-90px -146px"></span> is “on”).

When paused, we can debug - examine variables and trace the code to see where the execution goes wrong.

There are many more options in developer tools than covered here. The full manual is at <a href="https://developers.google.com/web/tools/chrome-devtools" class="uri">https://developers.google.com/web/tools/chrome-devtools</a>.

The information from this chapter is enough to begin debugging, but later, especially if you do a lot of browser stuff, please go there and look through more advanced capabilities of developer tools.

Oh, and also you can click at various places of dev tools and just see what’s showing up. That’s probably the fastest route to learn dev tools. Don’t forget about the right click and context menus! \# Coding Style

Our code must be as clean and easy to read as possible.

That is actually the art of programming – to take a complex task and code it in a way that is both correct and human-readable. A good code style greatly assists in that.

## Syntax

Here is a cheat sheet with some suggested rules (see below for more details):

![](code-style.svg)

Now let’s discuss the rules and reasons for them in detail.

`warn header="There are no \"you must\" rules" Nothing is set in stone here. These are style preferences, not religious dogmas.`

### Curly Braces

In most JavaScript projects curly braces are written in “Egyptian” style with the opening brace on the same line as the corresponding keyword – not on a new line. There should also be a space before the opening bracket, like this:

    if (condition) {
      // do this
      // ...and that
      // ...and that
    }

A single-line construct, such as `if (condition) doSomething()`, is an important edge case. Should we use braces at all?

Here are the annotated variants so you can judge their readability for yourself:

1.  😠 Beginners sometimes do that. Bad! Curly braces are not needed: `` js if (n < 0) *!*{*/!*alert(`Power ${n} is not supported`);*!*}*/!* ``
2.  😠 Split to a separate line without braces. Never do that, easy to make an error when adding new lines: `` js if (n < 0) alert(`Power ${n} is not supported`); ``
3.  😏 One line without braces - acceptable, if it’s short: `` js if (n < 0) alert(`Power ${n} is not supported`); ``
4.  😃 The best variant: `` js if (n < 0) { alert(`Power ${n} is not supported`); } ``

For a very brief code, one line is allowed, e.g. `if (cond) return null`. But a code block (the last variant) is usually more readable.

### Line Length

No one likes to read a long horizontal line of code. It’s best practice to split them.

For example:

    // backtick quotes ` allow to split the string into multiple lines
    let str = `
      ECMA International's TC39 is a group of JavaScript developers,
      implementers, academics, and more, collaborating with the community
      to maintain and evolve the definition of JavaScript.
    `;

And, for `if` statements:

    if (
      id === 123 &&
      moonPhase === 'Waning Gibbous' &&
      zodiacSign === 'Libra'
    ) {
      letTheSorceryBegin();
    }

The maximum line length should be agreed upon at the team-level. It’s usually 80 or 120 characters.

### Indents

There are two types of indents:

- **Horizontal indents: 2 or 4 spaces.**

  A horizontal indentation is made using either 2 or 4 spaces or the horizontal tab symbol (key `key:Tab`). Which one to choose is an old holy war. Spaces are more common nowadays.

  One advantage of spaces over tabs is that spaces allow more flexible configurations of indents than the tab symbol.

  For instance, we can align the parameters with the opening bracket, like this:

  `js no-beautify show(parameters, aligned, // 5 spaces padding at the left one, after, another ) { // ... }`

- **Vertical indents: empty lines for splitting code into logical blocks.**

  Even a single function can often be divided into logical blocks. In the example below, the initialization of variables, the main loop and returning the result are split vertically:

      function pow(x, n) {
        let result = 1;
        //              <--
        for (let i = 0; i < n; i++) {
          result *= x;
        }
        //              <--
        return result;
      }

  Insert an extra newline where it helps to make the code more readable. There should not be more than nine lines of code without a vertical indentation.

### Semicolons

A semicolon should be present after each statement, even if it could possibly be skipped.

There are languages where a semicolon is truly optional and it is rarely used. In JavaScript, though, there are cases where a line break is not interpreted as a semicolon, leaving the code vulnerable to errors. See more about that in the chapter <a href="info:structure#semicolon" class="uri">info:structure#semicolon</a>.

If you’re an experienced JavaScript programmer, you may choose a no-semicolon code style like [StandardJS](https://standardjs.com/). Otherwise, it’s best to use semicolons to avoid possible pitfalls. The majority of developers put semicolons.

### Nesting Levels

Try to avoid nesting code too many levels deep.

For example, in the loop, it’s sometimes a good idea to use the [`continue`](info:while-for#continue) directive to avoid extra nesting.

For example, instead of adding a nested `if` conditional like this:

    for (let i = 0; i < 10; i++) {
      if (cond) {
        ... // <- one more nesting level
      }
    }

We can write:

    for (let i = 0; i < 10; i++) {
      if (!cond) *!*continue*/!*;
      ...  // <- no extra nesting level
    }

A similar thing can be done with `if/else` and `return`.

For example, two constructs below are identical.

Option 1:

    function pow(x, n) {
      if (n < 0) {
        alert("Negative 'n' not supported");
      } else {
        let result = 1;

        for (let i = 0; i < n; i++) {
          result *= x;
        }

        return result;
      }
    }

Option 2:

    function pow(x, n) {
      if (n < 0) {
        alert("Negative 'n' not supported");
        return;
      }

      let result = 1;

      for (let i = 0; i < n; i++) {
        result *= x;
      }

      return result;
    }

The second one is more readable because the “special case” of `n < 0` is handled early on. Once the check is done we can move on to the “main” code flow without the need for additional nesting.

## Function Placement

If you are writing several “helper” functions and the code that uses them, there are three ways to organize the functions.

1.  Declare the functions _above_ the code that uses them:

        // *!*function declarations*/!*
        function createElement() {
          ...
        }

        function setHandler(elem) {
          ...
        }

        function walkAround() {
          ...
        }

        // *!*the code which uses them*/!*
        let elem = createElement();
        setHandler(elem);
        walkAround();

2.  Code first, then functions

        // *!*the code which uses the functions*/!*
        let elem = createElement();
        setHandler(elem);
        walkAround();

        // --- *!*helper functions*/!* ---
        function createElement() {
          ...
        }

        function setHandler(elem) {
          ...
        }

        function walkAround() {
          ...
        }

3.  Mixed: a function is declared where it’s first used.

Most of time, the second variant is preferred.

That’s because when reading code, we first want to know _what it does_. If the code goes first, then it becomes clear from the start. Then, maybe we won’t need to read the functions at all, especially if their names are descriptive of what they actually do.

## Style Guides

A style guide contains general rules about “how to write” code, e.g. which quotes to use, how many spaces to indent, the maximal line length, etc. A lot of minor things.

When all members of a team use the same style guide, the code looks uniform, regardless of which team member wrote it.

Of course, a team can always write their own style guide, but usually there’s no need to. There are many existing guides to choose from.

Some popular choices:

- [Google JavaScript Style Guide](https://google.github.io/styleguide/jsguide.html)
- [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript)
- [Idiomatic.JS](https://github.com/rwaldron/idiomatic.js)
- [StandardJS](https://standardjs.com/)
- (plus many more)

If you’re a novice developer, start with the cheat sheet at the beginning of this chapter. Then you can browse other style guides to pick up more ideas and decide which one you like best.

## Automated Linters

Linters are tools that can automatically check the style of your code and make improving suggestions.

The great thing about them is that style-checking can also find some bugs, like typos in variable or function names. Because of this feature, using a linter is recommended even if you don’t want to stick to one particular “code style”.

Here are some well-known linting tools:

- [JSLint](http://www.jslint.com/) – one of the first linters.
- [JSHint](http://www.jshint.com/) – more settings than JSLint.
- [ESLint](http://eslint.org/) – probably the newest one.

Most linters are integrated with many popular editors: just enable the plugin in the editor and configure the style.

For instance, for ESLint you should do the following:

1.  Install [Node.js](https://nodejs.org/).
2.  Install ESLint with the command `npm install -g eslint` (npm is a JavaScript package installer).
3.  Create a config file named `.eslintrc` in the root of your JavaScript project (in the folder that contains all your files).
4.  Install/enable the plugin for your editor that integrates with ESLint. The majority of editors have one.

Here’s an example of an `.eslintrc` file:

    {
      "extends": "eslint:recommended",
      "env": {
        "browser": true,
        "node": true,
        "es6": true
      },
      "rules": {
        "no-console": 0,
        "indent": 2
      }
    }

Here the directive `"extends"` denotes that the configuration is based on the “eslint:recommended” set of settings. After that, we specify our own.

It is also possible to download style rule sets from the web and extend them instead. See <a href="http://eslint.org/docs/user-guide/getting-started" class="uri">http://eslint.org/docs/user-guide/getting-started</a> for more details about installation.

Also certain IDEs have built-in linting, which is convenient but not as customizable as ESLint.

## Summary

All syntax rules described in this chapter (and in the style guides referenced) aim to increase the readability of your code. All of them are debatable.

When we think about writing “better” code, the questions we should ask ourselves are: “What makes the code more readable and easier to understand?” and “What can help us avoid errors?” These are the main things to keep in mind when choosing and debating code styles.

Reading popular style guides will allow you to keep up to date with the latest ideas about code style trends and best practices. \# Comments

As we know from the chapter <a href="info:structure" class="uri">info:structure</a>, comments can be single-line: starting with `//` and multiline: `/* ... */`.

We normally use them to describe how and why the code works.

At first sight, commenting might be obvious, but novices in programming often use them wrongly.

## Bad comments

Novices tend to use comments to explain “what is going on in the code”. Like this:

    // This code will do this thing (...) and that thing (...)
    // ...and who knows what else...
    very;
    complex;
    code;

But in good code, the amount of such “explanatory” comments should be minimal. Seriously, the code should be easy to understand without them.

There’s a great rule about that: “if the code is so unclear that it requires a comment, then maybe it should be rewritten instead”.

### Recipe: factor out functions

Sometimes it’s beneficial to replace a code piece with a function, like here:

    function showPrimes(n) {
      nextPrime:
      for (let i = 2; i < n; i++) {

    *!*
        // check if i is a prime number
        for (let j = 2; j < i; j++) {
          if (i % j == 0) continue nextPrime;
        }
    */!*

        alert(i);
      }
    }

The better variant, with a factored out function `isPrime`:

    function showPrimes(n) {

      for (let i = 2; i < n; i++) {
        *!*if (!isPrime(i)) continue;*/!*

        alert(i);
      }
    }

    function isPrime(n) {
      for (let i = 2; i < n; i++) {
        if (n % i == 0) return false;
      }

      return true;
    }

Now we can understand the code easily. The function itself becomes the comment. Such code is called _self-descriptive_.

### Recipe: create functions

And if we have a long “code sheet” like this:

    // here we add whiskey
    for(let i = 0; i < 10; i++) {
      let drop = getWhiskey();
      smell(drop);
      add(drop, glass);
    }

    // here we add juice
    for(let t = 0; t < 3; t++) {
      let tomato = getTomato();
      examine(tomato);
      let juice = press(tomato);
      add(juice, glass);
    }

    // ...

Then it might be a better variant to refactor it into functions like:

    addWhiskey(glass);
    addJuice(glass);

    function addWhiskey(container) {
      for(let i = 0; i < 10; i++) {
        let drop = getWhiskey();
        //...
      }
    }

    function addJuice(container) {
      for(let t = 0; t < 3; t++) {
        let tomato = getTomato();
        //...
      }
    }

Once again, functions themselves tell what’s going on. There’s nothing to comment. And also the code structure is better when split. It’s clear what every function does, what it takes and what it returns.

In reality, we can’t totally avoid “explanatory” comments. There are complex algorithms. And there are smart “tweaks” for purposes of optimization. But generally we should try to keep the code simple and self-descriptive.

## Good comments

So, explanatory comments are usually bad. Which comments are good?

Describe the architecture  
Provide a high-level overview of components, how they interact, what’s the control flow in various situations… In short – the bird’s eye view of the code. There’s a special language [UML](http://wikipedia.org/wiki/Unified_Modeling_Language) to build high-level architecture diagrams explaining the code. Definitely worth studying.

Document function parameters and usage  
There’s a special syntax [JSDoc](http://en.wikipedia.org/wiki/JSDoc) to document a function: usage, parameters, returned value.

For instance:

    /**
     * Returns x raised to the n-th power.
     *
     * @param {number} x The number to raise.
     * @param {number} n The power, must be a natural number.
     * @return {number} x raised to the n-th power.
     */
    function pow(x, n) {
      ...
    }

Such comments allow us to understand the purpose of the function and use it the right way without looking in its code.

By the way, many editors like [WebStorm](https://www.jetbrains.com/webstorm/) can understand them as well and use them to provide autocomplete and some automatic code-checking.

Also, there are tools like [JSDoc 3](https://github.com/jsdoc3/jsdoc) that can generate HTML-documentation from the comments. You can read more information about JSDoc at <a href="http://usejsdoc.org/" class="uri">http://usejsdoc.org/</a>.

Why is the task solved this way?  
What’s written is important. But what’s _not_ written may be even more important to understand what’s going on. Why is the task solved exactly this way? The code gives no answer.

If there are many ways to solve the task, why this one? Especially when it’s not the most obvious one.

Without such comments the following situation is possible: 1. You (or your colleague) open the code written some time ago, and see that it’s “suboptimal”. 2. You think: “How stupid I was then, and how much smarter I’m now”, and rewrite using the “more obvious and correct” variant. 3. …The urge to rewrite was good. But in the process you see that the “more obvious” solution is actually lacking. You even dimly remember why, because you already tried it long ago. You revert to the correct variant, but the time was wasted.

Comments that explain the solution are very important. They help to continue development the right way.

Any subtle features of the code? Where they are used?  
If the code has anything subtle and counter-intuitive, it’s definitely worth commenting.

## Summary

An important sign of a good developer is comments: their presence and even their absence.

Good comments allow us to maintain the code well, come back to it after a delay and use it more effectively.

**Comment this:**

- Overall architecture, high-level view.
- Function usage.
- Important solutions, especially when not immediately obvious.

**Avoid comments:**

- That tell “how code works” and “what it does”.
- Put them in only if it’s impossible to make the code so simple and self-descriptive that it doesn’t require them.

Comments are also used for auto-documenting tools like JSDoc3: they read them and generate HTML-docs (or docs in another format). \# Ninja code

Programmer ninjas of the past used these tricks to sharpen the mind of code maintainers.

Code review gurus look for them in test tasks.

Novice developers sometimes use them even better than programmer ninjas.

Read them carefully and find out who you are – a ninja, a novice, or maybe a code reviewer?

`warn header="Irony detected" Many try to follow ninja paths. Few succeed.`

## Brevity is the soul of wit

Make the code as short as possible. Show how smart you are.

Let subtle language features guide you.

For instance, take a look at this ternary operator `'?'`:

    // taken from a well-known javascript library
    i = i ? i < 0 ? Math.max(0, len + i) : i : 0;

Cool, right? If you write like that, a developer who comes across this line and tries to understand what is the value of `i` is going to have a merry time. Then come to you, seeking for an answer.

Tell them that shorter is always better. Initiate them into the paths of ninja.

## One-letter variables

Another way to code shorter is to use single-letter variable names everywhere. Like `a`, `b` or `c`.

A short variable disappears in the code like a real ninja in the forest. No one will be able to find it using “search” of the editor. And even if someone does, they won’t be able to “decipher” what the name `a` or `b` means.

…But there’s an exception. A real ninja will never use `i` as the counter in a `"for"` loop. Anywhere, but not here. Look around, there are many more exotic letters. For instance, `x` or `y`.

An exotic variable as a loop counter is especially cool if the loop body takes 1-2 pages (make it longer if you can). Then if someone looks deep inside the loop, they won’t be able to quickly figure out that the variable named `x` is the loop counter.

## Use abbreviations

If the team rules forbid the use of one-letter and vague names – shorten them, make abbreviations.

Like this:

- `list` -&gt; `lst`.
- `userAgent` -&gt; `ua`.
- `browser` -&gt; `brsr`.
- …etc

Only the one with truly good intuition will be able to understand such names. Try to shorten everything. Only a worthy person should be able to uphold the development of your code.

## Soar high. Be abstract.

While choosing a name try to use the most abstract word. Like `obj`, `data`, `value`, `item`, `elem` and so on.

- **The ideal name for a variable is `data`.** Use it everywhere you can. Indeed, every variable holds _data_, right?

  …But what to do if `data` is already taken? Try `value`, it’s also universal. After all, a variable eventually gets a _value_.

- **Name a variable by its type: `str`, `num`…**

  Give them a try. A young initiate may wonder – are such names really useful for a ninja? Indeed, they are!

  Sure, the variable name still means something. It says what’s inside the variable: a string, a number or something else. But when an outsider tries to understand the code, they’ll be surprised to see that there’s actually no information at all! And will ultimately fail to alter your well-thought code.

  The value type is easy to find out by debugging. But what’s the meaning of the variable? Which string/number does it store?

  There’s just no way to figure out without a good meditation!

- **…But what if there are no more such names?** Just add a number: `data1, item2, elem5`…

## Attention test

Only a truly attentive programmer should be able to understand your code. But how to check that?

**One of the ways – use similar variable names, like `date` and `data`.**

Mix them where you can.

A quick read of such code becomes impossible. And when there’s a typo… Ummm… We’re stuck for long, time to drink tea.

## Smart synonyms

Using _similar_ names for _same_ things makes life more interesting and shows your creativity to the public.

For instance, consider function prefixes. If a function shows a message on the screen – start it with `display…`, like `displayMessage`. And then if another function shows on the screen something else, like a user name, start it with `show…` (like `showName`).

Insinuate that there’s a subtle difference between such functions, while there is none.

Make a pact with fellow ninjas of the team: if John starts “showing” functions with `display...` in his code, then Peter could use `render..`, and Ann – `paint...`. Note how much more interesting and diverse the code became.

…And now the hat trick!

For two functions with important differences – use the same prefix!

For instance, the function `printPage(page)` will use a printer. And the function `printText(text)` will put the text on-screen. Let an unfamiliar reader think well over similarly named function `printMessage`: “Where does it put the message? To a printer or on the screen?”. To make it really shine, `printMessage(message)` should output it in the new window!

## Reuse names

Add a new variable only when absolutely necessary.

Instead, reuse existing names. Just write new values into them.

In a function try to use only variables passed as parameters.

That would make it really hard to identify what’s exactly in the variable _now_. And also where it comes from. The purpose is to develop the intuition and memory of a person reading the code. A person with weak intuition would have to analyze the code line-by-line and track the changes through every code branch.

**An advanced variant of the approach is to covertly (!) replace the value with something alike in the middle of a loop or a function.**

For instance:

    function ninjaFunction(elem) {
      // 20 lines of code working with elem

      elem = clone(elem);

      // 20 more lines, now working with the clone of the elem!
    }

A fellow programmer who wants to work with `elem` in the second half of the function will be surprised… Only during the debugging, after examining the code they will find out that they’re working with a clone!

Seen in code regularly. Deadly effective even against an experienced ninja.

## Underscores for fun

Put underscores `_` and `__` before variable names. Like `_name` or `__value`. It would be great if only you knew their meaning. Or, better, add them just for fun, without particular meaning at all. Or different meanings in different places.

You kill two rabbits with one shot. First, the code becomes longer and less readable, and the second, a fellow developer may spend a long time trying to figure out what the underscores mean.

A smart ninja puts underscores at one spot of code and evades them at other places. That makes the code even more fragile and increases the probability of future errors.

## Show your love

Let everyone see how magnificent your entities are! Names like `superElement`, `megaFrame` and `niceItem` will definitely enlighten a reader.

Indeed, from one hand, something is written: `super..`, `mega..`, `nice..` But from the other hand – that brings no details. A reader may decide to look for a hidden meaning and meditate for an hour or two of their paid working time.

## Overlap outer variables

Use same names for variables inside and outside a function. As simple. No efforts to invent new names.

    let *!*user*/!* = authenticateUser();

    function render() {
      let *!*user*/!* = anotherValue();
      ...
      ...many lines...
      ...
      ... // <-- a programmer wants to work with user here and...
      ...
    }

A programmer who jumps inside the `render` will probably fail to notice that there’s a local `user` shadowing the outer one.

Then they’ll try to work with `user` assuming that it’s the external variable, the result of `authenticateUser()`… The trap is sprung! Hello, debugger…

## Side-effects everywhere!

There are functions that look like they don’t change anything. Like `isReady()`, `checkPermission()`, `findTags()`… They are assumed to carry out calculations, find and return the data, without changing anything outside of them. In other words, without “side-effects”.

**A really beautiful trick is to add a “useful” action to them, besides the main task.**

An expression of dazed surprise on the face of your colleague when they see a function named `is..`, `check..` or `find...` changing something – will definitely broaden your boundaries of reason.

**Another way to surprise is to return a non-standard result.**

Show your original thinking! Let the call of `checkPermission` return not `true/false`, but a complex object with the results of the check.

Those developers who try to write `if (checkPermission(..))`, will wonder why it doesn’t work. Tell them: “Read the docs!”. And give this article.

## Powerful functions!

Don’t limit the function by what’s written in its name. Be broader.

For instance, a function `validateEmail(email)` could (besides checking the email for correctness) show an error message and ask to re-enter the email.

Additional actions should not be obvious from the function name. A true ninja coder will make them not obvious from the code as well.

**Joining several actions into one protects your code from reuse.**

Imagine, another developer wants only to check the email, and not output any message. Your function `validateEmail(email)` that does both will not suit them. So they won’t break your meditation by asking anything about it.

## Summary

All “pieces of advice” above are from the real code… Sometimes, written by experienced developers. Maybe even more experienced than you are ;)

- Follow some of them, and your code will become full of surprises.
- Follow many of them, and your code will become truly yours, no one would want to change it.
- Follow all, and your code will become a valuable lesson for young developers looking for enlightenment. \# Automated testing with Mocha

Automated testing will be used in further tasks, and it’s also widely used in real projects.

## Why do we need tests?

When we write a function, we can usually imagine what it should do: which parameters give which results.

During development, we can check the function by running it and comparing the outcome with the expected one. For instance, we can do it in the console.

If something is wrong – then we fix the code, run again, check the result – and so on till it works.

But such manual “re-runs” are imperfect.

**When testing a code by manual re-runs, it’s easy to miss something.**

For instance, we’re creating a function `f`. Wrote some code, testing: `f(1)` works, but `f(2)` doesn’t work. We fix the code and now `f(2)` works. Looks complete? But we forgot to re-test `f(1)`. That may lead to an error.

That’s very typical. When we develop something, we keep a lot of possible use cases in mind. But it’s hard to expect a programmer to check all of them manually after every change. So it becomes easy to fix one thing and break another one.

**Automated testing means that tests are written separately, in addition to the code. They run our functions in various ways and compare results with the expected.**

## Behavior Driven Development (BDD)

Let’s start with a technique named [Behavior Driven Development](http://en.wikipedia.org/wiki/Behavior-driven_development) or, in short, BDD.

**BDD is three things in one: tests AND documentation AND examples.**

To understand BDD, we’ll examine a practical case of development.

## Development of “pow”: the spec

Let’s say we want to make a function `pow(x, n)` that raises `x` to an integer power `n`. We assume that `n≥0`.

That task is just an example: there’s the `**` operator in JavaScript that can do that, but here we concentrate on the development flow that can be applied to more complex tasks as well.

Before creating the code of `pow`, we can imagine what the function should do and describe it.

Such description is called a _specification_ or, in short, a spec, and contains descriptions of use cases together with tests for them, like this:

    describe("pow", function() {

      it("raises to n-th power", function() {
        assert.equal(pow(2, 3), 8);
      });

    });

A spec has three main building blocks that you can see above:

`describe("title", function() { ... })`  
What functionality we’re describing. In our case we’re describing the function `pow`. Used to group “workers” – the `it` blocks.

`it("use case description", function() { ... })`  
In the title of `it` we _in a human-readable way_ describe the particular use case, and the second argument is a function that tests it.

`assert.equal(value1, value2)`  
The code inside `it` block, if the implementation is correct, should execute without errors.

Functions `assert.*` are used to check whether `pow` works as expected. Right here we’re using one of them – `assert.equal`, it compares arguments and yields an error if they are not equal. Here it checks that the result of `pow(2, 3)` equals `8`. There are other types of comparisons and checks, that we’ll add later.

The specification can be executed, and it will run the test specified in `it` block. We’ll see that later.

## The development flow

The flow of development usually looks like this:

1.  An initial spec is written, with tests for the most basic functionality.
2.  An initial implementation is created.
3.  To check whether it works, we run the testing framework [Mocha](http://mochajs.org/) (more details soon) that runs the spec. While the functionality is not complete, errors are displayed. We make corrections until everything works.
4.  Now we have a working initial implementation with tests.
5.  We add more use cases to the spec, probably not yet supported by the implementations. Tests start to fail.
6.  Go to 3, update the implementation till tests give no errors.
7.  Repeat steps 3-6 till the functionality is ready.

So, the development is _iterative_. We write the spec, implement it, make sure tests pass, then write more tests, make sure they work etc. At the end we have both a working implementation and tests for it.

Let’s see this development flow in our practical case.

The first step is already complete: we have an initial spec for `pow`. Now, before making the implementation, let’s use few JavaScript libraries to run the tests, just to see that they are working (they will all fail).

## The spec in action

Here in the tutorial we’ll be using the following JavaScript libraries for tests:

- [Mocha](http://mochajs.org/) – the core framework: it provides common testing functions including `describe` and `it` and the main function that runs tests.
- [Chai](http://chaijs.com) – the library with many assertions. It allows to use a lot of different assertions, for now we need only `assert.equal`.
- [Sinon](http://sinonjs.org/) – a library to spy over functions, emulate built-in functions and more, we’ll need it much later.

These libraries are suitable for both in-browser and server-side testing. Here we’ll consider the browser variant.

The full HTML page with these frameworks and `pow` spec:

`html src="index.html"`

The page can be divided into five parts:

1.  The `<head>` – add third-party libraries and styles for tests.
2.  The `<script>` with the function to test, in our case – with the code for `pow`.
3.  The tests – in our case an external script `test.js` that has `describe("pow", ...)` from above.
4.  The HTML element `<div id="mocha">` will be used by Mocha to output results.
5.  The tests are started by the command `mocha.run()`.

The result:

\[iframe height=250 src=“pow-1” border=1 edit\]

As of now, the test fails, there’s an error. That’s logical: we have an empty function code in `pow`, so `pow(2,3)` returns `undefined` instead of `8`.

For the future, let’s note that there are more high-level test-runners, like [karma](https://karma-runner.github.io/) and others, that make it easy to autorun many different tests.

## Initial implementation

Let’s make a simple implementation of `pow`, for tests to pass:

    function pow(x, n) {
      return 8; // :) we cheat!
    }

Wow, now it works!

\[iframe height=250 src=“pow-min” border=1 edit\]

## Improving the spec

What we’ve done is definitely a cheat. The function does not work: an attempt to calculate `pow(3,4)` would give an incorrect result, but tests pass.

…But the situation is quite typical, it happens in practice. Tests pass, but the function works wrong. Our spec is imperfect. We need to add more use cases to it.

Let’s add one more test to check that `pow(3, 4) = 81`.

We can select one of two ways to organize the test here:

1.  The first variant – add one more `assert` into the same `it`:

        describe("pow", function() {

          it("raises to n-th power", function() {
            assert.equal(pow(2, 3), 8);
        *!*
            assert.equal(pow(3, 4), 81);
        */!*
          });

        });

2.  The second – make two tests:

        describe("pow", function() {

          it("2 raised to power 3 is 8", function() {
            assert.equal(pow(2, 3), 8);
          });

          it("3 raised to power 4 is 81", function() {
            assert.equal(pow(3, 4), 81);
          });

        });

The principal difference is that when `assert` triggers an error, the `it` block immediately terminates. So, in the first variant if the first `assert` fails, then we’ll never see the result of the second `assert`.

Making tests separate is useful to get more information about what’s going on, so the second variant is better.

And besides that, there’s one more rule that’s good to follow.

**One test checks one thing.**

If we look at the test and see two independent checks in it, it’s better to split it into two simpler ones.

So let’s continue with the second variant.

The result:

\[iframe height=250 src=“pow-2” edit border=“1”\]

As we could expect, the second test failed. Sure, our function always returns `8`, while the `assert` expects `81`.

## Improving the implementation

Let’s write something more real for tests to pass:

    function pow(x, n) {
      let result = 1;

      for (let i = 0; i < n; i++) {
        result *= x;
      }

      return result;
    }

To be sure that the function works well, let’s test it for more values. Instead of writing `it` blocks manually, we can generate them in `for`:

    describe("pow", function() {

      function makeTest(x) {
        let expected = x * x * x;
        it(`${x} in the power 3 is ${expected}`, function() {
          assert.equal(pow(x, 3), expected);
        });
      }

      for (let x = 1; x <= 5; x++) {
        makeTest(x);
      }

    });

The result:

\[iframe height=250 src=“pow-3” edit border=“1”\]

## Nested describe

We’re going to add even more tests. But before that let’s note that the helper function `makeTest` and `for` should be grouped together. We won’t need `makeTest` in other tests, it’s needed only in `for`: their common task is to check how `pow` raises into the given power.

Grouping is done with a nested `describe`:

    describe("pow", function() {

    *!*
      describe("raises x to power 3", function() {
    */!*

        function makeTest(x) {
          let expected = x * x * x;
          it(`${x} in the power 3 is ${expected}`, function() {
            assert.equal(pow(x, 3), expected);
          });
        }

        for (let x = 1; x <= 5; x++) {
          makeTest(x);
        }

    *!*
      });
    */!*

      // ... more tests to follow here, both describe and it can be added
    });

The nested `describe` defines a new “subgroup” of tests. In the output we can see the titled indentation:

\[iframe height=250 src=“pow-4” edit border=“1”\]

In the future we can add more `it` and `describe` on the top level with helper functions of their own, they won’t see `makeTest`.

\`\`\``smart header="`before/after`and`beforeEach/afterEach`" We can setup`before/after`functions that execute before/after running tests, and also`beforeEach/afterEach`functions that execute before/after *every*`it\`.

For instance:

\`\`\`js no-beautify describe(“test”, function() {

before(() =&gt; alert(“Testing started – before all tests”)); after(() =&gt; alert(“Testing finished – after all tests”));

beforeEach(() =&gt; alert(“Before a test – enter a test”)); afterEach(() =&gt; alert(“After a test – exit a test”));

it(‘test 1’, () =&gt; alert(1)); it(‘test 2’, () =&gt; alert(2));

});

    The running sequence will be:

Testing started – before all tests (before) Before a test – enter a test (beforeEach) 1 After a test – exit a test (afterEach) Before a test – enter a test (beforeEach) 2 After a test – exit a test (afterEach) Testing finished – after all tests (after)

    [edit src="beforeafter" title="Open the example in the sandbox."]

    Usually, `beforeEach/afterEach` and `before/after` are used to perform initialization, zero out counters or do something else between the tests (or test groups).

## Extending the spec

The basic functionality of `pow` is complete. The first iteration of the development is done. When we’re done celebrating and drinking champagne – let’s go on and improve it.

As it was said, the function `pow(x, n)` is meant to work with positive integer values `n`.

To indicate a mathematical error, JavaScript functions usually return `NaN`. Let’s do the same for invalid values of `n`.

Let’s first add the behavior to the spec(!):

    describe("pow", function() {

      // ...

      it("for negative n the result is NaN", function() {
    *!*
        assert.isNaN(pow(2, -1));
    */!*
      });

      it("for non-integer n the result is NaN", function() {
    *!*
        assert.isNaN(pow(2, 1.5));
    */!*
      });

    });

The result with new tests:

\[iframe height=530 src=“pow-nan” edit border=“1”\]

The newly added tests fail, because our implementation does not support them. That’s how BDD is done: first we write failing tests, and then make an implementation for them.

\`\``smart header="Other assertions" Please note the assertion`assert.isNaN`: it checks for`NaN\`.

There are other assertions in [Chai](http://chaijs.com) as well, for instance:

- `assert.equal(value1, value2)` – checks the equality `value1 == value2`.
- `assert.strictEqual(value1, value2)` – checks the strict equality `value1 === value2`.
- `assert.notEqual`, `assert.notStrictEqual` – inverse checks to the ones above.
- `assert.isTrue(value)` – checks that `value === true`
- `assert.isFalse(value)` – checks that `value === false`
- …the full list is in the [docs](http://chaijs.com/api/assert/) \`\`\`

So we should add a couple of lines to `pow`:

    function pow(x, n) {
    *!*
      if (n < 0) return NaN;
      if (Math.round(n) != n) return NaN;
    */!*

      let result = 1;

      for (let i = 0; i < n; i++) {
        result *= x;
      }

      return result;
    }

Now it works, all tests pass:

\[iframe height=300 src=“pow-full” edit border=“1”\]

\[edit src=“pow-full” title=“Open the full final example in the sandbox.”\]

## Summary

In BDD, the spec goes first, followed by implementation. At the end we have both the spec and the code.

The spec can be used in three ways:

1.  As **Tests** - they guarantee that the code works correctly.
2.  As **Docs** – the titles of `describe` and `it` tell what the function does.
3.  As **Examples** – the tests are actually working examples showing how a function can be used.

With the spec, we can safely improve, change, even rewrite the function from scratch and make sure it still works right.

That’s especially important in large projects when a function is used in many places. When we change such a function, there’s just no way to manually check if every place that uses it still works right.

Without tests, people have two ways:

1.  To perform the change, no matter what. And then our users meet bugs, as we probably fail to check something manually.
2.  Or, if the punishment for errors is harsh, as there are no tests, people become afraid to modify such functions, and then the code becomes outdated, no one wants to get into it. Not good for development.

**Automatic testing helps to avoid these problems!**

If the project is covered with tests, there’s just no such problem. After any changes, we can run tests and see a lot of checks made in a matter of seconds.

**Besides, a well-tested code has better architecture.**

Naturally, that’s because auto-tested code is easier to modify and improve. But there’s also another reason.

To write tests, the code should be organized in such a way that every function has a clearly described task, well-defined input and output. That means a good architecture from the beginning.

In real life that’s sometimes not that easy. Sometimes it’s difficult to write a spec before the actual code, because it’s not yet clear how it should behave. But in general writing tests makes development faster and more stable.

Later in the tutorial you will meet many tasks with tests baked-in. So you’ll see more practical examples.

Writing tests requires good JavaScript knowledge. But we’re just starting to learn it. So, to settle down everything, as of now you’re not required to write tests, but you should already be able to read them even if they are a little bit more complex than in this chapter.

# Polyfills and transpilers

The JavaScript language steadily evolves. New proposals to the language appear regularly, they are analyzed and, if considered worthy, are appended to the list at <a href="https://tc39.github.io/ecma262/" class="uri">https://tc39.github.io/ecma262/</a> and then progress to the [specification](http://www.ecma-international.org/publications/standards/Ecma-262.htm).

Teams behind JavaScript engines have their own ideas about what to implement first. They may decide to implement proposals that are in draft and postpone things that are already in the spec, because they are less interesting or just harder to do.

So it’s quite common for an engine to implement only the part of the standard.

A good page to see the current state of support for language features is <a href="https://kangax.github.io/compat-table/es6/" class="uri">https://kangax.github.io/compat-table/es6/</a> (it’s big, we have a lot to study yet).

As programmers, we’d like to use most recent features. The more good stuff - the better!

On the other hand, how to make our modern code work on older engines that don’t understand recent features yet?

There are two tools for that:

1.  Transpilers.
2.  Polyfills.

Here, in this chapter, our purpose is to get the gist of how they work, and their place in web development.

## Transpilers

A [transpiler](https://en.wikipedia.org/wiki/Source-to-source_compiler) is a special piece of software that can parse (“read and understand”) modern code, and rewrite it using older syntax constructs, so that the result would be the same.

E.g. JavaScript before year 2020 didn’t have the “nullish coalescing operator” `??`. So, if a visitor uses an outdated browser, it may fail to understand the code like `height = height ?? 100`.

A transpiler would analyze our code and rewrite `height ?? 100` into `(height !== undefined && height !== null) ? height : 100`.

    // before running the transpiler
    height = height ?? 100;

    // after running the transpiler
    height = (height !== undefined && height !== null) ? height : 100;

Now the rewritten code is suitable for older JavaScript engines.

Usually, a developer runs the transpiler on their own computer, and then deploys the transpiled code to the server.

Speaking of names, [Babel](https://babeljs.io) is one of the most prominent transpilers out there.

Modern project build systems, such as [webpack](http://webpack.github.io/), provide means to run transpiler automatically on every code change, so it’s very easy to integrate into development process.

## Polyfills

New language features may include not only syntax constructs and operators, but also built-in functions.

For example, `Math.trunc(n)` is a function that “cuts off” the decimal part of a number, e.g `Math.trunc(1.23)` returns `1`.

In some (very outdated) JavaScript engines, there’s no `Math.trunc`, so such code will fail.

As we’re talking about new functions, not syntax changes, there’s no need to transpile anything here. We just need to declare the missing function.

A script that updates/adds new functions is called “polyfill”. It “fills in” the gap and adds missing implementations.

For this particular case, the polyfill for `Math.trunc` is a script that implements it, like this:

    if (!Math.trunc) { // if no such function
      // implement it
      Math.trunc = function(number) {
        // Math.ceil and Math.floor exist even in ancient JavaScript engines
        // they are covered later in the tutorial
        return number < 0 ? Math.ceil(number) : Math.floor(number);
      };
    }

JavaScript is a highly dynamic language, scripts may add/modify any functions, even including built-in ones.

Two interesting libraries of polyfills are: - [core js](https://github.com/zloirock/core-js) that supports a lot, allows to include only needed features. - [polyfill.io](http://polyfill.io) service that provides a script with polyfills, depending on the features and user’s browser.

## Summary

In this chapter we’d like to motivate you to study modern and even “bleeding-edge” language features, even if they aren’t yet well-supported by JavaScript engines.

Just don’t forget to use transpiler (if using modern syntax or operators) and polyfills (to add functions that may be missing). And they’ll ensure that the code works.

For example, later when you’re familiar with JavaScript, you can setup a code build system based on [webpack](http://webpack.github.io/) with [babel-loader](https://github.com/babel/babel-loader) plugin.

Good resources that show the current state of support for various features: - <a href="https://kangax.github.io/compat-table/es6/" class="uri">https://kangax.github.io/compat-table/es6/</a> - for pure JavaScript. - <a href="https://caniuse.com/" class="uri">https://caniuse.com/</a> - for browser-related functions.

P.S. Google Chrome is usually the most up-to-date with language features, try it if a tutorial demo fails. Most tutorial demos work with any modern browser though.

# Objects

As we know from the chapter <a href="info:types" class="uri">info:types</a>, there are eight data types in JavaScript. Seven of them are called “primitive”, because their values contain only a single thing (be it a string or a number or whatever).

In contrast, objects are used to store keyed collections of various data and more complex entities. In JavaScript, objects penetrate almost every aspect of the language. So we must understand them first before going in-depth anywhere else.

An object can be created with figure brackets `{…}` with an optional list of _properties_. A property is a “key: value” pair, where `key` is a string (also called a “property name”), and `value` can be anything.

We can imagine an object as a cabinet with signed files. Every piece of data is stored in its file by the key. It’s easy to find a file by its name or add/remove a file.

![](object.svg)

An empty object (“empty cabinet”) can be created using one of two syntaxes:

    let user = new Object(); // "object constructor" syntax
    let user = {};  // "object literal" syntax

![](object-user-empty.svg)

Usually, the figure brackets `{...}` are used. That declaration is called an _object literal_.

## Literals and properties

We can immediately put some properties into `{...}` as “key: value” pairs:

    let user = {     // an object
      name: "John",  // by key "name" store value "John"
      age: 30        // by key "age" store value 30
    };

A property has a key (also known as “name” or “identifier”) before the colon `":"` and a value to the right of it.

In the `user` object, there are two properties:

1.  The first property has the name `"name"` and the value `"John"`.
2.  The second one has the name `"age"` and the value `30`.

The resulting `user` object can be imagined as a cabinet with two signed files labeled “name” and “age”.

![user object](object-user.svg)

We can add, remove and read files from it any time.

Property values are accessible using the dot notation:

    // get property values of the object:
    alert( user.name ); // John
    alert( user.age ); // 30

The value can be of any type. Let’s add a boolean one:

    user.isAdmin = true;

![user object 2](object-user-isadmin.svg)

To remove a property, we can use `delete` operator:

    delete user.age;

![user object 3](object-user-delete.svg)

We can also use multiword property names, but then they must be quoted:

    let user = {
      name: "John",
      age: 30,
      "likes birds": true  // multiword property name must be quoted
    };

![](object-user-props.svg)

The last property in the list may end with a comma:

    let user = {
      name: "John",
      age: 30*!*,*/!*
    }

That is called a “trailing” or “hanging” comma. Makes it easier to add/remove/move around properties, because all lines become alike.

## Square brackets

For multiword properties, the dot access doesn’t work:

`js run // this would give a syntax error user.likes birds = true`

JavaScript doesn’t understand that. It thinks that we address `user.likes`, and then gives a syntax error when comes across unexpected `birds`.

The dot requires the key to be a valid variable identifier. That implies: contains no spaces, doesn’t start with a digit and doesn’t include special characters (`$` and `_` are allowed).

There’s an alternative “square bracket notation” that works with any string:

\`\`\`js run let user = {};

// set user\[“likes birds”\] = true;

// get alert(user\[“likes birds”\]); // true

// delete delete user\[“likes birds”\]; \`\`\`

Now everything is fine. Please note that the string inside the brackets is properly quoted (any type of quotes will do).

Square brackets also provide a way to obtain the property name as the result of any expression – as opposed to a literal string – like from a variable as follows:

    let key = "likes birds";

    // same as user["likes birds"] = true;
    user[key] = true;

Here, the variable `key` may be calculated at run-time or depend on the user input. And then we use it to access the property. That gives us a great deal of flexibility.

For instance:

\`\`\`js run let user = { name: “John”, age: 30 };

let key = prompt(“What do you want to know about the user?”, “name”);

// access by variable alert( user\[key\] ); // John (if enter “name”) \`\`\`

The dot notation cannot be used in a similar way:

\`\`\`js run let user = { name: “John”, age: 30 };

let key = “name”; alert( user.key ) // undefined \`\`\`

### Computed properties

We can use square brackets in an object literal, when creating an object. That’s called _computed properties_.

For instance:

\`\`\`js run let fruit = prompt(“Which fruit to buy?”, “apple”);

let bag = { _!_ \[fruit\]: 5, // the name of the property is taken from the variable fruit _/!_ };

alert( bag.apple ); // 5 if fruit=“apple” \`\`\`

The meaning of a computed property is simple: `[fruit]` means that the property name should be taken from `fruit`.

So, if a visitor enters `"apple"`, `bag` will become `{apple: 5}`.

Essentially, that works the same as: \`\`\`js run let fruit = prompt(“Which fruit to buy?”, “apple”); let bag = {};

// take property name from the fruit variable bag\[fruit\] = 5; \`\`\`

…But looks nicer.

We can use more complex expressions inside square brackets:

    let fruit = 'apple';
    let bag = {
      [fruit + 'Computers']: 5 // bag.appleComputers = 5
    };

Square brackets are much more powerful than the dot notation. They allow any property names and variables. But they are also more cumbersome to write.

So most of the time, when property names are known and simple, the dot is used. And if we need something more complex, then we switch to square brackets.

## Property value shorthand

In real code we often use existing variables as values for property names.

For instance:

\`\`\`js run function makeUser(name, age) { return { name: name, age: age, // …other properties }; }

let user = makeUser(“John”, 30); alert(user.name); // John \`\`\`

In the example above, properties have the same names as variables. The use-case of making a property from a variable is so common, that there’s a special _property value shorthand_ to make it shorter.

Instead of `name:name` we can just write `name`, like this:

    function makeUser(name, age) {
    *!*
      return {
        name, // same as name: name
        age,  // same as age: age
        // ...
      };
    */!*
    }

We can use both normal properties and shorthands in the same object:

    let user = {
      name,  // same as name:name
      age: 30
    };

## Property names limitations

As we already know, a variable cannot have a name equal to one of language-reserved words like “for”, “let”, “return” etc.

But for an object property, there’s no such restriction:

\`\`\`js run // these properties are all right let obj = { for: 1, let: 2, return: 3 };

alert( obj.for + obj.let + obj.return ); // 6 \`\`\`

In short, there are no limitations on property names. They can be any strings or symbols (a special type for identifiers, to be covered later).

Other types are automatically converted to strings.

For instance, a number `0` becomes a string `"0"` when used as a property key:

\`\`\`js run let obj = { 0: “test” // same as “0”: “test” };

// both alerts access the same property (the number 0 is converted to string “0”) alert( obj\[“0”\] ); // test alert( obj\[0\] ); // test (same property) \`\`\`

There’s a minor gotcha with a special property named `__proto__`. We can’t set it to a non-object value:

`js run let obj = {}; obj.__proto__ = 5; // assign a number alert(obj.__proto__); // [object Object] - the value is an object, didn't work as intended`

As we see from the code, the assignment to a primitive `5` is ignored.

We’ll cover the special nature of `__proto__` in [subsequent chapters](info:prototype-inheritance), and suggest the [ways to fix](info:prototype-methods) such behavior.

## Property existence test, “in” operator

A notable feature of objects in JavaScript, compared to many other languages, is that it’s possible to access any property. There will be no error if the property doesn’t exist!

Reading a non-existing property just returns `undefined`. So we can easily test whether the property exists:

\`\`\`js run let user = {};

alert( user.noSuchProperty === undefined ); // true means “no such property” \`\`\`

There’s also a special operator `"in"` for that.

The syntax is:

    "key" in object

For instance:

\`\`\`js run let user = { name: “John”, age: 30 };

alert( “age” in user ); // true, user.age exists alert( “blabla” in user ); // false, user.blabla doesn’t exist \`\`\`

Please note that on the left side of `in` there must be a _property name_. That’s usually a quoted string.

If we omit quotes, that means a variable, it should contain the actual name to be tested. For instance:

\`\`\`js run let user = { age: 30 };

let key = “age”; alert( *!*key*/!* in user ); // true, property “age” exists \`\`\`

Why does the `in` operator exist? Isn’t it enough to compare against `undefined`?

Well, most of the time the comparison with `undefined` works fine. But there’s a special case when it fails, but `"in"` works correctly.

It’s when an object property exists, but stores `undefined`:

\`\`\`js run let obj = { test: undefined };

alert( obj.test ); // it’s undefined, so - no such property?

alert( “test” in obj ); // true, the property does exist! \`\`\`

In the code above, the property `obj.test` technically exists. So the `in` operator works right.

Situations like this happen very rarely, because `undefined` should not be explicitly assigned. We mostly use `null` for “unknown” or “empty” values. So the `in` operator is an exotic guest in the code.

## The “for..in” loop

To walk over all keys of an object, there exists a special form of the loop: `for..in`. This is a completely different thing from the `for(;;)` construct that we studied before.

The syntax:

    for (key in object) {
      // executes the body for each key among object properties
    }

For instance, let’s output all properties of `user`:

\`\`\`js run let user = { name: “John”, age: 30, isAdmin: true };

for (let key in user) { // keys alert( key ); // name, age, isAdmin // values for the keys alert( user\[key\] ); // John, 30, true } \`\`\`

Note that all “for” constructs allow us to declare the looping variable inside the loop, like `let key` here.

Also, we could use another variable name here instead of `key`. For instance, `"for (let prop in obj)"` is also widely used.

### Ordered like an object

Are objects ordered? In other words, if we loop over an object, do we get all properties in the same order they were added? Can we rely on this?

The short answer is: “ordered in a special fashion”: integer properties are sorted, others appear in creation order. The details follow.

As an example, let’s consider an object with the phone codes:

\`\`\`js run let codes = { “49”: “Germany”, “41”: “Switzerland”, “44”: “Great Britain”, // .., “1”: “USA” };

_!_ for (let code in codes) { alert(code); // 1, 41, 44, 49 } _/!_ \`\`\`

The object may be used to suggest a list of options to the user. If we’re making a site mainly for German audience then we probably want `49` to be the first.

But if we run the code, we see a totally different picture:

- USA (1) goes first
- then Switzerland (41) and so on.

The phone codes go in the ascending sorted order, because they are integers. So we see `1, 41, 44, 49`.

\`\`\`\`smart header=“Integer properties? What’s that?” The “integer property” term here means a string that can be converted to-and-from an integer without a change.

So, “49” is an integer property name, because when it’s transformed to an integer number and back, it’s still the same. But “+49” and “1.2” are not:

`js run // Math.trunc is a built-in function that removes the decimal part alert( String(Math.trunc(Number("49"))) ); // "49", same, integer property alert( String(Math.trunc(Number("+49"))) ); // "49", not same "+49" ⇒ not integer property alert( String(Math.trunc(Number("1.2"))) ); // "1", not same "1.2" ⇒ not integer property` \`\`\`\`

…On the other hand, if the keys are non-integer, then they are listed in the creation order, for instance:

\`\`\`js run let user = { name: “John”, surname: “Smith” }; user.age = 25; // add one more

_!_ // non-integer properties are listed in the creation order _/!_ for (let prop in user) { alert( prop ); // name, surname, age } \`\`\`

So, to fix the issue with the phone codes, we can “cheat” by making the codes non-integer. Adding a plus `"+"` sign before each code is enough.

Like this:

\`\`\`js run let codes = { “+49”: “Germany”, “+41”: “Switzerland”, “+44”: “Great Britain”, // .., “+1”: “USA” };

for (let code in codes) { alert( +code ); // 49, 41, 44, 1 } \`\`\`

Now it works as intended.

## Summary

Objects are associative arrays with several special features.

They store properties (key-value pairs), where: - Property keys must be strings or symbols (usually strings). - Values can be of any type.

To access a property, we can use: - The dot notation: `obj.property`. - Square brackets notation `obj["property"]`. Square brackets allow to take the key from a variable, like `obj[varWithKey]`.

Additional operators: - To delete a property: `delete obj.prop`. - To check if a property with the given key exists: `"key" in obj`. - To iterate over an object: `for (let key in obj)` loop.

What we’ve studied in this chapter is called a “plain object”, or just `Object`.

There are many other kinds of objects in JavaScript:

- `Array` to store ordered data collections,
- `Date` to store the information about the date and time,
- `Error` to store the information about an error.
- …And so on.

They have their special features that we’ll study later. Sometimes people say something like “Array type” or “Date type”, but formally they are not types of their own, but belong to a single “object” data type. And they extend it in various ways.

Objects in JavaScript are very powerful. Here we’ve just scratched the surface of a topic that is really huge. We’ll be closely working with objects and learning more about them in further parts of the tutorial. \# Code editors

A code editor is the place where programmers spend most of their time.

There are two main types of code editors: IDEs and lightweight editors. Many people use one tool of each type.

## IDE

The term [IDE](https://en.wikipedia.org/wiki/Integrated_development_environment) (Integrated Development Environment) refers to a powerful editor with many features that usually operates on a “whole project.” As the name suggests, it’s not just an editor, but a full-scale “development environment.”

An IDE loads the project (which can be many files), allows navigation between files, provides autocompletion based on the whole project (not just the open file), and integrates with a version management system (like [git](https://git-scm.com/)), a testing environment, and other “project-level” stuff.

If you haven’t selected an IDE yet, consider the following options:

- [Visual Studio Code](https://code.visualstudio.com/) (cross-platform, free).
- [WebStorm](http://www.jetbrains.com/webstorm/) (cross-platform, paid).

For Windows, there’s also “Visual Studio”, not to be confused with “Visual Studio Code”. “Visual Studio” is a paid and mighty Windows-only editor, well-suited for the .NET platform. It’s also good at JavaScript. There’s also a free version [Visual Studio Community](https://www.visualstudio.com/vs/community/).

Many IDEs are paid, but have a trial period. Their cost is usually negligible compared to a qualified developer’s salary, so just choose the best one for you.

## Lightweight editors

“Lightweight editors” are not as powerful as IDEs, but they’re fast, elegant and simple.

They are mainly used to open and edit a file instantly.

The main difference between a “lightweight editor” and an “IDE” is that an IDE works on a project-level, so it loads much more data on start, analyzes the project structure if needed and so on. A lightweight editor is much faster if we need only one file.

In practice, lightweight editors may have a lot of plugins including directory-level syntax analyzers and autocompleters, so there’s no strict border between a lightweight editor and an IDE.

The following options deserve your attention:

- [Atom](https://atom.io/) (cross-platform, free).
- [Visual Studio Code](https://code.visualstudio.com/) (cross-platform, free).
- [Sublime Text](http://www.sublimetext.com) (cross-platform, shareware).
- [Notepad++](https://notepad-plus-plus.org/) (Windows, free).
- [Vim](http://www.vim.org/) and [Emacs](https://www.gnu.org/software/emacs/) are also cool if you know how to use them.

## Let’s not argue

The editors in the lists above are those that either I or my friends whom I consider good developers have been using for a long time and are happy with.

There are other great editors in our big world. Please choose the one you like the most.

The choice of an editor, like any other tool, is individual and depends on your projects, habits, and personal preferences. \# Object references and copying

One of the fundamental differences of objects versus primitives is that objects are stored and copied “by reference”, whereas primitive values: strings, numbers, booleans, etc – are always copied “as a whole value”.

That’s easy to understand if we look a bit under the hood of what happens when we copy a value.

Let’s start with a primitive, such as a string.

Here we put a copy of `message` into `phrase`:

    let message = "Hello!";
    let phrase = message;

As a result we have two independent variables, each one storing the string `"Hello!"`.

![](variable-copy-value.svg)

Quite an obvious result, right?

Objects are not like that.

**A variable assigned to an object stores not the object itself, but its “address in memory” – in other words “a reference” to it.**

Let’s look at an example of such a variable:

    let user = {
      name: "John"
    };

And here’s how it’s actually stored in memory:

![](variable-contains-reference.svg)

The object is stored somewhere in memory (at the right of the picture), while the `user` variable (at the left) has a “reference” to it.

We may think of an object variable, such as `user`, as like a sheet of paper with the address of the object on it.

When we perform actions with the object, e.g. take a property `user.name`, the JavaScript engine looks at what’s at that address and performs the operation on the actual object.

Now here’s why it’s important.

**When an object variable is copied, the reference is copied, but the object itself is not duplicated.**

For instance:

\`\`\`js no-beautify let user = { name: “John” };

let admin = user; // copy the reference \`\`\`

Now we have two variables, each storing a reference to the same object:

![](variable-copy-reference.svg)

As you can see, there’s still one object, but now with two variables that reference it.

We can use either variable to access the object and modify its contents:

\`\`\`js run let user = { name: ‘John’ };

let admin = user;

_!_ admin.name = ‘Pete’; // changed by the “admin” reference _/!_

alert(*!*user.name*/!*); // ‘Pete’, changes are seen from the “user” reference \`\`\`

It’s as if we had a cabinet with two keys and used one of them (`admin`) to get into it and make changes. Then, if we later use another key (`user`), we are still opening the same cabinet and can access the changed contents.

## Comparison by reference

Two objects are equal only if they are the same object.

For instance, here `a` and `b` reference the same object, thus they are equal:

\`\`\`js run let a = {}; let b = a; // copy the reference

alert( a == b ); // true, both variables reference the same object alert( a === b ); // true \`\`\`

And here two independent objects are not equal, even though they look alike (both are empty):

\`\`\`js run let a = {}; let b = {}; // two independent objects

alert( a == b ); // false \`\`\`

For comparisons like `obj1 > obj2` or for a comparison against a primitive `obj == 5`, objects are converted to primitives. We’ll study how object conversions work very soon, but to tell the truth, such comparisons are needed very rarely – usually they appear as a result of a programming mistake.

## Cloning and merging, Object.assign \[\#cloning-and-merging-object-assign\]

So, copying an object variable creates one more reference to the same object.

But what if we need to duplicate an object? Create an independent copy, a clone?

That’s also doable, but a little bit more difficult, because there’s no built-in method for that in JavaScript. But there is rarely a need – copying by reference is good most of the time.

But if we really want that, then we need to create a new object and replicate the structure of the existing one by iterating over its properties and copying them on the primitive level.

Like this:

\`\`\`js run let user = { name: “John”, age: 30 };

_!_ let clone = {}; // the new empty object

// let’s copy all user properties into it for (let key in user) { clone\[key\] = user\[key\]; } _/!_

// now clone is a fully independent object with the same content clone.name = “Pete”; // changed the data in it

alert( user.name ); // still John in the original object \`\`\`

Also we can use the method [Object.assign](mdn:js/Object/assign) for that.

The syntax is:

    Object.assign(dest, [src1, src2, src3...])

- The first argument `dest` is a target object.
- Further arguments `src1, ..., srcN` (can be as many as needed) are source objects.
- It copies the properties of all source objects `src1, ..., srcN` into the target `dest`. In other words, properties of all arguments starting from the second are copied into the first object.
- The call returns `dest`.

For instance, we can use it to merge several objects into one:

    let user = { name: "John" };

    let permissions1 = { canView: true };
    let permissions2 = { canEdit: true };

    *!*
    // copies all properties from permissions1 and permissions2 into user
    Object.assign(user, permissions1, permissions2);
    */!*

    // now user = { name: "John", canView: true, canEdit: true }

If the copied property name already exists, it gets overwritten:

\`\`\`js run let user = { name: “John” };

Object.assign(user, { name: “Pete” });

alert(user.name); // now user = { name: “Pete” } \`\`\`

We also can use `Object.assign` to replace `for..in` loop for simple cloning:

    let user = {
      name: "John",
      age: 30
    };

    *!*
    let clone = Object.assign({}, user);
    */!*

It copies all properties of `user` into the empty object and returns it.

There are also other methods of cloning an object, e.g. using the [spread syntax](info:rest-parameters-spread) `clone = {...user}`, covered later in the tutorial.

## Nested cloning

Until now we assumed that all properties of `user` are primitive. But properties can be references to other objects. What to do with them?

Like this: \`\`\`js run let user = { name: “John”, sizes: { height: 182, width: 50 } };

alert( user.sizes.height ); // 182 \`\`\`

Now it’s not enough to copy `clone.sizes = user.sizes`, because the `user.sizes` is an object, it will be copied by reference. So `clone` and `user` will share the same sizes:

Like this:

\`\`\`js run let user = { name: “John”, sizes: { height: 182, width: 50 } };

let clone = Object.assign({}, user);

alert( user.sizes === clone.sizes ); // true, same object

// user and clone share sizes user.sizes.width++; // change a property from one place alert(clone.sizes.width); // 51, see the result from the other one \`\`\`

To fix that, we should use a cloning loop that examines each value of `user[key]` and, if it’s an object, then replicate its structure as well. That is called a “deep cloning”.

We can use recursion to implement it. Or, to not reinvent the wheel, take an existing implementation, for instance [\_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep) from the JavaScript library [lodash](https://lodash.com).

\`\`\``smart header="Const objects can be modified" An important side effect of storing objects as references is that an object declared as`const\` _can_ be modified.

For instance:

\`\`\`js run const user = { name: “John” };

_!_ user.name = “Pete”; // (_)_ /!\*

alert(user.name); // Pete

    It might seem that the line `(*)` would cause an error, but it does not. The value of `user` is constant, it must always reference the same object, but properties of that object are free to change.

    In other words, the `const user` gives an error only if we try to set `user=...` as a whole.

    That said, if we really need to make constant object properties, it's also possible, but using totally different methods. We'll mention that in the chapter <info:property-descriptors>.

## Summary

Objects are assigned and copied by reference. In other words, a variable stores not the “object value”, but a “reference” (address in memory) for the value. So copying such a variable or passing it as a function argument copies that reference, not the object itself.

All operations via copied references (like adding/removing properties) are performed on the same single object.

To make a “real copy” (a clone) we can use `Object.assign` for the so-called “shallow copy” (nested objects are copied by reference) or a “deep cloning” function, such as [\_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep). \# Garbage collection

Memory management in JavaScript is performed automatically and invisibly to us. We create primitives, objects, functions… All that takes memory.

What happens when something is not needed any more? How does the JavaScript engine discover it and clean it up?

## Reachability

The main concept of memory management in JavaScript is _reachability_.

Simply put, “reachable” values are those that are accessible or usable somehow. They are guaranteed to be stored in memory.

1.  There’s a base set of inherently reachable values, that cannot be deleted for obvious reasons.

    For instance:

    - The currently executing function, its local variables and parameters.
    - Other functions on the current chain of nested calls, their local variables and parameters.
    - Global variables.
    - (there are some other, internal ones as well)

    These values are called _roots_.

2.  Any other value is considered reachable if it’s reachable from a root by a reference or by a chain of references.

    For instance, if there’s an object in a global variable, and that object has a property referencing another object, _that_ object is considered reachable. And those that it references are also reachable. Detailed examples to follow.

There’s a background process in the JavaScript engine that is called [garbage collector](<https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)>). It monitors all objects and removes those that have become unreachable.

## A simple example

Here’s the simplest example:

    // user has a reference to the object
    let user = {
      name: "John"
    };

![](memory-user-john.svg)

Here the arrow depicts an object reference. The global variable `"user"` references the object `{name: "John"}` (we’ll call it John for brevity). The `"name"` property of John stores a primitive, so it’s painted inside the object.

If the value of `user` is overwritten, the reference is lost:

    user = null;

![](memory-user-john-lost.svg)

Now John becomes unreachable. There’s no way to access it, no references to it. Garbage collector will junk the data and free the memory.

## Two references

Now let’s imagine we copied the reference from `user` to `admin`:

    // user has a reference to the object
    let user = {
      name: "John"
    };

    *!*
    let admin = user;
    */!*

![](memory-user-john-admin.svg)

Now if we do the same:

    user = null;

…Then the object is still reachable via `admin` global variable, so it’s in memory. If we overwrite `admin` too, then it can be removed.

## Interlinked objects

Now a more complex example. The family:

    function marry(man, woman) {
      woman.husband = man;
      man.wife = woman;

      return {
        father: man,
        mother: woman
      }
    }

    let family = marry({
      name: "John"
    }, {
      name: "Ann"
    });

Function `marry` “marries” two objects by giving them references to each other and returns a new object that contains them both.

The resulting memory structure:

![](family.svg)

As of now, all objects are reachable.

Now let’s remove two references:

    delete family.father;
    delete family.mother.husband;

![](family-delete-refs.svg)

It’s not enough to delete only one of these two references, because all objects would still be reachable.

But if we delete both, then we can see that John has no incoming reference any more:

![](family-no-father.svg)

Outgoing references do not matter. Only incoming ones can make an object reachable. So, John is now unreachable and will be removed from the memory with all its data that also became unaccessible.

After garbage collection:

![](family-no-father-2.svg)

## Unreachable island

It is possible that the whole island of interlinked objects becomes unreachable and is removed from the memory.

The source object is the same as above. Then:

    family = null;

The in-memory picture becomes:

![](family-no-family.svg)

This example demonstrates how important the concept of reachability is.

It’s obvious that John and Ann are still linked, both have incoming references. But that’s not enough.

The former `"family"` object has been unlinked from the root, there’s no reference to it any more, so the whole island becomes unreachable and will be removed.

## Internal algorithms

The basic garbage collection algorithm is called “mark-and-sweep”.

The following “garbage collection” steps are regularly performed:

- The garbage collector takes roots and “marks” (remembers) them.
- Then it visits and “marks” all references from them.
- Then it visits marked objects and marks _their_ references. All visited objects are remembered, so as not to visit the same object twice in the future.
- …And so on until every reachable (from the roots) references are visited.
- All objects except marked ones are removed.

For instance, let our object structure look like this:

![](garbage-collection-1.svg)

We can clearly see an “unreachable island” to the right side. Now let’s see how “mark-and-sweep” garbage collector deals with it.

The first step marks the roots:

![](garbage-collection-2.svg)

Then their references are marked:

![](garbage-collection-3.svg)

…And their references, while possible:

![](garbage-collection-4.svg)

Now the objects that could not be visited in the process are considered unreachable and will be removed:

![](garbage-collection-5.svg)

We can also imagine the process as spilling a huge bucket of paint from the roots, that flows through all references and marks all reachable objects. The unmarked ones are then removed.

That’s the concept of how garbage collection works. JavaScript engines apply many optimizations to make it run faster and not affect the execution.

Some of the optimizations:

- **Generational collection** – objects are split into two sets: “new ones” and “old ones”. Many objects appear, do their job and die fast, they can be cleaned up aggressively. Those that survive for long enough, become “old” and are examined less often.
- **Incremental collection** – if there are many objects, and we try to walk and mark the whole object set at once, it may take some time and introduce visible delays in the execution. So the engine tries to split the garbage collection into pieces. Then the pieces are executed one by one, separately. That requires some extra bookkeeping between them to track changes, but we have many tiny delays instead of a big one.
- **Idle-time collection** – the garbage collector tries to run only while the CPU is idle, to reduce the possible effect on the execution.

There exist other optimizations and flavours of garbage collection algorithms. As much as I’d like to describe them here, I have to hold off, because different engines implement different tweaks and techniques. And, what’s even more important, things change as engines develop, so studying deeper “in advance”, without a real need is probably not worth that. Unless, of course, it is a matter of pure interest, then there will be some links for you below.

## Summary

The main things to know:

- Garbage collection is performed automatically. We cannot force or prevent it.
- Objects are retained in memory while they are reachable.
- Being referenced is not the same as being reachable (from a root): a pack of interlinked objects can become unreachable as a whole.

Modern engines implement advanced algorithms of garbage collection.

A general book “The Garbage Collection Handbook: The Art of Automatic Memory Management” (R. Jones et al) covers some of them.

If you are familiar with low-level programming, the more detailed information about V8 garbage collector is in the article [A tour of V8: Garbage Collection](http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection).

[V8 blog](https://v8.dev/) also publishes articles about changes in memory management from time to time. Naturally, to learn the garbage collection, you’d better prepare by learning about V8 internals in general and read the blog of [Vyacheslav Egorov](http://mrale.ph) who worked as one of V8 engineers. I’m saying: “V8”, because it is best covered with articles in the internet. For other engines, many approaches are similar, but garbage collection differs in many aspects.

In-depth knowledge of engines is good when you need low-level optimizations. It would be wise to plan that as the next step after you’re familiar with the language.  
\# Object methods, “this”

Objects are usually created to represent entities of the real world, like users, orders and so on:

    let user = {
      name: "John",
      age: 30
    };

And, in the real world, a user can _act_: select something from the shopping cart, login, logout etc.

Actions are represented in JavaScript by functions in properties.

## Method examples

For a start, let’s teach the `user` to say hello:

\`\`\`js run let user = { name: “John”, age: 30 };

_!_ user.sayHi = function() { alert(“Hello!”); }; _/!_

user.sayHi(); // Hello! \`\`\`

Here we’ve just used a Function Expression to create a function and assign it to the property `user.sayHi` of the object.

Then we can call it as `user.sayHi()`. The user can now speak!

A function that is a property of an object is called its _method_.

So, here we’ve got a method `sayHi` of the object `user`.

Of course, we could use a pre-declared function as a method, like this:

\`\`\`js run let user = { // … };

_!_ // first, declare function sayHi() { alert(“Hello!”); };

// then add as a method user.sayHi = sayHi; _/!_

user.sayHi(); // Hello! \`\`\`

\`\`\`smart header=“Object-oriented programming” When we write our code using objects to represent entities, that’s called [object-oriented programming](https://en.wikipedia.org/wiki/Object-oriented_programming), in short: “OOP”.

OOP is a big thing, an interesting science of its own. How to choose the right entities? How to organize the interaction between them? That’s architecture, and there are great books on that topic, like “Design Patterns: Elements of Reusable Object-Oriented Software” by E. Gamma, R. Helm, R. Johnson, J. Vissides or “Object-Oriented Analysis and Design with Applications” by G. Booch, and more. \`\`\` \#\#\# Method shorthand

There exists a shorter syntax for methods in an object literal:

    // these objects do the same

    user = {
      sayHi: function() {
        alert("Hello");
      }
    };

    // method shorthand looks better, right?
    user = {
    *!*
      sayHi() { // same as "sayHi: function(){...}"
    */!*
        alert("Hello");
      }
    };

As demonstrated, we can omit `"function"` and just write `sayHi()`.

To tell the truth, the notations are not fully identical. There are subtle differences related to object inheritance (to be covered later), but for now they do not matter. In almost all cases the shorter syntax is preferred.

## “this” in methods

It’s common that an object method needs to access the information stored in the object to do its job.

For instance, the code inside `user.sayHi()` may need the name of the `user`.

**To access the object, a method can use the `this` keyword.**

The value of `this` is the object “before dot”, the one used to call the method.

For instance:

\`\`\`js run let user = { name: “John”, age: 30,

sayHi() { _!_ // “this” is the “current object” alert(this.name); _/!_ }

};

user.sayHi(); // John \`\`\`

Here during the execution of `user.sayHi()`, the value of `this` will be `user`.

Technically, it’s also possible to access the object without `this`, by referencing it via the outer variable:

    let user = {
      name: "John",
      age: 30,

      sayHi() {
    *!*
        alert(user.name); // "user" instead of "this"
    */!*
      }

    };

…But such code is unreliable. If we decide to copy `user` to another variable, e.g. `admin = user` and overwrite `user` with something else, then it will access the wrong object.

That’s demonstrated below:

\`\`\`js run let user = { name: “John”, age: 30,

sayHi() { _!_ alert( user.name ); // leads to an error _/!_ }

};

let admin = user; user = null; // overwrite to make things obvious

_!_ admin.sayHi(); // TypeError: Cannot read property ‘name’ of null _/!_ \`\`\`

If we used `this.name` instead of `user.name` inside the `alert`, then the code would work.

## “this” is not bound

In JavaScript, keyword `this` behaves unlike most other programming languages. It can be used in any function, even if it’s not a method of an object.

There’s no syntax error in the following example:

    function sayHi() {
      alert( *!*this*/!*.name );
    }

The value of `this` is evaluated during the run-time, depending on the context.

For instance, here the same function is assigned to two different objects and has different “this” in the calls:

\`\`\`js run let user = { name: “John” }; let admin = { name: “Admin” };

function sayHi() { alert( this.name ); }

_!_ // use the same function in two objects user.f = sayHi; admin.f = sayHi; _/!_

// these calls have different this // “this” inside the function is the object “before the dot” user.f(); // John (this == user) admin.f(); // Admin (this == admin)

admin[‘f’](); // Admin (dot or square brackets access the method – doesn’t matter) \`\`\`

The rule is simple: if `obj.f()` is called, then `this` is `obj` during the call of `f`. So it’s either `user` or `admin` in the example above.

\`\`\``smart header="Calling without an object:`this == undefined\`" We can even call the function without an object at all:

\`\`\`js run function sayHi() { alert(this); }

sayHi(); // undefined

    In this case `this` is `undefined` in strict mode. If we try to access `this.name`, there will be an error.

    In non-strict mode the value of `this` in such case will be the *global object* (`window` in a browser, we'll get to it later in the chapter [](info:global-object)). This is a historical behavior that `"use strict"` fixes.

    Usually such call is a programming error. If there's `this` inside a function, it expects to be called in an object context.

\`\``smart header="The consequences of unbound`this`" If you come from another programming language, then you are probably used to the idea of a "bound`this`", where methods defined in an object always have`this\` referencing that object.

In JavaScript `this` is “free”, its value is evaluated at call-time and does not depend on where the method was declared, but rather on what object is “before the dot”.

The concept of run-time evaluated `this` has both pluses and minuses. On the one hand, a function can be reused for different objects. On the other hand, the greater flexibility creates more possibilities for mistakes.

Here our position is not to judge whether this language design decision is good or bad. We’ll understand how to work with it, how to get benefits and avoid problems. \`\`\`

## Arrow functions have no “this”

Arrow functions are special: they don’t have their “own” `this`. If we reference `this` from such a function, it’s taken from the outer “normal” function.

For instance, here `arrow()` uses `this` from the outer `user.sayHi()` method:

\`\`\`js run let user = { firstName: “Ilya”, sayHi() { let arrow = () =&gt; alert(this.firstName); arrow(); } };

user.sayHi(); // Ilya \`\`\`

That’s a special feature of arrow functions, it’s useful when we actually do not want to have a separate `this`, but rather to take it from the outer context. Later in the chapter <a href="info:arrow-functions" class="uri">info:arrow-functions</a> we’ll go more deeply into arrow functions.

## Summary

- Functions that are stored in object properties are called “methods”.
- Methods allow objects to “act” like `object.doSomething()`.
- Methods can reference the object as `this`.

The value of `this` is defined at run-time. - When a function is declared, it may use `this`, but that `this` has no value until the function is called. - A function can be copied between objects. - When a function is called in the “method” syntax: `object.method()`, the value of `this` during the call is `object`.

Please note that arrow functions are special: they have no `this`. When `this` is accessed inside an arrow function, it is taken from outside. \# Constructor, operator “new”

The regular `{...}` syntax allows to create one object. But often we need to create many similar objects, like multiple users or menu items and so on.

That can be done using constructor functions and the `"new"` operator.

## Constructor function

Constructor functions technically are regular functions. There are two conventions though:

1.  They are named with capital letter first.
2.  They should be executed only with `"new"` operator.

For instance:

\`\`\`js run function User(name) { this.name = name; this.isAdmin = false; }

_!_ let user = new User(“Jack”); _/!_

alert(user.name); // Jack alert(user.isAdmin); // false \`\`\`

When a function is executed with `new`, it does the following steps:

1.  A new empty object is created and assigned to `this`.
2.  The function body executes. Usually it modifies `this`, adds new properties to it.
3.  The value of `this` is returned.

In other words, `new User(...)` does something like:

    function User(name) {
    *!*
      // this = {};  (implicitly)
    */!*

      // add properties to this
      this.name = name;
      this.isAdmin = false;

    *!*
      // return this;  (implicitly)
    */!*
    }

So `let user = new User("Jack")` gives the same result as:

    let user = {
      name: "Jack",
      isAdmin: false
    };

Now if we want to create other users, we can call `new User("Ann")`, `new User("Alice")` and so on. Much shorter than using literals every time, and also easy to read.

That’s the main purpose of constructors – to implement reusable object creation code.

Let’s note once again – technically, any function can be used as a constructor. That is: any function can be run with `new`, and it will execute the algorithm above. The “capital letter first” is a common agreement, to make it clear that a function is to be run with `new`.

\`\`\`\`smart header=“new function() { … }” If we have many lines of code all about creation of a single complex object, we can wrap them in constructor function, like this:

    let user = new function() {
      this.name = "John";
      this.isAdmin = false;

      // ...other code for user creation
      // maybe complex logic and statements
      // local variables etc
    };

The constructor can’t be called again, because it is not saved anywhere, just created and called. So this trick aims to encapsulate the code that constructs the single object, without future reuse. \`\`\`\`

## Constructor mode test: new.target

`smart header="Advanced stuff" The syntax from this section is rarely used, skip it unless you want to know everything.`

Inside a function, we can check whether it was called with `new` or without it, using a special `new.target` property.

It is undefined for regular calls and equals the function if called with `new`:

\`\`\`js run function User() { alert(new.target); }

// without “new”: _!_ User(); // undefined _/!_

// with “new”: _!_ new User(); // function User { … } _/!_ \`\`\`

That can be used inside the function to know whether it was called with `new`, “in constructor mode”, or without it, “in regular mode”.

We can also make both `new` and regular calls to do the same, like this:

\`\`\`js run function User(name) { if (!new.target) { // if you run me without new return new User(name); // …I will add new for you }

this.name = name; }

let john = User(“John”); // redirects call to new User alert(john.name); // John \`\`\`

This approach is sometimes used in libraries to make the syntax more flexible. So that people may call the function with or without `new`, and it still works.

Probably not a good thing to use everywhere though, because omitting `new` makes it a bit less obvious what’s going on. With `new` we all know that the new object is being created.

## Return from constructors

Usually, constructors do not have a `return` statement. Their task is to write all necessary stuff into `this`, and it automatically becomes the result.

But if there is a `return` statement, then the rule is simple:

- If `return` is called with an object, then the object is returned instead of `this`.
- If `return` is called with a primitive, it’s ignored.

In other words, `return` with an object returns that object, in all other cases `this` is returned.

For instance, here `return` overrides `this` by returning an object:

\`\`\`js run function BigUser() {

this.name = “John”;

return { name: “Godzilla” }; // &lt;– returns this object }

alert( new BigUser().name ); // Godzilla, got that object \`\`\`

And here’s an example with an empty `return` (or we could place a primitive after it, doesn’t matter):

\`\`\`js run function SmallUser() {

this.name = “John”;

return; // &lt;– returns this }

alert( new SmallUser().name ); // John \`\`\`

Usually constructors don’t have a `return` statement. Here we mention the special behavior with returning objects mainly for the sake of completeness.

\`\`\``smart header="Omitting parentheses" By the way, we can omit parentheses after`new\`, if it has no arguments:

    let user = new User; // <-- no parentheses
    // same as
    let user = new User();

Omitting parentheses here is not considered a “good style”, but the syntax is permitted by specification. \`\`\`\`

## Methods in constructor

Using constructor functions to create objects gives a great deal of flexibility. The constructor function may have parameters that define how to construct the object, and what to put in it.

Of course, we can add to `this` not only properties, but methods as well.

For instance, `new User(name)` below creates an object with the given `name` and the method `sayHi`:

\`\`\`js run function User(name) { this.name = name;

this.sayHi = function() { alert( “My name is:” + this.name ); }; }

_!_ let john = new User(“John”);

john.sayHi(); // My name is: John _/!_

/ _john = { name: “John”, sayHi: function() { … } }_ / \`\`\`

To create complex objects, there’s a more advanced syntax, [classes](info:classes), that we’ll cover later.

## Summary

- Constructor functions or, briefly, constructors, are regular functions, but there’s a common agreement to name them with capital letter first.
- Constructor functions should only be called using `new`. Such a call implies a creation of empty `this` at the start and returning the populated one at the end.

We can use constructor functions to make multiple similar objects.

JavaScript provides constructor functions for many built-in language objects: like `Date` for dates, `Set` for sets and others that we plan to study.

\`\`\`smart header=“Objects, we’ll be back!” In this chapter we only cover the basics about objects and constructors. They are essential for learning more about data types and functions in the next chapters.

After we learn that, we return to objects and cover them in-depth in the chapters <a href="info:prototypes" class="uri">info:prototypes</a> and <a href="info:classes" class="uri">info:classes</a>. \`\`\`

# Optional chaining ‘?.’

\[recent browser=“new”\]

The optional chaining `?.` is a safe way to access nested object properties, even if an intermediate property doesn’t exist.

## The “non-existing property” problem

If you’ve just started to read the tutorial and learn JavaScript, maybe the problem hasn’t touched you yet, but it’s quite common.

As an example, let’s say we have `user` objects that hold the information about our users.

Most of our users have addresses in `user.address` property, with the street `user.address.street`, but some did not provide them.

In such case, when we attempt to get `user.address.street`, and the user happens to be without an address, we get an error:

\`\`\`js run let user = {}; // a user without “address” property

alert(user.address.street); // Error! \`\`\`

That’s the expected result. JavaScript works like this. As `user.address` is `undefined`, an attempt to get `user.address.street` fails with an error.

In many practical cases we’d prefer to get `undefined` instead of an error here (meaning “no street”).

…And another example. In the web development, we can get an object that corresponds to a web page element using a special method call, such as `document.querySelector('.elem')`, and it returns `null` when there’s no such element.

`js run // document.querySelector('.elem') is null if there's no element let html = document.querySelector('.elem').innerHTML; // error if it's null`

Once again, if the element doesn’t exist, we’ll get an error accessing `.innerHTML` of `null`. And in some cases, when the absence of the element is normal, we’d like to avoid the error and just accept `html = null` as the result.

How can we do this?

The obvious solution would be to check the value using `if` or the conditional operator `?`, before accessing its property, like this:

    let user = {};

    alert(user.address ? user.address.street : undefined);

It works, there’s no error… But it’s quite inelegant. As you can see, the `"user.address"` appears twice in the code. For more deeply nested properties, that becomes a problem as more repetitions are required.

E.g. let’s try getting `user.address.street.name`.

We need to check both `user.address` and `user.address.street`:

    let user = {}; // user has no address

    alert(user.address ? user.address.street ? user.address.street.name : null : null);

That’s just awful, one may even have problems understanding such code.

Don’t even care to, as there’s a better way to write it, using the `&&` operator:

\`\`\`js run let user = {}; // user has no address

alert( user.address && user.address.street && user.address.street.name ); // undefined (no error) \`\`\`

AND’ing the whole path to the property ensures that all components exist (if not, the evaluation stops), but also isn’t ideal.

As you can see, property names are still duplicated in the code. E.g. in the code above, `user.address` appears three times.

That’s why the optional chaining `?.` was added to the language. To solve this problem once and for all!

## Optional chaining

The optional chaining `?.` stops the evaluation if the value before `?.` is `undefined` or `null` and returns `undefined`.

**Further in this article, for brevity, we’ll be saying that something “exists” if it’s not `null` and not `undefined`.**

In other words, `value?.prop`: - works as `value.prop`, if `value` exists, - otherwise (when `value` is `undefined/null`) it returns `undefined`.

Here’s the safe way to access `user.address.street` using `?.`:

\`\`\`js run let user = {}; // user has no address

alert( user?.address?.street ); // undefined (no error) \`\`\`

The code is short and clean, there’s no duplication at all.

Reading the address with `user?.address` works even if `user` object doesn’t exist:

\`\`\`js run let user = null;

alert( user?.address ); // undefined alert( user?.address.street ); // undefined \`\`\`

Please note: the `?.` syntax makes optional the value before it, but not any further.

E.g. in `user?.address.street.name` the `?.` allows `user` to safely be `null/undefined` (and returns `undefined` in that case), but that’s only for `user`. Further properties are accessed in a regular way. If we want some of them to be optional, then we’ll need to replace more `.` with `?.`.

\`\``warn header="Don't overuse the optional chaining" We should use`?.\` only where it’s ok that something doesn’t exist.

For example, if according to our coding logic `user` object must exist, but `address` is optional, then we should write `user.address?.street`, but not `user?.address?.street`.

So, if `user` happens to be undefined due to a mistake, we’ll see a programming error about it and fix it. Otherwise, coding errors can be silenced where not appropriate, and become more difficult to debug. \`\`\`

\`\`\``warn header="The variable before`?.`must be declared" If there's no variable`user`at all, then`user?.anything\` triggers an error:

`js run // ReferenceError: user is not defined user?.address;` The variable must be declared (e.g. `let/const/var user` or as a function parameter). The optional chaining works only for declared variables. \`\`\`\`

## Short-circuiting

As it was said before, the `?.` immediately stops (“short-circuits”) the evaluation if the left part doesn’t exist.

So, if there are any further function calls or side effects, they don’t occur.

For instance:

\`\`\`js run let user = null; let x = 0;

user?.sayHi(x++); // no “sayHi”, so the execution doesn’t reach x++

alert(x); // 0, value not incremented \`\`\`

## Other variants: ?.(), ?.\[\]

The optional chaining `?.` is not an operator, but a special syntax construct, that also works with functions and square brackets.

For example, `?.()` is used to call a function that may not exist.

In the code below, some of our users have `admin` method, and some don’t:

\`\`\`js run let userAdmin = { admin() { alert(“I am admin”); } };

let userGuest = {};

_!_ userAdmin.admin?.(); // I am admin _/!_

_!_ userGuest.admin?.(); // nothing (no such method) _/!_ \`\`\`

Here, in both lines we first use the dot (`userAdmin.admin`) to get `admin` property, because we assume that the user object exists, so it’s safe read from it.

Then `?.()` checks the left part: if the admin function exists, then it runs (that’s so for `userAdmin`). Otherwise (for `userGuest`) the evaluation stops without errors.

The `?.[]` syntax also works, if we’d like to use brackets `[]` to access properties instead of dot `.`. Similar to previous cases, it allows to safely read a property from an object that may not exist.

\`\`\`js run let key = “firstName”;

let user1 = { firstName: “John” };

let user2 = null;

alert( user1?.\[key\] ); // John alert( user2?.\[key\] ); // undefined \`\`\`

Also we can use `?.` with `delete`:

`js run delete user?.name; // delete user.name if user exists`

\`\`\``warn header="We can use`?.`for safe reading and deleting, but not writing" The optional chaining`?.\` has no use at the left side of an assignment.

For example: \`\`\`js run let user = null;

user?.name = “John”; // Error, doesn’t work // because it evaluates to undefined = “John”

    It's just not that smart.

## Summary

The optional chaining `?.` syntax has three forms:

1.  `obj?.prop` – returns `obj.prop` if `obj` exists, otherwise `undefined`.
2.  `obj?.[prop]` – returns `obj[prop]` if `obj` exists, otherwise `undefined`.
3.  `obj.method?.()` – calls `obj.method()` if `obj.method` exists, otherwise returns `undefined`.

As we can see, all of them are straightforward and simple to use. The `?.` checks the left part for `null/undefined` and allows the evaluation to proceed if it’s not so.

A chain of `?.` allows to safely access nested properties.

Still, we should apply `?.` carefully, only where it’s acceptable that the left part doesn’t exist. So that it won’t hide programming errors from us, if they occur.

# Symbol type

By specification, object property keys may be either of string type, or of symbol type. Not numbers, not booleans, only strings or symbols, these two types.

Till now we’ve been using only strings. Now let’s see the benefits that symbols can give us.

## Symbols

A “symbol” represents a unique identifier.

A value of this type can be created using `Symbol()`:

    // id is a new symbol
    let id = Symbol();

Upon creation, we can give symbol a description (also called a symbol name), mostly useful for debugging purposes:

    // id is a symbol with the description "id"
    let id = Symbol("id");

Symbols are guaranteed to be unique. Even if we create many symbols with the same description, they are different values. The description is just a label that doesn’t affect anything.

For instance, here are two symbols with the same description – they are not equal:

\`\`\`js run let id1 = Symbol(“id”); let id2 = Symbol(“id”);

_!_ alert(id1 == id2); // false _/!_ \`\`\`

If you are familiar with Ruby or another language that also has some sort of “symbols” – please don’t be misguided. JavaScript symbols are different.

\`\`\``warn header="Symbols don't auto-convert to a string" Most values in JavaScript support implicit conversion to a string. For instance, we can`alert\` almost any value, and it will work. Symbols are special. They don’t auto-convert.

For instance, this `alert` will show an error:

`js run let id = Symbol("id"); *!* alert(id); // TypeError: Cannot convert a Symbol value to a string */!*`

That’s a “language guard” against messing up, because strings and symbols are fundamentally different and should not accidentally convert one into another.

If we really want to show a symbol, we need to explicitly call `.toString()` on it, like here: `js run let id = Symbol("id"); *!* alert(id.toString()); // Symbol(id), now it works */!*`

Or get `symbol.description` property to show the description only: `js run let id = Symbol("id"); *!* alert(id.description); // id */!*`

\`\`\`\`

## “Hidden” properties

Symbols allow us to create “hidden” properties of an object, that no other part of code can accidentally access or overwrite.

For instance, if we’re working with `user` objects, that belong to a third-party code. We’d like to add identifiers to them.

Let’s use a symbol key for it:

\`\`\`js run let user = { // belongs to another code name: “John” };

let id = Symbol(“id”);

user\[id\] = 1;

alert( user\[id\] ); // we can access the data using the symbol as the key \`\`\`

What’s the benefit of using `Symbol("id")` over a string `"id"`?

As `user` objects belongs to another code, and that code also works with them, we shouldn’t just add any fields to it. That’s unsafe. But a symbol cannot be accessed accidentally, the third-party code probably won’t even see it, so it’s probably all right to do.

Also, imagine that another script wants to have its own identifier inside `user`, for its own purposes. That may be another JavaScript library, so that the scripts are completely unaware of each other.

Then that script can create its own `Symbol("id")`, like this:

    // ...
    let id = Symbol("id");

    user[id] = "Their id value";

There will be no conflict between our and their identifiers, because symbols are always different, even if they have the same name.

…But if we used a string `"id"` instead of a symbol for the same purpose, then there _would_ be a conflict:

    let user = { name: "John" };

    // Our script uses "id" property
    user.id = "Our id value";

    // ...Another script also wants "id" for its purposes...

    user.id = "Their id value"
    // Boom! overwritten by another script!

### Symbols in an object literal

If we want to use a symbol in an object literal `{...}`, we need square brackets around it.

Like this:

    let id = Symbol("id");

    let user = {
      name: "John",
    *!*
      [id]: 123 // not "id": 123
    */!*
    };

That’s because we need the value from the variable `id` as the key, not the string “id”.

### Symbols are skipped by for..in

Symbolic properties do not participate in `for..in` loop.

For instance:

\`\`\`js run let id = Symbol(“id”); let user = { name: “John”, age: 30, \[id\]: 123 };

_!_ for (let key in user) alert(key); // name, age (no symbols) _/!_

// the direct access by the symbol works alert( “Direct:” + user\[id\] ); \`\`\`

`Object.keys(user)` also ignores them. That’s a part of the general “hiding symbolic properties” principle. If another script or a library loops over our object, it won’t unexpectedly access a symbolic property.

In contrast, [Object.assign](mdn:js/Object/assign) copies both string and symbol properties:

\`\`\`js run let id = Symbol(“id”); let user = { \[id\]: 123 };

let clone = Object.assign({}, user);

alert( clone\[id\] ); // 123 \`\`\`

There’s no paradox here. That’s by design. The idea is that when we clone an object or merge objects, we usually want _all_ properties to be copied (including symbols like `id`).

## Global symbols

As we’ve seen, usually all symbols are different, even if they have the same name. But sometimes we want same-named symbols to be same entities. For instance, different parts of our application want to access symbol `"id"` meaning exactly the same property.

To achieve that, there exists a _global symbol registry_. We can create symbols in it and access them later, and it guarantees that repeated accesses by the same name return exactly the same symbol.

In order to read (create if absent) a symbol from the registry, use `Symbol.for(key)`.

That call checks the global registry, and if there’s a symbol described as `key`, then returns it, otherwise creates a new symbol `Symbol(key)` and stores it in the registry by the given `key`.

For instance:

\`\`\`js run // read from the global registry let id = Symbol.for(“id”); // if the symbol did not exist, it is created

// read it again (maybe from another part of the code) let idAgain = Symbol.for(“id”);

// the same symbol alert( id === idAgain ); // true \`\`\`

Symbols inside the registry are called _global symbols_. If we want an application-wide symbol, accessible everywhere in the code – that’s what they are for.

\`\`\`smart header=“That sounds like Ruby” In some programming languages, like Ruby, there’s a single symbol per name.

In JavaScript, as we can see, that’s right for global symbols. \`\`\`

### Symbol.keyFor

For global symbols, not only `Symbol.for(key)` returns a symbol by name, but there’s a reverse call: `Symbol.keyFor(sym)`, that does the reverse: returns a name by a global symbol.

For instance:

\`\`\`js run // get symbol by name let sym = Symbol.for(“name”); let sym2 = Symbol.for(“id”);

// get name by symbol alert( Symbol.keyFor(sym) ); // name alert( Symbol.keyFor(sym2) ); // id \`\`\`

The `Symbol.keyFor` internally uses the global symbol registry to look up the key for the symbol. So it doesn’t work for non-global symbols. If the symbol is not global, it won’t be able to find it and returns `undefined`.

That said, any symbols have `description` property.

For instance:

\`\`\`js run let globalSymbol = Symbol.for(“name”); let localSymbol = Symbol(“name”);

alert( Symbol.keyFor(globalSymbol) ); // name, global symbol alert( Symbol.keyFor(localSymbol) ); // undefined, not global

alert( localSymbol.description ); // name \`\`\`

## System symbols

There exist many “system” symbols that JavaScript uses internally, and we can use them to fine-tune various aspects of our objects.

They are listed in the specification in the [Well-known symbols](https://tc39.github.io/ecma262/#sec-well-known-symbols) table:

- `Symbol.hasInstance`
- `Symbol.isConcatSpreadable`
- `Symbol.iterator`
- `Symbol.toPrimitive`
- …and so on.

For instance, `Symbol.toPrimitive` allows us to describe object to primitive conversion. We’ll see its use very soon.

Other symbols will also become familiar when we study the corresponding language features.

## Summary

`Symbol` is a primitive type for unique identifiers.

Symbols are created with `Symbol()` call with an optional description (name).

Symbols are always different values, even if they have the same name. If we want same-named symbols to be equal, then we should use the global registry: `Symbol.for(key)` returns (creates if needed) a global symbol with `key` as the name. Multiple calls of `Symbol.for` with the same `key` return exactly the same symbol.

Symbols have two main use cases:

1.  “Hidden” object properties. If we want to add a property into an object that “belongs” to another script or a library, we can create a symbol and use it as a property key. A symbolic property does not appear in `for..in`, so it won’t be accidentally processed together with other properties. Also it won’t be accessed directly, because another script does not have our symbol. So the property will be protected from accidental use or overwrite.

    So we can “covertly” hide something into objects that we need, but others should not see, using symbolic properties.

2.  There are many system symbols used by JavaScript which are accessible as `Symbol.*`. We can use them to alter some built-in behaviors. For instance, later in the tutorial we’ll use `Symbol.iterator` for [iterables](info:iterable), `Symbol.toPrimitive` to setup [object-to-primitive conversion](info:object-toprimitive) and so on.

Technically, symbols are not 100% hidden. There is a built-in method [Object.getOwnPropertySymbols(obj)](mdn:js/Object/getOwnPropertySymbols) that allows us to get all symbols. Also there is a method named [Reflect.ownKeys(obj)](mdn:js/Reflect/ownKeys) that returns _all_ keys of an object including symbolic ones. So they are not really hidden. But most libraries, built-in functions and syntax constructs don’t use these methods.

# Object to primitive conversion

What happens when objects are added `obj1 + obj2`, subtracted `obj1 - obj2` or printed using `alert(obj)`?

In that case, objects are auto-converted to primitives, and then the operation is carried out.

In the chapter <a href="info:type-conversions" class="uri">info:type-conversions</a> we’ve seen the rules for numeric, string and boolean conversions of primitives. But we left a gap for objects. Now, as we know about methods and symbols it becomes possible to fill it.

1.  All objects are `true` in a boolean context. There are only numeric and string conversions.
2.  The numeric conversion happens when we subtract objects or apply mathematical functions. For instance, `Date` objects (to be covered in the chapter <a href="info:date" class="uri">info:date</a>) can be subtracted, and the result of `date1 - date2` is the time difference between two dates.
3.  As for the string conversion – it usually happens when we output an object like `alert(obj)` and in similar contexts.

## ToPrimitive

We can fine-tune string and numeric conversion, using special object methods.

There are three variants of type conversion, so-called “hints”, described in the [specification](https://tc39.github.io/ecma262/#sec-toprimitive):

`"string"`  
For an object-to-string conversion, when we’re doing an operation on an object that expects a string, like `alert`:

    // output
    alert(obj);

    // using object as a property key
    anotherObj[obj] = 123;

`"number"`  
For an object-to-number conversion, like when we’re doing maths:

    // explicit conversion
    let num = Number(obj);

    // maths (except binary plus)
    let n = +obj; // unary plus
    let delta = date1 - date2;

    // less/greater comparison
    let greater = user1 > user2;

`"default"`  
Occurs in rare cases when the operator is “not sure” what type to expect.

For instance, binary plus `+` can work both with strings (concatenates them) and numbers (adds them), so both strings and numbers would do. So if a binary plus gets an object as an argument, it uses the `"default"` hint to convert it.

Also, if an object is compared using `==` with a string, number or a symbol, it’s also unclear which conversion should be done, so the `"default"` hint is used.

    // binary plus uses the "default" hint
    let total = obj1 + obj2;

    // obj == number uses the "default" hint
    if (user == 1) { ... };

The greater and less comparison operators, such as `<` `>`, can work with both strings and numbers too. Still, they use the `"number"` hint, not `"default"`. That’s for historical reasons.

In practice though, we don’t need to remember these peculiar details, because all built-in objects except for one case (`Date` object, we’ll learn it later) implement `"default"` conversion the same way as `"number"`. And we can do the same.

\`\``smart header="No`"boolean"\` hint" Please note – there are only three hints. It’s that simple.

There is no “boolean” hint (all objects are `true` in boolean context) or anything else. And if we treat `"default"` and `"number"` the same, like most built-ins do, then there are only two conversions. \`\`\`

**To do the conversion, JavaScript tries to find and call three object methods:**

1.  Call `obj[Symbol.toPrimitive](hint)` - the method with the symbolic key `Symbol.toPrimitive` (system symbol), if such method exists,
2.  Otherwise if hint is `"string"`
    - try `obj.toString()` and `obj.valueOf()`, whatever exists.
3.  Otherwise if hint is `"number"` or `"default"`
    - try `obj.valueOf()` and `obj.toString()`, whatever exists.

## Symbol.toPrimitive

Let’s start from the first method. There’s a built-in symbol named `Symbol.toPrimitive` that should be used to name the conversion method, like this:

    obj[Symbol.toPrimitive] = function(hint) {
      // must return a primitive value
      // hint = one of "string", "number", "default"
    };

For instance, here `user` object implements it:

\`\`\`js run let user = { name: “John”, money: 1000,

[Symbol.toPrimitive](hint) { alert(`hint: ${hint}`); return hint == “string” ? `{name: "${this.name}"}` : this.money; } };

// conversions demo: alert(user); // hint: string -&gt; {name: “John”} alert(+user); // hint: number -&gt; 1000 alert(user + 500); // hint: default -&gt; 1500 \`\`\`

As we can see from the code, `user` becomes a self-descriptive string or a money amount depending on the conversion. The single method `user[Symbol.toPrimitive]` handles all conversion cases.

## toString/valueOf

Methods `toString` and `valueOf` come from ancient times. They are not symbols (symbols did not exist that long ago), but rather “regular” string-named methods. They provide an alternative “old-style” way to implement the conversion.

If there’s no `Symbol.toPrimitive` then JavaScript tries to find them and try in the order:

- `toString -> valueOf` for “string” hint.
- `valueOf -> toString` otherwise.

These methods must return a primitive value. If `toString` or `valueOf` returns an object, then it’s ignored (same as if there were no method).

By default, a plain object has following `toString` and `valueOf` methods:

- The `toString` method returns a string `"[object Object]"`.
- The `valueOf` method returns the object itself.

Here’s the demo:

\`\`\`js run let user = {name: “John”};

alert(user); // \[object Object\] alert(user.valueOf() === user); // true \`\`\`

So if we try to use an object as a string, like in an `alert` or so, then by default we see `[object Object]`.

And the default `valueOf` is mentioned here only for the sake of completeness, to avoid any confusion. As you can see, it returns the object itself, and so is ignored. Don’t ask me why, that’s for historical reasons. So we can assume it doesn’t exist.

Let’s implement these methods.

For instance, here `user` does the same as above using a combination of `toString` and `valueOf` instead of `Symbol.toPrimitive`:

\`\`\`js run let user = { name: “John”, money: 1000,

// for hint=“string” toString() { return `{name: "${this.name}"}`; },

// for hint=“number” or “default” valueOf() { return this.money; }

};

alert(user); // toString -&gt; {name: “John”} alert(+user); // valueOf -&gt; 1000 alert(user + 500); // valueOf -&gt; 1500 \`\`\`

As we can see, the behavior is the same as the previous example with `Symbol.toPrimitive`.

Often we want a single “catch-all” place to handle all primitive conversions. In this case, we can implement `toString` only, like this:

\`\`\`js run let user = { name: “John”,

toString() { return this.name; } };

alert(user); // toString -&gt; John alert(user + 500); // toString -&gt; John500 \`\`\`

In the absence of `Symbol.toPrimitive` and `valueOf`, `toString` will handle all primitive conversions.

## Return types

The important thing to know about all primitive-conversion methods is that they do not necessarily return the “hinted” primitive.

There is no control whether `toString` returns exactly a string, or whether `Symbol.toPrimitive` method returns a number for a hint `"number"`.

The only mandatory thing: these methods must return a primitive, not an object.

\`\``smart header="Historical notes" For historical reasons, if`toString`or`valueOf\` returns an object, there’s no error, but such value is ignored (like if the method didn’t exist). That’s because in ancient times there was no good “error” concept in JavaScript.

In contrast, `Symbol.toPrimitive` _must_ return a primitive, otherwise there will be an error. \`\`\`

## Further conversions

As we know already, many operators and functions perform type conversions, e.g. multiplication `*` converts operands to numbers.

If we pass an object as an argument, then there are two stages: 1. The object is converted to a primitive (using the rules described above). 2. If the resulting primitive isn’t of the right type, it’s converted.

For instance:

\`\`\`js run let obj = { // toString handles all conversions in the absence of other methods toString() { return “2”; } };

alert(obj \* 2); // 4, object converted to primitive “2”, then multiplication made it a number \`\`\`

1.  The multiplication `obj * 2` first converts the object to primitive (that’s a string `"2"`).
2.  Then `"2" * 2` becomes `2 * 2` (the string is converted to number).

Binary plus will concatenate strings in the same situation, as it gladly accepts a string:

\`\`\`js run let obj = { toString() { return “2”; } };

alert(obj + 2); // 22 (“2” + 2), conversion to primitive returned a string =&gt; concatenation \`\`\`

## Summary

The object-to-primitive conversion is called automatically by many built-in functions and operators that expect a primitive as a value.

There are 3 types (hints) of it: - `"string"` (for `alert` and other operations that need a string) - `"number"` (for maths) - `"default"` (few operators)

The specification describes explicitly which operator uses which hint. There are very few operators that “don’t know what to expect” and use the `"default"` hint. Usually for built-in objects `"default"` hint is handled the same way as `"number"`, so in practice the last two are often merged together.

The conversion algorithm is:

1.  Call `obj[Symbol.toPrimitive](hint)` if the method exists,
2.  Otherwise if hint is `"string"`
    - try `obj.toString()` and `obj.valueOf()`, whatever exists.
3.  Otherwise if hint is `"number"` or `"default"`
    - try `obj.valueOf()` and `obj.toString()`, whatever exists.

In practice, it’s often enough to implement only `obj.toString()` as a “catch-all” method for all conversions that return a “human-readable” representation of an object, for logging or debugging purposes.  
\# Methods of primitives

JavaScript allows us to work with primitives (strings, numbers, etc.) as if they were objects. They also provide methods to call as such. We will study those soon, but first we’ll see how it works because, of course, primitives are not objects (and here we will make it even clearer).

Let’s look at the key distinctions between primitives and objects.

A primitive

- Is a value of a primitive type.
- There are 7 primitive types: `string`, `number`, `bigint`, `boolean`, `symbol`, `null` and `undefined`.

An object

- Is capable of storing multiple values as properties.
- Can be created with `{}`, for instance: `{name: "John", age: 30}`. There are other kinds of objects in JavaScript: functions, for example, are objects.

One of the best things about objects is that we can store a function as one of its properties.

\`\`\`js run let john = { name: “John”, sayHi: function() { alert(“Hi buddy!”); } };

john.sayHi(); // Hi buddy! \`\`\`

So here we’ve made an object `john` with the method `sayHi`.

Many built-in objects already exist, such as those that work with dates, errors, HTML elements, etc. They have different properties and methods.

But, these features come with a cost!

Objects are “heavier” than primitives. They require additional resources to support the internal machinery.

## A primitive as an object

Here’s the paradox faced by the creator of JavaScript:

- There are many things one would want to do with a primitive like a string or a number. It would be great to access them as methods.
- Primitives must be as fast and lightweight as possible.

The solution looks a little bit awkward, but here it is:

1.  Primitives are still primitive. A single value, as desired.
2.  The language allows access to methods and properties of strings, numbers, booleans and symbols.
3.  In order for that to work, a special “object wrapper” that provides the extra functionality is created, and then is destroyed.

The “object wrappers” are different for each primitive type and are called: `String`, `Number`, `Boolean` and `Symbol`. Thus, they provide different sets of methods.

For instance, there exists a string method [str.toUpperCase()](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase) that returns a capitalized `str`.

Here’s how it works:

\`\`\`js run let str = “Hello”;

alert( str.toUpperCase() ); // HELLO \`\`\`

Simple, right? Here’s what actually happens in `str.toUpperCase()`:

1.  The string `str` is a primitive. So in the moment of accessing its property, a special object is created that knows the value of the string, and has useful methods, like `toUpperCase()`.
2.  That method runs and returns a new string (shown by `alert`).
3.  The special object is destroyed, leaving the primitive `str` alone.

So primitives can provide methods, but they still remain lightweight.

The JavaScript engine highly optimizes this process. It may even skip the creation of the extra object at all. But it must still adhere to the specification and behave as if it creates one.

A number has methods of its own, for instance, [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) rounds the number to the given precision:

\`\`\`js run let n = 1.23456;

alert( n.toFixed(2) ); // 1.23 \`\`\`

We’ll see more specific methods in chapters <a href="info:number" class="uri">info:number</a> and <a href="info:string" class="uri">info:string</a>.

\`\`\``warn header="Constructors`String/Number/Boolean`are for internal use only" Some languages like Java allow us to explicitly create "wrapper objects" for primitives using a syntax like`new Number(1)`or`new Boolean(false)\`.

In JavaScript, that’s also possible for historical reasons, but highly **unrecommended**. Things will go crazy in several places.

For instance:

\`\`\`js run alert( typeof 0 ); // “number”

alert( typeof new Number(0) ); // “object”! \`\`\`

Objects are always truthy in `if`, so here the alert will show up:

\`\`\`js run let zero = new Number(0);

if (zero) { // zero is true, because it’s an object alert( “zero is truthy!?!” ); } \`\`\`

On the other hand, using the same functions `String/Number/Boolean` without `new` is a totally sane and useful thing. They convert a value to the corresponding type: to a string, a number, or a boolean (primitive).

For example, this is entirely valid:

    let num = Number("123"); // convert a string to number

\`\`\`\`

\`\`\``warn header="null/undefined have no methods" The special primitives`null`and`undefined\` are exceptions. They have no corresponding “wrapper objects” and provide no methods. In a sense, they are “the most primitive”.

An attempt to access a property of such value would give the error:

\`\`\`js run alert(null.test); // error \`\`\`\`

## Summary

- Primitives except `null` and `undefined` provide many helpful methods. We will study those in the upcoming chapters.
- Formally, these methods work via temporary objects, but JavaScript engines are well tuned to optimize that internally, so they are not expensive to call. \# Numbers

In modern JavaScript, there are two types of numbers:

1.  Regular numbers in JavaScript are stored in 64-bit format [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754-2008_revision), also known as “double precision floating point numbers”. These are numbers that we’re using most of the time, and we’ll talk about them in this chapter.

2.  BigInt numbers, to represent integers of arbitrary length. They are sometimes needed, because a regular number can’t exceed `253` or be less than `-253`. As bigints are used in few special areas, we devote them a special chapter <a href="info:bigint" class="uri">info:bigint</a>.

So here we’ll talk about regular numbers. Let’s expand our knowledge of them.

## More ways to write a number

Imagine we need to write 1 billion. The obvious way is:

    let billion = 1000000000;

We also can use underscore `_` as the separator:

    let billion = 1_000_000_000;

Here the underscore `_` plays the role of the “syntactic sugar”, it makes the number more readable. The JavaScript engine simply ignores `_` between digits, so it’s exactly the same one billion as above.

In real life though, we try to avoid writing long sequences of zeroes. We’re too lazy for that. We’ll try to write something like `"1bn"` for a billion or `"7.3bn"` for 7 billion 300 million. The same is true for most large numbers.

In JavaScript, we can shorten a number by appending the letter `"e"` to it and specifying the zeroes count:

\`\`\`js run let billion = 1e9; // 1 billion, literally: 1 and 9 zeroes

alert( 7.3e9 ); // 7.3 billions (same as 7300000000 or 7_300_000_000) \`\`\`

In other words, `e` multiplies the number by `1` with the given zeroes count.

    1e3 = 1 * 1000 // e3 means *1000
    1.23e6 = 1.23 * 1000000 // e6 means *1000000

Now let’s write something very small. Say, 1 microsecond (one millionth of a second):

    let ms = 0.000001;

Just like before, using `"e"` can help. If we’d like to avoid writing the zeroes explicitly, we could say the same as:

    let ms = 1e-6; // six zeroes to the left from 1

If we count the zeroes in `0.000001`, there are 6 of them. So naturally it’s `1e-6`.

In other words, a negative number after `"e"` means a division by 1 with the given number of zeroes:

    // -3 divides by 1 with 3 zeroes
    1e-3 = 1 / 1000 (=0.001)

    // -6 divides by 1 with 6 zeroes
    1.23e-6 = 1.23 / 1000000 (=0.00000123)

### Hex, binary and octal numbers

[Hexadecimal](https://en.wikipedia.org/wiki/Hexadecimal) numbers are widely used in JavaScript to represent colors, encode characters, and for many other things. So naturally, there exists a shorter way to write them: `0x` and then the number.

For instance:

`js run alert( 0xff ); // 255 alert( 0xFF ); // 255 (the same, case doesn't matter)`

Binary and octal numeral systems are rarely used, but also supported using the `0b` and `0o` prefixes:

\`\`\`js run let a = 0b11111111; // binary form of 255 let b = 0o377; // octal form of 255

alert( a == b ); // true, the same number 255 at both sides \`\`\`

There are only 3 numeral systems with such support. For other numeral systems, we should use the function `parseInt` (which we will see later in this chapter).

## toString(base)

The method `num.toString(base)` returns a string representation of `num` in the numeral system with the given `base`.

For example: \`\`\`js run let num = 255;

alert( num.toString(16) ); // ff alert( num.toString(2) ); // 11111111 \`\`\`

The `base` can vary from `2` to `36`. By default it’s `10`.

Common use cases for this are:

- **base=16** is used for hex colors, character encodings etc, digits can be `0..9` or `A..F`.
- **base=2** is mostly for debugging bitwise operations, digits can be `0` or `1`.
- **base=36** is the maximum, digits can be `0..9` or `A..Z`. The whole latin alphabet is used to represent a number. A funny, but useful case for `36` is when we need to turn a long numeric identifier into something shorter, for example to make a short url. Can simply represent it in the numeral system with base `36`:

  `js run alert( 123456..toString(36) ); // 2n9c`

\`\``warn header="Two dots to call a method" Please note that two dots in`123456..toString(36)`is not a typo. If we want to call a method directly on a number, like`toString`in the example above, then we need to place two dots`..\` after it.

If we placed a single dot: `123456.toString(36)`, then there would be an error, because JavaScript syntax implies the decimal part after the first dot. And if we place one more dot, then JavaScript knows that the decimal part is empty and now goes the method.

Also could write `(123456).toString(36)`. \`\`\`

## Rounding

One of the most used operations when working with numbers is rounding.

There are several built-in functions for rounding:

`Math.floor`  
Rounds down: `3.1` becomes `3`, and `-1.1` becomes `-2`.

`Math.ceil`  
Rounds up: `3.1` becomes `4`, and `-1.1` becomes `-1`.

`Math.round`  
Rounds to the nearest integer: `3.1` becomes `3`, `3.6` becomes `4`, the middle case: `3.5` rounds up to `4` too.

`Math.trunc` (not supported by Internet Explorer)  
Removes anything after the decimal point without rounding: `3.1` becomes `3`, `-1.1` becomes `-1`.

Here’s the table to summarize the differences between them:

<table><thead><tr class="header"><th></th><th><code>Math.floor</code></th><th><code>Math.ceil</code></th><th><code>Math.round</code></th><th><code>Math.trunc</code></th></tr></thead><tbody><tr class="odd"><td><code>3.1</code></td><td><code>3</code></td><td><code>4</code></td><td><code>3</code></td><td><code>3</code></td></tr><tr class="even"><td><code>3.6</code></td><td><code>3</code></td><td><code>4</code></td><td><code>4</code></td><td><code>3</code></td></tr><tr class="odd"><td><code>-1.1</code></td><td><code>-2</code></td><td><code>-1</code></td><td><code>-1</code></td><td><code>-1</code></td></tr><tr class="even"><td><code>-1.6</code></td><td><code>-2</code></td><td><code>-1</code></td><td><code>-2</code></td><td><code>-1</code></td></tr></tbody></table>

These functions cover all of the possible ways to deal with the decimal part of a number. But what if we’d like to round the number to `n-th` digit after the decimal?

For instance, we have `1.2345` and want to round it to 2 digits, getting only `1.23`.

There are two ways to do so:

1.  Multiply-and-divide.

    For example, to round the number to the 2nd digit after the decimal, we can multiply the number by `100` (or a bigger power of 10), call the rounding function and then divide it back. \`\`\`js run let num = 1.23456;

    alert( Math.round(num \* 100) / 100 ); // 1.23456 -&gt; 123.456 -&gt; 123 -&gt; 1.23 \`\`\`

2.  The method [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) rounds the number to `n` digits after the point and returns a string representation of the result.

    `js run let num = 12.34; alert( num.toFixed(1) ); // "12.3"`

    This rounds up or down to the nearest value, similar to `Math.round`:

    `js run let num = 12.36; alert( num.toFixed(1) ); // "12.4"`

    Please note that result of `toFixed` is a string. If the decimal part is shorter than required, zeroes are appended to the end:

    `js run let num = 12.34; alert( num.toFixed(5) ); // "12.34000", added zeroes to make exactly 5 digits`

    We can convert it to a number using the unary plus or a `Number()` call: `+num.toFixed(5)`.

## Imprecise calculations

Internally, a number is represented in 64-bit format [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754-2008_revision), so there are exactly 64 bits to store a number: 52 of them are used to store the digits, 11 of them store the position of the decimal point (they are zero for integer numbers), and 1 bit is for the sign.

If a number is too big, it would overflow the 64-bit storage, potentially giving an infinity:

`js run alert( 1e500 ); // Infinity`

What may be a little less obvious, but happens quite often, is the loss of precision.

Consider this (falsy!) test:

`js run alert( 0.1 + 0.2 == 0.3 ); // *!*false*/!*`

That’s right, if we check whether the sum of `0.1` and `0.2` is `0.3`, we get `false`.

Strange! What is it then if not `0.3`?

`js run alert( 0.1 + 0.2 ); // 0.30000000000000004`

Ouch! There are more consequences than an incorrect comparison here. Imagine you’re making an e-shopping site and the visitor puts `$0.10` and `$0.20` goods into their cart. The order total will be `$0.30000000000000004`. That would surprise anyone.

But why does this happen?

A number is stored in memory in its binary form, a sequence of bits - ones and zeroes. But fractions like `0.1`, `0.2` that look simple in the decimal numeric system are actually unending fractions in their binary form.

In other words, what is `0.1`? It is one divided by ten `1/10`, one-tenth. In decimal numeral system such numbers are easily representable. Compare it to one-third: `1/3`. It becomes an endless fraction `0.33333(3)`.

So, division by powers `10` is guaranteed to work well in the decimal system, but division by `3` is not. For the same reason, in the binary numeral system, the division by powers of `2` is guaranteed to work, but `1/10` becomes an endless binary fraction.

There’s just no way to store _exactly 0.1_ or _exactly 0.2_ using the binary system, just like there is no way to store one-third as a decimal fraction.

The numeric format IEEE-754 solves this by rounding to the nearest possible number. These rounding rules normally don’t allow us to see that “tiny precision loss”, but it exists.

We can see this in action: `js run alert( 0.1.toFixed(20) ); // 0.10000000000000000555`

And when we sum two numbers, their “precision losses” add up.

That’s why `0.1 + 0.2` is not exactly `0.3`.

\`\`\`smart header=“Not only JavaScript” The same issue exists in many other programming languages.

PHP, Java, C, Perl, Ruby give exactly the same result, because they are based on the same numeric format. \`\`\`

Can we work around the problem? Sure, the most reliable method is to round the result with the help of a method [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed):

`js run let sum = 0.1 + 0.2; alert( sum.toFixed(2) ); // 0.30`

Please note that `toFixed` always returns a string. It ensures that it has 2 digits after the decimal point. That’s actually convenient if we have an e-shopping and need to show `$0.30`. For other cases, we can use the unary plus to coerce it into a number:

`js run let sum = 0.1 + 0.2; alert( +sum.toFixed(2) ); // 0.3`

We also can temporarily multiply the numbers by 100 (or a bigger number) to turn them into integers, do the maths, and then divide back. Then, as we’re doing maths with integers, the error somewhat decreases, but we still get it on division:

`js run alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3 alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001`

So, multiply/divide approach reduces the error, but doesn’t remove it totally.

Sometimes we could try to evade fractions at all. Like if we’re dealing with a shop, then we can store prices in cents instead of dollars. But what if we apply a discount of 30%? In practice, totally evading fractions is rarely possible. Just round them to cut “tails” when needed.

\`\`\`\`smart header=“The funny thing” Try running this:

`js run // Hello! I'm a self-increasing number! alert( 9999999999999999 ); // shows 10000000000000000`

This suffers from the same issue: a loss of precision. There are 64 bits for the number, 52 of them can be used to store digits, but that’s not enough. So the least significant digits disappear.

JavaScript doesn’t trigger an error in such events. It does its best to fit the number into the desired format, but unfortunately, this format is not big enough. \`\`\`\`

\`\``smart header="Two zeroes" Another funny consequence of the internal representation of numbers is the existence of two zeroes:`0`and`-0\`.

That’s because a sign is represented by a single bit, so it can be set or not set for any number including a zero.

In most cases the distinction is unnoticeable, because operators are suited to treat them as the same. \`\`\`

## Tests: isFinite and isNaN

Remember these two special numeric values?

- `Infinity` (and `-Infinity`) is a special numeric value that is greater (less) than anything.
- `NaN` represents an error.

They belong to the type `number`, but are not “normal” numbers, so there are special functions to check for them:

- `isNaN(value)` converts its argument to a number and then tests it for being `NaN`:

  `js run alert( isNaN(NaN) ); // true alert( isNaN("str") ); // true`

  But do we need this function? Can’t we just use the comparison `=== NaN`? Sorry, but the answer is no. The value `NaN` is unique in that it does not equal anything, including itself:

  `js run alert( NaN === NaN ); // false`

- `isFinite(value)` converts its argument to a number and returns `true` if it’s a regular number, not `NaN/Infinity/-Infinity`:

  `js run alert( isFinite("15") ); // true alert( isFinite("str") ); // false, because a special value: NaN alert( isFinite(Infinity) ); // false, because a special value: Infinity`

Sometimes `isFinite` is used to validate whether a string value is a regular number:

\`\`\`js run let num = +prompt(“Enter a number”, ’’);

// will be true unless you enter Infinity, -Infinity or not a number alert( isFinite(num) ); \`\`\`

Please note that an empty or a space-only string is treated as `0` in all numeric functions including `isFinite`.

\`\``smart header="Compare with`Object.is\`"

There is a special built-in method [`Object.is`](mdn:js/Object/is) that compares values like `===`, but is more reliable for two edge cases:

1.  It works with `NaN`: `Object.is(NaN, NaN) === true`, that’s a good thing.
2.  Values `0` and `-0` are different: `Object.is(0, -0) === false`, technically that’s true, because internally the number has a sign bit that may be different even if all other bits are zeroes.

In all other cases, `Object.is(a, b)` is the same as `a === b`.

This way of comparison is often used in JavaScript specification. When an internal algorithm needs to compare two values for being exactly the same, it uses `Object.is` (internally called [SameValue](https://tc39.github.io/ecma262/#sec-samevalue)). \`\`\`

## parseInt and parseFloat

Numeric conversion using a plus `+` or `Number()` is strict. If a value is not exactly a number, it fails:

`js run alert( +"100px" ); // NaN`

The sole exception is spaces at the beginning or at the end of the string, as they are ignored.

But in real life we often have values in units, like `"100px"` or `"12pt"` in CSS. Also in many countries the currency symbol goes after the amount, so we have `"19€"` and would like to extract a numeric value out of that.

That’s what `parseInt` and `parseFloat` are for.

They “read” a number from a string until they can’t. In case of an error, the gathered number is returned. The function `parseInt` returns an integer, whilst `parseFloat` will return a floating-point number:

\`\`\`js run alert( parseInt(‘100px’) ); // 100 alert( parseFloat(‘12.5em’) ); // 12.5

alert( parseInt(‘12.3’) ); // 12, only the integer part is returned alert( parseFloat(‘12.3.4’) ); // 12.3, the second point stops the reading \`\`\`

There are situations when `parseInt/parseFloat` will return `NaN`. It happens when no digits could be read:

`js run alert( parseInt('a123') ); // NaN, the first symbol stops the process`

\`\`\``smart header="The second argument of`parseInt(str, radix)`" The`parseInt()`function has an optional second parameter. It specifies the base of the numeral system, so`parseInt\` can also parse strings of hex numbers, binary numbers and so on:

\`\`\`js run alert( parseInt(‘0xff’, 16) ); // 255 alert( parseInt(‘ff’, 16) ); // 255, without 0x also works

alert( parseInt(‘2n9c’, 36) ); // 123456

## Other math functions

JavaScript has a built-in [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) object which contains a small library of mathematical functions and constants.

A few examples:

`Math.random()`  
Returns a random number from 0 to 1 (not including 1).

`js run alert( Math.random() ); // 0.1234567894322 alert( Math.random() ); // 0.5435252343232 alert( Math.random() ); // ... (any random numbers)`

`Math.max(a, b, c...)` / `Math.min(a, b, c...)`  
Returns the greatest/smallest from the arbitrary number of arguments.

`js run alert( Math.max(3, 5, -10, 0, 1) ); // 5 alert( Math.min(1, 2) ); // 1`

`Math.pow(n, power)`  
Returns `n` raised to the given power.

`js run alert( Math.pow(2, 10) ); // 2 in power 10 = 1024`

There are more functions and constants in `Math` object, including trigonometry, which you can find in the [docs for the Math object](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math).

## Summary

To write numbers with many zeroes:

- Append `"e"` with the zeroes count to the number. Like: `123e6` is the same as `123` with 6 zeroes `123000000`.
- A negative number after `"e"` causes the number to be divided by 1 with given zeroes. E.g. `123e-6` means `0.000123` (`123` millionths).

For different numeral systems:

- Can write numbers directly in hex (`0x`), octal (`0o`) and binary (`0b`) systems.
- `parseInt(str, base)` parses the string `str` into an integer in numeral system with given `base`, `2 ≤ base ≤ 36`.
- `num.toString(base)` converts a number to a string in the numeral system with the given `base`.

For converting values like `12pt` and `100px` to a number:

- Use `parseInt/parseFloat` for the “soft” conversion, which reads a number from a string and then returns the value they could read before the error.

For fractions:

- Round using `Math.floor`, `Math.ceil`, `Math.trunc`, `Math.round` or `num.toFixed(precision)`.
- Make sure to remember there’s a loss of precision when working with fractions.

More mathematical functions:

- See the [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) object when you need them. The library is very small, but can cover basic needs. \# Strings

In JavaScript, the textual data is stored as strings. There is no separate type for a single character.

The internal format for strings is always [UTF-16](https://en.wikipedia.org/wiki/UTF-16), it is not tied to the page encoding.

## Quotes

Let’s recall the kinds of quotes.

Strings can be enclosed within either single quotes, double quotes or backticks:

    let single = 'single-quoted';
    let double = "double-quoted";

    let backticks = `backticks`;

Single and double quotes are essentially the same. Backticks, however, allow us to embed any expression into the string, by wrapping it in `${…}`:

\`\`\`js run function sum(a, b) { return a + b; }

alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3. \`\`\`

Another advantage of using backticks is that they allow a string to span multiple lines:

\`\``js run let guestList =`Guests: \* John \* Pete \* Mary \`;

alert(guestList); // a list of guests, multiple lines \`\`\`

Looks natural, right? But single or double quotes do not work this way.

If we use them and try to use multiple lines, there’ll be an error:

`js run let guestList = "Guests: // Error: Unexpected token ILLEGAL * John";`

Single and double quotes come from ancient times of language creation when the need for multiline strings was not taken into account. Backticks appeared much later and thus are more versatile.

Backticks also allow us to specify a “template function” before the first backtick. The syntax is: `` func`string` ``. The function `func` is called automatically, receives the string and embedded expressions and can process them. This is called “tagged templates”. This feature makes it easier to implement custom templating, but is rarely used in practice. You can read more about it in the [manual](mdn:/JavaScript/Reference/Template_literals#Tagged_templates).

## Special characters

It is still possible to create multiline strings with single and double quotes by using a so-called “newline character”, written as `\n`, which denotes a line break:

\`\`\`js run let guestList = “Guests:JohnPeteMary”;

alert(guestList); // a multiline list of guests \`\`\`

For example, these two lines are equal, just written differently:

\`\`\`js run let str1 = “Hello”; // two lines using a “newline symbol”

// two lines using a normal newline and backticks let str2 = `Hello World`;

alert(str1 == str2); // true \`\`\`

There are other, less common “special” characters.

Here’s the full list:

<table style="width:99%;"><colgroup><col style="width: 45%" /><col style="width: 54%" /></colgroup><thead><tr class="header"><th>Character</th><th>Description</th></tr></thead><tbody><tr class="odd"><td><code>\n</code></td><td>New line</td></tr><tr class="even"><td><code>\r</code></td><td>Carriage return: not used alone. Windows text files use a combination of two characters <code>\r\n</code> to represent a line break.</td></tr><tr class="odd"><td><code>\'</code>, <code>\"</code></td><td>Quotes</td></tr><tr class="even"><td><code>\\</code></td><td>Backslash</td></tr><tr class="odd"><td><code>\t</code></td><td>Tab</td></tr><tr class="even"><td><code>\b</code>, <code>\f</code>, <code>\v</code></td><td>Backspace, Form Feed, Vertical Tab – kept for compatibility, not used nowadays.</td></tr><tr class="odd"><td><code>\xXX</code></td><td>Unicode character with the given hexadecimal Unicode <code>XX</code>, e.g. <code>'\x7A'</code> is the same as <code>'z'</code>.</td></tr><tr class="even"><td><code>\uXXXX</code></td><td>A Unicode symbol with the hex code <code>XXXX</code> in UTF-16 encoding, for instance <code>\u00A9</code> – is a Unicode for the copyright symbol <code>©</code>. It must be exactly 4 hex digits.</td></tr><tr class="odd"><td><code>\u{X…XXXXXX}</code> (1 to 6 hex characters)</td><td>A Unicode symbol with the given UTF-32 encoding. Some rare characters are encoded with two Unicode symbols, taking 4 bytes. This way we can insert long codes.</td></tr></tbody></table>

Examples with Unicode:

`js run alert( "\u00A9" ); // © alert( "\u{20331}" ); // 佫, a rare Chinese hieroglyph (long Unicode) alert( "\u{1F60D}" ); // 😍, a smiling face symbol (another long Unicode)`

All special characters start with a backslash character `\`. It is also called an “escape character”.

We might also use it if we wanted to insert a quote into the string.

For instance:

`js run alert( 'I*!*\'*/!*m the Walrus!' ); // *!*I'm*/!* the Walrus!`

As you can see, we have to prepend the inner quote by the backslash `\'`, because otherwise it would indicate the string end.

Of course, only the quotes that are the same as the enclosing ones need to be escaped. So, as a more elegant solution, we could switch to double quotes or backticks instead:

`` js run alert( `I'm the Walrus!` ); // I'm the Walrus! ``

Note that the backslash `\` serves for the correct reading of the string by JavaScript, then disappears. The in-memory string has no `\`. You can clearly see that in `alert` from the examples above.

But what if we need to show an actual backslash `\` within the string?

That’s possible, but we need to double it like `\\`:

`` js run alert( `The backslash: \\` ); // The backslash: \ ``

## String length

The `length` property has the string length:

`` js run alert( `My\n`.length ); // 3 ``

Note that `\n` is a single “special” character, so the length is indeed `3`.

\`\``warn header="`length`is a property" People with a background in some other languages sometimes mistype by calling`str.length()`instead of just`str.length\`. That doesn’t work.

Please note that `str.length` is a numeric property, not a function. There is no need to add parenthesis after it. \`\`\`

## Accessing characters

To get a character at position `pos`, use square brackets `[pos]` or call the method [str.charAt(pos)](mdn:js/String/charAt). The first character starts from the zero position:

\`\``js run let str =`Hello\`;

// the first character alert( str\[0\] ); // H alert( str.charAt(0) ); // H

// the last character alert( str\[str.length - 1\] ); // o \`\`\`

The square brackets are a modern way of getting a character, while `charAt` exists mostly for historical reasons.

The only difference between them is that if no character is found, `[]` returns `undefined`, and `charAt` returns an empty string:

\`\``js run let str =`Hello\`;

alert( str\[1000\] ); // undefined alert( str.charAt(1000) ); // ’’ (an empty string) \`\`\`

We can also iterate over characters using `for..of`:

`js run for (let char of "Hello") { alert(char); // H,e,l,l,o (char becomes "H", then "e", then "l" etc) }`

## Strings are immutable

Strings can’t be changed in JavaScript. It is impossible to change a character.

Let’s try it to show that it doesn’t work:

\`\`\`js run let str = ‘Hi’;

str\[0\] = ‘h’; // error alert( str\[0\] ); // doesn’t work \`\`\`

The usual workaround is to create a whole new string and assign it to `str` instead of the old one.

For instance:

\`\`\`js run let str = ‘Hi’;

str = ‘h’ + str\[1\]; // replace the string

alert( str ); // hi \`\`\`

In the following sections we’ll see more examples of this.

## Changing the case

Methods [toLowerCase()](mdn:js/String/toLowerCase) and [toUpperCase()](mdn:js/String/toUpperCase) change the case:

`js run alert( 'Interface'.toUpperCase() ); // INTERFACE alert( 'Interface'.toLowerCase() ); // interface`

Or, if we want a single character lowercased:

    alert( 'Interface'[0].toLowerCase() ); // 'i'

## Searching for a substring

There are multiple ways to look for a substring within a string.

### str.indexOf

The first method is [str.indexOf(substr, pos)](mdn:js/String/indexOf).

It looks for the `substr` in `str`, starting from the given position `pos`, and returns the position where the match was found or `-1` if nothing can be found.

For instance:

\`\`\`js run let str = ‘Widget with id’;

alert( str.indexOf(‘Widget’) ); // 0, because ‘Widget’ is found at the beginning alert( str.indexOf(‘widget’) ); // -1, not found, the search is case-sensitive

alert( str.indexOf(“id”) ); // 1, “id” is found at the position 1 (..idget with id) \`\`\`

The optional second parameter allows us to start searching from a given position.

For instance, the first occurrence of `"id"` is at position `1`. To look for the next occurrence, let’s start the search from position `2`:

\`\`\`js run let str = ‘Widget with id’;

alert( str.indexOf(‘id’, 2) ) // 12 \`\`\`

If we’re interested in all occurrences, we can run `indexOf` in a loop. Every new call is made with the position after the previous match:

\`\`\`js run let str = ‘As sly as a fox, as strong as an ox’;

let target = ‘as’; // let’s look for it

let pos = 0; while (true) { let foundPos = str.indexOf(target, pos); if (foundPos == -1) break;

alert( `Found at ${foundPos}` ); pos = foundPos + 1; // continue the search from the next position } \`\`\`

The same algorithm can be layed out shorter:

\`\`\`js run let str = “As sly as a fox, as strong as an ox”; let target = “as”;

_!_ let pos = -1; while ((pos = str.indexOf(target, pos + 1)) != -1) { alert( pos ); } _/!_ \`\`\`

\`\``smart header="`str.lastIndexOf(substr, position)\`" There is also a similar method [str.lastIndexOf(substr, position)](mdn:js/String/lastIndexOf) that searches from the end of a string to its beginning.

It would list the occurrences in the reverse order. \`\`\`

There is a slight inconvenience with `indexOf` in the `if` test. We can’t put it in the `if` like this:

\`\`\`js run let str = “Widget with id”;

if (str.indexOf(“Widget”)) { alert(“We found it”); // doesn’t work! } \`\`\`

The `alert` in the example above doesn’t show because `str.indexOf("Widget")` returns `0` (meaning that it found the match at the starting position). Right, but `if` considers `0` to be `false`.

So, we should actually check for `-1`, like this:

\`\`\`js run let str = “Widget with id”;

_!_ if (str.indexOf(“Widget”) != -1) { _/!_ alert(“We found it”); // works now! } \`\`\`

#### The bitwise NOT trick

One of the old tricks used here is the [bitwise NOT](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_NOT) `~` operator. It converts the number to a 32-bit integer (removes the decimal part if exists) and then reverses all bits in its binary representation.

In practice, that means a simple thing: for 32-bit integers `~n` equals `-(n+1)`.

For instance:

`js run alert( ~2 ); // -3, the same as -(2+1) alert( ~1 ); // -2, the same as -(1+1) alert( ~0 ); // -1, the same as -(0+1) *!* alert( ~-1 ); // 0, the same as -(-1+1) */!*`

As we can see, `~n` is zero only if `n == -1` (that’s for any 32-bit signed integer `n`).

So, the test `if ( ~str.indexOf("...") )` is truthy only if the result of `indexOf` is not `-1`. In other words, when there is a match.

People use it to shorten `indexOf` checks:

\`\`\`js run let str = “Widget”;

if (~str.indexOf(“Widget”)) { alert( ‘Found it!’ ); // works } \`\`\`

It is usually not recommended to use language features in a non-obvious way, but this particular trick is widely used in old code, so we should understand it.

Just remember: `if (~str.indexOf(...))` reads as “if found”.

To be precise though, as big numbers are truncated to 32 bits by `~` operator, there exist other numbers that give `0`, the smallest is `~4294967295=0`. That makes such check correct only if a string is not that long.

Right now we can see this trick only in the old code, as modern JavaScript provides `.includes` method (see below).

### includes, startsWith, endsWith

The more modern method [str.includes(substr, pos)](mdn:js/String/includes) returns `true/false` depending on whether `str` contains `substr` within.

It’s the right choice if we need to test for the match, but don’t need its position:

\`\`\`js run alert( “Widget with id”.includes(“Widget”) ); // true

alert( “Hello”.includes(“Bye”) ); // false \`\`\`

The optional second argument of `str.includes` is the position to start searching from:

`js run alert( "Widget".includes("id") ); // true alert( "Widget".includes("id", 3) ); // false, from position 3 there is no "id"`

The methods [str.startsWith](mdn:js/String/startsWith) and [str.endsWith](mdn:js/String/endsWith) do exactly what they say:

`js run alert( "Widget".startsWith("Wid") ); // true, "Widget" starts with "Wid" alert( "Widget".endsWith("get") ); // true, "Widget" ends with "get"`

## Getting a substring

There are 3 methods in JavaScript to get a substring: `substring`, `substr` and `slice`.

`str.slice(start [, end])`  
Returns the part of the string from `start` to (but not including) `end`.

For instance:

`js run let str = "stringify"; alert( str.slice(0, 5) ); // 'strin', the substring from 0 to 5 (not including 5) alert( str.slice(0, 1) ); // 's', from 0 to 1, but not including 1, so only character at 0`

If there is no second argument, then `slice` goes till the end of the string:

`js run let str = "st*!*ringify*/!*"; alert( str.slice(2) ); // 'ringify', from the 2nd position till the end`

Negative values for `start/end` are also possible. They mean the position is counted from the string end:

\`\`\`js run let str = “strin*!*gif*/!*y”;

// start at the 4th position from the right, end at the 1st from the right alert( str.slice(-4, -1) ); // ‘gif’ \`\`\`

`str.substring(start [, end])`  
Returns the part of the string _between_ `start` and `end`.

This is almost the same as `slice`, but it allows `start` to be greater than `end`.

For instance:

\`\`\`js run let str = “st*!*ring*/!*ify”;

// these are same for substring alert( str.substring(2, 6) ); // “ring” alert( str.substring(6, 2) ); // “ring”

// …but not for slice: alert( str.slice(2, 6) ); // “ring” (the same) alert( str.slice(6, 2) ); // "" (an empty string)

\`\`\`

Negative arguments are (unlike slice) not supported, they are treated as `0`.

`str.substr(start [, length])`  
Returns the part of the string from `start`, with the given `length`.

In contrast with the previous methods, this one allows us to specify the `length` instead of the ending position:

`js run let str = "st*!*ring*/!*ify"; alert( str.substr(2, 4) ); // 'ring', from the 2nd position get 4 characters`

The first argument may be negative, to count from the end:

`js run let str = "strin*!*gi*/!*fy"; alert( str.substr(-4, 2) ); // 'gi', from the 4th position get 2 characters`

Let’s recap these methods to avoid any confusion:

<table style="width:98%;"><colgroup><col style="width: 26%" /><col style="width: 36%" /><col style="width: 36%" /></colgroup><thead><tr class="header"><th>method</th><th>selects…</th><th>negatives</th></tr></thead><tbody><tr class="odd"><td><code>slice(start, end)</code></td><td>from <code>start</code> to <code>end</code> (not including <code>end</code>)</td><td>allows negatives</td></tr><tr class="even"><td><code>substring(start, end)</code></td><td>between <code>start</code> and <code>end</code></td><td>negative values mean <code>0</code></td></tr><tr class="odd"><td><code>substr(start, length)</code></td><td>from <code>start</code> get <code>length</code> characters</td><td>allows negative <code>start</code></td></tr></tbody></table>

\`\``smart header="Which one to choose?" All of them can do the job. Formally,`substr\` has a minor drawback: it is described not in the core JavaScript specification, but in Annex B, which covers browser-only features that exist mainly for historical reasons. So, non-browser environments may fail to support it. But in practice it works everywhere.

Of the other two variants, `slice` is a little bit more flexible, it allows negative arguments and shorter to write. So, it’s enough to remember solely `slice` of these three methods. \`\`\`

## Comparing strings

As we know from the chapter <a href="info:comparison" class="uri">info:comparison</a>, strings are compared character-by-character in alphabetical order.

Although, there are some oddities.

1.  A lowercase letter is always greater than the uppercase:

    `js run alert( 'a' > 'Z' ); // true`

2.  Letters with diacritical marks are “out of order”:

    `js run alert( 'Österreich' > 'Zealand' ); // true`

    This may lead to strange results if we sort these country names. Usually people would expect `Zealand` to come after `Österreich` in the list.

To understand what happens, let’s review the internal representation of strings in JavaScript.

All strings are encoded using [UTF-16](https://en.wikipedia.org/wiki/UTF-16). That is: each character has a corresponding numeric code. There are special methods that allow to get the character for the code and back.

`str.codePointAt(pos)`  
Returns the code for the character at position `pos`:

`js run // different case letters have different codes alert( "z".codePointAt(0) ); // 122 alert( "Z".codePointAt(0) ); // 90`

`String.fromCodePoint(code)`  
Creates a character by its numeric `code`

`js run alert( String.fromCodePoint(90) ); // Z`

We can also add Unicode characters by their codes using `\u` followed by the hex code:

`js run // 90 is 5a in hexadecimal system alert( '\u005a' ); // Z`

Now let’s see the characters with codes `65..220` (the latin alphabet and a little bit extra) by making a string of them:

\`\`\`js run let str = ’’;

for (let i = 65; i &lt;= 220; i++) { str += String.fromCodePoint(i); } alert( str ); // ABCDEFGHIJKLMNOPQRSTUVWXYZ\[\]^\_\`abcdefghijklmnopqrstuvwxyz{|}~€?‚ƒ„ // ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ \`\`\`

See? Capital characters go first, then a few special ones, then lowercase characters, and `Ö` near the end of the output.

Now it becomes obvious why `a > Z`.

The characters are compared by their numeric code. The greater code means that the character is greater. The code for `a` (97) is greater than the code for `Z` (90).

- All lowercase letters go after uppercase letters because their codes are greater.
- Some letters like `Ö` stand apart from the main alphabet. Here, it’s code is greater than anything from `a` to `z`.

### Correct comparisons \[\#correct-comparisons\]

The “right” algorithm to do string comparisons is more complex than it may seem, because alphabets are different for different languages.

So, the browser needs to know the language to compare.

Luckily, all modern browsers (IE10- requires the additional library [Intl.js](https://github.com/andyearnshaw/Intl.js/)) support the internationalization standard [ECMA-402](http://www.ecma-international.org/ecma-402/1.0/ECMA-402.pdf).

It provides a special method to compare strings in different languages, following their rules.

The call [str.localeCompare(str2)](mdn:js/String/localeCompare) returns an integer indicating whether `str` is less, equal or greater than `str2` according to the language rules:

- Returns a negative number if `str` is less than `str2`.
- Returns a positive number if `str` is greater than `str2`.
- Returns `0` if they are equivalent.

For instance:

`js run alert( 'Österreich'.localeCompare('Zealand') ); // -1`

This method actually has two additional arguments specified in [the documentation](mdn:js/String/localeCompare), which allows it to specify the language (by default taken from the environment, letter order depends on the language) and setup additional rules like case sensitivity or should `"a"` and `"á"` be treated as the same etc.

## Internals, Unicode

\`\`\`warn header=“Advanced knowledge” The section goes deeper into string internals. This knowledge will be useful for you if you plan to deal with emoji, rare mathematical or hieroglyphic characters or other rare symbols.

You can skip the section if you don’t plan to support them. \`\`\`

### Surrogate pairs

All frequently used characters have 2-byte codes. Letters in most european languages, numbers, and even most hieroglyphs, have a 2-byte representation.

But 2 bytes only allow 65536 combinations and that’s not enough for every possible symbol. So rare symbols are encoded with a pair of 2-byte characters called “a surrogate pair”.

The length of such symbols is `2`:

`js run alert( '𝒳'.length ); // 2, MATHEMATICAL SCRIPT CAPITAL X alert( '😂'.length ); // 2, FACE WITH TEARS OF JOY alert( '𩷶'.length ); // 2, a rare Chinese hieroglyph`

Note that surrogate pairs did not exist at the time when JavaScript was created, and thus are not correctly processed by the language!

We actually have a single symbol in each of the strings above, but the `length` shows a length of `2`.

`String.fromCodePoint` and `str.codePointAt` are few rare methods that deal with surrogate pairs right. They recently appeared in the language. Before them, there were only [String.fromCharCode](mdn:js/String/fromCharCode) and [str.charCodeAt](mdn:js/String/charCodeAt). These methods are actually the same as `fromCodePoint/codePointAt`, but don’t work with surrogate pairs.

Getting a symbol can be tricky, because surrogate pairs are treated as two characters:

`js run alert( '𝒳'[0] ); // strange symbols... alert( '𝒳'[1] ); // ...pieces of the surrogate pair`

Note that pieces of the surrogate pair have no meaning without each other. So the alerts in the example above actually display garbage.

Technically, surrogate pairs are also detectable by their codes: if a character has the code in the interval of `0xd800..0xdbff`, then it is the first part of the surrogate pair. The next character (second part) must have the code in interval `0xdc00..0xdfff`. These intervals are reserved exclusively for surrogate pairs by the standard.

In the case above:

\`\`\`js run // charCodeAt is not surrogate-pair aware, so it gives codes for parts

alert( ‘𝒳’.charCodeAt(0).toString(16) ); // d835, between 0xd800 and 0xdbff alert( ‘𝒳’.charCodeAt(1).toString(16) ); // dcb3, between 0xdc00 and 0xdfff \`\`\`

You will find more ways to deal with surrogate pairs later in the chapter <a href="info:iterable" class="uri">info:iterable</a>. There are probably special libraries for that too, but nothing famous enough to suggest here.

### Diacritical marks and normalization

In many languages there are symbols that are composed of the base character with a mark above/under it.

For instance, the letter `a` can be the base character for: `àáâäãåā`. Most common “composite” character have their own code in the UTF-16 table. But not all of them, because there are too many possible combinations.

To support arbitrary compositions, UTF-16 allows us to use several Unicode characters: the base character followed by one or many “mark” characters that “decorate” it.

For instance, if we have `S` followed by the special “dot above” character (code `\u0307`), it is shown as Ṡ.

`js run alert( 'S\u0307' ); // Ṡ`

If we need an additional mark above the letter (or below it) – no problem, just add the necessary mark character.

For instance, if we append a character “dot below” (code `\u0323`), then we’ll have “S with dots above and below”: `Ṩ`.

For example:

`js run alert( 'S\u0307\u0323' ); // Ṩ`

This provides great flexibility, but also an interesting problem: two characters may visually look the same, but be represented with different Unicode compositions.

For instance:
