<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>going-to-production</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
  </head>
  <body>
    <h1 id="going-to-production">Going to Production</h1>
    <p>
      Before taking your Next.js application to production, here are some
      recommendations to ensure the best user experience.
    </p>
    <h2 id="in-general">In General</h2>
    <ul>
      <li>Use <a href="#caching">caching</a> wherever possible.</li>
      <li>Ensure your database and backend are deployed in the same region.</li>
      <li>Aim to ship the least amount of JavaScript possible.</li>
      <li>Defer loading heavy JavaScript bundles until needed.</li>
      <li>Ensure <a href="#logging">logging</a> is set up.</li>
      <li>Ensure <a href="#error-handling">error handling</a> is set up.</li>
      <li>
        Configure the
        <a href="/docs/advanced-features/custom-error-page.md#404-page">404</a>
        (Not Found) and
        <a href="/docs/advanced-features/custom-error-page.md#500-page">500</a>
        (Error) pages.
      </li>
      <li>
        Ensure you are
        <a href="/docs/advanced-features/measuring-performance.md"
          >measuring performance</a
        >.
      </li>
      <li>
        Run
        <a href="https://developers.google.com/web/tools/lighthouse"
          >Lighthouse</a
        >
        to check for performance, best practices, accessibility, and SEO. For
        best results, use a production build of Next.js and use incognito in
        your browser so results aren’t affected by extensions.
      </li>
      <li>
        Review
        <a href="/docs/basic-features/supported-browsers-features.md"
          >Supported Browsers and Features</a
        >.
      </li>
      <li>
        Improve performance using:
        <ul>
          <li>
            <a href="/docs/basic-features/image-optimization.md"
              ><code>next/image</code> and Automatic Image Optimization</a
            >
          </li>
          <li>
            <a href="/docs/basic-features/font-optimization.md"
              >Automatic Font Optimization</a
            >
          </li>
          <li>
            <a href="/docs/basic-features/script.md">Script Optimization</a>
          </li>
        </ul>
      </li>
    </ul>
    <h2 id="caching">Caching</h2>
    <details open>
      <summary><b>Examples</b></summary>
      <ul>
        <li>
          <a
            href="https://github.com/vercel/next.js/tree/canary/examples/ssr-caching"
            >ssr-caching</a
          >
        </li>
      </ul>
    </details>
    <p>
      Caching improves response times and reduces the number of requests to
      external services. Next.js automatically adds caching headers to immutable
      assets served from <code>/_next/static</code> including JavaScript, CSS,
      static images, and other media.
    </p>
    <pre><code>Cache-Control: public, max-age=31536000, immutable</code></pre>
    <p>
      <code>Cache-Control</code> headers set in <code>next.config.js</code> will
      be overwritten in production to ensure that static assets can be cached
      effectively. If you need to revalidate the cache of a page that has been
      <a href="/docs/basic-features/pages.md#static-generation-recommended"
        >statically generated</a
      >, you can do so by setting <code>revalidate</code> in the page’s
      <a
        href="/docs/basic-features/data-fetching.md#getstaticprops-static-generation"
        ><code>getStaticProps</code></a
      >
      function. If you’re using <code>next/image</code>, there are also
      <a href="/docs/basic-features/image-optimization.md#caching"
        >specific caching rules</a
      >
      for the default Image Optimization loader.
    </p>
    <p>
      <strong>Note:</strong> When running your application locally with
      <code>next dev</code>, your headers are overwritten to prevent caching
      locally.
    </p>
    <pre><code>Cache-Control: no-cache, no-store, max-age=0, must-revalidate</code></pre>
    <p>
      You can also use caching headers inside
      <code>getServerSideProps</code> and API Routes for dynamic responses. For
      example, using
      <a href="https://web.dev/stale-while-revalidate/"
        ><code>stale-while-revalidate</code></a
      >.
    </p>
    <pre
      class="jsx"
    ><code>// This value is considered fresh for ten seconds (s-maxage=10).
// If a request is repeated within the next 10 seconds, the previously
// cached value will still be fresh. If the request is repeated before 59 seconds,
// the cached value will be stale but still render (stale-while-revalidate=59).
//
// In the background, a revalidation request will be made to populate the cache
// with a fresh value. If you refresh the page, you will see the new value.
export async function getServerSideProps({ req, res }) {
  res.setHeader(
    &#39;Cache-Control&#39;,
    &#39;public, s-maxage=10, stale-while-revalidate=59&#39;
  )

  return {
    props: {},
  }
}</code></pre>
    <blockquote>
      <p>
        <strong>Note:</strong> Your deployment provider must support edge
        caching for dynamic responses. If you are self-hosting, you will need to
        add this logic to the edge yourself using a key/value store. If you are
        using Vercel,
        <a href="https://vercel.com/docs/edge-network/caching"
          >edge caching works without configuration</a
        >.
      </p>
    </blockquote>
    <h2 id="reducing-javascript-size">Reducing JavaScript Size</h2>
    <details open>
      <summary><b>Examples</b></summary>
      <ul>
        <li>
          <a
            href="https://github.com/vercel/next.js/tree/canary/examples/with-dynamic-import"
            >with-dynamic-import</a
          >
        </li>
      </ul>
    </details>
    <p>
      To reduce the amount of JavaScript sent to the browser, you can use the
      following tools to understand what is included inside each JavaScript
      bundle:
    </p>
    <ul>
      <li>
        <a
          href="https://marketplace.visualstudio.com/items?itemName=wix.vscode-import-cost"
          >Import Cost</a
        >
        – Display the size of the imported package inside VSCode.
      </li>
      <li>
        <a href="https://packagephobia.com/">Package Phobia</a> – Find the cost
        of adding a new dev dependency to your project.
      </li>
      <li>
        <a href="https://bundlephobia.com/">Bundle Phobia</a> - Analyze how much
        a dependency can increase bundle sizes.
      </li>
      <li>
        <a
          href="https://github.com/vercel/next.js/tree/canary/packages/next-bundle-analyzer"
          >Webpack Bundle Analyzer</a
        >
        – Visualize size of webpack output files with an interactive, zoomable
        treemap.
      </li>
    </ul>
    <p>
      Each file inside your <code>pages/</code> directory will automatically be
      code split into its own JavaScript bundle during <code>next build</code>.
      You can also use
      <a href="/docs/advanced-features/dynamic-import.md">Dynamic Imports</a> to
      lazy-load components and libraries. For example, you might want to defer
      loading your modal code until a user clicks the open button.
    </p>
    <h2 id="logging">Logging</h2>
    <details open>
      <summary><b>Examples</b></summary>
      <ul>
        <li>
          <a
            href="https://github.com/Logflare/next-pino-logflare-logging-example"
            >with-logging</a
          >
        </li>
      </ul>
    </details>
    <p>
      Since Next.js runs on both the client and server, there are multiple forms
      of logging supported:
    </p>
    <ul>
      <li><code>console.log</code> in the browser</li>
      <li><code>stdout</code> on the server</li>
    </ul>
    <p>
      If you want a structured logging package, we recommend
      <a href="https://www.npmjs.com/package/pino">Pino</a>. If you’re using
      Vercel, there are
      <a href="https://vercel.com/integrations#logging"
        >pre-built logging integrations</a
      >
      compatible with Next.js.
    </p>
    <h2 id="error-handling">Error Handling</h2>
    <details open>
      <summary><b>Examples</b></summary>
      <ul>
        <li>
          <a
            href="https://github.com/vercel/next.js/tree/canary/examples/with-sentry"
            >with-sentry</a
          >
        </li>
      </ul>
    </details>
    <p>
      When an unhandled exception occurs, you can control the experience for
      your users with the
      <a href="/docs/advanced-features/custom-error-page.md#500-page"
        >500 page</a
      >. We recommend customizing this to your brand instead of the default
      Next.js theme.
    </p>
    <p>
      You can also log and track exceptions with a tool like Sentry.
      <a
        href="https://github.com/vercel/next.js/tree/canary/examples/with-sentry"
        >This example</a
      >
      shows how to catch &amp; report errors on both the client and server-side,
      using the Sentry SDK for Next.js. There’s also a
      <a href="https://vercel.com/integrations/sentry"
        >Sentry integration for Vercel</a
      >.
    </p>
    <h2 id="related">Related</h2>
    <p>
      For more information on what to do next, we recommend the following
      sections:
    </p>
    <div class="card">
      <p>
        <a href="/docs/deployment.md">
          <b>Deployment:</b>
          <small>Take your Next.js application to production.</small>
        </a>
      </p>
    </div>
  </body>
</html>
