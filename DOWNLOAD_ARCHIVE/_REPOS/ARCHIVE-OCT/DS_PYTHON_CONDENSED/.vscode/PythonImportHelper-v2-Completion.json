[
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "functools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functools",
        "description": "functools",
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "operator",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "operator",
        "description": "operator",
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "BigO",
        "importPath": "bigO",
        "description": "bigO",
        "isExtraImport": true,
        "detail": "bigO",
        "documentation": {}
    },
    {
        "label": "algorithm",
        "importPath": "bigO",
        "description": "bigO",
        "isExtraImport": true,
        "detail": "bigO",
        "documentation": {}
    },
    {
        "label": "BigO",
        "importPath": "bigO",
        "description": "bigO",
        "isExtraImport": true,
        "detail": "bigO",
        "documentation": {}
    },
    {
        "label": "algorithm",
        "importPath": "bigO",
        "description": "bigO",
        "isExtraImport": true,
        "detail": "bigO",
        "documentation": {}
    },
    {
        "label": "BigO",
        "importPath": "bigO",
        "description": "bigO",
        "isExtraImport": true,
        "detail": "bigO",
        "documentation": {}
    },
    {
        "label": "algorithm",
        "importPath": "bigO",
        "description": "bigO",
        "isExtraImport": true,
        "detail": "bigO",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "statistics",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "statistics",
        "description": "statistics",
        "detail": "statistics",
        "documentation": {}
    },
    {
        "label": "pprint",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pprint",
        "description": "pprint",
        "detail": "pprint",
        "documentation": {}
    },
    {
        "label": "pprint",
        "importPath": "pprint",
        "description": "pprint",
        "isExtraImport": true,
        "detail": "pprint",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "combinations",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "ThreadPoolExecutor",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "MISC.scrap.scrap",
        "description": "MISC.scrap.scrap",
        "peekOfCode": "class ListNode(object):\n  def __init__(self, x):\n    self.value = x\n    self.next = None\ndef removeKFromList(l, k):\n  c = l\n  while c:\n      if c.next and c.next.value == k:\n          c.next = c.next.next\n      else:",
        "detail": "MISC.scrap.scrap",
        "documentation": {}
    },
    {
        "label": "removeKFromList",
        "kind": 2,
        "importPath": "MISC.scrap.scrap",
        "description": "MISC.scrap.scrap",
        "peekOfCode": "def removeKFromList(l, k):\n  c = l\n  while c:\n      if c.next and c.next.value == k:\n          c.next = c.next.next\n      else:\n          c = c.next\n  return l.next if l and l.value == k else l\nprint('def removeKFromList(l1, k1):',removeKFromList(l1, k1))",
        "detail": "MISC.scrap.scrap",
        "documentation": {}
    },
    {
        "label": "l1",
        "kind": 5,
        "importPath": "MISC.scrap.scrap",
        "description": "MISC.scrap.scrap",
        "peekOfCode": "l1 = [3, 1, 2, 3, 4, 5]\nk1 = 3\nclass ListNode(object):\n  def __init__(self, x):\n    self.value = x\n    self.next = None\ndef removeKFromList(l, k):\n  c = l\n  while c:\n      if c.next and c.next.value == k:",
        "detail": "MISC.scrap.scrap",
        "documentation": {}
    },
    {
        "label": "k1",
        "kind": 5,
        "importPath": "MISC.scrap.scrap",
        "description": "MISC.scrap.scrap",
        "peekOfCode": "k1 = 3\nclass ListNode(object):\n  def __init__(self, x):\n    self.value = x\n    self.next = None\ndef removeKFromList(l, k):\n  c = l\n  while c:\n      if c.next and c.next.value == k:\n          c.next = c.next.next",
        "detail": "MISC.scrap.scrap",
        "documentation": {}
    },
    {
        "label": "add",
        "kind": 2,
        "importPath": "wk17.d1.challenges.challenges",
        "description": "wk17.d1.challenges.challenges",
        "peekOfCode": "def add(a, b):\n    return a + b\nprint(add(3, 2))\n# \"\"\"\n# Challenge #2:\n# Write a function that takes an integer `minutes` and converts it to seconds.\n# Examples:\n# - convert(5) ➞ 300\n# - convert(3) ➞ 180\n# - convert(2) ➞ 120",
        "detail": "wk17.d1.challenges.challenges",
        "documentation": {}
    },
    {
        "label": "convert",
        "kind": 2,
        "importPath": "wk17.d1.challenges.challenges",
        "description": "wk17.d1.challenges.challenges",
        "peekOfCode": "def convert(minutes):\n    return minutes * 60\nprint(convert(5))\n# \"\"\"\n# Challenge #3:\n# Create a function that takes a string and returns it as an integer.\n# Examples:\n# - string_int(\"6\") ➞ 6\n# - string_int(\"1000\") ➞ 1000\n# - string_int(\"12\") ➞ 12",
        "detail": "wk17.d1.challenges.challenges",
        "documentation": {}
    },
    {
        "label": "string_int",
        "kind": 2,
        "importPath": "wk17.d1.challenges.challenges",
        "description": "wk17.d1.challenges.challenges",
        "peekOfCode": "def string_int(txt):\n    return int(txt)\nprint(string_int(\"6\"))\nprint(string_int(\"1000\"))\nprint(string_int(\"12\"))\n# \"\"\"\n# Challenge #4:\n# Create a function that takes length and width and finds the perimeter of a\n# rectangle.\n# Examples:",
        "detail": "wk17.d1.challenges.challenges",
        "documentation": {}
    },
    {
        "label": "greet",
        "kind": 2,
        "importPath": "wk17.d1.challenges.cs46_python_i",
        "description": "wk17.d1.challenges.cs46_python_i",
        "peekOfCode": "def greet(name=\"world!\"):\n  print(type(name))\n  print(f\"Hello {name}\")\ngreet(\"1234\")\n# lets play with some strings\n# ['capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']\n# print(dir(\"\"))\nprint(help(\"\".count))\na = \"aabbccqqqq\"\nprint(a.count(\"q\"))",
        "detail": "wk17.d1.challenges.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "addition",
        "kind": 2,
        "importPath": "wk17.d1.challenges.cs46_python_i",
        "description": "wk17.d1.challenges.cs46_python_i",
        "peekOfCode": "def addition(a, b):\n    # Your code here\n\"\"\"\nChallenge #2:\nWrite a function that takes an integer `minutes` and converts it to seconds.\nExamples:\n- convert(5) ➞ 300\n- convert(3) ➞ 180\n- convert(2) ➞ 120\n\"\"\"",
        "detail": "wk17.d1.challenges.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "convert",
        "kind": 2,
        "importPath": "wk17.d1.challenges.cs46_python_i",
        "description": "wk17.d1.challenges.cs46_python_i",
        "peekOfCode": "def convert(minutes):\n    # Your code here\n\"\"\"\nChallenge #3:\nCreate a function that takes a string and returns it as an integer.\nExamples:\n- string_int(\"6\") ➞ 6\n- string_int(\"1000\") ➞ 1000\n- string_int(\"12\") ➞ 12\n\"\"\"",
        "detail": "wk17.d1.challenges.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "string_int",
        "kind": 2,
        "importPath": "wk17.d1.challenges.cs46_python_i",
        "description": "wk17.d1.challenges.cs46_python_i",
        "peekOfCode": "def string_int(txt):\n    # Your code here\n\"\"\"\nChallenge #4:\nCreate a function that takes length and width and finds the perimeter of a\nrectangle.\nExamples:\n- find_perimeter(6, 7) ➞ 26\n- find_perimeter(20, 10) ➞ 60\n- find_perimeter(2, 9) ➞ 22",
        "detail": "wk17.d1.challenges.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "find_perimeter",
        "kind": 2,
        "importPath": "wk17.d1.challenges.cs46_python_i",
        "description": "wk17.d1.challenges.cs46_python_i",
        "peekOfCode": "def find_perimeter(length, width):\n\"\"\"\nChallenge #5:\nCreate a function that returns a list of strings sorted by length in ascending\norder.\nExamples:\n- sort_by_length([\"a\", \"ccc\", \"dddd\", \"bb\"]) ➞ [\"a\", \"bb\", \"ccc\", \"dddd\"]\n- sort_by_length([\"apple\", \"pie\", \"shortcake\"]) ➞ [\"pie\", \"apple\", \"shortcake\"]\n- sort_by_length([\"may\", \"april\", \"september\", \"august\"]) ➞ [\"may\", \"april\", \"august\", \"september\"]\n- sort_by_length([]) ➞ []",
        "detail": "wk17.d1.challenges.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "sort_by_length",
        "kind": 2,
        "importPath": "wk17.d1.challenges.cs46_python_i",
        "description": "wk17.d1.challenges.cs46_python_i",
        "peekOfCode": "def sort_by_length(lst):\n\"\"\"\nChallenge #6:\nCreate a function that takes a string, checks if it has the same number of \"x\"s\nand \"o\"s and returns either True or False.\n- Return a boolean value (True or False).\n- The string can contain any character.\n- When no x and no o are in the string, return True.\nExamples:\n- XO(\"ooxx\") ➞ True",
        "detail": "wk17.d1.challenges.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "XO",
        "kind": 2,
        "importPath": "wk17.d1.challenges.cs46_python_i",
        "description": "wk17.d1.challenges.cs46_python_i",
        "peekOfCode": "def XO(txt):\n\"\"\"\nChallenge #7:\nGiven an unsorted list, create a function that returns the nth smallest element\n(the smallest element is the first smallest, the second smallest element is the\nsecond smallest, etc).\nExamples:\n- nth_smallest([7, 5, 3, 1], 1) ➞ 1\n- nth_smallest([1, 3, 5, 7], 3) ➞ 5\n- nth_smallest([1, 3, 5, 7], 5) ➞ None",
        "detail": "wk17.d1.challenges.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "nth_smallest",
        "kind": 2,
        "importPath": "wk17.d1.challenges.cs46_python_i",
        "description": "wk17.d1.challenges.cs46_python_i",
        "peekOfCode": "def nth_smallest(lst, n):\n\"\"\"\nChallenge #8:\nCreate a function that returns the number of arguments it was called with.\nExamples:\n- num_args() ➞ 0\n- num_args(\"foo\") ➞ 1\n- num_args(\"foo\", \"bar\") ➞ 2\n- num_args(True, False) ➞ 2\n- num_args({}) ➞ 1",
        "detail": "wk17.d1.challenges.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "num_args",
        "kind": 2,
        "importPath": "wk17.d1.challenges.cs46_python_i",
        "description": "wk17.d1.challenges.cs46_python_i",
        "peekOfCode": "def num_args():\n\"\"\"\nChallenge #9:\nWrite a function that creates a dictionary with each (key, value) pair being\nthe (lower case, upper case) versions of a letter, respectively.\nExamples:\n- mapping([\"p\", \"s\"]) ➞ { \"p\": \"P\", \"s\": \"S\" }\n- mapping([\"a\", \"b\", \"c\"]) ➞ { \"a\": \"A\", \"b\": \"B\", \"c\": \"C\" }\n- mapping([\"a\", \"v\", \"y\", \"z\"]) ➞ { \"a\": \"A\", \"v\": \"V\", \"y\": \"Y\", \"z\": \"Z\" }\nNotes:",
        "detail": "wk17.d1.challenges.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "mapping",
        "kind": 2,
        "importPath": "wk17.d1.challenges.cs46_python_i",
        "description": "wk17.d1.challenges.cs46_python_i",
        "peekOfCode": "def mapping(letters):\n\"\"\"\nChallenge #10:\nCreate a function that applies a discount d to every number in the list.\nExamples:\n- get_discounts([2, 4, 6, 11], \"50%\") ➞ [1, 2, 3, 5.5]\n- get_discounts([10, 20, 40, 80], \"75%\") ➞ [7.5, 15, 30, 60]\n- get_discounts([100], \"45%\") ➞ [45]\nNotes:\n- The discount is the percentage of the original price (i.e the discount of",
        "detail": "wk17.d1.challenges.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "get_discounts",
        "kind": 2,
        "importPath": "wk17.d1.challenges.cs46_python_i",
        "description": "wk17.d1.challenges.cs46_python_i",
        "peekOfCode": "def get_discounts(nums, percentage):",
        "detail": "wk17.d1.challenges.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk17.d1.challenges.cs46_python_i",
        "description": "wk17.d1.challenges.cs46_python_i",
        "peekOfCode": "a = 10\na = \"a string\"\na = 1.2\na = []\na = ()\na = {\"name\": \"Tom\"}\nb = []\nb.append(\"Dave\")\nb.append(\"Bob\")\nb.append(\"Joe\")",
        "detail": "wk17.d1.challenges.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk17.d1.challenges.cs46_python_i",
        "description": "wk17.d1.challenges.cs46_python_i",
        "peekOfCode": "a = \"a string\"\na = 1.2\na = []\na = ()\na = {\"name\": \"Tom\"}\nb = []\nb.append(\"Dave\")\nb.append(\"Bob\")\nb.append(\"Joe\")\n# print(type(a))",
        "detail": "wk17.d1.challenges.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk17.d1.challenges.cs46_python_i",
        "description": "wk17.d1.challenges.cs46_python_i",
        "peekOfCode": "a = 1.2\na = []\na = ()\na = {\"name\": \"Tom\"}\nb = []\nb.append(\"Dave\")\nb.append(\"Bob\")\nb.append(\"Joe\")\n# print(type(a))\n# print(a[\"name\"])",
        "detail": "wk17.d1.challenges.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk17.d1.challenges.cs46_python_i",
        "description": "wk17.d1.challenges.cs46_python_i",
        "peekOfCode": "a = []\na = ()\na = {\"name\": \"Tom\"}\nb = []\nb.append(\"Dave\")\nb.append(\"Bob\")\nb.append(\"Joe\")\n# print(type(a))\n# print(a[\"name\"])\n# print(dir([]))",
        "detail": "wk17.d1.challenges.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk17.d1.challenges.cs46_python_i",
        "description": "wk17.d1.challenges.cs46_python_i",
        "peekOfCode": "a = ()\na = {\"name\": \"Tom\"}\nb = []\nb.append(\"Dave\")\nb.append(\"Bob\")\nb.append(\"Joe\")\n# print(type(a))\n# print(a[\"name\"])\n# print(dir([]))\nprint(b.pop(0))",
        "detail": "wk17.d1.challenges.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk17.d1.challenges.cs46_python_i",
        "description": "wk17.d1.challenges.cs46_python_i",
        "peekOfCode": "a = {\"name\": \"Tom\"}\nb = []\nb.append(\"Dave\")\nb.append(\"Bob\")\nb.append(\"Joe\")\n# print(type(a))\n# print(a[\"name\"])\n# print(dir([]))\nprint(b.pop(0))\nprint(b)",
        "detail": "wk17.d1.challenges.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "wk17.d1.challenges.cs46_python_i",
        "description": "wk17.d1.challenges.cs46_python_i",
        "peekOfCode": "b = []\nb.append(\"Dave\")\nb.append(\"Bob\")\nb.append(\"Joe\")\n# print(type(a))\n# print(a[\"name\"])\n# print(dir([]))\nprint(b.pop(0))\nprint(b)\n\"\"\"# PYTHON I CODE: 5976\"\"\"",
        "detail": "wk17.d1.challenges.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk17.d1.challenges.cs46_python_i",
        "description": "wk17.d1.challenges.cs46_python_i",
        "peekOfCode": "a = [\"Dave\"] * 25\na[20] = \"Steve\"\n# for n in range(12, 25):\n#   print(a[n])\nfor x in enumerate(a):\n  i = x[0]\n  e = x[1]\n  if i == 9:\n    continue\n  print(i)",
        "detail": "wk17.d1.challenges.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "a[20]",
        "kind": 5,
        "importPath": "wk17.d1.challenges.cs46_python_i",
        "description": "wk17.d1.challenges.cs46_python_i",
        "peekOfCode": "a[20] = \"Steve\"\n# for n in range(12, 25):\n#   print(a[n])\nfor x in enumerate(a):\n  i = x[0]\n  e = x[1]\n  if i == 9:\n    continue\n  print(i)\n  print(e)",
        "detail": "wk17.d1.challenges.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk17.d1.challenges.cs46_python_i",
        "description": "wk17.d1.challenges.cs46_python_i",
        "peekOfCode": "a = int(input(\"input a number! \"))\nb = int(input(\"input a number! \"))4\nprint(f\"{a + b}\")\n\"\"\"# PYTHON I CODE: 5976\"\"\"\n# lets reuse some code...\ndef greet(name=\"world!\"):\n  print(type(name))\n  print(f\"Hello {name}\")\ngreet(\"1234\")\n# lets play with some strings",
        "detail": "wk17.d1.challenges.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "wk17.d1.challenges.cs46_python_i",
        "description": "wk17.d1.challenges.cs46_python_i",
        "peekOfCode": "b = int(input(\"input a number! \"))4\nprint(f\"{a + b}\")\n\"\"\"# PYTHON I CODE: 5976\"\"\"\n# lets reuse some code...\ndef greet(name=\"world!\"):\n  print(type(name))\n  print(f\"Hello {name}\")\ngreet(\"1234\")\n# lets play with some strings\n# ['capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']",
        "detail": "wk17.d1.challenges.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk17.d1.challenges.cs46_python_i",
        "description": "wk17.d1.challenges.cs46_python_i",
        "peekOfCode": "a = \"aabbccqqqq\"\nprint(a.count(\"q\"))\n# Lets put it all together\n\"\"\"# Challenges\"\"\"\n\"\"\"\nChallenge #1:\nCreate a function that takes two numbers as arguments and return their sum.\nExamples:\n- addition(3, 2) ➞ 5\n- addition(-3, -6) ➞ -9",
        "detail": "wk17.d1.challenges.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "cmd",
        "kind": 5,
        "importPath": "wk17.d1.challenges.prac",
        "description": "wk17.d1.challenges.prac",
        "peekOfCode": "cmd = \"\"\nwhile cmd != \"exit\":\n    cmd == input(\">>\")\n    if cmd == \"hello\" or cmd == \"hi\":\n        print(\"hello\")\n    elif cmd == \"goodbye\":\n        print(\"did you mean to exit?\")\n    elif cmd == \"exit\":\n        print(\"Thanks for using repl\")\n    else:",
        "detail": "wk17.d1.challenges.prac",
        "documentation": {}
    },
    {
        "label": "Animal",
        "kind": 6,
        "importPath": "wk17.d1.copy_of_cs47_python_ii",
        "description": "wk17.d1.copy_of_cs47_python_ii",
        "peekOfCode": "class Animal:\n    def __init__(self, name=\"\", kind=\"\", color=\"\"):\n        self.name = name\n        self.color = color\n        self.kind = kind\n    def description(self):\n        # return \"%s is a %s %s.\" % (self.name, self.color, self.kind)\n        return f\"{self.name} is a {self.color} {self.kind}\"\n\"\"\"\ninstantiate an instance of the Animal class labeled cat",
        "detail": "wk17.d1.copy_of_cs47_python_ii",
        "documentation": {}
    },
    {
        "label": "last",
        "kind": 2,
        "importPath": "wk17.d1.copy_of_cs47_python_ii",
        "description": "wk17.d1.copy_of_cs47_python_ii",
        "peekOfCode": "def last(a, n):\n    if n > len(a):\n        return \"invalid\"\n    if n == 0:\n        return []\n    return a[0 - n : len(a)]\n# tests\nprint(last([1, 2, 3, 4, 5], 1))  #  ➞ [5]\nprint(last([4, 3, 9, 9, 7, 6], 3))  #  ➞ [9, 7, 6]\nprint(last([1, 2, 3, 4, 5], 7))  # ➞ \"invalid\"",
        "detail": "wk17.d1.copy_of_cs47_python_ii",
        "documentation": {}
    },
    {
        "label": "add_indexes",
        "kind": 2,
        "importPath": "wk17.d1.copy_of_cs47_python_ii",
        "description": "wk17.d1.copy_of_cs47_python_ii",
        "peekOfCode": "def add_indexes(numbers):\n    pass",
        "detail": "wk17.d1.copy_of_cs47_python_ii",
        "documentation": {}
    },
    {
        "label": "output",
        "kind": 5,
        "importPath": "wk17.d1.copy_of_cs47_python_ii",
        "description": "wk17.d1.copy_of_cs47_python_ii",
        "peekOfCode": "output = []\nmath_module_functions_list = dir(math)\nfor function_string in math_module_functions_list:\n    if function_string[0:2] == \"is\":\n        output.append(function_string)\noutput.sort()\nprint(output)\n# print(func)\n# if func == \"isinf\":\n#   print(\"i got one!\")",
        "detail": "wk17.d1.copy_of_cs47_python_ii",
        "documentation": {}
    },
    {
        "label": "math_module_functions_list",
        "kind": 5,
        "importPath": "wk17.d1.copy_of_cs47_python_ii",
        "description": "wk17.d1.copy_of_cs47_python_ii",
        "peekOfCode": "math_module_functions_list = dir(math)\nfor function_string in math_module_functions_list:\n    if function_string[0:2] == \"is\":\n        output.append(function_string)\noutput.sort()\nprint(output)\n# print(func)\n# if func == \"isinf\":\n#   print(\"i got one!\")\n# print(\"bobinf\".startswith(\"is\"))",
        "detail": "wk17.d1.copy_of_cs47_python_ii",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "wk17.d1.copy_of_cs47_python_ii",
        "description": "wk17.d1.copy_of_cs47_python_ii",
        "peekOfCode": "s = \"this is a string\"\ns_l = s.split()\ns_l.reverse()\nreversed_string = \" \".join(s_l)\nprint(s)\nprint(reversed_string)\n\"\"\"\nBelow, you'll find a class definition for animals. Create two new animals `cat`\nand `dog`. Set `cat` to have a name of \"Purrfect\", kind of \"cat\",\nand color of \"brown\". Set `dog` to have a name of \"Fido\",",
        "detail": "wk17.d1.copy_of_cs47_python_ii",
        "documentation": {}
    },
    {
        "label": "s_l",
        "kind": 5,
        "importPath": "wk17.d1.copy_of_cs47_python_ii",
        "description": "wk17.d1.copy_of_cs47_python_ii",
        "peekOfCode": "s_l = s.split()\ns_l.reverse()\nreversed_string = \" \".join(s_l)\nprint(s)\nprint(reversed_string)\n\"\"\"\nBelow, you'll find a class definition for animals. Create two new animals `cat`\nand `dog`. Set `cat` to have a name of \"Purrfect\", kind of \"cat\",\nand color of \"brown\". Set `dog` to have a name of \"Fido\",\nkind of \"dog\", and color of \"black\".",
        "detail": "wk17.d1.copy_of_cs47_python_ii",
        "documentation": {}
    },
    {
        "label": "reversed_string",
        "kind": 5,
        "importPath": "wk17.d1.copy_of_cs47_python_ii",
        "description": "wk17.d1.copy_of_cs47_python_ii",
        "peekOfCode": "reversed_string = \" \".join(s_l)\nprint(s)\nprint(reversed_string)\n\"\"\"\nBelow, you'll find a class definition for animals. Create two new animals `cat`\nand `dog`. Set `cat` to have a name of \"Purrfect\", kind of \"cat\",\nand color of \"brown\". Set `dog` to have a name of \"Fido\",\nkind of \"dog\", and color of \"black\".\n\"\"\"\nclass Animal:",
        "detail": "wk17.d1.copy_of_cs47_python_ii",
        "documentation": {}
    },
    {
        "label": "cat",
        "kind": 5,
        "importPath": "wk17.d1.copy_of_cs47_python_ii",
        "description": "wk17.d1.copy_of_cs47_python_ii",
        "peekOfCode": "cat = Animal(\"Purrfect\", \"cat\", \"Brown\")\ndog = Animal()\n# cat.name = \"Purrfect\"\n# cat.kind = \"cat\"\n# cat.color = \"brown\"\ndog.name = \"Fido\"\ndog.kind = \"dog\"\ndog.color = \"black\"\n# print(help([].sort))\n# Should print Purrfect is a brown cat.",
        "detail": "wk17.d1.copy_of_cs47_python_ii",
        "documentation": {}
    },
    {
        "label": "dog",
        "kind": 5,
        "importPath": "wk17.d1.copy_of_cs47_python_ii",
        "description": "wk17.d1.copy_of_cs47_python_ii",
        "peekOfCode": "dog = Animal()\n# cat.name = \"Purrfect\"\n# cat.kind = \"cat\"\n# cat.color = \"brown\"\ndog.name = \"Fido\"\ndog.kind = \"dog\"\ndog.color = \"black\"\n# print(help([].sort))\n# Should print Purrfect is a brown cat.\nprint(cat.description())",
        "detail": "wk17.d1.copy_of_cs47_python_ii",
        "documentation": {}
    },
    {
        "label": "dog.name",
        "kind": 5,
        "importPath": "wk17.d1.copy_of_cs47_python_ii",
        "description": "wk17.d1.copy_of_cs47_python_ii",
        "peekOfCode": "dog.name = \"Fido\"\ndog.kind = \"dog\"\ndog.color = \"black\"\n# print(help([].sort))\n# Should print Purrfect is a brown cat.\nprint(cat.description())\n# Should print Fido is a black dog.\nprint(dog.description())\n\"\"\"# Demo\"\"\"\n\"\"\"",
        "detail": "wk17.d1.copy_of_cs47_python_ii",
        "documentation": {}
    },
    {
        "label": "dog.kind",
        "kind": 5,
        "importPath": "wk17.d1.copy_of_cs47_python_ii",
        "description": "wk17.d1.copy_of_cs47_python_ii",
        "peekOfCode": "dog.kind = \"dog\"\ndog.color = \"black\"\n# print(help([].sort))\n# Should print Purrfect is a brown cat.\nprint(cat.description())\n# Should print Fido is a black dog.\nprint(dog.description())\n\"\"\"# Demo\"\"\"\n\"\"\"\nChallenge #1:",
        "detail": "wk17.d1.copy_of_cs47_python_ii",
        "documentation": {}
    },
    {
        "label": "dog.color",
        "kind": 5,
        "importPath": "wk17.d1.copy_of_cs47_python_ii",
        "description": "wk17.d1.copy_of_cs47_python_ii",
        "peekOfCode": "dog.color = \"black\"\n# print(help([].sort))\n# Should print Purrfect is a brown cat.\nprint(cat.description())\n# Should print Fido is a black dog.\nprint(dog.description())\n\"\"\"# Demo\"\"\"\n\"\"\"\nChallenge #1:\nWrite a function that retrieves the last n elements from a list.",
        "detail": "wk17.d1.copy_of_cs47_python_ii",
        "documentation": {}
    },
    {
        "label": "addition",
        "kind": 2,
        "importPath": "wk17.d1.cs46_python_i",
        "description": "wk17.d1.cs46_python_i",
        "peekOfCode": "def addition(a, b):\n    # Your code here\n\"\"\"\nChallenge #2:\nWrite a function that takes an integer `minutes` and converts it to seconds.\nExamples:\n- convert(5) ➞ 300\n- convert(3) ➞ 180\n- convert(2) ➞ 120\n\"\"\"",
        "detail": "wk17.d1.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "convert",
        "kind": 2,
        "importPath": "wk17.d1.cs46_python_i",
        "description": "wk17.d1.cs46_python_i",
        "peekOfCode": "def convert(minutes):\n    # Your code here\n\"\"\"\nChallenge #3:\nCreate a function that takes a string and returns it as an integer.\nExamples:\n- string_int(\"6\") ➞ 6\n- string_int(\"1000\") ➞ 1000\n- string_int(\"12\") ➞ 12\n\"\"\"",
        "detail": "wk17.d1.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "string_int",
        "kind": 2,
        "importPath": "wk17.d1.cs46_python_i",
        "description": "wk17.d1.cs46_python_i",
        "peekOfCode": "def string_int(txt):\n    # Your code here\n\"\"\"\nChallenge #4:\nCreate a function that takes length and width and finds the perimeter of a\nrectangle.\nExamples:\n- find_perimeter(6, 7) ➞ 26\n- find_perimeter(20, 10) ➞ 60\n- find_perimeter(2, 9) ➞ 22",
        "detail": "wk17.d1.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "find_perimeter",
        "kind": 2,
        "importPath": "wk17.d1.cs46_python_i",
        "description": "wk17.d1.cs46_python_i",
        "peekOfCode": "def find_perimeter(length, width):\n\"\"\"\nChallenge #5:\nCreate a function that returns a list of strings sorted by length in ascending\norder.\nExamples:\n- sort_by_length([\"a\", \"ccc\", \"dddd\", \"bb\"]) ➞ [\"a\", \"bb\", \"ccc\", \"dddd\"]\n- sort_by_length([\"apple\", \"pie\", \"shortcake\"]) ➞ [\"pie\", \"apple\", \"shortcake\"]\n- sort_by_length([\"may\", \"april\", \"september\", \"august\"]) ➞ [\"may\", \"april\", \"august\", \"september\"]\n- sort_by_length([]) ➞ []",
        "detail": "wk17.d1.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "sort_by_length",
        "kind": 2,
        "importPath": "wk17.d1.cs46_python_i",
        "description": "wk17.d1.cs46_python_i",
        "peekOfCode": "def sort_by_length(lst):\n\"\"\"\nChallenge #6:\nCreate a function that takes a string, checks if it has the same number of \"x\"s\nand \"o\"s and returns either True or False.\n- Return a boolean value (True or False).\n- The string can contain any character.\n- When no x and no o are in the string, return True.\nExamples:\n- XO(\"ooxx\") ➞ True",
        "detail": "wk17.d1.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "XO",
        "kind": 2,
        "importPath": "wk17.d1.cs46_python_i",
        "description": "wk17.d1.cs46_python_i",
        "peekOfCode": "def XO(txt):\n\"\"\"\nChallenge #7:\nGiven an unsorted list, create a function that returns the nth smallest element\n(the smallest element is the first smallest, the second smallest element is the\nsecond smallest, etc).\nExamples:\n- nth_smallest([7, 5, 3, 1], 1) ➞ 1\n- nth_smallest([1, 3, 5, 7], 3) ➞ 5\n- nth_smallest([1, 3, 5, 7], 5) ➞ None",
        "detail": "wk17.d1.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "nth_smallest",
        "kind": 2,
        "importPath": "wk17.d1.cs46_python_i",
        "description": "wk17.d1.cs46_python_i",
        "peekOfCode": "def nth_smallest(lst, n):\n\"\"\"\nChallenge #8:\nCreate a function that returns the number of arguments it was called with.\nExamples:\n- num_args() ➞ 0\n- num_args(\"foo\") ➞ 1\n- num_args(\"foo\", \"bar\") ➞ 2\n- num_args(True, False) ➞ 2\n- num_args({}) ➞ 1",
        "detail": "wk17.d1.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "num_args",
        "kind": 2,
        "importPath": "wk17.d1.cs46_python_i",
        "description": "wk17.d1.cs46_python_i",
        "peekOfCode": "def num_args():\n\"\"\"\nChallenge #9:\nWrite a function that creates a dictionary with each (key, value) pair being\nthe (lower case, upper case) versions of a letter, respectively.\nExamples:\n- mapping([\"p\", \"s\"]) ➞ { \"p\": \"P\", \"s\": \"S\" }\n- mapping([\"a\", \"b\", \"c\"]) ➞ { \"a\": \"A\", \"b\": \"B\", \"c\": \"C\" }\n- mapping([\"a\", \"v\", \"y\", \"z\"]) ➞ { \"a\": \"A\", \"v\": \"V\", \"y\": \"Y\", \"z\": \"Z\" }\nNotes:",
        "detail": "wk17.d1.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "mapping",
        "kind": 2,
        "importPath": "wk17.d1.cs46_python_i",
        "description": "wk17.d1.cs46_python_i",
        "peekOfCode": "def mapping(letters):\n\"\"\"\nChallenge #10:\nCreate a function that applies a discount d to every number in the list.\nExamples:\n- get_discounts([2, 4, 6, 11], \"50%\") ➞ [1, 2, 3, 5.5]\n- get_discounts([10, 20, 40, 80], \"75%\") ➞ [7.5, 15, 30, 60]\n- get_discounts([100], \"45%\") ➞ [45]\nNotes:\n- The discount is the percentage of the original price (i.e the discount of",
        "detail": "wk17.d1.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "get_discounts",
        "kind": 2,
        "importPath": "wk17.d1.cs46_python_i",
        "description": "wk17.d1.cs46_python_i",
        "peekOfCode": "def get_discounts(nums, percentage):",
        "detail": "wk17.d1.cs46_python_i",
        "documentation": {}
    },
    {
        "label": "csnakeltjazzy",
        "kind": 2,
        "importPath": "wk17.d2.code-signal.jazzy",
        "description": "wk17.d2.code-signal.jazzy",
        "peekOfCode": "def csnakeltjazzy(chords):\nnewchords - []\nfor chord in chords: [\nif chord.isdigit(): ‘\nj newchords.appendEchordfl\nelif len(chords) -- 9:\nreturn []\nelse:\naddSeven - chord\naddSeven - addSeven[e:] + \"7\"",
        "detail": "wk17.d2.code-signal.jazzy",
        "documentation": {}
    },
    {
        "label": "csWhereIsBob",
        "kind": 2,
        "importPath": "wk17.d2.code-signal.return-index-of-string-in-list",
        "description": "wk17.d2.code-signal.return-index-of-string-in-list",
        "peekOfCode": "def csWhereIsBob(names):\n    bob = \"Bob\"\n    if bob in names:\n        return names.index(\"Bob\")\n    else:\n        return -1",
        "detail": "wk17.d2.code-signal.return-index-of-string-in-list",
        "documentation": {}
    },
    {
        "label": "csAnythingButFive",
        "kind": 2,
        "importPath": "wk17.d2.more-examples.anithingButFive",
        "description": "wk17.d2.more-examples.anithingButFive",
        "peekOfCode": "def csAnythingButFive(start, end):\n    count = 0\n    new_list = []\n    for num in range(start, end + 1):\n        str_num = str(num)\n        if \"5\" in str_num:\n            continue\n        count += 1\n    return count\nprint(csAnythingButFive(1, 5))",
        "detail": "wk17.d2.more-examples.anithingButFive",
        "documentation": {}
    },
    {
        "label": "csBinaryToASCII",
        "kind": 2,
        "importPath": "wk17.d2.more-examples.binaryToASCII",
        "description": "wk17.d2.more-examples.binaryToASCII",
        "peekOfCode": "def csBinaryToASCII(binary):\n    binary_letters = []\n    letters = \"\"\n    if binary == \"\":\n        return \"\"\n    for index in range(0, len(binary), 8):\n        binary_letters.append(binary[index : index + 8])\n    print(binary_letters)\n    for string in binary_letters:\n        binary_int = v = chr(int(string, 2))",
        "detail": "wk17.d2.more-examples.binaryToASCII",
        "documentation": {}
    },
    {
        "label": "csFindAddedLetter",
        "kind": 2,
        "importPath": "wk17.d2.more-examples.findAddedLetter",
        "description": "wk17.d2.more-examples.findAddedLetter",
        "peekOfCode": "def csFindAddedLetter(str_1, str_2):\n    m1 = {}\n    for i in str_2:\n        if i in m1:\n            m1[i] += 1\n        else:\n            m1[i] = 1\n    for i in str_1:\n        m1[i] -= 1\n    for h1 in m1:",
        "detail": "wk17.d2.more-examples.findAddedLetter",
        "documentation": {}
    },
    {
        "label": "csFindTheSingleNumber",
        "kind": 2,
        "importPath": "wk17.d2.more-examples.findTheSingleNumber",
        "description": "wk17.d2.more-examples.findTheSingleNumber",
        "peekOfCode": "def csFindTheSingleNumber(nums):\n    frequency = Counter(nums)\n    for i in frequency:\n        if frequency[i] == 1:\n            return i",
        "detail": "wk17.d2.more-examples.findTheSingleNumber",
        "documentation": {}
    },
    {
        "label": "csMakeItJazzy",
        "kind": 2,
        "importPath": "wk17.d2.more-examples.makeItJazzy",
        "description": "wk17.d2.more-examples.makeItJazzy",
        "peekOfCode": "def csMakeItJazzy(chords):\n    for index in range(len(chords)):\n        if chords[index].__contains__(\"7\"):\n            continue\n        elif chords == []:\n            return []\n        else:\n            chords[index] = chords[index] + \"7\"\n    return chords",
        "detail": "wk17.d2.more-examples.makeItJazzy",
        "documentation": {}
    },
    {
        "label": "csMaxNumberOfLambdas",
        "kind": 2,
        "importPath": "wk17.d2.more-examples.maxNumberOfLambdas",
        "description": "wk17.d2.more-examples.maxNumberOfLambdas",
        "peekOfCode": "def csMaxNumberOfLambdas(text):\n    sub_string = \"lambda\"\n    lambda_count = {\"l\": 0, \"a\": 0, \"m\": 0, \"b\": 0, \"d\": 0, \"a\": 0}\n    counts = []\n    for letter in text:\n        if letter in lambda_count:\n            lambda_count[letter] += 1\n    for key, value in lambda_count.items():\n        counts.append(value)\n    return min(counts)",
        "detail": "wk17.d2.more-examples.maxNumberOfLambdas",
        "documentation": {}
    },
    {
        "label": "get_count",
        "kind": 2,
        "importPath": "wk17.d2.more-examples.python_challenges",
        "description": "wk17.d2.more-examples.python_challenges",
        "peekOfCode": "def get_count(input_str):\n    # Your code here\n    vowel_counts = {}  # this is a dictionary to store the vowels\n    for vowel in \"aeiou\":\n        count = input_str.count(vowel)\n        vowel_counts[vowel] = count\n        print(vowel_counts)\n        counts = vowel_counts.values()\n    return sum(counts)\nprint(get_count(\"adela are mere\"))",
        "detail": "wk17.d2.more-examples.python_challenges",
        "documentation": {}
    },
    {
        "label": "data_type",
        "kind": 2,
        "importPath": "wk17.d2.more-examples.python_challenges",
        "description": "wk17.d2.more-examples.python_challenges",
        "peekOfCode": "def data_type(value):\n    # Your code here\n    date = datetime.date\n    if type(value) is int:\n        return \"integer\"\n    elif type(value) is str:\n        return \"string\"\n    elif type(value) is list:\n        return \"list\"\n    elif type(value) is dict:",
        "detail": "wk17.d2.more-examples.python_challenges",
        "documentation": {}
    },
    {
        "label": "emotify",
        "kind": 2,
        "importPath": "wk17.d2.more-examples.python_challenges",
        "description": "wk17.d2.more-examples.python_challenges",
        "peekOfCode": "def emotify(txt):\n    # Your code here\n    # ````another option```\n    # new = txt.split(' ')\n    # print(new)\n    # ````````````\n    new_list = list(txt)\n    # print(new_list)\n    sliced_list = new_list[8:]\n    emotion = \"\".join(sliced_list)",
        "detail": "wk17.d2.more-examples.python_challenges",
        "documentation": {}
    },
    {
        "label": "multiply_nums",
        "kind": 2,
        "importPath": "wk17.d2.more-examples.python_challenges",
        "description": "wk17.d2.more-examples.python_challenges",
        "peekOfCode": "def multiply_nums(nums):\n    # Your code here\n    # nums = \"2, 4, 6\"\n    integer_list = []\n    new_list = list(nums)\n    sliced_list = new_list[0::3]\n    print(sliced_list)\n    for elem in sliced_list:\n        int_elem = int(elem)\n        integer_list.append(int_elem)",
        "detail": "wk17.d2.more-examples.python_challenges",
        "documentation": {}
    },
    {
        "label": "add_indexes",
        "kind": 2,
        "importPath": "wk17.d2.more-examples.python_challenges",
        "description": "wk17.d2.more-examples.python_challenges",
        "peekOfCode": "def add_indexes(numbers):\n    # Your code here\n    new_list = []\n    for index, value in enumerate(numbers):\n        sum = index + value\n        new_list.append(sum)\n    return new_list\nenumerate(my_list)  # tuples of the index and the value of the list\nlist(enumerate(a_list))  # and makes it into an array\nfor item in enumerate(a_list):",
        "detail": "wk17.d2.more-examples.python_challenges",
        "documentation": {}
    },
    {
        "label": "last",
        "kind": 2,
        "importPath": "wk17.d2.more-examples.python_challenges",
        "description": "wk17.d2.more-examples.python_challenges",
        "peekOfCode": "def last(a, n):\n    # Your code here\n    if n > len(a):\n        return \"invalid\"\n    elif n == 0:\n        return []\n    else:\n        return a[-n:]  # the last 3/n elements\nprint(last([1, 2, 3, 4, 5], 1))\n\"\"\"",
        "detail": "wk17.d2.more-examples.python_challenges",
        "documentation": {}
    },
    {
        "label": "get_middle",
        "kind": 2,
        "importPath": "wk17.d2.more-examples.python_challenges",
        "description": "wk17.d2.more-examples.python_challenges",
        "peekOfCode": "def get_middle(input_str):\n    # Your code here\n    return input_str[(len(input_str) - 1) // 2 : (len(input_str) + 2) // 2]\nprint(get_middle(\"test\"))\nprint(get_middle(\"testing\"))\nprint(get_middle(\"middle\"))\nprint(get_middle(\"A\"))\nprint(get_middle(\"beyoudre\"))\nprint(get_middle(\"you\"))\n# Given a string of words, return the length of the shortest word(s).",
        "detail": "wk17.d2.more-examples.python_challenges",
        "documentation": {}
    },
    {
        "label": "csShortestWord",
        "kind": 2,
        "importPath": "wk17.d2.more-examples.python_challenges",
        "description": "wk17.d2.more-examples.python_challenges",
        "peekOfCode": "def csShortestWord(input_str):\n    word = map(len, input_str.split())\n    return min(word)\n# Given an array of integers, return the sum of all the positive integers in the array.\n# Examples:\n# csSumOfPositive([1, 2, 3, -4, 5]) -> 1 + 2 + 3 + 5 = 11\n# csSumOfPositive([-3, -2, -1, 0, 1]) -> 1\n# csSumOfPositive([-3, -2]) -> 0\n# Notes:\n# If the input_arr does not contain any positive integers, the default sum should be 0.",
        "detail": "wk17.d2.more-examples.python_challenges",
        "documentation": {}
    },
    {
        "label": "csSumOfPositive",
        "kind": 2,
        "importPath": "wk17.d2.more-examples.python_challenges",
        "description": "wk17.d2.more-examples.python_challenges",
        "peekOfCode": "def csSumOfPositive(input_arr):\n    new_array = []\n    for num in input_arr:\n        if num > 0:\n            new_array.append(num)\n        else:\n            continue\n    return math.fsum(new_array)\n\"\"\"\nChallenge #10:",
        "detail": "wk17.d2.more-examples.python_challenges",
        "documentation": {}
    },
    {
        "label": "max_and_min",
        "kind": 2,
        "importPath": "wk17.d2.more-examples.python_challenges",
        "description": "wk17.d2.more-examples.python_challenges",
        "peekOfCode": "def max_and_min(input_str):\n    # Your code here\n    new_list = list(map(int, input_str.split()))\n    new_string = str(max(new_list)) + \" \" + str(min(new_list))\n    print(type(new_string))\n    return new_string\nprint(max_and_min(\"1 2 3 4 5\"))\nprint(max_and_min(\"1 2 -3 4 5\"))\nprint(max_and_min(\"1 9 3 4 -5\"))\n\"\"\"",
        "detail": "wk17.d2.more-examples.python_challenges",
        "documentation": {}
    },
    {
        "label": "get_discounts",
        "kind": 2,
        "importPath": "wk17.d2.more-examples.python_challenges",
        "description": "wk17.d2.more-examples.python_challenges",
        "peekOfCode": "def get_discounts(nums, percentage):\n    # Your code here\n    new_percentage = list(percentage)\n    discount_str = int(new_percentage[0] + new_percentage[1])\n    discount = int(discount_str) / 100\n    print(discount)\n    d = []\n    for num in nums:\n        num = discount * num\n        s = str(num)",
        "detail": "wk17.d2.more-examples.python_challenges",
        "documentation": {}
    },
    {
        "label": "csOppositeReverse",
        "kind": 2,
        "importPath": "wk17.d2.more-examples.python_exercises",
        "description": "wk17.d2.more-examples.python_exercises",
        "peekOfCode": "def csOppositeReverse(txt):\n    return txt.swapcase()[::-1]\nprint(csOppositeReverse(text))\n# puterea a doua a fiecarui digit intr un numar\ndef csSquareAllDigits(n):\n    return int(\"\".join(str(int(i) ** 2) for i in str(n)))\n# take out the vowels of a string\nimport re\ndef csRemoveTheVowels(txt):\n    # vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]",
        "detail": "wk17.d2.more-examples.python_exercises",
        "documentation": {}
    },
    {
        "label": "csSquareAllDigits",
        "kind": 2,
        "importPath": "wk17.d2.more-examples.python_exercises",
        "description": "wk17.d2.more-examples.python_exercises",
        "peekOfCode": "def csSquareAllDigits(n):\n    return int(\"\".join(str(int(i) ** 2) for i in str(n)))\n# take out the vowels of a string\nimport re\ndef csRemoveTheVowels(txt):\n    # vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    # return \"\".join([l for l in txt if l not in vowels])\n    return re.sub(r\"[AEIOU]\", \"\", txt, flags=re.IGNORECASE)\nprint(csRemoveTheVowels(text))",
        "detail": "wk17.d2.more-examples.python_exercises",
        "documentation": {}
    },
    {
        "label": "csRemoveTheVowels",
        "kind": 2,
        "importPath": "wk17.d2.more-examples.python_exercises",
        "description": "wk17.d2.more-examples.python_exercises",
        "peekOfCode": "def csRemoveTheVowels(txt):\n    # vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    # return \"\".join([l for l in txt if l not in vowels])\n    return re.sub(r\"[AEIOU]\", \"\", txt, flags=re.IGNORECASE)\nprint(csRemoveTheVowels(text))",
        "detail": "wk17.d2.more-examples.python_exercises",
        "documentation": {}
    },
    {
        "label": "text",
        "kind": 5,
        "importPath": "wk17.d2.more-examples.python_exercises",
        "description": "wk17.d2.more-examples.python_exercises",
        "peekOfCode": "text = \"Adela, hi!\"\n# def csOppositeReverse(txt):\n#   for i in range(len(txt)):\n#     if re.match(\"^[a-z]+$\", txt[i]):\n#        txt[i] = txt[i].upper()\n#        return txt[::-1]\n#     elif re.match(\"^[A-Z]+$\", txt[i]):\n#       txt[i] = txt[i].lower()\n#       return txt[::-1]\ndef csOppositeReverse(txt):",
        "detail": "wk17.d2.more-examples.python_exercises",
        "documentation": {}
    },
    {
        "label": "csRaindrops",
        "kind": 2,
        "importPath": "wk17.d2.more-examples.rainDrops",
        "description": "wk17.d2.more-examples.rainDrops",
        "peekOfCode": "def csRaindrops(number):\n    output_string = \"\"\n    has_3_factor = output_string + \"Pling\"\n    if number % 3 == 0:\n        output_string += \"Pling\"\n    elif number % 5 == 0:\n        output_string += \"Plang\"\n    elif number % 7 == 0:\n        output_string += \"Plong\"\n    elif output_string is \"\":",
        "detail": "wk17.d2.more-examples.rainDrops",
        "documentation": {}
    },
    {
        "label": "repeat_it",
        "kind": 2,
        "importPath": "wk17.d2.more-examples.repeat_it",
        "description": "wk17.d2.more-examples.repeat_it",
        "peekOfCode": "def repeat_it(input_str):\n    # Your code here\n    new_list = list(input_str)\n    empty = []\n    for index, letter in enumerate(new_list):\n        letter = \"-\" + letter.upper() + (index * letter).lower()\n        empty.append(letter)\n        new_str = \"\".join(empty)\n        transformed = list(new_str)\n        good_string = transformed[1:]",
        "detail": "wk17.d2.more-examples.repeat_it",
        "documentation": {}
    },
    {
        "label": "csReverseIntegerBits",
        "kind": 2,
        "importPath": "wk17.d2.more-examples.reverseIntegerBits",
        "description": "wk17.d2.more-examples.reverseIntegerBits",
        "peekOfCode": "def csReverseIntegerBits(n):\n    reversed_num = 0\n    while n > 0:\n        reversed_num = reversed_num << 1\n        if n & 1 == 1:\n            reversed_num = reversed_num ^ 1\n        n = n >> 1\n    return reversed_num",
        "detail": "wk17.d2.more-examples.reverseIntegerBits",
        "documentation": {}
    },
    {
        "label": "schoolGroups",
        "kind": 2,
        "importPath": "wk17.d2.more-examples.schoolGroups",
        "description": "wk17.d2.more-examples.schoolGroups",
        "peekOfCode": "def schoolGroups(years, groups):\n    alphabet = list(map(chr, range(97, 123)))\n    emp_list = []\n    for year in range(1, years + 1):\n        for group in range(0, groups):\n            emp_list.append(f\"{year}{alphabet[group]}\")\n    # print(emp_list)\n    return \", \".join(emp_list)\nprint(schoolGroups(1, 4))\nprint(schoolGroups(6, 7))",
        "detail": "wk17.d2.more-examples.schoolGroups",
        "documentation": {}
    },
    {
        "label": "validParenthesesSequence",
        "kind": 2,
        "importPath": "wk17.d2.more-examples.validParenthasesSequence",
        "description": "wk17.d2.more-examples.validParenthasesSequence",
        "peekOfCode": "def validParenthesesSequence(s):\n    stack = []\n    # Traversing the Expression\n    for char in s:\n        if char in [\"(\", \"{\", \"[\"]:\n            stack.append(char)\n        else:\n            if not stack:\n                return False\n            current_char = stack.pop()",
        "detail": "wk17.d2.more-examples.validParenthasesSequence",
        "documentation": {}
    },
    {
        "label": "greet",
        "kind": 2,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "def greet(name=\"world!\"):\n  print(type(name))\n  print(f\"Hello {name}\")\ngreet(\"1234\")\n# lets play with some strings\n# ['capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']\n# print(dir(\"\"))\n# print(help(\"\".count))\na = \"aabbccqqZbqq\".swapcase()\nfor c in a:",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "addition",
        "kind": 2,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "def addition(a, b):\n    # Your code here\n  try:\n    a = int(a)\n    b = int(b)\n    return a + b\n  except:\n    print(\"please supply valid integer arguments\")\n    return 0\n# tests",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "convert",
        "kind": 2,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "def convert(minutes):\n    # Your code here\n    return minutes * 60\nprint(convert(5)) #  ➞ 300\nprint(convert(3)) #  ➞ 180\nprint(convert(2)) # ➞ 120\n\"\"\"\nChallenge #3:\nCreate a function that takes a string and returns it as an integer.\nExamples:",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "string_int",
        "kind": 2,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "def string_int(txt):\n    # Your code here\n\"\"\"\nChallenge #4:\nCreate a function that takes length and width and finds the perimeter of a\nrectangle.\nExamples:\n- find_perimeter(6, 7) ➞ 26\n- find_perimeter(20, 10) ➞ 60\n- find_perimeter(2, 9) ➞ 22",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "find_perimeter",
        "kind": 2,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "def find_perimeter(length, width):\n  result = (length * 2) + (width * 2)\n  return result\n# tests\nprint(find_perimeter(6, 7)) # ➞ 26\nprint(find_perimeter(20, 10)) # ➞ 60\nprint(find_perimeter(2, 9)) # ➞ 22\n\"\"\"\nChallenge #5:\nCreate a function that returns a list of strings sorted by length in ascending",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "sort_by_length",
        "kind": 2,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "def sort_by_length(lst):\n  \"\"\"\n    sort a list of stringe using the length of each string as the key\n    input: lst -> list(str)\n    output: -> list(str)\n  \"\"\"\n  return sorted(lst, key=len)\n\"\"\"\nChallenge #6:\nCreate a function that takes a string, checks if it has the same number of \"x\"s",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "XO",
        "kind": 2,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "def XO(txt):\n\"\"\"\nChallenge #7:\nGiven an unsorted list, create a function that returns the nth smallest element\n(the smallest element is the first smallest, the second smallest element is the\nsecond smallest, etc).\nExamples:\n- nth_smallest([7, 5, 3, 1], 1) ➞ 1\n- nth_smallest([1, 3, 5, 7], 3) ➞ 5\n- nth_smallest([1, 3, 5, 7], 5) ➞ None",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "nth_smallest",
        "kind": 2,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "def nth_smallest(lst, n):\n\"\"\"\nChallenge #8:\nCreate a function that returns the number of arguments it was called with.\nExamples:\n- num_args() ➞ 0\n- num_args(\"foo\") ➞ 1\n- num_args(\"foo\", \"bar\") ➞ 2\n- num_args(True, False) ➞ 2\n- num_args({}) ➞ 1",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "num_args",
        "kind": 2,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "def num_args():\n\"\"\"\nChallenge #9:\nWrite a function that creates a dictionary with each (key, value) pair being\nthe (lower case, upper case) versions of a letter, respectively.\nExamples:\n- mapping([\"p\", \"s\"]) ➞ { \"p\": \"P\", \"s\": \"S\" }\n- mapping([\"a\", \"b\", \"c\"]) ➞ { \"a\": \"A\", \"b\": \"B\", \"c\": \"C\" }\n- mapping([\"a\", \"v\", \"y\", \"z\"]) ➞ { \"a\": \"A\", \"v\": \"V\", \"y\": \"Y\", \"z\": \"Z\" }\nNotes:",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "mapping",
        "kind": 2,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "def mapping(letters):\n\"\"\"\nChallenge #10:\nCreate a function that applies a discount d to every number in the list.\nExamples:\n- get_discounts([2, 4, 6, 11], \"50%\") ➞ [1, 2, 3, 5.5]\n- get_discounts([10, 20, 40, 80], \"75%\") ➞ [7.5, 15, 30, 60]\n- get_discounts([100], \"45%\") ➞ [45]\nNotes:\n- The discount is the percentage of the original price (i.e the discount of",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "get_discounts",
        "kind": 2,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "def get_discounts(nums, percentage):",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "a = 10\na = \"a string\"\na = 1.2\na = []\na = ()\na = {\"name\": \"Tom\"}\nb = []\nb.append(\"Dave\")\nb.append(\"Bob\")\nb.append(\"Joe\")",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "a = \"a string\"\na = 1.2\na = []\na = ()\na = {\"name\": \"Tom\"}\nb = []\nb.append(\"Dave\")\nb.append(\"Bob\")\nb.append(\"Joe\")\n# print(type(a))",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "a = 1.2\na = []\na = ()\na = {\"name\": \"Tom\"}\nb = []\nb.append(\"Dave\")\nb.append(\"Bob\")\nb.append(\"Joe\")\n# print(type(a))\n# print(a[\"name\"])",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "a = []\na = ()\na = {\"name\": \"Tom\"}\nb = []\nb.append(\"Dave\")\nb.append(\"Bob\")\nb.append(\"Joe\")\n# print(type(a))\n# print(a[\"name\"])\n# print(dir([]))",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "a = ()\na = {\"name\": \"Tom\"}\nb = []\nb.append(\"Dave\")\nb.append(\"Bob\")\nb.append(\"Joe\")\n# print(type(a))\n# print(a[\"name\"])\n# print(dir([]))\nprint(b.pop(0))",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "a = {\"name\": \"Tom\"}\nb = []\nb.append(\"Dave\")\nb.append(\"Bob\")\nb.append(\"Joe\")\n# print(type(a))\n# print(a[\"name\"])\n# print(dir([]))\nprint(b.pop(0))\nprint(b)",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "b = []\nb.append(\"Dave\")\nb.append(\"Bob\")\nb.append(\"Joe\")\n# print(type(a))\n# print(a[\"name\"])\n# print(dir([]))\nprint(b.pop(0))\nprint(b)\n\"\"\"# PYTHON I CODE: 5976\"\"\"",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "a = [\"Dave\"] * 25\na[20] = \"Steve\"\n# for n in range(12, 25):\n#   print(a[n])\nfor x in enumerate(a):\n  i = x[0]\n  e = x[1]\n  if i == 9:\n    continue\n  print(i)",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "a[20]",
        "kind": 5,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "a[20] = \"Steve\"\n# for n in range(12, 25):\n#   print(a[n])\nfor x in enumerate(a):\n  i = x[0]\n  e = x[1]\n  if i == 9:\n    continue\n  print(i)\n  print(e)",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "a = int(input(\"input a number! \"))\nb = int(input(\"input a number! \"))4\nprint(f\"{a + b}\")\n\"\"\"# PYTHON I CODE: 5976\"\"\"\n# lets reuse some code...\ndef greet(name=\"world!\"):\n  print(type(name))\n  print(f\"Hello {name}\")\ngreet(\"1234\")\n# lets play with some strings",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "b = int(input(\"input a number! \"))4\nprint(f\"{a + b}\")\n\"\"\"# PYTHON I CODE: 5976\"\"\"\n# lets reuse some code...\ndef greet(name=\"world!\"):\n  print(type(name))\n  print(f\"Hello {name}\")\ngreet(\"1234\")\n# lets play with some strings\n# ['capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "a = \"aabbccqqZbqq\".swapcase()\nfor c in a:\n  if a.count(c) != 1:\n    print(c)\n# Lets put it all together\ncmd = \"\"\nwhile cmd != \"exit\":\n  cmd = input(\">> \")\n  if cmd == \"hello\" or cmd == \"hi\":\n    print(\"Hello to you!\")",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "cmd",
        "kind": 5,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "cmd = \"\"\nwhile cmd != \"exit\":\n  cmd = input(\">> \")\n  if cmd == \"hello\" or cmd == \"hi\":\n    print(\"Hello to you!\")\n  elif cmd == \"goodbye\":\n    print(\"did you mean exit?\")\n  elif cmd == \"exit\":\n    print(\"Thanks you for using the repl\")\n  else:",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "a = 3\nb = 2\nc = a + b\nreturn c\nreturn a + b = c\nreturn 3 + 2\n5 - 3 => 2\n5 - 2 => 3\n- addition(-3, -6) ➞ -9\n- addition(7, 3) ➞ 10",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "b = 2\nc = a + b\nreturn c\nreturn a + b = c\nreturn 3 + 2\n5 - 3 => 2\n5 - 2 => 3\n- addition(-3, -6) ➞ -9\n- addition(7, 3) ➞ 10\n\"\"\"",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "c",
        "kind": 5,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "c = a + b\nreturn c\nreturn a + b = c\nreturn 3 + 2\n5 - 3 => 2\n5 - 2 => 3\n- addition(-3, -6) ➞ -9\n- addition(7, 3) ➞ 10\n\"\"\"\n# - return a plus b",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "s = [\"a\", \"ccc\", \"dddd\", \"bb\"]\nd = {1: \"a\", 3: \"ccc\", 4: \"dddd\", 2: \"bb\"}\n\"\"\"\n  what not to do during your plan...\n  eg: go down a massive rabit hole and not read docs:::\n\"\"\"\n# create an empty dictionary\n# create a list to return\n# iterate over each string extract the len of the elem and the val of the elem\n#   use the len as the key and use the str as a val",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "d",
        "kind": 5,
        "importPath": "wk17.d2.copy_of_cs46_python_i",
        "description": "wk17.d2.copy_of_cs46_python_i",
        "peekOfCode": "d = {1: \"a\", 3: \"ccc\", 4: \"dddd\", 2: \"bb\"}\n\"\"\"\n  what not to do during your plan...\n  eg: go down a massive rabit hole and not read docs:::\n\"\"\"\n# create an empty dictionary\n# create a list to return\n# iterate over each string extract the len of the elem and the val of the elem\n#   use the len as the key and use the str as a val\n# store a prev key -1",
        "detail": "wk17.d2.copy_of_cs46_python_i",
        "documentation": {}
    },
    {
        "label": "Entity",
        "kind": 6,
        "importPath": "wk17.d2.copy_of_intro_python_ii",
        "description": "wk17.d2.copy_of_intro_python_ii",
        "peekOfCode": "class Entity:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    def __str__(self):\n        return f\"({self.x}, {self.y})\"\nclass Mob(Entity):\n    def __init__(self, x, y):\n        super().__init__(x, y)\n    def move(self, dir):",
        "detail": "wk17.d2.copy_of_intro_python_ii",
        "documentation": {}
    },
    {
        "label": "Mob",
        "kind": 6,
        "importPath": "wk17.d2.copy_of_intro_python_ii",
        "description": "wk17.d2.copy_of_intro_python_ii",
        "peekOfCode": "class Mob(Entity):\n    def __init__(self, x, y):\n        super().__init__(x, y)\n    def move(self, dir):\n        if dir == \"n\":\n            self.y -= 1\n        elif dir == \"s\":\n            self.y += 1\n        elif dir == \"w\":\n            self.x -= 1",
        "detail": "wk17.d2.copy_of_intro_python_ii",
        "documentation": {}
    },
    {
        "label": "last",
        "kind": 2,
        "importPath": "wk17.d2.copy_of_intro_python_ii",
        "description": "wk17.d2.copy_of_intro_python_ii",
        "peekOfCode": "def last(a, n):\n    if n > len(a):\n        return \"invalid\"\n    elif n == 0:\n        return []\n    return a[-n:]\nprint(last([1, 2, 3, 4, 5], 1))  # ➞ [5]\nprint(last([4, 3, 9, 9, 7, 6], 3))  # ➞ [9, 7, 6]\nprint(last([1, 2, 3, 4, 5], 7))  #  ➞ \"invalid\"\nprint(last([1, 2, 3, 4, 5], 0))  # ➞ []",
        "detail": "wk17.d2.copy_of_intro_python_ii",
        "documentation": {}
    },
    {
        "label": "parity",
        "kind": 2,
        "importPath": "wk17.d2.copy_of_intro_python_ii",
        "description": "wk17.d2.copy_of_intro_python_ii",
        "peekOfCode": "def parity(input_int):\n    if input_int % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\ndef parity2(input_int):\n    return \"Even\" if input_int % 2 == 0 else \"Odd\"\nprint(parity(0))  #  -> \"Even\"\nprint(parity(1))  #  -> \"Odd\"\nprint(parity(2))  # -> \"Even\"",
        "detail": "wk17.d2.copy_of_intro_python_ii",
        "documentation": {}
    },
    {
        "label": "parity2",
        "kind": 2,
        "importPath": "wk17.d2.copy_of_intro_python_ii",
        "description": "wk17.d2.copy_of_intro_python_ii",
        "peekOfCode": "def parity2(input_int):\n    return \"Even\" if input_int % 2 == 0 else \"Odd\"\nprint(parity(0))  #  -> \"Even\"\nprint(parity(1))  #  -> \"Odd\"\nprint(parity(2))  # -> \"Even\"\nprint(parity2(0))  #  -> \"Even\"\nprint(parity2(1))  #  -> \"Odd\"\nprint(parity2(2))  # -> \"Even\"",
        "detail": "wk17.d2.copy_of_intro_python_ii",
        "documentation": {}
    },
    {
        "label": "numbers",
        "kind": 5,
        "importPath": "wk17.d2.copy_of_intro_python_ii",
        "description": "wk17.d2.copy_of_intro_python_ii",
        "peekOfCode": "numbers = [12, 23, 1, 22]\n# print(l[::-1])\n# print(dir([]))\n# min and max\n# print(min(20, 10, 5)) # 5\n# print(max(20, 10, 5)) # 20\n# list index\n# s = \"100\"\n# if \"100\" in l:\n#   print(l.index(s))",
        "detail": "wk17.d2.copy_of_intro_python_ii",
        "documentation": {}
    },
    {
        "label": "l2",
        "kind": 5,
        "importPath": "wk17.d2.copy_of_intro_python_ii",
        "description": "wk17.d2.copy_of_intro_python_ii",
        "peekOfCode": "l2 = []\nfor number in numbers:\n    if number % 2 == 0:\n        l2.append(number * 2)\nprint(l2)\nl3 = [number * 2 for number in numbers if number % 2 == 0]\nprint(l3)\n\"\"\"# CODE: 6603\"\"\"\n# Classes and OOP\nclass Entity:",
        "detail": "wk17.d2.copy_of_intro_python_ii",
        "documentation": {}
    },
    {
        "label": "l3",
        "kind": 5,
        "importPath": "wk17.d2.copy_of_intro_python_ii",
        "description": "wk17.d2.copy_of_intro_python_ii",
        "peekOfCode": "l3 = [number * 2 for number in numbers if number % 2 == 0]\nprint(l3)\n\"\"\"# CODE: 6603\"\"\"\n# Classes and OOP\nclass Entity:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    def __str__(self):\n        return f\"({self.x}, {self.y})\"",
        "detail": "wk17.d2.copy_of_intro_python_ii",
        "documentation": {}
    },
    {
        "label": "e",
        "kind": 5,
        "importPath": "wk17.d2.copy_of_intro_python_ii",
        "description": "wk17.d2.copy_of_intro_python_ii",
        "peekOfCode": "e = Entity(10, 20)\n# print(e)\nm = Mob(10, 23)\nprint(m)\nm.move(\"n\")\nprint(m)\n\"\"\"# CODE: 6603\n# Demos\nWrite a function that retrieves the last n elements from a list.\nExamples:",
        "detail": "wk17.d2.copy_of_intro_python_ii",
        "documentation": {}
    },
    {
        "label": "m",
        "kind": 5,
        "importPath": "wk17.d2.copy_of_intro_python_ii",
        "description": "wk17.d2.copy_of_intro_python_ii",
        "peekOfCode": "m = Mob(10, 23)\nprint(m)\nm.move(\"n\")\nprint(m)\n\"\"\"# CODE: 6603\n# Demos\nWrite a function that retrieves the last n elements from a list.\nExamples:\n- last([1, 2, 3, 4, 5], 1) ➞ [5]\n- last([4, 3, 9, 9, 7, 6], 3) ➞ [9, 7, 6]",
        "detail": "wk17.d2.copy_of_intro_python_ii",
        "documentation": {}
    },
    {
        "label": "print_one_item",
        "kind": 2,
        "importPath": "wk17.d2.cs47_python_iii",
        "description": "wk17.d2.cs47_python_iii",
        "peekOfCode": "def print_one_item(items):\n    print(items[0])\n\"\"\"\nLinear Time O(n)\n\"\"\"\ndef print_every_item(items):\n    for item in items:\n        print(item)\n\"\"\"\nQuadratic Time O(n^2)",
        "detail": "wk17.d2.cs47_python_iii",
        "documentation": {}
    },
    {
        "label": "print_every_item",
        "kind": 2,
        "importPath": "wk17.d2.cs47_python_iii",
        "description": "wk17.d2.cs47_python_iii",
        "peekOfCode": "def print_every_item(items):\n    for item in items:\n        print(item)\n\"\"\"\nQuadratic Time O(n^2)\n\"\"\"\ndef print_pairs(items):\n    for item_one in items:\n        for item_two in items:\n            print(item_one, item_two)",
        "detail": "wk17.d2.cs47_python_iii",
        "documentation": {}
    },
    {
        "label": "print_pairs",
        "kind": 2,
        "importPath": "wk17.d2.cs47_python_iii",
        "description": "wk17.d2.cs47_python_iii",
        "peekOfCode": "def print_pairs(items):\n    for item_one in items:\n        for item_two in items:\n            print(item_one, item_two)\n\"\"\"\nWhat about constants?\n\"\"\"\ndef do_a_bunch_of_stuff(items):  # O(1 + n/2 + 2000) -> O(n)\n    last_idx = len(items) - 1\n    print(items[last_idx])  # O(1)",
        "detail": "wk17.d2.cs47_python_iii",
        "documentation": {}
    },
    {
        "label": "do_a_bunch_of_stuff",
        "kind": 2,
        "importPath": "wk17.d2.cs47_python_iii",
        "description": "wk17.d2.cs47_python_iii",
        "peekOfCode": "def do_a_bunch_of_stuff(items):  # O(1 + n/2 + 2000) -> O(n)\n    last_idx = len(items) - 1\n    print(items[last_idx])  # O(1)\n    middle_idx = len(items) / 2\n    idx = 0\n    while idx < middle_idx:  # O(n/2)\n        print(items[idx])\n        idx = idx + 1\n    for num in range(2000):  # O(2000)\n        print(num)",
        "detail": "wk17.d2.cs47_python_iii",
        "documentation": {}
    },
    {
        "label": "do_different_things",
        "kind": 2,
        "importPath": "wk17.d2.cs47_python_iii",
        "description": "wk17.d2.cs47_python_iii",
        "peekOfCode": "def do_different_things(items):  # O(n + n^2) -> O(n^2)\n    for item in items:  # O(n)\n        print(item)\n    for item_one in items:  # O(n * n) = O(n^2)\n        for item_two in items:\n            print(item_one, item_two)\n\"\"\"\nBig O is the worst case\n\"\"\"\ndef search_for_thing(items, thing):  # O(n)",
        "detail": "wk17.d2.cs47_python_iii",
        "documentation": {}
    },
    {
        "label": "search_for_thing",
        "kind": 2,
        "importPath": "wk17.d2.cs47_python_iii",
        "description": "wk17.d2.cs47_python_iii",
        "peekOfCode": "def search_for_thing(items, thing):  # O(n)\n    for item in items:\n        if item == thing:\n            return True\n    return False\n\"\"\"\nClassify the runtime complexity of the number_of_steps function below using Big O notation.\n\"\"\"\ndef number_of_steps(num):  # O(log(n))\n    steps = 0",
        "detail": "wk17.d2.cs47_python_iii",
        "documentation": {}
    },
    {
        "label": "number_of_steps",
        "kind": 2,
        "importPath": "wk17.d2.cs47_python_iii",
        "description": "wk17.d2.cs47_python_iii",
        "peekOfCode": "def number_of_steps(num):  # O(log(n))\n    steps = 0\n    while num > 0:\n        if num % 2 == 0:\n            num = num // 2\n        else:\n            num = num - 1\n        steps = steps + 1\n    return steps\n# print(number_of_steps(10))",
        "detail": "wk17.d2.cs47_python_iii",
        "documentation": {}
    },
    {
        "label": "print_lambda_n_times",
        "kind": 2,
        "importPath": "wk17.d2.cs47_python_iii",
        "description": "wk17.d2.cs47_python_iii",
        "peekOfCode": "def print_lambda_n_times(n):\n    for i in range(n):\n        print(\"lambda\")\ndef get_the_max(items_list):\n    maximum = float(\"-inf\")\n    for item in items_list:\n        if item > maximum:\n            maximum = item\n    return maximum\n\"\"\"",
        "detail": "wk17.d2.cs47_python_iii",
        "documentation": {}
    },
    {
        "label": "get_the_max",
        "kind": 2,
        "importPath": "wk17.d2.cs47_python_iii",
        "description": "wk17.d2.cs47_python_iii",
        "peekOfCode": "def get_the_max(items_list):\n    maximum = float(\"-inf\")\n    for item in items_list:\n        if item > maximum:\n            maximum = item\n    return maximum\n\"\"\"\nLinear Space O(n)\n\"\"\"\ndef append_to_list_n_times(n):",
        "detail": "wk17.d2.cs47_python_iii",
        "documentation": {}
    },
    {
        "label": "append_to_list_n_times",
        "kind": 2,
        "importPath": "wk17.d2.cs47_python_iii",
        "description": "wk17.d2.cs47_python_iii",
        "peekOfCode": "def append_to_list_n_times(n):\n    my_list = []  # O(1)\n    for _ in range(n):  # O(n)\n        my_list.append(\"lambda\")  # O(1)\n    return my_list\n\"\"\"\nUse Big O notation to classify the space complexity of the function below.\n\"\"\"\ndef fibonacci(n):  # O(n)\n    lst = [0, 1]  # O(2)",
        "detail": "wk17.d2.cs47_python_iii",
        "documentation": {}
    },
    {
        "label": "fibonacci",
        "kind": 2,
        "importPath": "wk17.d2.cs47_python_iii",
        "description": "wk17.d2.cs47_python_iii",
        "peekOfCode": "def fibonacci(n):  # O(n)\n    lst = [0, 1]  # O(2)\n    for i in range(2, n):  # O(n)\n        lst.append(lst[i - 2] + lst[i - 1])  # O(2)\n    return lst[n - 1]  # O(1)\n\"\"\"\nUse Big O notation to classify the space complexity of the function below.\n\"\"\"\ndef fibonacci_two(n):  # O(1)\n    x, y, z = 0, 1, None  # O(3)",
        "detail": "wk17.d2.cs47_python_iii",
        "documentation": {}
    },
    {
        "label": "fibonacci_two",
        "kind": 2,
        "importPath": "wk17.d2.cs47_python_iii",
        "description": "wk17.d2.cs47_python_iii",
        "peekOfCode": "def fibonacci_two(n):  # O(1)\n    x, y, z = 0, 1, None  # O(3)\n    if n == 0:\n        return x\n    if n == 1:\n        return y\n    for i in range(2, n):\n        z = x + y\n        x, y = y, z\n    return z",
        "detail": "wk17.d2.cs47_python_iii",
        "documentation": {}
    },
    {
        "label": "do_something",
        "kind": 2,
        "importPath": "wk17.d2.cs47_python_iii",
        "description": "wk17.d2.cs47_python_iii",
        "peekOfCode": "def do_something(n):  # O(n^2)\n    lst = []  # O(1)\n    for i in range(n):  # O(n)\n        for j in range(n):  # O(n)\n            lst.append(i + j)  # O(n^2 * 2)\n    return lst\n\"\"\"# List Comprehensions\"\"\"\nl = [1, 2, 3, 4, 5]\nfor i in range(len(l)):\n    l[i] = l[i] * 2",
        "detail": "wk17.d2.cs47_python_iii",
        "documentation": {}
    },
    {
        "label": "single_number",
        "kind": 2,
        "importPath": "wk17.d2.cs47_python_iii",
        "description": "wk17.d2.cs47_python_iii",
        "peekOfCode": "def single_number(nums):\n    singles = []\n    for num in nums:\n        if num not in singles:\n            singles.append(num)\n        else:\n            singles.remove(num)\n    return singles.pop()\nprint(single_number([3, 3, 2]))  #  -> 2\nprint(single_number([5, 2, 3, 2, 3]))  # -> 5",
        "detail": "wk17.d2.cs47_python_iii",
        "documentation": {}
    },
    {
        "label": "phonebook",
        "kind": 5,
        "importPath": "wk17.d2.cs47_python_iii",
        "description": "wk17.d2.cs47_python_iii",
        "peekOfCode": "phonebook = {\"Abe\": 4569874321, \"Bill\": 7659803241, \"Barry\": 6573214789}\n# YOUR CODE HERE\nphonebook[\"Herb\"] = 7653420789\ndel phonebook[\"Bill\"]\n# Should print Herb is in the phonebook.\nif \"Herb\" in phonebook:\n    print(\"Herb is in the phonebook.\")\n# Should print Bill is not in the phonebook.\nif \"Bill\" not in phonebook:\n    print(\"Bill is not in the phonebook.\")",
        "detail": "wk17.d2.cs47_python_iii",
        "documentation": {}
    },
    {
        "label": "phonebook[\"Herb\"]",
        "kind": 5,
        "importPath": "wk17.d2.cs47_python_iii",
        "description": "wk17.d2.cs47_python_iii",
        "peekOfCode": "phonebook[\"Herb\"] = 7653420789\ndel phonebook[\"Bill\"]\n# Should print Herb is in the phonebook.\nif \"Herb\" in phonebook:\n    print(\"Herb is in the phonebook.\")\n# Should print Bill is not in the phonebook.\nif \"Bill\" not in phonebook:\n    print(\"Bill is not in the phonebook.\")\n\"\"\"# Mutability\"\"\"\n\"\"\"",
        "detail": "wk17.d2.cs47_python_iii",
        "documentation": {}
    },
    {
        "label": "my_list1",
        "kind": 5,
        "importPath": "wk17.d2.cs47_python_iii",
        "description": "wk17.d2.cs47_python_iii",
        "peekOfCode": "my_list1 = [1, 2, 3, 4, 5, 6]\nmy_list2 = my_list1\n# How would you verify that my_list1 and my_list2 have the same identity?\nprint(id(my_list1), id(my_list2))\nmy_list1.append(7)\n# Check if my_list1 and my_list2 still have the same identity.\n# If they do, why is that?\nprint(id(my_list1), id(my_list2))\n\"\"\"\nExample Two",
        "detail": "wk17.d2.cs47_python_iii",
        "documentation": {}
    },
    {
        "label": "my_list2",
        "kind": 5,
        "importPath": "wk17.d2.cs47_python_iii",
        "description": "wk17.d2.cs47_python_iii",
        "peekOfCode": "my_list2 = my_list1\n# How would you verify that my_list1 and my_list2 have the same identity?\nprint(id(my_list1), id(my_list2))\nmy_list1.append(7)\n# Check if my_list1 and my_list2 still have the same identity.\n# If they do, why is that?\nprint(id(my_list1), id(my_list2))\n\"\"\"\nExample Two\n\"\"\"",
        "detail": "wk17.d2.cs47_python_iii",
        "documentation": {}
    },
    {
        "label": "my_text1",
        "kind": 5,
        "importPath": "wk17.d2.cs47_python_iii",
        "description": "wk17.d2.cs47_python_iii",
        "peekOfCode": "my_text1 = \"Lambda School\"\nmy_text2 = my_text1\n# How would you verify that my_text1 and my_text2 have the same identity?\nprint(\"My Text\", id(my_text1), id(my_text2))\nmy_text1 += \" is awesome!\"\n# Check if my_text1 and my_text2 still have the same identity?\nprint(\"My Text\", id(my_text1), id(my_text2))\n# If they do not, why is that?\n# Now check if my_text1 and my_text2 have the same value?\nprint(\"1:\", my_text1, \"2:\", my_text2)",
        "detail": "wk17.d2.cs47_python_iii",
        "documentation": {}
    },
    {
        "label": "my_text2",
        "kind": 5,
        "importPath": "wk17.d2.cs47_python_iii",
        "description": "wk17.d2.cs47_python_iii",
        "peekOfCode": "my_text2 = my_text1\n# How would you verify that my_text1 and my_text2 have the same identity?\nprint(\"My Text\", id(my_text1), id(my_text2))\nmy_text1 += \" is awesome!\"\n# Check if my_text1 and my_text2 still have the same identity?\nprint(\"My Text\", id(my_text1), id(my_text2))\n# If they do not, why is that?\n# Now check if my_text1 and my_text2 have the same value?\nprint(\"1:\", my_text1, \"2:\", my_text2)\n# Do they? Explain why or why not.",
        "detail": "wk17.d2.cs47_python_iii",
        "documentation": {}
    },
    {
        "label": "produce",
        "kind": 5,
        "importPath": "wk17.d2.cs47_python_iii",
        "description": "wk17.d2.cs47_python_iii",
        "peekOfCode": "produce = [\"Apple\", \"Banana\", \"Carrot\"]\n# Initialize a tuple and include a reference to the produce list in the tuple\nstore = (\"Bill's Grocery\", produce)\nprint(\"store\", id(store))\n# Add a new item to the produce list\nproduce.append(\"Dragonfruit\")\nprint(\"store\", id(store))\nprint(dir(store))\n# Did you notice that the identity of store remained the same?\n# But I thought if you changed a mutable object, a new object would",
        "detail": "wk17.d2.cs47_python_iii",
        "documentation": {}
    },
    {
        "label": "store",
        "kind": 5,
        "importPath": "wk17.d2.cs47_python_iii",
        "description": "wk17.d2.cs47_python_iii",
        "peekOfCode": "store = (\"Bill's Grocery\", produce)\nprint(\"store\", id(store))\n# Add a new item to the produce list\nproduce.append(\"Dragonfruit\")\nprint(\"store\", id(store))\nprint(dir(store))\n# Did you notice that the identity of store remained the same?\n# But I thought if you changed a mutable object, a new object would\n# be created in memory? Why did that not occur here?\n\"\"\"# Time Complexity",
        "detail": "wk17.d2.cs47_python_iii",
        "documentation": {}
    },
    {
        "label": "l",
        "kind": 5,
        "importPath": "wk17.d2.cs47_python_iii",
        "description": "wk17.d2.cs47_python_iii",
        "peekOfCode": "l = [1, 2, 3, 4, 5]\nfor i in range(len(l)):\n    l[i] = l[i] * 2\nl2 = [l[i] * 2 for i in range(len(l)) if l[i] == 4]\n# for i in range(len(l)):\n# l2.append(l[i] * 2)\nl3 = []\nfor i in range(len(l)):\n    l3.append(l[i] * 2)\nprint(l)",
        "detail": "wk17.d2.cs47_python_iii",
        "documentation": {}
    },
    {
        "label": "l2",
        "kind": 5,
        "importPath": "wk17.d2.cs47_python_iii",
        "description": "wk17.d2.cs47_python_iii",
        "peekOfCode": "l2 = [l[i] * 2 for i in range(len(l)) if l[i] == 4]\n# for i in range(len(l)):\n# l2.append(l[i] * 2)\nl3 = []\nfor i in range(len(l)):\n    l3.append(l[i] * 2)\nprint(l)\nprint(l2)\nprint(l3)\nprint(l)",
        "detail": "wk17.d2.cs47_python_iii",
        "documentation": {}
    },
    {
        "label": "l3",
        "kind": 5,
        "importPath": "wk17.d2.cs47_python_iii",
        "description": "wk17.d2.cs47_python_iii",
        "peekOfCode": "l3 = []\nfor i in range(len(l)):\n    l3.append(l[i] * 2)\nprint(l)\nprint(l2)\nprint(l3)\nprint(l)\n\"\"\"# DEMO\"\"\"\n\"\"\"\nDemonstration",
        "detail": "wk17.d2.cs47_python_iii",
        "documentation": {}
    },
    {
        "label": "my_hash",
        "kind": 2,
        "importPath": "wk17.d3.copy_of_dictionaries",
        "description": "wk17.d3.copy_of_dictionaries",
        "peekOfCode": "def my_hash(key):\n    sum = 0\n    c in key:\n        nc = ord(c)\n        print(c)\n        print(nc)\nmy_hash(\"A\")\n\"\"\"\nAdd \"Herb\" to the phonebook with the number 7653420789.\nRemove \"Bill\" from the phonebook.",
        "detail": "wk17.d3.copy_of_dictionaries",
        "documentation": {}
    },
    {
        "label": "phonebook",
        "kind": 5,
        "importPath": "wk17.d3.copy_of_dictionaries",
        "description": "wk17.d3.copy_of_dictionaries",
        "peekOfCode": "phonebook = {\n    \"Abe\": 4569874321,\n    \"Bill\": 7659803241,\n    \"Barry\": 6573214789\n}\n# YOUR CODE HERE\n# Should print Herb is in the phonebook.\nif \"Herb\" in phonebook:\n    print(\"Herb is in the phonebook.\")\n# Should print Bill is not in the phonebook.",
        "detail": "wk17.d3.copy_of_dictionaries",
        "documentation": {}
    },
    {
        "label": "my_hash",
        "kind": 2,
        "importPath": "wk17.d3.d3",
        "description": "wk17.d3.d3",
        "peekOfCode": "def my_hash(key):\n    sum = 0\n    for c in key:\n        nc = ord(c)\n        sum += nc\n    return sum\nstorage = [None] * 10\nh = my_hash(\"CBA\")\nprint(h)\nn = h % len(storage)",
        "detail": "wk17.d3.d3",
        "documentation": {}
    },
    {
        "label": "put",
        "kind": 2,
        "importPath": "wk17.d3.d3",
        "description": "wk17.d3.d3",
        "peekOfCode": "def put(key, value):\n    idx = my_hash(key) % len(storage)\n    storage[idx] = value\ndef get(key):\n    idx = my_hash(key) % len(storage)\n    return storage[idx]\nput(\"Tom\", 41)\n# bryan@LAPTOP-9LGJ3JGS:/c/Lambda/CIRRICULUMN/_NOTES/CS-python-notes/WEEKS/wk17/d3$ python3 d3.py\n# 198\n# 8",
        "detail": "wk17.d3.d3",
        "documentation": {}
    },
    {
        "label": "get",
        "kind": 2,
        "importPath": "wk17.d3.d3",
        "description": "wk17.d3.d3",
        "peekOfCode": "def get(key):\n    idx = my_hash(key) % len(storage)\n    return storage[idx]\nput(\"Tom\", 41)\n# bryan@LAPTOP-9LGJ3JGS:/c/Lambda/CIRRICULUMN/_NOTES/CS-python-notes/WEEKS/wk17/d3$ python3 d3.py\n# 198\n# 8\n# bryan@LAPTOP-9LGJ3JGS:/c/Lambda/CIRRICULUMN/_NOTES/CS-python-notes/WEEKS/wk17/d3$",
        "detail": "wk17.d3.d3",
        "documentation": {}
    },
    {
        "label": "storage",
        "kind": 5,
        "importPath": "wk17.d3.d3",
        "description": "wk17.d3.d3",
        "peekOfCode": "storage = [None] * 10\nh = my_hash(\"CBA\")\nprint(h)\nn = h % len(storage)\nprint(n)\ndef put(key, value):\n    idx = my_hash(key) % len(storage)\n    storage[idx] = value\ndef get(key):\n    idx = my_hash(key) % len(storage)",
        "detail": "wk17.d3.d3",
        "documentation": {}
    },
    {
        "label": "h",
        "kind": 5,
        "importPath": "wk17.d3.d3",
        "description": "wk17.d3.d3",
        "peekOfCode": "h = my_hash(\"CBA\")\nprint(h)\nn = h % len(storage)\nprint(n)\ndef put(key, value):\n    idx = my_hash(key) % len(storage)\n    storage[idx] = value\ndef get(key):\n    idx = my_hash(key) % len(storage)\n    return storage[idx]",
        "detail": "wk17.d3.d3",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "wk17.d3.d3",
        "description": "wk17.d3.d3",
        "peekOfCode": "n = h % len(storage)\nprint(n)\ndef put(key, value):\n    idx = my_hash(key) % len(storage)\n    storage[idx] = value\ndef get(key):\n    idx = my_hash(key) % len(storage)\n    return storage[idx]\nput(\"Tom\", 41)\n# bryan@LAPTOP-9LGJ3JGS:/c/Lambda/CIRRICULUMN/_NOTES/CS-python-notes/WEEKS/wk17/d3$ python3 d3.py",
        "detail": "wk17.d3.d3",
        "documentation": {}
    },
    {
        "label": "plus_one",
        "kind": 2,
        "importPath": "wk17.d4.copy_of_arraysandstrings",
        "description": "wk17.d4.copy_of_arraysandstrings",
        "peekOfCode": "def plus_one(digits):\n    # Your code here\n    n = len(digits)\n    # iterate over the list from right to left\n    for i in range(n - 1, -1, -1):\n        # idx = n - 1 - i\n        idx = i\n        # if the current digit is a 9 then set it to a 0\n        if digits[idx] == 9:\n            digits[idx] = 0",
        "detail": "wk17.d4.copy_of_arraysandstrings",
        "documentation": {}
    },
    {
        "label": "16Bits",
        "kind": 5,
        "importPath": "wk17.d4.copy_of_arraysandstrings",
        "description": "wk17.d4.copy_of_arraysandstrings",
        "peekOfCode": "16Bits = 2Bytes\n8Bit, 16Bit, 32Bit, 64Bit, 128Bit\n```\n[123, \"hello\" ]\nA = [\"Hello\", 232, 100]\nA[0] -> @A + offest 0 * 2\nA[1] -> @A + offset 1 * 2 => 100 + 1 * 2\noffest = base addr * size of data in bucket\n          128 64 32 16 8 4 2 1\n00000000   0  1   1  1 1 0 1 1",
        "detail": "wk17.d4.copy_of_arraysandstrings",
        "documentation": {}
    },
    {
        "label": "A",
        "kind": 5,
        "importPath": "wk17.d4.copy_of_arraysandstrings",
        "description": "wk17.d4.copy_of_arraysandstrings",
        "peekOfCode": "A = [\"Hello\", 232, 100]\nA[0] -> @A + offest 0 * 2\nA[1] -> @A + offset 1 * 2 => 100 + 1 * 2\noffest = base addr * size of data in bucket\n          128 64 32 16 8 4 2 1\n00000000   0  1   1  1 1 0 1 1\n```\n```\n[\n0x100: 00000000",
        "detail": "wk17.d4.copy_of_arraysandstrings",
        "documentation": {}
    },
    {
        "label": "offest",
        "kind": 5,
        "importPath": "wk17.d4.copy_of_arraysandstrings",
        "description": "wk17.d4.copy_of_arraysandstrings",
        "peekOfCode": "offest = base addr * size of data in bucket\n          128 64 32 16 8 4 2 1\n00000000   0  1   1  1 1 0 1 1\n```\n```\n[\n0x100: 00000000\n0x101: 01111011\n0x102:\n0x103:",
        "detail": "wk17.d4.copy_of_arraysandstrings",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk17.d4.copy_of_arraysandstrings",
        "description": "wk17.d4.copy_of_arraysandstrings",
        "peekOfCode": "a = [(\"bob\", (1, 2, 3, \"dave\"), [{\"bob\": [1, 2, \"Hello\"]}], (123, 22)), (2.7), \"bob\"]\na[0][1][3][1]\n[] -> () -> 1 2 3\n```\n()\n1\n2\n3\n# **CODE**: 3672\n\"\"\"",
        "detail": "wk17.d4.copy_of_arraysandstrings",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "wk17.d4.copy_of_arraysandstrings",
        "description": "wk17.d4.copy_of_arraysandstrings",
        "peekOfCode": "n = 3\nidx = 3 - 1 - 2\n\"\"\"\ndef plus_one(digits):\n    # Your code here\n    n = len(digits)\n    # iterate over the list from right to left\n    for i in range(n - 1, -1, -1):\n        # idx = n - 1 - i\n        idx = i",
        "detail": "wk17.d4.copy_of_arraysandstrings",
        "documentation": {}
    },
    {
        "label": "idx",
        "kind": 5,
        "importPath": "wk17.d4.copy_of_arraysandstrings",
        "description": "wk17.d4.copy_of_arraysandstrings",
        "peekOfCode": "idx = 3 - 1 - 2\n\"\"\"\ndef plus_one(digits):\n    # Your code here\n    n = len(digits)\n    # iterate over the list from right to left\n    for i in range(n - 1, -1, -1):\n        # idx = n - 1 - i\n        idx = i\n        # if the current digit is a 9 then set it to a 0",
        "detail": "wk17.d4.copy_of_arraysandstrings",
        "documentation": {}
    },
    {
        "label": "LinkedListNode",
        "kind": 6,
        "importPath": "wk17.general-prac.linked-list",
        "description": "wk17.general-prac.linked-list",
        "peekOfCode": "class LinkedListNode:\n    def __init__(self, data=None, next=None):\n        self.data = data\n        self.next = next\nclass LinkedList:\n    def __init__(self, head=None):\n        self.head = head\n    def append(self, data):\n        new_node = LinkedListNode(data)\n        if self.head:",
        "detail": "wk17.general-prac.linked-list",
        "documentation": {}
    },
    {
        "label": "LinkedList",
        "kind": 6,
        "importPath": "wk17.general-prac.linked-list",
        "description": "wk17.general-prac.linked-list",
        "peekOfCode": "class LinkedList:\n    def __init__(self, head=None):\n        self.head = head\n    def append(self, data):\n        new_node = LinkedListNode(data)\n        if self.head:\n            current = self.head\n            while current.next:\n                current = current.next\n            current.next = new_node",
        "detail": "wk17.general-prac.linked-list",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk17.general-prac.linked-list",
        "description": "wk17.general-prac.linked-list",
        "peekOfCode": "a = LinkedListNode(1)\nmy_ll = LinkedList(a)\nmy_ll.append(2)\nmy_ll.append(3)\nmy_ll.head.data\nmy_ll.head.next.data\nmy_ll.head.next.next.data\nprint(\"my_ll = LinkedList(a):\", my_ll)\nprint(\"my_ll.append(2):\", my_ll)\nprint(\"my_ll.append(3):\", my_ll)",
        "detail": "wk17.general-prac.linked-list",
        "documentation": {}
    },
    {
        "label": "my_ll",
        "kind": 5,
        "importPath": "wk17.general-prac.linked-list",
        "description": "wk17.general-prac.linked-list",
        "peekOfCode": "my_ll = LinkedList(a)\nmy_ll.append(2)\nmy_ll.append(3)\nmy_ll.head.data\nmy_ll.head.next.data\nmy_ll.head.next.next.data\nprint(\"my_ll = LinkedList(a):\", my_ll)\nprint(\"my_ll.append(2):\", my_ll)\nprint(\"my_ll.append(3):\", my_ll)\nprint(\"my_ll.head.data:\", my_ll.head.data)",
        "detail": "wk17.general-prac.linked-list",
        "documentation": {}
    },
    {
        "label": "print(\"my_ll",
        "kind": 5,
        "importPath": "wk17.general-prac.linked-list",
        "description": "wk17.general-prac.linked-list",
        "peekOfCode": "print(\"my_ll = LinkedList(a):\", my_ll)\nprint(\"my_ll.append(2):\", my_ll)\nprint(\"my_ll.append(3):\", my_ll)\nprint(\"my_ll.head.data:\", my_ll.head.data)\nprint(\"my_ll.head.next.data:\", my_ll.head.next.data)\nprint(\"my_ll.head.next.next.data:\", my_ll.head.next.next.data)",
        "detail": "wk17.general-prac.linked-list",
        "documentation": {}
    },
    {
        "label": "my_list",
        "kind": 5,
        "importPath": "wk17.general-prac.list",
        "description": "wk17.general-prac.list",
        "peekOfCode": "my_list = [0]  # empty list literal\nmy_list.append(1)  # add 1 to end of list\nmy_list.append(2)  # add 2 to end of list\nmy_list.append(3)  # add 3 to end of list\nprint(my_list[0])  # prints 1\nprint(my_list[1])  # prints 2\nprint(my_list[2])  # prints 3\nfor item in my_list:\n    print(item)\nnumbers = []",
        "detail": "wk17.general-prac.list",
        "documentation": {}
    },
    {
        "label": "numbers",
        "kind": 5,
        "importPath": "wk17.general-prac.list",
        "description": "wk17.general-prac.list",
        "peekOfCode": "numbers = []\nnumbers.append(1)\nnumbers.append(2)\nnumbers.append(3)\nstrings = []\nstrings.append(\"Bootcamp\")\nstrings.append(\"School\")\nprint(numbers[2], strings[1])\nsum = 0\nfor number in numbers:",
        "detail": "wk17.general-prac.list",
        "documentation": {}
    },
    {
        "label": "strings",
        "kind": 5,
        "importPath": "wk17.general-prac.list",
        "description": "wk17.general-prac.list",
        "peekOfCode": "strings = []\nstrings.append(\"Bootcamp\")\nstrings.append(\"School\")\nprint(numbers[2], strings[1])\nsum = 0\nfor number in numbers:\n    sum += number\nmy_list.append(1)  # add 1 to end of list\nmy_list.append(2)  # add 2 to end of list\nmy_list.append(3)  # add 3 to end of list",
        "detail": "wk17.general-prac.list",
        "documentation": {}
    },
    {
        "label": "sum",
        "kind": 5,
        "importPath": "wk17.general-prac.list",
        "description": "wk17.general-prac.list",
        "peekOfCode": "sum = 0\nfor number in numbers:\n    sum += number\nmy_list.append(1)  # add 1 to end of list\nmy_list.append(2)  # add 2 to end of list\nmy_list.append(3)  # add 3 to end of list\nprint(my_list[0])  # prints 1\nprint(my_list[1])  # prints 2\nprint(my_list[2])  # prints 3\nfor item in my_list:",
        "detail": "wk17.general-prac.list",
        "documentation": {}
    },
    {
        "label": "numbers",
        "kind": 5,
        "importPath": "wk17.general-prac.list",
        "description": "wk17.general-prac.list",
        "peekOfCode": "numbers = []\nnumbers.append(1)\nnumbers.append(2)\nnumbers.append(3)\nstrings = []\nstrings.append(\"Bootcamp\")\nstrings.append(\"School\")\nprint(numbers[2], strings[1])\nsum = 0\nfor number in numbers:",
        "detail": "wk17.general-prac.list",
        "documentation": {}
    },
    {
        "label": "strings",
        "kind": 5,
        "importPath": "wk17.general-prac.list",
        "description": "wk17.general-prac.list",
        "peekOfCode": "strings = []\nstrings.append(\"Bootcamp\")\nstrings.append(\"School\")\nprint(numbers[2], strings[1])\nsum = 0\nfor number in numbers:\n    sum += number",
        "detail": "wk17.general-prac.list",
        "documentation": {}
    },
    {
        "label": "sum",
        "kind": 5,
        "importPath": "wk17.general-prac.list",
        "description": "wk17.general-prac.list",
        "peekOfCode": "sum = 0\nfor number in numbers:\n    sum += number",
        "detail": "wk17.general-prac.list",
        "documentation": {}
    },
    {
        "label": "checkPalindrome",
        "kind": 2,
        "importPath": "wk17.sprint-prep.research.03_-_checkPalindrome",
        "description": "wk17.sprint-prep.research.03_-_checkPalindrome",
        "peekOfCode": "def checkPalindrome(inputString):\n    return inputString == inputString[::-1]",
        "detail": "wk17.sprint-prep.research.03_-_checkPalindrome",
        "documentation": {}
    },
    {
        "label": "is_palindrome",
        "kind": 2,
        "importPath": "wk17.sprint-prep.research.is_palindrome",
        "description": "wk17.sprint-prep.research.is_palindrome",
        "peekOfCode": "def is_palindrome(s):\n    if s[::-1] == s:\n        return True\n    return False",
        "detail": "wk17.sprint-prep.research.is_palindrome",
        "documentation": {}
    },
    {
        "label": "AngryBird",
        "kind": 6,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "class AngryBird:\n    # Slots optimize property access and memory usage and prevent you\n    # from arbitrarily assigning new properties the instance\n    __slots__ = [\"_x\", \"_y\"]\n    # Constructor\n    def __init__(self, x=0, y=0):\n        # Doc String\n        \"\"\"\n        Construct a new AngryBird by setting it's position to (0, 0)\n        \"\"\"",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "say_hi",
        "kind": 2,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "def say_hi(name):\n    \"\"\"<---- Multi-Line Comments and Docstrings\n    This is where you put your content for help() to inform the user\n    about what your function does and how to use it\n    \"\"\"\n    print(f\"Hello {name}!\")\nprint(say_hi(\"Bryan\"))  # Should get the print inside the function, then None\n# Boolean Values\n# Work the same as in JS, except they are title case: True and False\na = True",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "printCopyright",
        "kind": 2,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "def printCopyright():\n    print(\"Copyright 2021, Bgoonz\")\n# Lambdas are one liners! (Should be at least, you can use parenthesis to disobey)\ndef avg(num1, num2):\n    return print(num1 + num2)\navg(1, 2)\n# Calling it with keyword arguments, order does not matter\navg(num2=20, num1=1252)\nprintCopyright()\n# We can give parameters default arguments like JS",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "avg",
        "kind": 2,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "def avg(num1, num2):\n    return print(num1 + num2)\navg(1, 2)\n# Calling it with keyword arguments, order does not matter\navg(num2=20, num1=1252)\nprintCopyright()\n# We can give parameters default arguments like JS\ndef greeting(name, saying=\"Hello\"):\n    print(saying, name)\ngreeting(\"Mike\")  # Hello Mike",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "greeting",
        "kind": 2,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "def greeting(name, saying=\"Hello\"):\n    print(saying, name)\ngreeting(\"Mike\")  # Hello Mike\ngreeting(\"Bryan\", saying=\"Hello there...\")\n# A common gotcha is using a mutable object for a default parameter\n# All invocations of the function reference the same mutable object\ndef append_item(item_name, item_list=[]):  # Will it obey and give us a new list?\n    item_list.append(item_name)\n    return item_list\n# Uses same item list unless otherwise stated which is counterintuitive",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "append_item",
        "kind": 2,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "def append_item(item_name, item_list=[]):  # Will it obey and give us a new list?\n    item_list.append(item_name)\n    return item_list\n# Uses same item list unless otherwise stated which is counterintuitive\nprint(append_item(\"notebook\"))\nprint(append_item(\"notebook\"))\nprint(append_item(\"notebook\", []))\n# Errors - Unlike JS, if we pass the incorrect amount of arguments to a function,\n#          it will throw an error\n# avg(1)  # TypeError",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "add",
        "kind": 2,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "def add(a, b, *args):\n    # args is a tuple of the rest of the arguments\n    total = a + b\n    for n in args:\n        total += n\n    return total\nprint(add(1, 2))  # args is None, returns 3\nprint(add(1, 2, 3, 4, 5, 6))  # args is (3, 4, 5, 6), returns 21\n# Variable Length Keyword Arguments\ndef print_names_and_countries(greeting, **kwargs):",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "print_names_and_countries",
        "kind": 2,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "def print_names_and_countries(greeting, **kwargs):\n    # kwargs is a dictionary of the rest of the keyword arguments\n    for k, v in kwargs.items():\n        print(greeting, k, \"from\", v)\nprint_names_and_countries(\n    \"Hey there\", Monica=\"Sweden\", Mike=\"The United States\", Mark=\"China\"\n)\n# We can combine all of these together\ndef example2(arg1, arg2, *args, kw_1=\"cheese\", kw_2=\"horse\", **kwargs):\n    pass",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "example2",
        "kind": 2,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "def example2(arg1, arg2, *args, kw_1=\"cheese\", kw_2=\"horse\", **kwargs):\n    pass\n# Lists are mutable arrays\nempty_list = []\nroomates = [\"Beau\", \"Delynn\"]\n# List built-in function makes a list too\nspecials = list()\n# We can use 'in' to test if something is in the list, like 'includes' in JS\nprint(1 in [1, 2, 4])  # True\nprint(2 in [1, 3, 5])  # False",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "isOdd",
        "kind": 2,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "def isOdd(num):\n    return num % 2 == 1\nfiltered = filter(isOdd, [1, 2, 3, 4])\nprint(list(filtered))\nfor num in filtered:\n    print(f\"first way: {num}\")\nprint(\"--\" * 20)\n[print(f\"list comprehension: {i}\") for i in [1, 2, 3, 4, 5, 6, 7, 8] if i % 2 == 1]\n# Map\ndef toUpper(str):",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "toUpper",
        "kind": 2,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "def toUpper(str):\n    return str.upper()\nupperCased = map(toUpper, [\"a\", \"b\", \"c\", \"d\"])\nprint(list(upperCased))\n# Sorted\nsorted_items = sorted([\"john\", \"tom\", \"sonny\", \"Mike\"])\nprint(list(sorted_items))  # Notice uppercase comes before lowercase\n# Using a key function to control the sorting and make it case insensitive\nsorted_items = sorted([\"john\", \"tom\", \"sonny\", \"Mike\"], key=str.lower)\nprint(sorted_items)",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "print_len",
        "kind": 2,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "def print_len(item):\n    return print(len(item))\nprint_len(\"Mike\")\nprint_len([1, 5, 2, 10, 3, 10])\nprint_len({1, 5, 10, 9, 10})  # 4 because there is a duplicate here (10)\nprint_len((1, 4, 10, 9, 20))\n# Max will return the max number in a given scenario\nprint(max(1, 2, 35, 1012, 1))\n# Min\nprint(min(1, 5, 2, 10))",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "a = True\nb = False\n# Logical Operators\n# ! = not, || = or, && = and\nprint(True and True)\nprint(True and not True)\nprint(True or True)\n# Truthiness - Everything is True except...\n# False - None, False, '', [], (), set(), range(0)\n# Number Values",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "b = False\n# Logical Operators\n# ! = not, || = or, && = and\nprint(True and True)\nprint(True and not True)\nprint(True or True)\n# Truthiness - Everything is True except...\n# False - None, False, '', [], (), set(), range(0)\n# Number Values\n# Integers are numbers without a floating decimal point",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "name",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "name = \"Bryan\"\nfor i in range(len(name)):\n    print(name[i])  # B, r, y, a, n\n# We can index starting from the end as well, with negatives\noccupation = \"Full Stack Software Engineer\"\nprint(occupation[-3])  # e\n# We can also get ranges in the index with the [start:stop:step] syntax\nprint(occupation[0:4:1])  # step and stop are optional, stop is exclusive\nprint(occupation[::4])  # beginning to end, every 4th letter\nprint(occupation[4:14:2])  # Let's get weird with it!",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "occupation",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "occupation = \"Full Stack Software Engineer\"\nprint(occupation[-3])  # e\n# We can also get ranges in the index with the [start:stop:step] syntax\nprint(occupation[0:4:1])  # step and stop are optional, stop is exclusive\nprint(occupation[::4])  # beginning to end, every 4th letter\nprint(occupation[4:14:2])  # Let's get weird with it!\n# NOTE: Indexing out of range will give you an IndexError\n# We can also get the index og things with the .index() method, similar to indexOf()\nprint(occupation.index(\"Stack\"))\nprint([\"Mike\", \"Barry\", \"Cole\", \"James\", \"Mark\"].index(\"Cole\"))",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "first_name",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "first_name = \"Bryan\"\nlast_name = \"Guner\"\nprint(\"Your name is {0} {1}\".format(first_name, last_name))\n# Useful String Methods\nprint(\"Hello\".upper())  # HELLO\nprint(\"Hello\".lower())  # hello\nprint(\"HELLO\".islower())  # False\nprint(\"HELLO\".isupper())  # True\nprint(\"Hello\".startswith(\"he\"))  # False\nprint(\"Hello\".endswith(\"lo\"))  # True",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "last_name",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "last_name = \"Guner\"\nprint(\"Your name is {0} {1}\".format(first_name, last_name))\n# Useful String Methods\nprint(\"Hello\".upper())  # HELLO\nprint(\"Hello\".lower())  # hello\nprint(\"HELLO\".islower())  # False\nprint(\"HELLO\".isupper())  # True\nprint(\"Hello\".startswith(\"he\"))  # False\nprint(\"Hello\".endswith(\"lo\"))  # True\nprint(\"Hello There\".split())  # [Hello, There]",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "a = 3\nb = a\nc = \"heyoo\"\nb = [\"reassignment\", \"is\", \"fine\", \"G!\"]\n# Comparison Operators - Python uses the same equality operators as JS, but no ===\n# < - Less than\n# > - Greater than\n# <= - Less than or Equal\n# >= - Greater than or Equal\n# == - Equal to",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "b = a\nc = \"heyoo\"\nb = [\"reassignment\", \"is\", \"fine\", \"G!\"]\n# Comparison Operators - Python uses the same equality operators as JS, but no ===\n# < - Less than\n# > - Greater than\n# <= - Less than or Equal\n# >= - Greater than or Equal\n# == - Equal to\n# != - Not equal to",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "c",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "c = \"heyoo\"\nb = [\"reassignment\", \"is\", \"fine\", \"G!\"]\n# Comparison Operators - Python uses the same equality operators as JS, but no ===\n# < - Less than\n# > - Greater than\n# <= - Less than or Equal\n# >= - Greater than or Equal\n# == - Equal to\n# != - Not equal to\n# is - Refers to exact same memory location",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "b = [\"reassignment\", \"is\", \"fine\", \"G!\"]\n# Comparison Operators - Python uses the same equality operators as JS, but no ===\n# < - Less than\n# > - Greater than\n# <= - Less than or Equal\n# >= - Greater than or Equal\n# == - Equal to\n# != - Not equal to\n# is - Refers to exact same memory location\n# not - !",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "lst",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "lst = [1, 2, 3, 4]\nfor i in lst:\n    print(i)\n# Looping over a dictionary\nspam = {\"color\": \"red\", \"age\": 42, \"items\": [(1, \"hey\"), (2, \"hooo!\")]}\nfor v in spam.values():\n    print(v)\n# Loop over a list of tuples and destructuring the values\n# Assuming spam.items returns a list of tuples each containing two items (k, v)\nfor k, v in spam.items():",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "spam",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "spam = {\"color\": \"red\", \"age\": 42, \"items\": [(1, \"hey\"), (2, \"hooo!\")]}\nfor v in spam.values():\n    print(v)\n# Loop over a list of tuples and destructuring the values\n# Assuming spam.items returns a list of tuples each containing two items (k, v)\nfor k, v in spam.items():\n    print(f\"{k}: {v}\")\n# While loops as long as the condition is True\n#  - Exit loop early with break\n#  - Exit iteration early with continue",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "spam",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "spam = 0\nwhile True:\n    print(\"Sike That's the wrong Numba\")\n    spam += 1\n    if spam < 5:\n        continue\n    break\n# Functions - use def keyword to define a function in Python\ndef printCopyright():\n    print(\"Copyright 2021, Bgoonz\")",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "empty_list",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "empty_list = []\nroomates = [\"Beau\", \"Delynn\"]\n# List built-in function makes a list too\nspecials = list()\n# We can use 'in' to test if something is in the list, like 'includes' in JS\nprint(1 in [1, 2, 4])  # True\nprint(2 in [1, 3, 5])  # False\n# Dictionaries - Similar to JS POJO's or Map, containing key value pairs\na = {\"one\": 1, \"two\": 2, \"three\": 3}\nb = dict(one=1, two=2, three=3)",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "roomates",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "roomates = [\"Beau\", \"Delynn\"]\n# List built-in function makes a list too\nspecials = list()\n# We can use 'in' to test if something is in the list, like 'includes' in JS\nprint(1 in [1, 2, 4])  # True\nprint(2 in [1, 3, 5])  # False\n# Dictionaries - Similar to JS POJO's or Map, containing key value pairs\na = {\"one\": 1, \"two\": 2, \"three\": 3}\nb = dict(one=1, two=2, three=3)\n# Can use 'in' on dictionaries too (for keys)",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "specials",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "specials = list()\n# We can use 'in' to test if something is in the list, like 'includes' in JS\nprint(1 in [1, 2, 4])  # True\nprint(2 in [1, 3, 5])  # False\n# Dictionaries - Similar to JS POJO's or Map, containing key value pairs\na = {\"one\": 1, \"two\": 2, \"three\": 3}\nb = dict(one=1, two=2, three=3)\n# Can use 'in' on dictionaries too (for keys)\nprint(\"one\" in a)  # True\nprint(3 in b)  # False",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "a = {\"one\": 1, \"two\": 2, \"three\": 3}\nb = dict(one=1, two=2, three=3)\n# Can use 'in' on dictionaries too (for keys)\nprint(\"one\" in a)  # True\nprint(3 in b)  # False\n# Sets - Just like JS, unordered collection of distinct objects\nbedroom = {\"bed\", \"tv\", \"computer\", \"clothes\", \"playstation 4\"}\n# bedroom = set(\"bed\", \"tv\", \"computer\", \"clothes\", \"playstation 5\")\nschool_bag = set(\n    [\"book\", \"paper\", \"pencil\", \"pencil\", \"book\", \"book\", \"book\", \"eraser\"]",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "b = dict(one=1, two=2, three=3)\n# Can use 'in' on dictionaries too (for keys)\nprint(\"one\" in a)  # True\nprint(3 in b)  # False\n# Sets - Just like JS, unordered collection of distinct objects\nbedroom = {\"bed\", \"tv\", \"computer\", \"clothes\", \"playstation 4\"}\n# bedroom = set(\"bed\", \"tv\", \"computer\", \"clothes\", \"playstation 5\")\nschool_bag = set(\n    [\"book\", \"paper\", \"pencil\", \"pencil\", \"book\", \"book\", \"book\", \"eraser\"]\n)",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "bedroom",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "bedroom = {\"bed\", \"tv\", \"computer\", \"clothes\", \"playstation 4\"}\n# bedroom = set(\"bed\", \"tv\", \"computer\", \"clothes\", \"playstation 5\")\nschool_bag = set(\n    [\"book\", \"paper\", \"pencil\", \"pencil\", \"book\", \"book\", \"book\", \"eraser\"]\n)\nprint(school_bag)\nprint(bedroom)\n# We can use 'in' on sets as wel\nprint(1 in {1, 2, 3})  # True\nprint(4 in {1, 3, 5})  # False",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "school_bag",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "school_bag = set(\n    [\"book\", \"paper\", \"pencil\", \"pencil\", \"book\", \"book\", \"book\", \"eraser\"]\n)\nprint(school_bag)\nprint(bedroom)\n# We can use 'in' on sets as wel\nprint(1 in {1, 2, 3})  # True\nprint(4 in {1, 3, 5})  # False\n# Tuples are immutable lists of items\ntime_blocks = (\"AM\", \"PM\")",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "time_blocks",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "time_blocks = (\"AM\", \"PM\")\ncolors = \"red\", \"green\", \"blue\"  # Parenthesis not needed but encouraged\n# The tuple built-in function can be used to convert things to tuples\nprint(tuple(\"abc\"))\nprint(tuple([1, 2, 3]))\n# 'in' may be used on tuples as well\nprint(1 in (1, 2, 3))  # True\nprint(5 in (1, 4, 3))  # False\n# Ranges are immutable lists of numbers, often used with for loops\n#   - start - default: 0, first number in sequence",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "colors",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "colors = \"red\", \"green\", \"blue\"  # Parenthesis not needed but encouraged\n# The tuple built-in function can be used to convert things to tuples\nprint(tuple(\"abc\"))\nprint(tuple([1, 2, 3]))\n# 'in' may be used on tuples as well\nprint(1 in (1, 2, 3))  # True\nprint(5 in (1, 4, 3))  # False\n# Ranges are immutable lists of numbers, often used with for loops\n#   - start - default: 0, first number in sequence\n#   - stop - required, next number past last number in sequence",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "range1",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "range1 = range(5)  # [0,1,2,3,4]\nrange2 = range(1, 5)  # [1,2,3,4]\nrange3 = range(0, 25, 5)  # [0,5,10,15,20]\nrange4 = range(0)  # []\nfor i in range1:\n    print(i)\n# Built-in functions:\n# Filter\ndef isOdd(num):\n    return num % 2 == 1",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "range2",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "range2 = range(1, 5)  # [1,2,3,4]\nrange3 = range(0, 25, 5)  # [0,5,10,15,20]\nrange4 = range(0)  # []\nfor i in range1:\n    print(i)\n# Built-in functions:\n# Filter\ndef isOdd(num):\n    return num % 2 == 1\nfiltered = filter(isOdd, [1, 2, 3, 4])",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "range3",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "range3 = range(0, 25, 5)  # [0,5,10,15,20]\nrange4 = range(0)  # []\nfor i in range1:\n    print(i)\n# Built-in functions:\n# Filter\ndef isOdd(num):\n    return num % 2 == 1\nfiltered = filter(isOdd, [1, 2, 3, 4])\nprint(list(filtered))",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "range4",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "range4 = range(0)  # []\nfor i in range1:\n    print(i)\n# Built-in functions:\n# Filter\ndef isOdd(num):\n    return num % 2 == 1\nfiltered = filter(isOdd, [1, 2, 3, 4])\nprint(list(filtered))\nfor num in filtered:",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "filtered",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "filtered = filter(isOdd, [1, 2, 3, 4])\nprint(list(filtered))\nfor num in filtered:\n    print(f\"first way: {num}\")\nprint(\"--\" * 20)\n[print(f\"list comprehension: {i}\") for i in [1, 2, 3, 4, 5, 6, 7, 8] if i % 2 == 1]\n# Map\ndef toUpper(str):\n    return str.upper()\nupperCased = map(toUpper, [\"a\", \"b\", \"c\", \"d\"])",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "upperCased",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "upperCased = map(toUpper, [\"a\", \"b\", \"c\", \"d\"])\nprint(list(upperCased))\n# Sorted\nsorted_items = sorted([\"john\", \"tom\", \"sonny\", \"Mike\"])\nprint(list(sorted_items))  # Notice uppercase comes before lowercase\n# Using a key function to control the sorting and make it case insensitive\nsorted_items = sorted([\"john\", \"tom\", \"sonny\", \"Mike\"], key=str.lower)\nprint(sorted_items)\n# You can also reverse the sort\nsorted_items = sorted([\"john\", \"tom\", \"sonny\", \"Mike\"], key=str.lower, reverse=True)",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "sorted_items",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "sorted_items = sorted([\"john\", \"tom\", \"sonny\", \"Mike\"])\nprint(list(sorted_items))  # Notice uppercase comes before lowercase\n# Using a key function to control the sorting and make it case insensitive\nsorted_items = sorted([\"john\", \"tom\", \"sonny\", \"Mike\"], key=str.lower)\nprint(sorted_items)\n# You can also reverse the sort\nsorted_items = sorted([\"john\", \"tom\", \"sonny\", \"Mike\"], key=str.lower, reverse=True)\nprint(sorted_items)\n# Enumerate creates a tuple with an index for what you're enumerating\nquarters = [\"First\", \"Second\", \"Third\", \"Fourth\"]",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "sorted_items",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "sorted_items = sorted([\"john\", \"tom\", \"sonny\", \"Mike\"], key=str.lower)\nprint(sorted_items)\n# You can also reverse the sort\nsorted_items = sorted([\"john\", \"tom\", \"sonny\", \"Mike\"], key=str.lower, reverse=True)\nprint(sorted_items)\n# Enumerate creates a tuple with an index for what you're enumerating\nquarters = [\"First\", \"Second\", \"Third\", \"Fourth\"]\nprint(list(enumerate(quarters)))\nprint(list(enumerate(quarters, start=1)))\n# Zip takes list and combines them as key value pairs, or really however you need",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "sorted_items",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "sorted_items = sorted([\"john\", \"tom\", \"sonny\", \"Mike\"], key=str.lower, reverse=True)\nprint(sorted_items)\n# Enumerate creates a tuple with an index for what you're enumerating\nquarters = [\"First\", \"Second\", \"Third\", \"Fourth\"]\nprint(list(enumerate(quarters)))\nprint(list(enumerate(quarters, start=1)))\n# Zip takes list and combines them as key value pairs, or really however you need\nkeys = (\"Name\", \"Email\")\nvalues = (\"Buster\", \"cheetoh@johhnydepp.com\")\nzipped = zip(keys, values)",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "quarters",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "quarters = [\"First\", \"Second\", \"Third\", \"Fourth\"]\nprint(list(enumerate(quarters)))\nprint(list(enumerate(quarters, start=1)))\n# Zip takes list and combines them as key value pairs, or really however you need\nkeys = (\"Name\", \"Email\")\nvalues = (\"Buster\", \"cheetoh@johhnydepp.com\")\nzipped = zip(keys, values)\nprint(list(zipped))\n# You can zip more than 2\nx_coords = [0, 1, 2, 3, 4]",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "keys",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "keys = (\"Name\", \"Email\")\nvalues = (\"Buster\", \"cheetoh@johhnydepp.com\")\nzipped = zip(keys, values)\nprint(list(zipped))\n# You can zip more than 2\nx_coords = [0, 1, 2, 3, 4]\ny_coords = [4, 6, 10, 9, 10]\nz_coords = [20, 10, 5, 9, 1]\ncoords = zip(x_coords, y_coords, z_coords)\nprint(list(coords))",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "values",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "values = (\"Buster\", \"cheetoh@johhnydepp.com\")\nzipped = zip(keys, values)\nprint(list(zipped))\n# You can zip more than 2\nx_coords = [0, 1, 2, 3, 4]\ny_coords = [4, 6, 10, 9, 10]\nz_coords = [20, 10, 5, 9, 1]\ncoords = zip(x_coords, y_coords, z_coords)\nprint(list(coords))\n# Len reports the length of strings along with list and any other object data type",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "zipped",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "zipped = zip(keys, values)\nprint(list(zipped))\n# You can zip more than 2\nx_coords = [0, 1, 2, 3, 4]\ny_coords = [4, 6, 10, 9, 10]\nz_coords = [20, 10, 5, 9, 1]\ncoords = zip(x_coords, y_coords, z_coords)\nprint(list(coords))\n# Len reports the length of strings along with list and any other object data type\n# doing this to save myself some typing",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "x_coords",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "x_coords = [0, 1, 2, 3, 4]\ny_coords = [4, 6, 10, 9, 10]\nz_coords = [20, 10, 5, 9, 1]\ncoords = zip(x_coords, y_coords, z_coords)\nprint(list(coords))\n# Len reports the length of strings along with list and any other object data type\n# doing this to save myself some typing\ndef print_len(item):\n    return print(len(item))\nprint_len(\"Mike\")",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "y_coords",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "y_coords = [4, 6, 10, 9, 10]\nz_coords = [20, 10, 5, 9, 1]\ncoords = zip(x_coords, y_coords, z_coords)\nprint(list(coords))\n# Len reports the length of strings along with list and any other object data type\n# doing this to save myself some typing\ndef print_len(item):\n    return print(len(item))\nprint_len(\"Mike\")\nprint_len([1, 5, 2, 10, 3, 10])",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "z_coords",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "z_coords = [20, 10, 5, 9, 1]\ncoords = zip(x_coords, y_coords, z_coords)\nprint(list(coords))\n# Len reports the length of strings along with list and any other object data type\n# doing this to save myself some typing\ndef print_len(item):\n    return print(len(item))\nprint_len(\"Mike\")\nprint_len([1, 5, 2, 10, 3, 10])\nprint_len({1, 5, 10, 9, 10})  # 4 because there is a duplicate here (10)",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "coords",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "coords = zip(x_coords, y_coords, z_coords)\nprint(list(coords))\n# Len reports the length of strings along with list and any other object data type\n# doing this to save myself some typing\ndef print_len(item):\n    return print(len(item))\nprint_len(\"Mike\")\nprint_len([1, 5, 2, 10, 3, 10])\nprint_len({1, 5, 10, 9, 10})  # 4 because there is a duplicate here (10)\nprint_len((1, 4, 10, 9, 20))",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "user",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "user = {\"Name\": \"Bob\", \"Email\": \"bob@bob.com\"}\nprint(dir(user))\n# Importing packages and modules\n#  - Module - A Python code in a file or directory\n#  - Package - A module which is a directory containing an __init__.py file\n#  - Submodule - A module which is contained within a package\n#  - Name - An exported function, class, or variable in a module\n# Unlike JS, modules export ALL names contained within them without any special export key\n# Assuming we have the following package with four submodules\n#  math",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "squares",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "squares = []\nfor i in range(10):\n    squares.append(i ** 2)\nprint(squares)\n# value = i ** 2\n# loop = for i in range(10)\nsquares = [i ** 2 for i in range(10)]\nprint(list(squares))\nsentence = \"the rocket came back from mars\"\nvowels = [character for character in sentence if character in \"aeiou\"]",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "squares",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "squares = [i ** 2 for i in range(10)]\nprint(list(squares))\nsentence = \"the rocket came back from mars\"\nvowels = [character for character in sentence if character in \"aeiou\"]\nprint(vowels)\n# You can also use them on dictionaries. We can use the items() method\n# for the dictionary to loop through it getting the keys and values out at once\nperson = {\"name\": \"Corina\", \"age\": 32, \"height\": 1.4}\n# This loops through and capitalizes the first letter of all keys\nnewPerson = {key.title(): value for key, value in person.items()}",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "sentence",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "sentence = \"the rocket came back from mars\"\nvowels = [character for character in sentence if character in \"aeiou\"]\nprint(vowels)\n# You can also use them on dictionaries. We can use the items() method\n# for the dictionary to loop through it getting the keys and values out at once\nperson = {\"name\": \"Corina\", \"age\": 32, \"height\": 1.4}\n# This loops through and capitalizes the first letter of all keys\nnewPerson = {key.title(): value for key, value in person.items()}\nprint(list(newPerson.items()))",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "vowels",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "vowels = [character for character in sentence if character in \"aeiou\"]\nprint(vowels)\n# You can also use them on dictionaries. We can use the items() method\n# for the dictionary to loop through it getting the keys and values out at once\nperson = {\"name\": \"Corina\", \"age\": 32, \"height\": 1.4}\n# This loops through and capitalizes the first letter of all keys\nnewPerson = {key.title(): value for key, value in person.items()}\nprint(list(newPerson.items()))",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "person",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "person = {\"name\": \"Corina\", \"age\": 32, \"height\": 1.4}\n# This loops through and capitalizes the first letter of all keys\nnewPerson = {key.title(): value for key, value in person.items()}\nprint(list(newPerson.items()))",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "newPerson",
        "kind": 5,
        "importPath": "wk17.sprint-prep.research.notes",
        "description": "wk17.sprint-prep.research.notes",
        "peekOfCode": "newPerson = {key.title(): value for key, value in person.items()}\nprint(list(newPerson.items()))",
        "detail": "wk17.sprint-prep.research.notes",
        "documentation": {}
    },
    {
        "label": "reverse_sentence",
        "kind": 2,
        "importPath": "wk17.sprint-prep.research.reverse_string",
        "description": "wk17.sprint-prep.research.reverse_string",
        "peekOfCode": "def reverse_sentence(sentence):\n    arr = [c for c in sentence]  # or just arr = list(sentence)\n    start = 0\n    end = len(arr) - 1\n    while start < end:\n        # reverse the array from the start index to the end index by\n        # swaping each char with the pair from the other part of the array\n        swap(arr, start, end)\n        start += 1\n        end -= 1",
        "detail": "wk17.sprint-prep.research.reverse_string",
        "documentation": {}
    },
    {
        "label": "swap",
        "kind": 2,
        "importPath": "wk17.sprint-prep.research.reverse_string",
        "description": "wk17.sprint-prep.research.reverse_string",
        "peekOfCode": "def swap(arr, i, j):\n    # swapping two elements from a same array\n    arr[i], arr[j] = arr[j], arr[i]\n    \"\"\"same as\n    temp = arr[i]\n    arr[i] = arr[j]\n    arr[j] = temp\n    \"\"\"\n###########\n# Testing #",
        "detail": "wk17.sprint-prep.research.reverse_string",
        "documentation": {}
    },
    {
        "label": "csCheckPalindrome",
        "kind": 2,
        "importPath": "wk17.sprint-prep.sandbox.check-palindrome",
        "description": "wk17.sprint-prep.sandbox.check-palindrome",
        "peekOfCode": "def csCheckPalindrome(input_str):\n    if input_str[::-1] == input_str:\n        return True\n    return False",
        "detail": "wk17.sprint-prep.sandbox.check-palindrome",
        "documentation": {}
    },
    {
        "label": "csRemoveDuplicateWords",
        "kind": 2,
        "importPath": "wk17.sprint-prep.sandbox.remove-dupes-from-sentence",
        "description": "wk17.sprint-prep.sandbox.remove-dupes-from-sentence",
        "peekOfCode": "def csRemoveDuplicateWords(input_str):\n    return \" \".join(dict.fromkeys(input_str.split()))\nprint(\n    csRemoveDuplicateWords(\n        \"alpha bravo bravo golf golf golf delta alpha bravo bravo golf golf golf delta\"\n    )\n)\nprint(csRemoveDuplicateWords(\"my dog is my dog is super smart\"))\nprint(csRemoveDuplicateWords(\"Your tests are broken broken broken broken broken\"))\nprint(",
        "detail": "wk17.sprint-prep.sandbox.remove-dupes-from-sentence",
        "documentation": {}
    },
    {
        "label": "lib",
        "kind": 5,
        "importPath": "wk17.sprint-prep.sandbox.remove-dupes-from-sentence",
        "description": "wk17.sprint-prep.sandbox.remove-dupes-from-sentence",
        "peekOfCode": "lib = BigO()\ncomplexity = lib.test(csRemoveDuplicateWords, \"random\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"sorted\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"reversed\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"partial\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"Ksorted\")",
        "detail": "wk17.sprint-prep.sandbox.remove-dupes-from-sentence",
        "documentation": {}
    },
    {
        "label": "complexity",
        "kind": 5,
        "importPath": "wk17.sprint-prep.sandbox.remove-dupes-from-sentence",
        "description": "wk17.sprint-prep.sandbox.remove-dupes-from-sentence",
        "peekOfCode": "complexity = lib.test(csRemoveDuplicateWords, \"random\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"sorted\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"reversed\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"partial\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"Ksorted\")",
        "detail": "wk17.sprint-prep.sandbox.remove-dupes-from-sentence",
        "documentation": {}
    },
    {
        "label": "complexity",
        "kind": 5,
        "importPath": "wk17.sprint-prep.sandbox.remove-dupes-from-sentence",
        "description": "wk17.sprint-prep.sandbox.remove-dupes-from-sentence",
        "peekOfCode": "complexity = lib.test(csRemoveDuplicateWords, \"sorted\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"reversed\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"partial\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"Ksorted\")",
        "detail": "wk17.sprint-prep.sandbox.remove-dupes-from-sentence",
        "documentation": {}
    },
    {
        "label": "complexity",
        "kind": 5,
        "importPath": "wk17.sprint-prep.sandbox.remove-dupes-from-sentence",
        "description": "wk17.sprint-prep.sandbox.remove-dupes-from-sentence",
        "peekOfCode": "complexity = lib.test(csRemoveDuplicateWords, \"reversed\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"partial\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"Ksorted\")",
        "detail": "wk17.sprint-prep.sandbox.remove-dupes-from-sentence",
        "documentation": {}
    },
    {
        "label": "complexity",
        "kind": 5,
        "importPath": "wk17.sprint-prep.sandbox.remove-dupes-from-sentence",
        "description": "wk17.sprint-prep.sandbox.remove-dupes-from-sentence",
        "peekOfCode": "complexity = lib.test(csRemoveDuplicateWords, \"partial\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"Ksorted\")",
        "detail": "wk17.sprint-prep.sandbox.remove-dupes-from-sentence",
        "documentation": {}
    },
    {
        "label": "complexity",
        "kind": 5,
        "importPath": "wk17.sprint-prep.sandbox.remove-dupes-from-sentence",
        "description": "wk17.sprint-prep.sandbox.remove-dupes-from-sentence",
        "peekOfCode": "complexity = lib.test(csRemoveDuplicateWords, \"Ksorted\")",
        "detail": "wk17.sprint-prep.sandbox.remove-dupes-from-sentence",
        "documentation": {}
    },
    {
        "label": "csReverseString",
        "kind": 2,
        "importPath": "wk17.sprint-prep.sandbox.rev-string",
        "description": "wk17.sprint-prep.sandbox.rev-string",
        "peekOfCode": "def csReverseString(chars):\n    rev = chars[::-1]\n    print(rev)\n    return rev\n# def csReverseString2(chars):\n#     new_string = ''\n#     index = len(chars)\n#     while index:\n#         index -= 1                    # index = index - 1\n#         new_string += chars[index]  # new_string = new_string + character",
        "detail": "wk17.sprint-prep.sandbox.rev-string",
        "documentation": {}
    },
    {
        "label": "csReverseString2",
        "kind": 2,
        "importPath": "wk17.sprint-prep.sandbox.rev-string",
        "description": "wk17.sprint-prep.sandbox.rev-string",
        "peekOfCode": "def csReverseString2(chars):\n    new_string = \"\"\n    index = len(chars)\n    while index:\n        index -= 1  # index = index - 1\n        new_string += chars[index]  # new_string = new_string + character\n    return new_string\nprint(csReverseString2(\"helloworld\"))\n# Input:\n# chars:",
        "detail": "wk17.sprint-prep.sandbox.rev-string",
        "documentation": {}
    },
    {
        "label": "csRemoveDuplicateWords",
        "kind": 2,
        "importPath": "wk17.sprint-prep.sandbox.scrap",
        "description": "wk17.sprint-prep.sandbox.scrap",
        "peekOfCode": "def csRemoveDuplicateWords(input_str):\n    return \" \".join(dict.fromkeys(input_str.split()))\nprint(\n    csRemoveDuplicateWords(\n        \"alpha bravo bravo golf golf golf delta alpha bravo bravo golf golf golf delta\"\n    )\n)\nprint(csRemoveDuplicateWords(\"my dog is my dog is super smart\"))\nprint(csRemoveDuplicateWords(\"Your tests are broken broken broken broken broken\"))\nprint(",
        "detail": "wk17.sprint-prep.sandbox.scrap",
        "documentation": {}
    },
    {
        "label": "lib",
        "kind": 5,
        "importPath": "wk17.sprint-prep.sandbox.scrap",
        "description": "wk17.sprint-prep.sandbox.scrap",
        "peekOfCode": "lib = BigO()\ncomplexity = lib.test(csRemoveDuplicateWords, \"random\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"sorted\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"reversed\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"partial\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"Ksorted\")",
        "detail": "wk17.sprint-prep.sandbox.scrap",
        "documentation": {}
    },
    {
        "label": "complexity",
        "kind": 5,
        "importPath": "wk17.sprint-prep.sandbox.scrap",
        "description": "wk17.sprint-prep.sandbox.scrap",
        "peekOfCode": "complexity = lib.test(csRemoveDuplicateWords, \"random\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"sorted\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"reversed\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"partial\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"Ksorted\")",
        "detail": "wk17.sprint-prep.sandbox.scrap",
        "documentation": {}
    },
    {
        "label": "complexity",
        "kind": 5,
        "importPath": "wk17.sprint-prep.sandbox.scrap",
        "description": "wk17.sprint-prep.sandbox.scrap",
        "peekOfCode": "complexity = lib.test(csRemoveDuplicateWords, \"sorted\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"reversed\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"partial\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"Ksorted\")",
        "detail": "wk17.sprint-prep.sandbox.scrap",
        "documentation": {}
    },
    {
        "label": "complexity",
        "kind": 5,
        "importPath": "wk17.sprint-prep.sandbox.scrap",
        "description": "wk17.sprint-prep.sandbox.scrap",
        "peekOfCode": "complexity = lib.test(csRemoveDuplicateWords, \"reversed\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"partial\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"Ksorted\")",
        "detail": "wk17.sprint-prep.sandbox.scrap",
        "documentation": {}
    },
    {
        "label": "complexity",
        "kind": 5,
        "importPath": "wk17.sprint-prep.sandbox.scrap",
        "description": "wk17.sprint-prep.sandbox.scrap",
        "peekOfCode": "complexity = lib.test(csRemoveDuplicateWords, \"partial\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"Ksorted\")",
        "detail": "wk17.sprint-prep.sandbox.scrap",
        "documentation": {}
    },
    {
        "label": "complexity",
        "kind": 5,
        "importPath": "wk17.sprint-prep.sandbox.scrap",
        "description": "wk17.sprint-prep.sandbox.scrap",
        "peekOfCode": "complexity = lib.test(csRemoveDuplicateWords, \"Ksorted\")",
        "detail": "wk17.sprint-prep.sandbox.scrap",
        "documentation": {}
    },
    {
        "label": "csRemoveDuplicateWords",
        "kind": 2,
        "importPath": "wk17.sprint-prep.sandbox.scrap2",
        "description": "wk17.sprint-prep.sandbox.scrap2",
        "peekOfCode": "def csRemoveDuplicateWords(input_str):\n    return \" \".join(dict.fromkeys(input_str.split()))\nprint(\n    csRemoveDuplicateWords(\n        \"alpha bravo bravo golf golf golf delta alpha bravo bravo golf golf golf delta\"\n    )\n)\nprint(csRemoveDuplicateWords(\"my dog is my dog is super smart\"))\nprint(csRemoveDuplicateWords(\"Your tests are broken broken broken broken broken\"))",
        "detail": "wk17.sprint-prep.sandbox.scrap2",
        "documentation": {}
    },
    {
        "label": "csRemoveDuplicateWords",
        "kind": 2,
        "importPath": "wk17.sprint-prep.sandbox.scrap3",
        "description": "wk17.sprint-prep.sandbox.scrap3",
        "peekOfCode": "def csRemoveDuplicateWords(input_str):\n    return \" \".join(dict.fromkeys(input_str.split()))\nprint(\n    csRemoveDuplicateWords(\n        \"alpha bravo bravo golf golf golf delta alpha bravo bravo golf golf golf delta\"\n    )\n)\nprint(csRemoveDuplicateWords(\"my dog is my dog is super smart\"))\nprint(csRemoveDuplicateWords(\"Your tests are broken broken broken broken broken\"))\nprint(",
        "detail": "wk17.sprint-prep.sandbox.scrap3",
        "documentation": {}
    },
    {
        "label": "lib",
        "kind": 5,
        "importPath": "wk17.sprint-prep.sandbox.scrap3",
        "description": "wk17.sprint-prep.sandbox.scrap3",
        "peekOfCode": "lib = BigO()\ncomplexity = lib.test(csRemoveDuplicateWords, \"random\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"sorted\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"reversed\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"partial\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"Ksorted\")",
        "detail": "wk17.sprint-prep.sandbox.scrap3",
        "documentation": {}
    },
    {
        "label": "complexity",
        "kind": 5,
        "importPath": "wk17.sprint-prep.sandbox.scrap3",
        "description": "wk17.sprint-prep.sandbox.scrap3",
        "peekOfCode": "complexity = lib.test(csRemoveDuplicateWords, \"random\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"sorted\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"reversed\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"partial\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"Ksorted\")",
        "detail": "wk17.sprint-prep.sandbox.scrap3",
        "documentation": {}
    },
    {
        "label": "complexity",
        "kind": 5,
        "importPath": "wk17.sprint-prep.sandbox.scrap3",
        "description": "wk17.sprint-prep.sandbox.scrap3",
        "peekOfCode": "complexity = lib.test(csRemoveDuplicateWords, \"sorted\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"reversed\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"partial\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"Ksorted\")",
        "detail": "wk17.sprint-prep.sandbox.scrap3",
        "documentation": {}
    },
    {
        "label": "complexity",
        "kind": 5,
        "importPath": "wk17.sprint-prep.sandbox.scrap3",
        "description": "wk17.sprint-prep.sandbox.scrap3",
        "peekOfCode": "complexity = lib.test(csRemoveDuplicateWords, \"reversed\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"partial\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"Ksorted\")",
        "detail": "wk17.sprint-prep.sandbox.scrap3",
        "documentation": {}
    },
    {
        "label": "complexity",
        "kind": 5,
        "importPath": "wk17.sprint-prep.sandbox.scrap3",
        "description": "wk17.sprint-prep.sandbox.scrap3",
        "peekOfCode": "complexity = lib.test(csRemoveDuplicateWords, \"partial\")\ncomplexity = lib.test(csRemoveDuplicateWords, \"Ksorted\")",
        "detail": "wk17.sprint-prep.sandbox.scrap3",
        "documentation": {}
    },
    {
        "label": "complexity",
        "kind": 5,
        "importPath": "wk17.sprint-prep.sandbox.scrap3",
        "description": "wk17.sprint-prep.sandbox.scrap3",
        "peekOfCode": "complexity = lib.test(csRemoveDuplicateWords, \"Ksorted\")",
        "detail": "wk17.sprint-prep.sandbox.scrap3",
        "documentation": {}
    },
    {
        "label": "csReverseString",
        "kind": 2,
        "importPath": "wk17.sprint-prep.reverse-string",
        "description": "wk17.sprint-prep.reverse-string",
        "peekOfCode": "def csReverseString(chars):\n    rev = chars[::-1]\n    print(rev)\n    return rev",
        "detail": "wk17.sprint-prep.reverse-string",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, x):\n        self.value = x\n        self.next = None\na = [1]\nb = [9999, 9999, 9999, 9999, 9999, 9999]\n# my code couldn't get to pass\n# def addTwoHugeNumbers(a, b):\n#     if a is None and b is None:\n#         return [0]",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "firstDuplicate",
        "kind": 2,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "def firstDuplicate(a):\n    # define a set to hold non duplicate numbers\n    nums = set()\n    for i in range(len(a)):\n        # if we hit a number that's duplicate (exists in the set) return it\n        if a[i] in nums:\n            return a[i]\n        else:\n            # else if its not duplicate add it to the set\n            nums.add(a[i])",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "firstNotRepeatingCharacter",
        "kind": 2,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "def firstNotRepeatingCharacter(s):\n    for i in range(len(s)):\n        if s[i] not in s[i + 1 :] and s[i] not in s[:i]:\n            return s[i]\n    return \"_\"\n# print(firstNotRepeatingCharacter(s))\n\"\"\"\n*** Rotate image ***\n--------------------\nNote: Try to solve this task in-place (with O(1) additional memory), since this is what you'll be asked to do during an interview.",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "rotateImage",
        "kind": 2,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "def rotateImage(a):\n    # initialized the length of a set at 0\n    length = len(a[0])\n    # iterate through the length // 2\n    for idx1 in range(length // 2):\n        print(f\"idx1, {idx1}\")\n        # starting from idx1, iterate (num3) over length idx1 -1 -  (should get 1)\n        for idx2 in range(idx1, length - idx1 - 1):\n            print(f\"idx2, {idx2}\")\n            # initialize a placeholder",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "check_unique",
        "kind": 2,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "def check_unique(nums):\n    s = set()\n    for num in nums:\n        if num == \".\":\n            continue\n        if num in s:\n            return False\n        s.add(num)\n    return True\ndef sudoku2(grid):",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "sudoku2",
        "kind": 2,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "def sudoku2(grid):\n    for line in grid:\n        if not check_unique(line):\n            return False\n    for i in range(9):\n        if not check_unique([line[i] for line in grid]):\n            return False\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            if not check_unique(",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "isCryptSolution",
        "kind": 2,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "def isCryptSolution(crypt, solution):\n    # for each string get the numbers for each character\n    num_arr = []\n    nums = \"\"\n    for word in crypt:\n        for char in word:\n            for sect in solution:\n                if char in sect:\n                    nums += sect[1]\n        if len(nums) > 1 and nums.startswith(\"0\"):",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "removeKFromList",
        "kind": 2,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "def removeKFromList(l, k):\n    if l is None:\n        return []\n    current = l\n    prev = None\n    while current is not None:\n        if current.value == k:\n            # if the head has the current value just put the value of\n            # next into it and remove next\n            if prev is None:",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "isListPalindrome",
        "kind": 2,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "def isListPalindrome(l):\n    if l is None:\n        return True\n    head = l\n    prev = None\n    while l.next:\n        l.prev = prev\n        prev = l\n        l = l.next\n    tail = l",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "addTwoHugeNumbers",
        "kind": 2,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "def addTwoHugeNumbers(a, b):\n    a = reverse(a)\n    b = reverse(b)\n    carry = 0\n    result = None\n    while a is not None or b is not None or carry > 0:\n        raw = (\n            (a.value if a is not None else 0)\n            + (b.value if b is not None else 0)\n            + carry",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "reverse",
        "kind": 2,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "def reverse(list):\n    current = list\n    previous = None\n    while current is not None:\n        previous, current.next, current = current, previous, current.next\n    return previous\n\"\"\"\nRearrange Last N\n----------------\nNote: Try to solve this task in O(list size) time using O(1) additional space, since this is what you'll be asked during an interview.",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "rearrangeLastN",
        "kind": 2,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "def rearrangeLastN(l, n):\n    if l is None:\n        return l\n    if n == 0:\n        return l\n    if l.next is None:\n        return l\n    # set a current, a head, a previous\n    new_head = None\n    cur = l",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "arr = [8, 4, 6, 2, 6, 4, 7, 9, 5, 8]\n# O(n^2) solution\n# def firstDuplicate(a):\n#     # keep track of matched index\n#     matched = []\n#     if len(a) < 2:\n#         return -1\n#     # iterate the list checking for duplicates of current number\n#     for i, value in enumerate(a):\n#         for j, val in enumerate(a):",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "arr = [8, 4, 6, 2, 6, 4, 7, 9, 5, 8]\n# O(n) solution\ndef firstDuplicate(a):\n    # define a set to hold non duplicate numbers\n    nums = set()\n    for i in range(len(a)):\n        # if we hit a number that's duplicate (exists in the set) return it\n        if a[i] in nums:\n            return a[i]\n        else:",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "firstNotRepeatingCharacter(s)",
        "kind": 5,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "firstNotRepeatingCharacter(s) = 'c'.\nThere are 2 non-repeating characters in the string: 'c' and 'd'. Return c since it appears in the string first.\nFor s = \"abacabaabacaba\", the output should be\nfirstNotRepeatingCharacter(s) = '_'.\nThere are no characters in this string that do not repeat.\n\"\"\"\ns = \"abacabad\"\ndef firstNotRepeatingCharacter(s):\n    for i in range(len(s)):\n        if s[i] not in s[i + 1 :] and s[i] not in s[:i]:",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "firstNotRepeatingCharacter(s)",
        "kind": 5,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "firstNotRepeatingCharacter(s) = '_'.\nThere are no characters in this string that do not repeat.\n\"\"\"\ns = \"abacabad\"\ndef firstNotRepeatingCharacter(s):\n    for i in range(len(s)):\n        if s[i] not in s[i + 1 :] and s[i] not in s[:i]:\n            return s[i]\n    return \"_\"\n# print(firstNotRepeatingCharacter(s))",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "s = \"abacabad\"\ndef firstNotRepeatingCharacter(s):\n    for i in range(len(s)):\n        if s[i] not in s[i + 1 :] and s[i] not in s[:i]:\n            return s[i]\n    return \"_\"\n# print(firstNotRepeatingCharacter(s))\n\"\"\"\n*** Rotate image ***\n--------------------",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "a = [[1, 2, 3],\n     [4, 5, 6],\n     [7, 8, 9]]\nthe output should be\nrotateImage(a) =\n    [[7, 4, 1],\n     [8, 5, 2],\n     [9, 6, 3]]\n\"\"\"\na = [",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "rotateImage(a)",
        "kind": 5,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "rotateImage(a) =\n    [[7, 4, 1],\n     [8, 5, 2],\n     [9, 6, 3]]\n\"\"\"\na = [\n    [1, 2, 3],  # 1 -> [0 : len - 1] 2 -> [1 : len - 1] 3 -> [2 : len -1]\n    [4, 5, 6],  # 4 -> [0 : len - 2] 2 -> [1 : len - 2] 6 [2 : len -2]\n    [7, 8, 9],\n]  # 7 -> [0 : len - 3] 8 -> [1 : len - 3] 9 -> [2 : len -3]",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "a = [\n    [1, 2, 3],  # 1 -> [0 : len - 1] 2 -> [1 : len - 1] 3 -> [2 : len -1]\n    [4, 5, 6],  # 4 -> [0 : len - 2] 2 -> [1 : len - 2] 6 [2 : len -2]\n    [7, 8, 9],\n]  # 7 -> [0 : len - 3] 8 -> [1 : len - 3] 9 -> [2 : len -3]\ndef rotateImage(a):\n    # initialized the length of a set at 0\n    length = len(a[0])\n    # iterate through the length // 2\n    for idx1 in range(length // 2):",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "grid",
        "kind": 5,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "grid = [['.', '.', '.', '1', '4', '.', '.', '2', '.'],\n        ['.', '.', '6', '.', '.', '.', '.', '.', '.'],\n        ['.', '.', '.', '.', '.', '.', '.', '.', '.'],\n        ['.', '.', '1', '.', '.', '.', '.', '.', '.'],\n        ['.', '6', '7', '.', '.', '.', '.', '.', '9'],\n        ['.', '.', '.', '.', '.', '.', '8', '1', '.'],\n        ['.', '3', '.', '.', '.', '.', '.', '.', '6'],\n        ['.', '.', '.', '.', '.', '7', '.', '.', '.'],\n        ['.', '.', '.', '5', '.', '.', '.', '7', '.']]\nthe output should be",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "sudoku2(grid)",
        "kind": 5,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "sudoku2(grid) = true;\nFor\ngrid = [['.', '.', '.', '.', '2', '.', '.', '9', '.'],\n        ['.', '.', '.', '.', '6', '.', '.', '.', '.'],\n        ['7', '1', '.', '.', '7', '5', '.', '.', '.'],\n        ['.', '7', '.', '.', '.', '.', '.', '.', '.'],\n        ['.', '.', '.', '.', '8', '3', '.', '.', '.'],\n        ['.', '.', '8', '.', '.', '7', '.', '6', '.'],\n        ['.', '.', '.', '.', '.', '2', '.', '.', '.'],\n        ['.', '1', '.', '2', '.', '.', '.', '.', '.'],",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "grid",
        "kind": 5,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "grid = [['.', '.', '.', '.', '2', '.', '.', '9', '.'],\n        ['.', '.', '.', '.', '6', '.', '.', '.', '.'],\n        ['7', '1', '.', '.', '7', '5', '.', '.', '.'],\n        ['.', '7', '.', '.', '.', '.', '.', '.', '.'],\n        ['.', '.', '.', '.', '8', '3', '.', '.', '.'],\n        ['.', '.', '8', '.', '.', '7', '.', '6', '.'],\n        ['.', '.', '.', '.', '.', '2', '.', '.', '.'],\n        ['.', '1', '.', '2', '.', '.', '.', '.', '.'],\n        ['.', '2', '.', '.', '3', '.', '.', '.', '.']]\nthe output should be",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "sudoku2(grid)",
        "kind": 5,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "sudoku2(grid) = false.\nThe given grid is not correct because there are two 1s in the second column. Each column, each row, and each 3 × 3 subgrid can only contain the numbers 1 through 9 one time.\n\"\"\"\ngrid = [\n    [\".\", \"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \"4\", \".\", \".\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \"1\", \".\", \".\", \"7\", \".\", \".\"],\n    [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \"3\", \".\", \".\", \".\", \"6\", \".\"],\n    [\".\", \".\", \".\", \".\", \".\", \"6\", \".\", \"9\", \".\"],",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "grid",
        "kind": 5,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "grid = [\n    [\".\", \"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \"4\", \".\", \".\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \"1\", \".\", \".\", \"7\", \".\", \".\"],\n    [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \"3\", \".\", \".\", \".\", \"6\", \".\"],\n    [\".\", \".\", \".\", \".\", \".\", \"6\", \".\", \"9\", \".\"],\n    [\".\", \".\", \".\", \".\", \"1\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \".\", \".\", \".\", \"2\", \".\", \".\"],\n    [\".\", \".\", \".\", \"8\", \".\", \".\", \".\", \".\", \".\"],",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 5,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "solution = [['O', '0'],\n            ['M', '1'],\n            ['Y', '2'],\n            ['E', '5'],\n            ['N', '6'],\n            ['D', '7'],\n            ['R', '8'],\n            ['S', '9']]\nthe output should be\nisCryptSolution(crypt, solution) = true.",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 5,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "solution = [['O', '1'],\n            ['T', '0'],\n            ['W', '9'],\n            ['E', '5'],\n            ['N', '4']]\nthe output should be\nisCryptSolution(crypt, solution) = false.\nEven though 054 + 091 = 145, 054 and 091 both contain leading zeroes, meaning that this is not a valid solution.\n\"\"\"\ncrypt = [\"SEND\", \"MORE\", \"MONEY\"]",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "crypt",
        "kind": 5,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "crypt = [\"SEND\", \"MORE\", \"MONEY\"]\nsolution = [\n    [\"O\", \"0\"],\n    [\"M\", \"1\"],\n    [\"Y\", \"2\"],\n    [\"E\", \"5\"],\n    [\"N\", \"6\"],\n    [\"D\", \"7\"],\n    [\"R\", \"8\"],\n    [\"S\", \"9\"],",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "solution",
        "kind": 5,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "solution = [\n    [\"O\", \"0\"],\n    [\"M\", \"1\"],\n    [\"Y\", \"2\"],\n    [\"E\", \"5\"],\n    [\"N\", \"6\"],\n    [\"D\", \"7\"],\n    [\"R\", \"8\"],\n    [\"S\", \"9\"],\n]",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "k = 3\n# my solution\ndef removeKFromList(l, k):\n    if l is None:\n        return []\n    current = l\n    prev = None\n    while current is not None:\n        if current.value == k:\n            # if the head has the current value just put the value of",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "isListPalindrome(l)",
        "kind": 5,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "isListPalindrome(l) = true;\nFor l = [1, 2, 2, 3], the output should be\nisListPalindrome(l) = false.\n\"\"\"\n# Singly-linked lists are already defined with this interface:\n# class ListNode(object):\n#   def __init__(self, x):\n#     self.value = x\n#     self.next = None# my solution (used google)\ndef isListPalindrome(l):",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "isListPalindrome(l)",
        "kind": 5,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "isListPalindrome(l) = false.\n\"\"\"\n# Singly-linked lists are already defined with this interface:\n# class ListNode(object):\n#   def __init__(self, x):\n#     self.value = x\n#     self.next = None# my solution (used google)\ndef isListPalindrome(l):\n    if l is None:\n        return True",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "a = [1]\nb = [9999, 9999, 9999, 9999, 9999, 9999]\n# my code couldn't get to pass\n# def addTwoHugeNumbers(a, b):\n#     if a is None and b is None:\n#         return [0]\n#     if a.value == 0:\n#         return b\n#     cur_a = a\n#     cur_b = b",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "wk18.code_signal.codesignal",
        "description": "wk18.code_signal.codesignal",
        "peekOfCode": "b = [9999, 9999, 9999, 9999, 9999, 9999]\n# my code couldn't get to pass\n# def addTwoHugeNumbers(a, b):\n#     if a is None and b is None:\n#         return [0]\n#     if a.value == 0:\n#         return b\n#     cur_a = a\n#     cur_b = b\n#     a_val = ''",
        "detail": "wk18.code_signal.codesignal",
        "documentation": {}
    },
    {
        "label": "threeCharsDistinct",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-week1-projects",
        "description": "wk18.code_signal.cs-week1-projects",
        "peekOfCode": "def threeCharsDistinct(s):\n    count = 0\n    for i in range(len(s)):\n        if i < len(s) - 2:\n            # print(i)\n            if s[i] != s[i + 1] and s[i] != s[i + 2] and s[i + 1] != s[i + 2]:\n                count += 1\n    return count\n# print(threeCharsDistinct(s))\nsentence = \"Man bites dog\"",
        "detail": "wk18.code_signal.cs-week1-projects",
        "documentation": {}
    },
    {
        "label": "reverseSentence",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-week1-projects",
        "description": "wk18.code_signal.cs-week1-projects",
        "peekOfCode": "def reverseSentence(sentence):\n    words_array = sentence.split(\" \")\n    words_reversed = \" \".join(reversed(words_array))\n    return words_reversed\n# print(reverseSentence(sentence))\npasscode = \"1111\"\nattempts = [\n    \"1111\",\n    \"4444\",\n    \"9999\",",
        "detail": "wk18.code_signal.cs-week1-projects",
        "documentation": {}
    },
    {
        "label": "incorrectPasscodeAttempts",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-week1-projects",
        "description": "wk18.code_signal.cs-week1-projects",
        "peekOfCode": "def incorrectPasscodeAttempts(passcode, attempts):\n    count = 0\n    indexes = []\n    if len(attempts) < 10 and passcode not in attempts:\n        return False\n    for attempt in attempts:\n        print(\"attempt:\", attempt)\n        if attempt != passcode:\n            print(\"count before:\", count)\n            count += 1",
        "detail": "wk18.code_signal.cs-week1-projects",
        "documentation": {}
    },
    {
        "label": "digitSumsDifference",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-week1-projects",
        "description": "wk18.code_signal.cs-week1-projects",
        "peekOfCode": "def digitSumsDifference(n):\n    evens_sum = 0\n    odds_sum = 0\n    difference = 0\n    evens = []\n    odds = []\n    for num in str(n):\n        if int(num) % 2 == 0:\n            evens.append(int(num))\n        else:",
        "detail": "wk18.code_signal.cs-week1-projects",
        "documentation": {}
    },
    {
        "label": "digitsManipulations",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-week1-projects",
        "description": "wk18.code_signal.cs-week1-projects",
        "peekOfCode": "def digitsManipulations(n):\n    nums = []\n    for num in str(n):\n        nums.append(int(num))\n    return math.prod(nums) - sum(nums)\n# print(digitsManipulations(n))\ns = \"abcde\"\ndef countVowelConsonant(s):\n    vowel_count = 0\n    const_count = 0",
        "detail": "wk18.code_signal.cs-week1-projects",
        "documentation": {}
    },
    {
        "label": "countVowelConsonant",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-week1-projects",
        "description": "wk18.code_signal.cs-week1-projects",
        "peekOfCode": "def countVowelConsonant(s):\n    vowel_count = 0\n    const_count = 0\n    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    for letter in s:\n        if letter in vowels:\n            vowel_count += 1\n        else:\n            const_count += 2\n    return vowel_count + const_count",
        "detail": "wk18.code_signal.cs-week1-projects",
        "documentation": {}
    },
    {
        "label": "contains_duplicate_2",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-week1-projects",
        "description": "wk18.code_signal.cs-week1-projects",
        "peekOfCode": "def contains_duplicate_2(nums):\n    # overall runtime: O(nlogn + n) --> O(n log n)\n    # space complexity: O(1)\n    nums.sort()  # sorting is usually O(n log n)\n    # nums.sort() sorts it in place\n    # everything below this line is O(n)\n    i = 0  # O(1)\n    while i < len(nums) - 1:  # up to O(n)\n        if nums[i] == nums[i + 1]:  # O(1)\n            return True",
        "detail": "wk18.code_signal.cs-week1-projects",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-week1-projects",
        "description": "wk18.code_signal.cs-week1-projects",
        "peekOfCode": "s = \"abacaba\"\n# def threeCharsDistinct(s):\n#     count = 0\n#     for i in range(len(s)):\n#         if i < 6:\n#             if s[0] != s[i + 1] and s[i] != s[i + 2] and s[i + 1] != s[i + 2]:\n#                 count += 1\n#     print(count)\ndef threeCharsDistinct(s):\n    count = 0",
        "detail": "wk18.code_signal.cs-week1-projects",
        "documentation": {}
    },
    {
        "label": "sentence",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-week1-projects",
        "description": "wk18.code_signal.cs-week1-projects",
        "peekOfCode": "sentence = \"Man bites dog\"\ndef reverseSentence(sentence):\n    words_array = sentence.split(\" \")\n    words_reversed = \" \".join(reversed(words_array))\n    return words_reversed\n# print(reverseSentence(sentence))\npasscode = \"1111\"\nattempts = [\n    \"1111\",\n    \"4444\",",
        "detail": "wk18.code_signal.cs-week1-projects",
        "documentation": {}
    },
    {
        "label": "passcode",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-week1-projects",
        "description": "wk18.code_signal.cs-week1-projects",
        "peekOfCode": "passcode = \"1111\"\nattempts = [\n    \"1111\",\n    \"4444\",\n    \"9999\",\n    \"3333\",\n    \"8888\",\n    \"2222\",\n    \"7777\",\n    \"0000\",",
        "detail": "wk18.code_signal.cs-week1-projects",
        "documentation": {}
    },
    {
        "label": "attempts",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-week1-projects",
        "description": "wk18.code_signal.cs-week1-projects",
        "peekOfCode": "attempts = [\n    \"1111\",\n    \"4444\",\n    \"9999\",\n    \"3333\",\n    \"8888\",\n    \"2222\",\n    \"7777\",\n    \"0000\",\n    \"6666\",",
        "detail": "wk18.code_signal.cs-week1-projects",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-week1-projects",
        "description": "wk18.code_signal.cs-week1-projects",
        "peekOfCode": "n = 412\ndef digitSumsDifference(n):\n    evens_sum = 0\n    odds_sum = 0\n    difference = 0\n    evens = []\n    odds = []\n    for num in str(n):\n        if int(num) % 2 == 0:\n            evens.append(int(num))",
        "detail": "wk18.code_signal.cs-week1-projects",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-week1-projects",
        "description": "wk18.code_signal.cs-week1-projects",
        "peekOfCode": "n = 123456\ndef digitsManipulations(n):\n    nums = []\n    for num in str(n):\n        nums.append(int(num))\n    return math.prod(nums) - sum(nums)\n# print(digitsManipulations(n))\ns = \"abcde\"\ndef countVowelConsonant(s):\n    vowel_count = 0",
        "detail": "wk18.code_signal.cs-week1-projects",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-week1-projects",
        "description": "wk18.code_signal.cs-week1-projects",
        "peekOfCode": "s = \"abcde\"\ndef countVowelConsonant(s):\n    vowel_count = 0\n    const_count = 0\n    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    for letter in s:\n        if letter in vowels:\n            vowel_count += 1\n        else:\n            const_count += 2",
        "detail": "wk18.code_signal.cs-week1-projects",
        "documentation": {}
    },
    {
        "label": "remove_duplicates",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "def remove_duplicates(nums):\n    # Your code here\n    i = 0\n    while i < len(nums) - 1:\n        if nums[i] == nums[i + 1]:\n            nums.pop(i + 1)\n        else:\n            i = i + 1\n    return nums\n\"\"\"",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "contains_duplicate",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "def contains_duplicate(nums):\n    # Your code here\n    num_set = set(nums)\n    if len(num_set) == len(nums):\n        return False\n    else:\n        return True\n# print(contains_duplicate([1, 3, 3, 2, 1]))\n\"\"\"\nGiven two strings `a` and `b`, write a function to determine if `a` is an",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "is_anagram",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "def is_anagram(a, b):\n    # Your code here\n    pass\n# # \"\"\"\n# # Example One\n# # \"\"\"\n# # my_list1 = [1, 2, 3, 4, 5, 6]\n# # my_list2 = my_list1\n# # # How would you verify that my_list1 and my_list2 have the same identity?\n# # print(id(my_list1) == id(my_list2))",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "fibonacci",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "def fibonacci(n):\n    lst = [0, 1]\n    for i in range(2, n):\n        lst.append(lst[i - 2] + lst[i - 1])\n    return lst[n - 1]\n# # O(n)\n# \"\"\"\n# Use Big O notation to classify the space complexity of the function below.\n# \"\"\"\n#",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "fibonacci_two",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "def fibonacci_two(n):\n    x, y, z = 0, 1, None\n    if n == 0:\n        return x\n    if n == 1:\n        return y\n    for i in range(2, n):\n        z = x + y\n        x, y = y, z\n    return z",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "do_something",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "def do_something(n):\n    lst = []\n    for i in range(n):\n        for j in range(n):\n            lst.append(i + j)\n    return lst\n# O(n^2)\n# numbers = [2, 0, 0, 0]\n#\ndef removeEvens(numbers):",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "removeEvens",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "def removeEvens(numbers):\n    return [num for num in numbers if num % 2 != 0]\n# below code didn't pass tests above did\n# for num in numbers:\n#     if num % 2 == 0 and num != 0:\n#         numbers.remove(num)\n# return numbers\n# print(removeEvens(numbers))\nimport statistics\nsequence = [-1, 3, -2, 2]",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "arrayMedian",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "def arrayMedian(sequence):\n    return statistics.median(sequence)\n# print(arrayMedian(sequence))\n# s = \"TuVwXYZ\"\n# # s = \"ABCDEFFDEfghCBA\"\n# # def originalIncreasingSubstrings(s):\n# #     string = ''\n# #     subs = []\n# #     print(''.join(sorted(s)))\n# #     i = 0",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "increasingSubstrings",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "def increasingSubstrings(s):\n    string = \"\"\n    subs = []\n    i = 0\n    if len(s) == 1:\n        subs.append(s[0])\n    else:\n        for i in range(len(s) - 1):\n            # print(s[i])\n            if not string.startswith(s[i]):",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "additionWithoutCarrying",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "def additionWithoutCarrying(param1, param2):\n    # set variable to hold the added row answers\n    result = []\n    # function to find a digit in a number\n    def find_digit(number, place):\n        return number // 10 ** place % 10\n    # get larger number\n    larger = None\n    if param1 > param2:\n        larger = param1",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "evenDigitsNumber",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "def evenDigitsNumber(a):\n    even_count = 0\n    for group in a:\n        if len(str(group)) % 2 == 0:\n            even_count += 1\n    return even_count\n# print(evenDigitsNumber(a))\n# You're writing a new programming language and you'd like it to have the capability of splitting a string into substrings with limited characters. More specifically, we'll call a substring good if the absolute difference in ASCII codes between any two of its characters is less than or equal to k.\n# For example, if k = 3, then the string \"bad\" would be considered good, since the greatest difference in ASCII codes is 3 (between the a and d characters). The string \"nice\" would not be considered good, since there's a difference of 11 between the c and n characters.\n# You are given a string strToSplit that consists of lowercase English letters only, and your task is to find the minimal number of good substrings you can split it into.",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "increasingSubstrings",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "def increasingSubstrings(s):\n    string = \"\"\n    subs = []\n    i = 0\n    if len(s) == 1:\n        subs.append(s[0])\n    else:\n        for i in range(len(s) - 1):\n            # print(s[i])\n            if not string.startswith(s[i]):",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "goodSubstrings",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "def goodSubstrings(strToSplit, k):\n    smallest = ord(strToSplit[0])\n    largest = 0\n    subs = []\n    s = \"\"\n    for i in range(len(strToSplit)):\n        # print('Letter', strToSplit[i],\n        #       ord(strToSplit[i]))\n        # print(f'smallest: {smallest} largest: {largest}')\n        if ord(strToSplit[i]) < smallest:",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "to_lower_case",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "def to_lower_case(string):\n    result = \"\"\n    for i in range(len(string)):\n        if ord(string[i]) <= 90 or ord(string[i]) <= 65:\n            result += chr(ord(string[i]) + 32)\n        else:\n            result += string[i]\n    return result\n# print(to_lower_case(string))\n\"\"\"",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "roman_to_integer",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "def roman_to_integer(roman):\n    numerals = {\n        \"I\": 1,\n        \"V\": 5,\n        \"X\": 10,\n        \"L\": 50,\n        \"C\": 100,\n        \"D\": 500,\n        \"M\": 1000,\n        \"IV\": 4,",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "find_lucky",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "def find_lucky(lst):\n    lucky = []\n    for num in lst:\n        if num == lst.count(num):\n            lucky.append(num)\n    if not lucky:\n        return -1\n    return max(lucky)\n# print(find_lucky(lst))",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "sequence",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "sequence = [-1, 3, -2, 2]\ndef arrayMedian(sequence):\n    return statistics.median(sequence)\n# print(arrayMedian(sequence))\n# s = \"TuVwXYZ\"\n# # s = \"ABCDEFFDEfghCBA\"\n# # def originalIncreasingSubstrings(s):\n# #     string = ''\n# #     subs = []\n# #     print(''.join(sorted(s)))",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "s = \"f\"\ndef increasingSubstrings(s):\n    string = \"\"\n    subs = []\n    i = 0\n    if len(s) == 1:\n        subs.append(s[0])\n    else:\n        for i in range(len(s) - 1):\n            # print(s[i])",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "param1",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "param1 = 456\nparam2 = 1734\ndef additionWithoutCarrying(param1, param2):\n    # set variable to hold the added row answers\n    result = []\n    # function to find a digit in a number\n    def find_digit(number, place):\n        return number // 10 ** place % 10\n    # get larger number\n    larger = None",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "param2",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "param2 = 1734\ndef additionWithoutCarrying(param1, param2):\n    # set variable to hold the added row answers\n    result = []\n    # function to find a digit in a number\n    def find_digit(number, place):\n        return number // 10 ** place % 10\n    # get larger number\n    larger = None\n    if param1 > param2:",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "a = [12, 134, 111, 1111, 10]\ndef evenDigitsNumber(a):\n    even_count = 0\n    for group in a:\n        if len(str(group)) % 2 == 0:\n            even_count += 1\n    return even_count\n# print(evenDigitsNumber(a))\n# You're writing a new programming language and you'd like it to have the capability of splitting a string into substrings with limited characters. More specifically, we'll call a substring good if the absolute difference in ASCII codes between any two of its characters is less than or equal to k.\n# For example, if k = 3, then the string \"bad\" would be considered good, since the greatest difference in ASCII codes is 3 (between the a and d characters). The string \"nice\" would not be considered good, since there's a difference of 11 between the c and n characters.",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "strToSplit",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "strToSplit = \"aaabaaabb\"\nk = 0\nstrToSplit = \"aaabaaabb\"\nk = 1\nstrToSplit = \"aaabzaaabb\"\nk = 5\ndef goodSubstrings(strToSplit, k):\n    smallest = ord(strToSplit[0])\n    largest = 0\n    subs = []",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "k = 0\nstrToSplit = \"aaabaaabb\"\nk = 1\nstrToSplit = \"aaabzaaabb\"\nk = 5\ndef goodSubstrings(strToSplit, k):\n    smallest = ord(strToSplit[0])\n    largest = 0\n    subs = []\n    s = \"\"",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "strToSplit",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "strToSplit = \"aaabaaabb\"\nk = 1\nstrToSplit = \"aaabzaaabb\"\nk = 5\ndef goodSubstrings(strToSplit, k):\n    smallest = ord(strToSplit[0])\n    largest = 0\n    subs = []\n    s = \"\"\n    for i in range(len(strToSplit)):",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "k = 1\nstrToSplit = \"aaabzaaabb\"\nk = 5\ndef goodSubstrings(strToSplit, k):\n    smallest = ord(strToSplit[0])\n    largest = 0\n    subs = []\n    s = \"\"\n    for i in range(len(strToSplit)):\n        # print('Letter', strToSplit[i],",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "strToSplit",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "strToSplit = \"aaabzaaabb\"\nk = 5\ndef goodSubstrings(strToSplit, k):\n    smallest = ord(strToSplit[0])\n    largest = 0\n    subs = []\n    s = \"\"\n    for i in range(len(strToSplit)):\n        # print('Letter', strToSplit[i],\n        #       ord(strToSplit[i]))",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "k = 5\ndef goodSubstrings(strToSplit, k):\n    smallest = ord(strToSplit[0])\n    largest = 0\n    subs = []\n    s = \"\"\n    for i in range(len(strToSplit)):\n        # print('Letter', strToSplit[i],\n        #       ord(strToSplit[i]))\n        # print(f'smallest: {smallest} largest: {largest}')",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "string = \"LambdaSchool\"\ndef to_lower_case(string):\n    result = \"\"\n    for i in range(len(string)):\n        if ord(string[i]) <= 90 or ord(string[i]) <= 65:\n            result += chr(ord(string[i]) + 32)\n        else:\n            result += string[i]\n    return result\n# print(to_lower_case(string))",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "roman",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "roman = \"IV\"\nroman = \"XII\"\nroman = \"MCMLXXXIV\"\n#  TODO finish this!\ndef roman_to_integer(roman):\n    numerals = {\n        \"I\": 1,\n        \"V\": 5,\n        \"X\": 10,\n        \"L\": 50,",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "roman",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "roman = \"XII\"\nroman = \"MCMLXXXIV\"\n#  TODO finish this!\ndef roman_to_integer(roman):\n    numerals = {\n        \"I\": 1,\n        \"V\": 5,\n        \"X\": 10,\n        \"L\": 50,\n        \"C\": 100,",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "roman",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "roman = \"MCMLXXXIV\"\n#  TODO finish this!\ndef roman_to_integer(roman):\n    numerals = {\n        \"I\": 1,\n        \"V\": 5,\n        \"X\": 10,\n        \"L\": 50,\n        \"C\": 100,\n        \"D\": 500,",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "lst",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-week2-projects",
        "description": "wk18.code_signal.cs-week2-projects",
        "peekOfCode": "lst = [2, 2, 3, 3, 3, 4, 4, 4, 4]\n#  O(n^2) because counting in the loop...\ndef find_lucky(lst):\n    lucky = []\n    for num in lst:\n        if num == lst.count(num):\n            lucky.append(num)\n    if not lucky:\n        return -1\n    return max(lucky)",
        "detail": "wk18.code_signal.cs-week2-projects",
        "documentation": {}
    },
    {
        "label": "LinkedListNode",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "class LinkedListNode():\n    def __init__(self, value):\n        self.value = value\n        self.next  = None\nx = LinkedListNode('X')\ny = LinkedListNode('Y')\nz = LinkedListNode('Z')\nx.next = y\ny.next = z\ndelete_node(y)",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "LinkedListNode",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "class LinkedListNode:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\ndef delete_node(node_to_delete):\n    next = node_to_delete.next\n    next.next = None\n    node_to_delete.value = next.value\n    node_to_delete.next = next.next\nx = LinkedListNode(\"X\")",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "LinkedListNode",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "class LinkedListNode:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\ndef reverse(head_of_list):\n    current_node = head_of_list\n    previous_node = None\n    next_node = None\n    # Until we have 'fallen off' the end of the list\n    while current_node:",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, x):\n        self.value = x\n        self.next = None\n[1, 3, 4, 6]\n\"\"\"\nNote: Your solution should have O(n) time complexity, where n is the number of elements in l, since this is what you will be asked to accomplish in an interview.\nYou have a singly linked list l, which is sorted in strictly increasing order, and an integer value. Add value to the list l, preserving its original sorting.\nNote: in examples below and tests preview linked lists are presented as arrays just for simplicity of visualization: in real data you will be given a head node l of the linked list\nExample",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, x):\n        self.value = x\n        self.next = None\ndef mergeTwoLinkedLists(l1, l2):\n    # create empty node to hold the new merged list\n    merged_node = ListNode(0)\n    # end will hold the end node\n    end = merged_node\n    while True:",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, x):\n        self.value = x\n        self.next = None\ndef reverseNodesInKGroups(l, k):\n    # create an empty node to hold the new list\n    new_node = ListNode(0)\n    # set the next value to the list\n    new_node.next = l\n    # set the previous node to the new list",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "LinkedListNode",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "class LinkedListNode:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\nclass Queue:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n    def enqueue(self, item):\n        new_node = LinkedListNode(item)",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "Queue",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "class Queue:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n    def enqueue(self, item):\n        new_node = LinkedListNode(item)\n        # check if queue is empty\n        if self.is_empty():\n            self.front = new_node\n            self.rear = new_node",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "class Stack:\n    def __init__(self):\n        self.data = []\n    def push(self, item):\n        self.data.append(item)\n    # my code for peek method\n    def peek(self, item):\n        return self.data[-1]\n    def pop(self):\n        if len(self.data) > 0:",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "LinkedListNode",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "class LinkedListNode:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\nclass Stack:\n    def __init__(self):\n        self.top = None\n    def push(self, data):\n        # create new node with data\n        new_node = LinkedListNode(data)",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "class Stack:\n    def __init__(self):\n        self.top = None\n    def push(self, data):\n        # create new node with data\n        new_node = LinkedListNode(data)\n        # set current top to new node's next\n        new_node.next = self.top\n        # reset the top pointer to the new node\n        self.top = new_node",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "class Stack(object):\n    def __init__(self):\n        \"\"\"Initialize an empty stack\"\"\"\n        self.items = []\n    def push(self, item):\n        \"\"\"Push a new item onto the stack\"\"\"\n        self.items.append(item)\n    def pop(self):\n        \"\"\"Remove and return the last item\"\"\"\n        # If the stack is empty, return None",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "MaxStack",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "class MaxStack(object):\n    def __init__(self):\n        # Your code here\n        self.stack = Stack()\n        # self.head = []\n        self.max_stack = Stack()\n    def push(self, item):\n        \"\"\"Add a new item onto the top of our stack.\"\"\"\n        # Your code here\n        # self.head.append(item)",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "class Stack:\n    def __init__(self):\n        self.data = []\n    def push(self, item):\n        self.data.append(item)\n    def pop(self):\n        if len(self.data) > 0:\n            return self.data.pop()\n        return \"The stack is empty\"\nclass QueueTwoStacks:",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "QueueTwoStacks",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "class QueueTwoStacks:\n    def __init__(self):\n        # Your code here\n        self.stack1 = Stack()\n        self.stack2 = Stack()\n    def enqueue(self, item):\n        # Your code here\n        self.stack1.push(item)\n    def dequeue(self):\n        # Your code here",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "class Stack:\n    def __init__(self):\n        self.items = []\n    def isEmpty(self):\n        return self.items == []\n    def push(self, item):\n        self.items.append(item)\n    def pop(self):\n        return self.items.pop()\ndef queueOnStacks(requests):",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "pivot_index",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def pivot_index(nums):\n    if len(nums) <= 1:\n        return -1\n    left = 0\n    right = sum(nums)\n    for i in range(len(nums)):\n        right -= nums[i]\n        if right == left:\n            return i\n        left += nums[i]",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "plus_one",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def plus_one(digits):\n    # check the last digit if its not 9 we just add 1\n    # if it is a 9 make it 0\n    # go left check 2nd to last if its not a 9 add 1\n    # if it is a 9\n    index = len(digits) - 1\n    while index >= 0 and digits[index] == 9:\n        digits[index] = 0\n        index -= 1\n    if index == -1:",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "buyAndSellStock",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def buyAndSellStock(prices):\n    length = len(prices)\n    # iterate array, for each item after subtract and store the amount as\n    # highest profit.. replace if needed with a higher profit\n    if prices == sorted(prices, reverse=True) or len(prices) < 2:\n        return 0\n    highest_profit = prices[1] - prices[0]\n    smallest_number = prices[0]\n    for i in range(1, length):\n        # only check if the selected number minus the smallest number before",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "alphabeticShift",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def alphabeticShift(inputString):\n    new_string = \"\"\n    for letter in inputString:\n        new_letter = ord(letter) + 1\n        if new_letter == 123:\n            new_letter = 97\n        new_string += chr(new_letter)\n    return new_string\n# print(alphabeticShift(inputString))\n\"\"\"",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "validParenthesesSequence",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def validParenthesesSequence(s):\n    check = []\n    if s == \"\":\n        return True\n    if s[0] == \")\":\n        return False\n    for paren in s:\n        if paren == \"(\":\n            check.append(paren)\n        else:",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "delete_node",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def delete_node(node_to_delete):\n    next = node_to_delete.next\n    next.next = None\n    node_to_delete.value = next.value\n    node_to_delete.next = next.next\nx = LinkedListNode(\"X\")\ny = LinkedListNode(\"Y\")\nz = LinkedListNode(\"Z\")\nx.next = y\ny.next = z",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "reverse",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def reverse(head_of_list):\n    current_node = head_of_list\n    previous_node = None\n    next_node = None\n    # Until we have 'fallen off' the end of the list\n    while current_node:\n        # Copy a pointer to the next element\n        # before we overwrite current_node.next\n        next_node = current_node.next\n        # Reverse the 'next' pointer",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "insertValueIntoSortedLinkedList",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def insertValueIntoSortedLinkedList(l, value):\n    # create a new node with the value\n    node = ListNode(value)\n    # if there is no list return the new node\n    if l == None:\n        return node\n    else:\n        # else if the list.value (first item in the list) > the new value\n        if l.value > value:\n            # set new values as the first item in the list",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "mergeTwoLinkedLists",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def mergeTwoLinkedLists(l1, l2):\n    # create empty node to hold the new merged list\n    merged_node = ListNode(0)\n    # end will hold the end node\n    end = merged_node\n    while True:\n        # if either list becomes empty join lists\n        if l1 is None:\n            end.next = l2\n            break",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "reverseNodesInKGroups",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def reverseNodesInKGroups(l, k):\n    # create an empty node to hold the new list\n    new_node = ListNode(0)\n    # set the next value to the list\n    new_node.next = l\n    # set the previous node to the new list\n    prev = new_node\n    while True:\n        # set the start to the new node next\n        start = prev.next",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "reverse_list",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def reverse_list(start, end):\n    # set the last reversed group to the new start\n    old_reversed = start\n    # set the new current to the start\n    current = start\n    # set next node to the node start is pointing to\n    next_node = start.next\n    # while the current node is not the last node\n    while current != end:\n        # iterate",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "is_valid",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def is_valid(code):\n    check = []\n    if code == \"\":\n        return True\n    if code[0] == \")\" or code[0] == \"}\" or code[0] == \"]\":\n        return False\n    for paren in code:\n        if paren == \" \":\n            continue\n        if paren == \"(\" or paren == \"{\" or paren == \"[\":",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "queueOnStacks",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def queueOnStacks(requests):\n    left = Stack()\n    right = Stack()\n    def insert(x):\n        left.push(x)\n        print(\"queue:\", left.items)\n    def remove():\n        if len(right.items) == 0:\n            while len(left.items) > 0:\n                shifted = left.pop()",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "validBracketSequence",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def validBracketSequence(sequence):\n    pairs = dict(zip(\"(,[,{\", \"),],}\"))\n    stack = []\n    for item in sequence:\n        if item in pairs:\n            stack.append(pairs[item])\n        elif not (stack and item == stack.pop()):\n            return False\n    return not stack\n# print(validBracketSequence(sequence))",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "fibonacciSimpleSum2",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def fibonacciSimpleSum2(n):\n    # if 0 is less than n and n is less than 5 then we know we can return\n    # true because n will be 1-4 which can be created with 2 fib numbers\n    if 0 < n < 5:\n        return True\n    # first get fibonacci sequence up to n\n    seq = [0, 1]\n    # starting from 2 and ending at n\n    for i in range(2, n):\n        # add seq at i - 2 (0 to start) and seq at i - 1 (1 to start)",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "csBinarySearch",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def csBinarySearch(nums, target):\n    min = 0\n    max = len(nums) - 1\n    while not max < min:\n        guess = (max + min) // 2\n        if nums[guess] == target:\n            return guess\n        elif nums[guess] < target:\n            min = guess + 1\n        else:",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "csSearchRotatedSortedArray",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def csSearchRotatedSortedArray(nums, target):\n    min = 0\n    max = len(nums) - 1\n    while not max < min:\n        guess = (max + min) // 2\n        # print(f'min: {nums[min]} max: {nums[max]} guess:{nums[guess]} target:'\n        #       f' {target}')\n        # if the guess is the target we got it and return the guess\n        if nums[guess] == target:\n            # print('guessed the target')",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "linear_search",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def linear_search(arr, target):\n    # loop through each item in the input array\n    i = len(arr) - 1\n    for idx in range(len(arr)):\n        # check if the item at the current index is equal to the target\n        if arr[i] == target:\n            # return the current index as the match\n            return i\n        i -= 1\n    # if we were able to loop through the entire array, the target is not present",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "recursive_search",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def recursive_search(arr, target):\n    if arr[0] == target:\n        return True\n    elif len(arr[1:]) > 1:\n        return recursive_search(arr[1:], target)\n    return False\n# print(recursive_search(arr, target))\n\"\"\"\nBinary Search\n\"\"\"",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "binary_search",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def binary_search(arr, target):\n    # 1. Declare min = 0 and max = length of array - 1\n    min = 0\n    max = len(arr) - 1\n    while not max < min:\n        # 2. Figure out the guess value by getting the middle integer between min and max\n        guess = (max + min) // 2\n        # 3. if array[guess] equals the target, we found the element, return the index\n        if arr[guess] == target:\n            return guess",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "binary_recursive_search",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def binary_recursive_search(arr, target, min_index, max_index):\n    if min_index >= max_index:\n        return -1\n    guess = (max_index + min_index) // 2\n    if arr[guess] == target:\n        return guess\n    elif target < arr[guess]:\n        return binary_recursive_search(arr, target, min_index, guess - 1)\n    else:\n        return binary_recursive_search(arr, target, guess + 1, max_index)",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "find_rotation_point",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def find_rotation_point(surnames):\n    # Your code here\n    min = 0\n    max = len(surnames) - 1\n    while not max < min:\n        guess = (min + max) // 2\n        if (\n            surnames[guess] < surnames[guess + 1]\n            and surnames[guess] < surnames[guess - 1]\n        ):",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "find_rotation_point",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def find_rotation_point(surnames):\n    # Your code here\n    # UNDERSTAND\n    # [ 6,   7, 8, 0, 1, 2, 3, 4, 5]\n    #           min max\n    #           mid\n    # [ 7, 0, 1,  2, 3, 4, 5, 6]\n    #  min\n    # max\n    # mid",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "firstDraftWithTypo",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def firstDraftWithTypo(n):\n    # Your code here\n    pass\n    contains_typo = 4\n    min = 0\n    max = len(n) - 1\n    while not max < min:\n        guess = (min + max) // 2\n        # if containsTypo were real this line would be:\n        # if containsTypo(n[guess]) and not containsTypo(n[guess -1]):",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "eating_cookies",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def eating_cookies(n, cache=None):\n    # if n < 0:\n    #     return 0\n    # if n == 0:\n    #     return 1\n    # return eating_cookies(n-1) + eating_cookies(n - 2) + eating_cookies(n -3)\n    # let the cache be 2 longer than n\n    cache = [0] * (n + 2)\n    print(cache)\n    cache[0] = 1",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "removeAdjacent",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def removeAdjacent(s):\n    # add first letter to new string\n    if s == \"\":\n        return s\n    new_str = s[0]\n    # iterate the string\n    for letter in s:\n        # if the next letter is the same as previous continue\n        if letter == new_str[len(new_str) - 1]:\n            continue",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "reverse_String",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def reverse_String(str):\n    i, j = 0, len(str) - 1\n    print(i, j)\n    while i < j:\n        str[i], str[j] = str[j], str[i]\n        i += 1\n        j -= 1\n    return str\n# print(reverse_String(str))\n\"\"\"",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "checkPalindrome",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def checkPalindrome(inputString):\n    return inputString == inputString[::-1]\n# print(checkPalindrome(inputString))\n\"\"\"\n*** Data Structures and Algorithms Sprint ***\n---------------------------------------------\n\"\"\"\n\"\"\"\n*** Reverse Linked List ***\n---------------------------",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "reverseLinkedList",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def reverseLinkedList(l):\n    cur = l\n    prev = None\n    next = None\n    while cur:\n        next = cur.next\n        cur.next = prev\n        prev = cur\n        cur = next\n    return prev",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "checkBlanagrams",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def checkBlanagrams(word1, word2):\n    if word1 == \"\" or word2 == \"\":\n        return False\n    work_string = \"\"\n    diff = 0\n    sort1 = sorted(word1)  # O(n) space O(nlogn) time\n    sort2 = sorted(word2)  # O(n) space O(nlogn) time\n    for i in range(len(word1)):  # O(n)\n        # check for substitutions\n        if sort1[i] != sort2[i]:",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "findValueSortedShiftedArray",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "def findValueSortedShiftedArray(nums, target):\n    min = 0\n    max = len(nums) - 1\n    while not max < min:\n        guess = (max + min) // 2\n        if nums[guess] == target:\n            return guess\n        elif nums[min] <= nums[guess]:\n            if nums[min] <= target < nums[guess]:\n                max = guess",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "nums = [1, 7, 3, 6, 5, 6]\n# nums = [1,2,3]\n#  O(N^2) solution\n# def pivot_index(nums):\n#     # iterate array starting at index 1\n#     # get sum of items on left of i and compare to sum of items on right of i\n#     # if they are equal return i else keep going to the next i\n#     for i in range(len(nums)):\n#         left = sum(nums[:i])\n#         right = sum(nums[i + 1:])",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "prices",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "prices = [3, 100, 1, 97]\n# prices = []\n# prices = [61, 91, 6, 15, 28, 30, 39, 69, 78, 81, 62, 38, 56, 69, 22, 95, 47, 82,\n#           52, 64, 74, 97, 60, 68, 5, 23, 45, 55, 66, 57, 26, 4, 21, 65, 55, 50,\n#           41, 88, 39, 84, 77, 5, 76, 11, 3, 51, 96, 100, 13, 26, 79, 98, 84, 66,\n#           93, 65, 98, 60, 57, 35, 12, 40, 83, 62, 46, 60, 26, 94, 59, 29, 70,\n#           34, 83, 98, 89, 57, 71, 44, 23, 43, 55, 1, 70, 29, 44, 10, 70, 83, 95,\n#           96, 97, 84, 23, 16, 34, 55, 59, 73, 17, 73]\n# def buyAndSellStock(prices):\n#     # iterate array, for each item after subtract and store the amount as",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "prices",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "prices = [6, 3, 1, 2, 5, 4]\nprices = [8, 5, 3, 1]\nprices = [3, 100, 1, 97]\ndef buyAndSellStock(prices):\n    length = len(prices)\n    # iterate array, for each item after subtract and store the amount as\n    # highest profit.. replace if needed with a higher profit\n    if prices == sorted(prices, reverse=True) or len(prices) < 2:\n        return 0\n    highest_profit = prices[1] - prices[0]",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "prices",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "prices = [8, 5, 3, 1]\nprices = [3, 100, 1, 97]\ndef buyAndSellStock(prices):\n    length = len(prices)\n    # iterate array, for each item after subtract and store the amount as\n    # highest profit.. replace if needed with a higher profit\n    if prices == sorted(prices, reverse=True) or len(prices) < 2:\n        return 0\n    highest_profit = prices[1] - prices[0]\n    smallest_number = prices[0]",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "prices",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "prices = [3, 100, 1, 97]\ndef buyAndSellStock(prices):\n    length = len(prices)\n    # iterate array, for each item after subtract and store the amount as\n    # highest profit.. replace if needed with a higher profit\n    if prices == sorted(prices, reverse=True) or len(prices) < 2:\n        return 0\n    highest_profit = prices[1] - prices[0]\n    smallest_number = prices[0]\n    for i in range(1, length):",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "inputString",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "inputString = \"crazy\"\ndef alphabeticShift(inputString):\n    new_string = \"\"\n    for letter in inputString:\n        new_letter = ord(letter) + 1\n        if new_letter == 123:\n            new_letter = 97\n        new_string += chr(new_letter)\n    return new_string\n# print(alphabeticShift(inputString))",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "validParenthesesSequence(s)",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "validParenthesesSequence(s) = true;\nFor s = \"()()())\", the output should be\nvalidParenthesesSequence(s) = false\n\"\"\"\ns = \"()()(())\"\ns = \"()()())\"\ndef validParenthesesSequence(s):\n    check = []\n    if s == \"\":\n        return True",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "validParenthesesSequence(s)",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "validParenthesesSequence(s) = false\n\"\"\"\ns = \"()()(())\"\ns = \"()()())\"\ndef validParenthesesSequence(s):\n    check = []\n    if s == \"\":\n        return True\n    if s[0] == \")\":\n        return False",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "s = \"()()(())\"\ns = \"()()())\"\ndef validParenthesesSequence(s):\n    check = []\n    if s == \"\":\n        return True\n    if s[0] == \")\":\n        return False\n    for paren in s:\n        if paren == \"(\":",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "s = \"()()())\"\ndef validParenthesesSequence(s):\n    check = []\n    if s == \"\":\n        return True\n    if s[0] == \")\":\n        return False\n    for paren in s:\n        if paren == \"(\":\n            check.append(paren)",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "x = LinkedListNode('X')\ny = LinkedListNode('Y')\nz = LinkedListNode('Z')\nx.next = y\ny.next = z\ndelete_node(y)\n```\n*Note: We can do this in O(1) time and space! But be aware that our solution will have some side effects...*\n\"\"\"\nclass LinkedListNode:",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "y = LinkedListNode('Y')\nz = LinkedListNode('Z')\nx.next = y\ny.next = z\ndelete_node(y)\n```\n*Note: We can do this in O(1) time and space! But be aware that our solution will have some side effects...*\n\"\"\"\nclass LinkedListNode:\n    def __init__(self, value):",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "z",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "z = LinkedListNode('Z')\nx.next = y\ny.next = z\ndelete_node(y)\n```\n*Note: We can do this in O(1) time and space! But be aware that our solution will have some side effects...*\n\"\"\"\nclass LinkedListNode:\n    def __init__(self, value):\n        self.value = value",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "x.next",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "x.next = y\ny.next = z\ndelete_node(y)\n```\n*Note: We can do this in O(1) time and space! But be aware that our solution will have some side effects...*\n\"\"\"\nclass LinkedListNode:\n    def __init__(self, value):\n        self.value = value\n        self.next = None",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "y.next",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "y.next = z\ndelete_node(y)\n```\n*Note: We can do this in O(1) time and space! But be aware that our solution will have some side effects...*\n\"\"\"\nclass LinkedListNode:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\ndef delete_node(node_to_delete):",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "x = LinkedListNode(\"X\")\ny = LinkedListNode(\"Y\")\nz = LinkedListNode(\"Z\")\nx.next = y\ny.next = z\n# print(delete_node(y))\n# print(x.next.value)\n\"\"\"\nGiven a reference to the head node of a singly-linked list, write a function\nthat reverses the linked list in place. The function should return the new head",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "y = LinkedListNode(\"Y\")\nz = LinkedListNode(\"Z\")\nx.next = y\ny.next = z\n# print(delete_node(y))\n# print(x.next.value)\n\"\"\"\nGiven a reference to the head node of a singly-linked list, write a function\nthat reverses the linked list in place. The function should return the new head\nof the reversed list.",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "z",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "z = LinkedListNode(\"Z\")\nx.next = y\ny.next = z\n# print(delete_node(y))\n# print(x.next.value)\n\"\"\"\nGiven a reference to the head node of a singly-linked list, write a function\nthat reverses the linked list in place. The function should return the new head\nof the reversed list.\nIn order to do this in O(1) space (in-place), you cannot make a new list, you",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "x.next",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "x.next = y\ny.next = z\n# print(delete_node(y))\n# print(x.next.value)\n\"\"\"\nGiven a reference to the head node of a singly-linked list, write a function\nthat reverses the linked list in place. The function should return the new head\nof the reversed list.\nIn order to do this in O(1) space (in-place), you cannot make a new list, you\nneed to use the existing nodes.",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "y.next",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "y.next = z\n# print(delete_node(y))\n# print(x.next.value)\n\"\"\"\nGiven a reference to the head node of a singly-linked list, write a function\nthat reverses the linked list in place. The function should return the new head\nof the reversed list.\nIn order to do this in O(1) space (in-place), you cannot make a new list, you\nneed to use the existing nodes.\nIn order to do this in O(n) time, you should only have to traverse the list",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "max_stack",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "max_stack = MaxStack()\nmax_stack.push(1)\nmax_stack.push(2)\nmax_stack.push(5)\nmax_stack.pop()\n# print(max_stack.get_max())\n\"\"\"\nYour goal is to define a `Queue` class that uses two stacks. Your `Queue` class\nshould have an `enqueue()` method and a `dequeue()` method that ensures a\n\"first in first out\" (FIFO) order.",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "code",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "code = \"{ [ ] ( ) }\"\ncode = \"{ [ ( ] ) }\"\ncode = \"{ [ }\"\ndef is_valid(code):\n    check = []\n    if code == \"\":\n        return True\n    if code[0] == \")\" or code[0] == \"}\" or code[0] == \"]\":\n        return False\n    for paren in code:",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "code",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "code = \"{ [ ( ] ) }\"\ncode = \"{ [ }\"\ndef is_valid(code):\n    check = []\n    if code == \"\":\n        return True\n    if code[0] == \")\" or code[0] == \"}\" or code[0] == \"]\":\n        return False\n    for paren in code:\n        if paren == \" \":",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "code",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "code = \"{ [ }\"\ndef is_valid(code):\n    check = []\n    if code == \"\":\n        return True\n    if code[0] == \")\" or code[0] == \"}\" or code[0] == \"]\":\n        return False\n    for paren in code:\n        if paren == \" \":\n            continue",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "queueOnStacks(requests)",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "queueOnStacks(requests) = [1, 2].\nAfter the first request, the queue is {1}; after the second it is {1, 2}. Then we do the third request, \"pop\", and add the first element of the queue 1 to the answer array. The queue becomes {2}. After the fourth request, the queue is {2, 3}. Then we perform \"pop\" again and add 2 to the answer array, and the queue becomes {3}.\n\"\"\"\nrequests = [\"push 1\", \"push 2\", \"pop\", \"push 3\", \"pop\"]\nclass Stack:\n    def __init__(self):\n        self.items = []\n    def isEmpty(self):\n        return self.items == []\n    def push(self, item):",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "requests = [\"push 1\", \"push 2\", \"pop\", \"push 3\", \"pop\"]\nclass Stack:\n    def __init__(self):\n        self.items = []\n    def isEmpty(self):\n        return self.items == []\n    def push(self, item):\n        self.items.append(item)\n    def pop(self):\n        return self.items.pop()",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "sequence",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "sequence = \"()\"\ndef validBracketSequence(sequence):\n    pairs = dict(zip(\"(,[,{\", \"),],}\"))\n    stack = []\n    for item in sequence:\n        if item in pairs:\n            stack.append(pairs[item])\n        elif not (stack and item == stack.pop()):\n            return False\n    return not stack",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "fibonacciSimpleSum2(n)",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "fibonacciSimpleSum2(n) = true.\nExplanation: 1 = 0 + 1 = F0 + F1.\nFor n = 11, the output should be\nfibonacciSimpleSum2(n) = true.\nExplanation: 11 = 3 + 8 = F4 + F6.\nFor n = 60, the output should be\nfibonacciSimpleSum2(n) = true.\nExplanation: 11 = 5 + 55 = F5 + F10.\nFor n = 66, the output should be\nfibonacciSimpleSum2(n) = false",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "fibonacciSimpleSum2(n)",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "fibonacciSimpleSum2(n) = true.\nExplanation: 11 = 3 + 8 = F4 + F6.\nFor n = 60, the output should be\nfibonacciSimpleSum2(n) = true.\nExplanation: 11 = 5 + 55 = F5 + F10.\nFor n = 66, the output should be\nfibonacciSimpleSum2(n) = false\n\"\"\"\ndef fibonacciSimpleSum2(n):\n    # if 0 is less than n and n is less than 5 then we know we can return",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "fibonacciSimpleSum2(n)",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "fibonacciSimpleSum2(n) = true.\nExplanation: 11 = 5 + 55 = F5 + F10.\nFor n = 66, the output should be\nfibonacciSimpleSum2(n) = false\n\"\"\"\ndef fibonacciSimpleSum2(n):\n    # if 0 is less than n and n is less than 5 then we know we can return\n    # true because n will be 1-4 which can be created with 2 fib numbers\n    if 0 < n < 5:\n        return True",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "fibonacciSimpleSum2(n)",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "fibonacciSimpleSum2(n) = false\n\"\"\"\ndef fibonacciSimpleSum2(n):\n    # if 0 is less than n and n is less than 5 then we know we can return\n    # true because n will be 1-4 which can be created with 2 fib numbers\n    if 0 < n < 5:\n        return True\n    # first get fibonacci sequence up to n\n    seq = [0, 1]\n    # starting from 2 and ending at n",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "2^n",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "2^n = 64\nlog_2 64 = 6\nWrite an exponential expression that is identical to this logarithmic expression:\nlog_2 128 = n\n2^7 = 128\nWhat keywords should you look out for that might alert you that logarithms are involved?\ndoubles, halves\n\"\"\"\n\"\"\"\nRewrite the implementation of linear search below so that the algorithm searches from the end of the list to the beginning.",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "2^7",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "2^7 = 128\nWhat keywords should you look out for that might alert you that logarithms are involved?\ndoubles, halves\n\"\"\"\n\"\"\"\nRewrite the implementation of linear search below so that the algorithm searches from the end of the list to the beginning.\n\"\"\"\ndef linear_search(arr, target):\n    # loop through each item in the input array\n    i = len(arr) - 1",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "arr = [1, 2, 3, 4, 5, 6]\ntarget = 3\n# print(linear_search(arr, target))\n\"\"\"\nWrite a recursive search function that receives as input an array of integers and a target integer value. This function should return True if the target element exists in the array, and False otherwise.\nWhat would be the base case(s) we'd have to consider for implementing this function?\nHow should our recursive solution converge on our base case(s)?\nIn your own words, write out the three rules for recursion and how you can identify when a problem is amenable to using a recursive method.\n- problem has an obvious base case\n- the data changes predictably on the way to the base case ",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "target = 3\n# print(linear_search(arr, target))\n\"\"\"\nWrite a recursive search function that receives as input an array of integers and a target integer value. This function should return True if the target element exists in the array, and False otherwise.\nWhat would be the base case(s) we'd have to consider for implementing this function?\nHow should our recursive solution converge on our base case(s)?\nIn your own words, write out the three rules for recursion and how you can identify when a problem is amenable to using a recursive method.\n- problem has an obvious base case\n- the data changes predictably on the way to the base case \n- the function must call itself",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "arr = [1, 2, 3, 4, 5, 6]\ntarget = 55\ndef binary_recursive_search(arr, target, min_index, max_index):\n    if min_index >= max_index:\n        return -1\n    guess = (max_index + min_index) // 2\n    if arr[guess] == target:\n        return guess\n    elif target < arr[guess]:\n        return binary_recursive_search(arr, target, min_index, guess - 1)",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "target = 55\ndef binary_recursive_search(arr, target, min_index, max_index):\n    if min_index >= max_index:\n        return -1\n    guess = (max_index + min_index) // 2\n    if arr[guess] == target:\n        return guess\n    elif target < arr[guess]:\n        return binary_recursive_search(arr, target, min_index, guess - 1)\n    else:",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "surnames",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "surnames = [\n    'liu',\n    'mcdowell',\n    'nixon',\n    'sparks',\n    'zhang',\n    'ahmed',  # <-- rotates here!\n    'brandt',\n    'davenport',\n    'farley',",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "surnames",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "surnames = [\n    \"sparks\",\n    \"zhang\",\n    \"liu\",\n    \"ahmed\",  # <-- rotates here!\n    \"brandt\",\n    \"davenport\",\n    \"farley\",\n    \"glover\",\n    \"kennedy\",",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "n = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ndef firstDraftWithTypo(n):\n    # Your code here\n    pass\n    contains_typo = 4\n    min = 0\n    max = len(n) - 1\n    while not max < min:\n        guess = (min + max) // 2\n        # if containsTypo were real this line would be:",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "n = 3\ndef eating_cookies(n, cache=None):\n    # if n < 0:\n    #     return 0\n    # if n == 0:\n    #     return 1\n    # return eating_cookies(n-1) + eating_cookies(n - 2) + eating_cookies(n -3)\n    # let the cache be 2 longer than n\n    cache = [0] * (n + 2)\n    print(cache)",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "removeAdjacent(s)",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "removeAdjacent(s) = \"a\";\nFor s = \"abccaaab\", the output should be\nremoveAdjacent(s) = \"abcab\".\n\"\"\"\n# s = \"aaaaa\"\n# s = \"abccaaab\"\ndef removeAdjacent(s):\n    # add first letter to new string\n    if s == \"\":\n        return s",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "removeAdjacent(s)",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "removeAdjacent(s) = \"abcab\".\n\"\"\"\n# s = \"aaaaa\"\n# s = \"abccaaab\"\ndef removeAdjacent(s):\n    # add first letter to new string\n    if s == \"\":\n        return s\n    new_str = s[0]\n    # iterate the string",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "str",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "str = \"reverse\"\ndef reverse_String(str):\n    i, j = 0, len(str) - 1\n    print(i, j)\n    while i < j:\n        str[i], str[j] = str[j], str[i]\n        i += 1\n        j -= 1\n    return str\n# print(reverse_String(str))",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "checkPalindrome(inputString)",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "checkPalindrome(inputString) = true;\nFor inputString = \"abac\", the output should be\ncheckPalindrome(inputString) = false;\nFor inputString = \"a\", the output should be\ncheckPalindrome(inputString) = true.\n\"\"\"\ninputString = \"aabaa\"\n# inputString = \"abac\"\n# inputString = \"a\"\ninputString = \"hlbeeykoqqqqokyeeblh\"",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "checkPalindrome(inputString)",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "checkPalindrome(inputString) = false;\nFor inputString = \"a\", the output should be\ncheckPalindrome(inputString) = true.\n\"\"\"\ninputString = \"aabaa\"\n# inputString = \"abac\"\n# inputString = \"a\"\ninputString = \"hlbeeykoqqqqokyeeblh\"\ndef checkPalindrome(inputString):\n    return inputString == inputString[::-1]",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "checkPalindrome(inputString)",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "checkPalindrome(inputString) = true.\n\"\"\"\ninputString = \"aabaa\"\n# inputString = \"abac\"\n# inputString = \"a\"\ninputString = \"hlbeeykoqqqqokyeeblh\"\ndef checkPalindrome(inputString):\n    return inputString == inputString[::-1]\n# print(checkPalindrome(inputString))\n\"\"\"",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "inputString",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "inputString = \"aabaa\"\n# inputString = \"abac\"\n# inputString = \"a\"\ninputString = \"hlbeeykoqqqqokyeeblh\"\ndef checkPalindrome(inputString):\n    return inputString == inputString[::-1]\n# print(checkPalindrome(inputString))\n\"\"\"\n*** Data Structures and Algorithms Sprint ***\n---------------------------------------------",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "inputString",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "inputString = \"hlbeeykoqqqqokyeeblh\"\ndef checkPalindrome(inputString):\n    return inputString == inputString[::-1]\n# print(checkPalindrome(inputString))\n\"\"\"\n*** Data Structures and Algorithms Sprint ***\n---------------------------------------------\n\"\"\"\n\"\"\"\n*** Reverse Linked List ***",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "reverseLinkedList(l)",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "reverseLinkedList(l) = [5, 4, 3, 2, 1].\n\"\"\"\n# Singly-linked lists are already defined with this interface:\n# class ListNode(object):\n#   def __init__(self, x):\n#     self.value = x\n#     self.next = None\ndef reverseLinkedList(l):\n    cur = l\n    prev = None",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "word1",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "word1 = \"tangpam\"\nword2 = \"anagram\"\ndef checkBlanagrams(word1, word2):\n    if word1 == \"\" or word2 == \"\":\n        return False\n    work_string = \"\"\n    diff = 0\n    sort1 = sorted(word1)  # O(n) space O(nlogn) time\n    sort2 = sorted(word2)  # O(n) space O(nlogn) time\n    for i in range(len(word1)):  # O(n)",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "word2",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "word2 = \"anagram\"\ndef checkBlanagrams(word1, word2):\n    if word1 == \"\" or word2 == \"\":\n        return False\n    work_string = \"\"\n    diff = 0\n    sort1 = sorted(word1)  # O(n) space O(nlogn) time\n    sort2 = sorted(word2)  # O(n) space O(nlogn) time\n    for i in range(len(word1)):  # O(n)\n        # check for substitutions",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "nums = [4, 5, 6, 7, 0, 1, 2]\ntarget = 0\ndef findValueSortedShiftedArray(nums, target):\n    min = 0\n    max = len(nums) - 1\n    while not max < min:\n        guess = (max + min) // 2\n        if nums[guess] == target:\n            return guess\n        elif nums[min] <= nums[guess]:",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks3-4-projects",
        "description": "wk18.code_signal.cs-weeks3-4-projects",
        "peekOfCode": "target = 0\ndef findValueSortedShiftedArray(nums, target):\n    min = 0\n    max = len(nums) - 1\n    while not max < min:\n        guess = (max + min) // 2\n        if nums[guess] == target:\n            return guess\n        elif nums[min] <= nums[guess]:\n            if nums[min] <= target < nums[guess]:",
        "detail": "wk18.code_signal.cs-weeks3-4-projects",
        "documentation": {}
    },
    {
        "label": "BSTNode",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "class BSTNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n    def insert(self, value):\n        if value < self.value:\n            if self.left is None:\n                self.left = BSTNode(value)\n            else:",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "BST",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "class BST:\n    def __init__(self, value):\n        self.root = BSTNode(value)\n    def insert(self, value):\n        return self.root.insert(value)\n    def search(self, target):\n        return self.root.search(target)\n    def find_minimum_value(self):\n        return self.root.find_minimum_value().value\n    def delete(self, value):",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "BinaryTreeNode",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "class BinaryTreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\ndef maxDepth(self, root):\n    # if root is None return 0\n    if root is None:\n        return 0\n    # if root exists get the left depth and the right depth by recursively",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "class TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\ndef is_valid_BST(self, root):\n    # if there is no root return False\n    if root is None:\n        return True\n    # traverse the tree to make sure it is valid",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef helper(root, res):\n    if root is None:\n        return\n    helper(root.left, res)\n    res.append(root.val)",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef helper(root, res):\n    if root is None:\n        return\n    res.append(root.val)\n    helper(root.left, res)",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef helper(root, res):\n    if root is None:\n        return\n    helper(root.left, res)\n    helper(root.right, res)",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef breadth_first_traversal(root):\n    if root is None:\n        return []\n    result = []\n    queue = []",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n# go all the way down to left then back to root then right in iterative or\n# recursive\n# for recursive solution keep track of base case (when there is no root) and\n# the recursive way\ndef inorder_traversal(root):",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef build_tree(preorder, inorder):\n    # inorder (left -> right -> root ->)\n    # preorder (root -> left -> right)\n    # the absolute root will be preorder[0]\n    # all items to the left of inorder[root] will be the left subtree",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "Graph",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "class Graph:\n    def __init__(self):\n        self.vertices = {\n            \"A\": {\"B\": 1},\n            \"B\": {\"C\": 3, \"D\": 2, \"E\": 1},\n            \"C\": {\"E\": 4},\n            \"D\": {\"E\": 2},\n            \"E\": {\"F\": 3},\n            \"F\": {},\n            \"G\": {\"D\": 1},",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "Graph",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "class Graph:\n    def __init__(self):\n        self.edges = [\n            [0, 1, 0, 0, 0, 0, 0],\n            [0, 0, 3, 3, 1, 0, 0],\n            [0, 0, 0, 0, 4, 0, 0],\n            [0, 0, 0, 0, 2, 0, 0],\n            [0, 0, 0, 0, 0, 3, 0],\n            [0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 1, 0, 0, 0],",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "Vertex",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "class Vertex:\n    def __init__(self, value):\n        self.value = value\n        self.connections = {}\n    def __str__(self):\n        return (\n            str(self.value)\n            + \" connections: \"\n            + str([x.value for x in self.connections])\n        )",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "Graph",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "class Graph:\n    def __init__(self):\n        self.vertices = {}\n        self.count = 0\n    def __contains__(self, vert):\n        return vert in self.vertices\n    def __iter__(self):\n        return iter(self.vertices.values())\n    def add_vertex(self, value):\n        self.count += 1",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "GraphNode",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "class GraphNode:\n    def __init__(self, label):\n        self.label = label\n        self.neighbors = set()\n        self.color = None\ndef color_graph(graph, colors):\n    # make a graph to pass in\n    # try to get edges count\n    # edges plus 1 is colors\n    pass",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "Graph",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "class Graph:\n    def __init__(self):\n        self.vertices = {\n                            \"A\": {\"B\", \"C\", \"D\"},\n                            \"B\": {},\n                            \"C\": {\"E\", \"F\"},\n                            \"D\": {\"G\"},\n                            \"E\": {\"G\"},\n                            \"F\": {\"J\"},\n                            \"G\": {},",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "Graph",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "class Graph:\n    def __init__(self):\n        self.vertices = {\n                            \"A\": {\"B\", \"C\", \"D\"},\n                            \"B\": {},\n                            \"C\": {\"E\", \"F\"},\n                            \"D\": {\"G\"},\n                            \"E\": {\"G\"},\n                            \"F\": {\"J\"},\n                            \"G\": {},",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "class Solution:\n    def isCompleteTree(self, root: TreeNode) -> bool:\n        # we want to check each node for a right child\n        # if a right child exists and no left child exists we can return false\n        # if the left subtree is missing one or both children where the right\n        # subtree at that level has children return false\n        # init case where a node has no right child\n        no_right_child = False\n        # init case where a node has no children\n        no_children = False",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "maxDepth",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "def maxDepth(self, root):\n    # if root is None return 0\n    if root is None:\n        return 0\n    # if root exists get the left depth and the right depth by recursively\n    # calling maxDepth on each side of the subtree\n    left_depth = self.maxDepth(root.left)\n    right_depth = self.maxDepth(root.right)\n    # if the left depth is greater than the right depth return the left depth\n    # plus 1",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "is_valid_BST",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "def is_valid_BST(self, root):\n    # if there is no root return False\n    if root is None:\n        return True\n    # traverse the tree to make sure it is valid\n    else:\n        if root.left is None and root.right is None:\n            return True\n        elif root.left is None:\n            if root.right > root:",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "balancedBinaryTree",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "def balancedBinaryTree(root):\n    # define method to get the height of the tree\n    def get_height(root):\n        if root is None:\n            return 0\n        return max(get_height(root.left), get_height(root.right)) + 1\n    # if the root is None return True\n    if root is None:\n        return True\n    # get the heights of each subtree",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "minimumDepthBinaryTree",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "def minimumDepthBinaryTree(root):\n    # if root is None return 0\n    if root is None:\n        return 0\n    # if root has no children return 1\n    if root.left is None and root.right is None:\n        return 1\n    # if no left child traverse the right tree\n    if root.left is None:\n        return minimumDepthBinaryTree(root.right) + 1",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "helper",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "def helper(root, res):\n    if root is None:\n        return\n    helper(root.left, res)\n    res.append(root.val)\n    helper(root.right, res)\ndef inorder_traversal(root):\n    result = []\n    helper(root, result)\n    return result",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "inorder_traversal",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "def inorder_traversal(root):\n    result = []\n    helper(root, result)\n    return result\n\"\"\"\nDepth first pre-order traversal\n\"\"\"\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "helper",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "def helper(root, res):\n    if root is None:\n        return\n    res.append(root.val)\n    helper(root.left, res)\n    helper(root.right, res)\ndef preorder_traversal(root):\n    result = []\n    helper(root, result)\n    return result",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "preorder_traversal",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "def preorder_traversal(root):\n    result = []\n    helper(root, result)\n    return result\n\"\"\"\nDepth first  first post-order traversal\n\"\"\"\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "helper",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "def helper(root, res):\n    if root is None:\n        return\n    helper(root.left, res)\n    helper(root.right, res)\n    res.append(root.val)\ndef postorder_traversal(root):\n    result = []\n    helper(root, result)\n    return result",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "postorder_traversal",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "def postorder_traversal(root):\n    result = []\n    helper(root, result)\n    return result\n\"\"\"\nBreadth first level order traversal\n\"\"\"\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "breadth_first_traversal",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "def breadth_first_traversal(root):\n    if root is None:\n        return []\n    result = []\n    queue = []\n    queue.append(root)\n    while len(queue) != 0:\n        node = queue.pop(0)\n        result.append(node.val)\n        if node.left is not None:",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "inorder_traversal",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "def inorder_traversal(root):\n    # base case\n    if root is None:\n        return []\n    # recursively call the function on the left child until no more left\n    # children then the root will be none and the values are returned up the\n    # chain inorder\n    return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right)\n# the iterative way with a stack\n# declare the stack and the result array",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "build_tree",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "def build_tree(preorder, inorder):\n    # inorder (left -> right -> root ->)\n    # preorder (root -> left -> right)\n    # the absolute root will be preorder[0]\n    # all items to the left of inorder[root] will be the left subtree\n    # all items to the right of inorder[root] will be the right subtree\n    # pick the next element in preorder starting with item[0]\n    # create a new node with val set to the element\n    # delete it from preorder\n    # get the index of that element from inorder list using hashMaps to",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "binaryTreeInOrderTraversal",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "def binaryTreeInOrderTraversal(root):\n    stack = []\n    result = []\n    while root is not None or stack != []:\n        while root is not None:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        result.append(root.value)\n        root = root.right",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "traverseTree",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "def traverseTree(t):\n    queue = []\n    result = []\n    if t is None:\n        return result\n    root = t\n    queue.append(root)\n    while len(queue) > 0:\n        root = queue.pop(0)\n        result.append(root.value)",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "treePaths",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "def treePaths(t):\n    if t is None:\n        return []\n    result, stack = [], [(t, \"\")]\n    while stack:\n        root, el = stack.pop()\n        if root.left is None and root.right is None:\n            result.append(el + str(root.value))\n        if root.right:\n            stack.append((root.right, el + str(root.value) + \"->\"))",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "color_graph",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "def color_graph(graph, colors):\n    # make a graph to pass in\n    # try to get edges count\n    # edges plus 1 is colors\n    pass\n\"\"\"\n*** Demo 2 ***\n--------------\nYou are given a 2d grid of `\"1\"`s and `\"0\"`s that represents a \"map\". The\n`\"1\"`s represent land and the `\"0\"s` represent water.",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "numIslands",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "def numIslands(grid):\n    pass\n# print(numIslands(grid))\n\"\"\"\n*** Code signal ***\n-------------------\nYou are given a directed acyclic graph (DAG) that contains N nodes.\nWrite a function that can find all the possible paths from node 0 to node N - 1. You can return the path in any order.\ngraph[a] is a list of all nodes b for which the edge a -> b exists.\nExample:",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "csFindAllPathsFromAToB",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "def csFindAllPathsFromAToB(graph):\n    class Graph:\n        def __init__(self):\n            self.verts = {}\n        def add_vertex(self, vert):\n            self.verts[vert] = []\n        def add_edge(self, v_from, v_to):\n            self.verts[v_from].append(v_to)\n        def is_connected(self, v_from, v_to):\n            if v_from in self.verts and v_to in self.verts:",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "floodfill",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "def floodfill(image, row, col, color):\n    if image[row][col] != \" \":\n        return\n    image[row][col] = color\n    floodfill(row, col + 1, color)\n    floodfill(row, col - 1, color)\n    floodfill(row + 1, col, color)\n    floodfill(row - 1, col, color)\n\"\"\"\nDemo 2",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "find_judge",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "def find_judge(N, trust):\n    \"\"\"\n    Inputs:\n    N -> int\n    trust -> List[List[int]]\n    Output:\n    int\n    \"\"\"\n    # Your code here\n\"\"\"",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "csFriendCircles",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "def csFriendCircles(friendships):\n    # use dfs to ensure visiting every node\n    class Graph:\n        def __init__(self):\n            self.verts = {}\n        def add_vertex(self, vert):\n            self.verts[vert] = []\n        def add_edge(self, v_from, v_to):\n            self.verts[v_from].append(v_to)\n        def is_connected(self, v_from, v_to):",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "get_neighbors",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "def get_neighbors(word):\n    neighbors = []\n    for w in words:\n        if len(w) == len(word):\n            diff = 0\n            for i in range(len(w)):\n                if w[i] != word[i]:\n                    diff += 1\n                if diff > 1:\n                    break",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "bfs",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "def bfs(start_word, end_word):\n    print(\"s, e\", start_word, end_word)\n    visited = set()\n    q = [[start_word]]\n    while q:\n        path = q.pop(0)\n        v = path[-1]\n        if v not in visited:\n            visited.add(v)\n            if v == end_word:",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "csBSTRangeSum",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "def csBSTRangeSum(root, lower, upper):\n    # variable to hold running sum of target numbers\n    range = []\n    # variable to hold the current node\n    cur = root\n    # search the tree to find all numbers within the range of lower and upper\n    # dfs\n    def helper(root):\n        if root is None:\n            return",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "csBinaryTreeInvert",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "def csBinaryTreeInvert(root):\n    # use a bft to visit all levels and switch the positions of left and\n    # right children for each node at each level\n    if root is None:\n        return []\n    result = []\n    queue = []\n    queue.append(root)\n    while len(queue) != 0:\n        node = queue.pop(0)",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "reversePairs",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "def reversePairs(nums):\n    # EDGE CASE if the array length is less than 2 return 0\n    if len(nums) < 2:\n        return 0\n    # init i to 0 and j to 1\n    i = 0\n    j = 1\n    # init count for reverse pairs found\n    count = 0\n    # iterate the array",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "log2(128)",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "log2(128) = h\n2**7 = 128\n7 <~~ answer\n- Calculate the total number of nodes on a perfect binary tree, given that \n  the height of the tree is 8.\nn = 2h - 1\nn = 2**8 - 1\nn = 256 - 1\nn = 255 <~~ answer\n\"\"\"",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "2**7",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "2**7 = 128\n7 <~~ answer\n- Calculate the total number of nodes on a perfect binary tree, given that \n  the height of the tree is 8.\nn = 2h - 1\nn = 2**8 - 1\nn = 256 - 1\nn = 255 <~~ answer\n\"\"\"\n\"\"\"",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "n = 2h - 1\nn = 2**8 - 1\nn = 256 - 1\nn = 255 <~~ answer\n\"\"\"\n\"\"\"\n*** Objective 2 Challenge *** \n-----------------------------\n- In your own words, explain why an unbalanced binary search tree's \nperformance becomes degraded.",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "n = 2**8 - 1\nn = 256 - 1\nn = 255 <~~ answer\n\"\"\"\n\"\"\"\n*** Objective 2 Challenge *** \n-----------------------------\n- In your own words, explain why an unbalanced binary search tree's \nperformance becomes degraded.\nThe worst case performance is linear because each node would potentially need to be traversed",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "n = 256 - 1\nn = 255 <~~ answer\n\"\"\"\n\"\"\"\n*** Objective 2 Challenge *** \n-----------------------------\n- In your own words, explain why an unbalanced binary search tree's \nperformance becomes degraded.\nThe worst case performance is linear because each node would potentially need to be traversed\n\"\"\"",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "n = 255 <~~ answer\n\"\"\"\n\"\"\"\n*** Objective 2 Challenge *** \n-----------------------------\n- In your own words, explain why an unbalanced binary search tree's \nperformance becomes degraded.\nThe worst case performance is linear because each node would potentially need to be traversed\n\"\"\"\n\"\"\"",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "preorder",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "preorder = [5,7,22,13,9]\ninorder = [7,5,13,22,9]\nOutput:\n    5\n   / \\\n  7  22\n    /  \\\n   13   9\n   - Preorder Traversal\n--- Visit the root node first",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "inorder",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "inorder = [7,5,13,22,9]\nOutput:\n    5\n   / \\\n  7  22\n    /  \\\n   13   9\n   - Preorder Traversal\n--- Visit the root node first\n--- Traverse the left subtree in preorder",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "preorder",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "preorder = [5, 7, 22, 13, 9]\ninorder = [7, 5, 13, 22, 9]\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef build_tree(preorder, inorder):\n    # inorder (left -> right -> root ->)",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "inorder",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "inorder = [7, 5, 13, 22, 9]\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef build_tree(preorder, inorder):\n    # inorder (left -> right -> root ->)\n    # preorder (root -> left -> right)",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "tree",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "tree = build_tree(preorder, inorder)\n# print('tree:', inorder_traversal(tree))\n\"\"\"\n*** CodeSignal ***\n------------------\n\"\"\"\n\"\"\"\nYou are given a binary tree. Write a function that returns the binary tree's node values using an in-order traversal.\nExample:\nInput: [2,None,3,4]",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "t = {\n    \"value\": 1,\n    \"left\": {\n        \"value\": 2,\n        \"left\": null,\n        \"right\": {\n            \"value\": 3,\n            \"left\": null,\n            \"right\": null\n        }",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "traverseTree(t)",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "traverseTree(t) = [1, 2, 4, 3, 5].\nThis t looks like this:\n     1\n   /   \\\n  2     4\n   \\   /\n    3 5\n\"\"\"\nt = {\n    \"value\": 1,",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "t = {\n    \"value\": 1,\n    \"left\": {\n        \"value\": 2,\n        \"left\": None,\n        \"right\": {\"value\": 3, \"left\": None, \"right\": None},\n    },\n    \"right\": {\n        \"value\": 4,\n        \"left\": {\"value\": 5, \"left\": None, \"right\": None},",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "t = {\n    \"value\": 5,\n    \"left\": {\n        \"value\": 2,\n        \"left\": {\n            \"value\": 10,\n            \"left\": null,\n            \"right\": null\n        },\n        \"right\": {",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "treePaths(t)",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "treePaths(t) = [\"5->2->10\", \"5->2->4\", \"5->-3\"].\nThe given tree looks like this:\n    5\n   / \\\n  2  -3\n / \\\n10  4\n\"\"\"\n# Binary trees are already defined with this interface:\n# class Tree(object):",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "g_verts",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "g_verts = [\"A\", \"B\", \"C\", \"D\", \"E\"]\ng = Graph()\nfor v in g_verts:\n    g.add_vertex(g)\ng.add_edge(\"A\", \"B\", 1)\ng.add_edge(\"B\", \"C\", 3)\ng.add_edge(\"B\", \"D\", 2)\ng.add_edge(\"E\", \"D\", 1)\n# for v in g:\n#     for w in v.get_connections():",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "g",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "g = Graph()\nfor v in g_verts:\n    g.add_vertex(g)\ng.add_edge(\"A\", \"B\", 1)\ng.add_edge(\"B\", \"C\", 3)\ng.add_edge(\"B\", \"D\", 2)\ng.add_edge(\"E\", \"D\", 1)\n# for v in g:\n#     for w in v.get_connections():\n#         print(\"( %s, %s )\" % (v.get_value(), w.get_value()))",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "grid",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "grid = [\n    [\"1\", \"1\", \"1\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"1\", \"0\"],\n    [\"1\", \"1\", \"0\", \"0\", \"0\"],\n    [\"0\", \"0\", \"0\", \"0\", \"0\"],\n]\ndef numIslands(grid):\n    pass\n# print(numIslands(grid))\n\"\"\"",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "graph",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "graph = [[1, 2], [3], [3], [4], []]\ndef csFindAllPathsFromAToB(graph):\n    class Graph:\n        def __init__(self):\n            self.verts = {}\n        def add_vertex(self, vert):\n            self.verts[vert] = []\n        def add_edge(self, v_from, v_to):\n            self.verts[v_from].append(v_to)\n        def is_connected(self, v_from, v_to):",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "image",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "image = [[1,1,1],[1,1,0],[1,0,1]]\nsr = 1, sc = 1, newColor = 2\nOutput: [[2,2,2],[2,2,0],[2,0,1]]\nExplanation:\nFrom the center of the image (with position (sr, sc) = (1, 1)), all pixels\nconnected by a path of the same color as the starting pixel are colored with\nthe new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally\nconnected to the starting pixel.\n```",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "sr",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "sr = 1, sc = 1, newColor = 2\nOutput: [[2,2,2],[2,2,0],[2,0,1]]\nExplanation:\nFrom the center of the image (with position (sr, sc) = (1, 1)), all pixels\nconnected by a path of the same color as the starting pixel are colored with\nthe new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally\nconnected to the starting pixel.\n```\nNotes:",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "friendships",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "friendships = [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\nfriendships = [[1, 1, 0], [1, 1, 1], [0, 1, 1]]\ndef csFriendCircles(friendships):\n    # use dfs to ensure visiting every node\n    class Graph:\n        def __init__(self):\n            self.verts = {}\n        def add_vertex(self, vert):\n            self.verts[vert] = []\n        def add_edge(self, v_from, v_to):",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "friendships",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "friendships = [[1, 1, 0], [1, 1, 1], [0, 1, 1]]\ndef csFriendCircles(friendships):\n    # use dfs to ensure visiting every node\n    class Graph:\n        def __init__(self):\n            self.verts = {}\n        def add_vertex(self, vert):\n            self.verts[vert] = []\n        def add_edge(self, v_from, v_to):\n            self.verts[v_from].append(v_to)",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "start_word",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "start_word = 'hit'\nend_word = 'cog'\nreturn: ['hit', 'hot', 'cot', 'cog'] \n\"\"\"\nwords = set()\nwith open(\"words.txt\") as f:\n    for w in f:\n        w = w.strip().lower()\n        words.add(w)\n# create function to get all the neighbors of a word ( only 1 letter diff)",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "end_word",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "end_word = 'cog'\nreturn: ['hit', 'hot', 'cot', 'cog'] \n\"\"\"\nwords = set()\nwith open(\"words.txt\") as f:\n    for w in f:\n        w = w.strip().lower()\n        words.add(w)\n# create function to get all the neighbors of a word ( only 1 letter diff)\ndef get_neighbors(word):",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "words = set()\nwith open(\"words.txt\") as f:\n    for w in f:\n        w = w.strip().lower()\n        words.add(w)\n# create function to get all the neighbors of a word ( only 1 letter diff)\ndef get_neighbors(word):\n    neighbors = []\n    for w in words:\n        if len(w) == len(word):",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "root = [10, 5, 15, 3, 7, null, 18]\nlower = 7\nupper = 15\n         10\n         / \\\n        5  15\n       / \\    \\\n      3   7    18\nOutput:\n32",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "lower",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "lower = 7\nupper = 15\n         10\n         / \\\n        5  15\n       / \\    \\\n      3   7    18\nOutput:\n32\nExample 2:",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "upper",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "upper = 15\n         10\n         / \\\n        5  15\n       / \\    \\\n      3   7    18\nOutput:\n32\nExample 2:\nInput:",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "root = [10,5,15,3,7,13,18,1,null,6]\nlower = 6\nupper = 10\n           10\n          /  \\\n       5       15\n     / \\     /   \\ \n    3   7  13   18\n   /   /\n  1   6",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "lower",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "lower = 6\nupper = 10\n           10\n          /  \\\n       5       15\n     / \\     /   \\ \n    3   7  13   18\n   /   /\n  1   6\nOutput:",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "upper",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "upper = 10\n           10\n          /  \\\n       5       15\n     / \\     /   \\ \n    3   7  13   18\n   /   /\n  1   6\nOutput:\n23",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "root = [10, 5, 15, 3, 7, None, 18]\nlower = 7\nupper = 15\n# Binary trees are already defined with this interface:\n# class Tree(object):\n#   def __init__(self, x):\n#     self.value = x\n#     self.left = None\n#     self.right = None\n# Binary trees are already defined with this interface:",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "lower",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "lower = 7\nupper = 15\n# Binary trees are already defined with this interface:\n# class Tree(object):\n#   def __init__(self, x):\n#     self.value = x\n#     self.left = None\n#     self.right = None\n# Binary trees are already defined with this interface:\n# class Tree(object):",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "upper",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "upper = 15\n# Binary trees are already defined with this interface:\n# class Tree(object):\n#   def __init__(self, x):\n#     self.value = x\n#     self.left = None\n#     self.right = None\n# Binary trees are already defined with this interface:\n# class Tree(object):\n#   def __init__(self, x):",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks5-6-projects",
        "description": "wk18.code_signal.cs-weeks5-6-projects",
        "peekOfCode": "nums = [1, 3, 2, 3, 1]\nprint(f\"reversePairs(nums): {reversePairs(nums)}\")\n\"\"\"\n958. Check Completeness of a Binary Tree\nMedium\n1072\n14\nAdd to List\nShare\nGiven the root of a binary tree, determine if it is a complete binary tree.",
        "detail": "wk18.code_signal.cs-weeks5-6-projects",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "class ListNode:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.next = None\nclass MyHashTable:\n    def __init__(self):\n        # Your code here\n        self.size = 10\n        self.keys = [None] * self.size",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "MyHashTable",
        "kind": 6,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "class MyHashTable:\n    def __init__(self):\n        # Your code here\n        self.size = 10\n        self.keys = [None] * self.size\n        self.values = [None] * self.size\n        self.item_count = 0\n    def djb2(self, key):\n        str_key = str(key).encode()\n        hash_value = 5381",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "are_words_sorted",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "def are_words_sorted(words, alpha_order):\n    \"\"\"\n    Inputs:\n    words: List[str]\n    alpha_order: str\n    Output:\n    bool\n    \"\"\"\n    # Your code here\n    # map the letters of the string alpha_order to a dictionary",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "csFindTheSingleNumber",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "def csFindTheSingleNumber(nums):\n    appearances = {}\n    # hash the list into a dict with the number of appearances being the value\n    # and the number itself as the key\n    for num in nums:\n        if num in appearances:\n            appearances[num] += 1\n        else:\n            appearances[num] = 1\n    # return the key with the value of 1",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "csAverageOfTopFive",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "def csAverageOfTopFive(scores):\n    students_scores = {}\n    # create a dict with each student as the key and an array of their scores\n    # as the value\n    for score in scores:\n        student = score[0]\n        num = score[1]\n        if student in students_scores:\n            students_scores[student].append(num)\n        else:",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "csMaxNumberOfLambdas",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "def csMaxNumberOfLambdas(text):\n    # create dict to hold number of times letters in lambda appear\n    # (the letter 'a' will need to be twice the amount of other letters for\n    # each valid lambda)\n    lambdas = {\"l\": 0, \"a\": 0, \"m\": 0, \"b\": 0, \"d\": 0}\n    # get number count for valid letters from \"text\"\n    for letter in text:\n        if letter in lambdas:\n            lambdas[letter] += 1\n    minimum_letter = lambdas[\"l\"]",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "top_k_frequent",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "def top_k_frequent(words, k):\n    \"\"\"\n    Input:\n    words -> List[str]\n    k -> int\n    Output:\n    List[str]\n    \"\"\"\n    # create dict to hold words frequencies\n    word_freqs = {}",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "frequency_sort",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "def frequency_sort(s: str) -> str:\n    \"\"\"\n    Inputs:\n    s -> str\n    Output:\n    str\n    \"\"\"\n    letter_freq = {}\n    for char in s:\n        if char not in letter_freq:",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "csIsomorphicStrings",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "def csIsomorphicStrings(a, b):\n    if len(set(a)) == len(set(b)):\n        return True\n    return False\n# print(csIsomorphicStrings(a, b))\n\"\"\"\n*** csWordPattern ***\n---------------------\nGiven a pattern and a string a, find if a follows the same pattern.\nHere, to \"follow\" means a full match, such that there is a one-to-one correspondence between a letter in pattern and a non-empty word in s.",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "csWordPattern",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "def csWordPattern(pattern, a):\n    word_arr = a.split(\" \")\n    if len(pattern) != len(word_arr):\n        return False\n    pattern_map = {}\n    for i in range(len(pattern)):\n        if pattern[i] not in pattern_map:\n            if word_arr[i] not in pattern_map.values():\n                pattern_map[pattern[i]] = word_arr[i]\n            else:",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "csGroupAnagrams",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "def csGroupAnagrams(strs):\n    result = {}\n    for w in strs:\n        signature = \"\".join(sorted(w))\n        if signature not in result:\n            result[signature] = []\n        result[signature].append(w)\n    all_results = []\n    for item in result:\n        all_results.append(result[item])",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "condense_linked_list",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "def condense_linked_list(node):\n    # keep track of seen values\n    seen_values = []\n    cur = node\n    prev = None\n    # iterate linked list from the head\n    while cur is not None:\n        print(cur.value)\n        # if current is in seen values\n        if cur.value in seen_values:",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "first_not_repeating_character",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "def first_not_repeating_character(s):\n    # create hashmap of string and occurences of letters\n    # return the first key with the value of 1\n    chars = {}\n    for letter in s:\n        if letter not in chars:\n            chars[letter] = 1\n        else:\n            chars[letter] += 1\n    for key in chars:",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "uncover_spy",
        "kind": 2,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "def uncover_spy(n, trust):\n    # create map of people who trust\n    # return the person who trusts no one\n    trusts = {}\n    trusted = {}\n    for i in range(1, n + 1):\n        trusts[i] = []\n        trusted[i] = []\n    for group in trust:\n        if group[0] in trusts:",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "hash_table",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "hash_table = MyHashTable();\nhash_table.put(\"a\", 1);\nhash_table.put(\"b\", 2);\nhash_table.get(\"a\");            // returns 1\nhash_table.get(\"c\");            // returns -1 (not found)\nhash_table.put(\"b\", 1);         // update the existing value\nhash_table.get(\"b\");            // returns 1\nhash_table.remove(\"b\");         // remove the mapping for 2\nhash_table.get(\"b\");            // returns -1 (not found)\n```",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "words = [\"lambd\", \"school\"]\norder = \"hlabcdefgijkmnopqrstuvwxyz\"\ndef are_words_sorted(words, alpha_order):\n    \"\"\"\n    Inputs:\n    words: List[str]\n    alpha_order: str\n    Output:\n    bool\n    \"\"\"",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "order",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "order = \"hlabcdefgijkmnopqrstuvwxyz\"\ndef are_words_sorted(words, alpha_order):\n    \"\"\"\n    Inputs:\n    words: List[str]\n    alpha_order: str\n    Output:\n    bool\n    \"\"\"\n    # Your code here",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "nums = [1, 1, 2, 1]\ndef csFindTheSingleNumber(nums):\n    appearances = {}\n    # hash the list into a dict with the number of appearances being the value\n    # and the number itself as the key\n    for num in nums:\n        if num in appearances:\n            appearances[num] += 1\n        else:\n            appearances[num] = 1",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "scores",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "scores = [\n    [1, 91],\n    [1, 92],\n    [2, 93],\n    [2, 97],\n    [1, 60],\n    [2, 77],\n    [1, 65],\n    [1, 87],\n    [1, 100],",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "text",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "text = \"mbxcdatllaas\"\n# text = \"sctlamb\"\n# text = \"lalaaxcmbdtsumbdav\"\ndef csMaxNumberOfLambdas(text):\n    # create dict to hold number of times letters in lambda appear\n    # (the letter 'a' will need to be twice the amount of other letters for\n    # each valid lambda)\n    lambdas = {\"l\": 0, \"a\": 0, \"m\": 0, \"b\": 0, \"d\": 0}\n    # get number count for valid letters from \"text\"\n    for letter in text:",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "words = [\"lambda\", \"school\", \"rules\", \"lambda\", \"school\", \"rocks\"]\nk = 2\nOutput:\n[\"lambda\", \"school\"]\nExplanation:\n\"lambda\" and \"school\" are the two most frequent words.\n```\nExample 2:\n```plaintext\nInput:",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "k = 2\nOutput:\n[\"lambda\", \"school\"]\nExplanation:\n\"lambda\" and \"school\" are the two most frequent words.\n```\nExample 2:\n```plaintext\nInput:\nwords = [\"the\", \"sky\", \"is\", \"cloudy\", \"the\", \"the\", \"the\", \"cloudy\", \"is\", \"is\"]",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "words = [\"the\", \"sky\", \"is\", \"cloudy\", \"the\", \"the\", \"the\", \"cloudy\", \"is\", \"is\"]\nk = 4\nOutput:\n[\"the\", \"is\", \"cloudy\", \"sky\"]\nExplanation:\n\"the\", \"is\", \"cloudy\", and \"sky\" are the four most frequent words. The words\nare sorted from highest frequency to lowest.\n```\nNotes:\n- `k` is always valid: `1 <= k <= number of unique elements.",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "k = 4\nOutput:\n[\"the\", \"is\", \"cloudy\", \"sky\"]\nExplanation:\n\"the\", \"is\", \"cloudy\", and \"sky\" are the four most frequent words. The words\nare sorted from highest frequency to lowest.\n```\nNotes:\n- `k` is always valid: `1 <= k <= number of unique elements.\n- words in the input list only contain lowercase letters.",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "words = [\"the\", \"sky\", \"is\", \"cloudy\", \"the\", \"the\", \"the\", \"cloudy\", \"is\", \"is\"]\nk = 4\nwords = [\"lambda\", \"school\", \"rules\", \"lambda\", \"school\", \"rocks\"]\nk = 2\ndef top_k_frequent(words, k):\n    \"\"\"\n    Input:\n    words -> List[str]\n    k -> int\n    Output:",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "k = 4\nwords = [\"lambda\", \"school\", \"rules\", \"lambda\", \"school\", \"rocks\"]\nk = 2\ndef top_k_frequent(words, k):\n    \"\"\"\n    Input:\n    words -> List[str]\n    k -> int\n    Output:\n    List[str]",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "words = [\"lambda\", \"school\", \"rules\", \"lambda\", \"school\", \"rocks\"]\nk = 2\ndef top_k_frequent(words, k):\n    \"\"\"\n    Input:\n    words -> List[str]\n    k -> int\n    Output:\n    List[str]\n    \"\"\"",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "k = 2\ndef top_k_frequent(words, k):\n    \"\"\"\n    Input:\n    words -> List[str]\n    k -> int\n    Output:\n    List[str]\n    \"\"\"\n    # create dict to hold words frequencies",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "s = \"Bbcc\"\ndef frequency_sort(s: str) -> str:\n    \"\"\"\n    Inputs:\n    s -> str\n    Output:\n    str\n    \"\"\"\n    letter_freq = {}\n    for char in s:",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "a = \"odd\"\nb = \"egg\"\nOutput:\ntrue\nExample 2:\nInput:\na = \"foo\"\nb = \"bar\"\nOutput:\nfalse",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "b = \"egg\"\nOutput:\ntrue\nExample 2:\nInput:\na = \"foo\"\nb = \"bar\"\nOutput:\nfalse\nExample 3:",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "a = \"foo\"\nb = \"bar\"\nOutput:\nfalse\nExample 3:\nInput:\na = \"abca\"\nb = \"zbxz\"\nOutput:\ntrue",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "b = \"bar\"\nOutput:\nfalse\nExample 3:\nInput:\na = \"abca\"\nb = \"zbxz\"\nOutput:\ntrue\nExample 4:",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "a = \"abca\"\nb = \"zbxz\"\nOutput:\ntrue\nExample 4:\nInput:\na = \"abc\"\nb = \"\"\nOutput:\nfalse",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "b = \"zbxz\"\nOutput:\ntrue\nExample 4:\nInput:\na = \"abc\"\nb = \"\"\nOutput:\nfalse\n\"\"\"",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "a = \"abc\"\nb = \"\"\nOutput:\nfalse\n\"\"\"\na = \"odd\"\nb = \"egg\"\ndef csIsomorphicStrings(a, b):\n    if len(set(a)) == len(set(b)):\n        return True",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "b = \"\"\nOutput:\nfalse\n\"\"\"\na = \"odd\"\nb = \"egg\"\ndef csIsomorphicStrings(a, b):\n    if len(set(a)) == len(set(b)):\n        return True\n    return False",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "a = \"odd\"\nb = \"egg\"\ndef csIsomorphicStrings(a, b):\n    if len(set(a)) == len(set(b)):\n        return True\n    return False\n# print(csIsomorphicStrings(a, b))\n\"\"\"\n*** csWordPattern ***\n---------------------",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "b = \"egg\"\ndef csIsomorphicStrings(a, b):\n    if len(set(a)) == len(set(b)):\n        return True\n    return False\n# print(csIsomorphicStrings(a, b))\n\"\"\"\n*** csWordPattern ***\n---------------------\nGiven a pattern and a string a, find if a follows the same pattern.",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "pattern",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "pattern = \"abba\"\na = \"lambda school school lambda\"\nOutput: true\nExample 2:\nInput:\npattern = \"abba\"\na = \"lambda school school coding\"\nOutput:\nfalse\nExample 3:",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "a = \"lambda school school lambda\"\nOutput: true\nExample 2:\nInput:\npattern = \"abba\"\na = \"lambda school school coding\"\nOutput:\nfalse\nExample 3:\nInput:",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "pattern",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "pattern = \"abba\"\na = \"lambda school school coding\"\nOutput:\nfalse\nExample 3:\nInput:\npattern = \"aaaa\"\na = \"lambda school school lambda\"\nOutput: false\nExample 4:",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "a = \"lambda school school coding\"\nOutput:\nfalse\nExample 3:\nInput:\npattern = \"aaaa\"\na = \"lambda school school lambda\"\nOutput: false\nExample 4:\nInput:",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "pattern",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "pattern = \"aaaa\"\na = \"lambda school school lambda\"\nOutput: false\nExample 4:\nInput:\npattern = \"abba\"\na = \"lambda lambda lambda lambda\"\nOutput: false\n\"\"\"\npattern = \"abba\"",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "a = \"lambda school school lambda\"\nOutput: false\nExample 4:\nInput:\npattern = \"abba\"\na = \"lambda lambda lambda lambda\"\nOutput: false\n\"\"\"\npattern = \"abba\"\na = \"lambda school school lambda\"",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "pattern",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "pattern = \"abba\"\na = \"lambda lambda lambda lambda\"\nOutput: false\n\"\"\"\npattern = \"abba\"\na = \"lambda school school lambda\"\n# pattern = \"abba\"\n# a = \"lambda lambda lambda lambda\"\n# pattern = \"aaaa\"\n# a = \"lambda school school lambda\"",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "a = \"lambda lambda lambda lambda\"\nOutput: false\n\"\"\"\npattern = \"abba\"\na = \"lambda school school lambda\"\n# pattern = \"abba\"\n# a = \"lambda lambda lambda lambda\"\n# pattern = \"aaaa\"\n# a = \"lambda school school lambda\"\ndef csWordPattern(pattern, a):",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "pattern",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "pattern = \"abba\"\na = \"lambda school school lambda\"\n# pattern = \"abba\"\n# a = \"lambda lambda lambda lambda\"\n# pattern = \"aaaa\"\n# a = \"lambda school school lambda\"\ndef csWordPattern(pattern, a):\n    word_arr = a.split(\" \")\n    if len(pattern) != len(word_arr):\n        return False",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "a = \"lambda school school lambda\"\n# pattern = \"abba\"\n# a = \"lambda lambda lambda lambda\"\n# pattern = \"aaaa\"\n# a = \"lambda school school lambda\"\ndef csWordPattern(pattern, a):\n    word_arr = a.split(\" \")\n    if len(pattern) != len(word_arr):\n        return False\n    pattern_map = {}",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "strs",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "strs = [\"apt\",\"pat\",\"ear\",\"tap\",\"are\",\"arm\"]\nOutput:\n[[\"apt\",\"pat\",\"tap\"],[\"ear\",\"are\"],[\"arm\"]]\nExample 2:\nInput:\nstrs = [\"\"]\nOutput:\n[[\"\"]]\nExample 3:\nInput:",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "strs",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "strs = [\"\"]\nOutput:\n[[\"\"]]\nExample 3:\nInput:\nstrs = [\"a\"]\nOutput:\n[[\"a\"]]\n\"\"\"\nstrs = [\"apt\", \"pat\", \"ear\", \"tap\", \"are\", \"arm\"]",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "strs",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "strs = [\"a\"]\nOutput:\n[[\"a\"]]\n\"\"\"\nstrs = [\"apt\", \"pat\", \"ear\", \"tap\", \"are\", \"arm\"]\ndef csGroupAnagrams(strs):\n    result = {}\n    for w in strs:\n        signature = \"\".join(sorted(w))\n        if signature not in result:",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "strs",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "strs = [\"apt\", \"pat\", \"ear\", \"tap\", \"are\", \"arm\"]\ndef csGroupAnagrams(strs):\n    result = {}\n    for w in strs:\n        signature = \"\".join(sorted(w))\n        if signature not in result:\n            result[signature] = []\n        result[signature].append(w)\n    all_results = []\n    for item in result:",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "first_not_repeating_character(s)",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "first_not_repeating_character(s) = 'c'.\nThere are 2 non-repeating characters in the string: 'c' and 'd'. Return c since it appears in the string first.\nFor s = \"abacabaabacaba\", the output should be\nfirst_not_repeating_character(s) = '_'.\nThere are no characters in this string that do not repeat.\n[execution time limit] 4 seconds (py3)\n[input] string s\nA string that contains only lowercase English letters.\n[output] char\nThe first non-repeating character in s of '_' if there are no characters that do not repeat.",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "first_not_repeating_character(s)",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "first_not_repeating_character(s) = '_'.\nThere are no characters in this string that do not repeat.\n[execution time limit] 4 seconds (py3)\n[input] string s\nA string that contains only lowercase English letters.\n[output] char\nThe first non-repeating character in s of '_' if there are no characters that do not repeat.\n\"\"\"\ns = \"abacabad\"\ndef first_not_repeating_character(s):",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "s = \"abacabad\"\ndef first_not_repeating_character(s):\n    # create hashmap of string and occurences of letters\n    # return the first key with the value of 1\n    chars = {}\n    for letter in s:\n        if letter not in chars:\n            chars[letter] = 1\n        else:\n            chars[letter] += 1",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "n = 3\ntrust = [[1, 2], [2, 3]]\nn = 4\ntrust = [[1, 3], [1, 4], [2, 3], [2, 4], [4, 3]]\ndef uncover_spy(n, trust):\n    # create map of people who trust\n    # return the person who trusts no one\n    trusts = {}\n    trusted = {}\n    for i in range(1, n + 1):",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "trust",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "trust = [[1, 2], [2, 3]]\nn = 4\ntrust = [[1, 3], [1, 4], [2, 3], [2, 4], [4, 3]]\ndef uncover_spy(n, trust):\n    # create map of people who trust\n    # return the person who trusts no one\n    trusts = {}\n    trusted = {}\n    for i in range(1, n + 1):\n        trusts[i] = []",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "n = 4\ntrust = [[1, 3], [1, 4], [2, 3], [2, 4], [4, 3]]\ndef uncover_spy(n, trust):\n    # create map of people who trust\n    # return the person who trusts no one\n    trusts = {}\n    trusted = {}\n    for i in range(1, n + 1):\n        trusts[i] = []\n        trusted[i] = []",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "trust",
        "kind": 5,
        "importPath": "wk18.code_signal.cs-weeks7-8-projects",
        "description": "wk18.code_signal.cs-weeks7-8-projects",
        "peekOfCode": "trust = [[1, 3], [1, 4], [2, 3], [2, 4], [4, 3]]\ndef uncover_spy(n, trust):\n    # create map of people who trust\n    # return the person who trusts no one\n    trusts = {}\n    trusted = {}\n    for i in range(1, n + 1):\n        trusts[i] = []\n        trusted[i] = []\n    for group in trust:",
        "detail": "wk18.code_signal.cs-weeks7-8-projects",
        "documentation": {}
    },
    {
        "label": "newRoadSystem",
        "kind": 2,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "def newRoadSystem(roadRegister):\n    # for every city tally the outgoing roads and incoming roads\n    roads = {}\n    out = {}\n    roads_in = {}\n    for city in range(len(roadRegister)):\n        for road in range(len(roadRegister[city])):\n            if roadRegister[city][road] == True:\n                if city not in roads:\n                    roads[city] = {road}",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "newRoadSystem",
        "kind": 2,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "def newRoadSystem(roadRegister):\n    for x, y in zip(map(sum, roadRegister), map(sum, zip(*roadRegister))):\n        if x != y:\n            return False\n    return True\n# ------------------------------\ndef newRoadSystem(roadRegister):\n    return [l.count(True) for l in roadRegister] == [\n        l.count(True) for l in zip(*roadRegister)\n    ]",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "newRoadSystem",
        "kind": 2,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "def newRoadSystem(roadRegister):\n    return [l.count(True) for l in roadRegister] == [\n        l.count(True) for l in zip(*roadRegister)\n    ]\n\"\"\"\n*** Roads Building *** \n----------------------\nOnce upon a time, in a kingdom far, far away, there lived a King Byteasar II. There was nothing special about him or his kingdom. As a mediocre ruler, he preferred hunting and feasting over doing anything about his kingdom's prosperity.\nLuckily, his adviser, the wise magician Bitlin, worked for the kingdom's welfare day and night. However, since there was no one to advise him, he completely forgot about one important thing: the roads! Over the years most of the two-way roads built by Byteasar's predecessors were forgotten and no longer traversable. Only a few roads can still be used.\nBitlin wanted each pair of cities to be connected, but couldn't find a way to figure out which roads are missing. Desperate, he turned to his magic crystal ball for help. The crystal showed him a programmer from the distant future: you! Now you're the only one who can save the kingdom. Given the existing roads and the number of cities in the kingdom, you should use the most modern technologies and find out which roads should be built again to connect each pair of cities. Since the crystal ball is quite old and meticulous, it will only transfer the information if it is sorted properly.",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "roadsBuilding",
        "kind": 2,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "def roadsBuilding(cities, roads):\n    road_dict = {}\n    result = []\n    for i in range(cities):\n        road_dict[i] = set()\n    for road in roads:\n        road_dict[road[0]].add(road[1])\n        road_dict[road[1]].add(road[0])\n    for key in road_dict:\n        if road_dict[key] == set():",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "roadsBuilding",
        "kind": 2,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "def roadsBuilding(cities, roads):\n    roads = set([tuple(road) for road in roads])\n    print(roads)\n    toBuild = []\n    for i in range(0, cities - 1):\n        for j in range(i + 1, cities):\n            if (i, j) not in roads and (j, i) not in roads:\n                toBuild.append([i, j])\n    return toBuild\n# print(roadsBuilding(cities, roads))",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "efficientRoadNetwork",
        "kind": 2,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "def efficientRoadNetwork(n, roads):\n    adj = [[] for i in range(n)]\n    for rd in roads:\n        adj[rd[0]].append(rd[1])\n        adj[rd[1]].append(rd[0])\n    print(adj)\n    for city in range(n - 1):\n        oneHop = {c for c in adj[city]}\n        print(oneHop)\n        twoHops = {c for c1 in oneHop for c in adj[c1]}",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "financialCrisis",
        "kind": 2,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "def financialCrisis(roadRegister):\n    # the results will contain a copy of the matrix reflecting each city\n    # removed one at a time\n    # create result array to hold final result\n    result = []\n    # helper function to remove the current city\n    def remove_city(current_city):\n        # print(roadRegister[current_city + 1:])\n        new_road_register = []\n        for i in range(len(roadRegister)):",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "financialCrisis",
        "kind": 2,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "def financialCrisis(roadRegister):\n    newRegister = []\n    n = len(roadRegister)\n    newRegister = [ [ [roadRegister[j][k] for j in range(n) if j!=l] for k in range(n) if k!=l] for l in range(n)] \n    return newRegister\n11:34\ndef financialCrisis(r):\n    return [[v[:j] + v[j+1:] for i, v in enumerate(r) if i!=j] for j in range(len(r))]\n\"\"\"\nprint(financialCrisis(roadRegister))",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "financialCrisis",
        "kind": 2,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "def financialCrisis(r):\n    return [[v[:j] + v[j+1:] for i, v in enumerate(r) if i!=j] for j in range(len(r))]\n\"\"\"\nprint(financialCrisis(roadRegister))\n# not sure why the expected output only wants 4 registers returned when the\n# accepted output\n# [[[false,true,false,true,false],[true,false,true,true,true],[false,true,false,false,false],[true,true,false,false,true],[false,true,false,true,false]],\n#  [[false,false,false,true,false],[false,false,true,true,true],[false,true,false,false,false],[true,true,false,false,true],[false,true,false,true,false]],\n#  [[false,false,false,true,false],[false,false,false,true,false],[false,false,false,false,false],[true,true,false,false,true],[false,false,false,true,false]],\n#  [[false,false,false,true,false],[false,false,true,true,false],[false,true,false,true,true],[true,true,true,false,true],[false,false,true,true,false]],",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "hasDeadlock",
        "kind": 2,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "def hasDeadlock(g):\n    return any(cycle(g, u, [False] * len(g)) for u in range(len(g)))\ndef cycle(g, u, path):\n    path[u] = True\n    for v in g[u]:\n        if path[v] or cycle(g, v, path.copy()):\n            return True\n    return False\n# my solution only passing 19/20 tests\n# def hasDeadlock(connections):",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "cycle",
        "kind": 2,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "def cycle(g, u, path):\n    path[u] = True\n    for v in g[u]:\n        if path[v] or cycle(g, v, path.copy()):\n            return True\n    return False\n# my solution only passing 19/20 tests\n# def hasDeadlock(connections):\n#     # find out if the graph has a cycle\n#     # helper function to see if a nodes children are visited",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "roadRegister",
        "kind": 5,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "roadRegister = [[false, true,  false, false],\n                [false, false, true,  false],\n                [true,  false, false, true ],\n                [false, false, true,  false]]\nthe output should be\nnewRoadSystem(roadRegister) = true.\nThe cities will be connected as follows:\nCities 0, 1 and 3 (0-based) have one incoming and one outgoing road, and city 2 has two incoming and two outgoing roads. Thus, the output should be true.\nFor\nroadRegister = [[false, true,  false, false, false, false, false],",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "newRoadSystem(roadRegister)",
        "kind": 5,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "newRoadSystem(roadRegister) = true.\nThe cities will be connected as follows:\nCities 0, 1 and 3 (0-based) have one incoming and one outgoing road, and city 2 has two incoming and two outgoing roads. Thus, the output should be true.\nFor\nroadRegister = [[false, true,  false, false, false, false, false],\n                [true,  false, false, false, false, false, false],\n                [false, false, false, true,  false, false, false],\n                [false, false, true,  false, false, false, false],\n                [false, false, false, false, false, false, true ],\n                [false, false, false, false, true,  false, false],",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "roadRegister",
        "kind": 5,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "roadRegister = [[false, true,  false, false, false, false, false],\n                [true,  false, false, false, false, false, false],\n                [false, false, false, true,  false, false, false],\n                [false, false, true,  false, false, false, false],\n                [false, false, false, false, false, false, true ],\n                [false, false, false, false, true,  false, false],\n                [false, false, false, false, false, true,  false]]\nthe output should be\nnewRoadSystem(roadRegister) = true.\nThe cities will be connected as follows:",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "newRoadSystem(roadRegister)",
        "kind": 5,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "newRoadSystem(roadRegister) = true.\nThe cities will be connected as follows:\nEach city has one incoming and one outgoing road.\nFor\nroadRegister = [[false, true,  false],\n                [false, false, false],\n                [true,  false, false]]\nthe output should be\nnewRoadSystem(roadRegister) = false.\nThe cities will be connected as follows:",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "roadRegister",
        "kind": 5,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "roadRegister = [[false, true,  false],\n                [false, false, false],\n                [true,  false, false]]\nthe output should be\nnewRoadSystem(roadRegister) = false.\nThe cities will be connected as follows:\nCity 1 has one incoming and no outgoing roads, and city 2 has one outgoing and no incoming roads.\nInput/Output\n[execution time limit] 4 seconds (py3)\n[input] array.array.boolean roadRegister",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "newRoadSystem(roadRegister)",
        "kind": 5,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "newRoadSystem(roadRegister) = false.\nThe cities will be connected as follows:\nCity 1 has one incoming and no outgoing roads, and city 2 has one outgoing and no incoming roads.\nInput/Output\n[execution time limit] 4 seconds (py3)\n[input] array.array.boolean roadRegister\nSince cartography has not yet been properly developed in the kingdom, the registers are used instead. A register is stored as a square matrix, with its size equal to the number of cities in the kingdom. If roadRegister[i][j] = true, then there is a road from the ith to the jth city; the road doesn't exist otherwise.\nIt is guaranteed that there are no looping roads, i.e. roads that lead back to the same city it originated from.\nGuaranteed constraints:\n1 ≤ roadRegister.length ≤ 100,",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "roadRegister[0].length",
        "kind": 5,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "roadRegister[0].length = roadRegister.length,\nroadRegister[i][i] = false.\n[output] boolean\ntrue if the new road system is good enough, false otherwise.\n\"\"\"\nroadRegister = [\n    [False, True, False, False],\n    [False, False, True, False],\n    [True, False, False, True],\n    [False, False, True, False],",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "roadRegister[i][i]",
        "kind": 5,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "roadRegister[i][i] = false.\n[output] boolean\ntrue if the new road system is good enough, false otherwise.\n\"\"\"\nroadRegister = [\n    [False, True, False, False],\n    [False, False, True, False],\n    [True, False, False, True],\n    [False, False, True, False],\n]",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "roadRegister",
        "kind": 5,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "roadRegister = [\n    [False, True, False, False],\n    [False, False, True, False],\n    [True, False, False, True],\n    [False, False, True, False],\n]\nroadRegister = [[False, True, False], [False, False, False], [True, False, False]]\n# my solution (no google)\ndef newRoadSystem(roadRegister):\n    # for every city tally the outgoing roads and incoming roads",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "roadRegister",
        "kind": 5,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "roadRegister = [[False, True, False], [False, False, False], [True, False, False]]\n# my solution (no google)\ndef newRoadSystem(roadRegister):\n    # for every city tally the outgoing roads and incoming roads\n    roads = {}\n    out = {}\n    roads_in = {}\n    for city in range(len(roadRegister)):\n        for road in range(len(roadRegister[city])):\n            if roadRegister[city][road] == True:",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "roads[i].length",
        "kind": 5,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "roads[i].length = 2,\n0 ≤ roads[i][j] < cities.\n[output] array.array.integer\nA unique array of roads that should be built sorted as described above. There's no need to build looping roads, i.e. roads that lead back from a city to itself.\n\"\"\"\ncities = 4\nroads = [[0, 1], [1, 2], [2, 0]]\n# cities = 9\n# roads = [\n#     [5, 8],",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "cities",
        "kind": 5,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "cities = 4\nroads = [[0, 1], [1, 2], [2, 0]]\n# cities = 9\n# roads = [\n#     [5, 8],\n#     [6, 0],\n#     [0, 5],\n#     [4, 1],\n#     [0, 1],\n#     [7, 0],",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "roads",
        "kind": 5,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "roads = [[0, 1], [1, 2], [2, 0]]\n# cities = 9\n# roads = [\n#     [5, 8],\n#     [6, 0],\n#     [0, 5],\n#     [4, 1],\n#     [0, 1],\n#     [7, 0],\n#     [6, 8],",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "roads",
        "kind": 5,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "roads = [[3, 0], [0, 4], [5, 0], [2, 1],\n          [1, 4], [2, 3], [5, 2]]\nthe output should be\nefficientRoadNetwork(n, roads) = true.\nHere's how the road system can be represented:\nFor n = 6 and\nroads = [[0, 4], [5, 0], [2, 1],\n          [1, 4], [2, 3], [5, 2]]\nthe output should be\nefficientRoadNetwork(n, roads) = false.",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "roads",
        "kind": 5,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "roads = [[0, 4], [5, 0], [2, 1],\n          [1, 4], [2, 3], [5, 2]]\nthe output should be\nefficientRoadNetwork(n, roads) = false.\nHere's how the road system can be represented:\nAs you can see, it's only possible to travel from city 3 to city 4 by traversing at least 3 roads.\nInput/Output\n[execution time limit] 7 seconds (py3)\n[input] integer n\nThe number of cities in the kingdom.",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "roads[i].length",
        "kind": 5,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "roads[i].length = 2,\n0 ≤ roads[i][j] < n.\n[output] boolean\ntrue if the road system is efficient, false otherwise.\n\"\"\"\nn = 6\nroads = [[3, 0], [0, 4], [5, 0], [2, 1], [1, 4], [2, 3], [5, 2]]\ntester = [\n    [0, 0, 0, 1, 1, 1],\n    [0, 0, 1, 0, 1, 0],",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "n = 6\nroads = [[3, 0], [0, 4], [5, 0], [2, 1], [1, 4], [2, 3], [5, 2]]\ntester = [\n    [0, 0, 0, 1, 1, 1],\n    [0, 0, 1, 0, 1, 0],\n    [0, 1, 0, 1, 0, 1],\n    [1, 1, 0, 0, 0, 0],\n    [1, 1, 0, 0, 0, 0],\n    [1, 0, 1, 0, 0, 0],\n]",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "roads",
        "kind": 5,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "roads = [[3, 0], [0, 4], [5, 0], [2, 1], [1, 4], [2, 3], [5, 2]]\ntester = [\n    [0, 0, 0, 1, 1, 1],\n    [0, 0, 1, 0, 1, 0],\n    [0, 1, 0, 1, 0, 1],\n    [1, 1, 0, 0, 0, 0],\n    [1, 1, 0, 0, 0, 0],\n    [1, 0, 1, 0, 0, 0],\n]\n# roads = [[0, 4], [5, 0], [2, 1],",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "tester",
        "kind": 5,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "tester = [\n    [0, 0, 0, 1, 1, 1],\n    [0, 0, 1, 0, 1, 0],\n    [0, 1, 0, 1, 0, 1],\n    [1, 1, 0, 0, 0, 0],\n    [1, 1, 0, 0, 0, 0],\n    [1, 0, 1, 0, 0, 0],\n]\n# roads = [[0, 4], [5, 0], [2, 1],\n#          [1, 4], [2, 3], [5, 2]]",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "roadRegister",
        "kind": 5,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "roadRegister = [[false, true,  true,  false],\n                [true,  false, true,  false],\n                [true,  true,  false, true ],\n                [false, false, true,  false]]\nthe output should be\nfinancialCrisis(roadRegister) = [\n  [[false, true,  false],\n   [true,  false, true ],\n   [false, true,  false]],\n  [[false, true,  false],",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "financialCrisis(roadRegister)",
        "kind": 5,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "financialCrisis(roadRegister) = [\n  [[false, true,  false],\n   [true,  false, true ],\n   [false, true,  false]],\n  [[false, true,  false],\n   [true,  false, true ],\n   [false, true,  false]],\n  [[false, true,  false],\n   [true,  false, false],\n   [false, false, false]],",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "roadRegister",
        "kind": 5,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "roadRegister = [\n    [False, False, False, False, True, False],\n    [False, False, True, False, True, False],\n    [False, True, False, True, True, True],\n    [False, False, True, False, False, False],\n    [True, True, True, False, False, True],\n    [False, False, True, False, True, False],\n]\ndef financialCrisis(roadRegister):\n    # the results will contain a copy of the matrix reflecting each city",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "hasDeadlock(connections)",
        "kind": 5,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "hasDeadlock(connections) = true.\nThis graph contains a cycle.\nFor connections = [[1, 2, 3], [2, 3], [3], []], the output should be\nhasDeadlock(connections) = false.\n\"\"\"\nconnections = [[1], [2], [3, 4], [4], [0]]\n# connections = [[1, 2, 3], [2, 3], [3], []]\nconnections = [[1, 2], [2], [], [4], [3]]\n# top codesignal solution\ndef hasDeadlock(g):",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "hasDeadlock(connections)",
        "kind": 5,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "hasDeadlock(connections) = false.\n\"\"\"\nconnections = [[1], [2], [3, 4], [4], [0]]\n# connections = [[1, 2, 3], [2, 3], [3], []]\nconnections = [[1, 2], [2], [], [4], [3]]\n# top codesignal solution\ndef hasDeadlock(g):\n    return any(cycle(g, u, [False] * len(g)) for u in range(len(g)))\ndef cycle(g, u, path):\n    path[u] = True",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "connections",
        "kind": 5,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "connections = [[1], [2], [3, 4], [4], [0]]\n# connections = [[1, 2, 3], [2, 3], [3], []]\nconnections = [[1, 2], [2], [], [4], [3]]\n# top codesignal solution\ndef hasDeadlock(g):\n    return any(cycle(g, u, [False] * len(g)) for u in range(len(g)))\ndef cycle(g, u, path):\n    path[u] = True\n    for v in g[u]:\n        if path[v] or cycle(g, v, path.copy()):",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "connections",
        "kind": 5,
        "importPath": "wk18.code_signal.graph-practice",
        "description": "wk18.code_signal.graph-practice",
        "peekOfCode": "connections = [[1, 2], [2], [], [4], [3]]\n# top codesignal solution\ndef hasDeadlock(g):\n    return any(cycle(g, u, [False] * len(g)) for u in range(len(g)))\ndef cycle(g, u, path):\n    path[u] = True\n    for v in g[u]:\n        if path[v] or cycle(g, v, path.copy()):\n            return True\n    return False",
        "detail": "wk18.code_signal.graph-practice",
        "documentation": {}
    },
    {
        "label": "groupingDishes",
        "kind": 2,
        "importPath": "wk18.code_signal.hashtables",
        "description": "wk18.code_signal.hashtables",
        "peekOfCode": "def groupingDishes(dishes):\n    # create a dictionary to hold the ingredients as keys and then dishes that use them as the values\n    ingredient_dishes = {}\n    # populate the dictionary with the dishes\n    for dish in dishes:\n        for i in range(1, len(dish)):\n            if dish[i] not in ingredient_dishes:\n                ingredient_dishes[dish[i]] = []\n            # add the dish ( 0th element of current array) to the ingredient\n            # (i th element of current array) key array in the dictionary",
        "detail": "wk18.code_signal.hashtables",
        "documentation": {}
    },
    {
        "label": "areFollowingPatterns",
        "kind": 2,
        "importPath": "wk18.code_signal.hashtables",
        "description": "wk18.code_signal.hashtables",
        "peekOfCode": "def areFollowingPatterns(strings, patterns):\n    # check if strings and patterns lengths are the same if not just return\n    # False\n    if len(strings) != len(patterns):\n        return False\n    # create a map to hold pattern item as key and string item as value\n    pattern_map = {}\n    # iterate through the patterns\n    for i in range(len(patterns)):\n        # if the current patter in not in the dict add it",
        "detail": "wk18.code_signal.hashtables",
        "documentation": {}
    },
    {
        "label": "dishes",
        "kind": 5,
        "importPath": "wk18.code_signal.hashtables",
        "description": "wk18.code_signal.hashtables",
        "peekOfCode": "dishes = [\n    [\"Salad\", \"Tomato\", \"Cucumber\", \"Salad\", \"Sauce\"],\n    [\"Pizza\", \"Tomato\", \"Sausage\", \"Sauce\", \"Dough\"],\n    [\"Quesadilla\", \"Chicken\", \"Cheese\", \"Sauce\"],\n    [\"Sandwich\", \"Salad\", \"Bread\", \"Tomato\", \"Cheese\"],\n]\ndef groupingDishes(dishes):\n    # create a dictionary to hold the ingredients as keys and then dishes that use them as the values\n    ingredient_dishes = {}\n    # populate the dictionary with the dishes",
        "detail": "wk18.code_signal.hashtables",
        "documentation": {}
    },
    {
        "label": "patterns.length",
        "kind": 5,
        "importPath": "wk18.code_signal.hashtables",
        "description": "wk18.code_signal.hashtables",
        "peekOfCode": "patterns.length = strings.length,\n1 ≤ patterns[i].length ≤ 10.\n[output] boolean\nReturn true if strings follows patterns and false otherwise.\n\"\"\"\nstrings = [\"cat\", \"dog\", \"dog\"]\npatterns = [\"a\", \"b\", \"c\"]\ndef areFollowingPatterns(strings, patterns):\n    # check if strings and patterns lengths are the same if not just return\n    # False",
        "detail": "wk18.code_signal.hashtables",
        "documentation": {}
    },
    {
        "label": "strings",
        "kind": 5,
        "importPath": "wk18.code_signal.hashtables",
        "description": "wk18.code_signal.hashtables",
        "peekOfCode": "strings = [\"cat\", \"dog\", \"dog\"]\npatterns = [\"a\", \"b\", \"c\"]\ndef areFollowingPatterns(strings, patterns):\n    # check if strings and patterns lengths are the same if not just return\n    # False\n    if len(strings) != len(patterns):\n        return False\n    # create a map to hold pattern item as key and string item as value\n    pattern_map = {}\n    # iterate through the patterns",
        "detail": "wk18.code_signal.hashtables",
        "documentation": {}
    },
    {
        "label": "patterns",
        "kind": 5,
        "importPath": "wk18.code_signal.hashtables",
        "description": "wk18.code_signal.hashtables",
        "peekOfCode": "patterns = [\"a\", \"b\", \"c\"]\ndef areFollowingPatterns(strings, patterns):\n    # check if strings and patterns lengths are the same if not just return\n    # False\n    if len(strings) != len(patterns):\n        return False\n    # create a map to hold pattern item as key and string item as value\n    pattern_map = {}\n    # iterate through the patterns\n    for i in range(len(patterns)):",
        "detail": "wk18.code_signal.hashtables",
        "documentation": {}
    },
    {
        "label": "Item",
        "kind": 6,
        "importPath": "wk18.code_signal.old-cs-algorithm",
        "description": "wk18.code_signal.old-cs-algorithm",
        "peekOfCode": "class Item:\n    def __init__(self, name, weight, value):\n        self.name = name\n        self.weight = weight\n        self.value = value\n        self.efficiency = 0\n    def __str__(self):\n        return f\"{self.name}, {self.weight}, lbs, ${self.value}\"\nsmall_cave = []\nmedium_cave = []",
        "detail": "wk18.code_signal.old-cs-algorithm",
        "documentation": {}
    },
    {
        "label": "divides_itself",
        "kind": 2,
        "importPath": "wk18.code_signal.old-cs-algorithm",
        "description": "wk18.code_signal.old-cs-algorithm",
        "peekOfCode": "def divides_itself(n):\n    # ** REFLECT\n    # using comprehension ( less efficient will always be O(N) always\n    return False not in [digit == \"0\" or n % int(digit) == 0 for digit in str(n)]\n    #  ** PLAN / EXECUTE\n    # the long way to understand below more efficient O(N) but potentially less\n    # # iterate the digits\n    # for digit in str(n):\n    #     # check every digit in n and check if n modulo digit return 0 (no\n    #     # remainder when divided)",
        "detail": "wk18.code_signal.old-cs-algorithm",
        "documentation": {}
    },
    {
        "label": "fill_cave_with_items",
        "kind": 2,
        "importPath": "wk18.code_signal.old-cs-algorithm",
        "description": "wk18.code_signal.old-cs-algorithm",
        "peekOfCode": "def fill_cave_with_items():\n    \"\"\"\n     Randomly generates item objects and creates caves of different sizes\n     for testing\n    \"\"\"\n    names = [\n        \"painting\",\n        \"jewel\",\n        \"coin\",\n        \"statue\",",
        "detail": "wk18.code_signal.old-cs-algorithm",
        "documentation": {}
    },
    {
        "label": "print_results",
        "kind": 2,
        "importPath": "wk18.code_signal.old-cs-algorithm",
        "description": "wk18.code_signal.old-cs-algorithm",
        "peekOfCode": "def print_results(items, knapsack):\n    \"\"\"\n    Printed out contents of what the algorithm calculated should be added to\n    the knapsack\n    \"\"\"\n    # print(f'\\nItems in the cave:')\n    # for i in items:\n    #   print(i)\n    total = 0\n    print(\"\\nBest items to put in the knapsack:\\n\")",
        "detail": "wk18.code_signal.old-cs-algorithm",
        "documentation": {}
    },
    {
        "label": "naive_fill_knapsack",
        "kind": 2,
        "importPath": "wk18.code_signal.old-cs-algorithm",
        "description": "wk18.code_signal.old-cs-algorithm",
        "peekOfCode": "def naive_fill_knapsack(sack, items):\n    \"\"\"\n    Put highest value items in knapsack until full\n    (other basic, naive approaches exist\n    \"\"\"\n    # TODO - sort items by value\n    items.sort(key=lambda item: item.value, reverse=True)\n    # clear knapsack in case old items inside\n    sack.clear()\n    # TODO - put items in the knapsack until full",
        "detail": "wk18.code_signal.old-cs-algorithm",
        "documentation": {}
    },
    {
        "label": "greedy_fill_knapsack",
        "kind": 2,
        "importPath": "wk18.code_signal.old-cs-algorithm",
        "description": "wk18.code_signal.old-cs-algorithm",
        "peekOfCode": "def greedy_fill_knapsack(sack, items):  # O(n log n) because of the sort\n    \"\"\"\n    Use ratio of [value] / [weight]\n    to choose items for knapsack\n    \"\"\"\n    # TODO - calculate efficiencies\n    for i in items:\n        i.efficiency = i.value / i.weight\n    # TODO - sort items by efficiency\n    \"\"\"",
        "detail": "wk18.code_signal.old-cs-algorithm",
        "documentation": {}
    },
    {
        "label": "fib",
        "kind": 2,
        "importPath": "wk18.code_signal.old-cs-algorithm",
        "description": "wk18.code_signal.old-cs-algorithm",
        "peekOfCode": "def fib(n):\n    f = [0, 1]\n    if n <= 1:\n        return f[n]\n    for i in range(2, n):\n        # add the previous two numbers\n        next_fib = f[i - 1] + f[i - 2]\n        # another way to do it\n        next_fib = f[-1] + f[-2]\n        # append the answer to create the sequence",
        "detail": "wk18.code_signal.old-cs-algorithm",
        "documentation": {}
    },
    {
        "label": "is_anagram",
        "kind": 2,
        "importPath": "wk18.code_signal.old-cs-algorithm",
        "description": "wk18.code_signal.old-cs-algorithm",
        "peekOfCode": "def is_anagram(word1, word2):\n    return sorted(word1) == sorted(word2)\ndef brute_force_anagrams():\n    # for wordlen in range(15, 31):\n    #     for word1 in words[wordlen]:\n    #         for word2 in words[wordlen]:\n    #             if word1 == word2:\n    #                 continue\n    #             if is_anagram(word1, word2):\n    #                 print(word1, word2)",
        "detail": "wk18.code_signal.old-cs-algorithm",
        "documentation": {}
    },
    {
        "label": "brute_force_anagrams",
        "kind": 2,
        "importPath": "wk18.code_signal.old-cs-algorithm",
        "description": "wk18.code_signal.old-cs-algorithm",
        "peekOfCode": "def brute_force_anagrams():\n    # for wordlen in range(15, 31):\n    #     for word1 in words[wordlen]:\n    #         for word2 in words[wordlen]:\n    #             if word1 == word2:\n    #                 continue\n    #             if is_anagram(word1, word2):\n    #                 print(word1, word2)\n    # using a signature O(N)\n    result = {}",
        "detail": "wk18.code_signal.old-cs-algorithm",
        "documentation": {}
    },
    {
        "label": "floodfill",
        "kind": 2,
        "importPath": "wk18.code_signal.old-cs-algorithm",
        "description": "wk18.code_signal.old-cs-algorithm",
        "peekOfCode": "def floodfill(row, col, char, image):\n    if image[row][col] != \" \":\n        return\n    image[row][col] = char\n    floodfill(row, col + 1, char)\n    floodfill(row, col - 1, char)\n    floodfill(row + 1, col, char)\n    floodfill(row - 1, col, char)\n\"\"\"\nAlgorithms old cs project",
        "detail": "wk18.code_signal.old-cs-algorithm",
        "documentation": {}
    },
    {
        "label": "single_number",
        "kind": 2,
        "importPath": "wk18.code_signal.old-cs-algorithm",
        "description": "wk18.code_signal.old-cs-algorithm",
        "peekOfCode": "def single_number(arr):\n    # check if the number selected is in arr[num:] or arr[:num]\n    # if so continue if not return number\n    for i in range(len(arr)):\n        if arr[i] not in arr[i + 1 :] and arr[i] not in arr[:i]:\n            return arr[i]\n# print(single_number([4, 1, 2, 1, 2]))\n\"\"\"\n*** Moving Zeroes ***\n---------------------",
        "detail": "wk18.code_signal.old-cs-algorithm",
        "documentation": {}
    },
    {
        "label": "moving_zeroes",
        "kind": 2,
        "importPath": "wk18.code_signal.old-cs-algorithm",
        "description": "wk18.code_signal.old-cs-algorithm",
        "peekOfCode": "def moving_zeroes(arr):\n    for i in range(len(arr)):\n        if arr[i] == 0:\n            arr.append(arr[i])\n            arr.remove(arr[i])\n    return arr\n# print(moving_zeroes([0, 3, 1, 0, -2]))\n\"\"\"\n*** Product of All Other Numbers ***\n------------------------------------",
        "detail": "wk18.code_signal.old-cs-algorithm",
        "documentation": {}
    },
    {
        "label": "product_of_all_other_numbers",
        "kind": 2,
        "importPath": "wk18.code_signal.old-cs-algorithm",
        "description": "wk18.code_signal.old-cs-algorithm",
        "peekOfCode": "def product_of_all_other_numbers(lst, cache, length):\n    if length == 0:\n        return 0\n    result = 1\n    to_multiply = lst[1:]\n    for num in to_multiply:\n        result = result * num\n    to_multiply.append(lst[0])\n    cache.append(result)\n    product_of_all_other_numbers(to_multiply, cache, length - 1)",
        "detail": "wk18.code_signal.old-cs-algorithm",
        "documentation": {}
    },
    {
        "label": "sliding_window_max",
        "kind": 2,
        "importPath": "wk18.code_signal.old-cs-algorithm",
        "description": "wk18.code_signal.old-cs-algorithm",
        "peekOfCode": "def sliding_window_max(lst, k):\n    count = 0\n    result = []\n    for _ in range(count, len(lst) - 2):\n        window = [lst[count], lst[count + 1], lst[count + 2]]\n        result.append(max(window))\n        count += 1\n    return result\n# print(sliding_window_max([1,3,-1,-3,5,3,6,7], 3))\n\"\"\"",
        "detail": "wk18.code_signal.old-cs-algorithm",
        "documentation": {}
    },
    {
        "label": "rock_paper_scissors",
        "kind": 2,
        "importPath": "wk18.code_signal.old-cs-algorithm",
        "description": "wk18.code_signal.old-cs-algorithm",
        "peekOfCode": "def rock_paper_scissors(n):\n    combos = []\n    def get_combos(lst, combos):\n        for i in range(len(lst)):\n            for j in range(len(lst)):\n                next_combo = [lst[i], lst[j]]\n                if next_combo not in combos:\n                    combos.append(next_combo)\n        return combos\n    return get_combos(game, combos)",
        "detail": "wk18.code_signal.old-cs-algorithm",
        "documentation": {}
    },
    {
        "label": "small_cave",
        "kind": 5,
        "importPath": "wk18.code_signal.old-cs-algorithm",
        "description": "wk18.code_signal.old-cs-algorithm",
        "peekOfCode": "small_cave = []\nmedium_cave = []\nlarge_cave = []\ndef fill_cave_with_items():\n    \"\"\"\n     Randomly generates item objects and creates caves of different sizes\n     for testing\n    \"\"\"\n    names = [\n        \"painting\",",
        "detail": "wk18.code_signal.old-cs-algorithm",
        "documentation": {}
    },
    {
        "label": "medium_cave",
        "kind": 5,
        "importPath": "wk18.code_signal.old-cs-algorithm",
        "description": "wk18.code_signal.old-cs-algorithm",
        "peekOfCode": "medium_cave = []\nlarge_cave = []\ndef fill_cave_with_items():\n    \"\"\"\n     Randomly generates item objects and creates caves of different sizes\n     for testing\n    \"\"\"\n    names = [\n        \"painting\",\n        \"jewel\",",
        "detail": "wk18.code_signal.old-cs-algorithm",
        "documentation": {}
    },
    {
        "label": "large_cave",
        "kind": 5,
        "importPath": "wk18.code_signal.old-cs-algorithm",
        "description": "wk18.code_signal.old-cs-algorithm",
        "peekOfCode": "large_cave = []\ndef fill_cave_with_items():\n    \"\"\"\n     Randomly generates item objects and creates caves of different sizes\n     for testing\n    \"\"\"\n    names = [\n        \"painting\",\n        \"jewel\",\n        \"coin\",",
        "detail": "wk18.code_signal.old-cs-algorithm",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": "wk18.code_signal.old-cs-algorithm",
        "description": "wk18.code_signal.old-cs-algorithm",
        "peekOfCode": "words = []\nwith open(\"words.txt\") as f:\n    for w in f:\n        w = w.strip()\n        words.append(w)\n# with dictionary\n# words = {}\n# with open('words.txt') as f:\n#     for w in f:\n#         w = w.strip()",
        "detail": "wk18.code_signal.old-cs-algorithm",
        "documentation": {}
    },
    {
        "label": "game",
        "kind": 5,
        "importPath": "wk18.code_signal.old-cs-algorithm",
        "description": "wk18.code_signal.old-cs-algorithm",
        "peekOfCode": "game = [\"rock\", \"paper\", \"scissors\"]\ndef rock_paper_scissors(n):\n    combos = []\n    def get_combos(lst, combos):\n        for i in range(len(lst)):\n            for j in range(len(lst)):\n                next_combo = [lst[i], lst[j]]\n                if next_combo not in combos:\n                    combos.append(next_combo)\n        return combos",
        "detail": "wk18.code_signal.old-cs-algorithm",
        "documentation": {}
    },
    {
        "label": "findWords",
        "kind": 2,
        "importPath": "wk18.code_signal.py-words",
        "description": "wk18.code_signal.py-words",
        "peekOfCode": "def findWords(rack, words):\n    res = []\n    wild_count = rack.count(\"*\")\n    for word in words:\n        rack_copy = list(rack)\n        match = True\n        wilds = wild_count\n        wilds_used = []\n        for char in word:\n            if char not in rack_copy:",
        "detail": "wk18.code_signal.py-words",
        "documentation": {}
    },
    {
        "label": "findScores",
        "kind": 2,
        "importPath": "wk18.code_signal.py-words",
        "description": "wk18.code_signal.py-words",
        "peekOfCode": "def findScores(word_arr):\n    tally = 0\n    for char in word_arr[0]:\n        if char in word_arr[1]:\n            tally += 0\n            word_arr[1].remove(char)\n        elif char in scores:\n            tally += scores[char]\n    return tally\nword_scores = []",
        "detail": "wk18.code_signal.py-words",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": "wk18.code_signal.py-words",
        "description": "wk18.code_signal.py-words",
        "peekOfCode": "words = []\nwith open(\"sowpods.txt\") as f:\n    for w in f:\n        w = w.strip()\n        words.append(w)\n\"\"\"\nWhat are all of the words containing \"uu\"?\n\"\"\"\nres = []\nfor word in words:",
        "detail": "wk18.code_signal.py-words",
        "documentation": {}
    },
    {
        "label": "res",
        "kind": 5,
        "importPath": "wk18.code_signal.py-words",
        "description": "wk18.code_signal.py-words",
        "peekOfCode": "res = []\nfor word in words:\n    if \"UU\" in word:\n        res.append(word)\n\"\"\"\nWhat are all of the letters that never appear doubled in an English word?\n\"\"\"\nalphabet = {\n    \"A\": 0,\n    \"B\": 0,",
        "detail": "wk18.code_signal.py-words",
        "documentation": {}
    },
    {
        "label": "alphabet",
        "kind": 5,
        "importPath": "wk18.code_signal.py-words",
        "description": "wk18.code_signal.py-words",
        "peekOfCode": "alphabet = {\n    \"A\": 0,\n    \"B\": 0,\n    \"C\": 0,\n    \"D\": 0,\n    \"E\": 0,\n    \"F\": 0,\n    \"G\": 0,\n    \"H\": 0,\n    \"I\": 0,",
        "detail": "wk18.code_signal.py-words",
        "documentation": {}
    },
    {
        "label": "vowels",
        "kind": 5,
        "importPath": "wk18.code_signal.py-words",
        "description": "wk18.code_signal.py-words",
        "peekOfCode": "vowels = [\"A\", \"E\", \"I\", \"O\", \"U\"]\nfor word in words:\n    if all(char in word for char in vowels):\n        # print(word)\n        pass\n\"\"\"\nWhat are all of the words that have all 5 vowels, in alphabetical order?\n\"\"\"\nfor word in words:\n    for i in range(len(word)):",
        "detail": "wk18.code_signal.py-words",
        "documentation": {}
    },
    {
        "label": "longest_pal",
        "kind": 5,
        "importPath": "wk18.code_signal.py-words",
        "description": "wk18.code_signal.py-words",
        "peekOfCode": "longest_pal = \"\"\nfor word in words:\n    if word == word[::-1]:\n        if len(word) > len(longest_pal):\n            longest_pal = word\nprint(longest_pal)\nwords = []\nscores = {\n    \"a\": 1,\n    \"b\": 3,",
        "detail": "wk18.code_signal.py-words",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": "wk18.code_signal.py-words",
        "description": "wk18.code_signal.py-words",
        "peekOfCode": "words = []\nscores = {\n    \"a\": 1,\n    \"b\": 3,\n    \"c\": 3,\n    \"d\": 2,\n    \"e\": 1,\n    \"f\": 4,\n    \"g\": 2,\n    \"h\": 4,",
        "detail": "wk18.code_signal.py-words",
        "documentation": {}
    },
    {
        "label": "scores",
        "kind": 5,
        "importPath": "wk18.code_signal.py-words",
        "description": "wk18.code_signal.py-words",
        "peekOfCode": "scores = {\n    \"a\": 1,\n    \"b\": 3,\n    \"c\": 3,\n    \"d\": 2,\n    \"e\": 1,\n    \"f\": 4,\n    \"g\": 2,\n    \"h\": 4,\n    \"i\": 1,",
        "detail": "wk18.code_signal.py-words",
        "documentation": {}
    },
    {
        "label": "letters",
        "kind": 5,
        "importPath": "wk18.code_signal.py-words",
        "description": "wk18.code_signal.py-words",
        "peekOfCode": "letters = \"SPCQEIU\".lower()\nletters = \"CAT**\".lower()\nwords = [\"at\", \"tac\", \"boy\", \"cant\", \"tact\", \"tank\"]\ndef findWords(rack, words):\n    res = []\n    wild_count = rack.count(\"*\")\n    for word in words:\n        rack_copy = list(rack)\n        match = True\n        wilds = wild_count",
        "detail": "wk18.code_signal.py-words",
        "documentation": {}
    },
    {
        "label": "letters",
        "kind": 5,
        "importPath": "wk18.code_signal.py-words",
        "description": "wk18.code_signal.py-words",
        "peekOfCode": "letters = \"CAT**\".lower()\nwords = [\"at\", \"tac\", \"boy\", \"cant\", \"tact\", \"tank\"]\ndef findWords(rack, words):\n    res = []\n    wild_count = rack.count(\"*\")\n    for word in words:\n        rack_copy = list(rack)\n        match = True\n        wilds = wild_count\n        wilds_used = []",
        "detail": "wk18.code_signal.py-words",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": "wk18.code_signal.py-words",
        "description": "wk18.code_signal.py-words",
        "peekOfCode": "words = [\"at\", \"tac\", \"boy\", \"cant\", \"tact\", \"tank\"]\ndef findWords(rack, words):\n    res = []\n    wild_count = rack.count(\"*\")\n    for word in words:\n        rack_copy = list(rack)\n        match = True\n        wilds = wild_count\n        wilds_used = []\n        for char in word:",
        "detail": "wk18.code_signal.py-words",
        "documentation": {}
    },
    {
        "label": "found_words",
        "kind": 5,
        "importPath": "wk18.code_signal.py-words",
        "description": "wk18.code_signal.py-words",
        "peekOfCode": "found_words = findWords(letters, words)\ndef findScores(word_arr):\n    tally = 0\n    for char in word_arr[0]:\n        if char in word_arr[1]:\n            tally += 0\n            word_arr[1].remove(char)\n        elif char in scores:\n            tally += scores[char]\n    return tally",
        "detail": "wk18.code_signal.py-words",
        "documentation": {}
    },
    {
        "label": "word_scores",
        "kind": 5,
        "importPath": "wk18.code_signal.py-words",
        "description": "wk18.code_signal.py-words",
        "peekOfCode": "word_scores = []\nfor word_arr in found_words:\n    score = findScores(word_arr)\n    word_scores.append([score, word_arr[0]])\nprint(sorted(word_scores, reverse=True))",
        "detail": "wk18.code_signal.py-words",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "wk18.code_signal.study",
        "description": "wk18.code_signal.study",
        "peekOfCode": "class Solution:\n    def isCompleteTree(self, root: TreeNode) -> bool:\n        # we want to check each node for a right child\n        # if a right child exists and no left child exists we can return false\n        # if the left subtree is missing one or both children where the right\n        # subtree at that level has children return false\n        # init case where a node has no right child\n        no_right_child = False\n        # init case where a node has no children\n        no_children = False",
        "detail": "wk18.code_signal.study",
        "documentation": {}
    },
    {
        "label": "reversePairs",
        "kind": 2,
        "importPath": "wk18.code_signal.study",
        "description": "wk18.code_signal.study",
        "peekOfCode": "def reversePairs(nums):\n    # EDGE CASE if the array length is less than 2 return 0\n    if len(nums) < 2:\n        return 0\n    # init i to 0 and j to 1\n    i = 0\n    j = 1\n    # init count for reverse pairs found\n    count = 0\n    # iterate the array",
        "detail": "wk18.code_signal.study",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": "wk18.code_signal.study",
        "description": "wk18.code_signal.study",
        "peekOfCode": "nums = [1, 3, 2, 3, 1]\nprint(f\"reversePairs(nums): {reversePairs(nums)}\")\n\"\"\"\n958. Check Completeness of a Binary Tree\nMedium\n1072\n14\nAdd to List\nShare\nGiven the root of a binary tree, determine if it is a complete binary tree.",
        "detail": "wk18.code_signal.study",
        "documentation": {}
    },
    {
        "label": "HashTable",
        "kind": 6,
        "importPath": "wk18.d2.copy_of_cs46ht",
        "description": "wk18.d2.copy_of_cs46ht",
        "peekOfCode": "class HashTable:\n# \"\"\"\n# A hash table with `capacity` buckets\n# that accepts string keys\n# \"\"\"\ndef __init__(self, capacity):\n    self.capacity = capacity  # Number of buckets in the hash table\n    self.storage = [None] * capacity\n    self.item_count = 0\ndef djb2(self, key):",
        "detail": "wk18.d2.copy_of_cs46ht",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "wk18.d2.copy_of_cs46ht",
        "description": "wk18.d2.copy_of_cs46ht",
        "peekOfCode": "class ListNode:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.next = None\nclass MyHashTable:\n    def __init__(self):\n        # Your code here\n        self.capacity = 1000\n        self.size = 0# Number of buckets in the hash table",
        "detail": "wk18.d2.copy_of_cs46ht",
        "documentation": {}
    },
    {
        "label": "MyHashTable",
        "kind": 6,
        "importPath": "wk18.d2.copy_of_cs46ht",
        "description": "wk18.d2.copy_of_cs46ht",
        "peekOfCode": "class MyHashTable:\n    def __init__(self):\n        # Your code here\n        self.capacity = 1000\n        self.size = 0# Number of buckets in the hash table\n        self.storage = [None] * self.capacity\n    # Your code here\n    def put(self, key, value):\n        # Your code here\n        index = self.hash_index(key)",
        "detail": "wk18.d2.copy_of_cs46ht",
        "documentation": {}
    },
    {
        "label": "my_hash",
        "kind": 2,
        "importPath": "wk18.d2.copy_of_cs46ht",
        "description": "wk18.d2.copy_of_cs46ht",
        "peekOfCode": "def my_hash(key):\n  sum = 0\n  for c in key:\n    sum += ord(c)\n  return sum\ndef my_hash2(key):\n  sum = 0\n  string_bytes = key.encode()\n  for b in string_bytes:\n    sum += b",
        "detail": "wk18.d2.copy_of_cs46ht",
        "documentation": {}
    },
    {
        "label": "my_hash2",
        "kind": 2,
        "importPath": "wk18.d2.copy_of_cs46ht",
        "description": "wk18.d2.copy_of_cs46ht",
        "peekOfCode": "def my_hash2(key):\n  sum = 0\n  string_bytes = key.encode()\n  for b in string_bytes:\n    sum += b\n  return sum\n# print(my_hash(\"ABC\"))\n# print(my_hash2(\"ABC\"))\n# djb2\n# encode key",
        "detail": "wk18.d2.copy_of_cs46ht",
        "documentation": {}
    },
    {
        "label": "djb2",
        "kind": 2,
        "importPath": "wk18.d2.copy_of_cs46ht",
        "description": "wk18.d2.copy_of_cs46ht",
        "peekOfCode": "def djb2(key):\n  str_key = str(key).encode()\n  hash_value = 5381\n  for b in str_key:\n    # shifted_value = hash_value << 5\n    # add_shift = shifted_value + hash_value\n    # total_hash = add_shift + b\n    # total_hash &= 0xffffffff # 0b11111111111111111111111111111111 32bits\n    # final_hash = total_hash & 0xffffffff\n    hash_value = ((hash_value << 5) + hash_value) + b",
        "detail": "wk18.d2.copy_of_cs46ht",
        "documentation": {}
    },
    {
        "label": "djb2",
        "kind": 2,
        "importPath": "wk18.d2.copy_of_cs46ht",
        "description": "wk18.d2.copy_of_cs46ht",
        "peekOfCode": "def djb2(self, key):\n    \"\"\"\n    DJB2 hash, 32-bit\n    \"\"\"\n    # Cast the key to a string and get bytes\n    str_key = str(key).encode()\n    # Start from an arbitrary large prime\n    hash_value = 5381\n    # Bit-shift and sum value for each character\n    for b in str_key:",
        "detail": "wk18.d2.copy_of_cs46ht",
        "documentation": {}
    },
    {
        "label": "hash_index",
        "kind": 2,
        "importPath": "wk18.d2.copy_of_cs46ht",
        "description": "wk18.d2.copy_of_cs46ht",
        "peekOfCode": "def hash_index(self, key):\n    \"\"\"\n    Take an arbitrary key and return a valid integer index\n    between within the storage capacity of the hash table.\n    \"\"\"\n    return self.djb2(key) % self.capacity\ndef put(self, key, value):\n    \"\"\"\n    Store the value with the given key.\n    \"\"\"",
        "detail": "wk18.d2.copy_of_cs46ht",
        "documentation": {}
    },
    {
        "label": "put",
        "kind": 2,
        "importPath": "wk18.d2.copy_of_cs46ht",
        "description": "wk18.d2.copy_of_cs46ht",
        "peekOfCode": "def put(self, key, value):\n    \"\"\"\n    Store the value with the given key.\n    \"\"\"\n    index = self.hash_index(key)\n    self.storage[index] = value\n    return\ndef delete(self, key):\n    \"\"\"\n    Remove the value stored with the given key.",
        "detail": "wk18.d2.copy_of_cs46ht",
        "documentation": {}
    },
    {
        "label": "delete",
        "kind": 2,
        "importPath": "wk18.d2.copy_of_cs46ht",
        "description": "wk18.d2.copy_of_cs46ht",
        "peekOfCode": "def delete(self, key):\n    \"\"\"\n    Remove the value stored with the given key.\n    \"\"\"\n    index = self.hash_index(key)\n    self.storage[index] = None\ndef get(self, key):\n# \"\"\"\n#     Retrieve the value stored with the given key.\n#     Returns None if the key is not found.",
        "detail": "wk18.d2.copy_of_cs46ht",
        "documentation": {}
    },
    {
        "label": "get",
        "kind": 2,
        "importPath": "wk18.d2.copy_of_cs46ht",
        "description": "wk18.d2.copy_of_cs46ht",
        "peekOfCode": "def get(self, key):\n# \"\"\"\n#     Retrieve the value stored with the given key.\n#     Returns None if the key is not found.\n#     \"\"\"\n    index = self.hash_index(key)\n    return self.storage[index]\n\"\"\"# CODE 7506\n# Demo\n\"\"\"",
        "detail": "wk18.d2.copy_of_cs46ht",
        "documentation": {}
    },
    {
        "label": "my_hash_number",
        "kind": 5,
        "importPath": "wk18.d2.copy_of_cs46ht",
        "description": "wk18.d2.copy_of_cs46ht",
        "peekOfCode": "my_hash_number = djb2(\"ABCD\")\nprint(my_hash_number)\nstorage = [None] * 10\n\"\"\"# CODE 7506\n\"\"\"\nclass HashTable:\n# \"\"\"\n# A hash table with `capacity` buckets\n# that accepts string keys\n# \"\"\"",
        "detail": "wk18.d2.copy_of_cs46ht",
        "documentation": {}
    },
    {
        "label": "storage",
        "kind": 5,
        "importPath": "wk18.d2.copy_of_cs46ht",
        "description": "wk18.d2.copy_of_cs46ht",
        "peekOfCode": "storage = [None] * 10\n\"\"\"# CODE 7506\n\"\"\"\nclass HashTable:\n# \"\"\"\n# A hash table with `capacity` buckets\n# that accepts string keys\n# \"\"\"\ndef __init__(self, capacity):\n    self.capacity = capacity  # Number of buckets in the hash table",
        "detail": "wk18.d2.copy_of_cs46ht",
        "documentation": {}
    },
    {
        "label": "hash_table",
        "kind": 5,
        "importPath": "wk18.d2.copy_of_cs46ht",
        "description": "wk18.d2.copy_of_cs46ht",
        "peekOfCode": "hash_table = MyHashTable();\nhash_table.put(\"a\", 1);\nhash_table.put(\"b\", 2);\nhash_table.get(\"a\");            // returns 1\nhash_table.get(\"c\");            // returns -1 (not found)\nhash_table.put(\"b\", 1);         // update the existing value\nhash_table.get(\"b\");            // returns 1\nhash_table.remove(\"b\");         // remove the mapping for 2\nhash_table.get(\"b\");            // returns -1 (not found)\n```",
        "detail": "wk18.d2.copy_of_cs46ht",
        "documentation": {}
    },
    {
        "label": "HashTable",
        "kind": 6,
        "importPath": "wk18.d2.cs46ht",
        "description": "wk18.d2.cs46ht",
        "peekOfCode": "class HashTable:\n# \"\"\"\n# A hash table with `capacity` buckets\n# that accepts string keys\n# \"\"\"\ndef __init__(self, capacity):\n    self.capacity = capacity  # Number of buckets in the hash table\n    self.storage = [None] * capacity\n    self.item_count = 0\ndef djb2(self, key):",
        "detail": "wk18.d2.cs46ht",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "wk18.d2.cs46ht",
        "description": "wk18.d2.cs46ht",
        "peekOfCode": "class ListNode:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.next = None\n\"\"\"\n4000    12       89\n[\"ABC\", 10]-->[\"CBA\", 100]-->[\"BAC\", 2342]-->[\"AAAB\", 400]-->None\n   ^\n   |",
        "detail": "wk18.d2.cs46ht",
        "documentation": {}
    },
    {
        "label": "MyHashTable",
        "kind": 6,
        "importPath": "wk18.d2.cs46ht",
        "description": "wk18.d2.cs46ht",
        "peekOfCode": "class MyHashTable:\n    def __init__(self):\n        # Your code here\n        self.capacity = 1000\n        self.size = 0\n        self.storage = [None] * self.capacity\n    # Your code here\n    def djb2(self, key):\n      \"\"\"\n      DJB2 hash, 32-bit",
        "detail": "wk18.d2.cs46ht",
        "documentation": {}
    },
    {
        "label": "my_hash",
        "kind": 2,
        "importPath": "wk18.d2.cs46ht",
        "description": "wk18.d2.cs46ht",
        "peekOfCode": "def my_hash(key):\n  sum = 0\n  for c in key:\n    sum += ord(c)\n  return sum\ndef my_hash2(key):\n  sum = 0\n  string_bytes = key.encode()\n  for b in string_bytes:\n    sum += b",
        "detail": "wk18.d2.cs46ht",
        "documentation": {}
    },
    {
        "label": "my_hash2",
        "kind": 2,
        "importPath": "wk18.d2.cs46ht",
        "description": "wk18.d2.cs46ht",
        "peekOfCode": "def my_hash2(key):\n  sum = 0\n  string_bytes = key.encode()\n  for b in string_bytes:\n    sum += b\n  return sum\n# print(my_hash(\"ABC\"))\n# print(my_hash2(\"ABC\"))\n# djb2\n# encode key",
        "detail": "wk18.d2.cs46ht",
        "documentation": {}
    },
    {
        "label": "djb2",
        "kind": 2,
        "importPath": "wk18.d2.cs46ht",
        "description": "wk18.d2.cs46ht",
        "peekOfCode": "def djb2(key):\n  str_key = str(key).encode()\n  hash_value = 5381\n  for b in str_key:\n    # shifted_value = hash_value << 5\n    # add_shift = shifted_value + hash_value\n    # total_hash = add_shift + b\n    # total_hash &= 0xffffffff # 0b11111111111111111111111111111111 32bits\n    # final_hash = total_hash & 0xffffffff\n    hash_value = ((hash_value << 5) + hash_value) + b",
        "detail": "wk18.d2.cs46ht",
        "documentation": {}
    },
    {
        "label": "djb2",
        "kind": 2,
        "importPath": "wk18.d2.cs46ht",
        "description": "wk18.d2.cs46ht",
        "peekOfCode": "def djb2(self, key):\n    \"\"\"\n    DJB2 hash, 32-bit\n    \"\"\"\n    # Cast the key to a string and get bytes\n    str_key = str(key).encode()\n    # Start from an arbitrary large prime\n    hash_value = 5381\n    # Bit-shift and sum value for each character\n    for b in str_key:",
        "detail": "wk18.d2.cs46ht",
        "documentation": {}
    },
    {
        "label": "hash_index",
        "kind": 2,
        "importPath": "wk18.d2.cs46ht",
        "description": "wk18.d2.cs46ht",
        "peekOfCode": "def hash_index(self, key):\n    \"\"\"\n    Take an arbitrary key and return a valid integer index\n    between within the storage capacity of the hash table.\n    \"\"\"\n    return self.djb2(key) % self.capacity\ndef put(self, key, value):\n    \"\"\"\n    Store the value with the given key.\n    \"\"\"",
        "detail": "wk18.d2.cs46ht",
        "documentation": {}
    },
    {
        "label": "put",
        "kind": 2,
        "importPath": "wk18.d2.cs46ht",
        "description": "wk18.d2.cs46ht",
        "peekOfCode": "def put(self, key, value):\n    \"\"\"\n    Store the value with the given key.\n    \"\"\"\n    index = self.hash_index(key)\n    self.storage[index] = value\n    return\ndef delete(self, key):\n    \"\"\"\n    Remove the value stored with the given key.",
        "detail": "wk18.d2.cs46ht",
        "documentation": {}
    },
    {
        "label": "delete",
        "kind": 2,
        "importPath": "wk18.d2.cs46ht",
        "description": "wk18.d2.cs46ht",
        "peekOfCode": "def delete(self, key):\n    \"\"\"\n    Remove the value stored with the given key.\n    \"\"\"\n    index = self.hash_index(key)\n    self.storage[index] = None\ndef get(self, key):\n# \"\"\"\n#     Retrieve the value stored with the given key.\n#     Returns None if the key is not found.",
        "detail": "wk18.d2.cs46ht",
        "documentation": {}
    },
    {
        "label": "get",
        "kind": 2,
        "importPath": "wk18.d2.cs46ht",
        "description": "wk18.d2.cs46ht",
        "peekOfCode": "def get(self, key):\n# \"\"\"\n#     Retrieve the value stored with the given key.\n#     Returns None if the key is not found.\n#     \"\"\"\n    index = self.hash_index(key)\n    return self.storage[index]\n\"\"\"# CODE 7506\n# Demo\n\"\"\"",
        "detail": "wk18.d2.cs46ht",
        "documentation": {}
    },
    {
        "label": "hash_index",
        "kind": 2,
        "importPath": "wk18.d2.cs46ht",
        "description": "wk18.d2.cs46ht",
        "peekOfCode": "def hash_index(self, key):\n      \"\"\"\n      Take an arbitrary key and return a valid integer index\n      between within the storage capacity of the hash table.\n      \"\"\"\n      return self.djb2(key) % self.capacity\n    def put(self, key, value):\n        # Your code here\n        index = self.hash_index(key)\n        if self.storage[index] == None:",
        "detail": "wk18.d2.cs46ht",
        "documentation": {}
    },
    {
        "label": "my_hash_number",
        "kind": 5,
        "importPath": "wk18.d2.cs46ht",
        "description": "wk18.d2.cs46ht",
        "peekOfCode": "my_hash_number = djb2(\"ABCD\")\nprint(my_hash_number)\nstorage = [None] * 10\n\"\"\"# CODE 7506\n\"\"\"\nclass HashTable:\n# \"\"\"\n# A hash table with `capacity` buckets\n# that accepts string keys\n# \"\"\"",
        "detail": "wk18.d2.cs46ht",
        "documentation": {}
    },
    {
        "label": "storage",
        "kind": 5,
        "importPath": "wk18.d2.cs46ht",
        "description": "wk18.d2.cs46ht",
        "peekOfCode": "storage = [None] * 10\n\"\"\"# CODE 7506\n\"\"\"\nclass HashTable:\n# \"\"\"\n# A hash table with `capacity` buckets\n# that accepts string keys\n# \"\"\"\ndef __init__(self, capacity):\n    self.capacity = capacity  # Number of buckets in the hash table",
        "detail": "wk18.d2.cs46ht",
        "documentation": {}
    },
    {
        "label": "hash_table",
        "kind": 5,
        "importPath": "wk18.d2.cs46ht",
        "description": "wk18.d2.cs46ht",
        "peekOfCode": "hash_table = MyHashTable();\nhash_table.put(\"a\", 1);\nhash_table.put(\"b\", 2);\nhash_table.get(\"a\");            // returns 1\nhash_table.get(\"c\");            // returns -1 (not found)\nhash_table.put(\"b\", 1);         // update the existing value\nhash_table.get(\"b\");            // returns 1\nhash_table.remove(\"b\");         // remove the mapping for 2\nhash_table.get(\"b\");            // returns -1 (not found)\n```",
        "detail": "wk18.d2.cs46ht",
        "documentation": {}
    },
    {
        "label": "most_frequent",
        "kind": 2,
        "importPath": "wk18.d2.demo",
        "description": "wk18.d2.demo",
        "peekOfCode": "def most_frequent(lst):\n    return max(set(lst), key=lst.count)",
        "detail": "wk18.d2.demo",
        "documentation": {}
    },
    {
        "label": "HashTableEntry",
        "kind": 6,
        "importPath": "wk18.d2.hash_tables_ii_cs47",
        "description": "wk18.d2.hash_tables_ii_cs47",
        "peekOfCode": "class HashTableEntry:\n    \"\"\"\n  Linked List hash table key/value pair\n  \"\"\"\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.next = None\n# Hash table can't have fewer than this many slots\n# MIN_CAPACITY = 8",
        "detail": "wk18.d2.hash_tables_ii_cs47",
        "documentation": {}
    },
    {
        "label": "HashTable",
        "kind": 6,
        "importPath": "wk18.d2.hash_tables_ii_cs47",
        "description": "wk18.d2.hash_tables_ii_cs47",
        "peekOfCode": "class HashTable:\n    \"\"\"\n  A hash table that with `capacity` buckets\n  that accepts string keys\n  Implement this.\n  \"\"\"\n    def __init__(self, capacity):\n        self.capacity = capacity  # Number of buckets in the hash table\n        self.storage = [None] * capacity\n        self.item_count = 0",
        "detail": "wk18.d2.hash_tables_ii_cs47",
        "documentation": {}
    },
    {
        "label": "djb2",
        "kind": 2,
        "importPath": "wk18.d2.hash_tables_ii_cs47",
        "description": "wk18.d2.hash_tables_ii_cs47",
        "peekOfCode": "def djb2(key):\n    \"\"\"\n  DJB2 hash, 32-bit\n  \"\"\"\n    # Cast the key to a string and get bytes\n    str_key = str(key).encode()\n    # Start from an arbitrary large prime\n    hash_value = 5381\n    # Bit-shift and sum value for each character\n    for b in str_key:",
        "detail": "wk18.d2.hash_tables_ii_cs47",
        "documentation": {}
    },
    {
        "label": "fnv1",
        "kind": 2,
        "importPath": "wk18.d2.hash_tables_ii_cs47",
        "description": "wk18.d2.hash_tables_ii_cs47",
        "peekOfCode": "def fnv1(key):\n    \"\"\"\n  FNV-1 hash, 64-bit\n  \"\"\"\n    # Cast the key to a string and get bytes\n    str_key = str(key).encode()\n    hash = 0x00000100000001B3  # FNV Prime\n    for b in str_key:\n        hash *= 0xCBF29CE484222325  # FNV Offset Basis\n        hash ^= b",
        "detail": "wk18.d2.hash_tables_ii_cs47",
        "documentation": {}
    },
    {
        "label": "top_k_frequent",
        "kind": 2,
        "importPath": "wk18.d2.hash_tables_ii_cs47",
        "description": "wk18.d2.hash_tables_ii_cs47",
        "peekOfCode": "def top_k_frequent(words, k):\n    \"\"\"\n  Input:\n  words -> List[str]\n  k -> int\n  Output:\n  List[str]\n  \"\"\"\n    # Your code here\n# Tests",
        "detail": "wk18.d2.hash_tables_ii_cs47",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": "wk18.d2.hash_tables_ii_cs47",
        "description": "wk18.d2.hash_tables_ii_cs47",
        "peekOfCode": "words = [\"lambda\", \"school\", \"rules\", \"lambda\", \"school\", \"rocks\"]\nk = 2\nOutput:\n[\"lambda\", \"school\"]\nExplanation:\n\"lambda\" and \"school\" are the two most frequent words.\n```\nExample 2:\n```plaintext\nInput:",
        "detail": "wk18.d2.hash_tables_ii_cs47",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": "wk18.d2.hash_tables_ii_cs47",
        "description": "wk18.d2.hash_tables_ii_cs47",
        "peekOfCode": "k = 2\nOutput:\n[\"lambda\", \"school\"]\nExplanation:\n\"lambda\" and \"school\" are the two most frequent words.\n```\nExample 2:\n```plaintext\nInput:\nwords = [\"the\", \"sky\", \"is\", \"cloudy\", \"the\", \"the\", \"the\", \"cloudy\", \"is\", \"is\"]",
        "detail": "wk18.d2.hash_tables_ii_cs47",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": "wk18.d2.hash_tables_ii_cs47",
        "description": "wk18.d2.hash_tables_ii_cs47",
        "peekOfCode": "words = [\"the\", \"sky\", \"is\", \"cloudy\", \"the\", \"the\", \"the\", \"cloudy\", \"is\", \"is\"]\nk = 4\nOutput:\n[\"the\", \"is\", \"cloudy\", \"sky\"]\nExplanation:\n\"the\", \"is\", \"cloudy\", and \"sky\" are the four most frequent words. The words\nare sorted from highest frequency to lowest.\n```\nNotes:\n- `k` is always valid: `1 <= k <= number of unique elements.",
        "detail": "wk18.d2.hash_tables_ii_cs47",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": "wk18.d2.hash_tables_ii_cs47",
        "description": "wk18.d2.hash_tables_ii_cs47",
        "peekOfCode": "k = 4\nOutput:\n[\"the\", \"is\", \"cloudy\", \"sky\"]\nExplanation:\n\"the\", \"is\", \"cloudy\", and \"sky\" are the four most frequent words. The words\nare sorted from highest frequency to lowest.\n```\nNotes:\n- `k` is always valid: `1 <= k <= number of unique elements.\n- words in the input list only contain lowercase letters.",
        "detail": "wk18.d2.hash_tables_ii_cs47",
        "documentation": {}
    },
    {
        "label": "freq",
        "kind": 5,
        "importPath": "wk18.d2.hash_tables_ii_cs47",
        "description": "wk18.d2.hash_tables_ii_cs47",
        "peekOfCode": "freq = {\"the\": 4, \"sky\": 1, \"is\": 3, \"cloudy\": 2} sort this based on the values\nres = [\"the\", \"is\", \"cloudy\", \"sky\"]\nres[:k]\n# get the freq of each word\n# sort the dictionary besed on keys (maybe use a lambda)\n# encapsulate this sorted dictionary inside another function to sort it alpha?\n# then slice the results to constrain to k\n\"\"\"\ndef top_k_frequent(words, k):\n    \"\"\"",
        "detail": "wk18.d2.hash_tables_ii_cs47",
        "documentation": {}
    },
    {
        "label": "res",
        "kind": 5,
        "importPath": "wk18.d2.hash_tables_ii_cs47",
        "description": "wk18.d2.hash_tables_ii_cs47",
        "peekOfCode": "res = [\"the\", \"is\", \"cloudy\", \"sky\"]\nres[:k]\n# get the freq of each word\n# sort the dictionary besed on keys (maybe use a lambda)\n# encapsulate this sorted dictionary inside another function to sort it alpha?\n# then slice the results to constrain to k\n\"\"\"\ndef top_k_frequent(words, k):\n    \"\"\"\n  Input:",
        "detail": "wk18.d2.hash_tables_ii_cs47",
        "documentation": {}
    },
    {
        "label": "top_k_frequent",
        "kind": 2,
        "importPath": "wk18.d2.most-frequent",
        "description": "wk18.d2.most-frequent",
        "peekOfCode": "def top_k_frequent(words, k):\n    \"\"\"\n  Input:\n  words -> List[str]\n  k -> int\n  Output:\n  List[str]\n  \"\"\"\n    frequency = {}\n    for word in words:",
        "detail": "wk18.d2.most-frequent",
        "documentation": {}
    },
    {
        "label": "helper",
        "kind": 2,
        "importPath": "wk18.d2.most-frequent",
        "description": "wk18.d2.most-frequent",
        "peekOfCode": "def helper(word):\n    return word\n# Tests\nprint(\n    top_k_frequent(\n        [\"the\", \"sky\", \"is\", \"cloudy\", \"the\", \"the\", \"the\", \"cloudy\", \"is\", \"is\"], 4\n    )\n)\nprint(top_k_frequent([\"lambda\", \"school\", \"rules\", \"lambda\", \"school\", \"rocks\"], 2))\n# # Output",
        "detail": "wk18.d2.most-frequent",
        "documentation": {}
    },
    {
        "label": "csBinaryToASCII",
        "kind": 2,
        "importPath": "wk18.d3.bin-2-ascii",
        "description": "wk18.d3.bin-2-ascii",
        "peekOfCode": "def csBinaryToASCII(binary):\n    string_blocks = (binary[i : i + 8] for i in range(0, len(binary), 8))\n    string = \"\".join(chr(int(char, 2)) for char in string_blocks)\n    return string\nprint(csBinaryToASCII(\"011011000110000101101101011000100110010001100001\"))",
        "detail": "wk18.d3.bin-2-ascii",
        "documentation": {}
    },
    {
        "label": "csRaindrops",
        "kind": 2,
        "importPath": "wk18.d3.cs-raindrops",
        "description": "wk18.d3.cs-raindrops",
        "peekOfCode": "def csRaindrops(number):\n    output = \"\"\n    if number % 3 == 0:\n        output += \"Pling\"\n    if number % 5 == 0:\n        output += \"Plang\"\n    if number % 7 == 0:\n        output += \"Plong\"\n    if output is \"\":\n        return str(number)",
        "detail": "wk18.d3.cs-raindrops",
        "documentation": {}
    },
    {
        "label": "csReverseIntegerBits",
        "kind": 2,
        "importPath": "wk18.d3.csReverseBits",
        "description": "wk18.d3.csReverseBits",
        "peekOfCode": "def csReverseIntegerBits(n):\n    rev = 0\n    # traversing bits of 'n' from the right\n    while n > 0:\n        # bitwise left shift 'rev' by 1\n        rev = rev << 1\n        # if current bit is '1'\n        if n & 1 == 1:\n            rev = rev ^ 1\n        # bitwise right shift 'n' by 1",
        "detail": "wk18.d3.csReverseBits",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "wk18.d3.csReverseBits",
        "description": "wk18.d3.csReverseBits",
        "peekOfCode": "n = 267\nprint(csReverseIntegerBits(n))",
        "detail": "wk18.d3.csReverseBits",
        "documentation": {}
    },
    {
        "label": "top_k_frequent",
        "kind": 2,
        "importPath": "wk18.d3.demo",
        "description": "wk18.d3.demo",
        "peekOfCode": "def top_k_frequent(words, k):\nwords = [\"the\", \"sky\", \"is\", \"cloudy\", \"the\", \"the\", \"the\", \"cloudy\", \"is\", \"is\"]",
        "detail": "wk18.d3.demo",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": "wk18.d3.demo",
        "description": "wk18.d3.demo",
        "peekOfCode": "words = [\"lambda\", \"school\", \"rules\", \"lambda\", \"school\", \"rocks\"]\nk = 2\nOutput:\n[\"lambda\", \"school\"]\nExplanation:\n\"lambda\" and \"school\" are the two most frequent words.\n```\nExample 2:\n```plaintext\nInput:",
        "detail": "wk18.d3.demo",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": "wk18.d3.demo",
        "description": "wk18.d3.demo",
        "peekOfCode": "k = 2\nOutput:\n[\"lambda\", \"school\"]\nExplanation:\n\"lambda\" and \"school\" are the two most frequent words.\n```\nExample 2:\n```plaintext\nInput:\nwords = [\"the\", \"sky\", \"is\", \"cloudy\", \"the\", \"the\", \"the\", \"cloudy\", \"is\", \"is\"]",
        "detail": "wk18.d3.demo",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": "wk18.d3.demo",
        "description": "wk18.d3.demo",
        "peekOfCode": "words = [\"the\", \"sky\", \"is\", \"cloudy\", \"the\", \"the\", \"the\", \"cloudy\", \"is\", \"is\"]\nk = 4\nOutput:\n[\"the\", \"is\", \"cloudy\", \"sky\"]\nExplanation:\n\"the\", \"is\", \"cloudy\", and \"sky\" are the four most frequent words. The words\nare sorted from highest frequency to lowest.\n```\nNotes:\n- `k` is always valid: `1 <= k <= number of unique elements.",
        "detail": "wk18.d3.demo",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": "wk18.d3.demo",
        "description": "wk18.d3.demo",
        "peekOfCode": "k = 4\nOutput:\n[\"the\", \"is\", \"cloudy\", \"sky\"]\nExplanation:\n\"the\", \"is\", \"cloudy\", and \"sky\" are the four most frequent words. The words\nare sorted from highest frequency to lowest.\n```\nNotes:\n- `k` is always valid: `1 <= k <= number of unique elements.\n- words in the input list only contain lowercase letters.",
        "detail": "wk18.d3.demo",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": "wk18.d3.demo",
        "description": "wk18.d3.demo",
        "peekOfCode": "words = [\"the\", \"sky\", \"is\", \"cloudy\", \"the\", \"the\", \"the\", \"cloudy\", \"is\", \"is\"]",
        "detail": "wk18.d3.demo",
        "documentation": {}
    },
    {
        "label": "HashTableEntry",
        "kind": 6,
        "importPath": "wk18.d3.ht2 (1)",
        "description": "wk18.d3.ht2 (1)",
        "peekOfCode": "class HashTableEntry:\n    \"\"\"\n    Linked List hash table key/value pair\n    \"\"\"\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.next = None\n# Hash table can't have fewer than this many slots\n# MIN_CAPACITY = 8",
        "detail": "wk18.d3.ht2 (1)",
        "documentation": {}
    },
    {
        "label": "HashTable",
        "kind": 6,
        "importPath": "wk18.d3.ht2 (1)",
        "description": "wk18.d3.ht2 (1)",
        "peekOfCode": "class HashTable:\n    \"\"\"\n    A hash table that with `capacity` buckets\n    that accepts string keys\n    Implement this.\n    \"\"\"\n    def __init__(self, capacity):\n        self.capacity = capacity  # Number of buckets in the hash table\n        self.storage = [None] * capacity\n        self.item_count = 0",
        "detail": "wk18.d3.ht2 (1)",
        "documentation": {}
    },
    {
        "label": "HashTableEntry",
        "kind": 6,
        "importPath": "wk18.d3.ht2",
        "description": "wk18.d3.ht2",
        "peekOfCode": "class HashTableEntry:\n    \"\"\"\n    Linked List hash table key/value pair\n    \"\"\"\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.next = None\n# Hash table can't have fewer than this many slots\n# MIN_CAPACITY = 8",
        "detail": "wk18.d3.ht2",
        "documentation": {}
    },
    {
        "label": "HashTable",
        "kind": 6,
        "importPath": "wk18.d3.ht2",
        "description": "wk18.d3.ht2",
        "peekOfCode": "class HashTable:\n    \"\"\"\n    A hash table that with `capacity` buckets\n    that accepts string keys\n    Implement this.\n    \"\"\"\n    def __init__(self, capacity):\n        self.capacity = capacity  # Number of buckets in the hash table\n        self.storage = [None] * capacity\n        self.item_count = 0",
        "detail": "wk18.d3.ht2",
        "documentation": {}
    },
    {
        "label": "top_k_frequent",
        "kind": 2,
        "importPath": "wk18.d3.ht2",
        "description": "wk18.d3.ht2",
        "peekOfCode": "def top_k_frequent(words, k):\n    \"\"\"\n    Input:\n    words -> List[str]\n    k -> int\n    Output:\n    List[str]\n    \"\"\"\n    # Your code here",
        "detail": "wk18.d3.ht2",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": "wk18.d3.ht2",
        "description": "wk18.d3.ht2",
        "peekOfCode": "words = [\"lambda\", \"school\", \"rules\", \"lambda\", \"school\", \"rocks\"]\nk = 2\nOutput:\n[\"lambda\", \"school\"]\nExplanation:\n\"lambda\" and \"school\" are the two most frequent words.\n```\nExample 2:\n```plaintext\nInput:",
        "detail": "wk18.d3.ht2",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": "wk18.d3.ht2",
        "description": "wk18.d3.ht2",
        "peekOfCode": "k = 2\nOutput:\n[\"lambda\", \"school\"]\nExplanation:\n\"lambda\" and \"school\" are the two most frequent words.\n```\nExample 2:\n```plaintext\nInput:\nwords = [\"the\", \"sky\", \"is\", \"cloudy\", \"the\", \"the\", \"the\", \"cloudy\", \"is\", \"is\"]",
        "detail": "wk18.d3.ht2",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": "wk18.d3.ht2",
        "description": "wk18.d3.ht2",
        "peekOfCode": "words = [\"the\", \"sky\", \"is\", \"cloudy\", \"the\", \"the\", \"the\", \"cloudy\", \"is\", \"is\"]\nk = 4\nOutput:\n[\"the\", \"is\", \"cloudy\", \"sky\"]\nExplanation:\n\"the\", \"is\", \"cloudy\", and \"sky\" are the four most frequent words. The words\nare sorted from highest frequency to lowest.\n```\nNotes:\n- `k` is always valid: `1 <= k <= number of unique elements.",
        "detail": "wk18.d3.ht2",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": "wk18.d3.ht2",
        "description": "wk18.d3.ht2",
        "peekOfCode": "k = 4\nOutput:\n[\"the\", \"is\", \"cloudy\", \"sky\"]\nExplanation:\n\"the\", \"is\", \"cloudy\", and \"sky\" are the four most frequent words. The words\nare sorted from highest frequency to lowest.\n```\nNotes:\n- `k` is always valid: `1 <= k <= number of unique elements.\n- words in the input list only contain lowercase letters.",
        "detail": "wk18.d3.ht2",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "wk18.d3.kthmost",
        "description": "wk18.d3.kthmost",
        "peekOfCode": "class Solution(object):\n    def topKFrequent(self, nums, k):\n        number_frequency = {}\n        frequency_list = {}\n        for i in nums:\n            if i not in number_frequency:\n                number_frequency[i] = 1\n            else:\n                number_frequency[i] += 1\n        for key, value in number_frequency.items():",
        "detail": "wk18.d3.kthmost",
        "documentation": {}
    },
    {
        "label": "ob1",
        "kind": 5,
        "importPath": "wk18.d3.kthmost",
        "description": "wk18.d3.kthmost",
        "peekOfCode": "ob1 = Solution()\nprint(ob1.topKFrequent([1, 1, 1, 1, 2, 2, 3, 3, 3], 2))",
        "detail": "wk18.d3.kthmost",
        "documentation": {}
    },
    {
        "label": "top_k_frequent",
        "kind": 2,
        "importPath": "wk18.d3.scrap",
        "description": "wk18.d3.scrap",
        "peekOfCode": "def top_k_frequent(words, k):\n    # Initializing a dictionary\n    d = dict()\n    # Iterating through the wordsay\n    for i in words:\n        # If the element is not in\n        # the dictionary, adding it\n        # with the frequency as 1\n        if i not in d:\n            d[i] = 1",
        "detail": "wk18.d3.scrap",
        "documentation": {}
    },
    {
        "label": "K",
        "kind": 5,
        "importPath": "wk18.d3.scrap",
        "description": "wk18.d3.scrap",
        "peekOfCode": "K = 3\nprint(top_k_frequent(words, K))",
        "detail": "wk18.d3.scrap",
        "documentation": {}
    },
    {
        "label": "top_k_frequent",
        "kind": 2,
        "importPath": "wk18.d3.scrap2",
        "description": "wk18.d3.scrap2",
        "peekOfCode": "def top_k_frequent(words, k):\n    d = dict()\n    for i in words:\n        if i not in d:\n            d[i] = 1\n        else:\n            temp = d[i]\n            temp += 1\n            d[i] = temp\n    if len(d) < k:",
        "detail": "wk18.d3.scrap2",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": "wk18.d3.scrap2",
        "description": "wk18.d3.scrap2",
        "peekOfCode": "k = 3\nprint(top_k_frequent(words, k))",
        "detail": "wk18.d3.scrap2",
        "documentation": {}
    },
    {
        "label": "linear_search",
        "kind": 2,
        "importPath": "wk18.d4.notes",
        "description": "wk18.d4.notes",
        "peekOfCode": "def linear_search(lst, target):  # O(n) Linear\n    for i in range(len(lst)):  # O(n)\n        if lst[i] == target:  # O(1)\n            return i  # O(1)\n    return -1  # O(1)\nl = [23, 34, 12, 3, 5654, 2, 13, 456]\nprint(linear_search(l, 9876))  # -1\n# Recursion\ndef n_times_loop(n):\n    # for i in range(n, 0, -1):",
        "detail": "wk18.d4.notes",
        "documentation": {}
    },
    {
        "label": "n_times_loop",
        "kind": 2,
        "importPath": "wk18.d4.notes",
        "description": "wk18.d4.notes",
        "peekOfCode": "def n_times_loop(n):\n    # for i in range(n, 0, -1):\n    #   print(i)\n    while True:\n        # base case\n        if n <= 0:\n            return\n        # do something\n        print(n)\n        n -= 1  # Decrement",
        "detail": "wk18.d4.notes",
        "documentation": {}
    },
    {
        "label": "n_times_recurse",
        "kind": 2,
        "importPath": "wk18.d4.notes",
        "description": "wk18.d4.notes",
        "peekOfCode": "def n_times_recurse(n):\n    # base case\n    if n <= 0:\n        return\n    # do something\n    print(n)\n    # recursive call (decrement)\n    n_times_recurse(n - 1)\nn = 5\nn_times_recurse(n)",
        "detail": "wk18.d4.notes",
        "documentation": {}
    },
    {
        "label": "binary_search",
        "kind": 2,
        "importPath": "wk18.d4.notes",
        "description": "wk18.d4.notes",
        "peekOfCode": "def binary_search(lst, target):\n    low = 0\n    high = len(lst) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if lst[mid] < target:\n            low = mid + 1\n        elif lst[mid] > target:\n            high = mid - 1\n        else:",
        "detail": "wk18.d4.notes",
        "documentation": {}
    },
    {
        "label": "l",
        "kind": 5,
        "importPath": "wk18.d4.notes",
        "description": "wk18.d4.notes",
        "peekOfCode": "l = [23, 34, 12, 3, 5654, 2, 13, 456]\nprint(linear_search(l, 9876))  # -1\n# Recursion\ndef n_times_loop(n):\n    # for i in range(n, 0, -1):\n    #   print(i)\n    while True:\n        # base case\n        if n <= 0:\n            return",
        "detail": "wk18.d4.notes",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "wk18.d4.notes",
        "description": "wk18.d4.notes",
        "peekOfCode": "n = 5\nn_times_loop(n)\nprint(\"------------------------------RECURSIVE----------------------------------\")\ndef n_times_recurse(n):\n    # base case\n    if n <= 0:\n        return\n    # do something\n    print(n)\n    # recursive call (decrement)",
        "detail": "wk18.d4.notes",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "wk18.d4.notes",
        "description": "wk18.d4.notes",
        "peekOfCode": "n = 5\nn_times_recurse(n)\nprint(\n    \"------------------------------Binary Search---------BigO (log(n))-------------------------\"\n)\nprint(\"------------------------------Requires Sorted Data...-------------------------\")\n# Binary Search\n# If the list is sorted, then the binary search algorithm will take O(log(n)) time.\ndef binary_search(lst, target):\n    low = 0",
        "detail": "wk18.d4.notes",
        "documentation": {}
    },
    {
        "label": "l",
        "kind": 5,
        "importPath": "wk18.d4.notes",
        "description": "wk18.d4.notes",
        "peekOfCode": "l = [1, 2, 3, 45, 67, 78, 98, 120, 200]\nprint(binary_search(l, 78))",
        "detail": "wk18.d4.notes",
        "documentation": {}
    },
    {
        "label": "get_fib",
        "kind": 2,
        "importPath": "wk18.d4.recursive_fib",
        "description": "wk18.d4.recursive_fib",
        "peekOfCode": "def get_fib(n):\n    result = 0\n    if n == 0:\n        return result\n    if n == 1:\n        return n\n    else:\n        result += get_fib(n - 1) + get_fib(n - 2)\n        return result\n# Test cases",
        "detail": "wk18.d4.recursive_fib",
        "documentation": {}
    },
    {
        "label": "linear_search",
        "kind": 2,
        "importPath": "wk18.d4.searching",
        "description": "wk18.d4.searching",
        "peekOfCode": "def linear_search(data, target):\n    for i in range(len(data)):\n        if data[i] == target:\n            return (i, data[i])\n    return -1\nprint(linear_search(data, target))\n\"\"\"\nSearching (Binary)\n\"\"\"\n# 0 (log(n))",
        "detail": "wk18.d4.searching",
        "documentation": {}
    },
    {
        "label": "binary_search",
        "kind": 2,
        "importPath": "wk18.d4.searching",
        "description": "wk18.d4.searching",
        "peekOfCode": "def binary_search(data, target):\n    begin = 0\n    end = len(data) - 1\n    while not end < begin:\n        guess_index = (end + begin) // 2\n        if data[guess_index] == target:\n            return (guess_index, target)\n        elif data[guess_index] < target:\n            begin = guess_index + 1\n        else:",
        "detail": "wk18.d4.searching",
        "documentation": {}
    },
    {
        "label": "while_rec",
        "kind": 2,
        "importPath": "wk18.d4.searching",
        "description": "wk18.d4.searching",
        "peekOfCode": "def while_rec(n):  # O(n)\n    if not n > 0:  # O(1)\n        return\n    print(n)  # O(1)\n    while_rec(n - 1)  # O(1)\nstart = time.time()\nwhile_rec(n)\nend = time.time()\nprint(f\"func runtime = {end - start}\")\n# memoization",
        "detail": "wk18.d4.searching",
        "documentation": {}
    },
    {
        "label": "memo_func",
        "kind": 2,
        "importPath": "wk18.d4.searching",
        "description": "wk18.d4.searching",
        "peekOfCode": "def memo_func(f):\n    cache = {}\n    def memo_helper(n):\n        if n not in cache:\n            cache[n] = f(n)\n        return cache[n]\n    return memo_helper\n\"\"\"\n[ 0, 1, 1, 2, 3, 5, 8]\nfib(n) => fib(n - 1) + fib(n - 2)",
        "detail": "wk18.d4.searching",
        "documentation": {}
    },
    {
        "label": "fib",
        "kind": 2,
        "importPath": "wk18.d4.searching",
        "description": "wk18.d4.searching",
        "peekOfCode": "def fib(n):\n    if n <= 1:\n        return n\n    else:\n        return fib(n - 1) + fib(n - 2)\n@lru_cache(maxsize=1000000)\ndef fib2(n):\n    if n <= 1:\n        return n\n    else:",
        "detail": "wk18.d4.searching",
        "documentation": {}
    },
    {
        "label": "fib2",
        "kind": 2,
        "importPath": "wk18.d4.searching",
        "description": "wk18.d4.searching",
        "peekOfCode": "def fib2(n):\n    if n <= 1:\n        return n\n    else:\n        return fib(n - 1) + fib(n - 2)\n# fib(46)\n# memfib = memo_func(fib)\n# memfib(46)\nfib(460)",
        "detail": "wk18.d4.searching",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "wk18.d4.searching",
        "description": "wk18.d4.searching",
        "peekOfCode": "data = [12, 23, 1, 34, 56, 100]\ntarget = 10\n# starting at the beginning of the data\n# take each value and compare that value to a target value\n# if they are equal return the index of the target value or return the target value\n# if we reach the end of the data, without finding the target then we can return -1\ndef linear_search(data, target):\n    for i in range(len(data)):\n        if data[i] == target:\n            return (i, data[i])",
        "detail": "wk18.d4.searching",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "wk18.d4.searching",
        "description": "wk18.d4.searching",
        "peekOfCode": "target = 10\n# starting at the beginning of the data\n# take each value and compare that value to a target value\n# if they are equal return the index of the target value or return the target value\n# if we reach the end of the data, without finding the target then we can return -1\ndef linear_search(data, target):\n    for i in range(len(data)):\n        if data[i] == target:\n            return (i, data[i])\n    return -1",
        "detail": "wk18.d4.searching",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "wk18.d4.searching",
        "description": "wk18.d4.searching",
        "peekOfCode": "data = [12, 23, 45, 67, 99, 200]\ntarget = 99\n# keep track of begin and end\n# while the begin and end do not overlap\n# create a guess index in the middle of the view of data\n# check if the data at the guess index is equal to the target\n# return (guess_index, guess)\n# otherwise is the data at the guess index less than the target\n# set the begin to the guess_index + 1\n# otherwise",
        "detail": "wk18.d4.searching",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "wk18.d4.searching",
        "description": "wk18.d4.searching",
        "peekOfCode": "target = 99\n# keep track of begin and end\n# while the begin and end do not overlap\n# create a guess index in the middle of the view of data\n# check if the data at the guess index is equal to the target\n# return (guess_index, guess)\n# otherwise is the data at the guess index less than the target\n# set the begin to the guess_index + 1\n# otherwise\n# set end to the guess_index - 1",
        "detail": "wk18.d4.searching",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "wk18.d4.searching",
        "description": "wk18.d4.searching",
        "peekOfCode": "n = 10\ns = []\nstart = time.time()\nwhile n > 0:  # O(n)\n    print(n)\n    n -= 1\nend = time.time()\nprint(f\"loop runtime = {end - start}\")\n\"\"\"\nRecursive Function",
        "detail": "wk18.d4.searching",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "wk18.d4.searching",
        "description": "wk18.d4.searching",
        "peekOfCode": "s = []\nstart = time.time()\nwhile n > 0:  # O(n)\n    print(n)\n    n -= 1\nend = time.time()\nprint(f\"loop runtime = {end - start}\")\n\"\"\"\nRecursive Function\n\"\"\"",
        "detail": "wk18.d4.searching",
        "documentation": {}
    },
    {
        "label": "start",
        "kind": 5,
        "importPath": "wk18.d4.searching",
        "description": "wk18.d4.searching",
        "peekOfCode": "start = time.time()\nwhile n > 0:  # O(n)\n    print(n)\n    n -= 1\nend = time.time()\nprint(f\"loop runtime = {end - start}\")\n\"\"\"\nRecursive Function\n\"\"\"\nimport time",
        "detail": "wk18.d4.searching",
        "documentation": {}
    },
    {
        "label": "end",
        "kind": 5,
        "importPath": "wk18.d4.searching",
        "description": "wk18.d4.searching",
        "peekOfCode": "end = time.time()\nprint(f\"loop runtime = {end - start}\")\n\"\"\"\nRecursive Function\n\"\"\"\nimport time\nn = 10\ndef while_rec(n):  # O(n)\n    if not n > 0:  # O(1)\n        return",
        "detail": "wk18.d4.searching",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "wk18.d4.searching",
        "description": "wk18.d4.searching",
        "peekOfCode": "n = 10\ndef while_rec(n):  # O(n)\n    if not n > 0:  # O(1)\n        return\n    print(n)  # O(1)\n    while_rec(n - 1)  # O(1)\nstart = time.time()\nwhile_rec(n)\nend = time.time()\nprint(f\"func runtime = {end - start}\")",
        "detail": "wk18.d4.searching",
        "documentation": {}
    },
    {
        "label": "start",
        "kind": 5,
        "importPath": "wk18.d4.searching",
        "description": "wk18.d4.searching",
        "peekOfCode": "start = time.time()\nwhile_rec(n)\nend = time.time()\nprint(f\"func runtime = {end - start}\")\n# memoization\n# generic memo_func\ndef memo_func(f):\n    cache = {}\n    def memo_helper(n):\n        if n not in cache:",
        "detail": "wk18.d4.searching",
        "documentation": {}
    },
    {
        "label": "end",
        "kind": 5,
        "importPath": "wk18.d4.searching",
        "description": "wk18.d4.searching",
        "peekOfCode": "end = time.time()\nprint(f\"func runtime = {end - start}\")\n# memoization\n# generic memo_func\ndef memo_func(f):\n    cache = {}\n    def memo_helper(n):\n        if n not in cache:\n            cache[n] = f(n)\n        return cache[n]",
        "detail": "wk18.d4.searching",
        "documentation": {}
    },
    {
        "label": "checkBlanagrams",
        "kind": 2,
        "importPath": "wk18.sprint-prep.blanagrams",
        "description": "wk18.sprint-prep.blanagrams",
        "peekOfCode": "def checkBlanagrams(word1, word2):\n    lenWord1 = len(word1)\n    lenWord2 = len(word2)\n    # To store the frequencies of characters\n    # of string word1 and word2\n    freq1 = [0] * 26\n    freq2 = [0] * 26\n    # To store the count of valid pairs\n    count = 0\n    # Update the frequencies of the characters of string word1",
        "detail": "wk18.sprint-prep.blanagrams",
        "documentation": {}
    },
    {
        "label": "languages",
        "kind": 5,
        "importPath": "wk18.sprint-prep.scrap",
        "description": "wk18.sprint-prep.scrap",
        "peekOfCode": "languages = [\"Java\", \"Python\", \"JavaScript\"]\nversions = [14, 3, 6]\nresult = zip(languages, versions)\nprint(list(result))",
        "detail": "wk18.sprint-prep.scrap",
        "documentation": {}
    },
    {
        "label": "versions",
        "kind": 5,
        "importPath": "wk18.sprint-prep.scrap",
        "description": "wk18.sprint-prep.scrap",
        "peekOfCode": "versions = [14, 3, 6]\nresult = zip(languages, versions)\nprint(list(result))",
        "detail": "wk18.sprint-prep.scrap",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "wk18.sprint-prep.scrap",
        "description": "wk18.sprint-prep.scrap",
        "peekOfCode": "result = zip(languages, versions)\nprint(list(result))",
        "detail": "wk18.sprint-prep.scrap",
        "documentation": {}
    },
    {
        "label": "binarySearch",
        "kind": 2,
        "importPath": "wk18.sprint-prep.sorted-scrap",
        "description": "wk18.sprint-prep.sorted-scrap",
        "peekOfCode": "def binarySearch(arr, key):\n    min = 0\n    max = len(arr) - 1\n    while not max < min:\n        guess = (max + min) // 2\n        if key == arr[guess]:\n            return arr[guess]\n        elif key > arr[guess]:\n            min = guess + 1\n        else:",
        "detail": "wk18.sprint-prep.sorted-scrap",
        "documentation": {}
    },
    {
        "label": "findValueSortedShiftedArray",
        "kind": 2,
        "importPath": "wk18.sprint-prep.sorted-scrap",
        "description": "wk18.sprint-prep.sorted-scrap",
        "peekOfCode": "def findValueSortedShiftedArray(nums, target):\n    pivot = 3\n    if nums[pivot] == target:\n        return pivot\n    if nums[pivot] >= target:\n        value = binarySearch(nums[pivot + 1 :], target)\n        print(value)\n        if value == target:\n            return nums.index(value)\n##-------------------------------------------------------------------------------------------",
        "detail": "wk18.sprint-prep.sorted-scrap",
        "documentation": {}
    },
    {
        "label": "nums1",
        "kind": 5,
        "importPath": "wk18.sprint-prep.sorted-scrap",
        "description": "wk18.sprint-prep.sorted-scrap",
        "peekOfCode": "nums1 = [4, 5, 6, 7, 0, 1, 2]\ntarget1 = 3\nprint(findValueSortedShiftedArray(nums1, target1))\nprint(\"---------------nums = [4,5,6,7,0,1,2], target = 3--------------------------\")\nprint(findValueSortedShiftedArray([4, 5, 6, 7, 0, 1, 2], 3))\nprint(\n    \"---------------nums = [1, 3, 5, 6]-------target = 5----------------------------------\"\n)\nnums = [1, 3, 5, 6]\ntarget = 5",
        "detail": "wk18.sprint-prep.sorted-scrap",
        "documentation": {}
    },
    {
        "label": "target1",
        "kind": 5,
        "importPath": "wk18.sprint-prep.sorted-scrap",
        "description": "wk18.sprint-prep.sorted-scrap",
        "peekOfCode": "target1 = 3\nprint(findValueSortedShiftedArray(nums1, target1))\nprint(\"---------------nums = [4,5,6,7,0,1,2], target = 3--------------------------\")\nprint(findValueSortedShiftedArray([4, 5, 6, 7, 0, 1, 2], 3))\nprint(\n    \"---------------nums = [1, 3, 5, 6]-------target = 5----------------------------------\"\n)\nnums = [1, 3, 5, 6]\ntarget = 5\nprint(findValueSortedShiftedArray(nums, target))",
        "detail": "wk18.sprint-prep.sorted-scrap",
        "documentation": {}
    },
    {
        "label": "print(\"---------------nums",
        "kind": 5,
        "importPath": "wk18.sprint-prep.sorted-scrap",
        "description": "wk18.sprint-prep.sorted-scrap",
        "peekOfCode": "print(\"---------------nums = [4,5,6,7,0,1,2], target = 3--------------------------\")\nprint(findValueSortedShiftedArray([4, 5, 6, 7, 0, 1, 2], 3))\nprint(\n    \"---------------nums = [1, 3, 5, 6]-------target = 5----------------------------------\"\n)\nnums = [1, 3, 5, 6]\ntarget = 5\nprint(findValueSortedShiftedArray(nums, target))",
        "detail": "wk18.sprint-prep.sorted-scrap",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": "wk18.sprint-prep.sorted-scrap",
        "description": "wk18.sprint-prep.sorted-scrap",
        "peekOfCode": "nums = [1, 3, 5, 6]\ntarget = 5\nprint(findValueSortedShiftedArray(nums, target))",
        "detail": "wk18.sprint-prep.sorted-scrap",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "wk18.sprint-prep.sorted-scrap",
        "description": "wk18.sprint-prep.sorted-scrap",
        "peekOfCode": "target = 5\nprint(findValueSortedShiftedArray(nums, target))",
        "detail": "wk18.sprint-prep.sorted-scrap",
        "documentation": {}
    },
    {
        "label": "searchInsert",
        "kind": 2,
        "importPath": "wk18.sprint-prep.sorted-scrap2",
        "description": "wk18.sprint-prep.sorted-scrap2",
        "peekOfCode": "def searchInsert(nums, target):\n    try:\n        return nums.index(target)\n    except IndexError:  # best to use explicit except\n        for index, value in enumerate(nums):  # more pythonic than range(len(nums))\n            if value > target:\n                return index\n        return len(nums)\nprint(searchInsert([1, 3, 5, 6], 10))",
        "detail": "wk18.sprint-prep.sorted-scrap2",
        "documentation": {}
    },
    {
        "label": "binarySearch",
        "kind": 2,
        "importPath": "wk18.sprint-prep.sortedShifted",
        "description": "wk18.sprint-prep.sortedShifted",
        "peekOfCode": "def binarySearch(arr, key):\n    min = 0\n    max = len(arr) - 1\n    while not max < min:\n        guess = (max + min) // 2\n        if key == arr[guess]:\n            return arr[guess]\n        elif key > arr[guess]:\n            min = guess + 1\n        else:",
        "detail": "wk18.sprint-prep.sortedShifted",
        "documentation": {}
    },
    {
        "label": "findValueSortedShiftedArray",
        "kind": 2,
        "importPath": "wk18.sprint-prep.sortedShifted",
        "description": "wk18.sprint-prep.sortedShifted",
        "peekOfCode": "def findValueSortedShiftedArray(nums, target):\n    pivot = 3\n    if nums[pivot] == target:\n        return pivot\n    if nums[pivot] >= target:\n        value = binarySearch(nums[pivot + 1 :], target)\n        print(value)\n        if value == target:\n            return nums.index(value)",
        "detail": "wk18.sprint-prep.sortedShifted",
        "documentation": {}
    },
    {
        "label": "checkBlanagrams",
        "kind": 2,
        "importPath": "wk18.sprint-prep.super-scrap",
        "description": "wk18.sprint-prep.super-scrap",
        "peekOfCode": "def checkBlanagrams(word1, word2):\n    lenWord1 = len(word1)\n    lenWord2 = len(word2)\n    freq1 = [0] * 26\n    freq2 = [0] * 26\n    count = 0\n    for i in range(lenWord1):\n        freq1[ord(word1[i]) - ord(\"a\")] += 1\n    for i in range(lenWord2):\n        freq2[ord(word2[i]) - ord(\"a\")] += 1",
        "detail": "wk18.sprint-prep.super-scrap",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "wk19.d1.hw.merge-ll.merge-ll",
        "description": "wk19.d1.hw.merge-ll.merge-ll",
        "peekOfCode": "class ListNode(object):\n  def __init__(self, x):\n    self.value = x\n    self.next = None\ndef mergeTwoLinkedLists(l1, l2):\n    em = None\n    if l1 is None:\n        return l2\n    if l2 is None:\n        return l1",
        "detail": "wk19.d1.hw.merge-ll.merge-ll",
        "documentation": {}
    },
    {
        "label": "mergeTwoLinkedLists",
        "kind": 2,
        "importPath": "wk19.d1.hw.merge-ll.merge-ll",
        "description": "wk19.d1.hw.merge-ll.merge-ll",
        "peekOfCode": "def mergeTwoLinkedLists(l1, l2):\n    em = None\n    if l1 is None:\n        return l2\n    if l2 is None:\n        return l1\n    if l1.value <= l2.value:\n        startNode = ListNode(l1.value)\n        l1 = l1.next\n    else:",
        "detail": "wk19.d1.hw.merge-ll.merge-ll",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "wk19.d1.hw.ref.script",
        "description": "wk19.d1.hw.ref.script",
        "peekOfCode": "class Node:\n    def __init__(self, data=None, next=None):\n        self.data = data\n        self.next = next\n# Helper function to print a given linked list\ndef printList(head):\n    ptr = head\n    while ptr:\n        print(ptr.data, end=\" —> \")\n        ptr = ptr.next",
        "detail": "wk19.d1.hw.ref.script",
        "documentation": {}
    },
    {
        "label": "printList",
        "kind": 2,
        "importPath": "wk19.d1.hw.ref.script",
        "description": "wk19.d1.hw.ref.script",
        "peekOfCode": "def printList(head):\n    ptr = head\n    while ptr:\n        print(ptr.data, end=\" —> \")\n        ptr = ptr.next\n    print(\"None\")\n# Function to insert a given node at its correct sorted position into\n# a given list sorted in increasing order\ndef sortedInsert(head, newNode):\n    # special case for the head end",
        "detail": "wk19.d1.hw.ref.script",
        "documentation": {}
    },
    {
        "label": "sortedInsert",
        "kind": 2,
        "importPath": "wk19.d1.hw.ref.script",
        "description": "wk19.d1.hw.ref.script",
        "peekOfCode": "def sortedInsert(head, newNode):\n    # special case for the head end\n    if head is None or head.data >= newNode.data:\n        newNode.next = head\n        head = newNode\n        return head\n    # Locate the node before the poof insertion\n    current = head\n    while current.next and current.next.data < newNode.data:\n        current = current.next",
        "detail": "wk19.d1.hw.ref.script",
        "documentation": {}
    },
    {
        "label": "csAlphanumericRestriction",
        "kind": 2,
        "importPath": "wk19.d1.hw.alpha",
        "description": "wk19.d1.hw.alpha",
        "peekOfCode": "def csAlphanumericRestriction(input_str): #c is every char in\ninput string\nis_numeric = False\nis_alpha = False\nfor c in input_str:\n% if c.isnumeric():\nis_numeric = True\nelif c.isalpha():\nis_alpha = True\nelse:",
        "detail": "wk19.d1.hw.alpha",
        "documentation": {}
    },
    {
        "label": "is_numeric",
        "kind": 5,
        "importPath": "wk19.d1.hw.alpha",
        "description": "wk19.d1.hw.alpha",
        "peekOfCode": "is_numeric = False\nis_alpha = False\nfor c in input_str:\n% if c.isnumeric():\nis_numeric = True\nelif c.isalpha():\nis_alpha = True\nelse:\n‘ return False\nreturn (is_numeric and not is_alpha) or (is_alpha and not",
        "detail": "wk19.d1.hw.alpha",
        "documentation": {}
    },
    {
        "label": "is_alpha",
        "kind": 5,
        "importPath": "wk19.d1.hw.alpha",
        "description": "wk19.d1.hw.alpha",
        "peekOfCode": "is_alpha = False\nfor c in input_str:\n% if c.isnumeric():\nis_numeric = True\nelif c.isalpha():\nis_alpha = True\nelse:\n‘ return False\nreturn (is_numeric and not is_alpha) or (is_alpha and not\nis_numeric)",
        "detail": "wk19.d1.hw.alpha",
        "documentation": {}
    },
    {
        "label": "is_numeric",
        "kind": 5,
        "importPath": "wk19.d1.hw.alpha",
        "description": "wk19.d1.hw.alpha",
        "peekOfCode": "is_numeric = True\nelif c.isalpha():\nis_alpha = True\nelse:\n‘ return False\nreturn (is_numeric and not is_alpha) or (is_alpha and not\nis_numeric)\nI",
        "detail": "wk19.d1.hw.alpha",
        "documentation": {}
    },
    {
        "label": "is_alpha",
        "kind": 5,
        "importPath": "wk19.d1.hw.alpha",
        "description": "wk19.d1.hw.alpha",
        "peekOfCode": "is_alpha = True\nelse:\n‘ return False\nreturn (is_numeric and not is_alpha) or (is_alpha and not\nis_numeric)\nI",
        "detail": "wk19.d1.hw.alpha",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "wk19.d1.hw.insertValueIntoSortedLinkedList",
        "description": "wk19.d1.hw.insertValueIntoSortedLinkedList",
        "peekOfCode": "class ListNode(object):  # def __init__(self, value):\n    def __init__(self, x):\n        self.value = x  # self.value = value\n        self.next = None  # self.next = None\ndef insertValueIntoSortedLinkedList(l, value):\n    head = l\n    new_item = ListNode(value)\n    if head is None:\n        new_item.next = head\n        head = new_item",
        "detail": "wk19.d1.hw.insertValueIntoSortedLinkedList",
        "documentation": {}
    },
    {
        "label": "insertValueIntoSortedLinkedList",
        "kind": 2,
        "importPath": "wk19.d1.hw.insertValueIntoSortedLinkedList",
        "description": "wk19.d1.hw.insertValueIntoSortedLinkedList",
        "peekOfCode": "def insertValueIntoSortedLinkedList(l, value):\n    head = l\n    new_item = ListNode(value)\n    if head is None:\n        new_item.next = head\n        head = new_item\n        return head\n    elif head.value >= new_item.value:\n        new_item.next = head\n        head = new_item",
        "detail": "wk19.d1.hw.insertValueIntoSortedLinkedList",
        "documentation": {}
    },
    {
        "label": "mergeTwoLinkedLists",
        "kind": 2,
        "importPath": "wk19.d1.hw.mergeTwoLinkedLists",
        "description": "wk19.d1.hw.mergeTwoLinkedLists",
        "peekOfCode": "def mergeTwoLinkedLists(l1, l2):\n    em = None\n    if l1 is None:\n        return l2\n    if l2 is None:\n        return l1\n    if l1.value <= l2.value:\n        startNode = ListNode(l1.value)\n        l1 = l1.next\n    else:",
        "detail": "wk19.d1.hw.mergeTwoLinkedLists",
        "documentation": {}
    },
    {
        "label": "l1",
        "kind": 5,
        "importPath": "wk19.d1.hw.mergeTwoLinkedLists",
        "description": "wk19.d1.hw.mergeTwoLinkedLists",
        "peekOfCode": "l1 = [1, 2, 3]\nl2 = [4, 5, 6]\nmergeTwoLinkedLists(l1, l2)  # should = [1, 2, 3, 4, 5, 6]",
        "detail": "wk19.d1.hw.mergeTwoLinkedLists",
        "documentation": {}
    },
    {
        "label": "l2",
        "kind": 5,
        "importPath": "wk19.d1.hw.mergeTwoLinkedLists",
        "description": "wk19.d1.hw.mergeTwoLinkedLists",
        "peekOfCode": "l2 = [4, 5, 6]\nmergeTwoLinkedLists(l1, l2)  # should = [1, 2, 3, 4, 5, 6]",
        "detail": "wk19.d1.hw.mergeTwoLinkedLists",
        "documentation": {}
    },
    {
        "label": "LinkedListNode",
        "kind": 6,
        "importPath": "wk19.d1.linked_lists",
        "description": "wk19.d1.linked_lists",
        "peekOfCode": "class LinkedListNode:\n  \"\"\"\n    Simple Singly Linked List Node Class\n    value -> int\n    next -> LinkedListNode\n  \"\"\"\n  def __init__(self, value):\n    self.value = value\n    self.next = None\n  def add_node(self, value):",
        "detail": "wk19.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "LinkedListNode",
        "kind": 6,
        "importPath": "wk19.d1.linked_lists",
        "description": "wk19.d1.linked_lists",
        "peekOfCode": "class LinkedListNode:\n  \"\"\"\n    Simple Doubly Linked List Node Class\n    value -> int\n    next -> LinkedListNode\n    prev -> LinkedListNode\n  \"\"\"\n  def __init__(self, value):\n    self.value = value\n    self.next = None",
        "detail": "wk19.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "LinkedListNode",
        "kind": 6,
        "importPath": "wk19.d1.linked_lists",
        "description": "wk19.d1.linked_lists",
        "peekOfCode": "class LinkedListNode():\n    def __init__(self, value):\n        self.value = value\n        self.next  = None\ndef reverse(head_of_list):\n  current = head_of_list\n  prev = None\n  next = None\n  while current:\n    next = current.next",
        "detail": "wk19.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "HashTableEntry",
        "kind": 6,
        "importPath": "wk19.d1.linked_lists",
        "description": "wk19.d1.linked_lists",
        "peekOfCode": "class HashTableEntry:\n    \"\"\"\n    Linked List hash table key/value pair\n    \"\"\"\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.next = None\n# Hash table can't have fewer than this many slots\nMIN_CAPACITY = 8",
        "detail": "wk19.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "HashTable",
        "kind": 6,
        "importPath": "wk19.d1.linked_lists",
        "description": "wk19.d1.linked_lists",
        "peekOfCode": "class HashTable:\n    \"\"\"\n    A hash table that with `capacity` buckets\n    that accepts string keys\n    Implement this.\n    \"\"\"\n    def __init__(self, capacity):\n                self.capacity = capacity  # Number of buckets in the hash table\n        self.storage = [None] * capacity\n        self.item_count = 0",
        "detail": "wk19.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "print_ll",
        "kind": 2,
        "importPath": "wk19.d1.linked_lists",
        "description": "wk19.d1.linked_lists",
        "peekOfCode": "def print_ll(linked_list_node):\n  current = linked_list_node\n  while current is not None:\n    print(current.value)\n    current = current.next\ndef add_to_ll_storage(linked_list_node):\n  current = linked_list_node\n  while current is not None:\n    ll_storage.append(current)\n    current = current.next",
        "detail": "wk19.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "add_to_ll_storage",
        "kind": 2,
        "importPath": "wk19.d1.linked_lists",
        "description": "wk19.d1.linked_lists",
        "peekOfCode": "def add_to_ll_storage(linked_list_node):\n  current = linked_list_node\n  while current is not None:\n    ll_storage.append(current)\n    current = current.next\nL1.add_node(12)\nprint_ll(L1)\nL1.add_node(24)\nprint()\nprint_ll(L1)",
        "detail": "wk19.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "reverse",
        "kind": 2,
        "importPath": "wk19.d1.linked_lists",
        "description": "wk19.d1.linked_lists",
        "peekOfCode": "def reverse(head_of_list):\n  current = head_of_list\n  prev = None\n  next = None\n  while current:\n    next = current.next\n    current.next = prev\n    prev = current\n    current = next\n  return prev",
        "detail": "wk19.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "L1",
        "kind": 5,
        "importPath": "wk19.d1.linked_lists",
        "description": "wk19.d1.linked_lists",
        "peekOfCode": "L1 = Node(34)\nL1.next = Node(45)\nL1.next.next = Node(90)\n# while the current node is not none\n  # do something with the data\n  # traverse to next node\nL1 = [34]-> [45]-> [90] -> None\nNode(45)\nNode(90)\n```",
        "detail": "wk19.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "L1.next",
        "kind": 5,
        "importPath": "wk19.d1.linked_lists",
        "description": "wk19.d1.linked_lists",
        "peekOfCode": "L1.next = Node(45)\nL1.next.next = Node(90)\n# while the current node is not none\n  # do something with the data\n  # traverse to next node\nL1 = [34]-> [45]-> [90] -> None\nNode(45)\nNode(90)\n```\n\"\"\"",
        "detail": "wk19.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "L1.next.next",
        "kind": 5,
        "importPath": "wk19.d1.linked_lists",
        "description": "wk19.d1.linked_lists",
        "peekOfCode": "L1.next.next = Node(90)\n# while the current node is not none\n  # do something with the data\n  # traverse to next node\nL1 = [34]-> [45]-> [90] -> None\nNode(45)\nNode(90)\n```\n\"\"\"\nclass LinkedListNode:",
        "detail": "wk19.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "L1",
        "kind": 5,
        "importPath": "wk19.d1.linked_lists",
        "description": "wk19.d1.linked_lists",
        "peekOfCode": "L1 = [34]-> [45]-> [90] -> None\nNode(45)\nNode(90)\n```\n\"\"\"\nclass LinkedListNode:\n  \"\"\"\n    Simple Singly Linked List Node Class\n    value -> int\n    next -> LinkedListNode",
        "detail": "wk19.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "ll_storage",
        "kind": 5,
        "importPath": "wk19.d1.linked_lists",
        "description": "wk19.d1.linked_lists",
        "peekOfCode": "ll_storage = []\nL1 = LinkedListNode(34)\nL1.next = LinkedListNode(45)\nL1.next.next = LinkedListNode(90)\ndef print_ll(linked_list_node):\n  current = linked_list_node\n  while current is not None:\n    print(current.value)\n    current = current.next\ndef add_to_ll_storage(linked_list_node):",
        "detail": "wk19.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "L1",
        "kind": 5,
        "importPath": "wk19.d1.linked_lists",
        "description": "wk19.d1.linked_lists",
        "peekOfCode": "L1 = LinkedListNode(34)\nL1.next = LinkedListNode(45)\nL1.next.next = LinkedListNode(90)\ndef print_ll(linked_list_node):\n  current = linked_list_node\n  while current is not None:\n    print(current.value)\n    current = current.next\ndef add_to_ll_storage(linked_list_node):\n  current = linked_list_node",
        "detail": "wk19.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "L1.next",
        "kind": 5,
        "importPath": "wk19.d1.linked_lists",
        "description": "wk19.d1.linked_lists",
        "peekOfCode": "L1.next = LinkedListNode(45)\nL1.next.next = LinkedListNode(90)\ndef print_ll(linked_list_node):\n  current = linked_list_node\n  while current is not None:\n    print(current.value)\n    current = current.next\ndef add_to_ll_storage(linked_list_node):\n  current = linked_list_node\n  while current is not None:",
        "detail": "wk19.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "L1.next.next",
        "kind": 5,
        "importPath": "wk19.d1.linked_lists",
        "description": "wk19.d1.linked_lists",
        "peekOfCode": "L1.next.next = LinkedListNode(90)\ndef print_ll(linked_list_node):\n  current = linked_list_node\n  while current is not None:\n    print(current.value)\n    current = current.next\ndef add_to_ll_storage(linked_list_node):\n  current = linked_list_node\n  while current is not None:\n    ll_storage.append(current)",
        "detail": "wk19.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "MIN_CAPACITY",
        "kind": 5,
        "importPath": "wk19.d1.linked_lists",
        "description": "wk19.d1.linked_lists",
        "peekOfCode": "MIN_CAPACITY = 8\n[\n 0[\"Lou\", 41] -> [\"Bob\", 41] -> None,\n 1[\"Steve\", 41] -> None,\n 2[\"Jen\", 41] -> None,\n 3[\"Dave\", 41] -> None,\n 4None,\n 5[\"Hector\", 34]-> None,\n 6[\"Lisa\", 41] -> None,\n 7None,",
        "detail": "wk19.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": "wk19.d2.notes.qandstack",
        "description": "wk19.d2.notes.qandstack",
        "peekOfCode": "class Stack:\n  def __init__(self):\n    self.storage = []\n  def push(self, item):\n    \"\"\"\n    push the item on to the top of the stack\n    \"\"\"\n    self.storage.append(item)\n  def pop(self):\n    \"\"\"",
        "detail": "wk19.d2.notes.qandstack",
        "documentation": {}
    },
    {
        "label": "Queue",
        "kind": 6,
        "importPath": "wk19.d2.notes.qandstack",
        "description": "wk19.d2.notes.qandstack",
        "peekOfCode": "class Queue:\n    def __init__(self):\n        self.storage = []\n    def enqueue(self, item):\n        self.storage.append(item)\n    def pop(self):\n        if len(self.storage) > 0:\n            return self.storage.pop()\n        return \"The Stack is Empty\"\nclass Stack:",
        "detail": "wk19.d2.notes.qandstack",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": "wk19.d2.notes.qandstack",
        "description": "wk19.d2.notes.qandstack",
        "peekOfCode": "class Stack:\n    def __init__(self):\n        self.items = []\n    def push(self, item):\n        self.items.append(item)\n    def pop(self):\n        if not self.items:\n            return None\n        return self.items.pop()\n    def peek(self):",
        "detail": "wk19.d2.notes.qandstack",
        "documentation": {}
    },
    {
        "label": "MaxStack",
        "kind": 6,
        "importPath": "wk19.d2.notes.qandstack",
        "description": "wk19.d2.notes.qandstack",
        "peekOfCode": "class MaxStack:\n    def __init__(self):\n    def push(self, item):\n    def pop(self):\n    def get_max(self):\nclass Stack:\n    def __init__(self):\n        self.data = []\n    def push(self, item):\n        self.data.append(item)",
        "detail": "wk19.d2.notes.qandstack",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": "wk19.d2.notes.qandstack",
        "description": "wk19.d2.notes.qandstack",
        "peekOfCode": "class Stack:\n    def __init__(self):\n        self.data = []\n    def push(self, item):\n        self.data.append(item)\n    def pop(self):\n        if len(self.data) > 0:\n            return self.data.pop()\n        return \"The stack is empty\"\nclass QueueTwoStacks:",
        "detail": "wk19.d2.notes.qandstack",
        "documentation": {}
    },
    {
        "label": "QueueTwoStacks",
        "kind": 6,
        "importPath": "wk19.d2.notes.qandstack",
        "description": "wk19.d2.notes.qandstack",
        "peekOfCode": "class QueueTwoStacks:\n    def __init__(self):\n    def enqueue(self, item):\n    def dequeue(self):",
        "detail": "wk19.d2.notes.qandstack",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "wk19.d2.notes.qandstack",
        "description": "wk19.d2.notes.qandstack",
        "peekOfCode": "s = Stack()\ns.push(10)\ns.push(20)\ns.push(30)\nl = []\nl.append(s.pop())\nl.append(s.pop())\nl.append(s.pop())\nprint(l)\nclass Queue:",
        "detail": "wk19.d2.notes.qandstack",
        "documentation": {}
    },
    {
        "label": "l",
        "kind": 5,
        "importPath": "wk19.d2.notes.qandstack",
        "description": "wk19.d2.notes.qandstack",
        "peekOfCode": "l = []\nl.append(s.pop())\nl.append(s.pop())\nl.append(s.pop())\nprint(l)\nclass Queue:\n    def __init__(self):\n        self.storage = []\n    def enqueue(self, item):\n        self.storage.append(item)",
        "detail": "wk19.d2.notes.qandstack",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": "wk19.d2.qandstack (1)",
        "description": "wk19.d2.qandstack (1)",
        "peekOfCode": "class Stack:\n    def __init__(self):\n        self.storage = []\n    def push(self, item):\n        \"\"\"\n    push the item on to the top of the stack\n    \"\"\"\n        self.storage.append(item)\n    def pop(self):\n        \"\"\"",
        "detail": "wk19.d2.qandstack (1)",
        "documentation": {}
    },
    {
        "label": "Queue",
        "kind": 6,
        "importPath": "wk19.d2.qandstack (1)",
        "description": "wk19.d2.qandstack (1)",
        "peekOfCode": "class Queue:\n    def __init__(self):\n        self.storage = []\n    def enqueue(self, item):\n        \"\"\"\n    enqueues the item in to the queue\n    \"\"\"\n        self.storage.append(item)\n    def dequeue(self):\n        \"\"\"",
        "detail": "wk19.d2.qandstack (1)",
        "documentation": {}
    },
    {
        "label": "LLNode",
        "kind": 6,
        "importPath": "wk19.d2.qandstack (1)",
        "description": "wk19.d2.qandstack (1)",
        "peekOfCode": "class LLNode:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n    def __repr__(self):\n        return f\"[{self.data}]\"\nclass LLQueue:\n    def __init__(self):\n        self.front = None\n        self.rear = None",
        "detail": "wk19.d2.qandstack (1)",
        "documentation": {}
    },
    {
        "label": "LLQueue",
        "kind": 6,
        "importPath": "wk19.d2.qandstack (1)",
        "description": "wk19.d2.qandstack (1)",
        "peekOfCode": "class LLQueue:\n    def __init__(self):\n        self.front = None\n        self.rear = None\n    def enqueue(self, item):\n        new_node = LLNode(item)\n        if self.rear is None:\n            self.front = new_node\n            self.rear = new_node\n        else:",
        "detail": "wk19.d2.qandstack (1)",
        "documentation": {}
    },
    {
        "label": "LLNode",
        "kind": 6,
        "importPath": "wk19.d2.qandstack (1)",
        "description": "wk19.d2.qandstack (1)",
        "peekOfCode": "class LLNode:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n    def __repr__(self):\n        return f\"[{self.data}]\"\nclass LLStack:\n    def __init__(self):\n        self.top = None\n    def push(self, data):",
        "detail": "wk19.d2.qandstack (1)",
        "documentation": {}
    },
    {
        "label": "LLStack",
        "kind": 6,
        "importPath": "wk19.d2.qandstack (1)",
        "description": "wk19.d2.qandstack (1)",
        "peekOfCode": "class LLStack:\n    def __init__(self):\n        self.top = None\n    def push(self, data):\n        new_node = LLNode(data)\n        new_node.next = self.top\n        self.top = new_node\n    def pop(self):\n        if self.top is not None:\n            poped_node = self.top",
        "detail": "wk19.d2.qandstack (1)",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": "wk19.d2.qandstack (1)",
        "description": "wk19.d2.qandstack (1)",
        "peekOfCode": "class Stack:\n    def __init__(self):\n        \"\"\"Initialize an empty stack\"\"\"\n        self.items = []\n    def push(self, item):\n        \"\"\"Push a new item onto the stack\"\"\"\n        self.items.append(item)\n    def pop(self):\n        \"\"\"Remove and return the last item\"\"\"\n        # If the stack is empty, return None",
        "detail": "wk19.d2.qandstack (1)",
        "documentation": {}
    },
    {
        "label": "MaxStack",
        "kind": 6,
        "importPath": "wk19.d2.qandstack (1)",
        "description": "wk19.d2.qandstack (1)",
        "peekOfCode": "class MaxStack:\n    def __init__(self):\n        # Your code here\n        self.stack = Stack()\n        self.maxes_stack = Stack()\n    def push(self, item):\n        \"\"\"Add a new item onto the top of our stack.\"\"\"\n        # Your code here\n        self.stack.push(item)\n        if self.maxes_stack.peek() is None or item >= self.maxes_stack.peek():",
        "detail": "wk19.d2.qandstack (1)",
        "documentation": {}
    },
    {
        "label": "Song",
        "kind": 6,
        "importPath": "wk19.d2.qandstack (1)",
        "description": "wk19.d2.qandstack (1)",
        "peekOfCode": "class Song:\n    def __init__(self, name, link):\n        self.name = name\n        self.link = link\n    def __repr__(self):\n        return f\"{self.name}: {self.link}\"\ns1 = Song(\"Bob The Builder\", \"http://www.gogle.co.uk/\")\ns2 = Song(\"Eclipse - Pink Floyd 1\", \"http://www.yashoo.com\")\ns3 = Song(\"Bob The Builder 2\", \"http://www.gogle.co.uk/\")\ns4 = Song(\"Eclipse - Pink Floyd 2\", \"http://www.yashoo.com\")",
        "detail": "wk19.d2.qandstack (1)",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": "wk19.d2.qandstack (1)",
        "description": "wk19.d2.qandstack (1)",
        "peekOfCode": "class Stack:\n    def __init__(self):\n        self.data = []\n    def push(self, item):\n        self.data.append(item)\n    def pop(self):\n        if len(self.data) > 0:\n            return self.data.pop()\n        return \"The stack is empty\"\nclass QueueTwoStacks:",
        "detail": "wk19.d2.qandstack (1)",
        "documentation": {}
    },
    {
        "label": "QueueTwoStacks",
        "kind": 6,
        "importPath": "wk19.d2.qandstack (1)",
        "description": "wk19.d2.qandstack (1)",
        "peekOfCode": "class QueueTwoStacks:\n    def __init__(self):\n        # Your code here\n        self.in_stack = Stack()\n        self.out_stack = Stack()\n    def enqueue(self, item):\n        # Your code here\n        self.in_stack.push(item)\n    def dequeue(self):\n        # Your code here",
        "detail": "wk19.d2.qandstack (1)",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "wk19.d2.qandstack (1)",
        "description": "wk19.d2.qandstack (1)",
        "peekOfCode": "s = Stack()\ns.push(10)\ns.push(20)\ns.push(30)\nl = []\nl.append(s.pop())\nl.append(s.pop())\nl.append(s.pop())\nprint(l)\n# lets write a simple queue",
        "detail": "wk19.d2.qandstack (1)",
        "documentation": {}
    },
    {
        "label": "l",
        "kind": 5,
        "importPath": "wk19.d2.qandstack (1)",
        "description": "wk19.d2.qandstack (1)",
        "peekOfCode": "l = []\nl.append(s.pop())\nl.append(s.pop())\nl.append(s.pop())\nprint(l)\n# lets write a simple queue\nclass Queue:\n    def __init__(self):\n        self.storage = []\n    def enqueue(self, item):",
        "detail": "wk19.d2.qandstack (1)",
        "documentation": {}
    },
    {
        "label": "q",
        "kind": 5,
        "importPath": "wk19.d2.qandstack (1)",
        "description": "wk19.d2.qandstack (1)",
        "peekOfCode": "q = Queue()\nq.enqueue(10)\nq.enqueue(20)\nq.enqueue(30)\nl2 = []\nl2.append(q.dequeue())\nl2.append(q.dequeue())\nl2.append(q.dequeue())\nprint(l2)\n# lets write a more performant queue",
        "detail": "wk19.d2.qandstack (1)",
        "documentation": {}
    },
    {
        "label": "l2",
        "kind": 5,
        "importPath": "wk19.d2.qandstack (1)",
        "description": "wk19.d2.qandstack (1)",
        "peekOfCode": "l2 = []\nl2.append(q.dequeue())\nl2.append(q.dequeue())\nl2.append(q.dequeue())\nprint(l2)\n# lets write a more performant queue\n\"\"\"\n  F      R\n[10]-> [20]-> None\n\"\"\"",
        "detail": "wk19.d2.qandstack (1)",
        "documentation": {}
    },
    {
        "label": "q",
        "kind": 5,
        "importPath": "wk19.d2.qandstack (1)",
        "description": "wk19.d2.qandstack (1)",
        "peekOfCode": "q = LLQueue()\nq.enqueue(10)\nq.enqueue(20)\nq.enqueue(30)\nl2 = []\nl2.append(q.dequeue())\nl2.append(q.dequeue())\nl2.append(q.dequeue())\nl2.append(q.dequeue())\nprint(l2)",
        "detail": "wk19.d2.qandstack (1)",
        "documentation": {}
    },
    {
        "label": "l2",
        "kind": 5,
        "importPath": "wk19.d2.qandstack (1)",
        "description": "wk19.d2.qandstack (1)",
        "peekOfCode": "l2 = []\nl2.append(q.dequeue())\nl2.append(q.dequeue())\nl2.append(q.dequeue())\nl2.append(q.dequeue())\nprint(l2)\n\"\"\"# Break\n# CODE 8119\n\"\"\"\n# lets write a more performant stack",
        "detail": "wk19.d2.qandstack (1)",
        "documentation": {}
    },
    {
        "label": "ms",
        "kind": 5,
        "importPath": "wk19.d2.qandstack (1)",
        "description": "wk19.d2.qandstack (1)",
        "peekOfCode": "ms = MaxStack()\nms.push(20)\nms.push(30)\nms.push(9)\nms.push(102)\nms.push(33)\nms.push(1)\nms.pop()\nms.pop()\nms.pop()",
        "detail": "wk19.d2.qandstack (1)",
        "documentation": {}
    },
    {
        "label": "s1",
        "kind": 5,
        "importPath": "wk19.d2.qandstack (1)",
        "description": "wk19.d2.qandstack (1)",
        "peekOfCode": "s1 = Song(\"Bob The Builder\", \"http://www.gogle.co.uk/\")\ns2 = Song(\"Eclipse - Pink Floyd 1\", \"http://www.yashoo.com\")\ns3 = Song(\"Bob The Builder 2\", \"http://www.gogle.co.uk/\")\ns4 = Song(\"Eclipse - Pink Floyd 2\", \"http://www.yashoo.com\")\ns5 = Song(\"Bob The Builder 3\", \"http://www.gogle.co.uk/\")\ns6 = Song(\"Eclipse - Pink Floyd 3\", \"http://www.yashoo.com\")\ns7 = Song(\"Bob The Builder\", \"http://www.gogle.co.uk/\")\ns8 = Song(\"Eclipse - Pink Floyd Uncut\", \"http://www.yashoo.com\")\nclass Stack:\n    def __init__(self):",
        "detail": "wk19.d2.qandstack (1)",
        "documentation": {}
    },
    {
        "label": "s2",
        "kind": 5,
        "importPath": "wk19.d2.qandstack (1)",
        "description": "wk19.d2.qandstack (1)",
        "peekOfCode": "s2 = Song(\"Eclipse - Pink Floyd 1\", \"http://www.yashoo.com\")\ns3 = Song(\"Bob The Builder 2\", \"http://www.gogle.co.uk/\")\ns4 = Song(\"Eclipse - Pink Floyd 2\", \"http://www.yashoo.com\")\ns5 = Song(\"Bob The Builder 3\", \"http://www.gogle.co.uk/\")\ns6 = Song(\"Eclipse - Pink Floyd 3\", \"http://www.yashoo.com\")\ns7 = Song(\"Bob The Builder\", \"http://www.gogle.co.uk/\")\ns8 = Song(\"Eclipse - Pink Floyd Uncut\", \"http://www.yashoo.com\")\nclass Stack:\n    def __init__(self):\n        self.data = []",
        "detail": "wk19.d2.qandstack (1)",
        "documentation": {}
    },
    {
        "label": "s3",
        "kind": 5,
        "importPath": "wk19.d2.qandstack (1)",
        "description": "wk19.d2.qandstack (1)",
        "peekOfCode": "s3 = Song(\"Bob The Builder 2\", \"http://www.gogle.co.uk/\")\ns4 = Song(\"Eclipse - Pink Floyd 2\", \"http://www.yashoo.com\")\ns5 = Song(\"Bob The Builder 3\", \"http://www.gogle.co.uk/\")\ns6 = Song(\"Eclipse - Pink Floyd 3\", \"http://www.yashoo.com\")\ns7 = Song(\"Bob The Builder\", \"http://www.gogle.co.uk/\")\ns8 = Song(\"Eclipse - Pink Floyd Uncut\", \"http://www.yashoo.com\")\nclass Stack:\n    def __init__(self):\n        self.data = []\n    def push(self, item):",
        "detail": "wk19.d2.qandstack (1)",
        "documentation": {}
    },
    {
        "label": "s4",
        "kind": 5,
        "importPath": "wk19.d2.qandstack (1)",
        "description": "wk19.d2.qandstack (1)",
        "peekOfCode": "s4 = Song(\"Eclipse - Pink Floyd 2\", \"http://www.yashoo.com\")\ns5 = Song(\"Bob The Builder 3\", \"http://www.gogle.co.uk/\")\ns6 = Song(\"Eclipse - Pink Floyd 3\", \"http://www.yashoo.com\")\ns7 = Song(\"Bob The Builder\", \"http://www.gogle.co.uk/\")\ns8 = Song(\"Eclipse - Pink Floyd Uncut\", \"http://www.yashoo.com\")\nclass Stack:\n    def __init__(self):\n        self.data = []\n    def push(self, item):\n        self.data.append(item)",
        "detail": "wk19.d2.qandstack (1)",
        "documentation": {}
    },
    {
        "label": "s5",
        "kind": 5,
        "importPath": "wk19.d2.qandstack (1)",
        "description": "wk19.d2.qandstack (1)",
        "peekOfCode": "s5 = Song(\"Bob The Builder 3\", \"http://www.gogle.co.uk/\")\ns6 = Song(\"Eclipse - Pink Floyd 3\", \"http://www.yashoo.com\")\ns7 = Song(\"Bob The Builder\", \"http://www.gogle.co.uk/\")\ns8 = Song(\"Eclipse - Pink Floyd Uncut\", \"http://www.yashoo.com\")\nclass Stack:\n    def __init__(self):\n        self.data = []\n    def push(self, item):\n        self.data.append(item)\n    def pop(self):",
        "detail": "wk19.d2.qandstack (1)",
        "documentation": {}
    },
    {
        "label": "s6",
        "kind": 5,
        "importPath": "wk19.d2.qandstack (1)",
        "description": "wk19.d2.qandstack (1)",
        "peekOfCode": "s6 = Song(\"Eclipse - Pink Floyd 3\", \"http://www.yashoo.com\")\ns7 = Song(\"Bob The Builder\", \"http://www.gogle.co.uk/\")\ns8 = Song(\"Eclipse - Pink Floyd Uncut\", \"http://www.yashoo.com\")\nclass Stack:\n    def __init__(self):\n        self.data = []\n    def push(self, item):\n        self.data.append(item)\n    def pop(self):\n        if len(self.data) > 0:",
        "detail": "wk19.d2.qandstack (1)",
        "documentation": {}
    },
    {
        "label": "s7",
        "kind": 5,
        "importPath": "wk19.d2.qandstack (1)",
        "description": "wk19.d2.qandstack (1)",
        "peekOfCode": "s7 = Song(\"Bob The Builder\", \"http://www.gogle.co.uk/\")\ns8 = Song(\"Eclipse - Pink Floyd Uncut\", \"http://www.yashoo.com\")\nclass Stack:\n    def __init__(self):\n        self.data = []\n    def push(self, item):\n        self.data.append(item)\n    def pop(self):\n        if len(self.data) > 0:\n            return self.data.pop()",
        "detail": "wk19.d2.qandstack (1)",
        "documentation": {}
    },
    {
        "label": "s8",
        "kind": 5,
        "importPath": "wk19.d2.qandstack (1)",
        "description": "wk19.d2.qandstack (1)",
        "peekOfCode": "s8 = Song(\"Eclipse - Pink Floyd Uncut\", \"http://www.yashoo.com\")\nclass Stack:\n    def __init__(self):\n        self.data = []\n    def push(self, item):\n        self.data.append(item)\n    def pop(self):\n        if len(self.data) > 0:\n            return self.data.pop()\n        return \"The stack is empty\"",
        "detail": "wk19.d2.qandstack (1)",
        "documentation": {}
    },
    {
        "label": "q",
        "kind": 5,
        "importPath": "wk19.d2.qandstack (1)",
        "description": "wk19.d2.qandstack (1)",
        "peekOfCode": "q = QueueTwoStacks()\nq.enqueue(s1)\nq.enqueue(s2)\nq.enqueue(s3)\nq.enqueue(s4)\nq.enqueue(s5)\nq.enqueue(s6)\nq.enqueue(s7)\nl3 = []\nl3.append(q.dequeue())",
        "detail": "wk19.d2.qandstack (1)",
        "documentation": {}
    },
    {
        "label": "l3",
        "kind": 5,
        "importPath": "wk19.d2.qandstack (1)",
        "description": "wk19.d2.qandstack (1)",
        "peekOfCode": "l3 = []\nl3.append(q.dequeue())\nl3.append(q.dequeue())\nl3.append(q.dequeue())\nl3.append(q.dequeue())\nl3.append(q.dequeue())\nl3.append(q.dequeue())\nl3.append(q.dequeue())\nprint(l3)",
        "detail": "wk19.d2.qandstack (1)",
        "documentation": {}
    },
    {
        "label": "Tree",
        "kind": 6,
        "importPath": "wk19.d3.hw.balancedBinaryTree",
        "description": "wk19.d3.hw.balancedBinaryTree",
        "peekOfCode": "class Tree(object):\n    def __init__(self, x):\n        self.value = x\n        self.left = None\n        self.right = None\ndef balancedBinaryTree(root):\n    def get_height(root):\n        if root is None:\n            return 0\n        return max(get_height(root.left), get_height(root.right)) + 1",
        "detail": "wk19.d3.hw.balancedBinaryTree",
        "documentation": {}
    },
    {
        "label": "balancedBinaryTree",
        "kind": 2,
        "importPath": "wk19.d3.hw.balancedBinaryTree",
        "description": "wk19.d3.hw.balancedBinaryTree",
        "peekOfCode": "def balancedBinaryTree(root):\n    def get_height(root):\n        if root is None:\n            return 0\n        return max(get_height(root.left), get_height(root.right)) + 1\n    if root is None:\n        return True\n    left_height = get_height(root.left)\n    right_height = get_height(root.right)\n    if (",
        "detail": "wk19.d3.hw.balancedBinaryTree",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "wk19.d3.hw.csFindAllPathsFromAToB",
        "description": "wk19.d3.hw.csFindAllPathsFromAToB",
        "peekOfCode": "def dfs(s):\n    # Append the node in path\n    # and set visited\n    path.append(s)\n    visited[s] = True\n    # Path started with a node\n    # having in-degree 0 and\n    # current node has out-degree 0,\n    # print current path\n    if outdeg0[s] and indeg0[path[0]]:",
        "detail": "wk19.d3.hw.csFindAllPathsFromAToB",
        "documentation": {}
    },
    {
        "label": "csFindAllPathsFromAToB",
        "kind": 2,
        "importPath": "wk19.d3.hw.csFindAllPathsFromAToB",
        "description": "wk19.d3.hw.csFindAllPathsFromAToB",
        "peekOfCode": "def csFindAllPathsFromAToB(graph):\n    for i in range(graph):\n        # for each node with in-degree 0\n        # print all possible paths\n        if indeg0[i] and adj[i]:\n            path = []\n            visited = [False] * (graph + 1)\n            dfs(i)\n# Driver code\ngraph = 6",
        "detail": "wk19.d3.hw.csFindAllPathsFromAToB",
        "documentation": {}
    },
    {
        "label": "graph",
        "kind": 5,
        "importPath": "wk19.d3.hw.csFindAllPathsFromAToB",
        "description": "wk19.d3.hw.csFindAllPathsFromAToB",
        "peekOfCode": "graph = 6\n# set all nodes unvisited\nvisited = [False] * (graph + 1)\npath = []\n# edges = (a, b): a -> b\nedges = [(5, 0), (5, 2), (2, 3), (4, 0), (4, 1), (3, 1)]\n# adjacency list for nodes\nadj = defaultdict(list)\n# indeg0 and outdeg0 arrays\nindeg0 = [True] * graph",
        "detail": "wk19.d3.hw.csFindAllPathsFromAToB",
        "documentation": {}
    },
    {
        "label": "visited",
        "kind": 5,
        "importPath": "wk19.d3.hw.csFindAllPathsFromAToB",
        "description": "wk19.d3.hw.csFindAllPathsFromAToB",
        "peekOfCode": "visited = [False] * (graph + 1)\npath = []\n# edges = (a, b): a -> b\nedges = [(5, 0), (5, 2), (2, 3), (4, 0), (4, 1), (3, 1)]\n# adjacency list for nodes\nadj = defaultdict(list)\n# indeg0 and outdeg0 arrays\nindeg0 = [True] * graph\noutdeg0 = [True] * graph\nfor edge in edges:",
        "detail": "wk19.d3.hw.csFindAllPathsFromAToB",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "wk19.d3.hw.csFindAllPathsFromAToB",
        "description": "wk19.d3.hw.csFindAllPathsFromAToB",
        "peekOfCode": "path = []\n# edges = (a, b): a -> b\nedges = [(5, 0), (5, 2), (2, 3), (4, 0), (4, 1), (3, 1)]\n# adjacency list for nodes\nadj = defaultdict(list)\n# indeg0 and outdeg0 arrays\nindeg0 = [True] * graph\noutdeg0 = [True] * graph\nfor edge in edges:\n    u, v = edge[0], edge[1]",
        "detail": "wk19.d3.hw.csFindAllPathsFromAToB",
        "documentation": {}
    },
    {
        "label": "edges",
        "kind": 5,
        "importPath": "wk19.d3.hw.csFindAllPathsFromAToB",
        "description": "wk19.d3.hw.csFindAllPathsFromAToB",
        "peekOfCode": "edges = [(5, 0), (5, 2), (2, 3), (4, 0), (4, 1), (3, 1)]\n# adjacency list for nodes\nadj = defaultdict(list)\n# indeg0 and outdeg0 arrays\nindeg0 = [True] * graph\noutdeg0 = [True] * graph\nfor edge in edges:\n    u, v = edge[0], edge[1]\n    # u -> v\n    adj[u].append(v)",
        "detail": "wk19.d3.hw.csFindAllPathsFromAToB",
        "documentation": {}
    },
    {
        "label": "adj",
        "kind": 5,
        "importPath": "wk19.d3.hw.csFindAllPathsFromAToB",
        "description": "wk19.d3.hw.csFindAllPathsFromAToB",
        "peekOfCode": "adj = defaultdict(list)\n# indeg0 and outdeg0 arrays\nindeg0 = [True] * graph\noutdeg0 = [True] * graph\nfor edge in edges:\n    u, v = edge[0], edge[1]\n    # u -> v\n    adj[u].append(v)\n    # set indeg0[v] <- false\n    indeg0[v] = False",
        "detail": "wk19.d3.hw.csFindAllPathsFromAToB",
        "documentation": {}
    },
    {
        "label": "indeg0",
        "kind": 5,
        "importPath": "wk19.d3.hw.csFindAllPathsFromAToB",
        "description": "wk19.d3.hw.csFindAllPathsFromAToB",
        "peekOfCode": "indeg0 = [True] * graph\noutdeg0 = [True] * graph\nfor edge in edges:\n    u, v = edge[0], edge[1]\n    # u -> v\n    adj[u].append(v)\n    # set indeg0[v] <- false\n    indeg0[v] = False\n    # set outdeg0[u] <- false\n    outdeg0[u] = False",
        "detail": "wk19.d3.hw.csFindAllPathsFromAToB",
        "documentation": {}
    },
    {
        "label": "outdeg0",
        "kind": 5,
        "importPath": "wk19.d3.hw.csFindAllPathsFromAToB",
        "description": "wk19.d3.hw.csFindAllPathsFromAToB",
        "peekOfCode": "outdeg0 = [True] * graph\nfor edge in edges:\n    u, v = edge[0], edge[1]\n    # u -> v\n    adj[u].append(v)\n    # set indeg0[v] <- false\n    indeg0[v] = False\n    # set outdeg0[u] <- false\n    outdeg0[u] = False\n# print('All possible paths:')",
        "detail": "wk19.d3.hw.csFindAllPathsFromAToB",
        "documentation": {}
    },
    {
        "label": "Graph",
        "kind": 6,
        "importPath": "wk19.d3.hw.find-path-scrap",
        "description": "wk19.d3.hw.find-path-scrap",
        "peekOfCode": "class Graph:\n    # Constructor\n    def __init__(self, edges, N):\n        # A list of lists to represent an adjacency list\n        self.adjList = [[] for _ in range(N)]\n        # add edges to the undirected graph\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n# Perform DFS on the graph and set the departure time of all vertices of the graph\ndef DFS(graph, v, discovered, departure, time):",
        "detail": "wk19.d3.hw.find-path-scrap",
        "documentation": {}
    },
    {
        "label": "DFS",
        "kind": 2,
        "importPath": "wk19.d3.hw.find-path-scrap",
        "description": "wk19.d3.hw.find-path-scrap",
        "peekOfCode": "def DFS(graph, v, discovered, departure, time):\n    # mark the current node as discovered\n    discovered[v] = True\n    # do for every edge `v —> u`\n    for u in graph.adjList[v]:\n        # if `u` is not yet discovered\n        if not discovered[u]:\n            time = DFS(graph, u, discovered, departure, time)\n    # ready to backtrack\n    # set departure time of vertex `v`",
        "detail": "wk19.d3.hw.find-path-scrap",
        "documentation": {}
    },
    {
        "label": "isDAG",
        "kind": 2,
        "importPath": "wk19.d3.hw.find-path-scrap",
        "description": "wk19.d3.hw.find-path-scrap",
        "peekOfCode": "def isDAG(graph, N):\n    # keep track of whether a vertex is discovered or not\n    discovered = [False] * N\n    # keep track of the departure time of a vertex in DFS\n    departure = [None] * N\n    time = 0\n    # Perform DFS traversal from all undiscovered vertices\n    # to visit all connected components of a graph\n    for i in range(N):\n        if not discovered[i]:",
        "detail": "wk19.d3.hw.find-path-scrap",
        "documentation": {}
    },
    {
        "label": "Vertex",
        "kind": 6,
        "importPath": "wk19.d3.hw.h1-raph",
        "description": "wk19.d3.hw.h1-raph",
        "peekOfCode": "class Vertex:\n    def __init__(self, value):\n        self.value = value\n        self.connections = {}\n    def __str__(self):\n        return (\n            str(self.value)\n            + \" connections: \"\n            + str([x.value for x in self.connections])\n        )",
        "detail": "wk19.d3.hw.h1-raph",
        "documentation": {}
    },
    {
        "label": "Graph",
        "kind": 6,
        "importPath": "wk19.d3.hw.h1-raph",
        "description": "wk19.d3.hw.h1-raph",
        "peekOfCode": "class Graph:\n    def __init__(self):\n        self.vertices = {}\n        self.count = 0\n    def __contains__(self, vert):\n        return vert in self.vertices\n    def __iter__(self):\n        return iter(self.vertices.values())\n    def add_vertex(self, value):\n        self.count += 1",
        "detail": "wk19.d3.hw.h1-raph",
        "documentation": {}
    },
    {
        "label": "g",
        "kind": 5,
        "importPath": "wk19.d3.hw.h1-raph",
        "description": "wk19.d3.hw.h1-raph",
        "peekOfCode": "g = Graph()\nprint(\n    '-----------------------------------------g.add_vertex(\"A\")----------------------------------------------------------'\n)\nA = g.add_vertex(\"A\")\nprint(\"A:\", A)\nprint(\n    '----------------------------------------------g.add_vertex(\"B\")-----------------------------------------------------'\n)\nB = g.add_vertex(\"B\")",
        "detail": "wk19.d3.hw.h1-raph",
        "documentation": {}
    },
    {
        "label": "A",
        "kind": 5,
        "importPath": "wk19.d3.hw.h1-raph",
        "description": "wk19.d3.hw.h1-raph",
        "peekOfCode": "A = g.add_vertex(\"A\")\nprint(\"A:\", A)\nprint(\n    '----------------------------------------------g.add_vertex(\"B\")-----------------------------------------------------'\n)\nB = g.add_vertex(\"B\")\nprint(\"B:\", B)\nprint(\n    '-------------------------------------------------g.add_vertex(\"C\")--------------------------------------------------'\n)",
        "detail": "wk19.d3.hw.h1-raph",
        "documentation": {}
    },
    {
        "label": "B",
        "kind": 5,
        "importPath": "wk19.d3.hw.h1-raph",
        "description": "wk19.d3.hw.h1-raph",
        "peekOfCode": "B = g.add_vertex(\"B\")\nprint(\"B:\", B)\nprint(\n    '-------------------------------------------------g.add_vertex(\"C\")--------------------------------------------------'\n)\nC = g.add_vertex(\"C\")\nprint(\"C:\", C)\nprint(\n    '-----------------------------------------------------g.add_vertex(\"D\")-----------------------------------------------'\n)",
        "detail": "wk19.d3.hw.h1-raph",
        "documentation": {}
    },
    {
        "label": "C",
        "kind": 5,
        "importPath": "wk19.d3.hw.h1-raph",
        "description": "wk19.d3.hw.h1-raph",
        "peekOfCode": "C = g.add_vertex(\"C\")\nprint(\"C:\", C)\nprint(\n    '-----------------------------------------------------g.add_vertex(\"D\")-----------------------------------------------'\n)\nD = g.add_vertex(\"D\")\nprint(\"D:\", D)\nprint(\n    '------------------------------------------------g.add_vertex(\"E\")--------------------------------------------------'\n)",
        "detail": "wk19.d3.hw.h1-raph",
        "documentation": {}
    },
    {
        "label": "D",
        "kind": 5,
        "importPath": "wk19.d3.hw.h1-raph",
        "description": "wk19.d3.hw.h1-raph",
        "peekOfCode": "D = g.add_vertex(\"D\")\nprint(\"D:\", D)\nprint(\n    '------------------------------------------------g.add_vertex(\"E\")--------------------------------------------------'\n)\nE = g.add_vertex(\"E\")\nprint(\"E:\", E)\nprint(\n    \"---------------------------------------g.add_edge(A, B, 1)------------------------------------------------------------\"\n)",
        "detail": "wk19.d3.hw.h1-raph",
        "documentation": {}
    },
    {
        "label": "E",
        "kind": 5,
        "importPath": "wk19.d3.hw.h1-raph",
        "description": "wk19.d3.hw.h1-raph",
        "peekOfCode": "E = g.add_vertex(\"E\")\nprint(\"E:\", E)\nprint(\n    \"---------------------------------------g.add_edge(A, B, 1)------------------------------------------------------------\"\n)\ng.add_edge(A, B, 1)\nprint(\n    \"---------------------------------------g.add_edge(B, C, 3)----------------------------------------------------------\"\n)\ng.add_edge(B, C, 3)",
        "detail": "wk19.d3.hw.h1-raph",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "wk19.d3.hw.possible-paths-scrap",
        "description": "wk19.d3.hw.possible-paths-scrap",
        "peekOfCode": "def dfs(s):\n    # Append the node in path\n    # and set visited\n    path.append(s)\n    visited[s] = True\n    # Path started with a node\n    # having in-degree 0 and\n    # current node has out-degree 0,\n    # print current path\n    if outdeg0[s] and indeg0[path[0]]:",
        "detail": "wk19.d3.hw.possible-paths-scrap",
        "documentation": {}
    },
    {
        "label": "csFindAllPathsFromAToB",
        "kind": 2,
        "importPath": "wk19.d3.hw.possible-paths-scrap",
        "description": "wk19.d3.hw.possible-paths-scrap",
        "peekOfCode": "def csFindAllPathsFromAToB(graph):\n    for i in range(graph):\n        # for each node with in-degree 0\n        # print all possible paths\n        if indeg0[i] and adj[i]:\n            path = []\n            visited = [False] * (graph + 1)\n            dfs(i)\n# Driver code\ngraph = 6",
        "detail": "wk19.d3.hw.possible-paths-scrap",
        "documentation": {}
    },
    {
        "label": "graph",
        "kind": 5,
        "importPath": "wk19.d3.hw.possible-paths-scrap",
        "description": "wk19.d3.hw.possible-paths-scrap",
        "peekOfCode": "graph = 6\n# set all nodes unvisited\nvisited = [False] * (graph + 1)\npath = []\n# edges = (a, b): a -> b\nedges = [(5, 0), (5, 2), (2, 3), (4, 0), (4, 1), (3, 1)]\n# adjacency list for nodes\nadj = defaultdict(list)\n# indeg0 and outdeg0 arrays\nindeg0 = [True] * graph",
        "detail": "wk19.d3.hw.possible-paths-scrap",
        "documentation": {}
    },
    {
        "label": "visited",
        "kind": 5,
        "importPath": "wk19.d3.hw.possible-paths-scrap",
        "description": "wk19.d3.hw.possible-paths-scrap",
        "peekOfCode": "visited = [False] * (graph + 1)\npath = []\n# edges = (a, b): a -> b\nedges = [(5, 0), (5, 2), (2, 3), (4, 0), (4, 1), (3, 1)]\n# adjacency list for nodes\nadj = defaultdict(list)\n# indeg0 and outdeg0 arrays\nindeg0 = [True] * graph\noutdeg0 = [True] * graph\nfor edge in edges:",
        "detail": "wk19.d3.hw.possible-paths-scrap",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "wk19.d3.hw.possible-paths-scrap",
        "description": "wk19.d3.hw.possible-paths-scrap",
        "peekOfCode": "path = []\n# edges = (a, b): a -> b\nedges = [(5, 0), (5, 2), (2, 3), (4, 0), (4, 1), (3, 1)]\n# adjacency list for nodes\nadj = defaultdict(list)\n# indeg0 and outdeg0 arrays\nindeg0 = [True] * graph\noutdeg0 = [True] * graph\nfor edge in edges:\n    u, v = edge[0], edge[1]",
        "detail": "wk19.d3.hw.possible-paths-scrap",
        "documentation": {}
    },
    {
        "label": "edges",
        "kind": 5,
        "importPath": "wk19.d3.hw.possible-paths-scrap",
        "description": "wk19.d3.hw.possible-paths-scrap",
        "peekOfCode": "edges = [(5, 0), (5, 2), (2, 3), (4, 0), (4, 1), (3, 1)]\n# adjacency list for nodes\nadj = defaultdict(list)\n# indeg0 and outdeg0 arrays\nindeg0 = [True] * graph\noutdeg0 = [True] * graph\nfor edge in edges:\n    u, v = edge[0], edge[1]\n    # u -> v\n    adj[u].append(v)",
        "detail": "wk19.d3.hw.possible-paths-scrap",
        "documentation": {}
    },
    {
        "label": "adj",
        "kind": 5,
        "importPath": "wk19.d3.hw.possible-paths-scrap",
        "description": "wk19.d3.hw.possible-paths-scrap",
        "peekOfCode": "adj = defaultdict(list)\n# indeg0 and outdeg0 arrays\nindeg0 = [True] * graph\noutdeg0 = [True] * graph\nfor edge in edges:\n    u, v = edge[0], edge[1]\n    # u -> v\n    adj[u].append(v)\n    # set indeg0[v] <- false\n    indeg0[v] = False",
        "detail": "wk19.d3.hw.possible-paths-scrap",
        "documentation": {}
    },
    {
        "label": "indeg0",
        "kind": 5,
        "importPath": "wk19.d3.hw.possible-paths-scrap",
        "description": "wk19.d3.hw.possible-paths-scrap",
        "peekOfCode": "indeg0 = [True] * graph\noutdeg0 = [True] * graph\nfor edge in edges:\n    u, v = edge[0], edge[1]\n    # u -> v\n    adj[u].append(v)\n    # set indeg0[v] <- false\n    indeg0[v] = False\n    # set outdeg0[u] <- false\n    outdeg0[u] = False",
        "detail": "wk19.d3.hw.possible-paths-scrap",
        "documentation": {}
    },
    {
        "label": "outdeg0",
        "kind": 5,
        "importPath": "wk19.d3.hw.possible-paths-scrap",
        "description": "wk19.d3.hw.possible-paths-scrap",
        "peekOfCode": "outdeg0 = [True] * graph\nfor edge in edges:\n    u, v = edge[0], edge[1]\n    # u -> v\n    adj[u].append(v)\n    # set indeg0[v] <- false\n    indeg0[v] = False\n    # set outdeg0[u] <- false\n    outdeg0[u] = False\n# print('All possible paths:')",
        "detail": "wk19.d3.hw.possible-paths-scrap",
        "documentation": {}
    },
    {
        "label": "BinaryTreeNode",
        "kind": 6,
        "importPath": "wk19.d3.try-2-notes.bst-wk19-d3-notes",
        "description": "wk19.d3.try-2-notes.bst-wk19-d3-notes",
        "peekOfCode": "class BinaryTreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\nr = BinarySearchTree(5)\nr.left =\ndef maxDepthR(root):\n    \"\"\"\n    # if we have a root of None",
        "detail": "wk19.d3.try-2-notes.bst-wk19-d3-notes",
        "documentation": {}
    },
    {
        "label": "maxDepthR",
        "kind": 2,
        "importPath": "wk19.d3.try-2-notes.bst-wk19-d3-notes",
        "description": "wk19.d3.try-2-notes.bst-wk19-d3-notes",
        "peekOfCode": "def maxDepthR(root):\n    \"\"\"\n    # if we have a root of None\n      # return zero\n    # otherwise\n      # get the left height\n      # get the right height\n      # return the max of the left height and the right height + 1\n    pass\n    \"\"\"",
        "detail": "wk19.d3.try-2-notes.bst-wk19-d3-notes",
        "documentation": {}
    },
    {
        "label": "maxDepthI",
        "kind": 2,
        "importPath": "wk19.d3.try-2-notes.bst-wk19-d3-notes",
        "description": "wk19.d3.try-2-notes.bst-wk19-d3-notes",
        "peekOfCode": "def maxDepthI(root):\n    pass\nmaxDepthR(None)",
        "detail": "wk19.d3.try-2-notes.bst-wk19-d3-notes",
        "documentation": {}
    },
    {
        "label": "max_depth",
        "kind": 5,
        "importPath": "wk19.d3.try-2-notes.bst-wk19-d3-notes",
        "description": "wk19.d3.try-2-notes.bst-wk19-d3-notes",
        "peekOfCode": "max_depth = 2\nleft_height = 0\nright_height = 0\n- if there is no root node then return a zero\n- otherwise\n  - set a left height based on a call to the max depth on the left node\n  - set a right height based on a call to the max depth on the right node\n  - get the max of the left height and the right height then return that plus 1\n** iterative version **\n- create a stack to simulate the call stack",
        "detail": "wk19.d3.try-2-notes.bst-wk19-d3-notes",
        "documentation": {}
    },
    {
        "label": "left_height",
        "kind": 5,
        "importPath": "wk19.d3.try-2-notes.bst-wk19-d3-notes",
        "description": "wk19.d3.try-2-notes.bst-wk19-d3-notes",
        "peekOfCode": "left_height = 0\nright_height = 0\n- if there is no root node then return a zero\n- otherwise\n  - set a left height based on a call to the max depth on the left node\n  - set a right height based on a call to the max depth on the right node\n  - get the max of the left height and the right height then return that plus 1\n** iterative version **\n- create a stack to simulate the call stack\n- if the root node is not none",
        "detail": "wk19.d3.try-2-notes.bst-wk19-d3-notes",
        "documentation": {}
    },
    {
        "label": "right_height",
        "kind": 5,
        "importPath": "wk19.d3.try-2-notes.bst-wk19-d3-notes",
        "description": "wk19.d3.try-2-notes.bst-wk19-d3-notes",
        "peekOfCode": "right_height = 0\n- if there is no root node then return a zero\n- otherwise\n  - set a left height based on a call to the max depth on the left node\n  - set a right height based on a call to the max depth on the right node\n  - get the max of the left height and the right height then return that plus 1\n** iterative version **\n- create a stack to simulate the call stack\n- if the root node is not none\n  - append the root node to the stack and also the height of that node (1, root)",
        "detail": "wk19.d3.try-2-notes.bst-wk19-d3-notes",
        "documentation": {}
    },
    {
        "label": "max_depth",
        "kind": 5,
        "importPath": "wk19.d3.try-2-notes.bst-wk19-d3-notes",
        "description": "wk19.d3.try-2-notes.bst-wk19-d3-notes",
        "peekOfCode": "max_depth = 0\n- while the stack is not empty\n  pop the tuple off the stack, extracting the current_depth and the root_node\n  - if the root_node is not none\n    set max_depth to the max of current_depth and the max_depth\n    - push the data of (max_depth + 1, root_node.left) on to the stack\n    - push the data of (max_depth + 1, root_node.right) on to the stack\nreturn the max_depth to the caller\n    5  3  \n   / \\",
        "detail": "wk19.d3.try-2-notes.bst-wk19-d3-notes",
        "documentation": {}
    },
    {
        "label": "r",
        "kind": 5,
        "importPath": "wk19.d3.try-2-notes.bst-wk19-d3-notes",
        "description": "wk19.d3.try-2-notes.bst-wk19-d3-notes",
        "peekOfCode": "r = BinarySearchTree(5)\nr.left =\ndef maxDepthR(root):\n    \"\"\"\n    # if we have a root of None\n      # return zero\n    # otherwise\n      # get the left height\n      # get the right height\n      # return the max of the left height and the right height + 1",
        "detail": "wk19.d3.try-2-notes.bst-wk19-d3-notes",
        "documentation": {}
    },
    {
        "label": "r.left",
        "kind": 5,
        "importPath": "wk19.d3.try-2-notes.bst-wk19-d3-notes",
        "description": "wk19.d3.try-2-notes.bst-wk19-d3-notes",
        "peekOfCode": "r.left =\ndef maxDepthR(root):\n    \"\"\"\n    # if we have a root of None\n      # return zero\n    # otherwise\n      # get the left height\n      # get the right height\n      # return the max of the left height and the right height + 1\n    pass",
        "detail": "wk19.d3.try-2-notes.bst-wk19-d3-notes",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "class Node:\n    def __init__(self, value):\n        self.value = value\nn = Node(10)\n# [10]\n# lets make a linked list node\nclass LLNode:\n    def __init__(self, value):\n        self.value = value\n        self.next = None",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "LLNode",
        "kind": 6,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "class LLNode:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\nl = LLNode(10)\n# [10] -> None\n# lets refactor the linked list node to be a doubly linked list node\nclass DLLNode:\n    def __init__(self, value):\n        self.value = value",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "DLLNode",
        "kind": 6,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "class DLLNode:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n        self.prev = None\ndl = DLLNode(10)\n# None <- [10] -> None\n# Lets refactor the doubly linked list node to be a binary tree node\nclass BTNode:\n    def __init__(self, value):",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "BTNode",
        "kind": 6,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "class BTNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\nbt = BTNode(10)\nbt.left = BTNode(34)\nbt.right = BTNode(12)\n\"\"\"\n[12, 34, 1, 56, 1]",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "BSTNode",
        "kind": 6,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "class BSTNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n    def insert(self, value):\n        # left case\n        if value < self.value:\n            if self.left is None:\n                self.left = BSTNode(value)",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "BinaryTreeNode",
        "kind": 6,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "class BinaryTreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\"\"\"\nr = 5\nlh = 1\nrh = \nr1 = 12",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "maxDepthR",
        "kind": 2,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "def maxDepthR(self, root):\n    if root is None:\n        return 0\n    else:\n        left_height = self.maxDepthR(root.left)\n        right_height = self.maxDepthR(root.right)\n        return max(left_height, right_height) + 1\ndef maxDepthI(self, root):\n    # Your c\n    pass",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "maxDepthI",
        "kind": 2,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "def maxDepthI(self, root):\n    # Your c\n    pass",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "n = Node(10)\n# [10]\n# lets make a linked list node\nclass LLNode:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\nl = LLNode(10)\n# [10] -> None\n# lets refactor the linked list node to be a doubly linked list node",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "l",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "l = LLNode(10)\n# [10] -> None\n# lets refactor the linked list node to be a doubly linked list node\nclass DLLNode:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n        self.prev = None\ndl = DLLNode(10)\n# None <- [10] -> None",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "dl",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "dl = DLLNode(10)\n# None <- [10] -> None\n# Lets refactor the doubly linked list node to be a binary tree node\nclass BTNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\nbt = BTNode(10)\nbt.left = BTNode(34)",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "bt",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "bt = BTNode(10)\nbt.left = BTNode(34)\nbt.right = BTNode(12)\n\"\"\"\n[12, 34, 1, 56, 1]\n        [12]\n      /      \\\n     [1]      [34]\n    /         /   \\\n  [1]      [12]    [56]",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "bt.left",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "bt.left = BTNode(34)\nbt.right = BTNode(12)\n\"\"\"\n[12, 34, 1, 56, 1]\n        [12]\n      /      \\\n     [1]      [34]\n    /         /   \\\n  [1]      [12]    [56]\n          /  \\",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "bt.right",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "bt.right = BTNode(12)\n\"\"\"\n[12, 34, 1, 56, 1]\n        [12]\n      /      \\\n     [1]      [34]\n    /         /   \\\n  [1]      [12]    [56]\n          /  \\\n        n     n",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "t = BSTNode(10)\nt.insert(20)\nt.insert(15)\nresult = t.search(15)\nprint(result)\n# result [15]\n#        /  \\\n#       n    n\n#        [10] s\n#       /    \\",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "result = t.search(15)\nprint(result)\n# result [15]\n#        /  \\\n#       n    n\n#        [10] s\n#       /    \\\n#      n      [20] s\n#             /   \\\n#          s [15]    n",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "max_depth",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "max_depth = 2\nleft_height = 0\nright_height = 0\n- if there is no root node then return a zero\n- otherwise\n  - set a left height based on a call to the max depth on the left node\n  - set a right height based on a call to the max depth on the right node\n  - get the max of the left height and the right height then return that plus 1\n** iterative version **\n- create a stack to simulate the call stack",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "left_height",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "left_height = 0\nright_height = 0\n- if there is no root node then return a zero\n- otherwise\n  - set a left height based on a call to the max depth on the left node\n  - set a right height based on a call to the max depth on the right node\n  - get the max of the left height and the right height then return that plus 1\n** iterative version **\n- create a stack to simulate the call stack\n- if the root node is not none",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "right_height",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "right_height = 0\n- if there is no root node then return a zero\n- otherwise\n  - set a left height based on a call to the max depth on the left node\n  - set a right height based on a call to the max depth on the right node\n  - get the max of the left height and the right height then return that plus 1\n** iterative version **\n- create a stack to simulate the call stack\n- if the root node is not none\n  - append the root node to the stack and also the height of that node (1, root)",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "max_depth",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "max_depth = 0\n- while the stack is not empty\n  pop the tuple off the stack, extracting the current_depth and the root_node\n  - if the root_node is not none\n    set max_depth to the max of current_depth and the max_depth\n    - push the data of (max_depth + 1, root_node.left) on to the stack\n    - push the data of (max_depth + 1, root_node.right) on to the stack\nreturn the max_depth to the caller\n    5   \n   / \\",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "r",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "r = 5\nlh = 1\nrh = \nr1 = 12\nlh1 = 1\nrh1 = 1\nr2 = None\nr3 = None\nr4 = 32\nlh = 1",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "lh",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "lh = 1\nrh = \nr1 = 12\nlh1 = 1\nrh1 = 1\nr2 = None\nr3 = None\nr4 = 32\nlh = 1\nrh = 1",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "rh",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "rh = \nr1 = 12\nlh1 = 1\nrh1 = 1\nr2 = None\nr3 = None\nr4 = 32\nlh = 1\nrh = 1\nr5 = 8",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "r1",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "r1 = 12\nlh1 = 1\nrh1 = 1\nr2 = None\nr3 = None\nr4 = 32\nlh = 1\nrh = 1\nr5 = 8\nlh = 0",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "lh1",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "lh1 = 1\nrh1 = 1\nr2 = None\nr3 = None\nr4 = 32\nlh = 1\nrh = 1\nr5 = 8\nlh = 0\nrh = 0",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "rh1",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "rh1 = 1\nr2 = None\nr3 = None\nr4 = 32\nlh = 1\nrh = 1\nr5 = 8\nlh = 0\nrh = 0\nr6 = None",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "r2",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "r2 = None\nr3 = None\nr4 = 32\nlh = 1\nrh = 1\nr5 = 8\nlh = 0\nrh = 0\nr6 = None\nr7 = None",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "r3",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "r3 = None\nr4 = 32\nlh = 1\nrh = 1\nr5 = 8\nlh = 0\nrh = 0\nr6 = None\nr7 = None\nr8 = 4",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "r4",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "r4 = 32\nlh = 1\nrh = 1\nr5 = 8\nlh = 0\nrh = 0\nr6 = None\nr7 = None\nr8 = 4\nlh = 0",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "lh",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "lh = 1\nrh = 1\nr5 = 8\nlh = 0\nrh = 0\nr6 = None\nr7 = None\nr8 = 4\nlh = 0\nrh = 0",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "rh",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "rh = 1\nr5 = 8\nlh = 0\nrh = 0\nr6 = None\nr7 = None\nr8 = 4\nlh = 0\nrh = 0\nr9 = None",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "r5",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "r5 = 8\nlh = 0\nrh = 0\nr6 = None\nr7 = None\nr8 = 4\nlh = 0\nrh = 0\nr9 = None\nr10 = None",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "lh",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "lh = 0\nrh = 0\nr6 = None\nr7 = None\nr8 = 4\nlh = 0\nrh = 0\nr9 = None\nr10 = None\n\"\"\"",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "rh",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "rh = 0\nr6 = None\nr7 = None\nr8 = 4\nlh = 0\nrh = 0\nr9 = None\nr10 = None\n\"\"\"\ndef maxDepthR(self, root):",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "r6",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "r6 = None\nr7 = None\nr8 = 4\nlh = 0\nrh = 0\nr9 = None\nr10 = None\n\"\"\"\ndef maxDepthR(self, root):\n    if root is None:",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "r7",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "r7 = None\nr8 = 4\nlh = 0\nrh = 0\nr9 = None\nr10 = None\n\"\"\"\ndef maxDepthR(self, root):\n    if root is None:\n        return 0",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "r8",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "r8 = 4\nlh = 0\nrh = 0\nr9 = None\nr10 = None\n\"\"\"\ndef maxDepthR(self, root):\n    if root is None:\n        return 0\n    else:",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "lh",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "lh = 0\nrh = 0\nr9 = None\nr10 = None\n\"\"\"\ndef maxDepthR(self, root):\n    if root is None:\n        return 0\n    else:\n        left_height = self.maxDepthR(root.left)",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "rh",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "rh = 0\nr9 = None\nr10 = None\n\"\"\"\ndef maxDepthR(self, root):\n    if root is None:\n        return 0\n    else:\n        left_height = self.maxDepthR(root.left)\n        right_height = self.maxDepthR(root.right)",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "r9",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "r9 = None\nr10 = None\n\"\"\"\ndef maxDepthR(self, root):\n    if root is None:\n        return 0\n    else:\n        left_height = self.maxDepthR(root.left)\n        right_height = self.maxDepthR(root.right)\n        return max(left_height, right_height) + 1",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "r10",
        "kind": 5,
        "importPath": "wk19.d3.bst",
        "description": "wk19.d3.bst",
        "peekOfCode": "r10 = None\n\"\"\"\ndef maxDepthR(self, root):\n    if root is None:\n        return 0\n    else:\n        left_height = self.maxDepthR(root.left)\n        right_height = self.maxDepthR(root.right)\n        return max(left_height, right_height) + 1\ndef maxDepthI(self, root):",
        "detail": "wk19.d3.bst",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "wk19.d4.traversals",
        "description": "wk19.d4.traversals",
        "peekOfCode": "class TreeNode:\n  def __init__(self, value):\n    self.value = value\n    self.left = None\n    self.right = None\n# pre order\n# visit the root\n# do something with this node\n# visit the left of the root\n# visit the right of the root",
        "detail": "wk19.d4.traversals",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "wk19.d4.traversals",
        "description": "wk19.d4.traversals",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nl = TreeNode(3)\nl.right = TreeNode(1)\nl.right.left = TreeNode(5)\ndef inorder_traversal_r(root):\n    def dft(root, output):",
        "detail": "wk19.d4.traversals",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "wk19.d4.traversals",
        "description": "wk19.d4.traversals",
        "peekOfCode": "class TreeNode:\n  def __init__(self, val=0, left=None, right=None):\n      self.val = val\n      self.left = left\n      self.right = right\ndef build_tree(preorder, inorder):\n  def helper(left = 0, right = len(inorder)):\n    nonlocal starting_index\n    if left == right:\n      return None",
        "detail": "wk19.d4.traversals",
        "documentation": {}
    },
    {
        "label": "inorder_traversal_r",
        "kind": 2,
        "importPath": "wk19.d4.traversals",
        "description": "wk19.d4.traversals",
        "peekOfCode": "def inorder_traversal_r(root):\n    def dft(root, output):\n      if root:\n        dft(root.left, output)\n        output.append(root.val)\n        dft(root.right, output)\n    output = []\n    dft(root, output)\n    return output\ndef inorder_traversal_i(root):",
        "detail": "wk19.d4.traversals",
        "documentation": {}
    },
    {
        "label": "inorder_traversal_i",
        "kind": 2,
        "importPath": "wk19.d4.traversals",
        "description": "wk19.d4.traversals",
        "peekOfCode": "def inorder_traversal_i(root):\n  \"\"\"\n  output list\n  keep track of the data using a stack\n  # keep looping\n    # while root exists\n      # append root to the stack\n      # traverse to the left\n    # if the stack is empty\n      # return my output",
        "detail": "wk19.d4.traversals",
        "documentation": {}
    },
    {
        "label": "build_tree",
        "kind": 2,
        "importPath": "wk19.d4.traversals",
        "description": "wk19.d4.traversals",
        "peekOfCode": "def build_tree(preorder, inorder):\n  def helper(left = 0, right = len(inorder)):\n    nonlocal starting_index\n    if left == right:\n      return None\n    root_value = preorder[starting_index]\n    root = TreeNode(root_value)\n    index = inorder_index_map[root_value]\n    starting_index += 1\n    root.left = helper(left, index)",
        "detail": "wk19.d4.traversals",
        "documentation": {}
    },
    {
        "label": "l",
        "kind": 5,
        "importPath": "wk19.d4.traversals",
        "description": "wk19.d4.traversals",
        "peekOfCode": "l = TreeNode(3)\nl.right = TreeNode(1)\nl.right.left = TreeNode(5)\ndef inorder_traversal_r(root):\n    def dft(root, output):\n      if root:\n        dft(root.left, output)\n        output.append(root.val)\n        dft(root.right, output)\n    output = []",
        "detail": "wk19.d4.traversals",
        "documentation": {}
    },
    {
        "label": "l.right",
        "kind": 5,
        "importPath": "wk19.d4.traversals",
        "description": "wk19.d4.traversals",
        "peekOfCode": "l.right = TreeNode(1)\nl.right.left = TreeNode(5)\ndef inorder_traversal_r(root):\n    def dft(root, output):\n      if root:\n        dft(root.left, output)\n        output.append(root.val)\n        dft(root.right, output)\n    output = []\n    dft(root, output)",
        "detail": "wk19.d4.traversals",
        "documentation": {}
    },
    {
        "label": "l.right.left",
        "kind": 5,
        "importPath": "wk19.d4.traversals",
        "description": "wk19.d4.traversals",
        "peekOfCode": "l.right.left = TreeNode(5)\ndef inorder_traversal_r(root):\n    def dft(root, output):\n      if root:\n        dft(root.left, output)\n        output.append(root.val)\n        dft(root.right, output)\n    output = []\n    dft(root, output)\n    return output",
        "detail": "wk19.d4.traversals",
        "documentation": {}
    },
    {
        "label": "start1",
        "kind": 5,
        "importPath": "wk19.d4.traversals",
        "description": "wk19.d4.traversals",
        "peekOfCode": "start1 = time.time()\nresult1 = inorder_traversal_i(l)\nend1 = time.time()\nstart2 = time.time()\nresult2 = inorder_traversal_r(l)\nend2 = time.time()\nprint(f\"iterative version took {end1 - start1} seconds with a result of {result1}\")\nprint(f\"recursive version took {end2 - start2} seconds with a result of {result2}\")\n\"\"\"\nYou are given the values from a preorder and an inorder tree traversal. Write a",
        "detail": "wk19.d4.traversals",
        "documentation": {}
    },
    {
        "label": "result1",
        "kind": 5,
        "importPath": "wk19.d4.traversals",
        "description": "wk19.d4.traversals",
        "peekOfCode": "result1 = inorder_traversal_i(l)\nend1 = time.time()\nstart2 = time.time()\nresult2 = inorder_traversal_r(l)\nend2 = time.time()\nprint(f\"iterative version took {end1 - start1} seconds with a result of {result1}\")\nprint(f\"recursive version took {end2 - start2} seconds with a result of {result2}\")\n\"\"\"\nYou are given the values from a preorder and an inorder tree traversal. Write a\nfunction that can take those inputs and output a binary tree.",
        "detail": "wk19.d4.traversals",
        "documentation": {}
    },
    {
        "label": "end1",
        "kind": 5,
        "importPath": "wk19.d4.traversals",
        "description": "wk19.d4.traversals",
        "peekOfCode": "end1 = time.time()\nstart2 = time.time()\nresult2 = inorder_traversal_r(l)\nend2 = time.time()\nprint(f\"iterative version took {end1 - start1} seconds with a result of {result1}\")\nprint(f\"recursive version took {end2 - start2} seconds with a result of {result2}\")\n\"\"\"\nYou are given the values from a preorder and an inorder tree traversal. Write a\nfunction that can take those inputs and output a binary tree.\n*Note: assume that there will not be any duplicates in the tree.*",
        "detail": "wk19.d4.traversals",
        "documentation": {}
    },
    {
        "label": "start2",
        "kind": 5,
        "importPath": "wk19.d4.traversals",
        "description": "wk19.d4.traversals",
        "peekOfCode": "start2 = time.time()\nresult2 = inorder_traversal_r(l)\nend2 = time.time()\nprint(f\"iterative version took {end1 - start1} seconds with a result of {result1}\")\nprint(f\"recursive version took {end2 - start2} seconds with a result of {result2}\")\n\"\"\"\nYou are given the values from a preorder and an inorder tree traversal. Write a\nfunction that can take those inputs and output a binary tree.\n*Note: assume that there will not be any duplicates in the tree.*\nExample:",
        "detail": "wk19.d4.traversals",
        "documentation": {}
    },
    {
        "label": "result2",
        "kind": 5,
        "importPath": "wk19.d4.traversals",
        "description": "wk19.d4.traversals",
        "peekOfCode": "result2 = inorder_traversal_r(l)\nend2 = time.time()\nprint(f\"iterative version took {end1 - start1} seconds with a result of {result1}\")\nprint(f\"recursive version took {end2 - start2} seconds with a result of {result2}\")\n\"\"\"\nYou are given the values from a preorder and an inorder tree traversal. Write a\nfunction that can take those inputs and output a binary tree.\n*Note: assume that there will not be any duplicates in the tree.*\nExample:\nInputs:     0 1  2  3 4",
        "detail": "wk19.d4.traversals",
        "documentation": {}
    },
    {
        "label": "end2",
        "kind": 5,
        "importPath": "wk19.d4.traversals",
        "description": "wk19.d4.traversals",
        "peekOfCode": "end2 = time.time()\nprint(f\"iterative version took {end1 - start1} seconds with a result of {result1}\")\nprint(f\"recursive version took {end2 - start2} seconds with a result of {result2}\")\n\"\"\"\nYou are given the values from a preorder and an inorder tree traversal. Write a\nfunction that can take those inputs and output a binary tree.\n*Note: assume that there will not be any duplicates in the tree.*\nExample:\nInputs:     0 1  2  3 4\npreorder = [5,7,22,13,9]",
        "detail": "wk19.d4.traversals",
        "documentation": {}
    },
    {
        "label": "preorder",
        "kind": 5,
        "importPath": "wk19.d4.traversals",
        "description": "wk19.d4.traversals",
        "peekOfCode": "preorder = [5,7,22,13,9]\ninorder = [7,5,13,22,9]\nOutput:\n   [5]\n   / \\\n  7  22\n    /  \\\n   13   9\n# the outer function\n  # inner function take a left and right constraint",
        "detail": "wk19.d4.traversals",
        "documentation": {}
    },
    {
        "label": "inorder",
        "kind": 5,
        "importPath": "wk19.d4.traversals",
        "description": "wk19.d4.traversals",
        "peekOfCode": "inorder = [7,5,13,22,9]\nOutput:\n   [5]\n   / \\\n  7  22\n    /  \\\n   13   9\n# the outer function\n  # inner function take a left and right constraint\n    # get the root value from the preorder list at the starting_index",
        "detail": "wk19.d4.traversals",
        "documentation": {}
    },
    {
        "label": "inorder_index_map",
        "kind": 5,
        "importPath": "wk19.d4.traversals",
        "description": "wk19.d4.traversals",
        "peekOfCode": "inorder_index_map = {7: 0, 5: 1, 13: 2, 22: 3, 9: 4}\nstarting_index = 0\n# start our first call\nreturn innerfunction()\n\"\"\"\n# Definition for a binary tree node.\nclass TreeNode:\n  def __init__(self, val=0, left=None, right=None):\n      self.val = val\n      self.left = left",
        "detail": "wk19.d4.traversals",
        "documentation": {}
    },
    {
        "label": "starting_index",
        "kind": 5,
        "importPath": "wk19.d4.traversals",
        "description": "wk19.d4.traversals",
        "peekOfCode": "starting_index = 0\n# start our first call\nreturn innerfunction()\n\"\"\"\n# Definition for a binary tree node.\nclass TreeNode:\n  def __init__(self, val=0, left=None, right=None):\n      self.val = val\n      self.left = left\n      self.right = right",
        "detail": "wk19.d4.traversals",
        "documentation": {}
    },
    {
        "label": "preorder",
        "kind": 5,
        "importPath": "wk19.d4.traversals",
        "description": "wk19.d4.traversals",
        "peekOfCode": "preorder = [5,7,22,13,9]\ninorder = [7,5,13,22,9]\nt = build_tree(preorder, inorder)\n\"\"\"\n   [5]\n   / \\\n  7  22\n    /  \\\n   13   9\n\"\"\"",
        "detail": "wk19.d4.traversals",
        "documentation": {}
    },
    {
        "label": "inorder",
        "kind": 5,
        "importPath": "wk19.d4.traversals",
        "description": "wk19.d4.traversals",
        "peekOfCode": "inorder = [7,5,13,22,9]\nt = build_tree(preorder, inorder)\n\"\"\"\n   [5]\n   / \\\n  7  22\n    /  \\\n   13   9\n\"\"\"\nprint(f\"            [{t.val}]\")",
        "detail": "wk19.d4.traversals",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": "wk19.d4.traversals",
        "description": "wk19.d4.traversals",
        "peekOfCode": "t = build_tree(preorder, inorder)\n\"\"\"\n   [5]\n   / \\\n  7  22\n    /  \\\n   13   9\n\"\"\"\nprint(f\"            [{t.val}]\")\nprint(f\"     [{t.left.val}]       [{t.right.val}]\")",
        "detail": "wk19.d4.traversals",
        "documentation": {}
    },
    {
        "label": "addTwoHugeNumbers",
        "kind": 2,
        "importPath": "wk19.sprint-prep.prac.gists.addTwoHugeNumbers",
        "description": "wk19.sprint-prep.prac.gists.addTwoHugeNumbers",
        "peekOfCode": "def addTwoHugeNumbers(a, b):\n    lst_a = {}\n    lst_b = {}\n    i = 0\n    while a.value != None:\n        i += 1\n        lst_a[i] = a.value\n        if a.next != None:\n            a = a.next\n        else:",
        "detail": "wk19.sprint-prep.prac.gists.addTwoHugeNumbers",
        "documentation": {}
    },
    {
        "label": "findProfession",
        "kind": 2,
        "importPath": "wk19.sprint-prep.prac.gists.findProfession",
        "description": "wk19.sprint-prep.prac.gists.findProfession",
        "peekOfCode": "def findProfession(level, pos):\n    # Base case\n    if level == 1:\n        return \"Engineer\"\n    # Recursively find parent's profession. If parent\n    # is a doctar, this node will be a doctal if it is\n    # at odd position and an engineer if at even position\n    if findProfession(level - 1, (pos + 1) // 2) == \"Doctor\":\n        if pos % 2:\n            return \"Doctor\"",
        "detail": "wk19.sprint-prep.prac.gists.findProfession",
        "documentation": {}
    },
    {
        "label": "download_all_from_user",
        "kind": 2,
        "importPath": "wk19.sprint-prep.prac.gists.gist",
        "description": "wk19.sprint-prep.prac.gists.gist",
        "peekOfCode": "def download_all_from_user(user: str):\n    next_page = True\n    page = 1\n    while next_page:\n        url = f\"https://api.github.com/users/{user}/gists?page={page}\"\n        response = requests.get(url)\n        if not len(response.json()):\n            next_page = False\n        else:\n            page += 1",
        "detail": "wk19.sprint-prep.prac.gists.gist",
        "documentation": {}
    },
    {
        "label": "download_all",
        "kind": 2,
        "importPath": "wk19.sprint-prep.prac.gists.gist",
        "description": "wk19.sprint-prep.prac.gists.gist",
        "peekOfCode": "def download_all(gists: list):\n    with PoolExecutor(max_workers=10) as executor:\n        for _ in executor.map(download, gists):\n            pass\ndef download(gist):\n    target = gist[\"id\"] + hashlib.md5(gist[\"updated_at\"].encode(\"utf-8\")).hexdigest()\n    call([\"git\", \"clone\", gist[\"git_pull_url\"], target])\n    description_file = os.path.join(target, \"description.txt\")\n    with open(description_file, \"w\") as f:\n        f.write(f\"{gist['description']}\\n\")",
        "detail": "wk19.sprint-prep.prac.gists.gist",
        "documentation": {}
    },
    {
        "label": "download",
        "kind": 2,
        "importPath": "wk19.sprint-prep.prac.gists.gist",
        "description": "wk19.sprint-prep.prac.gists.gist",
        "peekOfCode": "def download(gist):\n    target = gist[\"id\"] + hashlib.md5(gist[\"updated_at\"].encode(\"utf-8\")).hexdigest()\n    call([\"git\", \"clone\", gist[\"git_pull_url\"], target])\n    description_file = os.path.join(target, \"description.txt\")\n    with open(description_file, \"w\") as f:\n        f.write(f\"{gist['description']}\\n\")\n# Run\nuser = sys.argv[1]\ndownload_all_from_user(user)",
        "detail": "wk19.sprint-prep.prac.gists.gist",
        "documentation": {}
    },
    {
        "label": "user",
        "kind": 5,
        "importPath": "wk19.sprint-prep.prac.gists.gist",
        "description": "wk19.sprint-prep.prac.gists.gist",
        "peekOfCode": "user = sys.argv[1]\ndownload_all_from_user(user)",
        "detail": "wk19.sprint-prep.prac.gists.gist",
        "documentation": {}
    },
    {
        "label": "hasPathWithGivenSum",
        "kind": 2,
        "importPath": "wk19.sprint-prep.prac.gists.hasPathWithGivenSum",
        "description": "wk19.sprint-prep.prac.gists.hasPathWithGivenSum",
        "peekOfCode": "def hasPathWithGivenSum(t, s):\n    if t is None:\n        if s == 0:\n            return True\n        else:\n            return False\n    else:\n        if t.left is not None and t.right is not None:\n            return any(\n                [",
        "detail": "wk19.sprint-prep.prac.gists.hasPathWithGivenSum",
        "documentation": {}
    },
    {
        "label": "decrypt",
        "kind": 2,
        "importPath": "wk19.sprint-prep.prac.gists.isCryptSolution",
        "description": "wk19.sprint-prep.prac.gists.isCryptSolution",
        "peekOfCode": "def decrypt(word, dictionary):\n    lst = []\n    for c in word:\n        lst.append(dictionary[c])\n    return \"\".join(lst)\ndef isCryptSolution(crypt, solution):\n    dict = {}\n    for r in solution:\n        dict[r[0]] = r[1]\n    values = [0] * 3",
        "detail": "wk19.sprint-prep.prac.gists.isCryptSolution",
        "documentation": {}
    },
    {
        "label": "isCryptSolution",
        "kind": 2,
        "importPath": "wk19.sprint-prep.prac.gists.isCryptSolution",
        "description": "wk19.sprint-prep.prac.gists.isCryptSolution",
        "peekOfCode": "def isCryptSolution(crypt, solution):\n    dict = {}\n    for r in solution:\n        dict[r[0]] = r[1]\n    values = [0] * 3\n    for i in range(3):\n        val = decrypt(crypt[i], dict)\n        if val.startswith(\"0\") and len(val) > 1:\n            return False\n        values[i] = int(val)",
        "detail": "wk19.sprint-prep.prac.gists.isCryptSolution",
        "documentation": {}
    },
    {
        "label": "isSubtree",
        "kind": 2,
        "importPath": "wk19.sprint-prep.prac.gists.isSubtree",
        "description": "wk19.sprint-prep.prac.gists.isSubtree",
        "peekOfCode": "def isSubtree(t1, t2):\n    def isEqual(left, right):\n        if left == None and right == None:\n            return True\n        if right == None and left != None:\n            return False\n        if left == None and right != None:\n            return False\n        return (\n            left.value == right.value",
        "detail": "wk19.sprint-prep.prac.gists.isSubtree",
        "documentation": {}
    },
    {
        "label": "isEqual",
        "kind": 2,
        "importPath": "wk19.sprint-prep.prac.gists.isTreeSymmetric",
        "description": "wk19.sprint-prep.prac.gists.isTreeSymmetric",
        "peekOfCode": "def isEqual(left, right):\n    if left == None and right == None:\n        return True\n    if right == None and left != None:\n        return False\n    if left == None and right != None:\n        return False\n    if left.value != right.value:\n        return False\n    return isEqual(left.right, right.left) and isEqual(left.left, right.right)",
        "detail": "wk19.sprint-prep.prac.gists.isTreeSymmetric",
        "documentation": {}
    },
    {
        "label": "isTreeSymmetric",
        "kind": 2,
        "importPath": "wk19.sprint-prep.prac.gists.isTreeSymmetric",
        "description": "wk19.sprint-prep.prac.gists.isTreeSymmetric",
        "peekOfCode": "def isTreeSymmetric(t):\n    if t == None:\n        return True\n    return isEqual(t.left, t.right)",
        "detail": "wk19.sprint-prep.prac.gists.isTreeSymmetric",
        "documentation": {}
    },
    {
        "label": "kthSmallestInBST",
        "kind": 2,
        "importPath": "wk19.sprint-prep.prac.gists.kthSmallestInBST",
        "description": "wk19.sprint-prep.prac.gists.kthSmallestInBST",
        "peekOfCode": "def kthSmallestInBST(t, k):\n    def inorder(r):\n        return inorder(r.left) + [r.value] + inorder(r.right) if r else []\n    return inorder(t)[k - 1]",
        "detail": "wk19.sprint-prep.prac.gists.kthSmallestInBST",
        "documentation": {}
    },
    {
        "label": "mergeTwoLinkedLists",
        "kind": 2,
        "importPath": "wk19.sprint-prep.prac.gists.mergeTwoLinkedLists",
        "description": "wk19.sprint-prep.prac.gists.mergeTwoLinkedLists",
        "peekOfCode": "def mergeTwoLinkedLists(l1, l2):\n    if l1 == None and l2 == None:\n        return None\n    merged = ListNode(None)\n    ret = merged\n    # prev = merged.value\n    while l1 != None or l2 != None:\n        if l1 != None:\n            if l2 == None and l1.next == None:\n                merged.value = l1.value",
        "detail": "wk19.sprint-prep.prac.gists.mergeTwoLinkedLists",
        "documentation": {}
    },
    {
        "label": "removeKFromList",
        "kind": 2,
        "importPath": "wk19.sprint-prep.prac.gists.removeKFromList",
        "description": "wk19.sprint-prep.prac.gists.removeKFromList",
        "peekOfCode": "def removeKFromList(l, k):\n    if l == None:\n        return l\n    while l != None and l.value == k:\n        l = l.next\n    n = l\n    while n != None and n.next != None:\n        if n.next.value == k:\n            n.next = n.next.next\n        else:",
        "detail": "wk19.sprint-prep.prac.gists.removeKFromList",
        "documentation": {}
    },
    {
        "label": "reverseList",
        "kind": 2,
        "importPath": "wk19.sprint-prep.prac.gists.reverseNodesInKGroups",
        "description": "wk19.sprint-prep.prac.gists.reverseNodesInKGroups",
        "peekOfCode": "def reverseList(head, tail):\n    prev = None\n    while prev != tail:\n        prev, prev.next, head = head, prev, head.next\n    return prev\ndef reverseNodesInKGroups(l, k):\n    if k < 2:\n        return l\n    p = ListNode(-1)\n    p.next = l",
        "detail": "wk19.sprint-prep.prac.gists.reverseNodesInKGroups",
        "documentation": {}
    },
    {
        "label": "reverseNodesInKGroups",
        "kind": 2,
        "importPath": "wk19.sprint-prep.prac.gists.reverseNodesInKGroups",
        "description": "wk19.sprint-prep.prac.gists.reverseNodesInKGroups",
        "peekOfCode": "def reverseNodesInKGroups(l, k):\n    if k < 2:\n        return l\n    p = ListNode(-1)\n    p.next = l\n    ret = p\n    while True:\n        flag = True\n        tmp = p\n        for i in range(k):",
        "detail": "wk19.sprint-prep.prac.gists.reverseNodesInKGroups",
        "documentation": {}
    },
    {
        "label": "rotateImage",
        "kind": 2,
        "importPath": "wk19.sprint-prep.prac.gists.rotateImage",
        "description": "wk19.sprint-prep.prac.gists.rotateImage",
        "peekOfCode": "def rotateImage(a):\n    w = len(a)\n    h = w\n    img = [0] * h\n    for col in range(h):\n        img_row = [0] * w\n        for row in range(w):\n            img_row[h - row - 1] = a[row][col]\n        img[col] = img_row\n    return img",
        "detail": "wk19.sprint-prep.prac.gists.rotateImage",
        "documentation": {}
    },
    {
        "label": "sudoku2",
        "kind": 2,
        "importPath": "wk19.sprint-prep.prac.gists.sudoku2",
        "description": "wk19.sprint-prep.prac.gists.sudoku2",
        "peekOfCode": "def sudoku2(grid):\n    # test row\n    tab = [[False for col in range(9)] for row in range(9)]\n    cols = [[False for col in range(9)] for row in range(9)]\n    rows = [[False for col in range(9)] for row in range(9)]\n    for r in range(9):\n        for c in range(9):\n            if grid[r][c] == \".\":\n                continue\n            v = int(grid[r][c]) - 1",
        "detail": "wk19.sprint-prep.prac.gists.sudoku2",
        "documentation": {}
    },
    {
        "label": "LinkedListNode",
        "kind": 6,
        "importPath": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "description": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "peekOfCode": "class LinkedListNode:\n  \"\"\"\n    Simple Singly Linked List Node Class\n    value -> int\n    next -> LinkedListNode\n  \"\"\"\n  def __init__(self, value):\n    self.value = value\n    self.next = None\n  def add_node(self, value):",
        "detail": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "documentation": {}
    },
    {
        "label": "LinkedListNode",
        "kind": 6,
        "importPath": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "description": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "peekOfCode": "class LinkedListNode:\n  \"\"\"\n    Simple Doubly Linked List Node Class\n    value -> int\n    next -> LinkedListNode\n    prev -> LinkedListNode\n  \"\"\"\n  def __init__(self, value):\n    self.value = value\n    self.next = None",
        "detail": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "documentation": {}
    },
    {
        "label": "LinkedListNode",
        "kind": 6,
        "importPath": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "description": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "peekOfCode": "class LinkedListNode():\n    def __init__(self, value):\n        self.value = value\n        self.next  = None\ndef reverse(head_of_list):\n  current = head_of_list\n  prev = None\n  next = None\n  while current:\n    next = current.next",
        "detail": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "documentation": {}
    },
    {
        "label": "HashTableEntry",
        "kind": 6,
        "importPath": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "description": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "peekOfCode": "class HashTableEntry:\n    \"\"\"\n    Linked List hash table key/value pair\n    \"\"\"\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.next = None\n# Hash table can't have fewer than this many slots\nMIN_CAPACITY = 8",
        "detail": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "documentation": {}
    },
    {
        "label": "HashTable",
        "kind": 6,
        "importPath": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "description": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "peekOfCode": "class HashTable:\n    \"\"\"\n    A hash table that with `capacity` buckets\n    that accepts string keys\n    Implement this.\n    \"\"\"\n    def __init__(self, capacity):\n                self.capacity = capacity  # Number of buckets in the hash table\n        self.storage = [None] * capacity\n        self.item_count = 0",
        "detail": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "documentation": {}
    },
    {
        "label": "print_ll",
        "kind": 2,
        "importPath": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "description": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "peekOfCode": "def print_ll(linked_list_node):\n  current = linked_list_node\n  while current is not None:\n    print(current.value)\n    current = current.next\ndef add_to_ll_storage(linked_list_node):\n  current = linked_list_node\n  while current is not None:\n    ll_storage.append(current)\n    current = current.next",
        "detail": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "documentation": {}
    },
    {
        "label": "add_to_ll_storage",
        "kind": 2,
        "importPath": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "description": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "peekOfCode": "def add_to_ll_storage(linked_list_node):\n  current = linked_list_node\n  while current is not None:\n    ll_storage.append(current)\n    current = current.next\nL1.add_node(12)\nprint_ll(L1)\nL1.add_node(24)\nprint()\nprint_ll(L1)",
        "detail": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "documentation": {}
    },
    {
        "label": "reverse",
        "kind": 2,
        "importPath": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "description": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "peekOfCode": "def reverse(head_of_list):\n  current = head_of_list\n  prev = None\n  next = None\n  while current:\n    next = current.next\n    current.next = prev\n    prev = current\n    current = next\n  return prev",
        "detail": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "documentation": {}
    },
    {
        "label": "L1",
        "kind": 5,
        "importPath": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "description": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "peekOfCode": "L1 = Node(34)\nL1.next = Node(45)\nL1.next.next = Node(90)\n# while the current node is not none\n  # do something with the data\n  # traverse to next node\nL1 = [34]-> [45]-> [90] -> None\nNode(45)\nNode(90)\n```",
        "detail": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "documentation": {}
    },
    {
        "label": "L1.next",
        "kind": 5,
        "importPath": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "description": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "peekOfCode": "L1.next = Node(45)\nL1.next.next = Node(90)\n# while the current node is not none\n  # do something with the data\n  # traverse to next node\nL1 = [34]-> [45]-> [90] -> None\nNode(45)\nNode(90)\n```\n\"\"\"",
        "detail": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "documentation": {}
    },
    {
        "label": "L1.next.next",
        "kind": 5,
        "importPath": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "description": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "peekOfCode": "L1.next.next = Node(90)\n# while the current node is not none\n  # do something with the data\n  # traverse to next node\nL1 = [34]-> [45]-> [90] -> None\nNode(45)\nNode(90)\n```\n\"\"\"\nclass LinkedListNode:",
        "detail": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "documentation": {}
    },
    {
        "label": "L1",
        "kind": 5,
        "importPath": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "description": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "peekOfCode": "L1 = [34]-> [45]-> [90] -> None\nNode(45)\nNode(90)\n```\n\"\"\"\nclass LinkedListNode:\n  \"\"\"\n    Simple Singly Linked List Node Class\n    value -> int\n    next -> LinkedListNode",
        "detail": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "documentation": {}
    },
    {
        "label": "ll_storage",
        "kind": 5,
        "importPath": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "description": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "peekOfCode": "ll_storage = []\nL1 = LinkedListNode(34)\nL1.next = LinkedListNode(45)\nL1.next.next = LinkedListNode(90)\ndef print_ll(linked_list_node):\n  current = linked_list_node\n  while current is not None:\n    print(current.value)\n    current = current.next\ndef add_to_ll_storage(linked_list_node):",
        "detail": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "documentation": {}
    },
    {
        "label": "L1",
        "kind": 5,
        "importPath": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "description": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "peekOfCode": "L1 = LinkedListNode(34)\nL1.next = LinkedListNode(45)\nL1.next.next = LinkedListNode(90)\ndef print_ll(linked_list_node):\n  current = linked_list_node\n  while current is not None:\n    print(current.value)\n    current = current.next\ndef add_to_ll_storage(linked_list_node):\n  current = linked_list_node",
        "detail": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "documentation": {}
    },
    {
        "label": "L1.next",
        "kind": 5,
        "importPath": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "description": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "peekOfCode": "L1.next = LinkedListNode(45)\nL1.next.next = LinkedListNode(90)\ndef print_ll(linked_list_node):\n  current = linked_list_node\n  while current is not None:\n    print(current.value)\n    current = current.next\ndef add_to_ll_storage(linked_list_node):\n  current = linked_list_node\n  while current is not None:",
        "detail": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "documentation": {}
    },
    {
        "label": "L1.next.next",
        "kind": 5,
        "importPath": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "description": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "peekOfCode": "L1.next.next = LinkedListNode(90)\ndef print_ll(linked_list_node):\n  current = linked_list_node\n  while current is not None:\n    print(current.value)\n    current = current.next\ndef add_to_ll_storage(linked_list_node):\n  current = linked_list_node\n  while current is not None:\n    ll_storage.append(current)",
        "detail": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "documentation": {}
    },
    {
        "label": "MIN_CAPACITY",
        "kind": 5,
        "importPath": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "description": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "peekOfCode": "MIN_CAPACITY = 8\n[\n 0[\"Lou\", 41] -> [\"Bob\", 41] -> None,\n 1[\"Steve\", 41] -> None,\n 2[\"Jen\", 41] -> None,\n 3[\"Dave\", 41] -> None,\n 4None,\n 5[\"Hector\", 34]-> None,\n 6[\"Lisa\", 41] -> None,\n 7None,",
        "detail": "wk19.sprint-prep.prac.pracprac.copy_of_linked_lists",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "wk19.sprint-prep.prac.pracprac.linked-list",
        "description": "wk19.sprint-prep.prac.pracprac.linked-list",
        "peekOfCode": "class Node:\n    # Constructor to initialize the node object\n    def __init__(self, data):\n        self.data = data\n        self.next = None\nclass LinkedList:\n    # Function to initialize head\n    def __init__(self):\n        self.head = None\n    # Function to reverse the linked list",
        "detail": "wk19.sprint-prep.prac.pracprac.linked-list",
        "documentation": {}
    },
    {
        "label": "LinkedList",
        "kind": 6,
        "importPath": "wk19.sprint-prep.prac.pracprac.linked-list",
        "description": "wk19.sprint-prep.prac.pracprac.linked-list",
        "peekOfCode": "class LinkedList:\n    # Function to initialize head\n    def __init__(self):\n        self.head = None\n    # Function to reverse the linked list\n    def reverse(self):\n        prev = None\n        current = self.head\n        while current is not None:\n            next = current.next",
        "detail": "wk19.sprint-prep.prac.pracprac.linked-list",
        "documentation": {}
    },
    {
        "label": "llist",
        "kind": 5,
        "importPath": "wk19.sprint-prep.prac.pracprac.linked-list",
        "description": "wk19.sprint-prep.prac.pracprac.linked-list",
        "peekOfCode": "llist = LinkedList()\nllist.push(20)\nllist.push(4)\nllist.push(15)\nllist.push(85)\nprint(\"Given Linked List\")\nllist.printList()\nllist.reverse()\nprint(\"\\nReversed Linked List\")\nllist.printList()",
        "detail": "wk19.sprint-prep.prac.pracprac.linked-list",
        "documentation": {}
    },
    {
        "label": "Tree",
        "kind": 6,
        "importPath": "wk19.sprint-prep.prac.pracprac.scrap",
        "description": "wk19.sprint-prep.prac.pracprac.scrap",
        "peekOfCode": "class Tree(object):\n    def __init__(self, x):\n        self.value = x\n        self.left = None\n        self.right = None\ndef csBSTRangeSum(root, lower, upper):\n    if not root:\n        return 0\n    res = 0\n    if lower <= root.value <= upper:",
        "detail": "wk19.sprint-prep.prac.pracprac.scrap",
        "documentation": {}
    },
    {
        "label": "csBSTRangeSum",
        "kind": 2,
        "importPath": "wk19.sprint-prep.prac.pracprac.scrap",
        "description": "wk19.sprint-prep.prac.pracprac.scrap",
        "peekOfCode": "def csBSTRangeSum(root, lower, upper):\n    if not root:\n        return 0\n    res = 0\n    if lower <= root.value <= upper:\n        res += root.value\n        res += csBSTRangeSum(root.left, lower, upper)\n        res += csBSTRangeSum(root.right, lower, upper)\n    elif root.value < lower:\n        res += csBSTRangeSum(root.right, lower, upper)",
        "detail": "wk19.sprint-prep.prac.pracprac.scrap",
        "documentation": {}
    },
    {
        "label": "Tree",
        "kind": 6,
        "importPath": "wk19.sprint-prep.prac.csBinaryTreelnvert",
        "description": "wk19.sprint-prep.prac.csBinaryTreelnvert",
        "peekOfCode": "class Tree(object):\n    def __init__(self, x):\n        self.value = x\n        self.left = None\n        self.right = None\ndef csBinaryTreeInvert(root):\n    if not root or (not root.left and not root.right):\n        return root\n    tmp = root.left\n    root.left = root.right",
        "detail": "wk19.sprint-prep.prac.csBinaryTreelnvert",
        "documentation": {}
    },
    {
        "label": "csBinaryTreeInvert",
        "kind": 2,
        "importPath": "wk19.sprint-prep.prac.csBinaryTreelnvert",
        "description": "wk19.sprint-prep.prac.csBinaryTreelnvert",
        "peekOfCode": "def csBinaryTreeInvert(root):\n    if not root or (not root.left and not root.right):\n        return root\n    tmp = root.left\n    root.left = root.right\n    root.right = tmp\n    csBinaryTreeInvert(root.left)\n    csBinaryTreeInvert(root.right)\n    return root",
        "detail": "wk19.sprint-prep.prac.csBinaryTreelnvert",
        "documentation": {}
    },
    {
        "label": "Tree",
        "kind": 6,
        "importPath": "wk19.sprint-prep.prac.csBSTRangeSum",
        "description": "wk19.sprint-prep.prac.csBSTRangeSum",
        "peekOfCode": "class Tree(object):\n    def __init__(self, x):\n        self.value = x\n        self.left = None\n        self.right = None\ndef csBSTRangeSum(root, lower, upper):\n    if not root:\n        return 0\n    res = 0\n    if lower <= root.value <= upper:",
        "detail": "wk19.sprint-prep.prac.csBSTRangeSum",
        "documentation": {}
    },
    {
        "label": "csBSTRangeSum",
        "kind": 2,
        "importPath": "wk19.sprint-prep.prac.csBSTRangeSum",
        "description": "wk19.sprint-prep.prac.csBSTRangeSum",
        "peekOfCode": "def csBSTRangeSum(root, lower, upper):\n    if not root:\n        return 0\n    res = 0\n    if lower <= root.value <= upper:\n        res += root.value\n        res += csBSTRangeSum(root.left, lower, upper)\n        res += csBSTRangeSum(root.right, lower, upper)\n    elif root.value < lower:\n        res += csBSTRangeSum(root.right, lower, upper)",
        "detail": "wk19.sprint-prep.prac.csBSTRangeSum",
        "documentation": {}
    },
    {
        "label": "reverseLinkedList",
        "kind": 2,
        "importPath": "wk19.sprint-prep.prac.reverseLinkedList",
        "description": "wk19.sprint-prep.prac.reverseLinkedList",
        "peekOfCode": "def reverseLinkedList(l):\n    prev = None\n    current = l\n    while current:\n        next = current.next\n        current.next = prev\n        prev = current\n        current = next\n    return prev",
        "detail": "wk19.sprint-prep.prac.reverseLinkedList",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "wk19.test.d1.hw.ref.script",
        "description": "wk19.test.d1.hw.ref.script",
        "peekOfCode": "class Node:\n    def __init__(self, data=None, next=None):\n        self.data = data\n        self.next = next\n# Helper function to print a given linked list\ndef printList(head):\n    ptr = head\n    while ptr:\n        print(ptr.data, end=\" —> \")\n        ptr = ptr.next",
        "detail": "wk19.test.d1.hw.ref.script",
        "documentation": {}
    },
    {
        "label": "printList",
        "kind": 2,
        "importPath": "wk19.test.d1.hw.ref.script",
        "description": "wk19.test.d1.hw.ref.script",
        "peekOfCode": "def printList(head):\n    ptr = head\n    while ptr:\n        print(ptr.data, end=\" —> \")\n        ptr = ptr.next\n    print(\"None\")\n# Function to insert a given node at its correct sorted position into\n# a given list sorted in increasing order\ndef sortedInsert(head, newNode):\n    # special case for the head end",
        "detail": "wk19.test.d1.hw.ref.script",
        "documentation": {}
    },
    {
        "label": "sortedInsert",
        "kind": 2,
        "importPath": "wk19.test.d1.hw.ref.script",
        "description": "wk19.test.d1.hw.ref.script",
        "peekOfCode": "def sortedInsert(head, newNode):\n    # special case for the head end\n    if head is None or head.data >= newNode.data:\n        newNode.next = head\n        head = newNode\n        return head\n    # Locate the node before the poof insertion\n    current = head\n    while current.next and current.next.data < newNode.data:\n        current = current.next",
        "detail": "wk19.test.d1.hw.ref.script",
        "documentation": {}
    },
    {
        "label": "csAlphanumericRestriction",
        "kind": 2,
        "importPath": "wk19.test.d1.hw.alpha",
        "description": "wk19.test.d1.hw.alpha",
        "peekOfCode": "def csAlphanumericRestriction(input_str): #c is every char in\ninput string\nis_numeric = False\nis_alpha = False\nfor c in input_str:\n% if c.isnumeric():\nis_numeric = True\nelif c.isalpha():\nis_alpha = True\nelse:",
        "detail": "wk19.test.d1.hw.alpha",
        "documentation": {}
    },
    {
        "label": "is_numeric",
        "kind": 5,
        "importPath": "wk19.test.d1.hw.alpha",
        "description": "wk19.test.d1.hw.alpha",
        "peekOfCode": "is_numeric = False\nis_alpha = False\nfor c in input_str:\n% if c.isnumeric():\nis_numeric = True\nelif c.isalpha():\nis_alpha = True\nelse:\n‘ return False\nreturn (is_numeric and not is_alpha) or (is_alpha and not",
        "detail": "wk19.test.d1.hw.alpha",
        "documentation": {}
    },
    {
        "label": "is_alpha",
        "kind": 5,
        "importPath": "wk19.test.d1.hw.alpha",
        "description": "wk19.test.d1.hw.alpha",
        "peekOfCode": "is_alpha = False\nfor c in input_str:\n% if c.isnumeric():\nis_numeric = True\nelif c.isalpha():\nis_alpha = True\nelse:\n‘ return False\nreturn (is_numeric and not is_alpha) or (is_alpha and not\nis_numeric)",
        "detail": "wk19.test.d1.hw.alpha",
        "documentation": {}
    },
    {
        "label": "is_numeric",
        "kind": 5,
        "importPath": "wk19.test.d1.hw.alpha",
        "description": "wk19.test.d1.hw.alpha",
        "peekOfCode": "is_numeric = True\nelif c.isalpha():\nis_alpha = True\nelse:\n‘ return False\nreturn (is_numeric and not is_alpha) or (is_alpha and not\nis_numeric)\nI",
        "detail": "wk19.test.d1.hw.alpha",
        "documentation": {}
    },
    {
        "label": "is_alpha",
        "kind": 5,
        "importPath": "wk19.test.d1.hw.alpha",
        "description": "wk19.test.d1.hw.alpha",
        "peekOfCode": "is_alpha = True\nelse:\n‘ return False\nreturn (is_numeric and not is_alpha) or (is_alpha and not\nis_numeric)\nI",
        "detail": "wk19.test.d1.hw.alpha",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "wk19.test.d1.hw.insertValueIntoSortedLinkedList",
        "description": "wk19.test.d1.hw.insertValueIntoSortedLinkedList",
        "peekOfCode": "class ListNode(object):  # def __init__(self, value):\n    def __init__(self, x):\n        self.value = x  # self.value = value\n        self.next = None  # self.next = None\ndef insertValueIntoSortedLinkedList(l, value):\n    head = l\n    new_item = ListNode(value)\n    if head is None:\n        new_item.next = head\n        head = new_item",
        "detail": "wk19.test.d1.hw.insertValueIntoSortedLinkedList",
        "documentation": {}
    },
    {
        "label": "insertValueIntoSortedLinkedList",
        "kind": 2,
        "importPath": "wk19.test.d1.hw.insertValueIntoSortedLinkedList",
        "description": "wk19.test.d1.hw.insertValueIntoSortedLinkedList",
        "peekOfCode": "def insertValueIntoSortedLinkedList(l, value):\n    head = l\n    new_item = ListNode(value)\n    if head is None:\n        new_item.next = head\n        head = new_item\n        return head\n    elif head.value >= new_item.value:\n        new_item.next = head\n        head = new_item",
        "detail": "wk19.test.d1.hw.insertValueIntoSortedLinkedList",
        "documentation": {}
    },
    {
        "label": "mergeTwoLinkedLists",
        "kind": 2,
        "importPath": "wk19.test.d1.hw.mergeTwoLinkedLists",
        "description": "wk19.test.d1.hw.mergeTwoLinkedLists",
        "peekOfCode": "def mergeTwoLinkedLists(l1, l2):\n    em = None\n    if l1 is None:\n        return l2\n    if l2 is None:\n        return l1\n    if l1.value <= l2.value:\n        startNode = ListNode(l1.value)\n        l1 = l1.next\n    else:",
        "detail": "wk19.test.d1.hw.mergeTwoLinkedLists",
        "documentation": {}
    },
    {
        "label": "LinkedListNode",
        "kind": 6,
        "importPath": "wk19.test.d1.linked_lists",
        "description": "wk19.test.d1.linked_lists",
        "peekOfCode": "class LinkedListNode:\n  \"\"\"\n    Simple Singly Linked List Node Class\n    value -> int\n    next -> LinkedListNode\n  \"\"\"\n  def __init__(self, value):\n    self.value = value\n    self.next = None\n  def add_node(self, value):",
        "detail": "wk19.test.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "LinkedListNode",
        "kind": 6,
        "importPath": "wk19.test.d1.linked_lists",
        "description": "wk19.test.d1.linked_lists",
        "peekOfCode": "class LinkedListNode:\n  \"\"\"\n    Simple Doubly Linked List Node Class\n    value -> int\n    next -> LinkedListNode\n    prev -> LinkedListNode\n  \"\"\"\n  def __init__(self, value):\n    self.value = value\n    self.next = None",
        "detail": "wk19.test.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "LinkedListNode",
        "kind": 6,
        "importPath": "wk19.test.d1.linked_lists",
        "description": "wk19.test.d1.linked_lists",
        "peekOfCode": "class LinkedListNode():\n    def __init__(self, value):\n        self.value = value\n        self.next  = None\ndef reverse(head_of_list):\n  current = head_of_list\n  prev = None\n  next = None\n  while current:\n    next = current.next",
        "detail": "wk19.test.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "HashTableEntry",
        "kind": 6,
        "importPath": "wk19.test.d1.linked_lists",
        "description": "wk19.test.d1.linked_lists",
        "peekOfCode": "class HashTableEntry:\n    \"\"\"\n    Linked List hash table key/value pair\n    \"\"\"\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.next = None\n# Hash table can't have fewer than this many slots\nMIN_CAPACITY = 8",
        "detail": "wk19.test.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "HashTable",
        "kind": 6,
        "importPath": "wk19.test.d1.linked_lists",
        "description": "wk19.test.d1.linked_lists",
        "peekOfCode": "class HashTable:\n    \"\"\"\n    A hash table that with `capacity` buckets\n    that accepts string keys\n    Implement this.\n    \"\"\"\n    def __init__(self, capacity):\n                self.capacity = capacity  # Number of buckets in the hash table\n        self.storage = [None] * capacity\n        self.item_count = 0",
        "detail": "wk19.test.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "print_ll",
        "kind": 2,
        "importPath": "wk19.test.d1.linked_lists",
        "description": "wk19.test.d1.linked_lists",
        "peekOfCode": "def print_ll(linked_list_node):\n  current = linked_list_node\n  while current is not None:\n    print(current.value)\n    current = current.next\ndef add_to_ll_storage(linked_list_node):\n  current = linked_list_node\n  while current is not None:\n    ll_storage.append(current)\n    current = current.next",
        "detail": "wk19.test.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "add_to_ll_storage",
        "kind": 2,
        "importPath": "wk19.test.d1.linked_lists",
        "description": "wk19.test.d1.linked_lists",
        "peekOfCode": "def add_to_ll_storage(linked_list_node):\n  current = linked_list_node\n  while current is not None:\n    ll_storage.append(current)\n    current = current.next\nL1.add_node(12)\nprint_ll(L1)\nL1.add_node(24)\nprint()\nprint_ll(L1)",
        "detail": "wk19.test.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "reverse",
        "kind": 2,
        "importPath": "wk19.test.d1.linked_lists",
        "description": "wk19.test.d1.linked_lists",
        "peekOfCode": "def reverse(head_of_list):\n  current = head_of_list\n  prev = None\n  next = None\n  while current:\n    next = current.next\n    current.next = prev\n    prev = current\n    current = next\n  return prev",
        "detail": "wk19.test.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "L1",
        "kind": 5,
        "importPath": "wk19.test.d1.linked_lists",
        "description": "wk19.test.d1.linked_lists",
        "peekOfCode": "L1 = Node(34)\nL1.next = Node(45)\nL1.next.next = Node(90)\n# while the current node is not none\n  # do something with the data\n  # traverse to next node\nL1 = [34]-> [45]-> [90] -> None\nNode(45)\nNode(90)\n```",
        "detail": "wk19.test.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "L1.next",
        "kind": 5,
        "importPath": "wk19.test.d1.linked_lists",
        "description": "wk19.test.d1.linked_lists",
        "peekOfCode": "L1.next = Node(45)\nL1.next.next = Node(90)\n# while the current node is not none\n  # do something with the data\n  # traverse to next node\nL1 = [34]-> [45]-> [90] -> None\nNode(45)\nNode(90)\n```\n\"\"\"",
        "detail": "wk19.test.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "L1.next.next",
        "kind": 5,
        "importPath": "wk19.test.d1.linked_lists",
        "description": "wk19.test.d1.linked_lists",
        "peekOfCode": "L1.next.next = Node(90)\n# while the current node is not none\n  # do something with the data\n  # traverse to next node\nL1 = [34]-> [45]-> [90] -> None\nNode(45)\nNode(90)\n```\n\"\"\"\nclass LinkedListNode:",
        "detail": "wk19.test.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "L1",
        "kind": 5,
        "importPath": "wk19.test.d1.linked_lists",
        "description": "wk19.test.d1.linked_lists",
        "peekOfCode": "L1 = [34]-> [45]-> [90] -> None\nNode(45)\nNode(90)\n```\n\"\"\"\nclass LinkedListNode:\n  \"\"\"\n    Simple Singly Linked List Node Class\n    value -> int\n    next -> LinkedListNode",
        "detail": "wk19.test.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "ll_storage",
        "kind": 5,
        "importPath": "wk19.test.d1.linked_lists",
        "description": "wk19.test.d1.linked_lists",
        "peekOfCode": "ll_storage = []\nL1 = LinkedListNode(34)\nL1.next = LinkedListNode(45)\nL1.next.next = LinkedListNode(90)\ndef print_ll(linked_list_node):\n  current = linked_list_node\n  while current is not None:\n    print(current.value)\n    current = current.next\ndef add_to_ll_storage(linked_list_node):",
        "detail": "wk19.test.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "L1",
        "kind": 5,
        "importPath": "wk19.test.d1.linked_lists",
        "description": "wk19.test.d1.linked_lists",
        "peekOfCode": "L1 = LinkedListNode(34)\nL1.next = LinkedListNode(45)\nL1.next.next = LinkedListNode(90)\ndef print_ll(linked_list_node):\n  current = linked_list_node\n  while current is not None:\n    print(current.value)\n    current = current.next\ndef add_to_ll_storage(linked_list_node):\n  current = linked_list_node",
        "detail": "wk19.test.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "L1.next",
        "kind": 5,
        "importPath": "wk19.test.d1.linked_lists",
        "description": "wk19.test.d1.linked_lists",
        "peekOfCode": "L1.next = LinkedListNode(45)\nL1.next.next = LinkedListNode(90)\ndef print_ll(linked_list_node):\n  current = linked_list_node\n  while current is not None:\n    print(current.value)\n    current = current.next\ndef add_to_ll_storage(linked_list_node):\n  current = linked_list_node\n  while current is not None:",
        "detail": "wk19.test.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "L1.next.next",
        "kind": 5,
        "importPath": "wk19.test.d1.linked_lists",
        "description": "wk19.test.d1.linked_lists",
        "peekOfCode": "L1.next.next = LinkedListNode(90)\ndef print_ll(linked_list_node):\n  current = linked_list_node\n  while current is not None:\n    print(current.value)\n    current = current.next\ndef add_to_ll_storage(linked_list_node):\n  current = linked_list_node\n  while current is not None:\n    ll_storage.append(current)",
        "detail": "wk19.test.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "MIN_CAPACITY",
        "kind": 5,
        "importPath": "wk19.test.d1.linked_lists",
        "description": "wk19.test.d1.linked_lists",
        "peekOfCode": "MIN_CAPACITY = 8\n[\n 0[\"Lou\", 41] -> [\"Bob\", 41] -> None,\n 1[\"Steve\", 41] -> None,\n 2[\"Jen\", 41] -> None,\n 3[\"Dave\", 41] -> None,\n 4None,\n 5[\"Hector\", 34]-> None,\n 6[\"Lisa\", 41] -> None,\n 7None,",
        "detail": "wk19.test.d1.linked_lists",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": "wk19.test.d2.notes.qandstack",
        "description": "wk19.test.d2.notes.qandstack",
        "peekOfCode": "class Stack:\n  def __init__(self):\n    self.storage = []\n  def push(self, item):\n    \"\"\"\n    push the item on to the top of the stack\n    \"\"\"\n    self.storage.append(item)\n  def pop(self):\n    \"\"\"",
        "detail": "wk19.test.d2.notes.qandstack",
        "documentation": {}
    },
    {
        "label": "Queue",
        "kind": 6,
        "importPath": "wk19.test.d2.notes.qandstack",
        "description": "wk19.test.d2.notes.qandstack",
        "peekOfCode": "class Queue:\n    def __init__(self):\n        self.storage = []\n    def enqueue(self, item):\n        self.storage.append(item)\n    def pop(self):\n        if len(self.storage) > 0:\n            return self.storage.pop()\n        return \"The Stack is Empty\"\nclass Stack:",
        "detail": "wk19.test.d2.notes.qandstack",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": "wk19.test.d2.notes.qandstack",
        "description": "wk19.test.d2.notes.qandstack",
        "peekOfCode": "class Stack:\n    def __init__(self):\n        self.items = []\n    def push(self, item):\n        self.items.append(item)\n    def pop(self):\n        if not self.items:\n            return None\n        return self.items.pop()\n    def peek(self):",
        "detail": "wk19.test.d2.notes.qandstack",
        "documentation": {}
    },
    {
        "label": "MaxStack",
        "kind": 6,
        "importPath": "wk19.test.d2.notes.qandstack",
        "description": "wk19.test.d2.notes.qandstack",
        "peekOfCode": "class MaxStack:\n    def __init__(self):\n    def push(self, item):\n    def pop(self):\n    def get_max(self):\nclass Stack:\n    def __init__(self):\n        self.data = []\n    def push(self, item):\n        self.data.append(item)",
        "detail": "wk19.test.d2.notes.qandstack",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": "wk19.test.d2.notes.qandstack",
        "description": "wk19.test.d2.notes.qandstack",
        "peekOfCode": "class Stack:\n    def __init__(self):\n        self.data = []\n    def push(self, item):\n        self.data.append(item)\n    def pop(self):\n        if len(self.data) > 0:\n            return self.data.pop()\n        return \"The stack is empty\"\nclass QueueTwoStacks:",
        "detail": "wk19.test.d2.notes.qandstack",
        "documentation": {}
    },
    {
        "label": "QueueTwoStacks",
        "kind": 6,
        "importPath": "wk19.test.d2.notes.qandstack",
        "description": "wk19.test.d2.notes.qandstack",
        "peekOfCode": "class QueueTwoStacks:\n    def __init__(self):\n    def enqueue(self, item):\n    def dequeue(self):",
        "detail": "wk19.test.d2.notes.qandstack",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "wk19.test.d2.notes.qandstack",
        "description": "wk19.test.d2.notes.qandstack",
        "peekOfCode": "s = Stack()\ns.push(10)\ns.push(20)\ns.push(30)\nl = []\nl.append(s.pop())\nl.append(s.pop())\nl.append(s.pop())\nprint(l)\nclass Queue:",
        "detail": "wk19.test.d2.notes.qandstack",
        "documentation": {}
    },
    {
        "label": "l",
        "kind": 5,
        "importPath": "wk19.test.d2.notes.qandstack",
        "description": "wk19.test.d2.notes.qandstack",
        "peekOfCode": "l = []\nl.append(s.pop())\nl.append(s.pop())\nl.append(s.pop())\nprint(l)\nclass Queue:\n    def __init__(self):\n        self.storage = []\n    def enqueue(self, item):\n        self.storage.append(item)",
        "detail": "wk19.test.d2.notes.qandstack",
        "documentation": {}
    },
    {
        "label": "isZigzag",
        "kind": 2,
        "importPath": "wk20.CGA_SPRINT.isZigZag",
        "description": "wk20.CGA_SPRINT.isZigZag",
        "peekOfCode": "def isZigzag(numbers):",
        "detail": "wk20.CGA_SPRINT.isZigZag",
        "documentation": {}
    },
    {
        "label": "rotatedRectSum",
        "kind": 2,
        "importPath": "wk20.CGA_SPRINT.rotatedRectSum",
        "description": "wk20.CGA_SPRINT.rotatedRectSum",
        "peekOfCode": "def rotatedRectSum(matrix, a, b):",
        "detail": "wk20.CGA_SPRINT.rotatedRectSum",
        "documentation": {}
    },
    {
        "label": "streetLights",
        "kind": 2,
        "importPath": "wk20.CGA_SPRINT.streetLights",
        "description": "wk20.CGA_SPRINT.streetLights",
        "peekOfCode": "def streetLights(n, lights):",
        "detail": "wk20.CGA_SPRINT.streetLights",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "wk20.d1.hw.findPathsFromA2B",
        "description": "wk20.d1.hw.findPathsFromA2B",
        "peekOfCode": "def dfs(s):\n    # Append the node in path\n    # and set visited\n    path.append(s)\n    visited[s] = True\n    # Path started with a node\n    # having in-degree 0 and\n    # current node has out-degree 0,\n    # print current path\n    if outdeg0[s] and indeg0[path[0]]:",
        "detail": "wk20.d1.hw.findPathsFromA2B",
        "documentation": {}
    },
    {
        "label": "csFindAllPathsFromAToB",
        "kind": 2,
        "importPath": "wk20.d1.hw.findPathsFromA2B",
        "description": "wk20.d1.hw.findPathsFromA2B",
        "peekOfCode": "def csFindAllPathsFromAToB(graph):\n    for i in range(n):\n        # for each node with in-degree 0\n        # print all possible paths\n        if indeg0[i] and adj[i]:\n            path = []\n            visited = [False] * (n + 1)\n            dfs(i)\n# Driver code\nfrom collections import defaultdict",
        "detail": "wk20.d1.hw.findPathsFromA2B",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "wk20.d1.hw.findPathsFromA2B",
        "description": "wk20.d1.hw.findPathsFromA2B",
        "peekOfCode": "n = 6\n# set all nodes unvisited\nvisited = [False] * (n + 1)\npath = []\n# edges = (a, b): a -> b\nedges = [(5, 0), (5, 2), (2, 3), (4, 0), (4, 1), (3, 1)]\n# adjacency list for nodes\nadj = defaultdict(list)\n# indeg0 and outdeg0 arrays\nindeg0 = [True] * n",
        "detail": "wk20.d1.hw.findPathsFromA2B",
        "documentation": {}
    },
    {
        "label": "visited",
        "kind": 5,
        "importPath": "wk20.d1.hw.findPathsFromA2B",
        "description": "wk20.d1.hw.findPathsFromA2B",
        "peekOfCode": "visited = [False] * (n + 1)\npath = []\n# edges = (a, b): a -> b\nedges = [(5, 0), (5, 2), (2, 3), (4, 0), (4, 1), (3, 1)]\n# adjacency list for nodes\nadj = defaultdict(list)\n# indeg0 and outdeg0 arrays\nindeg0 = [True] * n\noutdeg0 = [True] * n\nfor edge in edges:",
        "detail": "wk20.d1.hw.findPathsFromA2B",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "wk20.d1.hw.findPathsFromA2B",
        "description": "wk20.d1.hw.findPathsFromA2B",
        "peekOfCode": "path = []\n# edges = (a, b): a -> b\nedges = [(5, 0), (5, 2), (2, 3), (4, 0), (4, 1), (3, 1)]\n# adjacency list for nodes\nadj = defaultdict(list)\n# indeg0 and outdeg0 arrays\nindeg0 = [True] * n\noutdeg0 = [True] * n\nfor edge in edges:\n    u, v = edge[0], edge[1]",
        "detail": "wk20.d1.hw.findPathsFromA2B",
        "documentation": {}
    },
    {
        "label": "edges",
        "kind": 5,
        "importPath": "wk20.d1.hw.findPathsFromA2B",
        "description": "wk20.d1.hw.findPathsFromA2B",
        "peekOfCode": "edges = [(5, 0), (5, 2), (2, 3), (4, 0), (4, 1), (3, 1)]\n# adjacency list for nodes\nadj = defaultdict(list)\n# indeg0 and outdeg0 arrays\nindeg0 = [True] * n\noutdeg0 = [True] * n\nfor edge in edges:\n    u, v = edge[0], edge[1]\n    # u -> v\n    adj[u].append(v)",
        "detail": "wk20.d1.hw.findPathsFromA2B",
        "documentation": {}
    },
    {
        "label": "adj",
        "kind": 5,
        "importPath": "wk20.d1.hw.findPathsFromA2B",
        "description": "wk20.d1.hw.findPathsFromA2B",
        "peekOfCode": "adj = defaultdict(list)\n# indeg0 and outdeg0 arrays\nindeg0 = [True] * n\noutdeg0 = [True] * n\nfor edge in edges:\n    u, v = edge[0], edge[1]\n    # u -> v\n    adj[u].append(v)\n    # set indeg0[v] <- false\n    indeg0[v] = False",
        "detail": "wk20.d1.hw.findPathsFromA2B",
        "documentation": {}
    },
    {
        "label": "indeg0",
        "kind": 5,
        "importPath": "wk20.d1.hw.findPathsFromA2B",
        "description": "wk20.d1.hw.findPathsFromA2B",
        "peekOfCode": "indeg0 = [True] * n\noutdeg0 = [True] * n\nfor edge in edges:\n    u, v = edge[0], edge[1]\n    # u -> v\n    adj[u].append(v)\n    # set indeg0[v] <- false\n    indeg0[v] = False\n    # set outdeg0[u] <- false\n    outdeg0[u] = False",
        "detail": "wk20.d1.hw.findPathsFromA2B",
        "documentation": {}
    },
    {
        "label": "outdeg0",
        "kind": 5,
        "importPath": "wk20.d1.hw.findPathsFromA2B",
        "description": "wk20.d1.hw.findPathsFromA2B",
        "peekOfCode": "outdeg0 = [True] * n\nfor edge in edges:\n    u, v = edge[0], edge[1]\n    # u -> v\n    adj[u].append(v)\n    # set indeg0[v] <- false\n    indeg0[v] = False\n    # set outdeg0[u] <- false\n    outdeg0[u] = False\nprint(\"All possible paths:\")",
        "detail": "wk20.d1.hw.findPathsFromA2B",
        "documentation": {}
    },
    {
        "label": "DFS",
        "kind": 2,
        "importPath": "wk20.d1.hw.friend-circle",
        "description": "wk20.d1.hw.friend-circle",
        "peekOfCode": "def DFS(friendships, n, visited, v):\n    for x in range(n):\n        # A student is in the friend circle if he/she is friendships with the student represented by\n        # studentIndex and if he/she is not already in a friend circle\n        if friendships[v, x] and visited[x] == 0:\n            if x != v:\n                visited[x] = 1\n                DFS(friendships, n, visited, x)\nn = 4\ndef csFriendCircles(friendships):",
        "detail": "wk20.d1.hw.friend-circle",
        "documentation": {}
    },
    {
        "label": "csFriendCircles",
        "kind": 2,
        "importPath": "wk20.d1.hw.friend-circle",
        "description": "wk20.d1.hw.friend-circle",
        "peekOfCode": "def csFriendCircles(friendships):\n    numCircles = 0  # Number of friend circles\n    # Keep track of whether a student is already in a friend circle\n    visited = np.zeros((n))\n    # Start with the first student and recursively find all other students in his/her\n    # friend circle. Then, do the same thing for the next student that is not already\n    # in a friend circle. Repeat until all students are in a friend circle.\n    for i in range(n):\n        if visited[i] == 0:\n            visited[i] = 1",
        "detail": "wk20.d1.hw.friend-circle",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "wk20.d1.hw.friend-circle",
        "description": "wk20.d1.hw.friend-circle",
        "peekOfCode": "n = 4\ndef csFriendCircles(friendships):\n    numCircles = 0  # Number of friend circles\n    # Keep track of whether a student is already in a friend circle\n    visited = np.zeros((n))\n    # Start with the first student and recursively find all other students in his/her\n    # friend circle. Then, do the same thing for the next student that is not already\n    # in a friend circle. Repeat until all students are in a friend circle.\n    for i in range(n):\n        if visited[i] == 0:",
        "detail": "wk20.d1.hw.friend-circle",
        "documentation": {}
    },
    {
        "label": "first_not_repeating_character",
        "kind": 2,
        "importPath": "wk20.sprint-prep.first-not-repeating.first-non-repeating",
        "description": "wk20.sprint-prep.first-not-repeating.first-non-repeating",
        "peekOfCode": "def first_not_repeating_character(s):\n    c = {}\n    for i in s:\n        c[i] = c.get(i, 0) + 1\n    return next((i for i in s if c[i] == 1), \"_\")",
        "detail": "wk20.sprint-prep.first-not-repeating.first-non-repeating",
        "documentation": {}
    },
    {
        "label": "uncover_spy",
        "kind": 2,
        "importPath": "wk20.sprint-prep.trust.scrap",
        "description": "wk20.sprint-prep.trust.scrap",
        "peekOfCode": "def uncover_spy(n, trust):\n    degrees = [0] * n\n    for i, j in trust:\n        degrees[i - 1] -= 1\n        degrees[j - 1] += 1\n    for i in range(len(degrees)):\n        if degrees[i] == n - 1:\n            return i + 1\n    return -1",
        "detail": "wk20.sprint-prep.trust.scrap",
        "documentation": {}
    },
    {
        "label": "uncover_spy",
        "kind": 2,
        "importPath": "wk20.sprint-prep.trust.undercover-spy",
        "description": "wk20.sprint-prep.trust.undercover-spy",
        "peekOfCode": "def uncover_spy(n, trust):\n    trusted = [0 for _ in range(n + 1)]\n    for i, j in trust:\n        trusted[i] -= 1\n        trusted[j] += 1\n        for i in range(1, len(trusted)):\n            if trusted[i] == n - 1:\n                return i\n            return -1",
        "detail": "wk20.sprint-prep.trust.undercover-spy",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "wk20.sprint-prep.condense_linked_list",
        "description": "wk20.sprint-prep.condense_linked_list",
        "peekOfCode": "class ListNode(object):\n  def __init__(self, x):\n    self.value = x\n    self.next = None\ndef condense_linked_list(node):\n   root = ListNode(0)\n   root.next = head\n         p1 = head\n            if p1 is None:\n            return root.next",
        "detail": "wk20.sprint-prep.condense_linked_list",
        "documentation": {}
    },
    {
        "label": "condense_linked_list",
        "kind": 2,
        "importPath": "wk20.sprint-prep.condense_linked_list",
        "description": "wk20.sprint-prep.condense_linked_list",
        "peekOfCode": "def condense_linked_list(node):\n   root = ListNode(0)\n   root.next = head\n         p1 = head\n            if p1 is None:\n            return root.next\n        p = p1.next\n        if p is None:\n            return root.next\n        while p:",
        "detail": "wk20.sprint-prep.condense_linked_list",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "wk20.sprint-prep.scrap",
        "description": "wk20.sprint-prep.scrap",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, x):\n        self.value = x\n        self.next = None\ndef condense_linked_list(node):\n    root = ListNode(0)\n    root.next = node.next\n    p1 = node.next\n    if p1 is None:\n        return root.next",
        "detail": "wk20.sprint-prep.scrap",
        "documentation": {}
    },
    {
        "label": "condense_linked_list",
        "kind": 2,
        "importPath": "wk20.sprint-prep.scrap",
        "description": "wk20.sprint-prep.scrap",
        "peekOfCode": "def condense_linked_list(node):\n    root = ListNode(0)\n    root.next = node.next\n    p1 = node.next\n    if p1 is None:\n        return root.next\n    p = p1.next\n    if p is None:\n        return root.next\n    while p:",
        "detail": "wk20.sprint-prep.scrap",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "wk20.sprint-prep.scrap2",
        "description": "wk20.sprint-prep.scrap2",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, x):\n        self.value = x\n        self.next = None\ndef condense_linked_list(node):\n    root = ListNode(node.value)\n    root.next = node\n    p1 = root\n    if p1 is None:\n        return root.next",
        "detail": "wk20.sprint-prep.scrap2",
        "documentation": {}
    },
    {
        "label": "condense_linked_list",
        "kind": 2,
        "importPath": "wk20.sprint-prep.scrap2",
        "description": "wk20.sprint-prep.scrap2",
        "peekOfCode": "def condense_linked_list(node):\n    root = ListNode(node.value)\n    root.next = node\n    p1 = root\n    if p1 is None:\n        return root.next\n    p = p1.next\n    if p is None:\n        return root.next\n    while p:",
        "detail": "wk20.sprint-prep.scrap2",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "wk20.sprint-prep.scrap3",
        "description": "wk20.sprint-prep.scrap3",
        "peekOfCode": "class ListNode(object):\n  def __init__(self, x):\n    self.value = x\n    self.next = None\ndef condense_linked_list(node):",
        "detail": "wk20.sprint-prep.scrap3",
        "documentation": {}
    },
    {
        "label": "condense_linked_list",
        "kind": 2,
        "importPath": "wk20.sprint-prep.scrap3",
        "description": "wk20.sprint-prep.scrap3",
        "peekOfCode": "def condense_linked_list(node):",
        "detail": "wk20.sprint-prep.scrap3",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "wk20.sprint-prep.scrap4",
        "description": "wk20.sprint-prep.scrap4",
        "peekOfCode": "class ListNode(object):\n  def __init__(self, x):\n    self.value = x\n    self.next = None\ndef condense_linked_list(node):",
        "detail": "wk20.sprint-prep.scrap4",
        "documentation": {}
    },
    {
        "label": "condense_linked_list",
        "kind": 2,
        "importPath": "wk20.sprint-prep.scrap4",
        "description": "wk20.sprint-prep.scrap4",
        "peekOfCode": "def condense_linked_list(node):",
        "detail": "wk20.sprint-prep.scrap4",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "wk20.sprint-prep.scrap5",
        "description": "wk20.sprint-prep.scrap5",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, x):\n        self.value = x\n        self.next = None\ndef condense_linked_list(node):\n    ptr1 = None\n    ptr2 = None\n    dup = None\n    ptr1 = node\n    # Pick elements one by one",
        "detail": "wk20.sprint-prep.scrap5",
        "documentation": {}
    },
    {
        "label": "condense_linked_list",
        "kind": 2,
        "importPath": "wk20.sprint-prep.scrap5",
        "description": "wk20.sprint-prep.scrap5",
        "peekOfCode": "def condense_linked_list(node):\n    ptr1 = None\n    ptr2 = None\n    dup = None\n    ptr1 = node\n    # Pick elements one by one\n    while ptr1 != None and ptr1.next != None:\n        ptr2 = ptr1\n        # Compare the picked element with rest\n        # of the elements",
        "detail": "wk20.sprint-prep.scrap5",
        "documentation": {}
    },
    {
        "label": "condense_linked_list",
        "kind": 2,
        "importPath": "wk20.sprint-prep.temp",
        "description": "wk20.sprint-prep.temp",
        "peekOfCode": "def condense_linked_list(node):\n    head = node\n    curr_node = head.next\n    while curr_node is not None:\n        if curr_node.value == head.value:\n            curr_node = curr_node.next\n            curr_node.next = None\n        curr_node = curr_node.next\n        head = head.next\n    return head",
        "detail": "wk20.sprint-prep.temp",
        "documentation": {}
    },
    {
        "label": "concatenateArrays",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.CodeSignal-Solution.Challenges.Python.concatenateArrays",
        "description": "_GENERAL.CodeSignal-Solutions.CodeSignal-Solution.Challenges.Python.concatenateArrays",
        "peekOfCode": "def concatenateArrays(a, b):\n    return a + b",
        "detail": "_GENERAL.CodeSignal-Solutions.CodeSignal-Solution.Challenges.Python.concatenateArrays",
        "documentation": {}
    },
    {
        "label": "reverseSentence",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.CodeSignal-Solution.Challenges.Python.reverseSentence",
        "description": "_GENERAL.CodeSignal-Solutions.CodeSignal-Solution.Challenges.Python.reverseSentence",
        "peekOfCode": "def reverseSentence(sentence):\n    list = sentence.split(\" \")\n    i, out = list.__len__() - 1, \"\"\n    while i >= 0:\n        out += list[i] + \" \"\n        i -= 1\n    return out[0:-1]",
        "detail": "_GENERAL.CodeSignal-Solutions.CodeSignal-Solution.Challenges.Python.reverseSentence",
        "documentation": {}
    },
    {
        "label": "add",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.01_-_add",
        "description": "_GENERAL.CodeSignal-Solutions.01_-_add",
        "peekOfCode": "def add(param1, param2):\n    return param1 + param2",
        "detail": "_GENERAL.CodeSignal-Solutions.01_-_add",
        "documentation": {}
    },
    {
        "label": "centuryFromYear",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.02_-_centuryFromYear",
        "description": "_GENERAL.CodeSignal-Solutions.02_-_centuryFromYear",
        "peekOfCode": "def centuryFromYear(year):\n    return ((year - 1) // 100) + 1",
        "detail": "_GENERAL.CodeSignal-Solutions.02_-_centuryFromYear",
        "documentation": {}
    },
    {
        "label": "checkPalindrome",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.03_-_checkPalindrome",
        "description": "_GENERAL.CodeSignal-Solutions.03_-_checkPalindrome",
        "peekOfCode": "def checkPalindrome(inputString):\n    return inputString == inputString[::-1]",
        "detail": "_GENERAL.CodeSignal-Solutions.03_-_checkPalindrome",
        "documentation": {}
    },
    {
        "label": "adjacentElementsProduct",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.04_-_adjacentElementsProduct",
        "description": "_GENERAL.CodeSignal-Solutions.04_-_adjacentElementsProduct",
        "peekOfCode": "def adjacentElementsProduct(inputArray):\n    max = inputArray[0] * inputArray[1]\n    for i in range(len(inputArray) - 1):\n        if inputArray[i] * inputArray[i + 1] > max:\n            max = inputArray[i] * inputArray[i + 1]\n    return max",
        "detail": "_GENERAL.CodeSignal-Solutions.04_-_adjacentElementsProduct",
        "documentation": {}
    },
    {
        "label": "shapeArea",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.05_-_shapeArea",
        "description": "_GENERAL.CodeSignal-Solutions.05_-_shapeArea",
        "peekOfCode": "def shapeArea(n):\n    sum = n * 2 - 1\n    for i in range(1, (n * 2) - 1, 2):\n        sum += i * 2\n    return sum",
        "detail": "_GENERAL.CodeSignal-Solutions.05_-_shapeArea",
        "documentation": {}
    },
    {
        "label": "makeArrayConsecutive2",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.06_-_makeArrayConsecutive2",
        "description": "_GENERAL.CodeSignal-Solutions.06_-_makeArrayConsecutive2",
        "peekOfCode": "def makeArrayConsecutive2(statues):\n    return max(statues) - min(statues) - len(statues) + 1",
        "detail": "_GENERAL.CodeSignal-Solutions.06_-_makeArrayConsecutive2",
        "documentation": {}
    },
    {
        "label": "almostIncreasingSequence",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.07_-_almostIncreasingSequence",
        "description": "_GENERAL.CodeSignal-Solutions.07_-_almostIncreasingSequence",
        "peekOfCode": "def almostIncreasingSequence(sequence):\n    i = 0\n    while i < len(sequence) - 1:\n        if not sequence[i] < sequence[i + 1]:\n            if increasingSequence(\n                sequence[:i] + sequence[i + 1 :]\n            ) or increasingSequence(sequence[: i + 1] + sequence[i + 2 :]):\n                return True\n            else:\n                return False",
        "detail": "_GENERAL.CodeSignal-Solutions.07_-_almostIncreasingSequence",
        "documentation": {}
    },
    {
        "label": "increasingSequence",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.07_-_almostIncreasingSequence",
        "description": "_GENERAL.CodeSignal-Solutions.07_-_almostIncreasingSequence",
        "peekOfCode": "def increasingSequence(sequence):\n    for i in range(len(sequence) - 1):\n        if not sequence[i] < sequence[i + 1]:\n            return False\n    return True",
        "detail": "_GENERAL.CodeSignal-Solutions.07_-_almostIncreasingSequence",
        "documentation": {}
    },
    {
        "label": "matrixElementsSum",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.08_-_matrixElementsSum",
        "description": "_GENERAL.CodeSignal-Solutions.08_-_matrixElementsSum",
        "peekOfCode": "def matrixElementsSum(matrix):\n    if len(matrix) > 1:\n        for row in range(1, len(matrix)):\n            for room in range(len(matrix[row])):\n                if matrix[row - 1][room] == 0:\n                    matrix[row][room] = 0\n    sum = 0\n    for row in matrix:\n        for room in row:\n            sum += room",
        "detail": "_GENERAL.CodeSignal-Solutions.08_-_matrixElementsSum",
        "documentation": {}
    },
    {
        "label": "allLongestStrings",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.09_-_allLongestStrings",
        "description": "_GENERAL.CodeSignal-Solutions.09_-_allLongestStrings",
        "peekOfCode": "def allLongestStrings(inputArray):\n    length = max([len(word) for word in inputArray])\n    result = [word for word in inputArray if len(word) == length]\n    return result",
        "detail": "_GENERAL.CodeSignal-Solutions.09_-_allLongestStrings",
        "documentation": {}
    },
    {
        "label": "commonCharacterCount",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.10_-_commonCharacterCount",
        "description": "_GENERAL.CodeSignal-Solutions.10_-_commonCharacterCount",
        "peekOfCode": "def commonCharacterCount(s1, s2):\n    count = 0\n    word2 = list(s2)\n    for letter in s1:\n        if letter in word2:\n            word2.remove(letter)\n            count += 1\n    return count",
        "detail": "_GENERAL.CodeSignal-Solutions.10_-_commonCharacterCount",
        "documentation": {}
    },
    {
        "label": "isLucky",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.11_-_isLucky",
        "description": "_GENERAL.CodeSignal-Solutions.11_-_isLucky",
        "peekOfCode": "def isLucky(n):\n    string = str(n)\n    top = [int(x) for x in string[: len(string) // 2]]\n    bottom = [int(x) for x in string[len(string) // 2 :]]\n    return sum(top) == sum(bottom)",
        "detail": "_GENERAL.CodeSignal-Solutions.11_-_isLucky",
        "documentation": {}
    },
    {
        "label": "sortByHeight",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.12_-_sortByHeight",
        "description": "_GENERAL.CodeSignal-Solutions.12_-_sortByHeight",
        "peekOfCode": "def sortByHeight(a):\n    treePositions = [x for x in range(len(a)) if a[x] == -1]\n    people = sorted([x for x in a if x != -1])\n    for tree in treePositions:\n        people.insert(tree, -1)\n    return people",
        "detail": "_GENERAL.CodeSignal-Solutions.12_-_sortByHeight",
        "documentation": {}
    },
    {
        "label": "reverseParentheses",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.13_-_reverseParentheses",
        "description": "_GENERAL.CodeSignal-Solutions.13_-_reverseParentheses",
        "peekOfCode": "def reverseParentheses(s):\n    while \"(\" in s:\n        match = re.search(\"\\([^()]*\\)\", s)\n        match_string = match.group(0)[1 : len(match.group(0)) - 1]\n        reversed_match_string = match_string[::-1]\n        s = s[: match.start()] + reversed_match_string + s[match.end() :]\n    return s",
        "detail": "_GENERAL.CodeSignal-Solutions.13_-_reverseParentheses",
        "documentation": {}
    },
    {
        "label": "alternatingSums",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.14_-_alternatingSums",
        "description": "_GENERAL.CodeSignal-Solutions.14_-_alternatingSums",
        "peekOfCode": "def alternatingSums(a):\n    team1 = sum(a[0::2])\n    team2 = sum(a[1::2])\n    return [team1, team2]",
        "detail": "_GENERAL.CodeSignal-Solutions.14_-_alternatingSums",
        "documentation": {}
    },
    {
        "label": "addBorder",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.15_-_addBorder",
        "description": "_GENERAL.CodeSignal-Solutions.15_-_addBorder",
        "peekOfCode": "def addBorder(picture):\n    picture = [\"*\" + string + \"*\" for string in picture]\n    picture = [(\"*\" * len(picture[0]))] + picture + [(\"*\" * len(picture[0]))]\n    return picture",
        "detail": "_GENERAL.CodeSignal-Solutions.15_-_addBorder",
        "documentation": {}
    },
    {
        "label": "areSimilar",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.16_-_areSimilar",
        "description": "_GENERAL.CodeSignal-Solutions.16_-_areSimilar",
        "peekOfCode": "def areSimilar(a, b):\n    diff = [i for i in range(len(a)) if a[i] != b[i]]\n    if len(diff) == 2:\n        b[diff[0]], b[diff[1]] = b[diff[1]], b[diff[0]]\n    return a == b",
        "detail": "_GENERAL.CodeSignal-Solutions.16_-_areSimilar",
        "documentation": {}
    },
    {
        "label": "arrayChange",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.17_-_arrayChange",
        "description": "_GENERAL.CodeSignal-Solutions.17_-_arrayChange",
        "peekOfCode": "def arrayChange(inputArray):\n    count = 0\n    for i in range(1, len(inputArray)):\n        if inputArray[i - 1] >= inputArray[i]:\n            difference = inputArray[i - 1] - inputArray[i]\n            inputArray[i] += difference + 1\n            count += difference + 1\n    return count",
        "detail": "_GENERAL.CodeSignal-Solutions.17_-_arrayChange",
        "documentation": {}
    },
    {
        "label": "palindromeRearranging",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.18_-_palindromeRearranging",
        "description": "_GENERAL.CodeSignal-Solutions.18_-_palindromeRearranging",
        "peekOfCode": "def palindromeRearranging(inputString):\n    inputList = sorted(inputString)\n    foundMiddle = False\n    while len(inputList) > 1:\n        if inputList[0] == inputList[1]:\n            del inputList[1]\n        elif not foundMiddle:\n            foundMiddle = True\n        else:\n            return False",
        "detail": "_GENERAL.CodeSignal-Solutions.18_-_palindromeRearranging",
        "documentation": {}
    },
    {
        "label": "areEquallyStrong",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.19_-_areEquallyStrong",
        "description": "_GENERAL.CodeSignal-Solutions.19_-_areEquallyStrong",
        "peekOfCode": "def areEquallyStrong(yourLeft, yourRight, friendsLeft, friendsRight):\n    sameHands = yourLeft == friendsLeft and yourRight == friendsRight\n    differentHands = yourLeft == friendsRight and yourRight == friendsLeft\n    return sameHands or differentHands",
        "detail": "_GENERAL.CodeSignal-Solutions.19_-_areEquallyStrong",
        "documentation": {}
    },
    {
        "label": "arrayMaximalAdjacentDifference",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.20_-_arrayMaximalAdjacentDifference",
        "description": "_GENERAL.CodeSignal-Solutions.20_-_arrayMaximalAdjacentDifference",
        "peekOfCode": "def arrayMaximalAdjacentDifference(inputArray):\n    diffs = []\n    for i in range(len(inputArray) - 1):\n        diffs.append(abs(inputArray[i] - inputArray[i + 1]))\n    return max(diffs)",
        "detail": "_GENERAL.CodeSignal-Solutions.20_-_arrayMaximalAdjacentDifference",
        "documentation": {}
    },
    {
        "label": "isIPv4Address",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.21_-_isIPv4Address",
        "description": "_GENERAL.CodeSignal-Solutions.21_-_isIPv4Address",
        "peekOfCode": "def isIPv4Address(inputString):\n    strings = [string for string in inputString.split(\".\")]\n    for string in strings:\n        if not string.isdecimal():\n            return False\n    nums = [int(num) for num in strings]\n    return max(nums) <= 255 and min(nums) >= 0 and len(nums) == 4",
        "detail": "_GENERAL.CodeSignal-Solutions.21_-_isIPv4Address",
        "documentation": {}
    },
    {
        "label": "avoidObstacles",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.22_-_avoidObstacles",
        "description": "_GENERAL.CodeSignal-Solutions.22_-_avoidObstacles",
        "peekOfCode": "def avoidObstacles(inputArray):\n    for length in range(2, max(inputArray) + 2):\n        done = True\n        jump = length\n        while jump < (max(inputArray) + length):\n            if jump in inputArray:\n                done = False\n                break\n            jump += length\n        if done:",
        "detail": "_GENERAL.CodeSignal-Solutions.22_-_avoidObstacles",
        "documentation": {}
    },
    {
        "label": "boxBlur",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.23_-_boxBlur",
        "description": "_GENERAL.CodeSignal-Solutions.23_-_boxBlur",
        "peekOfCode": "def boxBlur(image):\n    outImage = []\n    for row in range(1, len(image) - 1):\n        line = []\n        for pixel in range(1, len(image[row]) - 1):\n            total = (\n                image[row - 1][pixel - 1]\n                + image[row - 1][pixel]\n                + image[row - 1][pixel + 1]\n                + image[row][pixel - 1]",
        "detail": "_GENERAL.CodeSignal-Solutions.23_-_boxBlur",
        "documentation": {}
    },
    {
        "label": "minesweeper",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.24_-_minesweeper",
        "description": "_GENERAL.CodeSignal-Solutions.24_-_minesweeper",
        "peekOfCode": "def minesweeper(matrix):\n    TOP = 0\n    BOTTOM = len(matrix) - 1\n    LEFT = 0\n    RIGHT = len(matrix[0]) - 1\n    outMatrix = []\n    for row in range(len(matrix)):\n        outRow = []\n        for cell in range(len(matrix[row])):\n            outRow.append(0)",
        "detail": "_GENERAL.CodeSignal-Solutions.24_-_minesweeper",
        "documentation": {}
    },
    {
        "label": "arrayReplace",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.25_-_arrayReplace",
        "description": "_GENERAL.CodeSignal-Solutions.25_-_arrayReplace",
        "peekOfCode": "def arrayReplace(inputArray, elemToReplace, substitutionElem):\n    return [x if x != elemToReplace else substitutionElem for x in inputArray]",
        "detail": "_GENERAL.CodeSignal-Solutions.25_-_arrayReplace",
        "documentation": {}
    },
    {
        "label": "evenDigitsOnly",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.26_-_evenDigitsOnly",
        "description": "_GENERAL.CodeSignal-Solutions.26_-_evenDigitsOnly",
        "peekOfCode": "def evenDigitsOnly(n):\n    return all(\n        (True if digit in (\"0\", \"2\", \"4\", \"6\", \"8\") else False for digit in str(n))\n    )",
        "detail": "_GENERAL.CodeSignal-Solutions.26_-_evenDigitsOnly",
        "documentation": {}
    },
    {
        "label": "variableName",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.27_-_variableName",
        "description": "_GENERAL.CodeSignal-Solutions.27_-_variableName",
        "peekOfCode": "def variableName(name):\n    return name.replace(\"_\", \"\").isalnum() and not name[0].isdigit()",
        "detail": "_GENERAL.CodeSignal-Solutions.27_-_variableName",
        "documentation": {}
    },
    {
        "label": "alphabeticShift",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.28_-_alphabeticShift",
        "description": "_GENERAL.CodeSignal-Solutions.28_-_alphabeticShift",
        "peekOfCode": "def alphabeticShift(inputString):\n    return \"\".join([chr(ord(x) + 1) if x != \"z\" else \"a\" for x in inputString])",
        "detail": "_GENERAL.CodeSignal-Solutions.28_-_alphabeticShift",
        "documentation": {}
    },
    {
        "label": "chessBoardCellColor",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.29_-_chessBoardCellColor",
        "description": "_GENERAL.CodeSignal-Solutions.29_-_chessBoardCellColor",
        "peekOfCode": "def chessBoardCellColor(cell1, cell2):\n    color1 = ((ord(cell1[0]) - ord(\"A\")) + ord(cell1[1]) - ord(\"1\")) % 2 == 0\n    color2 = ((ord(cell2[0]) - ord(\"A\")) + ord(cell2[1]) - ord(\"1\")) % 2 == 0\n    return color1 == color2",
        "detail": "_GENERAL.CodeSignal-Solutions.29_-_chessBoardCellColor",
        "documentation": {}
    },
    {
        "label": "circleOfNumbers",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.30_-_circleOfNumbers",
        "description": "_GENERAL.CodeSignal-Solutions.30_-_circleOfNumbers",
        "peekOfCode": "def circleOfNumbers(n, firstNumber):\n    return (firstNumber + (n / 2)) % n",
        "detail": "_GENERAL.CodeSignal-Solutions.30_-_circleOfNumbers",
        "documentation": {}
    },
    {
        "label": "depositProfit",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.31_-_depositProfit",
        "description": "_GENERAL.CodeSignal-Solutions.31_-_depositProfit",
        "peekOfCode": "def depositProfit(deposit, rate, threshold):\n    year = 0\n    while deposit < threshold:\n        deposit *= 1 + (rate / 100)\n        year += 1\n    return year",
        "detail": "_GENERAL.CodeSignal-Solutions.31_-_depositProfit",
        "documentation": {}
    },
    {
        "label": "absoluteValuesSumMinimization",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.32_-_absoluteValuesSumMinimization",
        "description": "_GENERAL.CodeSignal-Solutions.32_-_absoluteValuesSumMinimization",
        "peekOfCode": "def absoluteValuesSumMinimization(a):\n    sums = {}\n    for num in a:\n        total = sum([abs(a[i] - num) for i in range(len(a))])\n        if total in sums:\n            sums[total] = min(num, sums[total])\n        else:\n            sums[total] = num\n        print(sums)\n    return sums[min(sums)]",
        "detail": "_GENERAL.CodeSignal-Solutions.32_-_absoluteValuesSumMinimization",
        "documentation": {}
    },
    {
        "label": "stringsRearrangement",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.33_-_stringsRearrangement",
        "description": "_GENERAL.CodeSignal-Solutions.33_-_stringsRearrangement",
        "peekOfCode": "def stringsRearrangement(inputArray):\n    permutations = itertools.permutations(inputArray)\n    for array in permutations:\n        if testArrangement(array):\n            return True\n    return False\ndef testArrangement(array):\n    for i in range(len(array) - 1):\n        if sum([a != b for a, b in zip(array[i], array[i + 1])]) != 1:\n            return False",
        "detail": "_GENERAL.CodeSignal-Solutions.33_-_stringsRearrangement",
        "documentation": {}
    },
    {
        "label": "testArrangement",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.33_-_stringsRearrangement",
        "description": "_GENERAL.CodeSignal-Solutions.33_-_stringsRearrangement",
        "peekOfCode": "def testArrangement(array):\n    for i in range(len(array) - 1):\n        if sum([a != b for a, b in zip(array[i], array[i + 1])]) != 1:\n            return False\n    return True",
        "detail": "_GENERAL.CodeSignal-Solutions.33_-_stringsRearrangement",
        "documentation": {}
    },
    {
        "label": "extractEachKth",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.34_-_extractEachKth",
        "description": "_GENERAL.CodeSignal-Solutions.34_-_extractEachKth",
        "peekOfCode": "def extractEachKth(inputArray, k):\n    return [inputArray[x] for x in range(len(inputArray)) if (x + 1) % k != 0]",
        "detail": "_GENERAL.CodeSignal-Solutions.34_-_extractEachKth",
        "documentation": {}
    },
    {
        "label": "firstDigit",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.35_-_firstDigit",
        "description": "_GENERAL.CodeSignal-Solutions.35_-_firstDigit",
        "peekOfCode": "def firstDigit(inputString):\n    for char in inputString:\n        if char.isdigit():\n            return char",
        "detail": "_GENERAL.CodeSignal-Solutions.35_-_firstDigit",
        "documentation": {}
    },
    {
        "label": "differentSymbolsNaive",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.36_-_differentSymbolsNaive",
        "description": "_GENERAL.CodeSignal-Solutions.36_-_differentSymbolsNaive",
        "peekOfCode": "def differentSymbolsNaive(s):\n    return len(set(s))",
        "detail": "_GENERAL.CodeSignal-Solutions.36_-_differentSymbolsNaive",
        "documentation": {}
    },
    {
        "label": "arrayMaxConsecutiveSum",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.37_-_arrayMaxConsecutiveSum",
        "description": "_GENERAL.CodeSignal-Solutions.37_-_arrayMaxConsecutiveSum",
        "peekOfCode": "def arrayMaxConsecutiveSum(inputArray, k):\n    sums = [sum(inputArray[:k])]\n    for i in range(1, len(inputArray) - k + 1):\n        sums.append(sums[i - 1] - inputArray[i - 1] + inputArray[i + k - 1])\n    return max(sums)",
        "detail": "_GENERAL.CodeSignal-Solutions.37_-_arrayMaxConsecutiveSum",
        "documentation": {}
    },
    {
        "label": "growingPlant",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.38_-_growingPlant",
        "description": "_GENERAL.CodeSignal-Solutions.38_-_growingPlant",
        "peekOfCode": "def growingPlant(upSpeed, downSpeed, desiredHeight):\n    height = 0\n    days = 1\n    height += upSpeed\n    while height < desiredHeight:\n        days += 1\n        height -= downSpeed\n        height += upSpeed\n    return days",
        "detail": "_GENERAL.CodeSignal-Solutions.38_-_growingPlant",
        "documentation": {}
    },
    {
        "label": "knapsackLight",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.39_-_knapsackLight",
        "description": "_GENERAL.CodeSignal-Solutions.39_-_knapsackLight",
        "peekOfCode": "def knapsackLight(value1, weight1, value2, weight2, maxW):\n    if weight1 + weight2 <= maxW:\n        return value1 + value2\n    if weight1 <= maxW and (weight2 > maxW or value1 >= value2):\n        return value1\n    if weight2 <= maxW and (weight1 > maxW or value2 >= value1):\n        return value2\n    return 0",
        "detail": "_GENERAL.CodeSignal-Solutions.39_-_knapsackLight",
        "documentation": {}
    },
    {
        "label": "longestDigitsPrefix",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.40_-_longestDigitsPrefix",
        "description": "_GENERAL.CodeSignal-Solutions.40_-_longestDigitsPrefix",
        "peekOfCode": "def longestDigitsPrefix(inputString):\n    for char in range(len(inputString)):\n        if not inputString[char].isdigit():\n            return inputString[:char]\n    return inputString",
        "detail": "_GENERAL.CodeSignal-Solutions.40_-_longestDigitsPrefix",
        "documentation": {}
    },
    {
        "label": "digitDegree",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.41_-_digitDegree",
        "description": "_GENERAL.CodeSignal-Solutions.41_-_digitDegree",
        "peekOfCode": "def digitDegree(n):\n    degree = 0\n    while len(str(n)) > 1:\n        n = sum((int(digit) for digit in str(n)))\n        degree += 1\n    return degree",
        "detail": "_GENERAL.CodeSignal-Solutions.41_-_digitDegree",
        "documentation": {}
    },
    {
        "label": "bishopAndPawn",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.42_-_bishopAndPawn",
        "description": "_GENERAL.CodeSignal-Solutions.42_-_bishopAndPawn",
        "peekOfCode": "def bishopAndPawn(bishop, pawn):\n    return abs(ord(bishop[0]) - ord(pawn[0])) == abs(ord(bishop[1]) - ord(pawn[1]))",
        "detail": "_GENERAL.CodeSignal-Solutions.42_-_bishopAndPawn",
        "documentation": {}
    },
    {
        "label": "isBeautifulString",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.43_-_isBeautifulString",
        "description": "_GENERAL.CodeSignal-Solutions.43_-_isBeautifulString",
        "peekOfCode": "def isBeautifulString(inputString):\n    for letter in range(ord(\"a\"), ord(\"z\")):\n        if inputString.count(chr(letter)) < inputString.count(chr(letter + 1)):\n            return False\n    return True",
        "detail": "_GENERAL.CodeSignal-Solutions.43_-_isBeautifulString",
        "documentation": {}
    },
    {
        "label": "findEmailDomain",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.44_-_findEmailDomain",
        "description": "_GENERAL.CodeSignal-Solutions.44_-_findEmailDomain",
        "peekOfCode": "def findEmailDomain(address):\n    return address[address.rfind(\"@\") + 1 :]",
        "detail": "_GENERAL.CodeSignal-Solutions.44_-_findEmailDomain",
        "documentation": {}
    },
    {
        "label": "buildPalindrome",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.45_-_buildPalindrome",
        "description": "_GENERAL.CodeSignal-Solutions.45_-_buildPalindrome",
        "peekOfCode": "def buildPalindrome(st):\n    if st == st[::-1]:  # Check for initial palindrome\n        return st\n    index = 0\n    subStr = st[index:]\n    while subStr != subStr[::-1]:  # while substring is not a palindrome\n        index += 1\n        subStr = st[index:]\n    return st + st[index - 1 :: -1]",
        "detail": "_GENERAL.CodeSignal-Solutions.45_-_buildPalindrome",
        "documentation": {}
    },
    {
        "label": "electionsWinners",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.46_-_electionsWinners",
        "description": "_GENERAL.CodeSignal-Solutions.46_-_electionsWinners",
        "peekOfCode": "def electionsWinners(votes, k):\n    winners = 0\n    current_winner = max(votes)\n    for candidate in votes:\n        if k > 0 and candidate + k > current_winner:\n            winners += 1\n        if k == 0 and candidate == current_winner and votes.count(candidate) == 1:\n            winners += 1\n    return winners",
        "detail": "_GENERAL.CodeSignal-Solutions.46_-_electionsWinners",
        "documentation": {}
    },
    {
        "label": "isMAC48Address",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.47_-_isMAC48Address",
        "description": "_GENERAL.CodeSignal-Solutions.47_-_isMAC48Address",
        "peekOfCode": "def isMAC48Address(inputString):\n    hex_chars = (\n        \"1\",\n        \"2\",\n        \"3\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"7\",\n        \"8\",",
        "detail": "_GENERAL.CodeSignal-Solutions.47_-_isMAC48Address",
        "documentation": {}
    },
    {
        "label": "isDigit",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.48_-_isDigit",
        "description": "_GENERAL.CodeSignal-Solutions.48_-_isDigit",
        "peekOfCode": "def isDigit(symbol):\n    return symbol.isdigit()",
        "detail": "_GENERAL.CodeSignal-Solutions.48_-_isDigit",
        "documentation": {}
    },
    {
        "label": "lineEncoding",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.49_-_lineEncoding",
        "description": "_GENERAL.CodeSignal-Solutions.49_-_lineEncoding",
        "peekOfCode": "def lineEncoding(s):\n    count = 1\n    output = []\n    for char in range(1, len(s)):\n        if s[char] == s[char - 1]:\n            count += 1\n        else:\n            if count > 1:\n                output.append(str(count) + s[char - 1])\n            else:",
        "detail": "_GENERAL.CodeSignal-Solutions.49_-_lineEncoding",
        "documentation": {}
    },
    {
        "label": "chessKnight",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.50_-_chessKnight",
        "description": "_GENERAL.CodeSignal-Solutions.50_-_chessKnight",
        "peekOfCode": "def chessKnight(cell):\n    moves = 0\n    # Starting at the top left, going counter-clockwise\n    if ord(cell[0]) >= ord(\"b\") and ord(cell[1]) <= ord(\"6\"):\n        moves += 1\n    if ord(cell[0]) >= ord(\"c\") and ord(cell[1]) <= ord(\"7\"):\n        moves += 1\n    if ord(cell[0]) >= ord(\"c\") and ord(cell[1]) >= ord(\"2\"):\n        moves += 1\n    if ord(cell[0]) >= ord(\"b\") and ord(cell[1]) >= ord(\"3\"):",
        "detail": "_GENERAL.CodeSignal-Solutions.50_-_chessKnight",
        "documentation": {}
    },
    {
        "label": "deleteDigit",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.51_-_deleteDigit",
        "description": "_GENERAL.CodeSignal-Solutions.51_-_deleteDigit",
        "peekOfCode": "def deleteDigit(n):\n    num = str(n)\n    highest = 0\n    for digit in range(len(num)):\n        output = num[:digit] + num[digit + 1 :]\n        if int(output) > int(highest):\n            highest = output\n    return int(highest)",
        "detail": "_GENERAL.CodeSignal-Solutions.51_-_deleteDigit",
        "documentation": {}
    },
    {
        "label": "longestWord",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.52_-_longestWord",
        "description": "_GENERAL.CodeSignal-Solutions.52_-_longestWord",
        "peekOfCode": "def longestWord(text):\n    longest = []\n    word = []\n    for char in text:\n        if ord(\"A\") <= ord(char) <= ord(\"Z\") or ord(\"a\") <= ord(char) <= ord(\"z\"):\n            word.append(char)\n        else:\n            if len(word) > len(longest):\n                longest = word\n            word = []",
        "detail": "_GENERAL.CodeSignal-Solutions.52_-_longestWord",
        "documentation": {}
    },
    {
        "label": "validTime",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.53_-_validTime",
        "description": "_GENERAL.CodeSignal-Solutions.53_-_validTime",
        "peekOfCode": "def validTime(time):\n    groups = time.split(\":\")\n    if len(groups) != 2:\n        return False\n    if not (groups[0].isdigit() and groups[1].isdigit()):\n        return False\n    if int(groups[0]) > 23 or int(groups[1]) > 59:\n        return False\n    return True",
        "detail": "_GENERAL.CodeSignal-Solutions.53_-_validTime",
        "documentation": {}
    },
    {
        "label": "sumUpNumbers",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.54_-_sumUpNumbers",
        "description": "_GENERAL.CodeSignal-Solutions.54_-_sumUpNumbers",
        "peekOfCode": "def sumUpNumbers(inputString):\n    total = 0\n    current_num = []\n    for char in inputString:\n        if char.isdigit():\n            current_num.append(char)\n        else:\n            if len(current_num) > 0:\n                num = int(\"\".join(current_num))\n                total += num",
        "detail": "_GENERAL.CodeSignal-Solutions.54_-_sumUpNumbers",
        "documentation": {}
    },
    {
        "label": "differentSquares",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.55_-_differentSquares",
        "description": "_GENERAL.CodeSignal-Solutions.55_-_differentSquares",
        "peekOfCode": "def differentSquares(matrix):\n    squares = set()\n    for row in range(len(matrix) - 1):\n        for cell in range(len(matrix[row]) - 1):\n            square = (\n                (matrix[row][cell], matrix[row][cell + 1]),\n                (matrix[row + 1][cell], matrix[row + 1][cell + 1]),\n            )\n            squares.add(square)\n    return len(squares)",
        "detail": "_GENERAL.CodeSignal-Solutions.55_-_differentSquares",
        "documentation": {}
    },
    {
        "label": "digitsProduct",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.56_-_digitsProduct",
        "description": "_GENERAL.CodeSignal-Solutions.56_-_digitsProduct",
        "peekOfCode": "def digitsProduct(product):\n    # New idea: add product to factors\n    # while max(factors) > 10: split that num into factors\n    if product == 0:\n        return 10\n    factors = [product]\n    while max(factors) > 9:\n        factored = findFactors(max(factors))\n        if factored:\n            factors.remove(max(factors))",
        "detail": "_GENERAL.CodeSignal-Solutions.56_-_digitsProduct",
        "documentation": {}
    },
    {
        "label": "findFactors",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.56_-_digitsProduct",
        "description": "_GENERAL.CodeSignal-Solutions.56_-_digitsProduct",
        "peekOfCode": "def findFactors(n):\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return i, n // i\n    return False",
        "detail": "_GENERAL.CodeSignal-Solutions.56_-_digitsProduct",
        "documentation": {}
    },
    {
        "label": "fileNaming",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.57_-_fileNaming",
        "description": "_GENERAL.CodeSignal-Solutions.57_-_fileNaming",
        "peekOfCode": "def fileNaming(names):\n    outnames = []\n    for name in names:\n        if name in outnames:\n            k = 1\n            while \"{}({})\".format(name, k) in outnames:\n                k += 1\n            name = \"{}({})\".format(name, k)\n        outnames.append(name)\n    return outnames",
        "detail": "_GENERAL.CodeSignal-Solutions.57_-_fileNaming",
        "documentation": {}
    },
    {
        "label": "messageFromBinaryCode",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.58_-_messageFromBinaryCode",
        "description": "_GENERAL.CodeSignal-Solutions.58_-_messageFromBinaryCode",
        "peekOfCode": "def messageFromBinaryCode(code):\n    output = []\n    for i in range(0, len(code), 8):\n        letter = chr(int(code[i : i + 8], 2))\n        output.append(letter)\n    return \"\".join(output)",
        "detail": "_GENERAL.CodeSignal-Solutions.58_-_messageFromBinaryCode",
        "documentation": {}
    },
    {
        "label": "spiralNumbers",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.59_-_spiralNumbers",
        "description": "_GENERAL.CodeSignal-Solutions.59_-_spiralNumbers",
        "peekOfCode": "def spiralNumbers(n):\n    LEFT = \"left\"\n    RIGHT = \"right\"\n    UP = \"up\"\n    DOWN = \"down\"\n    direction = RIGHT\n    spiral = [[0 for i in range(n)] for j in range(n)]\n    row = 0\n    cell = 0\n    for num in range(1, (n * n) + 1):",
        "detail": "_GENERAL.CodeSignal-Solutions.59_-_spiralNumbers",
        "documentation": {}
    },
    {
        "label": "sudoku",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.60_-_sudoku",
        "description": "_GENERAL.CodeSignal-Solutions.60_-_sudoku",
        "peekOfCode": "def sudoku(grid):\n    match = [i for i in range(1, 10)]\n    for row in grid:\n        if sorted(row) != match:\n            return False\n    for column_index in range(9):\n        column = [grid[row_index][column_index] for row_index in range(9)]\n        if sorted(column) != match:\n            return False\n    for row in range(0, 9, 3):",
        "detail": "_GENERAL.CodeSignal-Solutions.60_-_sudoku",
        "documentation": {}
    },
    {
        "label": "addTwoDigits",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_001_-_addTwoDigits",
        "description": "_GENERAL.CodeSignal-Solutions.Core_001_-_addTwoDigits",
        "peekOfCode": "def addTwoDigits(n):\n    return (n // 10) + (n % 10)",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_001_-_addTwoDigits",
        "documentation": {}
    },
    {
        "label": "largestNumber",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_002_-_largestNumber",
        "description": "_GENERAL.CodeSignal-Solutions.Core_002_-_largestNumber",
        "peekOfCode": "def largestNumber(n):\n    return int(\"9\" * n)",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_002_-_largestNumber",
        "documentation": {}
    },
    {
        "label": "candies",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_003_-_candies",
        "description": "_GENERAL.CodeSignal-Solutions.Core_003_-_candies",
        "peekOfCode": "def candies(n, m):\n    return (m // n) * n",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_003_-_candies",
        "documentation": {}
    },
    {
        "label": "seatsInTheater",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_004_-_seatsInTheater",
        "description": "_GENERAL.CodeSignal-Solutions.Core_004_-_seatsInTheater",
        "peekOfCode": "def seatsInTheater(nCols, nRows, col, row):\n    return (nCols - col + 1) * (nRows - row)",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_004_-_seatsInTheater",
        "documentation": {}
    },
    {
        "label": "maxMultiple",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_005_-_maxMultiple",
        "description": "_GENERAL.CodeSignal-Solutions.Core_005_-_maxMultiple",
        "peekOfCode": "def maxMultiple(divisor, bound):\n    for num in range(bound, 1, -1):\n        if num % divisor == 0:\n            return num\n    return 0",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_005_-_maxMultiple",
        "documentation": {}
    },
    {
        "label": "circleOfNumbers",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_006_-_circleOfNumbers",
        "description": "_GENERAL.CodeSignal-Solutions.Core_006_-_circleOfNumbers",
        "peekOfCode": "def circleOfNumbers(n, firstNumber):\n    return (firstNumber + (n // 2)) % n",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_006_-_circleOfNumbers",
        "documentation": {}
    },
    {
        "label": "lateRide",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_007_-_lateRide",
        "description": "_GENERAL.CodeSignal-Solutions.Core_007_-_lateRide",
        "peekOfCode": "def lateRide(n):\n    hours = n // 60\n    minutes = n % 60\n    return (hours // 10) + (hours % 10) + (minutes // 10) + (minutes % 10)",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_007_-_lateRide",
        "documentation": {}
    },
    {
        "label": "phoneCall",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_008_-_phoneCall",
        "description": "_GENERAL.CodeSignal-Solutions.Core_008_-_phoneCall",
        "peekOfCode": "def phoneCall(min1, min2_10, min11, s):\n    if s < min1:\n        return 0\n    if s == min1:\n        return 1\n    if s <= min1 + (min2_10 * 9):\n        s -= min1\n        return (s // min2_10) + 1\n    s -= min1\n    s -= min2_10 * 9",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_008_-_phoneCall",
        "documentation": {}
    },
    {
        "label": "reachNextLevel",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_009_-_reachNextLevel",
        "description": "_GENERAL.CodeSignal-Solutions.Core_009_-_reachNextLevel",
        "peekOfCode": "def reachNextLevel(experience, threshold, reward):\n    return experience + reward >= threshold",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_009_-_reachNextLevel",
        "documentation": {}
    },
    {
        "label": "knapsackLight",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_010_-_knapsackLight",
        "description": "_GENERAL.CodeSignal-Solutions.Core_010_-_knapsackLight",
        "peekOfCode": "def knapsackLight(value1, weight1, value2, weight2, maxW):\n    if weight1 + weight2 <= maxW:\n        return value1 + value2\n    if weight1 <= maxW and weight2 <= maxW:\n        return max(value1, value2)\n    if weight1 <= maxW:\n        return value1\n    if weight2 <= maxW:\n        return value2\n    return 0",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_010_-_knapsackLight",
        "documentation": {}
    },
    {
        "label": "extraNumber",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_011_-_extraNumber",
        "description": "_GENERAL.CodeSignal-Solutions.Core_011_-_extraNumber",
        "peekOfCode": "def extraNumber(a, b, c):\n    if a == b:\n        return c\n    if a == c:\n        return b\n    return a",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_011_-_extraNumber",
        "documentation": {}
    },
    {
        "label": "isInfiniteProcess",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_012_-_isInfiniteProcess",
        "description": "_GENERAL.CodeSignal-Solutions.Core_012_-_isInfiniteProcess",
        "peekOfCode": "def isInfiniteProcess(a, b):\n    return a > b or (a % 2 != b % 2)",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_012_-_isInfiniteProcess",
        "documentation": {}
    },
    {
        "label": "arithmeticExpression",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_013_-_arithmeticExpression",
        "description": "_GENERAL.CodeSignal-Solutions.Core_013_-_arithmeticExpression",
        "peekOfCode": "def arithmeticExpression(a, b, c):\n    return a + b == c or a - b == c or a * b == c or a / b == c",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_013_-_arithmeticExpression",
        "documentation": {}
    },
    {
        "label": "tennisSet",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_014_-_tennisSet",
        "description": "_GENERAL.CodeSignal-Solutions.Core_014_-_tennisSet",
        "peekOfCode": "def tennisSet(score1, score2):\n    if max(score1, score2) == 6 and min(score1, score2) < 5:\n        return True\n    if 5 <= min(score1, score2) <= 6 and max(score1, score2) == 7:\n        return True\n    return False",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_014_-_tennisSet",
        "documentation": {}
    },
    {
        "label": "willYou",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_015_-_willYou",
        "description": "_GENERAL.CodeSignal-Solutions.Core_015_-_willYou",
        "peekOfCode": "def willYou(young, beautiful, loved):\n    return (young and beautiful) != loved",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_015_-_willYou",
        "documentation": {}
    },
    {
        "label": "metroCard",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_016_-_metroCard",
        "description": "_GENERAL.CodeSignal-Solutions.Core_016_-_metroCard",
        "peekOfCode": "def metroCard(lastNumberOfDays):\n    if lastNumberOfDays == 30 or lastNumberOfDays == 28:\n        return [31]\n    return [28, 30, 31]",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_016_-_metroCard",
        "documentation": {}
    },
    {
        "label": "killKthBit",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_017_-_killKthBit",
        "description": "_GENERAL.CodeSignal-Solutions.Core_017_-_killKthBit",
        "peekOfCode": "def killKthBit(n, k):\n    return n & ~(2 ** (k - 1))",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_017_-_killKthBit",
        "documentation": {}
    },
    {
        "label": "arrayPacking",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_018_-_arrayPacking",
        "description": "_GENERAL.CodeSignal-Solutions.Core_018_-_arrayPacking",
        "peekOfCode": "def arrayPacking(a):\n    binary_array = [bin(num)[2:].rjust(8, \"0\") for num in a]\n    out_string = \"\".join(binary_array[::-1])\n    return int(out_string, 2)",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_018_-_arrayPacking",
        "documentation": {}
    },
    {
        "label": "rangeBitCount",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_019_-_rangeBitCount",
        "description": "_GENERAL.CodeSignal-Solutions.Core_019_-_rangeBitCount",
        "peekOfCode": "def rangeBitCount(a, b):\n    array = list(range(a, b + 1))\n    binary_array = [bin(num) for num in array]\n    count_array = [binary.count(\"1\") for binary in binary_array]\n    return sum(count_array)",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_019_-_rangeBitCount",
        "documentation": {}
    },
    {
        "label": "mirrorBits",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_020_-_mirrorBits",
        "description": "_GENERAL.CodeSignal-Solutions.Core_020_-_mirrorBits",
        "peekOfCode": "def mirrorBits(a):\n    binary = bin(a)[2:]\n    return int(binary[::-1], 2)",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_020_-_mirrorBits",
        "documentation": {}
    },
    {
        "label": "secondRightmostZeroBit",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_021_-_secondRightmostZeroBit",
        "description": "_GENERAL.CodeSignal-Solutions.Core_021_-_secondRightmostZeroBit",
        "peekOfCode": "def secondRightmostZeroBit(n):\n    return 2 ** bin(n)[::-1].find(\"0\", bin(n)[::-1].find(\"0\") + 1)",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_021_-_secondRightmostZeroBit",
        "documentation": {}
    },
    {
        "label": "swapAdjacentBits",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_022_-_swapAdjacentBits",
        "description": "_GENERAL.CodeSignal-Solutions.Core_022_-_swapAdjacentBits",
        "peekOfCode": "def swapAdjacentBits(n):\n    return ((n >> 1) & 1431655765) | ((n << 1) & 2863311530)",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_022_-_swapAdjacentBits",
        "documentation": {}
    },
    {
        "label": "differentRightmostBit",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_023_-_differentRightmostBit",
        "description": "_GENERAL.CodeSignal-Solutions.Core_023_-_differentRightmostBit",
        "peekOfCode": "def differentRightmostBit(n, m):\n    return 2 ** bin((n ^ m))[::-1].find(\"1\")",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_023_-_differentRightmostBit",
        "documentation": {}
    },
    {
        "label": "equalPairOfBits",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_024_-_equalPairOfBits",
        "description": "_GENERAL.CodeSignal-Solutions.Core_024_-_equalPairOfBits",
        "peekOfCode": "def equalPairOfBits(n, m):\n    return 2 ** bin(~(n ^ m))[::-1].find(\"1\")",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_024_-_equalPairOfBits",
        "documentation": {}
    },
    {
        "label": "leastFactorial",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_025_-_leastFactorial",
        "description": "_GENERAL.CodeSignal-Solutions.Core_025_-_leastFactorial",
        "peekOfCode": "def leastFactorial(n):\n    factorial = 1\n    index = 1\n    while factorial < n:\n        index += 1\n        factorial *= index\n    return factorial",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_025_-_leastFactorial",
        "documentation": {}
    },
    {
        "label": "countSumOfTwoRepresentations2",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_026_-_countSumOfTwoRepresentations2",
        "description": "_GENERAL.CodeSignal-Solutions.Core_026_-_countSumOfTwoRepresentations2",
        "peekOfCode": "def countSumOfTwoRepresentations2(n, l, r):\n    count = 0\n    a = max(n - r, l)\n    b = n - a\n    while a <= r and a <= b:\n        count += 1\n        a += 1\n        b -= 1\n    return count",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_026_-_countSumOfTwoRepresentations2",
        "documentation": {}
    },
    {
        "label": "magicalWell",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_027_-_magicalWell",
        "description": "_GENERAL.CodeSignal-Solutions.Core_027_-_magicalWell",
        "peekOfCode": "def magicalWell(a, b, n):\n    total = 0\n    for i in range(n):\n        total += a * b\n        a += 1\n        b += 1\n    return total",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_027_-_magicalWell",
        "documentation": {}
    },
    {
        "label": "lineUp",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_028_-_lineUp",
        "description": "_GENERAL.CodeSignal-Solutions.Core_028_-_lineUp",
        "peekOfCode": "def lineUp(commands):\n    count = 0\n    smart_student = 0\n    dumb_student = 0\n    for command in commands:\n        if command == \"L\":\n            smart_student = (smart_student - 1) % 4\n            dumb_student = (dumb_student + 1) % 4\n        elif command == \"R\":\n            smart_student = (smart_student + 1) % 4",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_028_-_lineUp",
        "documentation": {}
    },
    {
        "label": "additionWithoutCarrying",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_029_-_additionWithoutCarrying",
        "description": "_GENERAL.CodeSignal-Solutions.Core_029_-_additionWithoutCarrying",
        "peekOfCode": "def additionWithoutCarrying(param1, param2):\n    # Convert numbers to strings\n    str1 = str(param1)\n    str2 = str(param2)\n    # Pad both to the same length with zeroes (to the left of the numbers)\n    length = max(len(str2), len(str1))\n    str1 = str1.rjust(length, \"0\")\n    str2 = str2.rjust(length, \"0\")\n    output = []\n    for num1, num2 in zip(str1, str2):",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_029_-_additionWithoutCarrying",
        "documentation": {}
    },
    {
        "label": "appleBoxes",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_030_-_appleBoxes",
        "description": "_GENERAL.CodeSignal-Solutions.Core_030_-_appleBoxes",
        "peekOfCode": "def appleBoxes(k):\n    red = 0\n    yellow = 0\n    for i in range(1, k + 1, 2):\n        yellow += i * i\n    for i in range(2, k + 1, 2):\n        red += i * i\n    return red - yellow",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_030_-_appleBoxes",
        "documentation": {}
    },
    {
        "label": "increaseNumberRoundness",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_031_-_increaseNumberRoundness",
        "description": "_GENERAL.CodeSignal-Solutions.Core_031_-_increaseNumberRoundness",
        "peekOfCode": "def increaseNumberRoundness(n):\n    string = str(n)\n    # Check for immediate rejection\n    if \"0\" not in string or len(string) < 2:\n        return False\n    # Since we know there's a 0, if it's not on\n    # the left, then we know to accept\n    if string[-1] != \"0\":\n        return True\n    # If there is only one 0, it must be at the end, so reject.",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_031_-_increaseNumberRoundness",
        "documentation": {}
    },
    {
        "label": "rounders",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_032_-_rounders",
        "description": "_GENERAL.CodeSignal-Solutions.Core_032_-_rounders",
        "peekOfCode": "def rounders(value):\n    length = len(str(value))\n    magnitude = length - 1\n    for i in range(length - 1):\n        value = int((value / 10) + 0.5)\n    return value * (10 ** magnitude)",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_032_-_rounders",
        "documentation": {}
    },
    {
        "label": "candles",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_033_-_candles",
        "description": "_GENERAL.CodeSignal-Solutions.Core_033_-_candles",
        "peekOfCode": "def candles(candlesNumber, makeNew):\n    totalBurned = 0\n    leftovers = 0\n    while candlesNumber > 0:\n        totalBurned += candlesNumber\n        leftovers += candlesNumber\n        candlesNumber = 0\n        candlesNumber = leftovers // makeNew\n        leftovers = leftovers % makeNew\n    return totalBurned",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_033_-_candles",
        "documentation": {}
    },
    {
        "label": "countBlackCells",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_034_-_countBlackCells",
        "description": "_GENERAL.CodeSignal-Solutions.Core_034_-_countBlackCells",
        "peekOfCode": "def countBlackCells(n, m):\n    gcd = find_gcd(n, m)\n    line_cells = n + m - gcd\n    line_corner_cells = (gcd - 1) * 2\n    return line_cells + line_corner_cells\ndef find_gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_034_-_countBlackCells",
        "documentation": {}
    },
    {
        "label": "find_gcd",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_034_-_countBlackCells",
        "description": "_GENERAL.CodeSignal-Solutions.Core_034_-_countBlackCells",
        "peekOfCode": "def find_gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_034_-_countBlackCells",
        "documentation": {}
    },
    {
        "label": "createArray",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_035_-_createArray",
        "description": "_GENERAL.CodeSignal-Solutions.Core_035_-_createArray",
        "peekOfCode": "def createArray(size):\n    return [1] * size",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_035_-_createArray",
        "documentation": {}
    },
    {
        "label": "arrayReplace",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_036_-_arrayReplace",
        "description": "_GENERAL.CodeSignal-Solutions.Core_036_-_arrayReplace",
        "peekOfCode": "def arrayReplace(inputArray, elemToReplace, substitutionElem):\n    output = [\n        elem if elem != elemToReplace else substitutionElem for elem in inputArray\n    ]\n    return output",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_036_-_arrayReplace",
        "documentation": {}
    },
    {
        "label": "firstReverseTry",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_037_-_firstReverseTry",
        "description": "_GENERAL.CodeSignal-Solutions.Core_037_-_firstReverseTry",
        "peekOfCode": "def firstReverseTry(arr):\n    if len(arr) < 2:\n        return arr\n    if len(arr) < 4:\n        return arr[::-1]\n    return arr[-1:] + arr[1:-1] + arr[:1]",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_037_-_firstReverseTry",
        "documentation": {}
    },
    {
        "label": "concatenateArrays",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_038_-_concatenateArrays",
        "description": "_GENERAL.CodeSignal-Solutions.Core_038_-_concatenateArrays",
        "peekOfCode": "def concatenateArrays(a, b):\n    return a + b",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_038_-_concatenateArrays",
        "documentation": {}
    },
    {
        "label": "removeArrayPart",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_039_-_removeArrayPart",
        "description": "_GENERAL.CodeSignal-Solutions.Core_039_-_removeArrayPart",
        "peekOfCode": "def removeArrayPart(inputArray, l, r):\n    return inputArray[:l] + inputArray[r + 1 :]",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_039_-_removeArrayPart",
        "documentation": {}
    },
    {
        "label": "isSmooth",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_040_-_isSmooth",
        "description": "_GENERAL.CodeSignal-Solutions.Core_040_-_isSmooth",
        "peekOfCode": "def isSmooth(arr):\n    if arr[0] != arr[-1]:\n        return False\n    if len(arr) % 2 == 0:\n        middle = arr[len(arr) // 2] + arr[(len(arr) // 2) - 1]\n    else:\n        middle = arr[len(arr) // 2]\n    return arr[0] == middle",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_040_-_isSmooth",
        "documentation": {}
    },
    {
        "label": "replaceMiddle",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_041_-_replaceMiddle",
        "description": "_GENERAL.CodeSignal-Solutions.Core_041_-_replaceMiddle",
        "peekOfCode": "def replaceMiddle(arr):\n    if len(arr) % 2 != 0:\n        return arr\n    right_middle = len(arr) // 2\n    middle_value = arr[right_middle] + arr[right_middle - 1]\n    return arr[: right_middle - 1] + [middle_value] + arr[right_middle + 1 :]",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_041_-_replaceMiddle",
        "documentation": {}
    },
    {
        "label": "makeArrayConsecutive2",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_042_-_makeArrayConsecutive2",
        "description": "_GENERAL.CodeSignal-Solutions.Core_042_-_makeArrayConsecutive2",
        "peekOfCode": "def makeArrayConsecutive2(statues):\n    count = 0\n    for i in range(min(statues), max(statues)):\n        if i not in statues:\n            count += 1\n    return count",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_042_-_makeArrayConsecutive2",
        "documentation": {}
    },
    {
        "label": "isPower",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_043_-_isPower",
        "description": "_GENERAL.CodeSignal-Solutions.Core_043_-_isPower",
        "peekOfCode": "def isPower(n):\n    if n == 1:\n        return True\n    a = 2\n    b = 2\n    while a ** 2 <= n:\n        while a ** b <= n:\n            if a ** b == n:\n                return True\n            b += 1",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_043_-_isPower",
        "documentation": {}
    },
    {
        "label": "isSumOfConsecutive2",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_044_-_isSumOfConsecutive2",
        "description": "_GENERAL.CodeSignal-Solutions.Core_044_-_isSumOfConsecutive2",
        "peekOfCode": "def isSumOfConsecutive2(n):\n    count = 0\n    right = 2\n    arr = [1, 2]\n    while right <= (n // 2) + 1:\n        total = sum(arr)\n        if total == n:\n            count += 1\n            del arr[0]\n        elif total < n:",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_044_-_isSumOfConsecutive2",
        "documentation": {}
    },
    {
        "label": "squareDigitsSequence",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_045_-_squareDigitsSequence",
        "description": "_GENERAL.CodeSignal-Solutions.Core_045_-_squareDigitsSequence",
        "peekOfCode": "def squareDigitsSequence(a0):\n    sequence = [a0]\n    while sequence[-1] not in sequence[:-1]:\n        next_value = 0\n        for digit in str(sequence[-1]):\n            next_value += int(digit) ** 2\n        sequence.append(next_value)\n    return len(sequence)",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_045_-_squareDigitsSequence",
        "documentation": {}
    },
    {
        "label": "pagesNumberingWithInk",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_046_-_pagesNumberingWithInk",
        "description": "_GENERAL.CodeSignal-Solutions.Core_046_-_pagesNumberingWithInk",
        "peekOfCode": "def pagesNumberingWithInk(current, numberOfDigits):\n    numberOfDigits -= len(str(current))\n    next_digits = len(str(current + 1))\n    while numberOfDigits >= next_digits:\n        current += 1\n        numberOfDigits -= next_digits\n        next_digits = len(str(current))\n    return current",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_046_-_pagesNumberingWithInk",
        "documentation": {}
    },
    {
        "label": "comfortableNumbers",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_047_-_comfortableNumbers",
        "description": "_GENERAL.CodeSignal-Solutions.Core_047_-_comfortableNumbers",
        "peekOfCode": "def comfortableNumbers(l, r):\n    count = 0\n    for a in range(l, r):\n        for b in range(a + 1, r + 1):\n            a_sum = sum(int(digit) for digit in str(a))\n            b_sum = sum(int(digit) for digit in str(b))\n            if b <= a + a_sum and a >= b - b_sum:\n                count += 1\n    return count",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_047_-_comfortableNumbers",
        "documentation": {}
    },
    {
        "label": "weakNumbers",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_048_-_weakNumbers",
        "description": "_GENERAL.CodeSignal-Solutions.Core_048_-_weakNumbers",
        "peekOfCode": "def weakNumbers(n):\n    all_factors = [count_factors(num) for num in range(1, n + 1)]\n    weaknesses = []\n    for num, num_factors in enumerate(all_factors, 1):\n        weakness = 0\n        for factor in all_factors[:num]:\n            if factor > num_factors:\n                weakness += 1\n        weaknesses.append(weakness)\n        weakest = max(weaknesses)",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_048_-_weakNumbers",
        "documentation": {}
    },
    {
        "label": "count_factors",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_048_-_weakNumbers",
        "description": "_GENERAL.CodeSignal-Solutions.Core_048_-_weakNumbers",
        "peekOfCode": "def count_factors(n):\n    factors = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            factors += 1\n    return factors\nprint(weakNumbers(500))",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_048_-_weakNumbers",
        "documentation": {}
    },
    {
        "label": "rectangleRotation",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.Core_049_-_rectangleRotation",
        "description": "_GENERAL.CodeSignal-Solutions.Core_049_-_rectangleRotation",
        "peekOfCode": "def rectangleRotation(a, b):\n    n = a / (2 ** 0.5)\n    m = b / (2 ** 0.5)\n    points = (math.floor(n) * math.floor(m)) + (math.ceil(n) * math.ceil(m))\n    if math.floor(n) % 2 != math.floor(m) % 2:\n        points -= 1\n    return points\n# rectangleRotation(6, 4)\nprint(rectangleRotation(8, 6))",
        "detail": "_GENERAL.CodeSignal-Solutions.Core_049_-_rectangleRotation",
        "documentation": {}
    },
    {
        "label": "add",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def add(param1, param2):\n    return param1 + param2\ndef centuryFromYear(year):\n    return ((year - 1) // 100) + 1\ndef checkPalindrome(inputString):\n    return inputString == inputString[::-1]\ndef adjacentElementsProduct(inputArray):\n    max = inputArray[0] * inputArray[1]\n    for i in range(len(inputArray) - 1):\n        if inputArray[i] * inputArray[i + 1] > max:",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "centuryFromYear",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def centuryFromYear(year):\n    return ((year - 1) // 100) + 1\ndef checkPalindrome(inputString):\n    return inputString == inputString[::-1]\ndef adjacentElementsProduct(inputArray):\n    max = inputArray[0] * inputArray[1]\n    for i in range(len(inputArray) - 1):\n        if inputArray[i] * inputArray[i + 1] > max:\n            max = inputArray[i] * inputArray[i + 1]\n    return max",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "checkPalindrome",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def checkPalindrome(inputString):\n    return inputString == inputString[::-1]\ndef adjacentElementsProduct(inputArray):\n    max = inputArray[0] * inputArray[1]\n    for i in range(len(inputArray) - 1):\n        if inputArray[i] * inputArray[i + 1] > max:\n            max = inputArray[i] * inputArray[i + 1]\n    return max\ndef shapeArea(n):\n    sum = n * 2 - 1",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "adjacentElementsProduct",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def adjacentElementsProduct(inputArray):\n    max = inputArray[0] * inputArray[1]\n    for i in range(len(inputArray) - 1):\n        if inputArray[i] * inputArray[i + 1] > max:\n            max = inputArray[i] * inputArray[i + 1]\n    return max\ndef shapeArea(n):\n    sum = n * 2 - 1\n    for i in range(1, (n * 2) - 1, 2):\n        sum += i * 2",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "shapeArea",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def shapeArea(n):\n    sum = n * 2 - 1\n    for i in range(1, (n * 2) - 1, 2):\n        sum += i * 2\n    return sum\ndef makeArrayConsecutive2(statues):\n    return max(statues) - min(statues) - len(statues) + 1\ndef almostIncreasingSequence(sequence):\n    i = 0\n    while i < len(sequence) - 1:",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "makeArrayConsecutive2",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def makeArrayConsecutive2(statues):\n    return max(statues) - min(statues) - len(statues) + 1\ndef almostIncreasingSequence(sequence):\n    i = 0\n    while i < len(sequence) - 1:\n        if not sequence[i] < sequence[i + 1]:\n            if increasingSequence(\n                sequence[:i] + sequence[i + 1 :]\n            ) or increasingSequence(sequence[: i + 1] + sequence[i + 2 :]):\n                return True",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "almostIncreasingSequence",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def almostIncreasingSequence(sequence):\n    i = 0\n    while i < len(sequence) - 1:\n        if not sequence[i] < sequence[i + 1]:\n            if increasingSequence(\n                sequence[:i] + sequence[i + 1 :]\n            ) or increasingSequence(sequence[: i + 1] + sequence[i + 2 :]):\n                return True\n            else:\n                return False",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "increasingSequence",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def increasingSequence(sequence):\n    for i in range(len(sequence) - 1):\n        if not sequence[i] < sequence[i + 1]:\n            return False\n    return True\ndef matrixElementsSum(matrix):\n    if len(matrix) > 1:\n        for row in range(1, len(matrix)):\n            for room in range(len(matrix[row])):\n                if matrix[row - 1][room] == 0:",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "matrixElementsSum",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def matrixElementsSum(matrix):\n    if len(matrix) > 1:\n        for row in range(1, len(matrix)):\n            for room in range(len(matrix[row])):\n                if matrix[row - 1][room] == 0:\n                    matrix[row][room] = 0\n    sum = 0\n    for row in matrix:\n        for room in row:\n            sum += room",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "allLongestStrings",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def allLongestStrings(inputArray):\n    length = max([len(word) for word in inputArray])\n    result = [word for word in inputArray if len(word) == length]\n    return result\ndef commonCharacterCount(s1, s2):\n    count = 0\n    word2 = list(s2)\n    for letter in s1:\n        if letter in word2:\n            word2.remove(letter)",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "commonCharacterCount",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def commonCharacterCount(s1, s2):\n    count = 0\n    word2 = list(s2)\n    for letter in s1:\n        if letter in word2:\n            word2.remove(letter)\n            count += 1\n    return count\ndef isLucky(n):\n    string = str(n)",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "isLucky",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def isLucky(n):\n    string = str(n)\n    top = [int(x) for x in string[: len(string) // 2]]\n    bottom = [int(x) for x in string[len(string) // 2 :]]\n    return sum(top) == sum(bottom)\ndef sortByHeight(a):\n    treePositions = [x for x in range(len(a)) if a[x] == -1]\n    people = sorted([x for x in a if x != -1])\n    for tree in treePositions:\n        people.insert(tree, -1)",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "sortByHeight",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def sortByHeight(a):\n    treePositions = [x for x in range(len(a)) if a[x] == -1]\n    people = sorted([x for x in a if x != -1])\n    for tree in treePositions:\n        people.insert(tree, -1)\n    return people\nimport re\ndef reverseParentheses(s):\n    while \"(\" in s:\n        match = re.search(\"\\([^()]*\\)\", s)",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "reverseParentheses",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def reverseParentheses(s):\n    while \"(\" in s:\n        match = re.search(\"\\([^()]*\\)\", s)\n        match_string = match.group(0)[1 : len(match.group(0)) - 1]\n        reversed_match_string = match_string[::-1]\n        s = s[: match.start()] + reversed_match_string + s[match.end() :]\n    return s\ndef alternatingSums(a):\n    team1 = sum(a[0::2])\n    team2 = sum(a[1::2])",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "alternatingSums",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def alternatingSums(a):\n    team1 = sum(a[0::2])\n    team2 = sum(a[1::2])\n    return [team1, team2]\ndef addBorder(picture):\n    picture = [\"*\" + string + \"*\" for string in picture]\n    picture = [(\"*\" * len(picture[0]))] + picture + [(\"*\" * len(picture[0]))]\n    return picture\ndef areSimilar(a, b):\n    diff = [i for i in range(len(a)) if a[i] != b[i]]",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "addBorder",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def addBorder(picture):\n    picture = [\"*\" + string + \"*\" for string in picture]\n    picture = [(\"*\" * len(picture[0]))] + picture + [(\"*\" * len(picture[0]))]\n    return picture\ndef areSimilar(a, b):\n    diff = [i for i in range(len(a)) if a[i] != b[i]]\n    if len(diff) == 2:\n        b[diff[0]], b[diff[1]] = b[diff[1]], b[diff[0]]\n    return a == b\ndef arrayChange(inputArray):",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "areSimilar",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def areSimilar(a, b):\n    diff = [i for i in range(len(a)) if a[i] != b[i]]\n    if len(diff) == 2:\n        b[diff[0]], b[diff[1]] = b[diff[1]], b[diff[0]]\n    return a == b\ndef arrayChange(inputArray):\n    count = 0\n    for i in range(1, len(inputArray)):\n        if inputArray[i - 1] >= inputArray[i]:\n            difference = inputArray[i - 1] - inputArray[i]",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "arrayChange",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def arrayChange(inputArray):\n    count = 0\n    for i in range(1, len(inputArray)):\n        if inputArray[i - 1] >= inputArray[i]:\n            difference = inputArray[i - 1] - inputArray[i]\n            inputArray[i] += difference + 1\n            count += difference + 1\n    return count\ndef palindromeRearranging(inputString):\n    inputList = sorted(inputString)",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "palindromeRearranging",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def palindromeRearranging(inputString):\n    inputList = sorted(inputString)\n    foundMiddle = False\n    while len(inputList) > 1:\n        if inputList[0] == inputList[1]:\n            del inputList[1]\n        elif not foundMiddle:\n            foundMiddle = True\n        else:\n            return False",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "areEquallyStrong",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def areEquallyStrong(yourLeft, yourRight, friendsLeft, friendsRight):\n    sameHands = yourLeft == friendsLeft and yourRight == friendsRight\n    differentHands = yourLeft == friendsRight and yourRight == friendsLeft\n    return sameHands or differentHands\ndef arrayMaximalAdjacentDifference(inputArray):\n    diffs = []\n    for i in range(len(inputArray) - 1):\n        diffs.append(abs(inputArray[i] - inputArray[i + 1]))\n    return max(diffs)\ndef isIPv4Address(inputString):",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "arrayMaximalAdjacentDifference",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def arrayMaximalAdjacentDifference(inputArray):\n    diffs = []\n    for i in range(len(inputArray) - 1):\n        diffs.append(abs(inputArray[i] - inputArray[i + 1]))\n    return max(diffs)\ndef isIPv4Address(inputString):\n    strings = [string for string in inputString.split(\".\")]\n    for string in strings:\n        if not string.isdecimal():\n            return False",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "isIPv4Address",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def isIPv4Address(inputString):\n    strings = [string for string in inputString.split(\".\")]\n    for string in strings:\n        if not string.isdecimal():\n            return False\n    nums = [int(num) for num in strings]\n    return max(nums) <= 255 and min(nums) >= 0 and len(nums) == 4\ndef avoidObstacles(inputArray):\n    for length in range(2, max(inputArray) + 2):\n        done = True",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "avoidObstacles",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def avoidObstacles(inputArray):\n    for length in range(2, max(inputArray) + 2):\n        done = True\n        jump = length\n        while jump < (max(inputArray) + length):\n            if jump in inputArray:\n                done = False\n                break\n            jump += length\n        if done:",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "boxBlur",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def boxBlur(image):\n    outImage = []\n    for row in range(1, len(image) - 1):\n        line = []\n        for pixel in range(1, len(image[row]) - 1):\n            total = (\n                image[row - 1][pixel - 1]\n                + image[row - 1][pixel]\n                + image[row - 1][pixel + 1]\n                + image[row][pixel - 1]",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "minesweeper",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def minesweeper(matrix):\n    TOP = 0\n    BOTTOM = len(matrix) - 1\n    LEFT = 0\n    RIGHT = len(matrix[0]) - 1\n    outMatrix = []\n    for row in range(len(matrix)):\n        outRow = []\n        for cell in range(len(matrix[row])):\n            outRow.append(0)",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "arrayReplace",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def arrayReplace(inputArray, elemToReplace, substitutionElem):\n    return [x if x != elemToReplace else substitutionElem for x in inputArray]\ndef evenDigitsOnly(n):\n    return all(\n        (True if digit in (\"0\", \"2\", \"4\", \"6\", \"8\") else False for digit in str(n))\n    )\ndef variableName(name):\n    return name.replace(\"_\", \"\").isalnum() and not name[0].isdigit()\ndef alphabeticShift(inputString):\n    return \"\".join([chr(ord(x) + 1) if x != \"z\" else \"a\" for x in inputString])",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "evenDigitsOnly",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def evenDigitsOnly(n):\n    return all(\n        (True if digit in (\"0\", \"2\", \"4\", \"6\", \"8\") else False for digit in str(n))\n    )\ndef variableName(name):\n    return name.replace(\"_\", \"\").isalnum() and not name[0].isdigit()\ndef alphabeticShift(inputString):\n    return \"\".join([chr(ord(x) + 1) if x != \"z\" else \"a\" for x in inputString])\ndef chessBoardCellColor(cell1, cell2):\n    color1 = ((ord(cell1[0]) - ord(\"A\")) + ord(cell1[1]) - ord(\"1\")) % 2 == 0",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "variableName",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def variableName(name):\n    return name.replace(\"_\", \"\").isalnum() and not name[0].isdigit()\ndef alphabeticShift(inputString):\n    return \"\".join([chr(ord(x) + 1) if x != \"z\" else \"a\" for x in inputString])\ndef chessBoardCellColor(cell1, cell2):\n    color1 = ((ord(cell1[0]) - ord(\"A\")) + ord(cell1[1]) - ord(\"1\")) % 2 == 0\n    color2 = ((ord(cell2[0]) - ord(\"A\")) + ord(cell2[1]) - ord(\"1\")) % 2 == 0\n    return color1 == color2\ndef circleOfNumbers(n, firstNumber):\n    return (firstNumber + (n / 2)) % n",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "alphabeticShift",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def alphabeticShift(inputString):\n    return \"\".join([chr(ord(x) + 1) if x != \"z\" else \"a\" for x in inputString])\ndef chessBoardCellColor(cell1, cell2):\n    color1 = ((ord(cell1[0]) - ord(\"A\")) + ord(cell1[1]) - ord(\"1\")) % 2 == 0\n    color2 = ((ord(cell2[0]) - ord(\"A\")) + ord(cell2[1]) - ord(\"1\")) % 2 == 0\n    return color1 == color2\ndef circleOfNumbers(n, firstNumber):\n    return (firstNumber + (n / 2)) % n\ndef depositProfit(deposit, rate, threshold):\n    year = 0",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "chessBoardCellColor",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def chessBoardCellColor(cell1, cell2):\n    color1 = ((ord(cell1[0]) - ord(\"A\")) + ord(cell1[1]) - ord(\"1\")) % 2 == 0\n    color2 = ((ord(cell2[0]) - ord(\"A\")) + ord(cell2[1]) - ord(\"1\")) % 2 == 0\n    return color1 == color2\ndef circleOfNumbers(n, firstNumber):\n    return (firstNumber + (n / 2)) % n\ndef depositProfit(deposit, rate, threshold):\n    year = 0\n    while deposit < threshold:\n        deposit *= 1 + (rate / 100)",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "circleOfNumbers",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def circleOfNumbers(n, firstNumber):\n    return (firstNumber + (n / 2)) % n\ndef depositProfit(deposit, rate, threshold):\n    year = 0\n    while deposit < threshold:\n        deposit *= 1 + (rate / 100)\n        year += 1\n    return year\ndef absoluteValuesSumMinimization(a):\n    sums = {}",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "depositProfit",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def depositProfit(deposit, rate, threshold):\n    year = 0\n    while deposit < threshold:\n        deposit *= 1 + (rate / 100)\n        year += 1\n    return year\ndef absoluteValuesSumMinimization(a):\n    sums = {}\n    for num in a:\n        total = sum([abs(a[i] - num) for i in range(len(a))])",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "absoluteValuesSumMinimization",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def absoluteValuesSumMinimization(a):\n    sums = {}\n    for num in a:\n        total = sum([abs(a[i] - num) for i in range(len(a))])\n        if total in sums:\n            sums[total] = min(num, sums[total])\n        else:\n            sums[total] = num\n        print(sums)\n    return sums[min(sums)]",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "stringsRearrangement",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def stringsRearrangement(inputArray):\n    permutations = itertools.permutations(inputArray)\n    for array in permutations:\n        if testArrangement(array):\n            return True\n    return False\ndef testArrangement(array):\n    for i in range(len(array) - 1):\n        if sum([a != b for a, b in zip(array[i], array[i + 1])]) != 1:\n            return False",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "testArrangement",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def testArrangement(array):\n    for i in range(len(array) - 1):\n        if sum([a != b for a, b in zip(array[i], array[i + 1])]) != 1:\n            return False\n    return True\ndef extractEachKth(inputArray, k):\n    return [inputArray[x] for x in range(len(inputArray)) if (x + 1) % k != 0]\ndef firstDigit(inputString):\n    for char in inputString:\n        if char.isdigit():",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "extractEachKth",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def extractEachKth(inputArray, k):\n    return [inputArray[x] for x in range(len(inputArray)) if (x + 1) % k != 0]\ndef firstDigit(inputString):\n    for char in inputString:\n        if char.isdigit():\n            return char\ndef differentSymbolsNaive(s):\n    return len(set(s))\ndef arrayMaxConsecutiveSum(inputArray, k):\n    sums = [sum(inputArray[:k])]",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "firstDigit",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def firstDigit(inputString):\n    for char in inputString:\n        if char.isdigit():\n            return char\ndef differentSymbolsNaive(s):\n    return len(set(s))\ndef arrayMaxConsecutiveSum(inputArray, k):\n    sums = [sum(inputArray[:k])]\n    for i in range(1, len(inputArray) - k + 1):\n        sums.append(sums[i - 1] - inputArray[i - 1] + inputArray[i + k - 1])",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "differentSymbolsNaive",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def differentSymbolsNaive(s):\n    return len(set(s))\ndef arrayMaxConsecutiveSum(inputArray, k):\n    sums = [sum(inputArray[:k])]\n    for i in range(1, len(inputArray) - k + 1):\n        sums.append(sums[i - 1] - inputArray[i - 1] + inputArray[i + k - 1])\n    return max(sums)\ndef growingPlant(upSpeed, downSpeed, desiredHeight):\n    height = 0\n    days = 1",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "arrayMaxConsecutiveSum",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def arrayMaxConsecutiveSum(inputArray, k):\n    sums = [sum(inputArray[:k])]\n    for i in range(1, len(inputArray) - k + 1):\n        sums.append(sums[i - 1] - inputArray[i - 1] + inputArray[i + k - 1])\n    return max(sums)\ndef growingPlant(upSpeed, downSpeed, desiredHeight):\n    height = 0\n    days = 1\n    height += upSpeed\n    while height < desiredHeight:",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "growingPlant",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def growingPlant(upSpeed, downSpeed, desiredHeight):\n    height = 0\n    days = 1\n    height += upSpeed\n    while height < desiredHeight:\n        days += 1\n        height -= downSpeed\n        height += upSpeed\n    return days\ndef knapsackLight(value1, weight1, value2, weight2, maxW):",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "knapsackLight",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def knapsackLight(value1, weight1, value2, weight2, maxW):\n    if weight1 + weight2 <= maxW:\n        return value1 + value2\n    if weight1 <= maxW and (weight2 > maxW or value1 >= value2):\n        return value1\n    if weight2 <= maxW and (weight1 > maxW or value2 >= value1):\n        return value2\n    return 0\ndef longestDigitsPrefix(inputString):\n    for char in range(len(inputString)):",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "longestDigitsPrefix",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def longestDigitsPrefix(inputString):\n    for char in range(len(inputString)):\n        if not inputString[char].isdigit():\n            return inputString[:char]\n    return inputString\ndef digitDegree(n):\n    degree = 0\n    while len(str(n)) > 1:\n        n = sum((int(digit) for digit in str(n)))\n        degree += 1",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "digitDegree",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def digitDegree(n):\n    degree = 0\n    while len(str(n)) > 1:\n        n = sum((int(digit) for digit in str(n)))\n        degree += 1\n    return degree\ndef bishopAndPawn(bishop, pawn):\n    return abs(ord(bishop[0]) - ord(pawn[0])) == abs(ord(bishop[1]) - ord(pawn[1]))\ndef isBeautifulString(inputString):\n    for letter in range(ord(\"a\"), ord(\"z\")):",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "bishopAndPawn",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def bishopAndPawn(bishop, pawn):\n    return abs(ord(bishop[0]) - ord(pawn[0])) == abs(ord(bishop[1]) - ord(pawn[1]))\ndef isBeautifulString(inputString):\n    for letter in range(ord(\"a\"), ord(\"z\")):\n        if inputString.count(chr(letter)) < inputString.count(chr(letter + 1)):\n            return False\n    return True\ndef findEmailDomain(address):\n    return address[address.rfind(\"@\") + 1 :]\ndef buildPalindrome(st):",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "isBeautifulString",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def isBeautifulString(inputString):\n    for letter in range(ord(\"a\"), ord(\"z\")):\n        if inputString.count(chr(letter)) < inputString.count(chr(letter + 1)):\n            return False\n    return True\ndef findEmailDomain(address):\n    return address[address.rfind(\"@\") + 1 :]\ndef buildPalindrome(st):\n    if st == st[::-1]:  # Check for initial palindrome\n        return st",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "findEmailDomain",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def findEmailDomain(address):\n    return address[address.rfind(\"@\") + 1 :]\ndef buildPalindrome(st):\n    if st == st[::-1]:  # Check for initial palindrome\n        return st\n    index = 0\n    subStr = st[index:]\n    while subStr != subStr[::-1]:  # while substring is not a palindrome\n        index += 1\n        subStr = st[index:]",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "buildPalindrome",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def buildPalindrome(st):\n    if st == st[::-1]:  # Check for initial palindrome\n        return st\n    index = 0\n    subStr = st[index:]\n    while subStr != subStr[::-1]:  # while substring is not a palindrome\n        index += 1\n        subStr = st[index:]\n    return st + st[index - 1 :: -1]\ndef electionsWinners(votes, k):",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "electionsWinners",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def electionsWinners(votes, k):\n    winners = 0\n    current_winner = max(votes)\n    for candidate in votes:\n        if k > 0 and candidate + k > current_winner:\n            winners += 1\n        if k == 0 and candidate == current_winner and votes.count(candidate) == 1:\n            winners += 1\n    return winners\ndef isMAC48Address(inputString):",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "isMAC48Address",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def isMAC48Address(inputString):\n    hex_chars = (\n        \"1\",\n        \"2\",\n        \"3\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"7\",\n        \"8\",",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "isDigit",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def isDigit(symbol):\n    return symbol.isdigit()\ndef lineEncoding(s):\n    count = 1\n    output = []\n    for char in range(1, len(s)):\n        if s[char] == s[char - 1]:\n            count += 1\n        else:\n            if count > 1:",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "lineEncoding",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def lineEncoding(s):\n    count = 1\n    output = []\n    for char in range(1, len(s)):\n        if s[char] == s[char - 1]:\n            count += 1\n        else:\n            if count > 1:\n                output.append(str(count) + s[char - 1])\n            else:",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "chessKnight",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def chessKnight(cell):\n    moves = 0\n    # Starting at the top left, going counter-clockwise\n    if ord(cell[0]) >= ord(\"b\") and ord(cell[1]) <= ord(\"6\"):\n        moves += 1\n    if ord(cell[0]) >= ord(\"c\") and ord(cell[1]) <= ord(\"7\"):\n        moves += 1\n    if ord(cell[0]) >= ord(\"c\") and ord(cell[1]) >= ord(\"2\"):\n        moves += 1\n    if ord(cell[0]) >= ord(\"b\") and ord(cell[1]) >= ord(\"3\"):",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "deleteDigit",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def deleteDigit(n):\n    num = str(n)\n    highest = 0\n    for digit in range(len(num)):\n        output = num[:digit] + num[digit + 1 :]\n        if int(output) > int(highest):\n            highest = output\n    return int(highest)\ndef longestWord(text):\n    longest = []",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "longestWord",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def longestWord(text):\n    longest = []\n    word = []\n    for char in text:\n        if ord(\"A\") <= ord(char) <= ord(\"Z\") or ord(\"a\") <= ord(char) <= ord(\"z\"):\n            word.append(char)\n        else:\n            if len(word) > len(longest):\n                longest = word\n            word = []",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "validTime",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def validTime(time):\n    groups = time.split(\":\")\n    if len(groups) != 2:\n        return False\n    if not (groups[0].isdigit() and groups[1].isdigit()):\n        return False\n    if int(groups[0]) > 23 or int(groups[1]) > 59:\n        return False\n    return True\ndef sumUpNumbers(inputString):",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "sumUpNumbers",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def sumUpNumbers(inputString):\n    total = 0\n    current_num = []\n    for char in inputString:\n        if char.isdigit():\n            current_num.append(char)\n        else:\n            if len(current_num) > 0:\n                num = int(\"\".join(current_num))\n                total += num",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "differentSquares",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def differentSquares(matrix):\n    squares = set()\n    for row in range(len(matrix) - 1):\n        for cell in range(len(matrix[row]) - 1):\n            square = (\n                (matrix[row][cell], matrix[row][cell + 1]),\n                (matrix[row + 1][cell], matrix[row + 1][cell + 1]),\n            )\n            squares.add(square)\n    return len(squares)",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "digitsProduct",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def digitsProduct(product):\n    # New idea: add product to factors\n    # while max(factors) > 10: split that num into factors\n    if product == 0:\n        return 10\n    factors = [product]\n    while max(factors) > 9:\n        factored = findFactors(max(factors))\n        if factored:\n            factors.remove(max(factors))",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "findFactors",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def findFactors(n):\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return i, n // i\n    return False\ndef fileNaming(names):\n    outnames = []\n    for name in names:\n        if name in outnames:\n            k = 1",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "fileNaming",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def fileNaming(names):\n    outnames = []\n    for name in names:\n        if name in outnames:\n            k = 1\n            while \"{}({})\".format(name, k) in outnames:\n                k += 1\n            name = \"{}({})\".format(name, k)\n        outnames.append(name)\n    return outnames",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "messageFromBinaryCode",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def messageFromBinaryCode(code):\n    output = []\n    for i in range(0, len(code), 8):\n        letter = chr(int(code[i : i + 8], 2))\n        output.append(letter)\n    return \"\".join(output)\ndef spiralNumbers(n):\n    LEFT = \"left\"\n    RIGHT = \"right\"\n    UP = \"up\"",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "spiralNumbers",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def spiralNumbers(n):\n    LEFT = \"left\"\n    RIGHT = \"right\"\n    UP = \"up\"\n    DOWN = \"down\"\n    direction = RIGHT\n    spiral = [[0 for i in range(n)] for j in range(n)]\n    row = 0\n    cell = 0\n    for num in range(1, (n * n) + 1):",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "sudoku",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def sudoku(grid):\n    match = [i for i in range(1, 10)]\n    for row in grid:\n        if sorted(row) != match:\n            return False\n    for column_index in range(9):\n        column = [grid[row_index][column_index] for row_index in range(9)]\n        if sorted(column) != match:\n            return False\n    for row in range(0, 9, 3):",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "addTwoDigits",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def addTwoDigits(n):\n    return (n // 10) + (n % 10)\ndef largestNumber(n):\n    return int(\"9\" * n)\ndef candies(n, m):\n    return (m // n) * n\ndef seatsInTheater(nCols, nRows, col, row):\n    return (nCols - col + 1) * (nRows - row)\ndef maxMultiple(divisor, bound):\n    for num in range(bound, 1, -1):",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "largestNumber",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def largestNumber(n):\n    return int(\"9\" * n)\ndef candies(n, m):\n    return (m // n) * n\ndef seatsInTheater(nCols, nRows, col, row):\n    return (nCols - col + 1) * (nRows - row)\ndef maxMultiple(divisor, bound):\n    for num in range(bound, 1, -1):\n        if num % divisor == 0:\n            return num",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "candies",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def candies(n, m):\n    return (m // n) * n\ndef seatsInTheater(nCols, nRows, col, row):\n    return (nCols - col + 1) * (nRows - row)\ndef maxMultiple(divisor, bound):\n    for num in range(bound, 1, -1):\n        if num % divisor == 0:\n            return num\n    return 0\ndef circleOfNumbers(n, firstNumber):",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "seatsInTheater",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def seatsInTheater(nCols, nRows, col, row):\n    return (nCols - col + 1) * (nRows - row)\ndef maxMultiple(divisor, bound):\n    for num in range(bound, 1, -1):\n        if num % divisor == 0:\n            return num\n    return 0\ndef circleOfNumbers(n, firstNumber):\n    return (firstNumber + (n // 2)) % n\ndef lateRide(n):",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "maxMultiple",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def maxMultiple(divisor, bound):\n    for num in range(bound, 1, -1):\n        if num % divisor == 0:\n            return num\n    return 0\ndef circleOfNumbers(n, firstNumber):\n    return (firstNumber + (n // 2)) % n\ndef lateRide(n):\n    hours = n // 60\n    minutes = n % 60",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "circleOfNumbers",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def circleOfNumbers(n, firstNumber):\n    return (firstNumber + (n // 2)) % n\ndef lateRide(n):\n    hours = n // 60\n    minutes = n % 60\n    return (hours // 10) + (hours % 10) + (minutes // 10) + (minutes % 10)\ndef phoneCall(min1, min2_10, min11, s):\n    if s < min1:\n        return 0\n    if s == min1:",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "lateRide",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def lateRide(n):\n    hours = n // 60\n    minutes = n % 60\n    return (hours // 10) + (hours % 10) + (minutes // 10) + (minutes % 10)\ndef phoneCall(min1, min2_10, min11, s):\n    if s < min1:\n        return 0\n    if s == min1:\n        return 1\n    if s <= min1 + (min2_10 * 9):",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "phoneCall",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def phoneCall(min1, min2_10, min11, s):\n    if s < min1:\n        return 0\n    if s == min1:\n        return 1\n    if s <= min1 + (min2_10 * 9):\n        s -= min1\n        return (s // min2_10) + 1\n    s -= min1\n    s -= min2_10 * 9",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "reachNextLevel",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def reachNextLevel(experience, threshold, reward):\n    return experience + reward >= threshold\ndef knapsackLight(value1, weight1, value2, weight2, maxW):\n    if weight1 + weight2 <= maxW:\n        return value1 + value2\n    if weight1 <= maxW and weight2 <= maxW:\n        return max(value1, value2)\n    if weight1 <= maxW:\n        return value1\n    if weight2 <= maxW:",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "knapsackLight",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def knapsackLight(value1, weight1, value2, weight2, maxW):\n    if weight1 + weight2 <= maxW:\n        return value1 + value2\n    if weight1 <= maxW and weight2 <= maxW:\n        return max(value1, value2)\n    if weight1 <= maxW:\n        return value1\n    if weight2 <= maxW:\n        return value2\n    return 0",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "extraNumber",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def extraNumber(a, b, c):\n    if a == b:\n        return c\n    if a == c:\n        return b\n    return a\ndef isInfiniteProcess(a, b):\n    return a > b or (a % 2 != b % 2)\ndef arithmeticExpression(a, b, c):\n    return a + b == c or a - b == c or a * b == c or a / b == c",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "isInfiniteProcess",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def isInfiniteProcess(a, b):\n    return a > b or (a % 2 != b % 2)\ndef arithmeticExpression(a, b, c):\n    return a + b == c or a - b == c or a * b == c or a / b == c\ndef tennisSet(score1, score2):\n    if max(score1, score2) == 6 and min(score1, score2) < 5:\n        return True\n    if 5 <= min(score1, score2) <= 6 and max(score1, score2) == 7:\n        return True\n    return False",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "arithmeticExpression",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def arithmeticExpression(a, b, c):\n    return a + b == c or a - b == c or a * b == c or a / b == c\ndef tennisSet(score1, score2):\n    if max(score1, score2) == 6 and min(score1, score2) < 5:\n        return True\n    if 5 <= min(score1, score2) <= 6 and max(score1, score2) == 7:\n        return True\n    return False\ndef willYou(young, beautiful, loved):\n    return (young and beautiful) != loved",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "tennisSet",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def tennisSet(score1, score2):\n    if max(score1, score2) == 6 and min(score1, score2) < 5:\n        return True\n    if 5 <= min(score1, score2) <= 6 and max(score1, score2) == 7:\n        return True\n    return False\ndef willYou(young, beautiful, loved):\n    return (young and beautiful) != loved\ndef metroCard(lastNumberOfDays):\n    if lastNumberOfDays == 30 or lastNumberOfDays == 28:",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "willYou",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def willYou(young, beautiful, loved):\n    return (young and beautiful) != loved\ndef metroCard(lastNumberOfDays):\n    if lastNumberOfDays == 30 or lastNumberOfDays == 28:\n        return [31]\n    return [28, 30, 31]\ndef killKthBit(n, k):\n    return n & ~(2 ** (k - 1))\ndef arrayPacking(a):\n    binary_array = [bin(num)[2:].rjust(8, \"0\") for num in a]",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "metroCard",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def metroCard(lastNumberOfDays):\n    if lastNumberOfDays == 30 or lastNumberOfDays == 28:\n        return [31]\n    return [28, 30, 31]\ndef killKthBit(n, k):\n    return n & ~(2 ** (k - 1))\ndef arrayPacking(a):\n    binary_array = [bin(num)[2:].rjust(8, \"0\") for num in a]\n    out_string = \"\".join(binary_array[::-1])\n    return int(out_string, 2)",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "killKthBit",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def killKthBit(n, k):\n    return n & ~(2 ** (k - 1))\ndef arrayPacking(a):\n    binary_array = [bin(num)[2:].rjust(8, \"0\") for num in a]\n    out_string = \"\".join(binary_array[::-1])\n    return int(out_string, 2)\ndef rangeBitCount(a, b):\n    array = list(range(a, b + 1))\n    binary_array = [bin(num) for num in array]\n    count_array = [binary.count(\"1\") for binary in binary_array]",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "arrayPacking",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def arrayPacking(a):\n    binary_array = [bin(num)[2:].rjust(8, \"0\") for num in a]\n    out_string = \"\".join(binary_array[::-1])\n    return int(out_string, 2)\ndef rangeBitCount(a, b):\n    array = list(range(a, b + 1))\n    binary_array = [bin(num) for num in array]\n    count_array = [binary.count(\"1\") for binary in binary_array]\n    return sum(count_array)\ndef mirrorBits(a):",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "rangeBitCount",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def rangeBitCount(a, b):\n    array = list(range(a, b + 1))\n    binary_array = [bin(num) for num in array]\n    count_array = [binary.count(\"1\") for binary in binary_array]\n    return sum(count_array)\ndef mirrorBits(a):\n    binary = bin(a)[2:]\n    return int(binary[::-1], 2)\ndef secondRightmostZeroBit(n):\n    return 2 ** bin(n)[::-1].find(\"0\", bin(n)[::-1].find(\"0\") + 1)",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "mirrorBits",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def mirrorBits(a):\n    binary = bin(a)[2:]\n    return int(binary[::-1], 2)\ndef secondRightmostZeroBit(n):\n    return 2 ** bin(n)[::-1].find(\"0\", bin(n)[::-1].find(\"0\") + 1)\ndef swapAdjacentBits(n):\n    return ((n >> 1) & 1431655765) | ((n << 1) & 2863311530)\ndef differentRightmostBit(n, m):\n    return 2 ** bin((n ^ m))[::-1].find(\"1\")\ndef equalPairOfBits(n, m):",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "secondRightmostZeroBit",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def secondRightmostZeroBit(n):\n    return 2 ** bin(n)[::-1].find(\"0\", bin(n)[::-1].find(\"0\") + 1)\ndef swapAdjacentBits(n):\n    return ((n >> 1) & 1431655765) | ((n << 1) & 2863311530)\ndef differentRightmostBit(n, m):\n    return 2 ** bin((n ^ m))[::-1].find(\"1\")\ndef equalPairOfBits(n, m):\n    return 2 ** bin(~(n ^ m))[::-1].find(\"1\")\ndef leastFactorial(n):\n    factorial = 1",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "swapAdjacentBits",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def swapAdjacentBits(n):\n    return ((n >> 1) & 1431655765) | ((n << 1) & 2863311530)\ndef differentRightmostBit(n, m):\n    return 2 ** bin((n ^ m))[::-1].find(\"1\")\ndef equalPairOfBits(n, m):\n    return 2 ** bin(~(n ^ m))[::-1].find(\"1\")\ndef leastFactorial(n):\n    factorial = 1\n    index = 1\n    while factorial < n:",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "differentRightmostBit",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def differentRightmostBit(n, m):\n    return 2 ** bin((n ^ m))[::-1].find(\"1\")\ndef equalPairOfBits(n, m):\n    return 2 ** bin(~(n ^ m))[::-1].find(\"1\")\ndef leastFactorial(n):\n    factorial = 1\n    index = 1\n    while factorial < n:\n        index += 1\n        factorial *= index",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "equalPairOfBits",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def equalPairOfBits(n, m):\n    return 2 ** bin(~(n ^ m))[::-1].find(\"1\")\ndef leastFactorial(n):\n    factorial = 1\n    index = 1\n    while factorial < n:\n        index += 1\n        factorial *= index\n    return factorial\ndef countSumOfTwoRepresentations2(n, l, r):",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "leastFactorial",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def leastFactorial(n):\n    factorial = 1\n    index = 1\n    while factorial < n:\n        index += 1\n        factorial *= index\n    return factorial\ndef countSumOfTwoRepresentations2(n, l, r):\n    count = 0\n    a = max(n - r, l)",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "countSumOfTwoRepresentations2",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def countSumOfTwoRepresentations2(n, l, r):\n    count = 0\n    a = max(n - r, l)\n    b = n - a\n    while a <= r and a <= b:\n        count += 1\n        a += 1\n        b -= 1\n    return count\ndef magicalWell(a, b, n):",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "magicalWell",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def magicalWell(a, b, n):\n    total = 0\n    for i in range(n):\n        total += a * b\n        a += 1\n        b += 1\n    return total\ndef lineUp(commands):\n    count = 0\n    smart_student = 0",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "lineUp",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def lineUp(commands):\n    count = 0\n    smart_student = 0\n    dumb_student = 0\n    for command in commands:\n        if command == \"L\":\n            smart_student = (smart_student - 1) % 4\n            dumb_student = (dumb_student + 1) % 4\n        elif command == \"R\":\n            smart_student = (smart_student + 1) % 4",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "additionWithoutCarrying",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def additionWithoutCarrying(param1, param2):\n    # Convert numbers to strings\n    str1 = str(param1)\n    str2 = str(param2)\n    # Pad both to the same length with zeroes (to the left of the numbers)\n    length = max(len(str2), len(str1))\n    str1 = str1.rjust(length, \"0\")\n    str2 = str2.rjust(length, \"0\")\n    output = []\n    for num1, num2 in zip(str1, str2):",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "appleBoxes",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def appleBoxes(k):\n    red = 0\n    yellow = 0\n    for i in range(1, k + 1, 2):\n        yellow += i * i\n    for i in range(2, k + 1, 2):\n        red += i * i\n    return red - yellow\ndef increaseNumberRoundness(n):\n    string = str(n)",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "increaseNumberRoundness",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def increaseNumberRoundness(n):\n    string = str(n)\n    # Check for immediate rejection\n    if \"0\" not in string or len(string) < 2:\n        return False\n    # Since we know there's a 0, if it's not on\n    # the left, then we know to accept\n    if string[-1] != \"0\":\n        return True\n    # If there is only one 0, it must be at the end, so reject.",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "rounders",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def rounders(value):\n    length = len(str(value))\n    magnitude = length - 1\n    for i in range(length - 1):\n        value = int((value / 10) + 0.5)\n    return value * (10 ** magnitude)\ndef candles(candlesNumber, makeNew):\n    totalBurned = 0\n    leftovers = 0\n    while candlesNumber > 0:",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "candles",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def candles(candlesNumber, makeNew):\n    totalBurned = 0\n    leftovers = 0\n    while candlesNumber > 0:\n        totalBurned += candlesNumber\n        leftovers += candlesNumber\n        candlesNumber = 0\n        candlesNumber = leftovers // makeNew\n        leftovers = leftovers % makeNew\n    return totalBurned",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "countBlackCells",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def countBlackCells(n, m):\n    gcd = find_gcd(n, m)\n    line_cells = n + m - gcd\n    line_corner_cells = (gcd - 1) * 2\n    return line_cells + line_corner_cells\ndef find_gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\ndef createArray(size):",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "find_gcd",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def find_gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\ndef createArray(size):\n    return [1] * size\ndef arrayReplace(inputArray, elemToReplace, substitutionElem):\n    output = [\n        elem if elem != elemToReplace else substitutionElem for elem in inputArray\n    ]",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "createArray",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def createArray(size):\n    return [1] * size\ndef arrayReplace(inputArray, elemToReplace, substitutionElem):\n    output = [\n        elem if elem != elemToReplace else substitutionElem for elem in inputArray\n    ]\n    return output\ndef firstReverseTry(arr):\n    if len(arr) < 2:\n        return arr",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "arrayReplace",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def arrayReplace(inputArray, elemToReplace, substitutionElem):\n    output = [\n        elem if elem != elemToReplace else substitutionElem for elem in inputArray\n    ]\n    return output\ndef firstReverseTry(arr):\n    if len(arr) < 2:\n        return arr\n    if len(arr) < 4:\n        return arr[::-1]",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "firstReverseTry",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def firstReverseTry(arr):\n    if len(arr) < 2:\n        return arr\n    if len(arr) < 4:\n        return arr[::-1]\n    return arr[-1:] + arr[1:-1] + arr[:1]\ndef concatenateArrays(a, b):\n    return a + b\ndef removeArrayPart(inputArray, l, r):\n    return inputArray[:l] + inputArray[r + 1 :]",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "concatenateArrays",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def concatenateArrays(a, b):\n    return a + b\ndef removeArrayPart(inputArray, l, r):\n    return inputArray[:l] + inputArray[r + 1 :]\ndef isSmooth(arr):\n    if arr[0] != arr[-1]:\n        return False\n    if len(arr) % 2 == 0:\n        middle = arr[len(arr) // 2] + arr[(len(arr) // 2) - 1]\n    else:",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "removeArrayPart",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def removeArrayPart(inputArray, l, r):\n    return inputArray[:l] + inputArray[r + 1 :]\ndef isSmooth(arr):\n    if arr[0] != arr[-1]:\n        return False\n    if len(arr) % 2 == 0:\n        middle = arr[len(arr) // 2] + arr[(len(arr) // 2) - 1]\n    else:\n        middle = arr[len(arr) // 2]\n    return arr[0] == middle",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "isSmooth",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def isSmooth(arr):\n    if arr[0] != arr[-1]:\n        return False\n    if len(arr) % 2 == 0:\n        middle = arr[len(arr) // 2] + arr[(len(arr) // 2) - 1]\n    else:\n        middle = arr[len(arr) // 2]\n    return arr[0] == middle\ndef replaceMiddle(arr):\n    if len(arr) % 2 != 0:",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "replaceMiddle",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def replaceMiddle(arr):\n    if len(arr) % 2 != 0:\n        return arr\n    right_middle = len(arr) // 2\n    middle_value = arr[right_middle] + arr[right_middle - 1]\n    return arr[: right_middle - 1] + [middle_value] + arr[right_middle + 1 :]\ndef makeArrayConsecutive2(statues):\n    count = 0\n    for i in range(min(statues), max(statues)):\n        if i not in statues:",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "makeArrayConsecutive2",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def makeArrayConsecutive2(statues):\n    count = 0\n    for i in range(min(statues), max(statues)):\n        if i not in statues:\n            count += 1\n    return count\ndef isPower(n):\n    if n == 1:\n        return True\n    a = 2",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "isPower",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def isPower(n):\n    if n == 1:\n        return True\n    a = 2\n    b = 2\n    while a ** 2 <= n:\n        while a ** b <= n:\n            if a ** b == n:\n                return True\n            b += 1",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "isSumOfConsecutive2",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def isSumOfConsecutive2(n):\n    count = 0\n    right = 2\n    arr = [1, 2]\n    while right <= (n // 2) + 1:\n        total = sum(arr)\n        if total == n:\n            count += 1\n            del arr[0]\n        elif total < n:",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "squareDigitsSequence",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def squareDigitsSequence(a0):\n    sequence = [a0]\n    while sequence[-1] not in sequence[:-1]:\n        next_value = 0\n        for digit in str(sequence[-1]):\n            next_value += int(digit) ** 2\n        sequence.append(next_value)\n    return len(sequence)\ndef pagesNumberingWithInk(current, numberOfDigits):\n    numberOfDigits -= len(str(current))",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "pagesNumberingWithInk",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def pagesNumberingWithInk(current, numberOfDigits):\n    numberOfDigits -= len(str(current))\n    next_digits = len(str(current + 1))\n    while numberOfDigits >= next_digits:\n        current += 1\n        numberOfDigits -= next_digits\n        next_digits = len(str(current))\n    return current\ndef comfortableNumbers(l, r):\n    count = 0",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "comfortableNumbers",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def comfortableNumbers(l, r):\n    count = 0\n    for a in range(l, r):\n        for b in range(a + 1, r + 1):\n            a_sum = sum(int(digit) for digit in str(a))\n            b_sum = sum(int(digit) for digit in str(b))\n            if b <= a + a_sum and a >= b - b_sum:\n                count += 1\n    return count\ndef weakNumbers(n):",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "weakNumbers",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def weakNumbers(n):\n    all_factors = [count_factors(num) for num in range(1, n + 1)]\n    weaknesses = []\n    for num, num_factors in enumerate(all_factors, 1):\n        weakness = 0\n        for factor in all_factors[:num]:\n            if factor > num_factors:\n                weakness += 1\n        weaknesses.append(weakness)\n        weakest = max(weaknesses)",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "count_factors",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def count_factors(n):\n    factors = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            factors += 1\n    return factors\nprint(weakNumbers(500))\nimport math\ndef rectangleRotation(a, b):\n    n = a / (2 ** 0.5)",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    },
    {
        "label": "rectangleRotation",
        "kind": 2,
        "importPath": "_GENERAL.CodeSignal-Solutions.merged",
        "description": "_GENERAL.CodeSignal-Solutions.merged",
        "peekOfCode": "def rectangleRotation(a, b):\n    n = a / (2 ** 0.5)\n    m = b / (2 ** 0.5)\n    points = (math.floor(n) * math.floor(m)) + (math.ceil(n) * math.ceil(m))\n    if math.floor(n) % 2 != math.floor(m) % 2:\n        points -= 1\n    return points\n# rectangleRotation(6, 4)\nprint(rectangleRotation(8, 6))",
        "detail": "_GENERAL.CodeSignal-Solutions.merged",
        "documentation": {}
    }
]