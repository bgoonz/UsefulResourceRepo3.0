<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>d3</title>
    <style>
      /* cspell:disable-file */
      /* webkit printing magic: print all background colors */
      html {
        -webkit-print-color-adjust: exact;
      }
      * {
        box-sizing: border-box;
        -webkit-print-color-adjust: exact;
      }

      html,
      body {
        margin: 0;
        padding: 0;
      }
      @media only screen {
        body {
          margin: 2em auto;
          max-width: 900px;
          color: rgb(55, 53, 47);
        }
      }

      body {
        line-height: 1.5;
        white-space: pre-wrap;
      }

      a,
      a.visited {
        color: inherit;
        text-decoration: underline;
      }

      .pdf-relative-link-path {
        font-size: 80%;
        color: #444;
      }

      h1,
      h2,
      h3 {
        letter-spacing: -0.01em;
        line-height: 1.2;
        font-weight: 600;
        margin-bottom: 0;
      }

      .page-title {
        font-size: 2.5rem;
        font-weight: 700;
        margin-top: 0;
        margin-bottom: 0.75em;
      }

      h1 {
        font-size: 1.875rem;
        margin-top: 1.875rem;
      }

      h2 {
        font-size: 1.5rem;
        margin-top: 1.5rem;
      }

      h3 {
        font-size: 1.25rem;
        margin-top: 1.25rem;
      }

      .source {
        border: 1px solid #ddd;
        border-radius: 3px;
        padding: 1.5em;
        word-break: break-all;
      }

      .callout {
        border-radius: 3px;
        padding: 1rem;
      }

      figure {
        margin: 1.25em 0;
        page-break-inside: avoid;
      }

      figcaption {
        opacity: 0.5;
        font-size: 85%;
        margin-top: 0.5em;
      }

      mark {
        background-color: transparent;
      }

      .indented {
        padding-left: 1.5em;
      }

      hr {
        background: transparent;
        display: block;
        width: 100%;
        height: 1px;
        visibility: visible;
        border: none;
        border-bottom: 1px solid rgba(55, 53, 47, 0.09);
      }

      img {
        max-width: 100%;
      }

      @media only print {
        img {
          max-height: 100vh;
          object-fit: contain;
        }
      }

      @page {
        margin: 1in;
      }

      .collection-content {
        font-size: 0.875rem;
      }

      .column-list {
        display: flex;
        justify-content: space-between;
      }

      .column {
        padding: 0 1em;
      }

      .column:first-child {
        padding-left: 0;
      }

      .column:last-child {
        padding-right: 0;
      }

      .table_of_contents-item {
        display: block;
        font-size: 0.875rem;
        line-height: 1.3;
        padding: 0.125rem;
      }

      .table_of_contents-indent-1 {
        margin-left: 1.5rem;
      }

      .table_of_contents-indent-2 {
        margin-left: 3rem;
      }

      .table_of_contents-indent-3 {
        margin-left: 4.5rem;
      }

      .table_of_contents-link {
        text-decoration: none;
        opacity: 0.7;
        border-bottom: 1px solid rgba(55, 53, 47, 0.18);
      }

      table,
      th,
      td {
        border: 1px solid rgba(55, 53, 47, 0.09);
        border-collapse: collapse;
      }

      table {
        border-left: none;
        border-right: none;
      }

      th,
      td {
        font-weight: normal;
        padding: 0.25em 0.5em;
        line-height: 1.5;
        min-height: 1.5em;
        text-align: left;
      }

      th {
        color: rgba(55, 53, 47, 0.6);
      }

      ol,
      ul {
        margin: 0;
        margin-block-start: 0.6em;
        margin-block-end: 0.6em;
      }

      li > ol:first-child,
      li > ul:first-child {
        margin-block-start: 0.6em;
      }

      ul > li {
        list-style: disc;
      }

      ul.to-do-list {
        text-indent: -1.7em;
      }

      ul.to-do-list > li {
        list-style: none;
      }

      .to-do-children-checked {
        text-decoration: line-through;
        opacity: 0.375;
      }

      ul.toggle > li {
        list-style: none;
      }

      ul {
        padding-inline-start: 1.7em;
      }

      ul > li {
        padding-left: 0.1em;
      }

      ol {
        padding-inline-start: 1.6em;
      }

      ol > li {
        padding-left: 0.2em;
      }

      .mono ol {
        padding-inline-start: 2em;
      }

      .mono ol > li {
        text-indent: -0.4em;
      }

      .toggle {
        padding-inline-start: 0em;
        list-style-type: none;
      }

      /* Indent toggle children */
      .toggle > li > details {
        padding-left: 1.7em;
      }

      .toggle > li > details > summary {
        margin-left: -1.1em;
      }

      .selected-value {
        display: inline-block;
        padding: 0 0.5em;
        background: rgba(206, 205, 202, 0.5);
        border-radius: 3px;
        margin-right: 0.5em;
        margin-top: 0.3em;
        margin-bottom: 0.3em;
        white-space: nowrap;
      }

      .collection-title {
        display: inline-block;
        margin-right: 1em;
      }

      time {
        opacity: 0.5;
      }

      .icon {
        display: inline-block;
        max-width: 1.2em;
        max-height: 1.2em;
        text-decoration: none;
        vertical-align: text-bottom;
        margin-right: 0.5em;
      }

      img.icon {
        border-radius: 3px;
      }

      .user-icon {
        width: 1.5em;
        height: 1.5em;
        border-radius: 100%;
        margin-right: 0.5rem;
      }

      .user-icon-inner {
        font-size: 0.8em;
      }

      .text-icon {
        border: 1px solid #000;
        text-align: center;
      }

      .page-cover-image {
        display: block;
        object-fit: cover;
        width: 100%;
        height: 30vh;
      }

      .page-header-icon {
        font-size: 3rem;
        margin-bottom: 1rem;
      }

      .page-header-icon-with-cover {
        margin-top: -0.72em;
        margin-left: 0.07em;
      }

      .page-header-icon img {
        border-radius: 3px;
      }

      .link-to-page {
        margin: 1em 0;
        padding: 0;
        border: none;
        font-weight: 500;
      }

      p > .user {
        opacity: 0.5;
      }

      td > .user,
      td > time {
        white-space: nowrap;
      }

      input[type='checkbox'] {
        transform: scale(1.5);
        margin-right: 0.6em;
        vertical-align: middle;
      }

      p {
        margin-top: 0.5em;
        margin-bottom: 0.5em;
      }

      .image {
        border: none;
        margin: 1.5em 0;
        padding: 0;
        border-radius: 0;
        text-align: center;
      }

      .code,
      code {
        background: rgba(135, 131, 120, 0.15);
        border-radius: 3px;
        padding: 0.2em 0.4em;
        border-radius: 3px;
        font-size: 85%;
        tab-size: 2;
      }

      code {
        color: #eb5757;
      }

      .code {
        padding: 1.5em 1em;
      }

      .code-wrap {
        white-space: pre-wrap;
        word-break: break-all;
      }

      .code > code {
        background: none;
        padding: 0;
        font-size: 100%;
        color: inherit;
      }

      blockquote {
        font-size: 1.25em;
        margin: 1em 0;
        padding-left: 1em;
        border-left: 3px solid rgb(55, 53, 47);
      }

      .bookmark {
        text-decoration: none;
        max-height: 8em;
        padding: 0;
        display: flex;
        width: 100%;
        align-items: stretch;
      }

      .bookmark-title {
        font-size: 0.85em;
        overflow: hidden;
        text-overflow: ellipsis;
        height: 1.75em;
        white-space: nowrap;
      }

      .bookmark-text {
        display: flex;
        flex-direction: column;
      }

      .bookmark-info {
        flex: 4 1 180px;
        padding: 12px 14px 14px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }

      .bookmark-image {
        width: 33%;
        flex: 1 1 180px;
        display: block;
        position: relative;
        object-fit: cover;
        border-radius: 1px;
      }

      .bookmark-description {
        color: rgba(55, 53, 47, 0.6);
        font-size: 0.75em;
        overflow: hidden;
        max-height: 4.5em;
        word-break: break-word;
      }

      .bookmark-href {
        font-size: 0.75em;
        margin-top: 0.25em;
      }

      .sans {
        font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont,
          'Segoe UI', Helvetica, 'Apple Color Emoji', Arial, sans-serif,
          'Segoe UI Emoji', 'Segoe UI Symbol';
      }
      .code {
        font-family: 'SFMono-Regular', Menlo, Consolas, 'PT Mono',
          'Liberation Mono', Courier, monospace;
      }
      .serif {
        font-family: Lyon-Text, Georgia, ui-serif, serif;
      }
      .mono {
        font-family: iawriter-mono, Nitti, Menlo, Courier, monospace;
      }
      .pdf .sans {
        font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont,
          'Segoe UI', Helvetica, 'Apple Color Emoji', Arial, sans-serif,
          'Segoe UI Emoji', 'Segoe UI Symbol', 'Twemoji', 'Noto Color Emoji',
          'Noto Sans CJK JP';
      }
      .pdf:lang(zh-CN) .sans {
        font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont,
          'Segoe UI', Helvetica, 'Apple Color Emoji', Arial, sans-serif,
          'Segoe UI Emoji', 'Segoe UI Symbol', 'Twemoji', 'Noto Color Emoji',
          'Noto Sans CJK SC';
      }
      .pdf:lang(zh-TW) .sans {
        font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont,
          'Segoe UI', Helvetica, 'Apple Color Emoji', Arial, sans-serif,
          'Segoe UI Emoji', 'Segoe UI Symbol', 'Twemoji', 'Noto Color Emoji',
          'Noto Sans CJK TC';
      }
      .pdf:lang(ko-KR) .sans {
        font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont,
          'Segoe UI', Helvetica, 'Apple Color Emoji', Arial, sans-serif,
          'Segoe UI Emoji', 'Segoe UI Symbol', 'Twemoji', 'Noto Color Emoji',
          'Noto Sans CJK KR';
      }
      .pdf .code {
        font-family: Source Code Pro, 'SFMono-Regular', Menlo, Consolas,
          'PT Mono', 'Liberation Mono', Courier, monospace, 'Twemoji',
          'Noto Color Emoji', 'Noto Sans Mono CJK JP';
      }
      .pdf:lang(zh-CN) .code {
        font-family: Source Code Pro, 'SFMono-Regular', Menlo, Consolas,
          'PT Mono', 'Liberation Mono', Courier, monospace, 'Twemoji',
          'Noto Color Emoji', 'Noto Sans Mono CJK SC';
      }
      .pdf:lang(zh-TW) .code {
        font-family: Source Code Pro, 'SFMono-Regular', Menlo, Consolas,
          'PT Mono', 'Liberation Mono', Courier, monospace, 'Twemoji',
          'Noto Color Emoji', 'Noto Sans Mono CJK TC';
      }
      .pdf:lang(ko-KR) .code {
        font-family: Source Code Pro, 'SFMono-Regular', Menlo, Consolas,
          'PT Mono', 'Liberation Mono', Courier, monospace, 'Twemoji',
          'Noto Color Emoji', 'Noto Sans Mono CJK KR';
      }
      .pdf .serif {
        font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji',
          'Noto Color Emoji', 'Noto Serif CJK JP';
      }
      .pdf:lang(zh-CN) .serif {
        font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji',
          'Noto Color Emoji', 'Noto Serif CJK SC';
      }
      .pdf:lang(zh-TW) .serif {
        font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji',
          'Noto Color Emoji', 'Noto Serif CJK TC';
      }
      .pdf:lang(ko-KR) .serif {
        font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji',
          'Noto Color Emoji', 'Noto Serif CJK KR';
      }
      .pdf .mono {
        font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace,
          'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP';
      }
      .pdf:lang(zh-CN) .mono {
        font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace,
          'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC';
      }
      .pdf:lang(zh-TW) .mono {
        font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace,
          'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC';
      }
      .pdf:lang(ko-KR) .mono {
        font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace,
          'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR';
      }
      .highlight-default {
      }
      .highlight-gray {
        color: rgb(155, 154, 151);
      }
      .highlight-brown {
        color: rgb(100, 71, 58);
      }
      .highlight-orange {
        color: rgb(217, 115, 13);
      }
      .highlight-yellow {
        color: rgb(223, 171, 1);
      }
      .highlight-teal {
        color: rgb(15, 123, 108);
      }
      .highlight-blue {
        color: rgb(11, 110, 153);
      }
      .highlight-purple {
        color: rgb(105, 64, 165);
      }
      .highlight-pink {
        color: rgb(173, 26, 114);
      }
      .highlight-red {
        color: rgb(224, 62, 62);
      }
      .highlight-gray_background {
        background: rgb(235, 236, 237);
      }
      .highlight-brown_background {
        background: rgb(233, 229, 227);
      }
      .highlight-orange_background {
        background: rgb(250, 235, 221);
      }
      .highlight-yellow_background {
        background: rgb(251, 243, 219);
      }
      .highlight-teal_background {
        background: rgb(221, 237, 234);
      }
      .highlight-blue_background {
        background: rgb(221, 235, 241);
      }
      .highlight-purple_background {
        background: rgb(234, 228, 242);
      }
      .highlight-pink_background {
        background: rgb(244, 223, 235);
      }
      .highlight-red_background {
        background: rgb(251, 228, 228);
      }
      .block-color-default {
        color: inherit;
        fill: inherit;
      }
      .block-color-gray {
        color: rgba(55, 53, 47, 0.6);
        fill: rgba(55, 53, 47, 0.6);
      }
      .block-color-brown {
        color: rgb(100, 71, 58);
        fill: rgb(100, 71, 58);
      }
      .block-color-orange {
        color: rgb(217, 115, 13);
        fill: rgb(217, 115, 13);
      }
      .block-color-yellow {
        color: rgb(223, 171, 1);
        fill: rgb(223, 171, 1);
      }
      .block-color-teal {
        color: rgb(15, 123, 108);
        fill: rgb(15, 123, 108);
      }
      .block-color-blue {
        color: rgb(11, 110, 153);
        fill: rgb(11, 110, 153);
      }
      .block-color-purple {
        color: rgb(105, 64, 165);
        fill: rgb(105, 64, 165);
      }
      .block-color-pink {
        color: rgb(173, 26, 114);
        fill: rgb(173, 26, 114);
      }
      .block-color-red {
        color: rgb(224, 62, 62);
        fill: rgb(224, 62, 62);
      }
      .block-color-gray_background {
        background: rgb(235, 236, 237);
      }
      .block-color-brown_background {
        background: rgb(233, 229, 227);
      }
      .block-color-orange_background {
        background: rgb(250, 235, 221);
      }
      .block-color-yellow_background {
        background: rgb(251, 243, 219);
      }
      .block-color-teal_background {
        background: rgb(221, 237, 234);
      }
      .block-color-blue_background {
        background: rgb(221, 235, 241);
      }
      .block-color-purple_background {
        background: rgb(234, 228, 242);
      }
      .block-color-pink_background {
        background: rgb(244, 223, 235);
      }
      .block-color-red_background {
        background: rgb(251, 228, 228);
      }
      .select-value-color-default {
        background-color: rgba(206, 205, 202, 0.5);
      }
      .select-value-color-gray {
        background-color: rgba(155, 154, 151, 0.4);
      }
      .select-value-color-brown {
        background-color: rgba(140, 46, 0, 0.2);
      }
      .select-value-color-orange {
        background-color: rgba(245, 93, 0, 0.2);
      }
      .select-value-color-yellow {
        background-color: rgba(233, 168, 0, 0.2);
      }
      .select-value-color-green {
        background-color: rgba(0, 135, 107, 0.2);
      }
      .select-value-color-blue {
        background-color: rgba(0, 120, 223, 0.2);
      }
      .select-value-color-purple {
        background-color: rgba(103, 36, 222, 0.2);
      }
      .select-value-color-pink {
        background-color: rgba(221, 0, 129, 0.2);
      }
      .select-value-color-red {
        background-color: rgba(255, 0, 26, 0.2);
      }

      .checkbox {
        display: inline-flex;
        vertical-align: text-bottom;
        width: 16;
        height: 16;
        background-size: 16px;
        margin-left: 2px;
        margin-right: 5px;
      }

      .checkbox-on {
        background-image: url('data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E');
      }

      .checkbox-off {
        background-image: url('data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E');
      }
    </style>
  </head>
  <body>
    <article id="a3e20cb3-e7fe-455a-8cb7-d874c5b65940" class="page serif">
      <header>
        <h1 class="page-title">d3</h1>
        <table class="properties">
          <tbody>
            <tr class="property-row property-row-multi_select">
              <th>
                <span class="icon property-icon"
                  ><svg
                    viewBox="0 0 14 14"
                    style="
                      width: 14px;
                      height: 14px;
                      display: block;
                      fill: rgba(55, 53, 47, 0.4);
                      flex-shrink: 0;
                      -webkit-backface-visibility: hidden;
                    "
                    class="typesMultipleSelect"
                  >
                    <path
                      d="M4,3 C4,2.447715 4.447715,2 5,2 L12,2 C12.5523,2 13,2.447716 13,3 C13,3.55228 12.5523,4 12,4 L5,4 C4.447715,4 4,3.55228 4,3 Z M4,7 C4,6.447715 4.447715,6 5,6 L12,6 C12.5523,6 13,6.447716 13,7 C13,7.55228 12.5523,8 12,8 L5,8 C4.447715,8 4,7.55228 4,7 Z M4,11 C4,10.447715 4.447715,10 5,10 L12,10 C12.5523,10 13,10.447716 13,11 C13,11.55228 12.5523,12 12,12 L5,12 C4.447715,12 4,11.55228 4,11 Z M2,4 C1.44771525,4 1,3.55228475 1,3 C1,2.44771525 1.44771525,2 2,2 C2.55228475,2 3,2.44771525 3,3 C3,3.55228475 2.55228475,4 2,4 Z M2,8 C1.44771525,8 1,7.55228475 1,7 C1,6.44771525 1.44771525,6 2,6 C2.55228475,6 3,6.44771525 3,7 C3,7.55228475 2.55228475,8 2,8 Z M2,12 C1.44771525,12 1,11.5522847 1,11 C1,10.4477153 1.44771525,10 2,10 C2.55228475,10 3,10.4477153 3,11 C3,11.5522847 2.55228475,12 2,12 Z"
                    ></path></svg></span
                >Tags
              </th>
              <td>
                <span class="selected-value select-value-color-default"
                  >data structures</span
                ><span class="selected-value select-value-color-green"
                  >python</span
                >
              </td>
            </tr>
          </tbody>
        </table>
      </header>
      <div class="page-body">
        <p id="b3092ad9-9d14-47a2-b9ca-fae13486ca42" class=""></p>
        <p id="9fc944f9-aadc-4ce5-b5c3-b2bec588b22c" class=""></p>
        <p id="87b51cbf-04a0-4592-8345-9b274e7b5d22" class=""></p>
        <figure id="152373df-3a1d-407d-b7dd-cd8997121377" class="image">
          <a href="d3%20a3e20cb3e7fe455a8cb7d874c5b65940/Untitled.png"
            ><img
              style="width: 1139px"
              src="d3%20a3e20cb3e7fe455a8cb7d874c5b65940/Untitled.png"
          /></a>
        </figure>
        <p id="2079dba7-a92f-49c6-803b-b4e21be9ada2" class=""></p>
        <h1 id="6f8b2a83-e6e7-4bf5-8193-7a7481c72b5c" class="">
          Objective 01 - Understand hash collisions and use a linked list for
          collision resolution in a user-defined HashTable class
        </h1>
        <h2 id="ac8b9d47-6c0a-44b8-9f68-24034b371d80" class="">
          <strong>Overview</strong>
        </h2>
        <p id="30e45dfb-09a4-4e1e-ade7-2155d863606b" class="">
          Remember when we wondered what would happen if multiple keys hashed to
          the same index, and we said that we would worry about it later? Whelp,
          it&#x27;s later 🤪.
        </p>
        <p id="7ecf918b-8c2b-4e58-945a-03696fdec39c" class="">
          Let&#x27;s say we were given the key-value pair <code
            >(&quot;Ryan&quot;, 10)</code
          >. Our hash code then maps &quot;Ryan&quot; to index 3. Excellent,
          that works!Now let&#x27;s say after we inserted <code
            >(&quot;Ryan&quot;, 10)</code
          >, we have to insert <code>(&quot;Parth&quot;, 12)</code>. Our hash
          code maps &quot;Parth&quot; to index 3. Uh oh! Ryan is already there!
          What do we do?? 😱
        </p>
        <p id="ebeb08b0-3508-4b4e-abdf-66b8bcf4bc2c" class="">
          Ok, let&#x27;s stop freaking out, and let&#x27;s think about this. If
          we don&#x27;t do anything, the value stored at index 3 will just get
          overwritten. Meaning if we try to retrieve the value associated
          with <code>&quot;Ryan&quot;</code>, 12 will be returned instead of 10.
          That might not seem like a big deal, but what if we were returning
          passwords based on a user ID, and we returned someone else&#x27;s
          password. That would be horrible.
        </p>
        <p id="4b4c261f-2d22-402b-add3-266e9674dd3d" class="">
          Let&#x27;s fix this problem. The most common way to solve this is
          with <strong>chaining</strong>. If we see multiple values hashed to an
          index, we will chain them in a some data structure that can hold
          multiple items. In our case, we&#x27;ll use
          Python&#x27;s <code>list</code> type, but a more typical solution
          would use a linked list. We&#x27;ll cover linked lists in a future
          module.
        </p>
        <figure id="0ed6e75a-e0bb-435e-9f0c-f4d95b711ce7" class="image">
          <a
            href="https://tk-assets.lambdaschool.com/f952600c-f3e0-4d96-bb53-def08235c9c0_collision.gif"
            ><img
              src="https://tk-assets.lambdaschool.com/f952600c-f3e0-4d96-bb53-def08235c9c0_collision.gif"
          /></a>
        </figure>
        <p id="458afcb5-db8c-455f-b8f3-396b07623a66" class="">
          Ok, sounds ideal? But how does this work in code? Let&#x27;s write
          some of it together.
        </p>
        <h2 id="52edc29b-25c9-44c3-a404-a8769a43d738" class="">
          <strong>Follow Along</strong>
        </h2>
        <p id="bc8704a5-468e-40f9-a0e5-adaf8792951b" class="">
          Below is a partially filled out hash table class where we will be
          using <code>HashTableEntry</code> as our chain entries.
        </p>
        <p id="80977690-ca65-4b33-9ebf-d8ba7ef85af0" class="">
          Take a look at the code below.
        </p>
        <pre
          id="5cf3afe8-3a38-4eaf-975e-712960ded408"
          class="code code-wrap"
        ><code>class HashTableEntry:
    &quot;&quot;&quot;
    Hash table key/value pair to go in our collision chain
    &quot;&quot;&quot;
    def __init__(self, key, value):
        self.key = key
        self.value = value

# Hash table can&#x27;t have fewer than this many slots
MIN_CAPACITY = 8

class HashTable:
    &quot;&quot;&quot;
    A hash table with `capacity` buckets
    that accepts string keys
    Implement this.
    &quot;&quot;&quot;

    def __init__(self, capacity):
        self.capacity = capacity  # Number of buckets in the hash table

        self.storage = []
        for _ in range(capacity):   # Initialize with empty lists
            self.storage.append([])

        self.item_count = 0

    def get_num_slots(self):
        &quot;&quot;&quot;
        Return the length of the list you&#x27;re using to hold the hash table data. (Not the number of items stored in the hash table,
        but the number of slots in the main list.)
        One of the tests relies on this.
        Implement this.
        &quot;&quot;&quot;
        # Your code here

    def get_load_factor(self):
        &quot;&quot;&quot;
        Return the load factor for this hash table.
        Implement this.
        &quot;&quot;&quot;
        return len(self.storage)

    def djb2(self, key):
        &quot;&quot;&quot;
        DJB2 hash, 32-bit
        Implement this, and/or FNV-1.
        &quot;&quot;&quot;
        str_key = str(key).encode()

        hash = FNV_offset_basis_64

        for b in str_key:
            hash *= FNV_prime_64
            hash ^= b
            hash &amp;= 0xffffffffffffffff  # 64-bit hash

        return hash

    def hash_index(self, key):
        &quot;&quot;&quot;
        Take an arbitrary key and return a valid integer index between within the hash table&#x27;s storage capacity.
        &quot;&quot;&quot;
        return self.djb2(key) % self.capacity

    def put(self, key, value):
        &quot;&quot;&quot;
        Store the value with the given key.
        Hash collisions should be handled with Linked List Chaining.
        Implement this.
        &quot;&quot;&quot;
        # Your code here

    def delete(self, key):
        &quot;&quot;&quot;
        Remove the value stored with the given key.
        Print a warning if the key is not found.
        Implement this.
        &quot;&quot;&quot;
        # Your code here

    def get(self, key):
        &quot;&quot;&quot;
        Retrieve the value stored with the given key.
        Returns None if the key is not found.
        Implement this.
        &quot;&quot;&quot;
        # Your code here</code></pre>
        <p id="302855e8-be70-499f-be5e-8b6574646441" class="">
          Let&#x27;s implement the <code>put</code> method with collision
          resolution by chaining. What are the two cases we need to handle?
        </p>
        <ol
          type="1"
          id="3df6ebf4-5e80-45c7-a1f4-903a25c93a3b"
          class="numbered-list"
          start="1"
        >
          <li>
            <strong>There are no entries at the index</strong>. Great! We can
            initialize the entry to a list with the
            new <code>HashTableEntry</code> in it.
          </li>
        </ol>
        <ol
          type="1"
          id="b6700e68-f4b5-471f-9e56-f69fc5ed854d"
          class="numbered-list"
          start="2"
        >
          <li>
            <strong>There are multiple entries at the index.</strong> We need to
            check every entry in the chain. If the key in one of the entries is
            equal to the key we are passing in, we need to replace it. For
            instance, let&#x27;s say we pass in <code
              >(&quot;Ryan&quot;, 12),</code
            > and then we later pass in <code>(&quot;Ryan&quot;, 15)</code>. We
            would need to replace &quot;Ryan&quot;&#x27;s old value with 15. If
            there are no entries that match, we create a new entry at the end of
            the chain.
          </li>
        </ol>
        <p id="0152e932-de46-4ca6-b3b4-4d9a7905193d" class="">
          Ok, that might sound confusing. Let&#x27;s start breaking it down into
          code.
        </p>
        <pre
          id="805fc869-cd63-4242-a6da-8bff5d5542d9"
          class="code code-wrap"
        ><code>    def put(self, key, value):
        &quot;&quot;&quot;
        Store the value with the given key.
        Hash collisions should be handled with Linked List Chaining.
        Implement this.
        &quot;&quot;&quot;
        # Your code here</code></pre>
        <p id="9bc98047-0f64-45b5-abb8-994eeef61876" class="">
          First, we need to hash the key and start with the first entry at that
          index.
        </p>
        <pre
          id="65ef4b06-cbc2-4b11-a193-0c466923d829"
          class="code code-wrap"
        ><code>    def put(self, key, value):
        &quot;&quot;&quot;
        Store the value with the given key.
        Hash collisions should be handled with Linked List Chaining.
        Implement this.
        &quot;&quot;&quot;
        index = self.hash_index(key)

        chain = self.storage[index]</code></pre>
        <p id="70c54aef-163e-4135-ac4d-473a107fe5da" class="">
          Next, we need to go through the chain. We need to check two
          conditions:
        </p>
        <ol
          type="1"
          id="1898fb66-e7bd-4e43-ae4b-657e0365f830"
          class="numbered-list"
          start="1"
        >
          <li>The current entry is not empty.</li>
        </ol>
        <ol
          type="1"
          id="89726b3a-d8bc-4a2c-bae4-c0ada1812c52"
          class="numbered-list"
          start="2"
        >
          <li>
            The key or the current entry is not equal to the key we are passing
            in.
          </li>
        </ol>
        <pre
          id="ff94cc4a-2245-4ad3-86fb-82f71566238f"
          class="code code-wrap"
        ><code>    def put(self, key, value):
        &quot;&quot;&quot;
        Store the value with the given key.
        Hash collisions should be handled with Linked List Chaining.
        Implement this.
        &quot;&quot;&quot;
        index = self.hash_index(key)

        chain = self.storage[index]

        existing_entry = None

        for current_entry in chain:
            if current_entry.key == key:
                exiting_entry = current_entry
                break</code></pre>
        <p id="0c5eab71-d4a4-437f-a8f9-4d21ee9bf6c2" class="">
          Sweet! Now we need to check what happens when the loop breaks. It
          would only break for two reasons:
        </p>
        <ol
          type="1"
          id="0b784820-f100-4996-8f5e-8120d69a3a0f"
          class="numbered-list"
          start="1"
        >
          <li>
            We reached an entry with the same key and need to replace the value.
          </li>
        </ol>
        <ol
          type="1"
          id="cf5f3be4-2640-4378-b99f-b77b8cdd2e9b"
          class="numbered-list"
          start="2"
        >
          <li>
            We reached the end of the chain and need to create a new entry.
          </li>
        </ol>
        <p id="562bb8d5-08b0-4878-bf55-418276210c03" class="">
          Let&#x27;s write that in code!
        </p>
        <pre
          id="ff54e15d-56e4-4694-96aa-ad879139c957"
          class="code code-wrap"
        ><code>    def put(self, key, value):
        &quot;&quot;&quot;
        Store the value with the given key.
        Hash collisions should be handled with Linked List Chaining.
        Implement this.
        &quot;&quot;&quot;
        index = self.hash_index(key)

        chain = self.storage[index]

        existing_entry = None

        for current_entry in chain:
            if current_entry.key == key:
                existing_entry = current_entry
                break

        if existing_entry is not None:
            existing_entry.value = value
        else:
            new_entry = HashTableEntry(key, value)
            chain.append(new_entry)</code></pre>
        <p id="869b91d6-78be-4840-88d8-2151e1aa88f5" class="">
          Great! We created the <code>put</code> method.
        </p>
        <h2 id="6138cc1d-31ff-4c87-aa2f-9d19a8564750" class="">
          <strong>Challenge</strong>
        </h2>
        <p id="ef351b51-56aa-4968-8e23-f71563013820" class=""></p>
        <figure id="50e06b22-d838-436a-aa2a-ee88d2c04969">
          <div class="source">
            <a
              href="https://replit.com/@bgoonz/cs-unit-1-sprint-4-module-2-hash-table-collision-resolution#main.py"
              >https://replit.com/@bgoonz/cs-unit-1-sprint-4-module-2-hash-table-collision-resolution#main.py</a
            >
          </div>
        </figure>
        <p id="6014c100-9dab-4c8e-8029-4382b59823e7" class=""></p>
        <p id="cfbd57f1-8d9d-455b-8a47-14db7fe11922" class=""></p>
        <p id="7b3d3380-d113-459f-aceb-667790f11199" class=""></p>
        <p id="2dab6600-cff7-4fdb-8dfd-155189200c1c" class=""></p>
        <figure id="e2a279c7-aee2-4e77-b0db-990dbaa6f045" class="image">
          <a href="d3%20a3e20cb3e7fe455a8cb7d874c5b65940/Untitled.png"
            ><img
              style="width: 1139px"
              src="d3%20a3e20cb3e7fe455a8cb7d874c5b65940/Untitled.png"
          /></a>
        </figure>
        <p id="071e6fd4-b903-4e32-821e-328115d5b84c" class=""></p>
        <p id="1da2a6c6-0662-4e3a-9057-2d43253b8a26" class=""></p>
        <p id="60d37da4-7516-400b-8c18-1bbce1f488e0" class=""></p>
        <h1 id="608f7d76-e0dc-4df6-8eb8-3f00f096681c" class="">
          Objective 02 - Define and compute the load factor of a hash table and
          implement a hash table that automatically resizes based on load factor
        </h1>
        <h2 id="9b6b5622-bed3-43f0-9f0f-199be14e7b4a" class="">
          <strong>Overview</strong>
        </h2>
        <p id="ed933e70-e982-474b-b8db-38053759b506" class="">
          What does runtime look like with linked list chaining?
        </p>
        <p id="4d34d447-d6cd-4900-86b9-ecae88a191e5" class="">
          The performance of hash tables for search, insertion, and deletion is
          constant time (<code>O(1)</code>) in the average case. However, as the
          chains get longer and longer, in the worst case, those same operations
          are done in linear time (<code>O(n)</code>). The more collisions that
          your hash table has, the less performant the hash table is. To avoid
          collisions, a proper hash function and maintaining a low load factor
          is crucial. What is a load factor?
        </p>
        <h3 id="c4be35ec-b402-4ef3-ab77-1b3ec933a764" class="">
          <strong>Load Factor</strong>
        </h3>
        <p id="29602757-c0bc-45dd-b15d-bf4da51a7281" class="">
          The load factor of a hash table is trivial to calculate. You take the
          number of items stored in the hash table divided by the number of
          slots.
        </p>
        <figure id="96535525-f595-402d-abd0-5d95a8f604f8" class="image">
          <a
            href="https://tk-assets.lambdaschool.com/59d00218-52e2-4f3d-9680-2b2d8baad3ae_S5-M3-O1LoadFactor.001.jpeg"
            ><img
              src="https://tk-assets.lambdaschool.com/59d00218-52e2-4f3d-9680-2b2d8baad3ae_S5-M3-O1LoadFactor.001.jpeg"
          /></a>
        </figure>
        <p id="fbf4fb75-42e9-4a03-9abd-da847c2519ac" class="">
          Hash tables use an array for storage. So, the load factor is the
          number of occupied slots divided by the length of the array. So, an
          array of length 10 with three items in it has a load factor of 0.3,
          and an array of length 20 with twenty items has a load factor of 1. If
          you use linear probing for collision resolution, then the maximum load
          factor is 1. If you use chaining for collision resolution, then the
          load factor can be greater than 1.
        </p>
        <p id="b6c11487-0f40-4f9f-97f1-e5b34d39436c" class="">
          As the load factor of your hash table increases, so does the
          likelihood of a collision, which reduces your hash table&#x27;s
          performance. Therefore, you need to monitor the load factor and resize
          your hash table when the load factor gets too large. The general rule
          of thumb is to resize your hash table when your load factor is greater
          than 0.7. Also, when you resize, it is common to double the size of
          the hash table. When you resize the array, you need to re-insert all
          of the items into this new hash table. You cannot simply copy the old
          items into the new hash table. Each item has to be rerun through the
          hashing function because the hashing function considers the size of
          the hash table when determining the index that it returns.
        </p>
        <p id="9386dc44-a9da-4972-9397-be39b3803938" class="">
          You can see that resizing is an expensive operation, so you don’t want
          to resize too often. However, when we average it out, hash tables are
          constant time (<code>O(1)</code>) even with resizing.
        </p>
        <p id="7ff2eff4-566c-4218-822c-2dbbe99e5bcc" class="">
          The load factor can also be too small. If the hash table is too large
          for the data that it is storing, then memory is being wasted. So, in
          addition to resizing, when the load factor gets too high, you should
          also resize when the load factor gets too low.
        </p>
        <p id="58b65d5c-6cc2-4734-8009-e4a253036d52" class="">
          One way to know when to resize your hash table is to compute the load
          factor whenever an item is inserted or deleted into the hash table. If
          the load factor is too high or too low, then you need to resize.
        </p>
        <p id="d5916627-35f2-4b90-b063-115cbbb2ebbc" class="">
          We added a <code>get_load_factor</code> and <code>resize</code> method
          to calculate the load factor and resize the hash table with a new
          capacity when necessary.
        </p>
        <pre
          id="8b96c773-3e69-4f76-8db1-c2f2634a65af"
          class="code code-wrap"
        ><code>class HashTableEntry:
    &quot;&quot;&quot;
    Linked List hash table key/value pair
    &quot;&quot;&quot;
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.next = None

# Hash table can&#x27;t have fewer than this many slots
MIN_CAPACITY = 8

class HashTable:
    &quot;&quot;&quot;
    A hash table with `capacity` buckets
    that accepts string keys
    Implement this.
    &quot;&quot;&quot;

    def __init__(self, capacity):
        self.capacity = capacity  # Number of buckets in the hash table
        self.storage = [None] * capacity
        self.item_count = 0

    def get_num_slots(self):
        &quot;&quot;&quot;
        Return the length of the list you&#x27;re using to hold the hash
        table data. (Not the number of items stored in the hash table,
        but the number of slots in the main list.)
        One of the tests relies on this.
        Implement this.
        &quot;&quot;&quot;
        # Your code here

    def get_load_factor(self):
        &quot;&quot;&quot;
        Return the load factor for this hash table.
        Implement this.
        &quot;&quot;&quot;
        return self.item_count / self.capacity

    def resize(self, new_capacity):
        &quot;&quot;&quot;
        Changes the capacity of the hash table and
        rehashes all key/value pairs.
        Implement this.
        &quot;&quot;&quot;
        old_storage = self.storage
        self.capacity = new_capacity
        self.storage = [None] * self.capacity

        current_entry = None

        # Save this because put adds to it, and we don&#x27;t want that.
        # It might be less hackish to pass a flag to put indicating that
        # we&#x27;re in a resize and don&#x27;t want to modify item count.
        old_item_count = self.item_count

        for bucket_item in old_storage:
            current_entry = bucket_item
            while current_entry is not None:
                self.put(current_entry.key, current_entry.value)
                current_entry = current_entry.next

        # Restore this to the correct number
        self.item_count = old_item_count

    def djb2(self, key):
        &quot;&quot;&quot;
        DJB2 hash, 32-bit
        Implement this, and/or FNV-1.
        &quot;&quot;&quot;
        str_key = str(key).encode()

        hash = FNV_offset_basis_64

        for b in str_key:
            hash *= FNV_prime_64
            hash ^= b
            hash &amp;= 0xffffffffffffffff  # 64-bit hash

        return hash

    def hash_index(self, key):
        &quot;&quot;&quot;
        Take an arbitrary key and return a valid integer index
        within the hash table&#x27;s storage capacity.
        &quot;&quot;&quot;
        return self.djb2(key) % self.capacity

    def put(self, key, value):
        &quot;&quot;&quot;
        Store the value with the given key.
        Hash collisions should be handled with Linked List Chaining.
        Implement this.
        &quot;&quot;&quot;
        index = self.hash_index(key)

        current_entry = self.storage[index]

        while current_entry is not None and current_entry.key != key:
            current_entry = current_entry.next

        if current_entry is not None:
            current_entry.value = value
        else:
            new_entry = HashTableEntry(key, value)
            new_entry.next = self.storage[index]
            self.storage[index] = new_entry

    def delete(self, key):
        &quot;&quot;&quot;
        Remove the value stored with the given key.
        Print a warning if the key is not found.
        Implement this.
        &quot;&quot;&quot;
        # Your code here

    def get(self, key):
        &quot;&quot;&quot;
        Retrieve the value stored with the given key.
        Returns None if the key is not found.
        Implement this.
        &quot;&quot;&quot;
        # Your code here</code></pre>
        <h2 id="e73fee0e-a94f-4ec5-b33f-de848af43d23" class="">
          <strong>Follow Along</strong>
        </h2>
        <p id="7ffd3f80-98a9-4ab8-aa27-f695043993b3" class="">
          Let&#x27;s change our <code>put</code> method to resize when the load
          factor gets too high. Here&#x27;s how our
          current <code>put</code> method looks:
        </p>
        <pre
          id="2255a062-16c8-4423-9789-7202c9cde4c2"
          class="code code-wrap"
        ><code>def put(self, key, value):
    &quot;&quot;&quot;
    Store the value with the given key.
    Hash collisions should be handled with Linked List Chaining.
    Implement this.
    &quot;&quot;&quot;
    index = self.hash_index(key)

    current_entry = self.storage[index]

    while current_entry is not None and current_entry.key != key:
        current_entry = current_entry.next

    if current_entry is not None:
        current_entry.value = value
    else:
        new_entry = HashTableEntry(key, value)
        new_entry.next = self.storage[index]
        self.storage[index] = new_entry</code></pre>
        <p id="b846f420-c422-42a4-adb4-8f60ca367757" class="">
          To know when to resize, we need to correctly increment the count
          whenever we insert something new into the hash table. Let&#x27;s go
          ahead and add that.
        </p>
        <pre
          id="0972d26d-7246-46df-ac45-185cbf93344b"
          class="code code-wrap"
        ><code>def put(self, key, value):
    &quot;&quot;&quot;
    Store the value with the given key.
    Hash collisions should be handled with Linked List Chaining.
    Implement this.
    &quot;&quot;&quot;
    index = self.hash_index(key)

    current_entry = self.storage[index]

    while current_entry is not None and current_entry.key != key:
        current_entry = current_entry.next

    if current_entry is not None:
        current_entry.value = value
    else:
        new_entry = HashTableEntry(key, value)
        new_entry.next = self.storage[index]
        self.storage[index] = new_entry

        self.item_count += 1</code></pre>
        <p id="92ae752e-8c95-4fb3-8a32-8678f6306329" class="">
          Next, we need to check if the load factor is greater than or equal to
          0.7. If it is, we need to double our capacity and resize.
        </p>
        <pre
          id="1b33ce50-777c-471c-81aa-18dfb8e10585"
          class="code code-wrap"
        ><code>def put(self, key, value):
    &quot;&quot;&quot;
    Store the value with the given key.
    Hash collisions should be handled with Linked List Chaining.
    Implement this.
    &quot;&quot;&quot;
    index = self.hash_index(key)

    current_entry = self.storage[index]

    while current_entry is not None and current_entry.key != key:
        current_entry = current_entry.next

    if current_entry is not None:
        current_entry.value = value
    else:
        new_entry = HashTableEntry(key, value)
        new_entry.next = self.storage[index]
        self.storage[index] = new_entry

        self.item_count += 1

        if self.get_load_factor() &gt; 0.7:
            self.resize(self.capacity * 2)</code></pre>
        <p id="03485bc0-a30d-42eb-a07a-1fe87607f736" class="">
          Fantastic, we did it!
        </p>
        <p id="25d205f6-f022-4dc8-8619-d65c58dd6cac" class=""></p>
        <p id="a00c754f-2e77-4330-aff3-d109c7b853f5" class=""></p>
        <p id="446de2a5-f208-448d-8d9e-d70f468d73a9" class=""></p>
        <p id="cb9cbf11-b412-4b6e-99e8-1c6c207c9c1f" class=""></p>
        <p id="8433ff89-368a-40a9-a5a1-9caa6852318b" class=""></p>
        <figure id="ca64c65c-fb88-456b-bfdc-1773f6e7fde1" class="image">
          <a href="d3%20a3e20cb3e7fe455a8cb7d874c5b65940/Untitled%201.png"
            ><img
              style="width: 1139px"
              src="d3%20a3e20cb3e7fe455a8cb7d874c5b65940/Untitled%201.png"
          /></a>
        </figure>
        <p id="8c88654a-37d4-4f5b-8578-ff7ee5cbdc9d" class=""></p>
        <p id="b38ba67d-7cf3-4e15-87ce-4716eb0e1dfb" class=""></p>
        <p id="470fd60d-e353-4f7c-b835-c215a0cad027" class=""></p>
        <p id="0657d1cd-b2af-4379-a392-e7973a756963" class=""></p>
        <p id="8314d5bb-831b-4454-a451-0aba15ffa929" class=""></p>
        <p id="78756adb-ba01-482b-bedf-c93f8aae2c21" class=""></p>
        <p id="0717969f-df0e-4a04-90f8-9cdeec93e088" class=""></p>
        <p id="e4e9ab80-423a-4079-99b3-e188d9ed4751" class=""></p>
        <p id="38f20d6e-8418-4fbb-b8c5-f9531f5c6e3f" class=""></p>
        <p id="cddb4a1b-1cdf-4588-adf1-d8f540c38555" class=""></p>
        <p id="4c0e7572-20f9-4529-be1a-3d7334245a69" class=""></p>
        <p id="526a0ae0-7670-41a2-ba3d-655b4bf2a362" class=""></p>
        <p id="70515212-7b20-4318-814d-bcabbc774581" class=""></p>
        <p id="bb36092f-53e4-424a-b18c-339835d4d4aa" class=""></p>
        <p id="02d177ad-072b-448c-a7e5-754002b54b33" class=""></p>
        <p id="70726097-667e-4a8b-bf14-f680bc3ad05d" class=""></p>
        <p id="df0b7b87-be72-44da-a23a-ea3bb5972d46" class=""></p>
        <p id="dfe52bc1-78ea-453a-a13f-bd1a85b7fb75" class=""></p>
        <p id="be472c8b-4cc8-4877-989f-7f15279e1159" class=""></p>
        <p id="44f2b710-a745-416d-88fc-f0d051a45f41" class=""></p>
        <p id="b25105ef-4035-46fd-a97f-a3e9eeb229a6" class=""></p>
        <p id="5bd572e0-074b-4289-838d-5fa7503dcea1" class=""></p>
        <p id="4a0401d2-6a13-4b54-869d-e26891168332" class=""></p>
        <p id="4054712d-2643-4031-a794-890a57f59c50" class=""></p>
        <p id="609aeb6b-56fb-4ff1-a3bb-adab32f92470" class=""></p>
        <p id="b7800682-94d2-4587-a3b7-57367972796f" class=""></p>
        <p id="db790af4-529a-4804-b333-d75bcb5b688e" class=""></p>
        <p id="7206e8aa-287d-44ef-a33b-09091e05e4b9" class=""></p>
        <p id="f21f956e-0bc8-40d8-a529-227865db5573" class=""></p>
        <p id="155fc695-feee-4677-88bd-e5bafe3b66fb" class=""></p>
        <p id="4b02e630-6cf5-43dd-8f5e-a368715d1433" class=""></p>
        <p id="18cd6b6d-4f61-4987-998b-d6f5c1fe0bba" class=""></p>
        <p id="2bdfbdbe-c16b-43c3-8db0-75beb858cb3f" class=""></p>
        <p id="01ea7fe5-2b21-40dd-8d70-2e7f8ab82eb9" class=""></p>
        <p id="6a6a4f95-dae3-46fa-b8a9-8cb3d43dd06c" class=""></p>
        <p id="5cf5219c-1072-415b-8694-d8bf24009d37" class=""></p>
        <p id="2b5dc4a3-e891-4ec6-a0f1-a370f9b5aa31" class=""></p>
        <p id="85bf1de6-00aa-4630-9a5f-46f133cbfca6" class=""></p>
        <p id="d4794c6f-65b6-4d88-9189-cf1321ce4744" class=""></p>
        <p id="56ba6fe5-c0c4-47b1-ba11-4e201a22a8c9" class=""></p>
        <p id="863d83e9-f7de-47ad-8b31-b0ae5bf07322" class=""></p>
        <p id="8cf9317f-a685-43c9-a81f-1d9f0908a279" class=""></p>
        <p id="1832a434-6aa3-4dd2-8efd-1b8437235319" class=""></p>
        <p id="8ec8ff2e-e597-4e09-b461-675db65f624e" class=""></p>
        <p id="20ca690d-ee5a-425d-9b82-37b8da020b9d" class=""></p>
        <p id="6d5cd75b-0b7f-4d3c-9969-0f9b3f97a75b" class=""></p>
        <p id="8cce7d81-87a0-4c21-8d37-c3d82c7d4b71" class=""></p>
        <p id="476ce612-d348-4972-9625-a88129e4004a" class=""></p>
        <p id="977b7c7e-6b77-4243-b7e7-b15729242613" class=""></p>
        <p id="e8a13499-2d9f-4eb9-b518-357422c91b10" class=""></p>
        <p id="b2f1001c-2afe-44e0-9e8a-5e6ad1477b7c" class=""></p>
        <p id="5dafb71e-fe61-470e-8156-9fd9f17401d8" class=""></p>
        <p id="61e016a1-97f6-4e7c-a082-99c424fa006c" class=""></p>
        <p id="c097ab76-5a8e-4100-a5f1-42e2c7ea9845" class=""></p>
        <p id="a7101c22-7794-4d44-aa7f-cb1c6f0c4c80" class=""></p>
        <p id="18c3ed20-dc27-435b-852c-9e86833f9e03" class=""></p>
        <h1 id="6ea190af-32d6-487a-aa41-2b9cb6792681" class="">
          Objective 02 - Define and compute the load factor of a hash table and
          implement a hash table that automatically resizes based on load factor
        </h1>
        <h2 id="bcd04909-8674-4b9d-a5a4-b30aa5235168" class="">
          <strong>Overview</strong>
        </h2>
        <p id="51bb01e0-dc93-489a-8b2b-7889319ba0c6" class="">
          What does runtime look like with linked list chaining?
        </p>
        <p id="92d06a60-3650-4e78-8465-6a4a1e95da58" class="">
          The performance of hash tables for search, insertion, and deletion is
          constant time (<code>O(1)</code>) in the average case. However, as the
          chains get longer and longer, in the worst case, those same operations
          are done in linear time (<code>O(n)</code>). The more collisions that
          your hash table has, the less performant the hash table is. To avoid
          collisions, a proper hash function and maintaining a low load factor
          is crucial. What is a load factor?
        </p>
        <h3 id="5c152241-21d8-4cc9-89c2-1a757d6c7e43" class="">
          <strong>Load Factor</strong>
        </h3>
        <p id="092afa2f-2f41-458f-878e-8f8be91ebb08" class="">
          The load factor of a hash table is trivial to calculate. You take the
          number of items stored in the hash table divided by the number of
          slots.
        </p>
        <figure id="ff0ec5b1-cf3e-43f8-a5cd-fb56c31ee802" class="image">
          <a
            href="https://tk-assets.lambdaschool.com/59d00218-52e2-4f3d-9680-2b2d8baad3ae_S5-M3-O1LoadFactor.001.jpeg"
            ><img
              src="https://tk-assets.lambdaschool.com/59d00218-52e2-4f3d-9680-2b2d8baad3ae_S5-M3-O1LoadFactor.001.jpeg"
          /></a>
        </figure>
        <p id="0562c1b5-4dcd-4719-9ca0-3f31384dc16b" class="">
          Hash tables use an array for storage. So, the load factor is the
          number of occupied slots divided by the length of the array. So, an
          array of length 10 with three items in it has a load factor of 0.3,
          and an array of length 20 with twenty items has a load factor of 1. If
          you use linear probing for collision resolution, then the maximum load
          factor is 1. If you use chaining for collision resolution, then the
          load factor can be greater than 1.
        </p>
        <p id="05861a95-4f7d-47e3-b968-ee2246affec8" class="">
          As the load factor of your hash table increases, so does the
          likelihood of a collision, which reduces your hash table&#x27;s
          performance. Therefore, you need to monitor the load factor and resize
          your hash table when the load factor gets too large. The general rule
          of thumb is to resize your hash table when your load factor is greater
          than 0.7. Also, when you resize, it is common to double the size of
          the hash table. When you resize the array, you need to re-insert all
          of the items into this new hash table. You cannot simply copy the old
          items into the new hash table. Each item has to be rerun through the
          hashing function because the hashing function considers the size of
          the hash table when determining the index that it returns.
        </p>
        <p id="acda582d-db94-4a7e-87b7-460ed748af94" class="">
          You can see that resizing is an expensive operation, so you don’t want
          to resize too often. However, when we average it out, hash tables are
          constant time (<code>O(1)</code>) even with resizing.
        </p>
        <p id="bea7c339-e4f5-4e75-a03f-f31d6cb11a7d" class="">
          The load factor can also be too small. If the hash table is too large
          for the data that it is storing, then memory is being wasted. So, in
          addition to resizing, when the load factor gets too high, you should
          also resize when the load factor gets too low.
        </p>
        <p id="a79fc4b3-b57d-468a-852a-ea861c5e2f2f" class="">
          One way to know when to resize your hash table is to compute the load
          factor whenever an item is inserted or deleted into the hash table. If
          the load factor is too high or too low, then you need to resize.
        </p>
        <p id="9c8a2879-e040-4c85-9a72-d738ca519f88" class="">
          We added a <code>get_load_factor</code> and <code>resize</code> method
          to calculate the load factor and resize the hash table with a new
          capacity when necessary.
        </p>
        <pre
          id="128d99ba-4ac4-48d9-8694-b701e0793de1"
          class="code code-wrap"
        ><code>class HashTableEntry:
    &quot;&quot;&quot;
    Linked List hash table key/value pair
    &quot;&quot;&quot;
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.next = None

# Hash table can&#x27;t have fewer than this many slots
MIN_CAPACITY = 8

class HashTable:
    &quot;&quot;&quot;
    A hash table with `capacity` buckets
    that accepts string keys
    Implement this.
    &quot;&quot;&quot;

    def __init__(self, capacity):
        self.capacity = capacity  # Number of buckets in the hash table
        self.storage = [None] * capacity
        self.item_count = 0

    def get_num_slots(self):
        &quot;&quot;&quot;
        Return the length of the list you&#x27;re using to hold the hash
        table data. (Not the number of items stored in the hash table,
        but the number of slots in the main list.)
        One of the tests relies on this.
        Implement this.
        &quot;&quot;&quot;
        # Your code here

    def get_load_factor(self):
        &quot;&quot;&quot;
        Return the load factor for this hash table.
        Implement this.
        &quot;&quot;&quot;
        return self.item_count / self.capacity

    def resize(self, new_capacity):
        &quot;&quot;&quot;
        Changes the capacity of the hash table and
        rehashes all key/value pairs.
        Implement this.
        &quot;&quot;&quot;
        old_storage = self.storage
        self.capacity = new_capacity
        self.storage = [None] * self.capacity

        current_entry = None

        # Save this because put adds to it, and we don&#x27;t want that.
        # It might be less hackish to pass a flag to put indicating that
        # we&#x27;re in a resize and don&#x27;t want to modify item count.
        old_item_count = self.item_count

        for bucket_item in old_storage:
            current_entry = bucket_item
            while current_entry is not None:
                self.put(current_entry.key, current_entry.value)
                current_entry = current_entry.next

        # Restore this to the correct number
        self.item_count = old_item_count

    def djb2(self, key):
        &quot;&quot;&quot;
        DJB2 hash, 32-bit
        Implement this, and/or FNV-1.
        &quot;&quot;&quot;
        str_key = str(key).encode()

        hash = FNV_offset_basis_64

        for b in str_key:
            hash *= FNV_prime_64
            hash ^= b
            hash &amp;= 0xffffffffffffffff  # 64-bit hash

        return hash

    def hash_index(self, key):
        &quot;&quot;&quot;
        Take an arbitrary key and return a valid integer index
        within the hash table&#x27;s storage capacity.
        &quot;&quot;&quot;
        return self.djb2(key) % self.capacity

    def put(self, key, value):
        &quot;&quot;&quot;
        Store the value with the given key.
        Hash collisions should be handled with Linked List Chaining.
        Implement this.
        &quot;&quot;&quot;
        index = self.hash_index(key)

        current_entry = self.storage[index]

        while current_entry is not None and current_entry.key != key:
            current_entry = current_entry.next

        if current_entry is not None:
            current_entry.value = value
        else:
            new_entry = HashTableEntry(key, value)
            new_entry.next = self.storage[index]
            self.storage[index] = new_entry

    def delete(self, key):
        &quot;&quot;&quot;
        Remove the value stored with the given key.
        Print a warning if the key is not found.
        Implement this.
        &quot;&quot;&quot;
        # Your code here

    def get(self, key):
        &quot;&quot;&quot;
        Retrieve the value stored with the given key.
        Returns None if the key is not found.
        Implement this.
        &quot;&quot;&quot;
        # Your code here</code></pre>
        <h2 id="119bd4b4-9145-4eac-b4b4-dc21d9965b4e" class="">
          <strong>Follow Along</strong>
        </h2>
        <p id="bd9de47f-4ac4-42ce-a172-e0b8aa23ef19" class="">
          Let&#x27;s change our <code>put</code> method to resize when the load
          factor gets too high. Here&#x27;s how our
          current <code>put</code> method looks:
        </p>
        <pre
          id="11121c86-0be8-4c7f-a925-a2b042a6f126"
          class="code code-wrap"
        ><code>def put(self, key, value):
    &quot;&quot;&quot;
    Store the value with the given key.
    Hash collisions should be handled with Linked List Chaining.
    Implement this.
    &quot;&quot;&quot;
    index = self.hash_index(key)

    current_entry = self.storage[index]

    while current_entry is not None and current_entry.key != key:
        current_entry = current_entry.next

    if current_entry is not None:
        current_entry.value = value
    else:
        new_entry = HashTableEntry(key, value)
        new_entry.next = self.storage[index]
        self.storage[index] = new_entry</code></pre>
        <p id="4d256f5d-b9e8-4b49-be04-78ea6d99a609" class="">
          To know when to resize, we need to correctly increment the count
          whenever we insert something new into the hash table. Let&#x27;s go
          ahead and add that.
        </p>
        <pre
          id="4075ed5c-1d6d-455c-91b0-33e9b6aa29d6"
          class="code code-wrap"
        ><code>def put(self, key, value):
    &quot;&quot;&quot;
    Store the value with the given key.
    Hash collisions should be handled with Linked List Chaining.
    Implement this.
    &quot;&quot;&quot;
    index = self.hash_index(key)

    current_entry = self.storage[index]

    while current_entry is not None and current_entry.key != key:
        current_entry = current_entry.next

    if current_entry is not None:
        current_entry.value = value
    else:
        new_entry = HashTableEntry(key, value)
        new_entry.next = self.storage[index]
        self.storage[index] = new_entry

        self.item_count += 1</code></pre>
        <p id="0ccc35b9-9532-433a-9fa5-57de9ee0bac5" class="">
          Next, we need to check if the load factor is greater than or equal to
          0.7. If it is, we need to double our capacity and resize.
        </p>
        <pre
          id="1c79af50-d293-4ab8-96e0-470b490681b8"
          class="code code-wrap"
        ><code>def put(self, key, value):
    &quot;&quot;&quot;
    Store the value with the given key.
    Hash collisions should be handled with Linked List Chaining.
    Implement this.
    &quot;&quot;&quot;
    index = self.hash_index(key)

    current_entry = self.storage[index]

    while current_entry is not None and current_entry.key != key:
        current_entry = current_entry.next

    if current_entry is not None:
        current_entry.value = value
    else:
        new_entry = HashTableEntry(key, value)
        new_entry.next = self.storage[index]
        self.storage[index] = new_entry

        self.item_count += 1

        if self.get_load_factor() &gt; 0.7:
            self.resize(self.capacity * 2)</code></pre>
        <p id="dbf9f537-1aeb-4eb0-8263-0e6b0256eaa2" class="">
          Fantastic, we did it!
        </p>
        <h2 id="9e6a3e27-8078-4145-907d-88dae39ba395" class="">
          <strong>Challenge</strong>
        </h2>
        <ol
          type="1"
          id="633a680e-1e82-4b1a-a2c2-5416efaeb9fd"
          class="numbered-list"
          start="1"
        >
          <li>
            Do we need to modify
            our <code>delete</code> and <code>get</code> methods to account for
            the
            new <code>get_load_factor</code> and <code>resize</code> methods?
            Why or why not?
          </li>
        </ol>
        <h2 id="3f08499f-ba96-4189-81a5-69dff83cb5b0" class="">
          <strong>Additional Resources</strong>
        </h2>
        <ul id="7be89631-f407-42eb-9948-c768b7d249b5" class="bulleted-list">
          <li>
            <a href="https://courses.csail.mit.edu/6.006/spring11/rec/rec07.pdf"
              >https://courses.csail.mit.edu/6.006/spring11/rec/rec07.pdf (Links
              to an external site.)</a
            >
          </li>
        </ul>
      </div>
    </article>
  </body>
</html>
