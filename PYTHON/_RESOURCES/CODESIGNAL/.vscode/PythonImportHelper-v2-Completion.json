[
  {
    "label": "collections",
    "kind": 6,
    "isExtraImport": true,
    "importPath": "collections",
    "description": "collections",
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "Counter",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "Counter",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "Counter",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "Counter",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "Counter",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "Counter",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "time",
    "kind": 6,
    "isExtraImport": true,
    "importPath": "time",
    "description": "time",
    "detail": "time",
    "documentation": {}
  },
  {
    "label": "traceback",
    "kind": 6,
    "isExtraImport": true,
    "importPath": "traceback",
    "description": "traceback",
    "detail": "traceback",
    "documentation": {}
  },
  {
    "label": "numpy",
    "kind": 6,
    "isExtraImport": true,
    "importPath": "numpy",
    "description": "numpy",
    "detail": "numpy",
    "documentation": {}
  },
  {
    "label": "re",
    "kind": 6,
    "isExtraImport": true,
    "importPath": "re",
    "description": "re",
    "detail": "re",
    "documentation": {}
  },
  {
    "label": "itertools",
    "kind": 6,
    "isExtraImport": true,
    "importPath": "itertools",
    "description": "itertools",
    "detail": "itertools",
    "documentation": {}
  },
  {
    "label": "groupby",
    "importPath": "itertools",
    "description": "itertools",
    "isExtraImport": true,
    "detail": "itertools",
    "documentation": {}
  },
  {
    "label": "permutations",
    "importPath": "itertools",
    "description": "itertools",
    "isExtraImport": true,
    "detail": "itertools",
    "documentation": {}
  },
  {
    "label": "permutations",
    "importPath": "itertools",
    "description": "itertools",
    "isExtraImport": true,
    "detail": "itertools",
    "documentation": {}
  },
  {
    "label": "permutations",
    "importPath": "itertools",
    "description": "itertools",
    "isExtraImport": true,
    "detail": "itertools",
    "documentation": {}
  },
  {
    "label": "groupby",
    "importPath": "itertools",
    "description": "itertools",
    "isExtraImport": true,
    "detail": "itertools",
    "documentation": {}
  },
  {
    "label": "permutations",
    "importPath": "itertools",
    "description": "itertools",
    "isExtraImport": true,
    "detail": "itertools",
    "documentation": {}
  },
  {
    "label": "permutations",
    "importPath": "itertools",
    "description": "itertools",
    "isExtraImport": true,
    "detail": "itertools",
    "documentation": {}
  },
  {
    "label": "permutations",
    "importPath": "itertools",
    "description": "itertools",
    "isExtraImport": true,
    "detail": "itertools",
    "documentation": {}
  },
  {
    "label": "math",
    "kind": 6,
    "isExtraImport": true,
    "importPath": "math",
    "description": "math",
    "detail": "math",
    "documentation": {}
  },
  {
    "label": "requests",
    "kind": 6,
    "isExtraImport": true,
    "importPath": "requests",
    "description": "requests",
    "detail": "requests",
    "documentation": {}
  },
  {
    "label": "pandas",
    "kind": 6,
    "isExtraImport": true,
    "importPath": "pandas",
    "description": "pandas",
    "detail": "pandas",
    "documentation": {}
  },
  {
    "label": "random",
    "kind": 6,
    "isExtraImport": true,
    "importPath": "random",
    "description": "random",
    "detail": "random",
    "documentation": {}
  },
  {
    "label": "ipaddress",
    "kind": 6,
    "isExtraImport": true,
    "importPath": "ipaddress",
    "description": "ipaddress",
    "detail": "ipaddress",
    "documentation": {}
  },
  {
    "label": "copy",
    "kind": 6,
    "isExtraImport": true,
    "importPath": "copy",
    "description": "copy",
    "detail": "copy",
    "documentation": {}
  },
  {
    "label": "weekday",
    "importPath": "calendar",
    "description": "calendar",
    "isExtraImport": true,
    "detail": "calendar",
    "documentation": {}
  },
  {
    "label": "weekday",
    "importPath": "calendar",
    "description": "calendar",
    "isExtraImport": true,
    "detail": "calendar",
    "documentation": {}
  },
  {
    "label": "unittest",
    "kind": 6,
    "isExtraImport": true,
    "importPath": "unittest",
    "description": "unittest",
    "detail": "unittest",
    "documentation": {}
  },
  {
    "label": "ddt",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "data",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "unpack",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "ddt",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "data",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "unpack",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "ddt",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "data",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "unpack",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "ddt",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "data",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "unpack",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "ddt",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "data",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "unpack",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "ddt",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "data",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "unpack",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "ddt",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "data",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "unpack",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "ddt",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "data",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "unpack",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "ddt",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "data",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "unpack",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "ddt",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "data",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "unpack",
    "importPath": "ddt",
    "description": "ddt",
    "isExtraImport": true,
    "detail": "ddt",
    "documentation": {}
  },
  {
    "label": "add",
    "importPath": "source",
    "description": "source",
    "isExtraImport": true,
    "detail": "source",
    "documentation": {}
  },
  {
    "label": "adjacent_elements_product",
    "importPath": "source",
    "description": "source",
    "isExtraImport": true,
    "detail": "source",
    "documentation": {}
  },
  {
    "label": "century_from_year",
    "importPath": "source",
    "description": "source",
    "isExtraImport": true,
    "detail": "source",
    "documentation": {}
  },
  {
    "label": "palindrome",
    "importPath": "source",
    "description": "source",
    "isExtraImport": true,
    "detail": "source",
    "documentation": {}
  },
  {
    "label": "shape_area",
    "importPath": "source",
    "description": "source",
    "isExtraImport": true,
    "detail": "source",
    "documentation": {}
  },
  {
    "label": "add",
    "importPath": "source",
    "description": "source",
    "isExtraImport": true,
    "detail": "source",
    "documentation": {}
  },
  {
    "label": "adjacent_elements_product",
    "importPath": "source",
    "description": "source",
    "isExtraImport": true,
    "detail": "source",
    "documentation": {}
  },
  {
    "label": "century_from_year",
    "importPath": "source",
    "description": "source",
    "isExtraImport": true,
    "detail": "source",
    "documentation": {}
  },
  {
    "label": "palindrome",
    "importPath": "source",
    "description": "source",
    "isExtraImport": true,
    "detail": "source",
    "documentation": {}
  },
  {
    "label": "shape_area",
    "importPath": "source",
    "description": "source",
    "isExtraImport": true,
    "detail": "source",
    "documentation": {}
  },
  {
    "label": "crosswordFormation",
    "kind": 2,
    "importPath": "CGA-guesses.crossword_creator",
    "description": "CGA-guesses.crossword_creator",
    "peekOfCode": "def crosswordFormation(words):\n    possible_crosswords = 0\n    # check case where all the words are the same or have one letter repeated\n    # setup a map charting the word to each letter to a list of the indices of the letters\n    word_map = defaultdict(lambda: defaultdict(list))\n    for word in words:\n        for i in range(len(word)):\n            word_map[word][word[i]].append(i)\n    seen = set()\n    # first, use nested loops to get all combinations of the words (4! = 24)",
    "detail": "CGA-guesses.crossword_creator",
    "documentation": {}
  },
  {
    "label": "isRotated",
    "kind": 2,
    "importPath": "CGA-guesses.crossword_creator",
    "description": "CGA-guesses.crossword_creator",
    "peekOfCode": "def isRotated(a, b):\n    a = list(a)\n    b = list(b)\n    if a[0] == b[1] and a[1] == b[0] and a[2] == b[3] and a[3] == b[2]:\n        return True\n    return False\nwords = [\"aaaaaaaaaaaaaa\", \"aaaaaaaaaaaaab\", \"aaaaaaaaaaaaca\", \"aaaaaaaaaaadaa\"]\nstart = time.clock()\nprint(crosswordFormation(words))\nprint(time.clock() - start)",
    "detail": "CGA-guesses.crossword_creator",
    "documentation": {}
  },
  {
    "label": "words",
    "kind": 5,
    "importPath": "CGA-guesses.crossword_creator",
    "description": "CGA-guesses.crossword_creator",
    "peekOfCode": "words = [\"aaaaaaaaaaaaaa\", \"aaaaaaaaaaaaab\", \"aaaaaaaaaaaaca\", \"aaaaaaaaaaadaa\"]\nstart = time.clock()\nprint(crosswordFormation(words))\nprint(time.clock() - start)",
    "detail": "CGA-guesses.crossword_creator",
    "documentation": {}
  },
  {
    "label": "start",
    "kind": 5,
    "importPath": "CGA-guesses.crossword_creator",
    "description": "CGA-guesses.crossword_creator",
    "peekOfCode": "start = time.clock()\nprint(crosswordFormation(words))\nprint(time.clock() - start)",
    "detail": "CGA-guesses.crossword_creator",
    "documentation": {}
  },
  {
    "label": "bankRequests",
    "kind": 2,
    "importPath": "CodeSignal-master.bank",
    "description": "CodeSignal-master.bank",
    "peekOfCode": "def bankRequests(accounts, requests):\n    request = []\n    for elements in requests:\n        request.append(elements.split(\" \"))\n    errores = 0\n    for elements in request:\n        if(bank(accounts, elements) == [-2]):\n            errores += 1\n        else:\n            accounts = bank(accounts, elements)",
    "detail": "CodeSignal-master.bank",
    "documentation": {}
  },
  {
    "label": "bank",
    "kind": 2,
    "importPath": "CodeSignal-master.bank",
    "description": "CodeSignal-master.bank",
    "peekOfCode": "def bank(accounts, request):\n    type = request[0]\n    print(accounts)\n    if type == \"withdraw\":\n        index = (int(request[1])-1)\n        if index < len(accounts):\n            print(index)\n            value = int(request[2])\n            if accounts[index] >= value:\n                accounts[index] -= value",
    "detail": "CodeSignal-master.bank",
    "documentation": {}
  },
  {
    "label": "main",
    "kind": 2,
    "importPath": "CodeSignal-master.bank",
    "description": "CodeSignal-master.bank",
    "peekOfCode": "def main():\n    accounts = [10, 100, 20, 50, 30]\n    requests = [\"withdraw  10\", \"transfer 5 1 20\",\n                \"deposit 5 20\", \"transfer 3 4 15\"]\n    print(bankRequests(accounts, requests))\nif __name__ == '__main__':\n    main()",
    "detail": "CodeSignal-master.bank",
    "documentation": {}
  },
  {
    "label": "bankRequests",
    "kind": 2,
    "importPath": "CodeSignal-master.bankManagement",
    "description": "CodeSignal-master.bankManagement",
    "peekOfCode": "def bankRequests(accounts, requests):\n    \"\"\"Shubidubi\"\"\"\n    request = []\n    for elements in requests:  # Se le da un split a todos los elementos de la matriz con parámetro de espacio\n        request.append(elements.split(\" \"))\n    errores = 0\n    for elements in request:        try:\n            accounts = bank(accounts, elements)\n        except Exception as err:\n            errores += 1",
    "detail": "CodeSignal-master.bankManagement",
    "documentation": {}
  },
  {
    "label": "bank",
    "kind": 2,
    "importPath": "CodeSignal-master.bankManagement",
    "description": "CodeSignal-master.bankManagement",
    "peekOfCode": "def bank(accounts, request):\n    type = request[0]\n    print(accounts)\n    if type == \"withdraw\":\n        index = (int(request[1])-1)\n        value = int(request[2])\n        if accounts[index] >= value:\n            accounts[index] -= value\n        else:\n            return \"Error\"",
    "detail": "CodeSignal-master.bankManagement",
    "documentation": {}
  },
  {
    "label": "main",
    "kind": 2,
    "importPath": "CodeSignal-master.bankManagement",
    "description": "CodeSignal-master.bankManagement",
    "peekOfCode": "def main():\n    accounts = [10, 100, 20, 50, 30]\n    requests = [\"withdraw  10\", \"transfer 5 1 20\",\n                \"deposit 5 20\", \"transfer 3 4 15\"]\n    accounts\n    print(bankRequests(accounts, requests))\nif __name__ == '__main__':\n    main()",
    "detail": "CodeSignal-master.bankManagement",
    "documentation": {}
  },
  {
    "label": "bankRequests",
    "kind": 2,
    "importPath": "CodeSignal-master.banks",
    "description": "CodeSignal-master.banks",
    "peekOfCode": "def bankRequests(accounts, requests):\n    map(lambda x: x.split(), requests)\n    print(requests)\ndef main():\n    acco < unts = [10, 100, 20, 50, 30]\n    requests = [\"withdraw 2 10\", \"transfer 5 1 20\",\n                \"deposit 5 20\", \"transfer 3 4 15\"]\n    bankRequests(accounts, requests)\nif __name__ == '__main__':\n    main()",
    "detail": "CodeSignal-master.banks",
    "documentation": {}
  },
  {
    "label": "main",
    "kind": 2,
    "importPath": "CodeSignal-master.banks",
    "description": "CodeSignal-master.banks",
    "peekOfCode": "def main():\n    acco < unts = [10, 100, 20, 50, 30]\n    requests = [\"withdraw 2 10\", \"transfer 5 1 20\",\n                \"deposit 5 20\", \"transfer 3 4 15\"]\n    bankRequests(accounts, requests)\nif __name__ == '__main__':\n    main()\ndef hayDuplicados(lista):\n    lista.sort()\n    for i in range(lista):",
    "detail": "CodeSignal-master.banks",
    "documentation": {}
  },
  {
    "label": "hayDuplicados",
    "kind": 2,
    "importPath": "CodeSignal-master.banks",
    "description": "CodeSignal-master.banks",
    "peekOfCode": "def hayDuplicados(lista):\n    lista.sort()\n    for i in range(lista):\n        if i+1 <= len(lista):\n            if lista[i] == lista[i+1]:\n                return True\n    return False\ndef borrarDuplicados(lista):\n    lista = [set(lista)]",
    "detail": "CodeSignal-master.banks",
    "documentation": {}
  },
  {
    "label": "borrarDuplicados",
    "kind": 2,
    "importPath": "CodeSignal-master.banks",
    "description": "CodeSignal-master.banks",
    "peekOfCode": "def borrarDuplicados(lista):\n    lista = [set(lista)]",
    "detail": "CodeSignal-master.banks",
    "documentation": {}
  },
  {
    "label": "pagarEstacionamiento",
    "kind": 2,
    "importPath": "CodeSignal-master.cajero",
    "description": "CodeSignal-master.cajero",
    "peekOfCode": "def pagarEstacionamiento(apagar):\n    total = apagar\n    print(\"Total a pagar:\" + str(apagar))\n    while apagar > 0:\n        moneda = int(\n            input(\"Ingresa la cantidad de la moneda que quieres ingresar: \"))\n        if moneda == 1 or moneda == 2 or moneda == 5 or moneda == 10 or moneda == 50:\n            apagar -= moneda\n        else:\n            print(",
    "detail": "CodeSignal-master.cajero",
    "documentation": {}
  },
  {
    "label": "main",
    "kind": 2,
    "importPath": "CodeSignal-master.cajero",
    "description": "CodeSignal-master.cajero",
    "peekOfCode": "def main():\n    pagarEstacionamiento(72)\nif __name__ == '__main__':\n    main()",
    "detail": "CodeSignal-master.cajero",
    "documentation": {}
  },
  {
    "label": "constructArray",
    "kind": 2,
    "importPath": "CodeSignal-master.constructArray",
    "description": "CodeSignal-master.constructArray",
    "peekOfCode": "def constructArray(size):\n    lista1 = list(range(1,size+1))\n    lista2 = list(range(size,0,-1))\n    print(lista1)\n    print(lista2)\n    resultado = []\n    ultimo = True\n    for i in range(len(lista1)):\n        if(lista1[i] < lista2[i]):\n            resultado.append(lista1[i])",
    "detail": "CodeSignal-master.constructArray",
    "documentation": {}
  },
  {
    "label": "main",
    "kind": 2,
    "importPath": "CodeSignal-master.constructArray",
    "description": "CodeSignal-master.constructArray",
    "peekOfCode": "def main():\n    constructArray(7)\nif __name__ == '__main__':\n    main()",
    "detail": "CodeSignal-master.constructArray",
    "documentation": {}
  },
  {
    "label": "constructSubmatrix",
    "kind": 2,
    "importPath": "CodeSignal-master.constructSubmatrix",
    "description": "CodeSignal-master.constructSubmatrix",
    "peekOfCode": "def constructSubmatrix(matrix, rowsToDelete, columnsToDelete):\n    for rows in rowsToDelete:\n        del matrix[rows]\n    print(matrix)\n    resultado = []\n    for lista in matrix:  # SACA LAS LISTAS DE LA MATRIZ\n        nuevalista = []\n        for i in range(len(lista)):  # RECORRE LA LISTA CON I\n            if i not in columnsToDelete:\n                nuevalista.append(lista[i])",
    "detail": "CodeSignal-master.constructSubmatrix",
    "documentation": {}
  },
  {
    "label": "main",
    "kind": 2,
    "importPath": "CodeSignal-master.constructSubmatrix",
    "description": "CodeSignal-master.constructSubmatrix",
    "peekOfCode": "def main():\n    matriz = [[1, 0, 0, 2],\n              [0, 5, 0, 1],\n              [0, 0, 3, 5]]\n    print(constructSubmatrix(matriz, [1], [0, 2]))\nif __name__ == '__main__':\n    main()",
    "detail": "CodeSignal-master.constructSubmatrix",
    "documentation": {}
  },
  {
    "label": "digitRootSort",
    "kind": 2,
    "importPath": "CodeSignal-master.digitRootSort",
    "description": "CodeSignal-master.digitRootSort",
    "peekOfCode": "def digitRootSort(a):\n    a.sort()\n    a = map(str, a)\n    separados = []\n    for numeros in a:\n        separados.append(list(numeros))\n    totales = []\n    for i in range(len(separados)):\n        sumaElementos = 0\n        for x in range(len(separados[i])):",
    "detail": "CodeSignal-master.digitRootSort",
    "documentation": {}
  },
  {
    "label": "main",
    "kind": 2,
    "importPath": "CodeSignal-master.digitRootSort",
    "description": "CodeSignal-master.digitRootSort",
    "peekOfCode": "def main():\n    lista = [13, 20, 7, 4]\n    digitRootSort(lista)\nif __name__ == '__main__':\n    main()",
    "detail": "CodeSignal-master.digitRootSort",
    "documentation": {}
  },
  {
    "label": "decodeString",
    "kind": 2,
    "importPath": "CodeSignal-master.encoded",
    "description": "CodeSignal-master.encoded",
    "peekOfCode": "def decodeString(s):\n    return s[s.find(\"[\")+1:s.find(\"]\")]\ndef main():\n    s = \"z1[y]zzz2[abc]\"\n    #zyzzzabcabc\n    print(decodeString(s))\nif __name__ == '__main__':\n    main()",
    "detail": "CodeSignal-master.encoded",
    "documentation": {}
  },
  {
    "label": "main",
    "kind": 2,
    "importPath": "CodeSignal-master.encoded",
    "description": "CodeSignal-master.encoded",
    "peekOfCode": "def main():\n    s = \"z1[y]zzz2[abc]\"\n    #zyzzzabcabc\n    print(decodeString(s))\nif __name__ == '__main__':\n    main()",
    "detail": "CodeSignal-master.encoded",
    "documentation": {}
  },
  {
    "label": "main",
    "kind": 2,
    "importPath": "CodeSignal-master.experimentando",
    "description": "CodeSignal-master.experimentando",
    "peekOfCode": "def main():\n    for i in range(100, 0, -1):\n        print(i)\n    for x in range(1, 100, 3):\n        print(x)\n    pow()\nif __name__ == '__main__':\n    main()",
    "detail": "CodeSignal-master.experimentando",
    "documentation": {}
  },
  {
    "label": "water_collected",
    "kind": 2,
    "importPath": "CodeSignal-master.flooded",
    "description": "CodeSignal-master.flooded",
    "peekOfCode": "def water_collected(heights):\n    water_collected = 0\n    left_height = []\n    right_height = []\n    temp_max = heights[0]\n    for height in heights:\n        if (height > temp_max):\n            temp_max = height\n        left_height.append(temp_max)\n    temp_max = heights[-1]",
    "detail": "CodeSignal-master.flooded",
    "documentation": {}
  },
  {
    "label": "main",
    "kind": 2,
    "importPath": "CodeSignal-master.flooded",
    "description": "CodeSignal-master.flooded",
    "peekOfCode": "def main():\n    numberOfTowers = input()\n    sequenceHeights = input()\n    maxVume(numberOfTowers, sequenceHeights)\nif __name__ == '__main__':\n    main()",
    "detail": "CodeSignal-master.flooded",
    "documentation": {}
  },
  {
    "label": "entrada",
    "kind": 5,
    "importPath": "CodeSignal-master.serie",
    "description": "CodeSignal-master.serie",
    "peekOfCode": "entrada = int(input(\"CUANTAS VECES QUIERES PERRO: \"))\nacumulador = 0\ndenominador = -1\nfor i in range(entrada):\n    denominador += (i*3)\n    acumulador += 1/denominador\nprint(acumulador)",
    "detail": "CodeSignal-master.serie",
    "documentation": {}
  },
  {
    "label": "acumulador",
    "kind": 5,
    "importPath": "CodeSignal-master.serie",
    "description": "CodeSignal-master.serie",
    "peekOfCode": "acumulador = 0\ndenominador = -1\nfor i in range(entrada):\n    denominador += (i*3)\n    acumulador += 1/denominador\nprint(acumulador)",
    "detail": "CodeSignal-master.serie",
    "documentation": {}
  },
  {
    "label": "denominador",
    "kind": 5,
    "importPath": "CodeSignal-master.serie",
    "description": "CodeSignal-master.serie",
    "peekOfCode": "denominador = -1\nfor i in range(entrada):\n    denominador += (i*3)\n    acumulador += 1/denominador\nprint(acumulador)",
    "detail": "CodeSignal-master.serie",
    "documentation": {}
  },
  {
    "label": "launchSequenceChecker",
    "kind": 2,
    "importPath": "CodeSignal-master.spacex",
    "description": "CodeSignal-master.spacex",
    "peekOfCode": "def launchSequenceChecker(systemNames, stepNumbers):",
    "detail": "CodeSignal-master.spacex",
    "documentation": {}
  },
  {
    "label": "zigzags",
    "kind": 2,
    "importPath": "CodeSignal-master.zigzag",
    "description": "CodeSignal-master.zigzag",
    "peekOfCode": "def zigzags(input):\n    input = iter(input)\n    stack = None\n    try:\n        stack = [next(input)]\n        while True:\n            if len(stack) < 2:\n                stack.append(next(input))\n            else:\n                stack = stack[-2:]",
    "detail": "CodeSignal-master.zigzag",
    "documentation": {}
  },
  {
    "label": "zigzag",
    "kind": 2,
    "importPath": "CodeSignal-master.zigzag",
    "description": "CodeSignal-master.zigzag",
    "peekOfCode": "def zigzag(input):\n    item = max(zigzags(input), key=len)\n    print len(item), item",
    "detail": "CodeSignal-master.zigzag",
    "documentation": {}
  },
  {
    "label": "line_is_valid",
    "kind": 2,
    "importPath": "codesignal-my-solutions-master.Sudoku2.sudoku2",
    "description": "codesignal-my-solutions-master.Sudoku2.sudoku2",
    "peekOfCode": "def line_is_valid(row):\n    tmp_dict = {}\n    valid = True\n    if len(row) > 0:\n        # print(row)\n        for r in row:\n            if r in tmp_dict:\n                tmp_dict[r] += 1\n            else:\n                tmp_dict[r] = 1",
    "detail": "codesignal-my-solutions-master.Sudoku2.sudoku2",
    "documentation": {}
  },
  {
    "label": "grid_is_valid",
    "kind": 2,
    "importPath": "codesignal-my-solutions-master.Sudoku2.sudoku2",
    "description": "codesignal-my-solutions-master.Sudoku2.sudoku2",
    "peekOfCode": "def grid_is_valid(grid):\n    valid = True\n    for i in range(len(grid)):\n        row = [int(x) for x in grid[i] if x != \".\"]\n        # print(row)\n        valid = line_is_valid(row)\n        if not valid:\n            break\n    return valid\ndef sudoku2(grid):",
    "detail": "codesignal-my-solutions-master.Sudoku2.sudoku2",
    "documentation": {}
  },
  {
    "label": "sudoku2",
    "kind": 2,
    "importPath": "codesignal-my-solutions-master.Sudoku2.sudoku2",
    "description": "codesignal-my-solutions-master.Sudoku2.sudoku2",
    "peekOfCode": "def sudoku2(grid):\n    result = False\n    # check rows:\n    rows_valid = grid_is_valid(grid)\n    # check columns:\n    col_valid = grid_is_valid(list(zip(*grid)))\n    # check 3x3 grids:\n    grid3x3_valid = True\n    for i in range(0, len(grid), 3):\n        if not grid3x3_valid:",
    "detail": "codesignal-my-solutions-master.Sudoku2.sudoku2",
    "documentation": {}
  },
  {
    "label": "add",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.01 - add",
    "description": "CodeSignal-Solutions-master.01 - add",
    "peekOfCode": "def add(param1, param2):\n    return param1 + param2",
    "detail": "CodeSignal-Solutions-master.01 - add",
    "documentation": {}
  },
  {
    "label": "centuryFromYear",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.02 - centuryFromYear",
    "description": "CodeSignal-Solutions-master.02 - centuryFromYear",
    "peekOfCode": "def centuryFromYear(year):\n    return ((year-1) // 100) + 1",
    "detail": "CodeSignal-Solutions-master.02 - centuryFromYear",
    "documentation": {}
  },
  {
    "label": "checkPalindrome",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.03 - checkPalindrome",
    "description": "CodeSignal-Solutions-master.03 - checkPalindrome",
    "peekOfCode": "def checkPalindrome(inputString):\n    return inputString == inputString[::-1]",
    "detail": "CodeSignal-Solutions-master.03 - checkPalindrome",
    "documentation": {}
  },
  {
    "label": "adjacentElementsProduct",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.04 - adjacentElementsProduct",
    "description": "CodeSignal-Solutions-master.04 - adjacentElementsProduct",
    "peekOfCode": "def adjacentElementsProduct(inputArray):\n    max = inputArray[0] * inputArray[1]\n    for i in range(len(inputArray) - 1):\n        if inputArray[i] * inputArray[i+1] > max:\n            max = inputArray[i] * inputArray[i+1]\n    return max",
    "detail": "CodeSignal-Solutions-master.04 - adjacentElementsProduct",
    "documentation": {}
  },
  {
    "label": "shapeArea",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.05 - shapeArea",
    "description": "CodeSignal-Solutions-master.05 - shapeArea",
    "peekOfCode": "def shapeArea(n):\n    sum = n*2 - 1\n    for i in range(1, (n*2)-1, 2):\n        sum += i*2\n    return sum",
    "detail": "CodeSignal-Solutions-master.05 - shapeArea",
    "documentation": {}
  },
  {
    "label": "makeArrayConsecutive2",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.06 - makeArrayConsecutive2",
    "description": "CodeSignal-Solutions-master.06 - makeArrayConsecutive2",
    "peekOfCode": "def makeArrayConsecutive2(statues):\n    return max(statues) - min(statues) - len(statues) + 1",
    "detail": "CodeSignal-Solutions-master.06 - makeArrayConsecutive2",
    "documentation": {}
  },
  {
    "label": "almostIncreasingSequence",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.07 - almostIncreasingSequence",
    "description": "CodeSignal-Solutions-master.07 - almostIncreasingSequence",
    "peekOfCode": "def almostIncreasingSequence(sequence):\n    i = 0\n    while i < len(sequence) - 1:\n        if not sequence[i] < sequence[i + 1]:\n            if increasingSequence(sequence[:i] + sequence[i+1:]) or \\\n                    increasingSequence(sequence[:i+1] + sequence[i+2:]):\n                return True\n            else:\n                return False\n        i += 1",
    "detail": "CodeSignal-Solutions-master.07 - almostIncreasingSequence",
    "documentation": {}
  },
  {
    "label": "increasingSequence",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.07 - almostIncreasingSequence",
    "description": "CodeSignal-Solutions-master.07 - almostIncreasingSequence",
    "peekOfCode": "def increasingSequence(sequence):\n    for i in range(len(sequence) - 1):\n        if not sequence[i] < sequence[i + 1]:\n            return False\n    return True",
    "detail": "CodeSignal-Solutions-master.07 - almostIncreasingSequence",
    "documentation": {}
  },
  {
    "label": "matrixElementsSum",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.08 - matrixElementsSum",
    "description": "CodeSignal-Solutions-master.08 - matrixElementsSum",
    "peekOfCode": "def matrixElementsSum(matrix):\n    if len(matrix) > 1:\n        for row in range(1, len(matrix)):\n            for room in range(len(matrix[row])):\n                if matrix[row - 1][room] == 0:\n                    matrix[row][room] = 0\n    sum = 0\n    for row in matrix:\n        for room in row:\n            sum += room",
    "detail": "CodeSignal-Solutions-master.08 - matrixElementsSum",
    "documentation": {}
  },
  {
    "label": "allLongestStrings",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.09 - allLongestStrings",
    "description": "CodeSignal-Solutions-master.09 - allLongestStrings",
    "peekOfCode": "def allLongestStrings(inputArray):\n    length = max([len(word) for word in inputArray])\n    result = [word for word in inputArray if len(word) == length]\n    return result",
    "detail": "CodeSignal-Solutions-master.09 - allLongestStrings",
    "documentation": {}
  },
  {
    "label": "commonCharacterCount",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.10 - commonCharacterCount",
    "description": "CodeSignal-Solutions-master.10 - commonCharacterCount",
    "peekOfCode": "def commonCharacterCount(s1, s2):\n    count = 0\n    word2 = list(s2)\n    for letter in s1:\n        if letter in word2:\n            word2.remove(letter)\n            count += 1\n    return count",
    "detail": "CodeSignal-Solutions-master.10 - commonCharacterCount",
    "documentation": {}
  },
  {
    "label": "isLucky",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.11 - isLucky",
    "description": "CodeSignal-Solutions-master.11 - isLucky",
    "peekOfCode": "def isLucky(n):\n    string = str(n)\n    top = [int(x) for x in string[:len(string)//2]]\n    bottom = [int(x) for x in string[len(string)//2:]]\n    return sum(top) == sum(bottom)",
    "detail": "CodeSignal-Solutions-master.11 - isLucky",
    "documentation": {}
  },
  {
    "label": "sortByHeight",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.12 - sortByHeight",
    "description": "CodeSignal-Solutions-master.12 - sortByHeight",
    "peekOfCode": "def sortByHeight(a):\n    treePositions = [x for x in range(len(a)) if a[x] == -1]\n    people = sorted([x for x in a if x != -1])\n    for tree in treePositions:\n        people.insert(tree, -1)\n    return people",
    "detail": "CodeSignal-Solutions-master.12 - sortByHeight",
    "documentation": {}
  },
  {
    "label": "reverseParentheses",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.13 - reverseParentheses",
    "description": "CodeSignal-Solutions-master.13 - reverseParentheses",
    "peekOfCode": "def reverseParentheses(s):\n    while \"(\" in s:\n        match = re.search(\"\\([^()]*\\)\", s)\n        match_string = match.group(0)[1: len(match.group(0)) - 1]\n        reversed_match_string = match_string[::-1]\n        s = s[:match.start()] + reversed_match_string + s[match.end():]\n    return s",
    "detail": "CodeSignal-Solutions-master.13 - reverseParentheses",
    "documentation": {}
  },
  {
    "label": "alternatingSums",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.14 - alternatingSums",
    "description": "CodeSignal-Solutions-master.14 - alternatingSums",
    "peekOfCode": "def alternatingSums(a):\n    team1 = sum(a[0::2])\n    team2 = sum(a[1::2])\n    return [team1, team2]",
    "detail": "CodeSignal-Solutions-master.14 - alternatingSums",
    "documentation": {}
  },
  {
    "label": "addBorder",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.15 - addBorder",
    "description": "CodeSignal-Solutions-master.15 - addBorder",
    "peekOfCode": "def addBorder(picture):\n    picture = [\"*\" + string + \"*\" for string in picture]\n    picture = [(\"*\" * len(picture[0]))] + picture + [(\"*\" * len(picture[0]))]\n    return picture",
    "detail": "CodeSignal-Solutions-master.15 - addBorder",
    "documentation": {}
  },
  {
    "label": "areSimilar",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.16 - areSimilar",
    "description": "CodeSignal-Solutions-master.16 - areSimilar",
    "peekOfCode": "def areSimilar(a, b):\n    diff = [i for i in range(len(a)) if a[i] != b[i]]\n    if len(diff) == 2:\n        b[diff[0]], b[diff[1]] = b[diff[1]], b[diff[0]]\n    return a == b",
    "detail": "CodeSignal-Solutions-master.16 - areSimilar",
    "documentation": {}
  },
  {
    "label": "arrayChange",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.17 - arrayChange",
    "description": "CodeSignal-Solutions-master.17 - arrayChange",
    "peekOfCode": "def arrayChange(inputArray):\n    count = 0\n    for i in range(1, len(inputArray)):\n        if inputArray[i-1] >= inputArray[i]:\n            difference = inputArray[i-1] - inputArray[i]\n            inputArray[i] += difference + 1\n            count += difference + 1\n    return count",
    "detail": "CodeSignal-Solutions-master.17 - arrayChange",
    "documentation": {}
  },
  {
    "label": "palindromeRearranging",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.18 - palindromeRearranging",
    "description": "CodeSignal-Solutions-master.18 - palindromeRearranging",
    "peekOfCode": "def palindromeRearranging(inputString):\n    inputList = sorted(inputString)\n    foundMiddle = False\n    while len(inputList) > 1:\n        if inputList[0] == inputList[1]:\n            del inputList[1]\n        elif not foundMiddle:\n            foundMiddle = True\n        else:\n            return False",
    "detail": "CodeSignal-Solutions-master.18 - palindromeRearranging",
    "documentation": {}
  },
  {
    "label": "areEquallyStrong",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.19 - areEquallyStrong",
    "description": "CodeSignal-Solutions-master.19 - areEquallyStrong",
    "peekOfCode": "def areEquallyStrong(yourLeft, yourRight, friendsLeft, friendsRight):\n    sameHands = yourLeft == friendsLeft and yourRight == friendsRight\n    differentHands = yourLeft == friendsRight and yourRight == friendsLeft\n    return sameHands or differentHands",
    "detail": "CodeSignal-Solutions-master.19 - areEquallyStrong",
    "documentation": {}
  },
  {
    "label": "arrayMaximalAdjacentDifference",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.20 - arrayMaximalAdjacentDifference",
    "description": "CodeSignal-Solutions-master.20 - arrayMaximalAdjacentDifference",
    "peekOfCode": "def arrayMaximalAdjacentDifference(inputArray):\n    diffs = []\n    for i in range(len(inputArray) - 1):\n        diffs.append(abs(inputArray[i] - inputArray[i + 1]))\n    return max(diffs)",
    "detail": "CodeSignal-Solutions-master.20 - arrayMaximalAdjacentDifference",
    "documentation": {}
  },
  {
    "label": "isIPv4Address",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.21 - isIPv4Address",
    "description": "CodeSignal-Solutions-master.21 - isIPv4Address",
    "peekOfCode": "def isIPv4Address(inputString):\n    strings = [string for string in inputString.split('.')]\n    for string in strings:\n        if not string.isdecimal():\n            return False\n    nums = [int(num) for num in strings]\n    return max(nums) <= 255 and min(nums) >= 0 and len(nums) == 4",
    "detail": "CodeSignal-Solutions-master.21 - isIPv4Address",
    "documentation": {}
  },
  {
    "label": "avoidObstacles",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.22 - avoidObstacles",
    "description": "CodeSignal-Solutions-master.22 - avoidObstacles",
    "peekOfCode": "def avoidObstacles(inputArray):\n    for length in range(2, max(inputArray) + 2):\n        done = True\n        jump = length\n        while jump < (max(inputArray) + length):\n            if jump in inputArray:\n                done = False\n                break\n            jump += length\n        if done:",
    "detail": "CodeSignal-Solutions-master.22 - avoidObstacles",
    "documentation": {}
  },
  {
    "label": "boxBlur",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.23 - boxBlur",
    "description": "CodeSignal-Solutions-master.23 - boxBlur",
    "peekOfCode": "def boxBlur(image):\n    outImage = []\n    for row in range(1, len(image) - 1):\n        line = []\n        for pixel in range(1, len(image[row]) - 1):\n            total = (image[row - 1][pixel - 1]\n                     + image[row - 1][pixel]\n                     + image[row - 1][pixel + 1]\n                     + image[row][pixel - 1]\n                     + image[row][pixel]",
    "detail": "CodeSignal-Solutions-master.23 - boxBlur",
    "documentation": {}
  },
  {
    "label": "minesweeper",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.24 - minesweeper",
    "description": "CodeSignal-Solutions-master.24 - minesweeper",
    "peekOfCode": "def minesweeper(matrix):\n    TOP = 0\n    BOTTOM = len(matrix) - 1\n    LEFT = 0\n    RIGHT = len(matrix[0]) - 1\n    outMatrix = []\n    for row in range(len(matrix)):\n        outRow = []\n        for cell in range(len(matrix[row])):\n            outRow.append(0)",
    "detail": "CodeSignal-Solutions-master.24 - minesweeper",
    "documentation": {}
  },
  {
    "label": "arrayReplace",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.25 - arrayReplace",
    "description": "CodeSignal-Solutions-master.25 - arrayReplace",
    "peekOfCode": "def arrayReplace(inputArray, elemToReplace, substitutionElem):\n    return [x if x != elemToReplace else substitutionElem for x in inputArray]",
    "detail": "CodeSignal-Solutions-master.25 - arrayReplace",
    "documentation": {}
  },
  {
    "label": "evenDigitsOnly",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.26 - evenDigitsOnly",
    "description": "CodeSignal-Solutions-master.26 - evenDigitsOnly",
    "peekOfCode": "def evenDigitsOnly(n):\n    return all((True if digit in ('0', '2', '4', '6', '8') else False for digit in str(n)))",
    "detail": "CodeSignal-Solutions-master.26 - evenDigitsOnly",
    "documentation": {}
  },
  {
    "label": "variableName",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.27 - variableName",
    "description": "CodeSignal-Solutions-master.27 - variableName",
    "peekOfCode": "def variableName(name):\n    return name.replace(\"_\", \"\").isalnum() and not name[0].isdigit()",
    "detail": "CodeSignal-Solutions-master.27 - variableName",
    "documentation": {}
  },
  {
    "label": "alphabeticShift",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.28 - alphabeticShift",
    "description": "CodeSignal-Solutions-master.28 - alphabeticShift",
    "peekOfCode": "def alphabeticShift(inputString):\n    return ''.join([chr(ord(x) + 1) if x != 'z' else 'a' for x in inputString])",
    "detail": "CodeSignal-Solutions-master.28 - alphabeticShift",
    "documentation": {}
  },
  {
    "label": "chessBoardCellColor",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.29 - chessBoardCellColor",
    "description": "CodeSignal-Solutions-master.29 - chessBoardCellColor",
    "peekOfCode": "def chessBoardCellColor(cell1, cell2):\n    color1 = ((ord(cell1[0]) - ord('A')) + ord(cell1[1]) - ord('1')) % 2 == 0\n    color2 = ((ord(cell2[0]) - ord('A')) + ord(cell2[1]) - ord('1')) % 2 == 0\n    return color1 == color2",
    "detail": "CodeSignal-Solutions-master.29 - chessBoardCellColor",
    "documentation": {}
  },
  {
    "label": "circleOfNumbers",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.30 - circleOfNumbers",
    "description": "CodeSignal-Solutions-master.30 - circleOfNumbers",
    "peekOfCode": "def circleOfNumbers(n, firstNumber):\n    return (firstNumber + (n / 2)) % n",
    "detail": "CodeSignal-Solutions-master.30 - circleOfNumbers",
    "documentation": {}
  },
  {
    "label": "depositProfit",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.31 - depositProfit",
    "description": "CodeSignal-Solutions-master.31 - depositProfit",
    "peekOfCode": "def depositProfit(deposit, rate, threshold):\n    year = 0\n    while deposit < threshold:\n        deposit *= 1 + (rate / 100)\n        year += 1\n    return year",
    "detail": "CodeSignal-Solutions-master.31 - depositProfit",
    "documentation": {}
  },
  {
    "label": "absoluteValuesSumMinimization",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.32 - absoluteValuesSumMinimization",
    "description": "CodeSignal-Solutions-master.32 - absoluteValuesSumMinimization",
    "peekOfCode": "def absoluteValuesSumMinimization(a):\n    sums = {}\n    for num in a:\n        total = sum([abs(a[i] - num) for i in range(len(a))])\n        if total in sums:\n            sums[total] = min(num, sums[total])\n        else:\n            sums[total] = num\n        print(sums)\n    return sums[min(sums)]",
    "detail": "CodeSignal-Solutions-master.32 - absoluteValuesSumMinimization",
    "documentation": {}
  },
  {
    "label": "stringsRearrangement",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.33 - stringsRearrangement",
    "description": "CodeSignal-Solutions-master.33 - stringsRearrangement",
    "peekOfCode": "def stringsRearrangement(inputArray):\n    permutations = itertools.permutations(inputArray)\n    for array in permutations:\n        if testArrangement(array):\n            return True\n    return False\ndef testArrangement(array):\n    for i in range(len(array) - 1):\n        if sum([a != b for a, b in zip(array[i], array[i + 1])]) != 1:\n            return False",
    "detail": "CodeSignal-Solutions-master.33 - stringsRearrangement",
    "documentation": {}
  },
  {
    "label": "testArrangement",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.33 - stringsRearrangement",
    "description": "CodeSignal-Solutions-master.33 - stringsRearrangement",
    "peekOfCode": "def testArrangement(array):\n    for i in range(len(array) - 1):\n        if sum([a != b for a, b in zip(array[i], array[i + 1])]) != 1:\n            return False\n    return True",
    "detail": "CodeSignal-Solutions-master.33 - stringsRearrangement",
    "documentation": {}
  },
  {
    "label": "extractEachKth",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.34 - extractEachKth",
    "description": "CodeSignal-Solutions-master.34 - extractEachKth",
    "peekOfCode": "def extractEachKth(inputArray, k):\n    return [inputArray[x] for x in range(len(inputArray)) if (x + 1) % k != 0]",
    "detail": "CodeSignal-Solutions-master.34 - extractEachKth",
    "documentation": {}
  },
  {
    "label": "firstDigit",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.35 - firstDigit",
    "description": "CodeSignal-Solutions-master.35 - firstDigit",
    "peekOfCode": "def firstDigit(inputString):\n    for char in inputString:\n        if char.isdigit():\n            return char",
    "detail": "CodeSignal-Solutions-master.35 - firstDigit",
    "documentation": {}
  },
  {
    "label": "differentSymbolsNaive",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.36 - differentSymbolsNaive",
    "description": "CodeSignal-Solutions-master.36 - differentSymbolsNaive",
    "peekOfCode": "def differentSymbolsNaive(s):\n    return len(set(s))",
    "detail": "CodeSignal-Solutions-master.36 - differentSymbolsNaive",
    "documentation": {}
  },
  {
    "label": "arrayMaxConsecutiveSum",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.37 - arrayMaxConsecutiveSum",
    "description": "CodeSignal-Solutions-master.37 - arrayMaxConsecutiveSum",
    "peekOfCode": "def arrayMaxConsecutiveSum(inputArray, k):\n    sums = [sum(inputArray[:k])]\n    for i in range(1, len(inputArray) - k + 1):\n        sums.append(sums[i - 1] - inputArray[i - 1] + inputArray[i + k - 1])\n    return max(sums)",
    "detail": "CodeSignal-Solutions-master.37 - arrayMaxConsecutiveSum",
    "documentation": {}
  },
  {
    "label": "growingPlant",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.38 - growingPlant",
    "description": "CodeSignal-Solutions-master.38 - growingPlant",
    "peekOfCode": "def growingPlant(upSpeed, downSpeed, desiredHeight):\n    height = 0\n    days = 1\n    height += upSpeed\n    while height < desiredHeight:\n        days += 1\n        height -= downSpeed\n        height += upSpeed\n    return days",
    "detail": "CodeSignal-Solutions-master.38 - growingPlant",
    "documentation": {}
  },
  {
    "label": "knapsackLight",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.39 - knapsackLight",
    "description": "CodeSignal-Solutions-master.39 - knapsackLight",
    "peekOfCode": "def knapsackLight(value1, weight1, value2, weight2, maxW):\n    if weight1 + weight2 <= maxW:\n        return value1 + value2\n    if weight1 <= maxW and (weight2 > maxW or value1 >= value2):\n        return value1\n    if weight2 <= maxW and (weight1 > maxW or value2 >= value1):\n        return value2\n    return 0",
    "detail": "CodeSignal-Solutions-master.39 - knapsackLight",
    "documentation": {}
  },
  {
    "label": "longestDigitsPrefix",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.40 - longestDigitsPrefix",
    "description": "CodeSignal-Solutions-master.40 - longestDigitsPrefix",
    "peekOfCode": "def longestDigitsPrefix(inputString):\n    for char in range(len(inputString)):\n        if not inputString[char].isdigit():\n            return inputString[:char]\n    return inputString",
    "detail": "CodeSignal-Solutions-master.40 - longestDigitsPrefix",
    "documentation": {}
  },
  {
    "label": "digitDegree",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.41 - digitDegree",
    "description": "CodeSignal-Solutions-master.41 - digitDegree",
    "peekOfCode": "def digitDegree(n):\n    degree = 0\n    while len(str(n)) > 1:\n        n = sum((int(digit) for digit in str(n)))\n        degree += 1\n    return degree",
    "detail": "CodeSignal-Solutions-master.41 - digitDegree",
    "documentation": {}
  },
  {
    "label": "bishopAndPawn",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.42 - bishopAndPawn",
    "description": "CodeSignal-Solutions-master.42 - bishopAndPawn",
    "peekOfCode": "def bishopAndPawn(bishop, pawn):\n    return abs(ord(bishop[0]) - ord(pawn[0])) == abs(ord(bishop[1]) - ord(pawn[1]))",
    "detail": "CodeSignal-Solutions-master.42 - bishopAndPawn",
    "documentation": {}
  },
  {
    "label": "isBeautifulString",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.43 - isBeautifulString",
    "description": "CodeSignal-Solutions-master.43 - isBeautifulString",
    "peekOfCode": "def isBeautifulString(inputString):\n    for letter in range(ord('a'), ord('z')):\n        if inputString.count(chr(letter)) < inputString.count(chr(letter + 1)):\n            return False\n    return True",
    "detail": "CodeSignal-Solutions-master.43 - isBeautifulString",
    "documentation": {}
  },
  {
    "label": "findEmailDomain",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.44 - findEmailDomain",
    "description": "CodeSignal-Solutions-master.44 - findEmailDomain",
    "peekOfCode": "def findEmailDomain(address):\n    return address[address.rfind('@') + 1:]",
    "detail": "CodeSignal-Solutions-master.44 - findEmailDomain",
    "documentation": {}
  },
  {
    "label": "buildPalindrome",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.45 - buildPalindrome",
    "description": "CodeSignal-Solutions-master.45 - buildPalindrome",
    "peekOfCode": "def buildPalindrome(st):\n    if st == st[::-1]:  # Check for initial palindrome\n        return st\n    index = 0\n    subStr = st[index:]\n    while subStr != subStr[::-1]:  # while substring is not a palindrome\n        index += 1\n        subStr = st[index:]\n    return st + st[index - 1::-1]",
    "detail": "CodeSignal-Solutions-master.45 - buildPalindrome",
    "documentation": {}
  },
  {
    "label": "electionsWinners",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.46 - electionsWinners",
    "description": "CodeSignal-Solutions-master.46 - electionsWinners",
    "peekOfCode": "def electionsWinners(votes, k):\n    winners = 0\n    current_winner = max(votes)\n    for candidate in votes:\n        if k > 0 and candidate + k > current_winner:\n            winners += 1\n        if k == 0 and candidate == current_winner and votes.count(candidate) == 1:\n            winners += 1\n    return winners",
    "detail": "CodeSignal-Solutions-master.46 - electionsWinners",
    "documentation": {}
  },
  {
    "label": "isMAC48Address",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.47 - isMAC48Address",
    "description": "CodeSignal-Solutions-master.47 - isMAC48Address",
    "peekOfCode": "def isMAC48Address(inputString):\n    hex_chars = ('1', '2', '3', '4', '5', '6', '7', '8', '9', '0',\n                 'A', 'B', 'C', 'D', 'E', 'F',\n                 'a', 'b', 'c', 'd', 'e', 'f')\n    groups = inputString.split('-')\n    if len(groups) != 6:\n        return False\n    if not all((len(group) == 2 for group in groups)):\n        return False\n    if not all((group[0] in hex_chars and group[1] in hex_chars for group in groups)):",
    "detail": "CodeSignal-Solutions-master.47 - isMAC48Address",
    "documentation": {}
  },
  {
    "label": "isDigit",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.48 - isDigit",
    "description": "CodeSignal-Solutions-master.48 - isDigit",
    "peekOfCode": "def isDigit(symbol):\n    return symbol.isdigit()",
    "detail": "CodeSignal-Solutions-master.48 - isDigit",
    "documentation": {}
  },
  {
    "label": "lineEncoding",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.49 - lineEncoding",
    "description": "CodeSignal-Solutions-master.49 - lineEncoding",
    "peekOfCode": "def lineEncoding(s):\n    count = 1\n    output = []\n    for char in range(1, len(s)):\n        if s[char] == s[char - 1]:\n            count += 1\n        else:\n            if count > 1:\n                output.append(str(count) + s[char - 1])\n            else:",
    "detail": "CodeSignal-Solutions-master.49 - lineEncoding",
    "documentation": {}
  },
  {
    "label": "chessKnight",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.50 - chessKnight",
    "description": "CodeSignal-Solutions-master.50 - chessKnight",
    "peekOfCode": "def chessKnight(cell):\n    moves = 0\n    # Starting at the top left, going counter-clockwise\n    if ord(cell[0]) >= ord(\"b\") and ord(cell[1]) <= ord(\"6\"):\n        moves += 1\n    if ord(cell[0]) >= ord(\"c\") and ord(cell[1]) <= ord(\"7\"):\n        moves += 1\n    if ord(cell[0]) >= ord(\"c\") and ord(cell[1]) >= ord(\"2\"):\n        moves += 1\n    if ord(cell[0]) >= ord(\"b\") and ord(cell[1]) >= ord(\"3\"):",
    "detail": "CodeSignal-Solutions-master.50 - chessKnight",
    "documentation": {}
  },
  {
    "label": "deleteDigit",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.51 - deleteDigit",
    "description": "CodeSignal-Solutions-master.51 - deleteDigit",
    "peekOfCode": "def deleteDigit(n):\n    num = str(n)\n    highest = 0\n    for digit in range(len(num)):\n        output = num[:digit] + num[digit + 1:]\n        if int(output) > int(highest):\n            highest = output\n    return int(highest)",
    "detail": "CodeSignal-Solutions-master.51 - deleteDigit",
    "documentation": {}
  },
  {
    "label": "longestWord",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.52 - longestWord",
    "description": "CodeSignal-Solutions-master.52 - longestWord",
    "peekOfCode": "def longestWord(text):\n    longest = []\n    word = []\n    for char in text:\n        if ord(\"A\") <= ord(char) <= ord(\"Z\") or ord(\"a\") <= ord(char) <= ord(\"z\"):\n            word.append(char)\n        else:\n            if len(word) > len(longest):\n                longest = word\n            word = []",
    "detail": "CodeSignal-Solutions-master.52 - longestWord",
    "documentation": {}
  },
  {
    "label": "validTime",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.53 - validTime",
    "description": "CodeSignal-Solutions-master.53 - validTime",
    "peekOfCode": "def validTime(time):\n    groups = time.split(\":\")\n    if len(groups) != 2:\n        return False\n    if not (groups[0].isdigit() and groups[1].isdigit()):\n        return False\n    if int(groups[0]) > 23 or int(groups[1]) > 59:\n        return False\n    return True",
    "detail": "CodeSignal-Solutions-master.53 - validTime",
    "documentation": {}
  },
  {
    "label": "sumUpNumbers",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.54 - sumUpNumbers",
    "description": "CodeSignal-Solutions-master.54 - sumUpNumbers",
    "peekOfCode": "def sumUpNumbers(inputString):\n    total = 0\n    current_num = []\n    for char in inputString:\n        if char.isdigit():\n            current_num.append(char)\n        else:\n            if len(current_num) > 0:\n                num = int(\"\".join(current_num))\n                total += num",
    "detail": "CodeSignal-Solutions-master.54 - sumUpNumbers",
    "documentation": {}
  },
  {
    "label": "differentSquares",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.55 - differentSquares",
    "description": "CodeSignal-Solutions-master.55 - differentSquares",
    "peekOfCode": "def differentSquares(matrix):\n    squares = set()\n    for row in range(len(matrix) - 1):\n        for cell in range(len(matrix[row]) - 1):\n            square = ((matrix[row][cell], matrix[row][cell + 1]),\n                      (matrix[row + 1][cell], matrix[row + 1][cell + 1]))\n            squares.add(square)\n    return len(squares)",
    "detail": "CodeSignal-Solutions-master.55 - differentSquares",
    "documentation": {}
  },
  {
    "label": "digitsProduct",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.56 - digitsProduct",
    "description": "CodeSignal-Solutions-master.56 - digitsProduct",
    "peekOfCode": "def digitsProduct(product):\n    # New idea: add product to factors\n    # while max(factors) > 10: split that num into factors\n    if product == 0:\n        return 10\n    factors = [product]\n    while max(factors) > 9:\n        factored = findFactors(max(factors))\n        if factored:\n            factors.remove(max(factors))",
    "detail": "CodeSignal-Solutions-master.56 - digitsProduct",
    "documentation": {}
  },
  {
    "label": "findFactors",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.56 - digitsProduct",
    "description": "CodeSignal-Solutions-master.56 - digitsProduct",
    "peekOfCode": "def findFactors(n):\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return i, n // i\n    return False",
    "detail": "CodeSignal-Solutions-master.56 - digitsProduct",
    "documentation": {}
  },
  {
    "label": "fileNaming",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.57 - fileNaming",
    "description": "CodeSignal-Solutions-master.57 - fileNaming",
    "peekOfCode": "def fileNaming(names):\n    outnames = []\n    for name in names:\n        if name in outnames:\n            k = 1\n            while \"{}({})\".format(name, k) in outnames:\n                k += 1\n            name = \"{}({})\".format(name, k)\n        outnames.append(name)\n    return outnames",
    "detail": "CodeSignal-Solutions-master.57 - fileNaming",
    "documentation": {}
  },
  {
    "label": "messageFromBinaryCode",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.58 - messageFromBinaryCode",
    "description": "CodeSignal-Solutions-master.58 - messageFromBinaryCode",
    "peekOfCode": "def messageFromBinaryCode(code):\n    output = []\n    for i in range(0, len(code), 8):\n        letter = chr(int(code[i:i + 8], 2))\n        output.append(letter)\n    return ''.join(output)",
    "detail": "CodeSignal-Solutions-master.58 - messageFromBinaryCode",
    "documentation": {}
  },
  {
    "label": "spiralNumbers",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.59 - spiralNumbers",
    "description": "CodeSignal-Solutions-master.59 - spiralNumbers",
    "peekOfCode": "def spiralNumbers(n):\n    LEFT = 'left'\n    RIGHT = 'right'\n    UP = 'up'\n    DOWN = 'down'\n    direction = RIGHT\n    spiral = [[0 for i in range(n)] for j in range(n)]\n    row = 0\n    cell = 0\n    for num in range(1, (n * n) + 1):",
    "detail": "CodeSignal-Solutions-master.59 - spiralNumbers",
    "documentation": {}
  },
  {
    "label": "sudoku",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.60 - sudoku",
    "description": "CodeSignal-Solutions-master.60 - sudoku",
    "peekOfCode": "def sudoku(grid):\n    match = [i for i in range(1, 10)]\n    for row in grid:\n        if sorted(row) != match:\n            return False\n    for column_index in range(9):\n        column = [grid[row_index][column_index] for row_index in range(9)]\n        if sorted(column) != match:\n            return False\n    for row in range(0, 9, 3):",
    "detail": "CodeSignal-Solutions-master.60 - sudoku",
    "documentation": {}
  },
  {
    "label": "addTwoDigits",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 001 - addTwoDigits",
    "description": "CodeSignal-Solutions-master.Core 001 - addTwoDigits",
    "peekOfCode": "def addTwoDigits(n):\n    return (n // 10) + (n % 10)",
    "detail": "CodeSignal-Solutions-master.Core 001 - addTwoDigits",
    "documentation": {}
  },
  {
    "label": "largestNumber",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 002 - largestNumber",
    "description": "CodeSignal-Solutions-master.Core 002 - largestNumber",
    "peekOfCode": "def largestNumber(n):\n    return int(\"9\" * n)",
    "detail": "CodeSignal-Solutions-master.Core 002 - largestNumber",
    "documentation": {}
  },
  {
    "label": "candies",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 003 - candies",
    "description": "CodeSignal-Solutions-master.Core 003 - candies",
    "peekOfCode": "def candies(n, m):\n    return (m // n) * n",
    "detail": "CodeSignal-Solutions-master.Core 003 - candies",
    "documentation": {}
  },
  {
    "label": "seatsInTheater",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 004 - seatsInTheater",
    "description": "CodeSignal-Solutions-master.Core 004 - seatsInTheater",
    "peekOfCode": "def seatsInTheater(nCols, nRows, col, row):\n    return (nCols - col + 1) * (nRows - row)",
    "detail": "CodeSignal-Solutions-master.Core 004 - seatsInTheater",
    "documentation": {}
  },
  {
    "label": "maxMultiple",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 005 - maxMultiple",
    "description": "CodeSignal-Solutions-master.Core 005 - maxMultiple",
    "peekOfCode": "def maxMultiple(divisor, bound):\n    for num in range(bound, 1, -1):\n        if num % divisor == 0:\n            return num\n    return 0",
    "detail": "CodeSignal-Solutions-master.Core 005 - maxMultiple",
    "documentation": {}
  },
  {
    "label": "circleOfNumbers",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 006 - circleOfNumbers",
    "description": "CodeSignal-Solutions-master.Core 006 - circleOfNumbers",
    "peekOfCode": "def circleOfNumbers(n, firstNumber):\n    return (firstNumber + (n // 2)) % n",
    "detail": "CodeSignal-Solutions-master.Core 006 - circleOfNumbers",
    "documentation": {}
  },
  {
    "label": "lateRide",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 007 - lateRide",
    "description": "CodeSignal-Solutions-master.Core 007 - lateRide",
    "peekOfCode": "def lateRide(n):\n    hours = n // 60\n    minutes = n % 60\n    return (hours // 10) + (hours % 10) + (minutes // 10) + (minutes % 10)",
    "detail": "CodeSignal-Solutions-master.Core 007 - lateRide",
    "documentation": {}
  },
  {
    "label": "phoneCall",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 008 - phoneCall",
    "description": "CodeSignal-Solutions-master.Core 008 - phoneCall",
    "peekOfCode": "def phoneCall(min1, min2_10, min11, s):\n    if s < min1:\n        return 0\n    if s == min1:\n        return 1\n    if s <= min1 + (min2_10 * 9):\n        s -= min1\n        return (s // min2_10) + 1\n    s -= min1\n    s -= min2_10 * 9",
    "detail": "CodeSignal-Solutions-master.Core 008 - phoneCall",
    "documentation": {}
  },
  {
    "label": "reachNextLevel",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 009 - reachNextLevel",
    "description": "CodeSignal-Solutions-master.Core 009 - reachNextLevel",
    "peekOfCode": "def reachNextLevel(experience, threshold, reward):\n    return experience + reward >= threshold",
    "detail": "CodeSignal-Solutions-master.Core 009 - reachNextLevel",
    "documentation": {}
  },
  {
    "label": "knapsackLight",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 010 - knapsackLight",
    "description": "CodeSignal-Solutions-master.Core 010 - knapsackLight",
    "peekOfCode": "def knapsackLight(value1, weight1, value2, weight2, maxW):\n    if weight1 + weight2 <= maxW:\n        return value1 + value2\n    if weight1 <= maxW and weight2 <= maxW:\n        return max(value1, value2)\n    if weight1 <= maxW:\n        return value1\n    if weight2 <= maxW:\n        return value2\n    return 0",
    "detail": "CodeSignal-Solutions-master.Core 010 - knapsackLight",
    "documentation": {}
  },
  {
    "label": "extraNumber",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 011 - extraNumber",
    "description": "CodeSignal-Solutions-master.Core 011 - extraNumber",
    "peekOfCode": "def extraNumber(a, b, c):\n    if a == b:\n        return c\n    if a == c:\n        return b\n    return a",
    "detail": "CodeSignal-Solutions-master.Core 011 - extraNumber",
    "documentation": {}
  },
  {
    "label": "isInfiniteProcess",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 012 - isInfiniteProcess",
    "description": "CodeSignal-Solutions-master.Core 012 - isInfiniteProcess",
    "peekOfCode": "def isInfiniteProcess(a, b):\n    return a > b or (a % 2 != b % 2)",
    "detail": "CodeSignal-Solutions-master.Core 012 - isInfiniteProcess",
    "documentation": {}
  },
  {
    "label": "arithmeticExpression",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 013 - arithmeticExpression",
    "description": "CodeSignal-Solutions-master.Core 013 - arithmeticExpression",
    "peekOfCode": "def arithmeticExpression(a, b, c):\n    return a + b == c or a - b == c or a * b == c or a / b == c",
    "detail": "CodeSignal-Solutions-master.Core 013 - arithmeticExpression",
    "documentation": {}
  },
  {
    "label": "tennisSet",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 014 - tennisSet",
    "description": "CodeSignal-Solutions-master.Core 014 - tennisSet",
    "peekOfCode": "def tennisSet(score1, score2):\n    if max(score1, score2) == 6 and min(score1, score2) < 5:\n        return True\n    if 5 <= min(score1, score2) <= 6 and max(score1, score2) == 7:\n        return True\n    return False",
    "detail": "CodeSignal-Solutions-master.Core 014 - tennisSet",
    "documentation": {}
  },
  {
    "label": "willYou",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 015 - willYou",
    "description": "CodeSignal-Solutions-master.Core 015 - willYou",
    "peekOfCode": "def willYou(young, beautiful, loved):\n    return (young and beautiful) != loved",
    "detail": "CodeSignal-Solutions-master.Core 015 - willYou",
    "documentation": {}
  },
  {
    "label": "metroCard",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 016 - metroCard",
    "description": "CodeSignal-Solutions-master.Core 016 - metroCard",
    "peekOfCode": "def metroCard(lastNumberOfDays):\n    if lastNumberOfDays == 30 or lastNumberOfDays == 28:\n        return [31]\n    return [28, 30, 31]",
    "detail": "CodeSignal-Solutions-master.Core 016 - metroCard",
    "documentation": {}
  },
  {
    "label": "killKthBit",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 017 - killKthBit",
    "description": "CodeSignal-Solutions-master.Core 017 - killKthBit",
    "peekOfCode": "def killKthBit(n, k):\n    return n & ~(2 ** (k - 1))",
    "detail": "CodeSignal-Solutions-master.Core 017 - killKthBit",
    "documentation": {}
  },
  {
    "label": "arrayPacking",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 018 - arrayPacking",
    "description": "CodeSignal-Solutions-master.Core 018 - arrayPacking",
    "peekOfCode": "def arrayPacking(a):\n    binary_array = [bin(num)[2:].rjust(8, '0') for num in a]\n    out_string = ''.join(binary_array[::-1])\n    return int(out_string, 2)",
    "detail": "CodeSignal-Solutions-master.Core 018 - arrayPacking",
    "documentation": {}
  },
  {
    "label": "rangeBitCount",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 019 - rangeBitCount",
    "description": "CodeSignal-Solutions-master.Core 019 - rangeBitCount",
    "peekOfCode": "def rangeBitCount(a, b):\n    array = list(range(a, b + 1))\n    binary_array = [bin(num) for num in array]\n    count_array = [binary.count('1') for binary in binary_array]\n    return sum(count_array)",
    "detail": "CodeSignal-Solutions-master.Core 019 - rangeBitCount",
    "documentation": {}
  },
  {
    "label": "mirrorBits",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 020 - mirrorBits",
    "description": "CodeSignal-Solutions-master.Core 020 - mirrorBits",
    "peekOfCode": "def mirrorBits(a):\n    binary = bin(a)[2:]\n    return int(binary[::-1], 2)",
    "detail": "CodeSignal-Solutions-master.Core 020 - mirrorBits",
    "documentation": {}
  },
  {
    "label": "secondRightmostZeroBit",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 021 - secondRightmostZeroBit",
    "description": "CodeSignal-Solutions-master.Core 021 - secondRightmostZeroBit",
    "peekOfCode": "def secondRightmostZeroBit(n):\n    return 2 ** bin(n)[::-1].find('0', bin(n)[::-1].find('0') + 1)",
    "detail": "CodeSignal-Solutions-master.Core 021 - secondRightmostZeroBit",
    "documentation": {}
  },
  {
    "label": "swapAdjacentBits",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 022 - swapAdjacentBits",
    "description": "CodeSignal-Solutions-master.Core 022 - swapAdjacentBits",
    "peekOfCode": "def swapAdjacentBits(n):\n    return ((n >> 1) & 1431655765) | ((n << 1) & 2863311530)",
    "detail": "CodeSignal-Solutions-master.Core 022 - swapAdjacentBits",
    "documentation": {}
  },
  {
    "label": "differentRightmostBit",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 023 - differentRightmostBit",
    "description": "CodeSignal-Solutions-master.Core 023 - differentRightmostBit",
    "peekOfCode": "def differentRightmostBit(n, m):\n    return 2 ** bin((n ^ m))[::-1].find('1')",
    "detail": "CodeSignal-Solutions-master.Core 023 - differentRightmostBit",
    "documentation": {}
  },
  {
    "label": "equalPairOfBits",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 024 - equalPairOfBits",
    "description": "CodeSignal-Solutions-master.Core 024 - equalPairOfBits",
    "peekOfCode": "def equalPairOfBits(n, m):\n    return 2 ** bin(~(n ^ m))[::-1].find('1')",
    "detail": "CodeSignal-Solutions-master.Core 024 - equalPairOfBits",
    "documentation": {}
  },
  {
    "label": "leastFactorial",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 025 - leastFactorial",
    "description": "CodeSignal-Solutions-master.Core 025 - leastFactorial",
    "peekOfCode": "def leastFactorial(n):\n    factorial = 1\n    index = 1\n    while factorial < n:\n        index += 1\n        factorial *= index\n    return factorial",
    "detail": "CodeSignal-Solutions-master.Core 025 - leastFactorial",
    "documentation": {}
  },
  {
    "label": "countSumOfTwoRepresentations2",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 026 - countSumOfTwoRepresentations2",
    "description": "CodeSignal-Solutions-master.Core 026 - countSumOfTwoRepresentations2",
    "peekOfCode": "def countSumOfTwoRepresentations2(n, l, r):\n    count = 0\n    a = max(n - r, l)\n    b = n - a\n    while a <= r and a <= b:\n        count += 1\n        a += 1\n        b -= 1\n    return count",
    "detail": "CodeSignal-Solutions-master.Core 026 - countSumOfTwoRepresentations2",
    "documentation": {}
  },
  {
    "label": "magicalWell",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 027 - magicalWell",
    "description": "CodeSignal-Solutions-master.Core 027 - magicalWell",
    "peekOfCode": "def magicalWell(a, b, n):\n    total = 0\n    for i in range(n):\n        total += a * b\n        a += 1\n        b += 1\n    return total",
    "detail": "CodeSignal-Solutions-master.Core 027 - magicalWell",
    "documentation": {}
  },
  {
    "label": "lineUp",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 028 - lineUp",
    "description": "CodeSignal-Solutions-master.Core 028 - lineUp",
    "peekOfCode": "def lineUp(commands):\n    count = 0\n    smart_student = 0\n    dumb_student = 0\n    for command in commands:\n        if command == 'L':\n            smart_student = (smart_student - 1) % 4\n            dumb_student = (dumb_student + 1) % 4\n        elif command == 'R':\n            smart_student = (smart_student + 1) % 4",
    "detail": "CodeSignal-Solutions-master.Core 028 - lineUp",
    "documentation": {}
  },
  {
    "label": "additionWithoutCarrying",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 029 - additionWithoutCarrying",
    "description": "CodeSignal-Solutions-master.Core 029 - additionWithoutCarrying",
    "peekOfCode": "def additionWithoutCarrying(param1, param2):\n    # Convert numbers to strings\n    str1 = str(param1)\n    str2 = str(param2)\n    # Pad both to the same length with zeroes (to the left of the numbers)\n    length = max(len(str2), len(str1))\n    str1 = str1.rjust(length, '0')\n    str2 = str2.rjust(length, '0')\n    output = []\n    for num1, num2 in zip(str1, str2):",
    "detail": "CodeSignal-Solutions-master.Core 029 - additionWithoutCarrying",
    "documentation": {}
  },
  {
    "label": "appleBoxes",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 030 - appleBoxes",
    "description": "CodeSignal-Solutions-master.Core 030 - appleBoxes",
    "peekOfCode": "def appleBoxes(k):\n    red = 0\n    yellow = 0\n    for i in range(1, k + 1, 2):\n        yellow += i * i\n    for i in range(2, k + 1, 2):\n        red += i * i\n    return red - yellow",
    "detail": "CodeSignal-Solutions-master.Core 030 - appleBoxes",
    "documentation": {}
  },
  {
    "label": "increaseNumberRoundness",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 031 - increaseNumberRoundness",
    "description": "CodeSignal-Solutions-master.Core 031 - increaseNumberRoundness",
    "peekOfCode": "def increaseNumberRoundness(n):\n    string = str(n)\n    # Check for immediate rejection\n    if '0' not in string or len(string) < 2:\n        return False\n    # Since we know there's a 0, if it's not on\n    # the left, then we know to accept\n    if string[-1] != '0':\n        return True\n    # If there is only one 0, it must be at the end, so reject.",
    "detail": "CodeSignal-Solutions-master.Core 031 - increaseNumberRoundness",
    "documentation": {}
  },
  {
    "label": "rounders",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 032 - rounders",
    "description": "CodeSignal-Solutions-master.Core 032 - rounders",
    "peekOfCode": "def rounders(value):\n    length = len(str(value))\n    magnitude = length - 1\n    for i in range(length - 1):\n        value = int((value / 10) + 0.5)\n    return value * (10 ** magnitude)",
    "detail": "CodeSignal-Solutions-master.Core 032 - rounders",
    "documentation": {}
  },
  {
    "label": "candles",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 033 - candles",
    "description": "CodeSignal-Solutions-master.Core 033 - candles",
    "peekOfCode": "def candles(candlesNumber, makeNew):\n    totalBurned = 0\n    leftovers = 0\n    while candlesNumber > 0:\n        totalBurned += candlesNumber\n        leftovers += candlesNumber\n        candlesNumber = 0\n        candlesNumber = leftovers // makeNew\n        leftovers = leftovers % makeNew\n    return totalBurned",
    "detail": "CodeSignal-Solutions-master.Core 033 - candles",
    "documentation": {}
  },
  {
    "label": "countBlackCells",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 034 - countBlackCells",
    "description": "CodeSignal-Solutions-master.Core 034 - countBlackCells",
    "peekOfCode": "def countBlackCells(n, m):\n    gcd = find_gcd(n, m)\n    line_cells = n + m - gcd\n    line_corner_cells = (gcd - 1) * 2\n    return line_cells + line_corner_cells\ndef find_gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a",
    "detail": "CodeSignal-Solutions-master.Core 034 - countBlackCells",
    "documentation": {}
  },
  {
    "label": "find_gcd",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 034 - countBlackCells",
    "description": "CodeSignal-Solutions-master.Core 034 - countBlackCells",
    "peekOfCode": "def find_gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a",
    "detail": "CodeSignal-Solutions-master.Core 034 - countBlackCells",
    "documentation": {}
  },
  {
    "label": "createArray",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 035 - createArray",
    "description": "CodeSignal-Solutions-master.Core 035 - createArray",
    "peekOfCode": "def createArray(size):\n    return [1] * size",
    "detail": "CodeSignal-Solutions-master.Core 035 - createArray",
    "documentation": {}
  },
  {
    "label": "arrayReplace",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 036 - arrayReplace",
    "description": "CodeSignal-Solutions-master.Core 036 - arrayReplace",
    "peekOfCode": "def arrayReplace(inputArray, elemToReplace, substitutionElem):\n    output = [elem if elem != elemToReplace else substitutionElem for elem in inputArray]\n    return output",
    "detail": "CodeSignal-Solutions-master.Core 036 - arrayReplace",
    "documentation": {}
  },
  {
    "label": "firstReverseTry",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 037 - firstReverseTry",
    "description": "CodeSignal-Solutions-master.Core 037 - firstReverseTry",
    "peekOfCode": "def firstReverseTry(arr):\n    if len(arr) < 2:\n        return arr\n    if len(arr) < 4:\n        return arr[::-1]\n    return arr[-1:] + arr[1:-1] + arr[:1]",
    "detail": "CodeSignal-Solutions-master.Core 037 - firstReverseTry",
    "documentation": {}
  },
  {
    "label": "concatenateArrays",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 038 - concatenateArrays",
    "description": "CodeSignal-Solutions-master.Core 038 - concatenateArrays",
    "peekOfCode": "def concatenateArrays(a, b):\n    return a + b",
    "detail": "CodeSignal-Solutions-master.Core 038 - concatenateArrays",
    "documentation": {}
  },
  {
    "label": "removeArrayPart",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 039 - removeArrayPart",
    "description": "CodeSignal-Solutions-master.Core 039 - removeArrayPart",
    "peekOfCode": "def removeArrayPart(inputArray, l, r):\n    return inputArray[:l] + inputArray[r + 1:]",
    "detail": "CodeSignal-Solutions-master.Core 039 - removeArrayPart",
    "documentation": {}
  },
  {
    "label": "isSmooth",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 040 - isSmooth",
    "description": "CodeSignal-Solutions-master.Core 040 - isSmooth",
    "peekOfCode": "def isSmooth(arr):\n    if arr[0] != arr[-1]:\n        return False\n    if len(arr) % 2 == 0:\n        middle = arr[len(arr) // 2] + arr[(len(arr) // 2) - 1]\n    else:\n        middle = arr[len(arr) // 2]\n    return arr[0] == middle",
    "detail": "CodeSignal-Solutions-master.Core 040 - isSmooth",
    "documentation": {}
  },
  {
    "label": "replaceMiddle",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 041 - replaceMiddle",
    "description": "CodeSignal-Solutions-master.Core 041 - replaceMiddle",
    "peekOfCode": "def replaceMiddle(arr):\n    if len(arr) % 2 != 0:\n        return arr\n    right_middle = len(arr) // 2\n    middle_value = arr[right_middle] + arr[right_middle - 1]\n    return arr[:right_middle - 1] + [middle_value] + arr[right_middle + 1:]",
    "detail": "CodeSignal-Solutions-master.Core 041 - replaceMiddle",
    "documentation": {}
  },
  {
    "label": "makeArrayConsecutive2",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 042 - makeArrayConsecutive2",
    "description": "CodeSignal-Solutions-master.Core 042 - makeArrayConsecutive2",
    "peekOfCode": "def makeArrayConsecutive2(statues):\n    count = 0\n    for i in range(min(statues), max(statues)):\n        if i not in statues:\n            count += 1\n    return count",
    "detail": "CodeSignal-Solutions-master.Core 042 - makeArrayConsecutive2",
    "documentation": {}
  },
  {
    "label": "isPower",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 043 - isPower",
    "description": "CodeSignal-Solutions-master.Core 043 - isPower",
    "peekOfCode": "def isPower(n):\n    if n == 1:\n        return True\n    a = 2\n    b = 2\n    while a ** 2 <= n:\n        while a ** b <= n:\n            if a ** b == n:\n                return True\n            b += 1",
    "detail": "CodeSignal-Solutions-master.Core 043 - isPower",
    "documentation": {}
  },
  {
    "label": "isSumOfConsecutive2",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 044 - isSumOfConsecutive2",
    "description": "CodeSignal-Solutions-master.Core 044 - isSumOfConsecutive2",
    "peekOfCode": "def isSumOfConsecutive2(n):\n    count = 0\n    right = 2\n    arr = [1, 2]\n    while right <= (n // 2) + 1:\n        total = sum(arr)\n        if total == n:\n            count += 1\n            del arr[0]\n        elif total < n:",
    "detail": "CodeSignal-Solutions-master.Core 044 - isSumOfConsecutive2",
    "documentation": {}
  },
  {
    "label": "squareDigitsSequence",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 045 - squareDigitsSequence",
    "description": "CodeSignal-Solutions-master.Core 045 - squareDigitsSequence",
    "peekOfCode": "def squareDigitsSequence(a0):\n    sequence = [a0]\n    while sequence[-1] not in sequence[:-1]:\n        next_value = 0\n        for digit in str(sequence[-1]):\n            next_value += int(digit) ** 2\n        sequence.append(next_value)\n    return len(sequence)",
    "detail": "CodeSignal-Solutions-master.Core 045 - squareDigitsSequence",
    "documentation": {}
  },
  {
    "label": "pagesNumberingWithInk",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 046 - pagesNumberingWithInk",
    "description": "CodeSignal-Solutions-master.Core 046 - pagesNumberingWithInk",
    "peekOfCode": "def pagesNumberingWithInk(current, numberOfDigits):\n    numberOfDigits -= len(str(current))\n    next_digits = len(str(current + 1))\n    while numberOfDigits >= next_digits:\n        current += 1\n        numberOfDigits -= next_digits\n        next_digits = len(str(current))\n    return current",
    "detail": "CodeSignal-Solutions-master.Core 046 - pagesNumberingWithInk",
    "documentation": {}
  },
  {
    "label": "comfortableNumbers",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 047 - comfortableNumbers",
    "description": "CodeSignal-Solutions-master.Core 047 - comfortableNumbers",
    "peekOfCode": "def comfortableNumbers(l, r):\n    count = 0\n    for a in range(l, r):\n        for b in range(a + 1, r + 1):\n            a_sum = sum(int(digit) for digit in str(a))\n            b_sum = sum(int(digit) for digit in str(b))\n            if b <= a + a_sum and a >= b - b_sum:\n                count += 1\n    return count",
    "detail": "CodeSignal-Solutions-master.Core 047 - comfortableNumbers",
    "documentation": {}
  },
  {
    "label": "weakNumbers",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 048 - weakNumbers",
    "description": "CodeSignal-Solutions-master.Core 048 - weakNumbers",
    "peekOfCode": "def weakNumbers(n):\n    all_factors = [count_factors(num) for num in range(1, n+1)]\n    weaknesses = []\n    for num, num_factors in enumerate(all_factors, 1):\n        weakness = 0\n        for factor in all_factors[:num]:\n            if factor > num_factors:\n                weakness += 1\n        weaknesses.append(weakness)\n    weakest = max(weaknesses)",
    "detail": "CodeSignal-Solutions-master.Core 048 - weakNumbers",
    "documentation": {}
  },
  {
    "label": "count_factors",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 048 - weakNumbers",
    "description": "CodeSignal-Solutions-master.Core 048 - weakNumbers",
    "peekOfCode": "def count_factors(n):\n    factors = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            factors += 1\n    return factors\nprint(weakNumbers(500))",
    "detail": "CodeSignal-Solutions-master.Core 048 - weakNumbers",
    "documentation": {}
  },
  {
    "label": "rectangleRotation",
    "kind": 2,
    "importPath": "CodeSignal-Solutions-master.Core 049 - rectangleRotation",
    "description": "CodeSignal-Solutions-master.Core 049 - rectangleRotation",
    "peekOfCode": "def rectangleRotation(a, b):\n    n = a / (2 ** 0.5)\n    m = b / (2 ** 0.5)\n    points = (math.floor(n) * math.floor(m)) + (math.ceil(n) * math.ceil(m))\n    if math.floor(n) % 2 != math.floor(m) % 2:\n        points -= 1\n    return points\n# rectangleRotation(6, 4)\nprint(rectangleRotation(8,6))",
    "detail": "CodeSignal-Solutions-master.Core 049 - rectangleRotation",
    "documentation": {}
  },
  {
    "label": "add",
    "kind": 2,
    "importPath": "coding-challenges-Python.add",
    "description": "coding-challenges-Python.add",
    "peekOfCode": "def add(param1, param2):\n    return param1 + param2",
    "detail": "coding-challenges-Python.add",
    "documentation": {}
  },
  {
    "label": "addTwoDigits",
    "kind": 5,
    "importPath": "coding-challenges-Python.addTwoDigits",
    "description": "coding-challenges-Python.addTwoDigits",
    "peekOfCode": "addTwoDigits = lambda n: n % 10 + n // 10\n# return sum(int(i) for i in str(n))",
    "detail": "coding-challenges-Python.addTwoDigits",
    "documentation": {}
  },
  {
    "label": "L,",
    "kind": 5,
    "importPath": "coding-challenges-Python.arrayConsecutive",
    "description": "coding-challenges-Python.arrayConsecutive",
    "peekOfCode": "L, = eval(dir()[0])\ns = 0\nwhile len(L) > 1:\n    L = numpy.add(L[:-1:2], L[1::2]) if s % 2 == 0 else numpy.multiply(L[:-1:2], L[1::2])\n    s += 1\nreturn L[0]",
    "detail": "coding-challenges-Python.arrayConsecutive",
    "documentation": {}
  },
  {
    "label": "s",
    "kind": 5,
    "importPath": "coding-challenges-Python.arrayConsecutive",
    "description": "coding-challenges-Python.arrayConsecutive",
    "peekOfCode": "s = 0\nwhile len(L) > 1:\n    L = numpy.add(L[:-1:2], L[1::2]) if s % 2 == 0 else numpy.multiply(L[:-1:2], L[1::2])\n    s += 1\nreturn L[0]",
    "detail": "coding-challenges-Python.arrayConsecutive",
    "documentation": {}
  },
  {
    "label": "L,",
    "kind": 5,
    "importPath": "coding-challenges-Python.arrayConversion",
    "description": "coding-challenges-Python.arrayConversion",
    "peekOfCode": "L, = eval(dir()[0])\ns = 0\nwhile len(L) > 1:\n    L = numpy.add(L[:-1:2], L[1::2]) if s % 2 == 0 else numpy.multiply(L[:-1:2], L[1::2])\n    s += 1\nreturn L[0]",
    "detail": "coding-challenges-Python.arrayConversion",
    "documentation": {}
  },
  {
    "label": "s",
    "kind": 5,
    "importPath": "coding-challenges-Python.arrayConversion",
    "description": "coding-challenges-Python.arrayConversion",
    "peekOfCode": "s = 0\nwhile len(L) > 1:\n    L = numpy.add(L[:-1:2], L[1::2]) if s % 2 == 0 else numpy.multiply(L[:-1:2], L[1::2])\n    s += 1\nreturn L[0]",
    "detail": "coding-challenges-Python.arrayConversion",
    "documentation": {}
  },
  {
    "label": "caseUnification",
    "kind": 2,
    "importPath": "coding-challenges-Python.caseUnification",
    "description": "coding-challenges-Python.caseUnification",
    "peekOfCode": "def caseUnification(s):\n    u = (sum(1 for x in s if x.isupper()))\n    if u > (len(s)/2):\n        return s.upper()\n    else:\n        return s.lower()",
    "detail": "coding-challenges-Python.caseUnification",
    "documentation": {}
  },
  {
    "label": "checkPalindrome",
    "kind": 5,
    "importPath": "coding-challenges-Python.checkPalindrome",
    "description": "coding-challenges-Python.checkPalindrome",
    "peekOfCode": "checkPalindrome = lambda x: x == x[::-1]",
    "detail": "coding-challenges-Python.checkPalindrome",
    "documentation": {}
  },
  {
    "label": "n,",
    "kind": 5,
    "importPath": "coding-challenges-Python.columnTitle",
    "description": "coding-challenges-Python.columnTitle",
    "peekOfCode": "n, = eval(dir()[0])\nr = \"\"\nwhile n:\n    n -= 1\n    r = chr(n % 26 + 65) + r\n    n //= 26\nreturn r",
    "detail": "coding-challenges-Python.columnTitle",
    "documentation": {}
  },
  {
    "label": "r",
    "kind": 5,
    "importPath": "coding-challenges-Python.columnTitle",
    "description": "coding-challenges-Python.columnTitle",
    "peekOfCode": "r = \"\"\nwhile n:\n    n -= 1\n    r = chr(n % 26 + 65) + r\n    n //= 26\nreturn r",
    "detail": "coding-challenges-Python.columnTitle",
    "documentation": {}
  },
  {
    "label": "cubeVolume",
    "kind": 5,
    "importPath": "coding-challenges-Python.cubeVolume",
    "description": "coding-challenges-Python.cubeVolume",
    "peekOfCode": "cubeVolume = lambda n: n ** 3",
    "detail": "coding-challenges-Python.cubeVolume",
    "documentation": {}
  },
  {
    "label": "depositProfit",
    "kind": 2,
    "importPath": "coding-challenges-Python.depositProfit",
    "description": "coding-challenges-Python.depositProfit",
    "peekOfCode": "def depositProfit(deposit, rate, threshold):\n    i = 0\n    while deposit < threshold:\n        deposit += deposit * rate * .01\n        i+=1\n    return i",
    "detail": "coding-challenges-Python.depositProfit",
    "documentation": {}
  },
  {
    "label": "findTheRemainder",
    "kind": 2,
    "importPath": "coding-challenges-Python.findTheRemainder",
    "description": "coding-challenges-Python.findTheRemainder",
    "peekOfCode": "def findTheRemainder(a, b):\n    return a % b",
    "detail": "coding-challenges-Python.findTheRemainder",
    "documentation": {}
  },
  {
    "label": "r",
    "kind": 5,
    "importPath": "coding-challenges-Python.fractionComparison",
    "description": "coding-challenges-Python.fractionComparison",
    "peekOfCode": "r = (a * d) / (b * c)\nreturn \"<\" if r < 1 else \">\" if r > 1 else \"=\"\n# 72 chars",
    "detail": "coding-challenges-Python.fractionComparison",
    "documentation": {}
  },
  {
    "label": "f,",
    "kind": 5,
    "importPath": "coding-challenges-Python.fractionReducing",
    "description": "coding-challenges-Python.fractionReducing",
    "peekOfCode": "f, = eval(dir()[0])\nreturn [i / math.gcd(f[0], f[1]) for i in f]",
    "detail": "coding-challenges-Python.fractionReducing",
    "documentation": {}
  },
  {
    "label": "gasPrediction",
    "kind": 5,
    "importPath": "coding-challenges-Python.gasPrediction",
    "description": "coding-challenges-Python.gasPrediction",
    "peekOfCode": "gasPrediction = lambda d, c, a: sum(d) / 12 / a > c",
    "detail": "coding-challenges-Python.gasPrediction",
    "documentation": {}
  },
  {
    "label": "greetPerson",
    "kind": 5,
    "importPath": "coding-challenges-Python.greetPerson",
    "description": "coding-challenges-Python.greetPerson",
    "peekOfCode": "greetPerson = \"Hello, {}\".format",
    "detail": "coding-challenges-Python.greetPerson",
    "documentation": {}
  },
  {
    "label": "halvingSum",
    "kind": 2,
    "importPath": "coding-challenges-Python.halvingSum",
    "description": "coding-challenges-Python.halvingSum",
    "peekOfCode": "def halvingSum(n):\n    s = 0\n    while n:\n        s += n\n        n //= 2\n    return s\n# s (int) : Sum\n# n (int) : Input number",
    "detail": "coding-challenges-Python.halvingSum",
    "documentation": {}
  },
  {
    "label": "isAdult",
    "kind": 5,
    "importPath": "coding-challenges-Python.isAdult",
    "description": "coding-challenges-Python.isAdult",
    "peekOfCode": "isAdult = lambda a, m: a >= m",
    "detail": "coding-challenges-Python.isAdult",
    "documentation": {}
  },
  {
    "label": "isSum",
    "kind": 2,
    "importPath": "coding-challenges-Python.isSum",
    "description": "coding-challenges-Python.isSum",
    "peekOfCode": "def isSum(value):\n    s=0\n    for i in range(100):\n        s+=i\n        if s== value:\n            return True",
    "detail": "coding-challenges-Python.isSum",
    "documentation": {}
  },
  {
    "label": "isSuspiciousRespondent",
    "kind": 2,
    "importPath": "coding-challenges-Python.isSuspiciousRespondent",
    "description": "coding-challenges-Python.isSuspiciousRespondent",
    "peekOfCode": "def isSuspiciousRespondent(ans1, ans2, ans3):\n    return ans1 == ans2 == ans3",
    "detail": "coding-challenges-Python.isSuspiciousRespondent",
    "documentation": {}
  },
  {
    "label": "r",
    "kind": 5,
    "importPath": "coding-challenges-Python.lrcSubrip",
    "description": "coding-challenges-Python.lrcSubrip",
    "peekOfCode": "r = []\nc = 1\nt = [[int(s[i:i+2]) for i in [1, 4]] +[s[7:9]] for s in l]\nt = [f\"{x // 60:02d}:{x % 60:02d}:{y:02d},{z.ljust(3, str(0))}\" for x, y, z in t] + [s + ',000'] # if I replace str(0) with '0', this increases to 359 characters wtf\nfor a, b in enumerate(l):\n    r.extend([str(c), t[a] + ' --> ' + t[a+1], b[11:], ''])\n    c += 1\nreturn r[:-1]",
    "detail": "coding-challenges-Python.lrcSubrip",
    "documentation": {}
  },
  {
    "label": "c",
    "kind": 5,
    "importPath": "coding-challenges-Python.lrcSubrip",
    "description": "coding-challenges-Python.lrcSubrip",
    "peekOfCode": "c = 1\nt = [[int(s[i:i+2]) for i in [1, 4]] +[s[7:9]] for s in l]\nt = [f\"{x // 60:02d}:{x % 60:02d}:{y:02d},{z.ljust(3, str(0))}\" for x, y, z in t] + [s + ',000'] # if I replace str(0) with '0', this increases to 359 characters wtf\nfor a, b in enumerate(l):\n    r.extend([str(c), t[a] + ' --> ' + t[a+1], b[11:], ''])\n    c += 1\nreturn r[:-1]",
    "detail": "coding-challenges-Python.lrcSubrip",
    "documentation": {}
  },
  {
    "label": "t",
    "kind": 5,
    "importPath": "coding-challenges-Python.lrcSubrip",
    "description": "coding-challenges-Python.lrcSubrip",
    "peekOfCode": "t = [[int(s[i:i+2]) for i in [1, 4]] +[s[7:9]] for s in l]\nt = [f\"{x // 60:02d}:{x % 60:02d}:{y:02d},{z.ljust(3, str(0))}\" for x, y, z in t] + [s + ',000'] # if I replace str(0) with '0', this increases to 359 characters wtf\nfor a, b in enumerate(l):\n    r.extend([str(c), t[a] + ' --> ' + t[a+1], b[11:], ''])\n    c += 1\nreturn r[:-1]",
    "detail": "coding-challenges-Python.lrcSubrip",
    "documentation": {}
  },
  {
    "label": "t",
    "kind": 5,
    "importPath": "coding-challenges-Python.lrcSubrip",
    "description": "coding-challenges-Python.lrcSubrip",
    "peekOfCode": "t = [f\"{x // 60:02d}:{x % 60:02d}:{y:02d},{z.ljust(3, str(0))}\" for x, y, z in t] + [s + ',000'] # if I replace str(0) with '0', this increases to 359 characters wtf\nfor a, b in enumerate(l):\n    r.extend([str(c), t[a] + ' --> ' + t[a+1], b[11:], ''])\n    c += 1\nreturn r[:-1]",
    "detail": "coding-challenges-Python.lrcSubrip",
    "documentation": {}
  },
  {
    "label": "magicalWell",
    "kind": 2,
    "importPath": "coding-challenges-Python.magicalWell",
    "description": "coding-challenges-Python.magicalWell",
    "peekOfCode": "def magicalWell(a,b,n):\n    s, m = 0, 0\n    while m < n:\n        s += a * b\n        a += 1\n        b += 1\n        m += 1\n    return s",
    "detail": "coding-challenges-Python.magicalWell",
    "documentation": {}
  },
  {
    "label": "a,",
    "kind": 5,
    "importPath": "coding-challenges-Python.makeArrayConsecutive",
    "description": "coding-challenges-Python.makeArrayConsecutive",
    "peekOfCode": "a, = eval(dir()[0])\nreturn [i for i in range(min(a), max(a)) if i not in a]",
    "detail": "coding-challenges-Python.makeArrayConsecutive",
    "documentation": {}
  },
  {
    "label": "maxSubarray",
    "kind": 2,
    "importPath": "coding-challenges-Python.maxSubarray",
    "description": "coding-challenges-Python.maxSubarray",
    "peekOfCode": "def maxSubarray(A):\n    # A: inputArray\n    # m: Max\n    # \n    # \n    m = e = 0\n    for i in A:\n        e += i\n        if e < 0:\n            e = 0",
    "detail": "coding-challenges-Python.maxSubarray",
    "documentation": {}
  },
  {
    "label": "mySubstring",
    "kind": 5,
    "importPath": "coding-challenges-Python.mySubstring",
    "description": "coding-challenges-Python.mySubstring",
    "peekOfCode": "mySubstring = lambda s, l, r: s[l:r+1]",
    "detail": "coding-challenges-Python.mySubstring",
    "documentation": {}
  },
  {
    "label": "#passwordCheck",
    "kind": 5,
    "importPath": "coding-challenges-Python.passwordCheck",
    "description": "coding-challenges-Python.passwordCheck",
    "peekOfCode": "#passwordCheck = lambda s: (any(i.isdigit()) and any(i.islower()) and any(i.isupper())) for i in s and len(s) > 4\n# Regex:\n#def passwordCheck(s):\n#    return len(s) > 4 and all(re.search(p, s) for p in ('[A-Z]', '\\d', '[a-z]'))\npasswordCheck = lambda s: len(s) > 4 and all(re.search(i, s) for i in ('[A-Z]', '\\d', '[a-z]'))",
    "detail": "coding-challenges-Python.passwordCheck",
    "documentation": {}
  },
  {
    "label": "passwordCheck",
    "kind": 5,
    "importPath": "coding-challenges-Python.passwordCheck",
    "description": "coding-challenges-Python.passwordCheck",
    "peekOfCode": "passwordCheck = lambda s: len(s) > 4 and all(re.search(i, s) for i in ('[A-Z]', '\\d', '[a-z]'))",
    "detail": "coding-challenges-Python.passwordCheck",
    "documentation": {}
  },
  {
    "label": "partition",
    "kind": 2,
    "importPath": "coding-challenges-Python.quicksort",
    "description": "coding-challenges-Python.quicksort",
    "peekOfCode": "def partition(A, lo, hi):\n    pivot = A[lo + (hi - lo) // 2]\n    i = lo - 1\n    j = hi + 1\n    while True:\n        i += 1\n        while A[i] < pivot:\n            i += 1\n        j -= 1    \n        while A[j] > pivot:",
    "detail": "coding-challenges-Python.quicksort",
    "documentation": {}
  },
  {
    "label": "quicksort",
    "kind": 2,
    "importPath": "coding-challenges-Python.quicksort",
    "description": "coding-challenges-Python.quicksort",
    "peekOfCode": "def quicksort(A, lo, hi):\n    if lo < hi:\n        p = partition(A, lo, hi)\n        quicksort(A, lo, p)\n        quicksort(A, p + 1, hi)\n    return A\nif __name__ == \"__main__\":\n    arr = [8, 3, 5, 1, 7, 2]\n    quicksort(arr, 0, len(arr) - 1)\n    # >>> [1, 2, 3, 5, 7, 8]",
    "detail": "coding-challenges-Python.quicksort",
    "documentation": {}
  },
  {
    "label": "returnTwelve",
    "kind": 5,
    "importPath": "coding-challenges-Python.returnTwelve",
    "description": "coding-challenges-Python.returnTwelve",
    "peekOfCode": "returnTwelve = lambda n: 12 if n < 12 else n",
    "detail": "coding-challenges-Python.returnTwelve",
    "documentation": {}
  },
  {
    "label": "r",
    "kind": 5,
    "importPath": "coding-challenges-Python.runnersMeetings",
    "description": "coding-challenges-Python.runnersMeetings",
    "peekOfCode": "r = -1\nl = len(p)\nfor i in range(l):\n    for j in range(l):\n        c = 0\n        d = p[j] - p[i]\n        f = s[i] - s[j]\n        if d * f < 1:\n            continue\n        for k in range(l):",
    "detail": "coding-challenges-Python.runnersMeetings",
    "documentation": {}
  },
  {
    "label": "l",
    "kind": 5,
    "importPath": "coding-challenges-Python.runnersMeetings",
    "description": "coding-challenges-Python.runnersMeetings",
    "peekOfCode": "l = len(p)\nfor i in range(l):\n    for j in range(l):\n        c = 0\n        d = p[j] - p[i]\n        f = s[i] - s[j]\n        if d * f < 1:\n            continue\n        for k in range(l):\n            if p[k] * f + s[k] * d == p[i] * f + s[i] * d:",
    "detail": "coding-challenges-Python.runnersMeetings",
    "documentation": {}
  },
  {
    "label": "smallestMultiple",
    "kind": 2,
    "importPath": "coding-challenges-Python.smallestMultiple",
    "description": "coding-challenges-Python.smallestMultiple",
    "peekOfCode": "def smallestMultiple(l ,r):\n    for i in range(1, 16):\n        for j in range(l, r+1):\n            while True:\n                if i % j != 0:\n                    break\n            return i",
    "detail": "coding-challenges-Python.smallestMultiple",
    "documentation": {}
  },
  {
    "label": "A,",
    "kind": 5,
    "importPath": "coding-challenges-Python.sortByHeight",
    "description": "coding-challenges-Python.sortByHeight",
    "peekOfCode": "A, = numpy.r_[eval(dir()[0])]\nA[A > 0] = sorted(A[A > 0])\nreturn A",
    "detail": "coding-challenges-Python.sortByHeight",
    "documentation": {}
  },
  {
    "label": "sulkyBoy",
    "kind": 5,
    "importPath": "coding-challenges-Python.sulkyBoy",
    "description": "coding-challenges-Python.sulkyBoy",
    "peekOfCode": "sulkyBoy = lambda x: not x",
    "detail": "coding-challenges-Python.sulkyBoy",
    "documentation": {}
  },
  {
    "label": "sumOfSquares",
    "kind": 2,
    "importPath": "coding-challenges-Python.sumOfSquares",
    "description": "coding-challenges-Python.sumOfSquares",
    "peekOfCode": "def sumOfSquares(n):\n    return sum([x**2 for x in range(1, n+1)])",
    "detail": "coding-challenges-Python.sumOfSquares",
    "documentation": {}
  },
  {
    "label": "sumOfTheAngles",
    "kind": 5,
    "importPath": "coding-challenges-Python.sumOfTheAngles",
    "description": "coding-challenges-Python.sumOfTheAngles",
    "peekOfCode": "sumOfTheAngles = lambda n: (n - 2) * 180\n#n = eval(dir()[0])\n#return (n - 2) * 180",
    "detail": "coding-challenges-Python.sumOfTheAngles",
    "documentation": {}
  },
  {
    "label": "#n",
    "kind": 5,
    "importPath": "coding-challenges-Python.sumOfTheAngles",
    "description": "coding-challenges-Python.sumOfTheAngles",
    "peekOfCode": "#n = eval(dir()[0])\n#return (n - 2) * 180",
    "detail": "coding-challenges-Python.sumOfTheAngles",
    "documentation": {}
  },
  {
    "label": "sumOfTwo",
    "kind": 2,
    "importPath": "coding-challenges-Python.sumOfTwo",
    "description": "coding-challenges-Python.sumOfTwo",
    "peekOfCode": "def sumOfTwo(a, b, v):\n    b = set(b)\n    return any(v - i in b for i in a)",
    "detail": "coding-challenges-Python.sumOfTwo",
    "documentation": {}
  },
  {
    "label": "visitsOnCircularRoad",
    "kind": 2,
    "importPath": "coding-challenges-Python.visitsOnCircularRoad",
    "description": "coding-challenges-Python.visitsOnCircularRoad",
    "peekOfCode": "def visitsOnCircularRoad(n, v):\n    c = 1\n    t = 0\n    for i in v :\n        t += min(abs(i - c), abs(n - abs(i - c)))\n        c = i\n    return t\n# v = visitsOrder\n# n = number of houses\n# c = Current position",
    "detail": "coding-challenges-Python.visitsOnCircularRoad",
    "documentation": {}
  },
  {
    "label": "rotateImage",
    "kind": 2,
    "importPath": "Interview Prep.Arrays.rotateImage",
    "description": "Interview Prep.Arrays.rotateImage",
    "peekOfCode": "def rotateImage(a):\n    n = len(a)\n    # reflect about the diagonal\n    for i in range(n):\n        for j in range(i, n):\n            a[i][j], a[j][i] = a[j][i], a[i][j]\n    # now flip the columns about the center\n    for i in range(n):\n        for j in range(n // 2):\n            a[i][j], a[i][n - 1 - j] = a[i][n - 1 - j], a[i][j]",
    "detail": "Interview Prep.Arrays.rotateImage",
    "documentation": {}
  },
  {
    "label": "productExceptSelf",
    "kind": 2,
    "importPath": "Interview Prep.Basic Techniques.ExceptSelfProduct",
    "description": "Interview Prep.Basic Techniques.ExceptSelfProduct",
    "peekOfCode": "def productExceptSelf(nums, m, first=True):\n    # uses divide and conquer approach from Khan academy!\n    # may need to upgrade with prime factorization\n    # and fast modular exponents using binary!\n    # make map of prime factors and their exponents (number of each factor)\n    # by breaking down individual array items\n    # remove individual values from map for each item in array (reduce number of each factor present in current item)\n    # convert exponent to binary and get modular exponents for each factor (see here: https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/fast-modular-exponentiation)\n    # finally, combine all different prime factors for the number and add to array\n    # reduce array by summing and final mod as shown",
    "detail": "Interview Prep.Basic Techniques.ExceptSelfProduct",
    "documentation": {}
  },
  {
    "label": "arr",
    "kind": 5,
    "importPath": "Interview Prep.Basic Techniques.ExceptSelfProduct",
    "description": "Interview Prep.Basic Techniques.ExceptSelfProduct",
    "peekOfCode": "arr = pd.read_json(\"./test-16.json\").loc[\"nums\", \"input\"]\n# print(arr)\nprint(productExceptSelf(arr, 9999, first=True))\n# works for small cases, need to use divide and conquer according to Khan\n# causes overflow issues\n# #first, get the number of all nums multiplied\n# largest_num = 1\n# for num in nums:\n#     largest_num*=num\n# print(largest_num)",
    "detail": "Interview Prep.Basic Techniques.ExceptSelfProduct",
    "documentation": {}
  },
  {
    "label": "containsCloseNums",
    "kind": 2,
    "importPath": "Interview Prep.Dictionaries.containsCloseNums",
    "description": "Interview Prep.Dictionaries.containsCloseNums",
    "peekOfCode": "def containsCloseNums(nums, k):\n    num_dict = {}\n    # setup keys for each number seen, then list their indices\n    for i, item in enumerate(nums):\n        if item in num_dict:\n            num_dict[item].append(i)\n        else:\n            num_dict[item] = [i]\n    # remove all nums that are not repeated\n    # first make a set of keys to remove to prevent editing the dictionary size while iterating over it",
    "detail": "Interview Prep.Dictionaries.containsCloseNums",
    "documentation": {}
  },
  {
    "label": "areFollowingPatterns",
    "kind": 2,
    "importPath": "Interview Prep.Dictionaries.followingPatterns",
    "description": "Interview Prep.Dictionaries.followingPatterns",
    "peekOfCode": "def areFollowingPatterns(strings, patterns):\n    pattern_to_string = {}\n    string_to_pattern = {}\n    for i in range(len(patterns)):\n        # first, check condition that strings are equal for patterns[i]=patterns[j]\n        this_pattern = patterns[i]\n        if patterns[i] in pattern_to_string:\n            if strings[i] != pattern_to_string[this_pattern]:\n                return False\n        else:",
    "detail": "Interview Prep.Dictionaries.followingPatterns",
    "documentation": {}
  },
  {
    "label": "possibleSums",
    "kind": 2,
    "importPath": "Interview Prep.Dictionaries.possibleSums",
    "description": "Interview Prep.Dictionaries.possibleSums",
    "peekOfCode": "def possibleSums(coins, quantity):\n    # sum_map = set()\n    # start with brute force\n    # total_arr = [coins[i] for i, q in enumerate(quantity) for l in range(q)]\n    # for i in range(1, len(total_arr)+1):\n    #     combos = itertools.combinations(total_arr, i)\n    #     print(combos)\n    #     for combo in combos:\n    #         sum_map.add(sum(combo))\n    # return len(sum_map)",
    "detail": "Interview Prep.Dictionaries.possibleSums",
    "documentation": {}
  },
  {
    "label": "combine_sets",
    "kind": 2,
    "importPath": "Interview Prep.Dictionaries.possibleSums",
    "description": "Interview Prep.Dictionaries.possibleSums",
    "peekOfCode": "def combine_sets(set1, set2):\n    together_set = set()\n    for item1 in set1:\n        for item2 in set2:\n            together_set.add(item1 + item2)\n        together_set.add(item1)\n    for item2 in set2:\n        together_set.add(item2)\n    return together_set",
    "detail": "Interview Prep.Dictionaries.possibleSums",
    "documentation": {}
  },
  {
    "label": "mapDecoding",
    "kind": 2,
    "importPath": "Interview Prep.Dynamic Programming.mapDecoder",
    "description": "Interview Prep.Dynamic Programming.mapDecoder",
    "peekOfCode": "def mapDecoding(message):\n    counts = [0, 1]\n    size = len(message)\n    # special cases\n    if size == 0:\n        return 1\n    if int(message[0]) == 0:\n        return 0\n    if size == 1:\n        return 1",
    "detail": "Interview Prep.Dynamic Programming.mapDecoder",
    "documentation": {}
  },
  {
    "label": "feedingTime",
    "kind": 2,
    "importPath": "Interview Prep.Graphs.feedingTime",
    "description": "Interview Prep.Graphs.feedingTime",
    "peekOfCode": "def feedingTime(classes):\n    class_graph = defaultdict(set)\n    animals = defaultdict(set)\n    neg_graph = defaultdict(set)\n    c_size = len(classes)\n    # fully connected graph\n    for i in range(c_size):\n        for j in range(c_size):\n            if not i == j:\n                class_graph[i].add(j)",
    "detail": "Interview Prep.Graphs.feedingTime",
    "documentation": {}
  },
  {
    "label": "graph_search",
    "kind": 2,
    "importPath": "Interview Prep.Graphs.feedingTime",
    "description": "Interview Prep.Graphs.feedingTime",
    "peekOfCode": "def graph_search(vals, class_graph, neg_graph):\n    seen = set()\n    islands = []\n    for i in vals:\n        if i not in seen:\n            queue = [i]\n            seen.add(i)\n            route = set()\n            route.add(i)\n            found_val = False",
    "detail": "Interview Prep.Graphs.feedingTime",
    "documentation": {}
  },
  {
    "label": "sort_last",
    "kind": 2,
    "importPath": "Interview Prep.Graphs.feedingTime",
    "description": "Interview Prep.Graphs.feedingTime",
    "peekOfCode": "def sort_last(tup):\n    return tup[1]",
    "detail": "Interview Prep.Graphs.feedingTime",
    "documentation": {}
  },
  {
    "label": "singlePointOfFailure",
    "kind": 2,
    "importPath": "Interview Prep.Graphs.singlePointOfFailure",
    "description": "Interview Prep.Graphs.singlePointOfFailure",
    "peekOfCode": "def singlePointOfFailure(connections):\n    size = len(connections)\n    total = 0\n    if size == 1:\n        return total\n    # print(connections)\n    cuttable_nodes = set()\n    cut_segments = {}\n    single_edges = set()\n    while anySingleEdges(connections):",
    "detail": "Interview Prep.Graphs.singlePointOfFailure",
    "documentation": {}
  },
  {
    "label": "anySingleEdges",
    "kind": 2,
    "importPath": "Interview Prep.Graphs.singlePointOfFailure",
    "description": "Interview Prep.Graphs.singlePointOfFailure",
    "peekOfCode": "def anySingleEdges(adj_matrix):\n    for item in adj_matrix:\n        if sum(item) == 1:\n            return True\n    return False\ndef remove_empty_nodes(adj_matrix, nodes):\n    if len(nodes) == 0:\n        return adj_matrix\n    removals = list(nodes)\n    print(removals)",
    "detail": "Interview Prep.Graphs.singlePointOfFailure",
    "documentation": {}
  },
  {
    "label": "remove_empty_nodes",
    "kind": 2,
    "importPath": "Interview Prep.Graphs.singlePointOfFailure",
    "description": "Interview Prep.Graphs.singlePointOfFailure",
    "peekOfCode": "def remove_empty_nodes(adj_matrix, nodes):\n    if len(nodes) == 0:\n        return adj_matrix\n    removals = list(nodes)\n    print(removals)\n    removals.sort()\n    removals.reverse()\n    for item in removals:\n        for i, node in enumerate(adj_matrix):\n            if i == item:",
    "detail": "Interview Prep.Graphs.singlePointOfFailure",
    "documentation": {}
  },
  {
    "label": "remove_node",
    "kind": 2,
    "importPath": "Interview Prep.Graphs.singlePointOfFailure",
    "description": "Interview Prep.Graphs.singlePointOfFailure",
    "peekOfCode": "def remove_node(node, adj_matrix):\n    size = len(adj_matrix)\n    indices = set()\n    for i, a in enumerate(adj_matrix[node]):\n        if a == 1:\n            indices.add(i)\n    output = []\n    for i, item in enumerate(adj_matrix):\n        if i == node:\n            this_row = [0 for l in range(size)]",
    "detail": "Interview Prep.Graphs.singlePointOfFailure",
    "documentation": {}
  },
  {
    "label": "adjacency_matrix_BFS",
    "kind": 2,
    "importPath": "Interview Prep.Graphs.singlePointOfFailure",
    "description": "Interview Prep.Graphs.singlePointOfFailure",
    "peekOfCode": "def adjacency_matrix_BFS(node, adj_matrix):\n    seen = set()\n    seen.add(node)\n    queue = [i for i, a in enumerate(adj_matrix[node]) if a == 1]\n    while queue:\n        curr_node = queue.pop(0)\n        seen.add(curr_node)\n        new_items = [\n            i for i, a in enumerate(adj_matrix[curr_node]) if a == 1 and not i in seen\n        ]",
    "detail": "Interview Prep.Graphs.singlePointOfFailure",
    "documentation": {}
  },
  {
    "label": "connections",
    "kind": 5,
    "importPath": "Interview Prep.Graphs.singlePointOfFailure",
    "description": "Interview Prep.Graphs.singlePointOfFailure",
    "peekOfCode": "connections = [\n    [0, 1, 1, 0, 0, 0, 0],\n    [1, 0, 1, 0, 0, 0, 0],\n    [1, 1, 0, 0, 0, 0, 1],\n    [0, 0, 0, 0, 1, 1, 1],\n    [0, 0, 0, 1, 0, 1, 0],\n    [0, 0, 0, 1, 1, 0, 0],\n    [0, 0, 1, 1, 0, 0, 0],\n]\ntest8 = [",
    "detail": "Interview Prep.Graphs.singlePointOfFailure",
    "documentation": {}
  },
  {
    "label": "test8",
    "kind": 5,
    "importPath": "Interview Prep.Graphs.singlePointOfFailure",
    "description": "Interview Prep.Graphs.singlePointOfFailure",
    "peekOfCode": "test8 = [\n    [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],\n    [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0],\n    [0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0],\n    [0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],",
    "detail": "Interview Prep.Graphs.singlePointOfFailure",
    "documentation": {}
  },
  {
    "label": "solution",
    "kind": 2,
    "importPath": "Solved_Interview_Questions-master.Python.minInteger.minInteger",
    "description": "Solved_Interview_Questions-master.Python.minInteger.minInteger",
    "peekOfCode": "def solution(A):\n    solution.n = 1\n    def getMin(num):\n        if solution.n == num:\n            solution.n += 1\n        return num\n    B = sorted(A, key=getMin)\n    print(solution.n)\n    return solution.n\n# test cases",
    "detail": "Solved_Interview_Questions-master.Python.minInteger.minInteger",
    "documentation": {}
  },
  {
    "label": "start",
    "kind": 5,
    "importPath": "Solved_Interview_Questions-master.Python.minInteger.minInteger",
    "description": "Solved_Interview_Questions-master.Python.minInteger.minInteger",
    "peekOfCode": "start = time.time()\ndef solution(A):\n    solution.n = 1\n    def getMin(num):\n        if solution.n == num:\n            solution.n += 1\n        return num\n    B = sorted(A, key=getMin)\n    print(solution.n)\n    return solution.n",
    "detail": "Solved_Interview_Questions-master.Python.minInteger.minInteger",
    "documentation": {}
  },
  {
    "label": "end",
    "kind": 5,
    "importPath": "Solved_Interview_Questions-master.Python.minInteger.minInteger",
    "description": "Solved_Interview_Questions-master.Python.minInteger.minInteger",
    "peekOfCode": "end = time.time()\nprint(end - start)",
    "detail": "Solved_Interview_Questions-master.Python.minInteger.minInteger",
    "documentation": {}
  },
  {
    "label": "testTreeLine",
    "kind": 2,
    "importPath": "Solved_Interview_Questions-master.Python.Tree_Cutter.treeCutter",
    "description": "Solved_Interview_Questions-master.Python.Tree_Cutter.treeCutter",
    "peekOfCode": "def testTreeLine(A):\n    if A == sorted(A):\n        return True\n    else:\n        return False\n# check if solution is possible\ndef impossible(A):\n    maxIndex = A.index(max(A))\n    maxBefore = max(A[0:maxIndex])\n    minAfter = min(A[maxIndex:])",
    "detail": "Solved_Interview_Questions-master.Python.Tree_Cutter.treeCutter",
    "documentation": {}
  },
  {
    "label": "impossible",
    "kind": 2,
    "importPath": "Solved_Interview_Questions-master.Python.Tree_Cutter.treeCutter",
    "description": "Solved_Interview_Questions-master.Python.Tree_Cutter.treeCutter",
    "peekOfCode": "def impossible(A):\n    maxIndex = A.index(max(A))\n    maxBefore = max(A[0:maxIndex])\n    minAfter = min(A[maxIndex:])\n    if A[maxIndex] != A[len(A) - 1]:\n        if minAfter <= (maxBefore - 2) and len(A[maxIndex + 1 :]) > 1:\n            return True\n        else:\n            return False\n# function to see how many trees can be cut down",
    "detail": "Solved_Interview_Questions-master.Python.Tree_Cutter.treeCutter",
    "documentation": {}
  },
  {
    "label": "numCutTrees",
    "kind": 2,
    "importPath": "Solved_Interview_Questions-master.Python.Tree_Cutter.treeCutter",
    "description": "Solved_Interview_Questions-master.Python.Tree_Cutter.treeCutter",
    "peekOfCode": "def numCutTrees(A):\n    n = 0\n    # check case where no solutions possible\n    # for faster result\n    if impossible(A):\n        return n\n    for l in range(len(A)):\n        elem = A.pop(l)\n        if testTreeLine(A):\n            n = n + 1",
    "detail": "Solved_Interview_Questions-master.Python.Tree_Cutter.treeCutter",
    "documentation": {}
  },
  {
    "label": "N",
    "kind": 5,
    "importPath": "Solved_Interview_Questions-master.Python.Tree_Cutter.treeCutter",
    "description": "Solved_Interview_Questions-master.Python.Tree_Cutter.treeCutter",
    "peekOfCode": "N = [1, 2, 3, 4, 4]  # 5\nL = [1, 4, 2, 3]  # 1\nC = [1, 3, 5, 3]  # 2\nD = [1, 4, 3, 5, 3]  # 0\nE = [1, 2, 3, 4, 1]  # 1\nprint(numCutTrees(N))\nprint(numCutTrees(L))\nprint(numCutTrees(C))\nprint(numCutTrees(D))\nprint(numCutTrees(E))",
    "detail": "Solved_Interview_Questions-master.Python.Tree_Cutter.treeCutter",
    "documentation": {}
  },
  {
    "label": "L",
    "kind": 5,
    "importPath": "Solved_Interview_Questions-master.Python.Tree_Cutter.treeCutter",
    "description": "Solved_Interview_Questions-master.Python.Tree_Cutter.treeCutter",
    "peekOfCode": "L = [1, 4, 2, 3]  # 1\nC = [1, 3, 5, 3]  # 2\nD = [1, 4, 3, 5, 3]  # 0\nE = [1, 2, 3, 4, 1]  # 1\nprint(numCutTrees(N))\nprint(numCutTrees(L))\nprint(numCutTrees(C))\nprint(numCutTrees(D))\nprint(numCutTrees(E))",
    "detail": "Solved_Interview_Questions-master.Python.Tree_Cutter.treeCutter",
    "documentation": {}
  },
  {
    "label": "C",
    "kind": 5,
    "importPath": "Solved_Interview_Questions-master.Python.Tree_Cutter.treeCutter",
    "description": "Solved_Interview_Questions-master.Python.Tree_Cutter.treeCutter",
    "peekOfCode": "C = [1, 3, 5, 3]  # 2\nD = [1, 4, 3, 5, 3]  # 0\nE = [1, 2, 3, 4, 1]  # 1\nprint(numCutTrees(N))\nprint(numCutTrees(L))\nprint(numCutTrees(C))\nprint(numCutTrees(D))\nprint(numCutTrees(E))",
    "detail": "Solved_Interview_Questions-master.Python.Tree_Cutter.treeCutter",
    "documentation": {}
  },
  {
    "label": "D",
    "kind": 5,
    "importPath": "Solved_Interview_Questions-master.Python.Tree_Cutter.treeCutter",
    "description": "Solved_Interview_Questions-master.Python.Tree_Cutter.treeCutter",
    "peekOfCode": "D = [1, 4, 3, 5, 3]  # 0\nE = [1, 2, 3, 4, 1]  # 1\nprint(numCutTrees(N))\nprint(numCutTrees(L))\nprint(numCutTrees(C))\nprint(numCutTrees(D))\nprint(numCutTrees(E))",
    "detail": "Solved_Interview_Questions-master.Python.Tree_Cutter.treeCutter",
    "documentation": {}
  },
  {
    "label": "E",
    "kind": 5,
    "importPath": "Solved_Interview_Questions-master.Python.Tree_Cutter.treeCutter",
    "description": "Solved_Interview_Questions-master.Python.Tree_Cutter.treeCutter",
    "peekOfCode": "E = [1, 2, 3, 4, 1]  # 1\nprint(numCutTrees(N))\nprint(numCutTrees(L))\nprint(numCutTrees(C))\nprint(numCutTrees(D))\nprint(numCutTrees(E))",
    "detail": "Solved_Interview_Questions-master.Python.Tree_Cutter.treeCutter",
    "documentation": {}
  },
  {
    "label": "add",
    "kind": 2,
    "importPath": "_ALL_PY.01 - add",
    "description": "_ALL_PY.01 - add",
    "peekOfCode": "def add(param1, param2):\n    return param1 + param2",
    "detail": "_ALL_PY.01 - add",
    "documentation": {}
  },
  {
    "label": "centuryFromYear",
    "kind": 2,
    "importPath": "_ALL_PY.02 - centuryFromYear",
    "description": "_ALL_PY.02 - centuryFromYear",
    "peekOfCode": "def centuryFromYear(year):\n    return ((year-1) // 100) + 1",
    "detail": "_ALL_PY.02 - centuryFromYear",
    "documentation": {}
  },
  {
    "label": "checkPalindrome",
    "kind": 2,
    "importPath": "_ALL_PY.03 - checkPalindrome",
    "description": "_ALL_PY.03 - checkPalindrome",
    "peekOfCode": "def checkPalindrome(inputString):\n    return inputString == inputString[::-1]",
    "detail": "_ALL_PY.03 - checkPalindrome",
    "documentation": {}
  },
  {
    "label": "adjacentElementsProduct",
    "kind": 2,
    "importPath": "_ALL_PY.04 - adjacentElementsProduct",
    "description": "_ALL_PY.04 - adjacentElementsProduct",
    "peekOfCode": "def adjacentElementsProduct(inputArray):\n    max = inputArray[0] * inputArray[1]\n    for i in range(len(inputArray) - 1):\n        if inputArray[i] * inputArray[i+1] > max:\n            max = inputArray[i] * inputArray[i+1]\n    return max",
    "detail": "_ALL_PY.04 - adjacentElementsProduct",
    "documentation": {}
  },
  {
    "label": "shapeArea",
    "kind": 2,
    "importPath": "_ALL_PY.05 - shapeArea",
    "description": "_ALL_PY.05 - shapeArea",
    "peekOfCode": "def shapeArea(n):\n    sum = n*2 - 1\n    for i in range(1, (n*2)-1, 2):\n        sum += i*2\n    return sum",
    "detail": "_ALL_PY.05 - shapeArea",
    "documentation": {}
  },
  {
    "label": "makeArrayConsecutive2",
    "kind": 2,
    "importPath": "_ALL_PY.06 - makeArrayConsecutive2",
    "description": "_ALL_PY.06 - makeArrayConsecutive2",
    "peekOfCode": "def makeArrayConsecutive2(statues):\n    return max(statues) - min(statues) - len(statues) + 1",
    "detail": "_ALL_PY.06 - makeArrayConsecutive2",
    "documentation": {}
  },
  {
    "label": "almostIncreasingSequence",
    "kind": 2,
    "importPath": "_ALL_PY.07 - almostIncreasingSequence",
    "description": "_ALL_PY.07 - almostIncreasingSequence",
    "peekOfCode": "def almostIncreasingSequence(sequence):\n    i = 0\n    while i < len(sequence) - 1:\n        if not sequence[i] < sequence[i + 1]:\n            if increasingSequence(sequence[:i] + sequence[i+1:]) or \\\n                    increasingSequence(sequence[:i+1] + sequence[i+2:]):\n                return True\n            else:\n                return False\n        i += 1",
    "detail": "_ALL_PY.07 - almostIncreasingSequence",
    "documentation": {}
  },
  {
    "label": "increasingSequence",
    "kind": 2,
    "importPath": "_ALL_PY.07 - almostIncreasingSequence",
    "description": "_ALL_PY.07 - almostIncreasingSequence",
    "peekOfCode": "def increasingSequence(sequence):\n    for i in range(len(sequence) - 1):\n        if not sequence[i] < sequence[i + 1]:\n            return False\n    return True",
    "detail": "_ALL_PY.07 - almostIncreasingSequence",
    "documentation": {}
  },
  {
    "label": "matrixElementsSum",
    "kind": 2,
    "importPath": "_ALL_PY.08 - matrixElementsSum",
    "description": "_ALL_PY.08 - matrixElementsSum",
    "peekOfCode": "def matrixElementsSum(matrix):\n    if len(matrix) > 1:\n        for row in range(1, len(matrix)):\n            for room in range(len(matrix[row])):\n                if matrix[row - 1][room] == 0:\n                    matrix[row][room] = 0\n    sum = 0\n    for row in matrix:\n        for room in row:\n            sum += room",
    "detail": "_ALL_PY.08 - matrixElementsSum",
    "documentation": {}
  },
  {
    "label": "allLongestStrings",
    "kind": 2,
    "importPath": "_ALL_PY.09 - allLongestStrings",
    "description": "_ALL_PY.09 - allLongestStrings",
    "peekOfCode": "def allLongestStrings(inputArray):\n    length = max([len(word) for word in inputArray])\n    result = [word for word in inputArray if len(word) == length]\n    return result",
    "detail": "_ALL_PY.09 - allLongestStrings",
    "documentation": {}
  },
  {
    "label": "commonCharacterCount",
    "kind": 2,
    "importPath": "_ALL_PY.10 - commonCharacterCount",
    "description": "_ALL_PY.10 - commonCharacterCount",
    "peekOfCode": "def commonCharacterCount(s1, s2):\n    count = 0\n    word2 = list(s2)\n    for letter in s1:\n        if letter in word2:\n            word2.remove(letter)\n            count += 1\n    return count",
    "detail": "_ALL_PY.10 - commonCharacterCount",
    "documentation": {}
  },
  {
    "label": "isLucky",
    "kind": 2,
    "importPath": "_ALL_PY.11 - isLucky",
    "description": "_ALL_PY.11 - isLucky",
    "peekOfCode": "def isLucky(n):\n    string = str(n)\n    top = [int(x) for x in string[:len(string)//2]]\n    bottom = [int(x) for x in string[len(string)//2:]]\n    return sum(top) == sum(bottom)",
    "detail": "_ALL_PY.11 - isLucky",
    "documentation": {}
  },
  {
    "label": "sortByHeight",
    "kind": 2,
    "importPath": "_ALL_PY.12 - sortByHeight",
    "description": "_ALL_PY.12 - sortByHeight",
    "peekOfCode": "def sortByHeight(a):\n    treePositions = [x for x in range(len(a)) if a[x] == -1]\n    people = sorted([x for x in a if x != -1])\n    for tree in treePositions:\n        people.insert(tree, -1)\n    return people",
    "detail": "_ALL_PY.12 - sortByHeight",
    "documentation": {}
  },
  {
    "label": "reverseParentheses",
    "kind": 2,
    "importPath": "_ALL_PY.13 - reverseParentheses",
    "description": "_ALL_PY.13 - reverseParentheses",
    "peekOfCode": "def reverseParentheses(s):\n    while \"(\" in s:\n        match = re.search(\"\\([^()]*\\)\", s)\n        match_string = match.group(0)[1: len(match.group(0)) - 1]\n        reversed_match_string = match_string[::-1]\n        s = s[:match.start()] + reversed_match_string + s[match.end():]\n    return s",
    "detail": "_ALL_PY.13 - reverseParentheses",
    "documentation": {}
  },
  {
    "label": "alternatingSums",
    "kind": 2,
    "importPath": "_ALL_PY.14 - alternatingSums",
    "description": "_ALL_PY.14 - alternatingSums",
    "peekOfCode": "def alternatingSums(a):\n    team1 = sum(a[0::2])\n    team2 = sum(a[1::2])\n    return [team1, team2]",
    "detail": "_ALL_PY.14 - alternatingSums",
    "documentation": {}
  },
  {
    "label": "addBorder",
    "kind": 2,
    "importPath": "_ALL_PY.15 - addBorder",
    "description": "_ALL_PY.15 - addBorder",
    "peekOfCode": "def addBorder(picture):\n    picture = [\"*\" + string + \"*\" for string in picture]\n    picture = [(\"*\" * len(picture[0]))] + picture + [(\"*\" * len(picture[0]))]\n    return picture",
    "detail": "_ALL_PY.15 - addBorder",
    "documentation": {}
  },
  {
    "label": "areSimilar",
    "kind": 2,
    "importPath": "_ALL_PY.16 - areSimilar",
    "description": "_ALL_PY.16 - areSimilar",
    "peekOfCode": "def areSimilar(a, b):\n    diff = [i for i in range(len(a)) if a[i] != b[i]]\n    if len(diff) == 2:\n        b[diff[0]], b[diff[1]] = b[diff[1]], b[diff[0]]\n    return a == b",
    "detail": "_ALL_PY.16 - areSimilar",
    "documentation": {}
  },
  {
    "label": "arrayChange",
    "kind": 2,
    "importPath": "_ALL_PY.17 - arrayChange",
    "description": "_ALL_PY.17 - arrayChange",
    "peekOfCode": "def arrayChange(inputArray):\n    count = 0\n    for i in range(1, len(inputArray)):\n        if inputArray[i-1] >= inputArray[i]:\n            difference = inputArray[i-1] - inputArray[i]\n            inputArray[i] += difference + 1\n            count += difference + 1\n    return count",
    "detail": "_ALL_PY.17 - arrayChange",
    "documentation": {}
  },
  {
    "label": "palindromeRearranging",
    "kind": 2,
    "importPath": "_ALL_PY.18 - palindromeRearranging",
    "description": "_ALL_PY.18 - palindromeRearranging",
    "peekOfCode": "def palindromeRearranging(inputString):\n    inputList = sorted(inputString)\n    foundMiddle = False\n    while len(inputList) > 1:\n        if inputList[0] == inputList[1]:\n            del inputList[1]\n        elif not foundMiddle:\n            foundMiddle = True\n        else:\n            return False",
    "detail": "_ALL_PY.18 - palindromeRearranging",
    "documentation": {}
  },
  {
    "label": "areEquallyStrong",
    "kind": 2,
    "importPath": "_ALL_PY.19 - areEquallyStrong",
    "description": "_ALL_PY.19 - areEquallyStrong",
    "peekOfCode": "def areEquallyStrong(yourLeft, yourRight, friendsLeft, friendsRight):\n    sameHands = yourLeft == friendsLeft and yourRight == friendsRight\n    differentHands = yourLeft == friendsRight and yourRight == friendsLeft\n    return sameHands or differentHands",
    "detail": "_ALL_PY.19 - areEquallyStrong",
    "documentation": {}
  },
  {
    "label": "arrayMaximalAdjacentDifference",
    "kind": 2,
    "importPath": "_ALL_PY.20 - arrayMaximalAdjacentDifference",
    "description": "_ALL_PY.20 - arrayMaximalAdjacentDifference",
    "peekOfCode": "def arrayMaximalAdjacentDifference(inputArray):\n    diffs = []\n    for i in range(len(inputArray) - 1):\n        diffs.append(abs(inputArray[i] - inputArray[i + 1]))\n    return max(diffs)",
    "detail": "_ALL_PY.20 - arrayMaximalAdjacentDifference",
    "documentation": {}
  },
  {
    "label": "isIPv4Address",
    "kind": 2,
    "importPath": "_ALL_PY.21 - isIPv4Address",
    "description": "_ALL_PY.21 - isIPv4Address",
    "peekOfCode": "def isIPv4Address(inputString):\n    strings = [string for string in inputString.split('.')]\n    for string in strings:\n        if not string.isdecimal():\n            return False\n    nums = [int(num) for num in strings]\n    return max(nums) <= 255 and min(nums) >= 0 and len(nums) == 4",
    "detail": "_ALL_PY.21 - isIPv4Address",
    "documentation": {}
  },
  {
    "label": "avoidObstacles",
    "kind": 2,
    "importPath": "_ALL_PY.22 - avoidObstacles",
    "description": "_ALL_PY.22 - avoidObstacles",
    "peekOfCode": "def avoidObstacles(inputArray):\n    for length in range(2, max(inputArray) + 2):\n        done = True\n        jump = length\n        while jump < (max(inputArray) + length):\n            if jump in inputArray:\n                done = False\n                break\n            jump += length\n        if done:",
    "detail": "_ALL_PY.22 - avoidObstacles",
    "documentation": {}
  },
  {
    "label": "boxBlur",
    "kind": 2,
    "importPath": "_ALL_PY.23 - boxBlur",
    "description": "_ALL_PY.23 - boxBlur",
    "peekOfCode": "def boxBlur(image):\n    outImage = []\n    for row in range(1, len(image) - 1):\n        line = []\n        for pixel in range(1, len(image[row]) - 1):\n            total = (image[row - 1][pixel - 1]\n                     + image[row - 1][pixel]\n                     + image[row - 1][pixel + 1]\n                     + image[row][pixel - 1]\n                     + image[row][pixel]",
    "detail": "_ALL_PY.23 - boxBlur",
    "documentation": {}
  },
  {
    "label": "minesweeper",
    "kind": 2,
    "importPath": "_ALL_PY.24 - minesweeper",
    "description": "_ALL_PY.24 - minesweeper",
    "peekOfCode": "def minesweeper(matrix):\n    TOP = 0\n    BOTTOM = len(matrix) - 1\n    LEFT = 0\n    RIGHT = len(matrix[0]) - 1\n    outMatrix = []\n    for row in range(len(matrix)):\n        outRow = []\n        for cell in range(len(matrix[row])):\n            outRow.append(0)",
    "detail": "_ALL_PY.24 - minesweeper",
    "documentation": {}
  },
  {
    "label": "arrayReplace",
    "kind": 2,
    "importPath": "_ALL_PY.25 - arrayReplace",
    "description": "_ALL_PY.25 - arrayReplace",
    "peekOfCode": "def arrayReplace(inputArray, elemToReplace, substitutionElem):\n    return [x if x != elemToReplace else substitutionElem for x in inputArray]",
    "detail": "_ALL_PY.25 - arrayReplace",
    "documentation": {}
  },
  {
    "label": "evenDigitsOnly",
    "kind": 2,
    "importPath": "_ALL_PY.26 - evenDigitsOnly",
    "description": "_ALL_PY.26 - evenDigitsOnly",
    "peekOfCode": "def evenDigitsOnly(n):\n    return all((True if digit in ('0', '2', '4', '6', '8') else False for digit in str(n)))",
    "detail": "_ALL_PY.26 - evenDigitsOnly",
    "documentation": {}
  },
  {
    "label": "variableName",
    "kind": 2,
    "importPath": "_ALL_PY.27 - variableName",
    "description": "_ALL_PY.27 - variableName",
    "peekOfCode": "def variableName(name):\n    return name.replace(\"_\", \"\").isalnum() and not name[0].isdigit()",
    "detail": "_ALL_PY.27 - variableName",
    "documentation": {}
  },
  {
    "label": "alphabeticShift",
    "kind": 2,
    "importPath": "_ALL_PY.28 - alphabeticShift",
    "description": "_ALL_PY.28 - alphabeticShift",
    "peekOfCode": "def alphabeticShift(inputString):\n    return ''.join([chr(ord(x) + 1) if x != 'z' else 'a' for x in inputString])",
    "detail": "_ALL_PY.28 - alphabeticShift",
    "documentation": {}
  },
  {
    "label": "chessBoardCellColor",
    "kind": 2,
    "importPath": "_ALL_PY.29 - chessBoardCellColor",
    "description": "_ALL_PY.29 - chessBoardCellColor",
    "peekOfCode": "def chessBoardCellColor(cell1, cell2):\n    color1 = ((ord(cell1[0]) - ord('A')) + ord(cell1[1]) - ord('1')) % 2 == 0\n    color2 = ((ord(cell2[0]) - ord('A')) + ord(cell2[1]) - ord('1')) % 2 == 0\n    return color1 == color2",
    "detail": "_ALL_PY.29 - chessBoardCellColor",
    "documentation": {}
  },
  {
    "label": "circleOfNumbers",
    "kind": 2,
    "importPath": "_ALL_PY.30 - circleOfNumbers",
    "description": "_ALL_PY.30 - circleOfNumbers",
    "peekOfCode": "def circleOfNumbers(n, firstNumber):\n    return (firstNumber + (n / 2)) % n",
    "detail": "_ALL_PY.30 - circleOfNumbers",
    "documentation": {}
  },
  {
    "label": "depositProfit",
    "kind": 2,
    "importPath": "_ALL_PY.31 - depositProfit",
    "description": "_ALL_PY.31 - depositProfit",
    "peekOfCode": "def depositProfit(deposit, rate, threshold):\n    year = 0\n    while deposit < threshold:\n        deposit *= 1 + (rate / 100)\n        year += 1\n    return year",
    "detail": "_ALL_PY.31 - depositProfit",
    "documentation": {}
  },
  {
    "label": "absoluteValuesSumMinimization",
    "kind": 2,
    "importPath": "_ALL_PY.32 - absoluteValuesSumMinimization",
    "description": "_ALL_PY.32 - absoluteValuesSumMinimization",
    "peekOfCode": "def absoluteValuesSumMinimization(a):\n    sums = {}\n    for num in a:\n        total = sum([abs(a[i] - num) for i in range(len(a))])\n        if total in sums:\n            sums[total] = min(num, sums[total])\n        else:\n            sums[total] = num\n        print(sums)\n    return sums[min(sums)]",
    "detail": "_ALL_PY.32 - absoluteValuesSumMinimization",
    "documentation": {}
  },
  {
    "label": "stringsRearrangement",
    "kind": 2,
    "importPath": "_ALL_PY.33 - stringsRearrangement",
    "description": "_ALL_PY.33 - stringsRearrangement",
    "peekOfCode": "def stringsRearrangement(inputArray):\n    permutations = itertools.permutations(inputArray)\n    for array in permutations:\n        if testArrangement(array):\n            return True\n    return False\ndef testArrangement(array):\n    for i in range(len(array) - 1):\n        if sum([a != b for a, b in zip(array[i], array[i + 1])]) != 1:\n            return False",
    "detail": "_ALL_PY.33 - stringsRearrangement",
    "documentation": {}
  },
  {
    "label": "testArrangement",
    "kind": 2,
    "importPath": "_ALL_PY.33 - stringsRearrangement",
    "description": "_ALL_PY.33 - stringsRearrangement",
    "peekOfCode": "def testArrangement(array):\n    for i in range(len(array) - 1):\n        if sum([a != b for a, b in zip(array[i], array[i + 1])]) != 1:\n            return False\n    return True",
    "detail": "_ALL_PY.33 - stringsRearrangement",
    "documentation": {}
  },
  {
    "label": "extractEachKth",
    "kind": 2,
    "importPath": "_ALL_PY.34 - extractEachKth",
    "description": "_ALL_PY.34 - extractEachKth",
    "peekOfCode": "def extractEachKth(inputArray, k):\n    return [inputArray[x] for x in range(len(inputArray)) if (x + 1) % k != 0]",
    "detail": "_ALL_PY.34 - extractEachKth",
    "documentation": {}
  },
  {
    "label": "firstDigit",
    "kind": 2,
    "importPath": "_ALL_PY.35 - firstDigit",
    "description": "_ALL_PY.35 - firstDigit",
    "peekOfCode": "def firstDigit(inputString):\n    for char in inputString:\n        if char.isdigit():\n            return char",
    "detail": "_ALL_PY.35 - firstDigit",
    "documentation": {}
  },
  {
    "label": "differentSymbolsNaive",
    "kind": 2,
    "importPath": "_ALL_PY.36 - differentSymbolsNaive",
    "description": "_ALL_PY.36 - differentSymbolsNaive",
    "peekOfCode": "def differentSymbolsNaive(s):\n    return len(set(s))",
    "detail": "_ALL_PY.36 - differentSymbolsNaive",
    "documentation": {}
  },
  {
    "label": "arrayMaxConsecutiveSum",
    "kind": 2,
    "importPath": "_ALL_PY.37 - arrayMaxConsecutiveSum",
    "description": "_ALL_PY.37 - arrayMaxConsecutiveSum",
    "peekOfCode": "def arrayMaxConsecutiveSum(inputArray, k):\n    sums = [sum(inputArray[:k])]\n    for i in range(1, len(inputArray) - k + 1):\n        sums.append(sums[i - 1] - inputArray[i - 1] + inputArray[i + k - 1])\n    return max(sums)",
    "detail": "_ALL_PY.37 - arrayMaxConsecutiveSum",
    "documentation": {}
  },
  {
    "label": "growingPlant",
    "kind": 2,
    "importPath": "_ALL_PY.38 - growingPlant",
    "description": "_ALL_PY.38 - growingPlant",
    "peekOfCode": "def growingPlant(upSpeed, downSpeed, desiredHeight):\n    height = 0\n    days = 1\n    height += upSpeed\n    while height < desiredHeight:\n        days += 1\n        height -= downSpeed\n        height += upSpeed\n    return days",
    "detail": "_ALL_PY.38 - growingPlant",
    "documentation": {}
  },
  {
    "label": "knapsackLight",
    "kind": 2,
    "importPath": "_ALL_PY.39 - knapsackLight",
    "description": "_ALL_PY.39 - knapsackLight",
    "peekOfCode": "def knapsackLight(value1, weight1, value2, weight2, maxW):\n    if weight1 + weight2 <= maxW:\n        return value1 + value2\n    if weight1 <= maxW and (weight2 > maxW or value1 >= value2):\n        return value1\n    if weight2 <= maxW and (weight1 > maxW or value2 >= value1):\n        return value2\n    return 0",
    "detail": "_ALL_PY.39 - knapsackLight",
    "documentation": {}
  },
  {
    "label": "longestDigitsPrefix",
    "kind": 2,
    "importPath": "_ALL_PY.40 - longestDigitsPrefix",
    "description": "_ALL_PY.40 - longestDigitsPrefix",
    "peekOfCode": "def longestDigitsPrefix(inputString):\n    for char in range(len(inputString)):\n        if not inputString[char].isdigit():\n            return inputString[:char]\n    return inputString",
    "detail": "_ALL_PY.40 - longestDigitsPrefix",
    "documentation": {}
  },
  {
    "label": "digitDegree",
    "kind": 2,
    "importPath": "_ALL_PY.41 - digitDegree",
    "description": "_ALL_PY.41 - digitDegree",
    "peekOfCode": "def digitDegree(n):\n    degree = 0\n    while len(str(n)) > 1:\n        n = sum((int(digit) for digit in str(n)))\n        degree += 1\n    return degree",
    "detail": "_ALL_PY.41 - digitDegree",
    "documentation": {}
  },
  {
    "label": "bishopAndPawn",
    "kind": 2,
    "importPath": "_ALL_PY.42 - bishopAndPawn",
    "description": "_ALL_PY.42 - bishopAndPawn",
    "peekOfCode": "def bishopAndPawn(bishop, pawn):\n    return abs(ord(bishop[0]) - ord(pawn[0])) == abs(ord(bishop[1]) - ord(pawn[1]))",
    "detail": "_ALL_PY.42 - bishopAndPawn",
    "documentation": {}
  },
  {
    "label": "isBeautifulString",
    "kind": 2,
    "importPath": "_ALL_PY.43 - isBeautifulString",
    "description": "_ALL_PY.43 - isBeautifulString",
    "peekOfCode": "def isBeautifulString(inputString):\n    for letter in range(ord('a'), ord('z')):\n        if inputString.count(chr(letter)) < inputString.count(chr(letter + 1)):\n            return False\n    return True",
    "detail": "_ALL_PY.43 - isBeautifulString",
    "documentation": {}
  },
  {
    "label": "findEmailDomain",
    "kind": 2,
    "importPath": "_ALL_PY.44 - findEmailDomain",
    "description": "_ALL_PY.44 - findEmailDomain",
    "peekOfCode": "def findEmailDomain(address):\n    return address[address.rfind('@') + 1:]",
    "detail": "_ALL_PY.44 - findEmailDomain",
    "documentation": {}
  },
  {
    "label": "buildPalindrome",
    "kind": 2,
    "importPath": "_ALL_PY.45 - buildPalindrome",
    "description": "_ALL_PY.45 - buildPalindrome",
    "peekOfCode": "def buildPalindrome(st):\n    if st == st[::-1]:  # Check for initial palindrome\n        return st\n    index = 0\n    subStr = st[index:]\n    while subStr != subStr[::-1]:  # while substring is not a palindrome\n        index += 1\n        subStr = st[index:]\n    return st + st[index - 1::-1]",
    "detail": "_ALL_PY.45 - buildPalindrome",
    "documentation": {}
  },
  {
    "label": "electionsWinners",
    "kind": 2,
    "importPath": "_ALL_PY.46 - electionsWinners",
    "description": "_ALL_PY.46 - electionsWinners",
    "peekOfCode": "def electionsWinners(votes, k):\n    winners = 0\n    current_winner = max(votes)\n    for candidate in votes:\n        if k > 0 and candidate + k > current_winner:\n            winners += 1\n        if k == 0 and candidate == current_winner and votes.count(candidate) == 1:\n            winners += 1\n    return winners",
    "detail": "_ALL_PY.46 - electionsWinners",
    "documentation": {}
  },
  {
    "label": "isMAC48Address",
    "kind": 2,
    "importPath": "_ALL_PY.47 - isMAC48Address",
    "description": "_ALL_PY.47 - isMAC48Address",
    "peekOfCode": "def isMAC48Address(inputString):\n    hex_chars = ('1', '2', '3', '4', '5', '6', '7', '8', '9', '0',\n                 'A', 'B', 'C', 'D', 'E', 'F',\n                 'a', 'b', 'c', 'd', 'e', 'f')\n    groups = inputString.split('-')\n    if len(groups) != 6:\n        return False\n    if not all((len(group) == 2 for group in groups)):\n        return False\n    if not all((group[0] in hex_chars and group[1] in hex_chars for group in groups)):",
    "detail": "_ALL_PY.47 - isMAC48Address",
    "documentation": {}
  },
  {
    "label": "isDigit",
    "kind": 2,
    "importPath": "_ALL_PY.48 - isDigit",
    "description": "_ALL_PY.48 - isDigit",
    "peekOfCode": "def isDigit(symbol):\n    return symbol.isdigit()",
    "detail": "_ALL_PY.48 - isDigit",
    "documentation": {}
  },
  {
    "label": "lineEncoding",
    "kind": 2,
    "importPath": "_ALL_PY.49 - lineEncoding",
    "description": "_ALL_PY.49 - lineEncoding",
    "peekOfCode": "def lineEncoding(s):\n    count = 1\n    output = []\n    for char in range(1, len(s)):\n        if s[char] == s[char - 1]:\n            count += 1\n        else:\n            if count > 1:\n                output.append(str(count) + s[char - 1])\n            else:",
    "detail": "_ALL_PY.49 - lineEncoding",
    "documentation": {}
  },
  {
    "label": "chessKnight",
    "kind": 2,
    "importPath": "_ALL_PY.50 - chessKnight",
    "description": "_ALL_PY.50 - chessKnight",
    "peekOfCode": "def chessKnight(cell):\n    moves = 0\n    # Starting at the top left, going counter-clockwise\n    if ord(cell[0]) >= ord(\"b\") and ord(cell[1]) <= ord(\"6\"):\n        moves += 1\n    if ord(cell[0]) >= ord(\"c\") and ord(cell[1]) <= ord(\"7\"):\n        moves += 1\n    if ord(cell[0]) >= ord(\"c\") and ord(cell[1]) >= ord(\"2\"):\n        moves += 1\n    if ord(cell[0]) >= ord(\"b\") and ord(cell[1]) >= ord(\"3\"):",
    "detail": "_ALL_PY.50 - chessKnight",
    "documentation": {}
  },
  {
    "label": "deleteDigit",
    "kind": 2,
    "importPath": "_ALL_PY.51 - deleteDigit",
    "description": "_ALL_PY.51 - deleteDigit",
    "peekOfCode": "def deleteDigit(n):\n    num = str(n)\n    highest = 0\n    for digit in range(len(num)):\n        output = num[:digit] + num[digit + 1:]\n        if int(output) > int(highest):\n            highest = output\n    return int(highest)",
    "detail": "_ALL_PY.51 - deleteDigit",
    "documentation": {}
  },
  {
    "label": "longestWord",
    "kind": 2,
    "importPath": "_ALL_PY.52 - longestWord",
    "description": "_ALL_PY.52 - longestWord",
    "peekOfCode": "def longestWord(text):\n    longest = []\n    word = []\n    for char in text:\n        if ord(\"A\") <= ord(char) <= ord(\"Z\") or ord(\"a\") <= ord(char) <= ord(\"z\"):\n            word.append(char)\n        else:\n            if len(word) > len(longest):\n                longest = word\n            word = []",
    "detail": "_ALL_PY.52 - longestWord",
    "documentation": {}
  },
  {
    "label": "validTime",
    "kind": 2,
    "importPath": "_ALL_PY.53 - validTime",
    "description": "_ALL_PY.53 - validTime",
    "peekOfCode": "def validTime(time):\n    groups = time.split(\":\")\n    if len(groups) != 2:\n        return False\n    if not (groups[0].isdigit() and groups[1].isdigit()):\n        return False\n    if int(groups[0]) > 23 or int(groups[1]) > 59:\n        return False\n    return True",
    "detail": "_ALL_PY.53 - validTime",
    "documentation": {}
  },
  {
    "label": "sumUpNumbers",
    "kind": 2,
    "importPath": "_ALL_PY.54 - sumUpNumbers",
    "description": "_ALL_PY.54 - sumUpNumbers",
    "peekOfCode": "def sumUpNumbers(inputString):\n    total = 0\n    current_num = []\n    for char in inputString:\n        if char.isdigit():\n            current_num.append(char)\n        else:\n            if len(current_num) > 0:\n                num = int(\"\".join(current_num))\n                total += num",
    "detail": "_ALL_PY.54 - sumUpNumbers",
    "documentation": {}
  },
  {
    "label": "differentSquares",
    "kind": 2,
    "importPath": "_ALL_PY.55 - differentSquares",
    "description": "_ALL_PY.55 - differentSquares",
    "peekOfCode": "def differentSquares(matrix):\n    squares = set()\n    for row in range(len(matrix) - 1):\n        for cell in range(len(matrix[row]) - 1):\n            square = ((matrix[row][cell], matrix[row][cell + 1]),\n                      (matrix[row + 1][cell], matrix[row + 1][cell + 1]))\n            squares.add(square)\n    return len(squares)",
    "detail": "_ALL_PY.55 - differentSquares",
    "documentation": {}
  },
  {
    "label": "digitsProduct",
    "kind": 2,
    "importPath": "_ALL_PY.56 - digitsProduct",
    "description": "_ALL_PY.56 - digitsProduct",
    "peekOfCode": "def digitsProduct(product):\n    # New idea: add product to factors\n    # while max(factors) > 10: split that num into factors\n    if product == 0:\n        return 10\n    factors = [product]\n    while max(factors) > 9:\n        factored = findFactors(max(factors))\n        if factored:\n            factors.remove(max(factors))",
    "detail": "_ALL_PY.56 - digitsProduct",
    "documentation": {}
  },
  {
    "label": "findFactors",
    "kind": 2,
    "importPath": "_ALL_PY.56 - digitsProduct",
    "description": "_ALL_PY.56 - digitsProduct",
    "peekOfCode": "def findFactors(n):\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return i, n // i\n    return False",
    "detail": "_ALL_PY.56 - digitsProduct",
    "documentation": {}
  },
  {
    "label": "fileNaming",
    "kind": 2,
    "importPath": "_ALL_PY.57 - fileNaming",
    "description": "_ALL_PY.57 - fileNaming",
    "peekOfCode": "def fileNaming(names):\n    outnames = []\n    for name in names:\n        if name in outnames:\n            k = 1\n            while \"{}({})\".format(name, k) in outnames:\n                k += 1\n            name = \"{}({})\".format(name, k)\n        outnames.append(name)\n    return outnames",
    "detail": "_ALL_PY.57 - fileNaming",
    "documentation": {}
  },
  {
    "label": "messageFromBinaryCode",
    "kind": 2,
    "importPath": "_ALL_PY.58 - messageFromBinaryCode",
    "description": "_ALL_PY.58 - messageFromBinaryCode",
    "peekOfCode": "def messageFromBinaryCode(code):\n    output = []\n    for i in range(0, len(code), 8):\n        letter = chr(int(code[i:i + 8], 2))\n        output.append(letter)\n    return ''.join(output)",
    "detail": "_ALL_PY.58 - messageFromBinaryCode",
    "documentation": {}
  },
  {
    "label": "spiralNumbers",
    "kind": 2,
    "importPath": "_ALL_PY.59 - spiralNumbers",
    "description": "_ALL_PY.59 - spiralNumbers",
    "peekOfCode": "def spiralNumbers(n):\n    LEFT = 'left'\n    RIGHT = 'right'\n    UP = 'up'\n    DOWN = 'down'\n    direction = RIGHT\n    spiral = [[0 for i in range(n)] for j in range(n)]\n    row = 0\n    cell = 0\n    for num in range(1, (n * n) + 1):",
    "detail": "_ALL_PY.59 - spiralNumbers",
    "documentation": {}
  },
  {
    "label": "sudoku",
    "kind": 2,
    "importPath": "_ALL_PY.60 - sudoku",
    "description": "_ALL_PY.60 - sudoku",
    "peekOfCode": "def sudoku(grid):\n    match = [i for i in range(1, 10)]\n    for row in grid:\n        if sorted(row) != match:\n            return False\n    for column_index in range(9):\n        column = [grid[row_index][column_index] for row_index in range(9)]\n        if sorted(column) != match:\n            return False\n    for row in range(0, 9, 3):",
    "detail": "_ALL_PY.60 - sudoku",
    "documentation": {}
  },
  {
    "label": "absolute_value_sum",
    "kind": 2,
    "importPath": "_ALL_PY.absolute_values_sum_minimization",
    "description": "_ALL_PY.absolute_values_sum_minimization",
    "peekOfCode": "def absolute_value_sum(mylist, x):\n    running_sum = 0\n    for number in mylist:\n        running_sum += abs(number - x)\n    return running_sum\ndef absoluteValuesSumMinimization(a):\n    mydict = {}\n    for i in range(len(a)):\n        mydict[a[i]] = absolute_value_sum(a, a[i])\n    return min(mydict, key=mydict.get)",
    "detail": "_ALL_PY.absolute_values_sum_minimization",
    "documentation": {}
  },
  {
    "label": "absoluteValuesSumMinimization",
    "kind": 2,
    "importPath": "_ALL_PY.absolute_values_sum_minimization",
    "description": "_ALL_PY.absolute_values_sum_minimization",
    "peekOfCode": "def absoluteValuesSumMinimization(a):\n    mydict = {}\n    for i in range(len(a)):\n        mydict[a[i]] = absolute_value_sum(a, a[i])\n    return min(mydict, key=mydict.get)",
    "detail": "_ALL_PY.absolute_values_sum_minimization",
    "documentation": {}
  },
  {
    "label": "add",
    "kind": 2,
    "importPath": "_ALL_PY.add (2)",
    "description": "_ALL_PY.add (2)",
    "peekOfCode": "def add(param1, param2):\n    return param1 + param2",
    "detail": "_ALL_PY.add (2)",
    "documentation": {}
  },
  {
    "label": "add",
    "kind": 2,
    "importPath": "_ALL_PY.add",
    "description": "_ALL_PY.add",
    "peekOfCode": "def add(param1, param2):\n    return param1 + param2",
    "detail": "_ALL_PY.add",
    "documentation": {}
  },
  {
    "label": "addTwoDigits",
    "kind": 5,
    "importPath": "_ALL_PY.addTwoDigits",
    "description": "_ALL_PY.addTwoDigits",
    "peekOfCode": "addTwoDigits = lambda n: n % 10 + n // 10\n# return sum(int(i) for i in str(n))",
    "detail": "_ALL_PY.addTwoDigits",
    "documentation": {}
  },
  {
    "label": "addBorder",
    "kind": 2,
    "importPath": "_ALL_PY.add_border",
    "description": "_ALL_PY.add_border",
    "peekOfCode": "def addBorder(picture):\n    picture_with_border = []\n    for i in range(len(picture)):\n        # Add the main border to the picture\n        if i == 0:\n            picture_with_border.append(\"*\" * (len(picture[i]) + 2))\n        picture_with_border.append(\"*\" + \"\".join(picture[i]) + \"*\")\n        # Add the main border to the picture\n        if i == len(picture) - 1:\n            picture_with_border.append(\"*\" * (len(picture[i]) + 2))",
    "detail": "_ALL_PY.add_border",
    "documentation": {}
  },
  {
    "label": "addTwoDigits",
    "kind": 2,
    "importPath": "_ALL_PY.add_two_digits",
    "description": "_ALL_PY.add_two_digits",
    "peekOfCode": "def addTwoDigits(n):\n\t\"\"\"\n\tReturn sum of the two digits in n\n\t\"\"\"\n    digits = str(n)\n    return sum([int(digit) for digit in digits])",
    "detail": "_ALL_PY.add_two_digits",
    "documentation": {}
  },
  {
    "label": "adjacent_elements_product",
    "kind": 2,
    "importPath": "_ALL_PY.adjacent_elements_product",
    "description": "_ALL_PY.adjacent_elements_product",
    "peekOfCode": "def adjacent_elements_product(inputArray: list = None) -> int:\n    if inputArray is None:\n        return 0\n    if isinstance(inputArray, list) and 2 <= len(inputArray) <= 10:\n        adjacent = inputArray[0] * inputArray[1]\n        for i in range(len(inputArray) - 1):\n            if -1000 <= inputArray[i] <= 1000 and -1000 <= inputArray[i + 1] <= 1000:\n                tmp = inputArray[i] * inputArray[i + 1]\n                if tmp > adjacent:\n                    adjacent = tmp",
    "detail": "_ALL_PY.adjacent_elements_product",
    "documentation": {}
  },
  {
    "label": "isAdult",
    "kind": 5,
    "importPath": "_ALL_PY.Adult",
    "description": "_ALL_PY.Adult",
    "peekOfCode": "isAdult = lambda a, m: a >= m",
    "detail": "_ALL_PY.Adult",
    "documentation": {}
  },
  {
    "label": "allLongestStrings",
    "kind": 2,
    "importPath": "_ALL_PY.all_longest_strings",
    "description": "_ALL_PY.all_longest_strings",
    "peekOfCode": "def allLongestStrings(inputArray):\n    # sortedList = sorted(inputArray, key=len, reverse=True)\n    max_string_length, longest_strings = max(inputArray, key=len), []\n    for i in range(len(inputArray)):\n        if len(inputArray[i]) == len(max_string_length):\n            longest_strings.append(inputArray[i])\n    return longest_strings",
    "detail": "_ALL_PY.all_longest_strings",
    "documentation": {}
  },
  {
    "label": "is_increasing_sequence",
    "kind": 2,
    "importPath": "_ALL_PY.almost_increasing_sequence",
    "description": "_ALL_PY.almost_increasing_sequence",
    "peekOfCode": "def is_increasing_sequence(sequence):\n    for i in range(len(sequence) - 1):\n        if sequence[i] >= sequence[i + 1]:\n            return i\n    return -1\ndef almostIncreasingSequence(sequence):\n    j = is_increasing_sequence(sequence)\n    if j == -1:\n        return True\n    if is_increasing_sequence(sequence[j - 1 : j] + sequence[j + 1 :]) == -1:",
    "detail": "_ALL_PY.almost_increasing_sequence",
    "documentation": {}
  },
  {
    "label": "almostIncreasingSequence",
    "kind": 2,
    "importPath": "_ALL_PY.almost_increasing_sequence",
    "description": "_ALL_PY.almost_increasing_sequence",
    "peekOfCode": "def almostIncreasingSequence(sequence):\n    j = is_increasing_sequence(sequence)\n    if j == -1:\n        return True\n    if is_increasing_sequence(sequence[j - 1 : j] + sequence[j + 1 :]) == -1:\n        return True  # Deleting earlier element makes it increasing\n    if is_increasing_sequence(sequence[j : j + 1] + sequence[j + 2 :]) == -1:\n        return True  # Deleting later element makes it increasing\n    return False",
    "detail": "_ALL_PY.almost_increasing_sequence",
    "documentation": {}
  },
  {
    "label": "alphabeticShift",
    "kind": 2,
    "importPath": "_ALL_PY.alphabetic_shift",
    "description": "_ALL_PY.alphabetic_shift",
    "peekOfCode": "def alphabeticShift(inputString):\n    outputString = \"\"\n    for i in range(len(inputString)):\n        outputString += chr((ord(inputString[i]) + 1 - 97) % 26 + 97)\n    return outputString",
    "detail": "_ALL_PY.alphabetic_shift",
    "documentation": {}
  },
  {
    "label": "alternatingSums",
    "kind": 2,
    "importPath": "_ALL_PY.alternating_sums",
    "description": "_ALL_PY.alternating_sums",
    "peekOfCode": "def alternatingSums(a):\n    team1, team2 = [], []\n    for i in range(len(a)):\n        if i % 2 == 0:\n            team1.append(a[i])\n        else:\n            team2.append(a[i])\n    return [sum(team1), sum(team2)]",
    "detail": "_ALL_PY.alternating_sums",
    "documentation": {}
  },
  {
    "label": "bishopAndPawn",
    "kind": 2,
    "importPath": "_ALL_PY.AndPawn",
    "description": "_ALL_PY.AndPawn",
    "peekOfCode": "def bishopAndPawn(bishop, pawn):\n    if ord(bishop[0]) == ord(pawn[0]):\n        return False\n    else:\n        bishop_elm = ord(bishop[0]) + int(bishop[1])\n        pawn_elm = ord(pawn[0]) + int(pawn[1])\n        return (bishop_elm + pawn_elm) % 2 == 0",
    "detail": "_ALL_PY.AndPawn",
    "documentation": {}
  },
  {
    "label": "shapeArea",
    "kind": 2,
    "importPath": "_ALL_PY.Area",
    "description": "_ALL_PY.Area",
    "peekOfCode": "def shapeArea(n):\n    # Case 1: If the polygon is 0-interesting, it has an area equal to zero.\n    if n == 0:\n        return None\n    # Case 2: If the polygon is 1-interesting, it has an area equal to one.\n    elif n == 1:\n        return 1\n    # Case 3: If the polygon is n-interesting, it has an area equal to the sum of the square of n\n    # and the square of n-1. A way that I thought of it (based on the picture provided) is the following:\n    # - n**2: Counted the number of the blue squares from the middle line upwards (INCLUDING the blue squares of the middle line).",
    "detail": "_ALL_PY.Area",
    "documentation": {}
  },
  {
    "label": "areEquallyStrong",
    "kind": 2,
    "importPath": "_ALL_PY.are_equally_strong",
    "description": "_ALL_PY.are_equally_strong",
    "peekOfCode": "def areEquallyStrong(yourLeft, yourRight, friendsLeft, friendsRight):\n    myStrongestArm = max(yourLeft, yourRight)\n    myWeakestArm = min(yourLeft, yourRight)\n    friendStrongestArm = max(friendsLeft, friendsRight)\n    friendWeakestArm = min(friendsLeft, friendsRight)\n    if myStrongestArm == friendStrongestArm and myWeakestArm == friendWeakestArm:\n        return True\n    else:\n        return False",
    "detail": "_ALL_PY.are_equally_strong",
    "documentation": {}
  },
  {
    "label": "areSimilar",
    "kind": 2,
    "importPath": "_ALL_PY.are_similar",
    "description": "_ALL_PY.are_similar",
    "peekOfCode": "def areSimilar(a, b):\n    for i in range(len(a)):\n        sorted_a, sorted_b = sorted(a), sorted(b)\n        if sorted_a != sorted_b:\n            return False\n        inversions = 0\n        for i in range(len(a)):\n            if a[i] != b[i]:\n                inversions += 1\n        return inversions == 2 or inversions == 0",
    "detail": "_ALL_PY.are_similar",
    "documentation": {}
  },
  {
    "label": "arithmeticExpression",
    "kind": 2,
    "importPath": "_ALL_PY.arithmetic_expression",
    "description": "_ALL_PY.arithmetic_expression",
    "peekOfCode": "def arithmeticExpression(a, b, c):\n    \"\"\"\n    Consider an arithmetic expression of the form a#b=c. \n    Check whether it is possible to replace # with one of \n    the four signs: +, -, * or / to obtain a correct\n    \"\"\"\n    return (\n        True if (a + b == c) or (a - b == c) or (a * b == c) or (a / b == c) else False\n    )",
    "detail": "_ALL_PY.arithmetic_expression",
    "documentation": {}
  },
  {
    "label": "L,",
    "kind": 5,
    "importPath": "_ALL_PY.arrayConsecutive",
    "description": "_ALL_PY.arrayConsecutive",
    "peekOfCode": "L, = eval(dir()[0])\ns = 0\nwhile len(L) > 1:\n    L = numpy.add(L[:-1:2], L[1::2]) if s % 2 == 0 else numpy.multiply(L[:-1:2], L[1::2])\n    s += 1\nreturn L[0]",
    "detail": "_ALL_PY.arrayConsecutive",
    "documentation": {}
  },
  {
    "label": "s",
    "kind": 5,
    "importPath": "_ALL_PY.arrayConsecutive",
    "description": "_ALL_PY.arrayConsecutive",
    "peekOfCode": "s = 0\nwhile len(L) > 1:\n    L = numpy.add(L[:-1:2], L[1::2]) if s % 2 == 0 else numpy.multiply(L[:-1:2], L[1::2])\n    s += 1\nreturn L[0]",
    "detail": "_ALL_PY.arrayConsecutive",
    "documentation": {}
  },
  {
    "label": "makeArrayConsecutive2",
    "kind": 2,
    "importPath": "_ALL_PY.ArrayConsecutive2",
    "description": "_ALL_PY.ArrayConsecutive2",
    "peekOfCode": "def makeArrayConsecutive2(statues):\n    # Step 1: We begin by creating a new array called \"stat_arr\", which will accommodate the sorted version of the original \"statues\" array.\n    stat_arr = sorted(statues)\n    # Step 2: Furthermore, we use the first element of the sorted array as our index (that will be used in the following steps).\n    i = stat_arr[0]\n    # Step 3: We create an empty list called \"result\" to store our (numbered) missing statues.\n    result = list()\n    # Step 4: We initiate a while-loop with the condition that the index from Step 2 is not equal to the last (hence largest) entry of\n    # the stat_arr. You must make sure that you add the \"incrementation by 1\" part to make the while loop proceed to the next element.\n    while i != stat_arr[-1]:",
    "detail": "_ALL_PY.ArrayConsecutive2",
    "documentation": {}
  },
  {
    "label": "L,",
    "kind": 5,
    "importPath": "_ALL_PY.arrayConversion",
    "description": "_ALL_PY.arrayConversion",
    "peekOfCode": "L, = eval(dir()[0])\ns = 0\nwhile len(L) > 1:\n    L = numpy.add(L[:-1:2], L[1::2]) if s % 2 == 0 else numpy.multiply(L[:-1:2], L[1::2])\n    s += 1\nreturn L[0]",
    "detail": "_ALL_PY.arrayConversion",
    "documentation": {}
  },
  {
    "label": "s",
    "kind": 5,
    "importPath": "_ALL_PY.arrayConversion",
    "description": "_ALL_PY.arrayConversion",
    "peekOfCode": "s = 0\nwhile len(L) > 1:\n    L = numpy.add(L[:-1:2], L[1::2]) if s % 2 == 0 else numpy.multiply(L[:-1:2], L[1::2])\n    s += 1\nreturn L[0]",
    "detail": "_ALL_PY.arrayConversion",
    "documentation": {}
  },
  {
    "label": "arrayChange",
    "kind": 2,
    "importPath": "_ALL_PY.array_change",
    "description": "_ALL_PY.array_change",
    "peekOfCode": "def arrayChange(inputArray):\n    moves = 0\n    current = inputArray[0]\n    for number in inputArray[1:]:\n        if number <= current:\n            moves += current - number + 1\n            current += 1\n        else:\n            current = number\n    return moves",
    "detail": "_ALL_PY.array_change",
    "documentation": {}
  },
  {
    "label": "arrayMaximalAdjacentDifference",
    "kind": 2,
    "importPath": "_ALL_PY.array_maximal_adjacent_abs_difference",
    "description": "_ALL_PY.array_maximal_adjacent_abs_difference",
    "peekOfCode": "def arrayMaximalAdjacentDifference(inputArray):\n    max_diff = -15\n    for i in range(len(inputArray) - 1):\n        max_diff = max(abs(inputArray[i] - inputArray[i + 1]), max_diff)\n    return max_diff",
    "detail": "_ALL_PY.array_maximal_adjacent_abs_difference",
    "documentation": {}
  },
  {
    "label": "maxSum",
    "kind": 2,
    "importPath": "_ALL_PY.array_max_consecutive_sum",
    "description": "_ALL_PY.array_max_consecutive_sum",
    "peekOfCode": "def maxSum(arr, n, k):\n    # k must be greater\n    if n < k:\n        print(\"Invalid\")\n        return -1\n    # Compute sum of first\n    # window of size k\n    res = 0\n    for i in range(k):\n        res += arr[i]",
    "detail": "_ALL_PY.array_max_consecutive_sum",
    "documentation": {}
  },
  {
    "label": "arrayMaxConsecutiveSum",
    "kind": 2,
    "importPath": "_ALL_PY.array_max_consecutive_sum",
    "description": "_ALL_PY.array_max_consecutive_sum",
    "peekOfCode": "def arrayMaxConsecutiveSum(inputArray, k):\n    \"\"\"Find maximal possible sum of k consecutive elements in list of integers\n    Args:\n        intputArray(int): List of integers\n        k(int): Number of consecutive elements\n    Return\n        Maximum sum of k consecutive elements\n    Raises:\n    \"\"\"\n    return maxSum(inputArray, len(inputArray), k)",
    "detail": "_ALL_PY.array_max_consecutive_sum",
    "documentation": {}
  },
  {
    "label": "arrayReplace",
    "kind": 2,
    "importPath": "_ALL_PY.array_replace",
    "description": "_ALL_PY.array_replace",
    "peekOfCode": "def arrayReplace(inputArray, elemToReplace, substitutionElem):\n    for i in range(len(inputArray)):\n        if inputArray[i] == elemToReplace:\n            inputArray[i] = substitutionElem\n    return inputArray",
    "detail": "_ALL_PY.array_replace",
    "documentation": {}
  },
  {
    "label": "avoidObstacles",
    "kind": 2,
    "importPath": "_ALL_PY.avoid_obstacles",
    "description": "_ALL_PY.avoid_obstacles",
    "peekOfCode": "def avoidObstacles(inputArray):\n    sortedlist = sorted(inputArray)  # Sort list in ascending order\n    jump_dist = 1  # Set jump distance to 1 initially\n    obstacle_hit = True  # Flag to check if current jump distance hit an obstacle\n    while obstacle_hit:\n        obstacle_hit = False  # Set flag to false as we check next jump distance\n        jump_dist += (\n            1\n        )  # Increment jump distance as we check if next value hits no obstacles\n        # Check if jumping with current length hits an obstacle",
    "detail": "_ALL_PY.avoid_obstacles",
    "documentation": {}
  },
  {
    "label": "bankRequests",
    "kind": 2,
    "importPath": "_ALL_PY.bank",
    "description": "_ALL_PY.bank",
    "peekOfCode": "def bankRequests(accounts, requests):\n    request = []\n    for elements in requests:\n        request.append(elements.split(\" \"))\n    errores = 0\n    for elements in request:\n        if(bank(accounts, elements) == [-2]):\n            errores += 1\n        else:\n            accounts = bank(accounts, elements)",
    "detail": "_ALL_PY.bank",
    "documentation": {}
  },
  {
    "label": "bank",
    "kind": 2,
    "importPath": "_ALL_PY.bank",
    "description": "_ALL_PY.bank",
    "peekOfCode": "def bank(accounts, request):\n    type = request[0]\n    print(accounts)\n    if type == \"withdraw\":\n        index = (int(request[1])-1)\n        if index < len(accounts):\n            print(index)\n            value = int(request[2])\n            if accounts[index] >= value:\n                accounts[index] -= value",
    "detail": "_ALL_PY.bank",
    "documentation": {}
  },
  {
    "label": "main",
    "kind": 2,
    "importPath": "_ALL_PY.bank",
    "description": "_ALL_PY.bank",
    "peekOfCode": "def main():\n    accounts = [10, 100, 20, 50, 30]\n    requests = [\"withdraw  10\", \"transfer 5 1 20\",\n                \"deposit 5 20\", \"transfer 3 4 15\"]\n    print(bankRequests(accounts, requests))\nif __name__ == '__main__':\n    main()",
    "detail": "_ALL_PY.bank",
    "documentation": {}
  },
  {
    "label": "bankRequests",
    "kind": 2,
    "importPath": "_ALL_PY.bankManagement",
    "description": "_ALL_PY.bankManagement",
    "peekOfCode": "def bankRequests(accounts, requests):\n    \"\"\"Shubidubi\"\"\"\n    request = []\n    for elements in requests:  # Se le da un split a todos los elementos de la matriz con parámetro de espacio\n        request.append(elements.split(\" \"))\n    errores = 0\n    for elements in request:        try:\n            accounts = bank(accounts, elements)\n        except Exception as err:\n            errores += 1",
    "detail": "_ALL_PY.bankManagement",
    "documentation": {}
  },
  {
    "label": "bank",
    "kind": 2,
    "importPath": "_ALL_PY.bankManagement",
    "description": "_ALL_PY.bankManagement",
    "peekOfCode": "def bank(accounts, request):\n    type = request[0]\n    print(accounts)\n    if type == \"withdraw\":\n        index = (int(request[1])-1)\n        value = int(request[2])\n        if accounts[index] >= value:\n            accounts[index] -= value\n        else:\n            return \"Error\"",
    "detail": "_ALL_PY.bankManagement",
    "documentation": {}
  },
  {
    "label": "main",
    "kind": 2,
    "importPath": "_ALL_PY.bankManagement",
    "description": "_ALL_PY.bankManagement",
    "peekOfCode": "def main():\n    accounts = [10, 100, 20, 50, 30]\n    requests = [\"withdraw  10\", \"transfer 5 1 20\",\n                \"deposit 5 20\", \"transfer 3 4 15\"]\n    accounts\n    print(bankRequests(accounts, requests))\nif __name__ == '__main__':\n    main()",
    "detail": "_ALL_PY.bankManagement",
    "documentation": {}
  },
  {
    "label": "bankRequests",
    "kind": 2,
    "importPath": "_ALL_PY.banks",
    "description": "_ALL_PY.banks",
    "peekOfCode": "def bankRequests(accounts, requests):\n    map(lambda x: x.split(), requests)\n    print(requests)\ndef main():\n    acco < unts = [10, 100, 20, 50, 30]\n    requests = [\"withdraw 2 10\", \"transfer 5 1 20\",\n                \"deposit 5 20\", \"transfer 3 4 15\"]\n    bankRequests(accounts, requests)\nif __name__ == '__main__':\n    main()",
    "detail": "_ALL_PY.banks",
    "documentation": {}
  },
  {
    "label": "main",
    "kind": 2,
    "importPath": "_ALL_PY.banks",
    "description": "_ALL_PY.banks",
    "peekOfCode": "def main():\n    acco < unts = [10, 100, 20, 50, 30]\n    requests = [\"withdraw 2 10\", \"transfer 5 1 20\",\n                \"deposit 5 20\", \"transfer 3 4 15\"]\n    bankRequests(accounts, requests)\nif __name__ == '__main__':\n    main()\ndef hayDuplicados(lista):\n    lista.sort()\n    for i in range(lista):",
    "detail": "_ALL_PY.banks",
    "documentation": {}
  },
  {
    "label": "hayDuplicados",
    "kind": 2,
    "importPath": "_ALL_PY.banks",
    "description": "_ALL_PY.banks",
    "peekOfCode": "def hayDuplicados(lista):\n    lista.sort()\n    for i in range(lista):\n        if i+1 <= len(lista):\n            if lista[i] == lista[i+1]:\n                return True\n    return False\ndef borrarDuplicados(lista):\n    lista = [set(lista)]",
    "detail": "_ALL_PY.banks",
    "documentation": {}
  },
  {
    "label": "borrarDuplicados",
    "kind": 2,
    "importPath": "_ALL_PY.banks",
    "description": "_ALL_PY.banks",
    "peekOfCode": "def borrarDuplicados(lista):\n    lista = [set(lista)]",
    "detail": "_ALL_PY.banks",
    "documentation": {}
  },
  {
    "label": "isBeautifulString",
    "kind": 2,
    "importPath": "_ALL_PY.BeautifulString",
    "description": "_ALL_PY.BeautifulString",
    "peekOfCode": "def isBeautifulString(inputString):\n    counter = [inputString.count(i) for i in string.ascii_lowercase]\n    return counter[::-1] == sorted(counter)",
    "detail": "_ALL_PY.BeautifulString",
    "documentation": {}
  },
  {
    "label": "bishopAndPawn",
    "kind": 2,
    "importPath": "_ALL_PY.bishop_and_pawn",
    "description": "_ALL_PY.bishop_and_pawn",
    "peekOfCode": "def bishopAndPawn(bishop, pawn):\n    x = \"abcdefgh\"\n    return abs(int(x.index(bishop[0])) - int(x.index(pawn[0]))) == abs(\n        int(bishop[1]) - int(pawn[1])\n    )",
    "detail": "_ALL_PY.bishop_and_pawn",
    "documentation": {}
  },
  {
    "label": "boxBlur",
    "kind": 2,
    "importPath": "_ALL_PY.Blur",
    "description": "_ALL_PY.Blur",
    "peekOfCode": "def boxBlur(image):\n    def pixels(matrix, i, j):\n        summ = 0\n        for x in range(i - 1, i + 2):\n            for y in range(j - 1, j + 2):\n                summ += matrix[x][y]\n                mean = summ // 9\n        return mean\n    output = []\n    row = len(image)",
    "detail": "_ALL_PY.Blur",
    "documentation": {}
  },
  {
    "label": "chessBoardCellColor",
    "kind": 2,
    "importPath": "_ALL_PY.BoardCellColor",
    "description": "_ALL_PY.BoardCellColor",
    "peekOfCode": "def chessBoardCellColor(cell1, cell2):\n    cell1_elm = ord(cell1[0]) + int(cell1[1])\n    cell2_elm = ord(cell2[0]) + int(cell2[1])\n    return (cell1_elm + cell2_elm) % 2 == 0",
    "detail": "_ALL_PY.BoardCellColor",
    "documentation": {}
  },
  {
    "label": "addBorder",
    "kind": 2,
    "importPath": "_ALL_PY.Border",
    "description": "_ALL_PY.Border",
    "peekOfCode": "def addBorder(picture):\n    new_pic = []\n    border = \"\"\n    pic_len = len(picture)\n    for i in range(0, len(picture[0]) + 2):\n        border += \"*\"\n    new_pic.append(border)\n    for i in range(0, pic_len):\n        new_pic.append(\"*\" + picture[i] + \"*\")\n    new_pic.append(border)",
    "detail": "_ALL_PY.Border",
    "documentation": {}
  },
  {
    "label": "square_matrix",
    "kind": 2,
    "importPath": "_ALL_PY.box_blur_algortihm",
    "description": "_ALL_PY.box_blur_algortihm",
    "peekOfCode": "def square_matrix(square):\n    # Calculate sum of all the pixels in 3 * 3 matrix\n    tot_sum = 0\n    for i in range(3):\n        for j in range(3):\n            tot_sum += square[i][j]\n    return tot_sum // 9  # return the average of the sum of pixels\ndef boxBlur(image):\n    square = []  # This will store the 3 * 3 matrix\n    # which will be used to find its blurred pixel",
    "detail": "_ALL_PY.box_blur_algortihm",
    "documentation": {}
  },
  {
    "label": "boxBlur",
    "kind": 2,
    "importPath": "_ALL_PY.box_blur_algortihm",
    "description": "_ALL_PY.box_blur_algortihm",
    "peekOfCode": "def boxBlur(image):\n    square = []  # This will store the 3 * 3 matrix\n    # which will be used to find its blurred pixel\n    square_row = []  # This will store one row of a 3 * 3 matrix and\n    # will be appended in square\n    blur_row = []  # Here we will store the resulting blurred\n    # pixels possible in one row\n    # and will append this in the blur_img\n    blur_img = []  # This is the resulting blurred image\n    # number of rows in the given image",
    "detail": "_ALL_PY.box_blur_algortihm",
    "documentation": {}
  },
  {
    "label": "sulkyBoy",
    "kind": 5,
    "importPath": "_ALL_PY.Boy",
    "description": "_ALL_PY.Boy",
    "peekOfCode": "sulkyBoy = lambda x: not x",
    "detail": "_ALL_PY.Boy",
    "documentation": {}
  },
  {
    "label": "TreeNode",
    "kind": 6,
    "importPath": "_ALL_PY.BST_from_preorder",
    "description": "_ALL_PY.BST_from_preorder",
    "peekOfCode": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\nclass Solution:\n    def bstFromPreorder(self, preorder):\n        if not preorder:\n            return None\n        root = TreeNode(preorder[0])",
    "detail": "_ALL_PY.BST_from_preorder",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "_ALL_PY.BST_from_preorder",
    "description": "_ALL_PY.BST_from_preorder",
    "peekOfCode": "class Solution:\n    def bstFromPreorder(self, preorder):\n        if not preorder:\n            return None\n        root = TreeNode(preorder[0])\n        i = 1\n        while i < len(preorder) and preorder[i] < root.val:\n            i += 1\n        root.left = self.bstFromPreorder(preorder[1:i])\n        root.right = self.bstFromPreorder(preorder[i:])",
    "detail": "_ALL_PY.BST_from_preorder",
    "documentation": {}
  },
  {
    "label": "preorder",
    "kind": 5,
    "importPath": "_ALL_PY.BST_from_preorder",
    "description": "_ALL_PY.BST_from_preorder",
    "peekOfCode": "preorder = [19, 4, 8, 11]\nbst = Solution()\nbst.bstFromPreorder(preorder)",
    "detail": "_ALL_PY.BST_from_preorder",
    "documentation": {}
  },
  {
    "label": "bst",
    "kind": 5,
    "importPath": "_ALL_PY.BST_from_preorder",
    "description": "_ALL_PY.BST_from_preorder",
    "peekOfCode": "bst = Solution()\nbst.bstFromPreorder(preorder)",
    "detail": "_ALL_PY.BST_from_preorder",
    "documentation": {}
  },
  {
    "label": "isPalindrome",
    "kind": 2,
    "importPath": "_ALL_PY.build_palindrome",
    "description": "_ALL_PY.build_palindrome",
    "peekOfCode": "def isPalindrome(st):\n    for i in range(len(st) // 2):\n        if st[i] != st[len(st) - 1 - i]:\n            return False\n    return True\ndef buildPalindrome(st):\n    for i in range(len(st)):\n        substring = st[i : len(st)]\n        if isPalindrome(substring):\n            non_palindrome_part = st[0:i]",
    "detail": "_ALL_PY.build_palindrome",
    "documentation": {}
  },
  {
    "label": "buildPalindrome",
    "kind": 2,
    "importPath": "_ALL_PY.build_palindrome",
    "description": "_ALL_PY.build_palindrome",
    "peekOfCode": "def buildPalindrome(st):\n    for i in range(len(st)):\n        substring = st[i : len(st)]\n        if isPalindrome(substring):\n            non_palindrome_part = st[0:i]\n            return st + non_palindrome_part[::-1]\n    return \"String not found\"",
    "detail": "_ALL_PY.build_palindrome",
    "documentation": {}
  },
  {
    "label": "maxProfit",
    "kind": 2,
    "importPath": "_ALL_PY.Buy_and_Sell_Stock",
    "description": "_ALL_PY.Buy_and_Sell_Stock",
    "peekOfCode": "def maxProfit(prices):\n    i = 0\n    max_profit = 0\n    while i < len(prices) - 1:\n        while i < len(prices) - 1 and prices[i] >= prices[i + 1]:\n            i += 1\n        min_pri = prices[i]\n        while i < len(prices) - 1 and prices[i] <= prices[i + 1]:\n            i += 1\n        max_pri = prices[i]",
    "detail": "_ALL_PY.Buy_and_Sell_Stock",
    "documentation": {}
  },
  {
    "label": "A,",
    "kind": 5,
    "importPath": "_ALL_PY.ByHeight (2)",
    "description": "_ALL_PY.ByHeight (2)",
    "peekOfCode": "A, = numpy.r_[eval(dir()[0])]\nA[A > 0] = sorted(A[A > 0])\nreturn A",
    "detail": "_ALL_PY.ByHeight (2)",
    "documentation": {}
  },
  {
    "label": "sortByHeight",
    "kind": 2,
    "importPath": "_ALL_PY.ByHeight",
    "description": "_ALL_PY.ByHeight",
    "peekOfCode": "def sortByHeight(a):\n    # Step 1: We begin by creating a counter, starting from 0, that will be used in the subsequent for-loop.\n    j = 0\n    # Step 2: We also create a new array, called \"a_sort\", where we sort (in ascending order) all elements of the given array \"a\"\n    # that are not \"trees\" (i.e. do not have a value of -1).\n    a_sort = sorted([i for i in a if i != -1])\n    # Step 3: By implementing a for-loop, we investigate all elements of the given array \"a\" (NOT a_sort!) and check:\n    # if the element i in array \"a\" is equal to -1, the for-loop continues. Otherwise, the element i in array \"a\" should be\n    # the same as element j in array \"a_sort\" (starting from 0 index, as defined in step 1).\n    # You can think of it as working through elements of array \"a\", disregarding the \"trees\" (-1s) and sorting the rest",
    "detail": "_ALL_PY.ByHeight",
    "documentation": {}
  },
  {
    "label": "pagarEstacionamiento",
    "kind": 2,
    "importPath": "_ALL_PY.cajero",
    "description": "_ALL_PY.cajero",
    "peekOfCode": "def pagarEstacionamiento(apagar):\n    total = apagar\n    print(\"Total a pagar:\" + str(apagar))\n    while apagar > 0:\n        moneda = int(\n            input(\"Ingresa la cantidad de la moneda que quieres ingresar: \"))\n        if moneda == 1 or moneda == 2 or moneda == 5 or moneda == 10 or moneda == 50:\n            apagar -= moneda\n        else:\n            print(",
    "detail": "_ALL_PY.cajero",
    "documentation": {}
  },
  {
    "label": "main",
    "kind": 2,
    "importPath": "_ALL_PY.cajero",
    "description": "_ALL_PY.cajero",
    "peekOfCode": "def main():\n    pagarEstacionamiento(72)\nif __name__ == '__main__':\n    main()",
    "detail": "_ALL_PY.cajero",
    "documentation": {}
  },
  {
    "label": "candies",
    "kind": 2,
    "importPath": "_ALL_PY.candies",
    "description": "_ALL_PY.candies",
    "peekOfCode": "def candies(n, m):\n    return (m // n) * n",
    "detail": "_ALL_PY.candies",
    "documentation": {}
  },
  {
    "label": "caseUnification",
    "kind": 2,
    "importPath": "_ALL_PY.caseUnification",
    "description": "_ALL_PY.caseUnification",
    "peekOfCode": "def caseUnification(s):\n    u = (sum(1 for x in s if x.isupper()))\n    if u > (len(s)/2):\n        return s.upper()\n    else:\n        return s.lower()",
    "detail": "_ALL_PY.caseUnification",
    "documentation": {}
  },
  {
    "label": "century_from_year",
    "kind": 2,
    "importPath": "_ALL_PY.century_from_year",
    "description": "_ALL_PY.century_from_year",
    "peekOfCode": "def century_from_year(year: int = 0) -> int:\n    if isinstance(year, int) and 1 <= year <= 2005:\n        century = year // 100\n        if year % 100 == 0:\n            return century\n        else:\n            return century + 1\n    return 0",
    "detail": "_ALL_PY.century_from_year",
    "documentation": {}
  },
  {
    "label": "arrayChange",
    "kind": 2,
    "importPath": "_ALL_PY.Change",
    "description": "_ALL_PY.Change",
    "peekOfCode": "def arrayChange(inputArray):\n    first = inputArray[0]\n    count = 0\n    for i in inputArray[1:]:\n        if i <= first:\n            count += first - i + 1\n            first = first + 1\n        else:\n            first = i\n    return count",
    "detail": "_ALL_PY.Change",
    "documentation": {}
  },
  {
    "label": "commonCharacterCount",
    "kind": 2,
    "importPath": "_ALL_PY.CharacterCount",
    "description": "_ALL_PY.CharacterCount",
    "peekOfCode": "def commonCharacterCount(s1, s2):\n    # Step 1: We create two lists, namely s1_l and s2_l, where we store the characters of strings s1 and s2 respectively.\n    s1_l = list(s1)\n    s2_l = list(s2)\n    # Step 2: We also create an empty list, where we are going to store all common characters.\n    common = []\n    # Step 3: Using a for-loop, we investigate the list of the first string, element by element.\n    for i in s1_l:\n        # Step 4: If the i-th element from the list of the first string is also present in the list of the second string,\n        # we append it to the common array. BE CAREFUL: We must implement the s2_l.remove(i) to avoid double-counting.",
    "detail": "_ALL_PY.CharacterCount",
    "documentation": {}
  },
  {
    "label": "passwordCheck",
    "kind": 5,
    "importPath": "_ALL_PY.Check",
    "description": "_ALL_PY.Check",
    "peekOfCode": "passwordCheck = lambda s: len(s) > 4 and all(\n    re.search(i, s) for i in (\"[A-Z]\", \"\\d\", \"[a-z]\")\n)",
    "detail": "_ALL_PY.Check",
    "documentation": {}
  },
  {
    "label": "checkPalindrome",
    "kind": 5,
    "importPath": "_ALL_PY.checkPalindrome",
    "description": "_ALL_PY.checkPalindrome",
    "peekOfCode": "checkPalindrome = lambda x: x == x[::-1]",
    "detail": "_ALL_PY.checkPalindrome",
    "documentation": {}
  },
  {
    "label": "checkPalindrome",
    "kind": 2,
    "importPath": "_ALL_PY.check_palindrome",
    "description": "_ALL_PY.check_palindrome",
    "peekOfCode": "def checkPalindrome(inputString):\n    for i in range(len(inputString) // 2):\n        if inputString[i] != inputString[len(inputString) - 1 - i]:\n            return False\n    return True",
    "detail": "_ALL_PY.check_palindrome",
    "documentation": {}
  },
  {
    "label": "chessBoardCellColor",
    "kind": 2,
    "importPath": "_ALL_PY.chess_board_cell_color",
    "description": "_ALL_PY.chess_board_cell_color",
    "peekOfCode": "def chessBoardCellColor(cell1, cell2):\n    mydict = {\"A\": 1, \"B\": 2, \"C\": 3, \"D\": 4, \"E\": 5, \"F\": 6, \"G\": 7, \"H\": 8}\n    if (mydict[cell1[0]] + int(cell1[1])) % 2 == (mydict[cell2[0]] + int(cell2[1])) % 2:\n        return True\n    else:\n        return False",
    "detail": "_ALL_PY.chess_board_cell_color",
    "documentation": {}
  },
  {
    "label": "chessKnight",
    "kind": 2,
    "importPath": "_ALL_PY.chess_knight",
    "description": "_ALL_PY.chess_knight",
    "peekOfCode": "def chessKnight(cell):\n    valid_count = 0\n    # All possible moves for knight\n    dirs = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    # For each move of knight, check if it's valid\n    for x, y in dirs:\n        if (97 <= ord(cell[0]) + x <= 104) and (1 <= int(cell[1]) + y <= 8):\n            valid_count += 1\n    return valid_count",
    "detail": "_ALL_PY.chess_knight",
    "documentation": {}
  },
  {
    "label": "circleOfNumbers",
    "kind": 2,
    "importPath": "_ALL_PY.circle_of_numbers",
    "description": "_ALL_PY.circle_of_numbers",
    "peekOfCode": "def circleOfNumbers(n, firstNumber):\n\t\"\"\"\n\tReturn number that is radially opposite firstNumber\n\tin circle from 1 to n\n\t\"\"\"\n    return (firstNumber + (n / 2)) % n",
    "detail": "_ALL_PY.circle_of_numbers",
    "documentation": {}
  },
  {
    "label": "n,",
    "kind": 5,
    "importPath": "_ALL_PY.columnTitle",
    "description": "_ALL_PY.columnTitle",
    "peekOfCode": "n, = eval(dir()[0])\nr = \"\"\nwhile n:\n    n -= 1\n    r = chr(n % 26 + 65) + r\n    n //= 26\nreturn r",
    "detail": "_ALL_PY.columnTitle",
    "documentation": {}
  },
  {
    "label": "r",
    "kind": 5,
    "importPath": "_ALL_PY.columnTitle",
    "description": "_ALL_PY.columnTitle",
    "peekOfCode": "r = \"\"\nwhile n:\n    n -= 1\n    r = chr(n % 26 + 65) + r\n    n //= 26\nreturn r",
    "detail": "_ALL_PY.columnTitle",
    "documentation": {}
  },
  {
    "label": "commonCharacterCount",
    "kind": 2,
    "importPath": "_ALL_PY.common_character_count",
    "description": "_ALL_PY.common_character_count",
    "peekOfCode": "def commonCharacterCount(s1, s2):\n    # To store the frequencies of characters\n    # of string s1 and s2\n    freq1 = [0] * 26\n    freq2 = [0] * 26\n    # To store the count of valid pairs\n    count = 0\n    # Update the frequencies of\n    # the characters of string s1\n    for i in range(len(s1)):",
    "detail": "_ALL_PY.common_character_count",
    "documentation": {}
  },
  {
    "label": "r",
    "kind": 5,
    "importPath": "_ALL_PY.Comparison",
    "description": "_ALL_PY.Comparison",
    "peekOfCode": "r = (a * d) / (b * c)\nreturn \"<\" if r < 1 else \">\" if r > 1 else \"=\"\n# 72 chars",
    "detail": "_ALL_PY.Comparison",
    "documentation": {}
  },
  {
    "label": "L,",
    "kind": 5,
    "importPath": "_ALL_PY.Consecutive",
    "description": "_ALL_PY.Consecutive",
    "peekOfCode": "L, = eval(dir()[0])\ns = 0\nwhile len(L) > 1:\n    L = (\n        numpy.add(L[:-1:2], L[1::2])\n        if s % 2 == 0\n        else numpy.multiply(L[:-1:2], L[1::2])\n    )\n    s += 1\nreturn L[0]",
    "detail": "_ALL_PY.Consecutive",
    "documentation": {}
  },
  {
    "label": "s",
    "kind": 5,
    "importPath": "_ALL_PY.Consecutive",
    "description": "_ALL_PY.Consecutive",
    "peekOfCode": "s = 0\nwhile len(L) > 1:\n    L = (\n        numpy.add(L[:-1:2], L[1::2])\n        if s % 2 == 0\n        else numpy.multiply(L[:-1:2], L[1::2])\n    )\n    s += 1\nreturn L[0]",
    "detail": "_ALL_PY.Consecutive",
    "documentation": {}
  },
  {
    "label": "constructArray",
    "kind": 2,
    "importPath": "_ALL_PY.constructArray",
    "description": "_ALL_PY.constructArray",
    "peekOfCode": "def constructArray(size):\n    lista1 = list(range(1,size+1))\n    lista2 = list(range(size,0,-1))\n    print(lista1)\n    print(lista2)\n    resultado = []\n    ultimo = True\n    for i in range(len(lista1)):\n        if(lista1[i] < lista2[i]):\n            resultado.append(lista1[i])",
    "detail": "_ALL_PY.constructArray",
    "documentation": {}
  },
  {
    "label": "main",
    "kind": 2,
    "importPath": "_ALL_PY.constructArray",
    "description": "_ALL_PY.constructArray",
    "peekOfCode": "def main():\n    constructArray(7)\nif __name__ == '__main__':\n    main()",
    "detail": "_ALL_PY.constructArray",
    "documentation": {}
  },
  {
    "label": "constructSubmatrix",
    "kind": 2,
    "importPath": "_ALL_PY.constructSubmatrix",
    "description": "_ALL_PY.constructSubmatrix",
    "peekOfCode": "def constructSubmatrix(matrix, rowsToDelete, columnsToDelete):\n    for rows in rowsToDelete:\n        del matrix[rows]\n    print(matrix)\n    resultado = []\n    for lista in matrix:  # SACA LAS LISTAS DE LA MATRIZ\n        nuevalista = []\n        for i in range(len(lista)):  # RECORRE LA LISTA CON I\n            if i not in columnsToDelete:\n                nuevalista.append(lista[i])",
    "detail": "_ALL_PY.constructSubmatrix",
    "documentation": {}
  },
  {
    "label": "main",
    "kind": 2,
    "importPath": "_ALL_PY.constructSubmatrix",
    "description": "_ALL_PY.constructSubmatrix",
    "peekOfCode": "def main():\n    matriz = [[1, 0, 0, 2],\n              [0, 5, 0, 1],\n              [0, 0, 3, 5]]\n    print(constructSubmatrix(matriz, [1], [0, 2]))\nif __name__ == '__main__':\n    main()",
    "detail": "_ALL_PY.constructSubmatrix",
    "documentation": {}
  },
  {
    "label": "containsCloseNums",
    "kind": 2,
    "importPath": "_ALL_PY.containsCloseNums",
    "description": "_ALL_PY.containsCloseNums",
    "peekOfCode": "def containsCloseNums(nums, k):\n    num_dict = {}\n    # setup keys for each number seen, then list their indices\n    for i, item in enumerate(nums):\n        if item in num_dict:\n            num_dict[item].append(i)\n        else:\n            num_dict[item] = [i]\n    # remove all nums that are not repeated\n    # first make a set of keys to remove to prevent editing the dictionary size while iterating over it",
    "detail": "_ALL_PY.containsCloseNums",
    "documentation": {}
  },
  {
    "label": "L,",
    "kind": 5,
    "importPath": "_ALL_PY.Conversion",
    "description": "_ALL_PY.Conversion",
    "peekOfCode": "L, = eval(dir()[0])\ns = 0\nwhile len(L) > 1:\n    L = (\n        numpy.add(L[:-1:2], L[1::2])\n        if s % 2 == 0\n        else numpy.multiply(L[:-1:2], L[1::2])\n    )\n    s += 1\nreturn L[0]",
    "detail": "_ALL_PY.Conversion",
    "documentation": {}
  },
  {
    "label": "s",
    "kind": 5,
    "importPath": "_ALL_PY.Conversion",
    "description": "_ALL_PY.Conversion",
    "peekOfCode": "s = 0\nwhile len(L) > 1:\n    L = (\n        numpy.add(L[:-1:2], L[1::2])\n        if s % 2 == 0\n        else numpy.multiply(L[:-1:2], L[1::2])\n    )\n    s += 1\nreturn L[0]",
    "detail": "_ALL_PY.Conversion",
    "documentation": {}
  },
  {
    "label": "addTwoDigits",
    "kind": 2,
    "importPath": "_ALL_PY.Core 001 - addTwoDigits",
    "description": "_ALL_PY.Core 001 - addTwoDigits",
    "peekOfCode": "def addTwoDigits(n):\n    return (n // 10) + (n % 10)",
    "detail": "_ALL_PY.Core 001 - addTwoDigits",
    "documentation": {}
  },
  {
    "label": "largestNumber",
    "kind": 2,
    "importPath": "_ALL_PY.Core 002 - largestNumber",
    "description": "_ALL_PY.Core 002 - largestNumber",
    "peekOfCode": "def largestNumber(n):\n    return int(\"9\" * n)",
    "detail": "_ALL_PY.Core 002 - largestNumber",
    "documentation": {}
  },
  {
    "label": "candies",
    "kind": 2,
    "importPath": "_ALL_PY.Core 003 - candies",
    "description": "_ALL_PY.Core 003 - candies",
    "peekOfCode": "def candies(n, m):\n    return (m // n) * n",
    "detail": "_ALL_PY.Core 003 - candies",
    "documentation": {}
  },
  {
    "label": "seatsInTheater",
    "kind": 2,
    "importPath": "_ALL_PY.Core 004 - seatsInTheater",
    "description": "_ALL_PY.Core 004 - seatsInTheater",
    "peekOfCode": "def seatsInTheater(nCols, nRows, col, row):\n    return (nCols - col + 1) * (nRows - row)",
    "detail": "_ALL_PY.Core 004 - seatsInTheater",
    "documentation": {}
  },
  {
    "label": "maxMultiple",
    "kind": 2,
    "importPath": "_ALL_PY.Core 005 - maxMultiple",
    "description": "_ALL_PY.Core 005 - maxMultiple",
    "peekOfCode": "def maxMultiple(divisor, bound):\n    for num in range(bound, 1, -1):\n        if num % divisor == 0:\n            return num\n    return 0",
    "detail": "_ALL_PY.Core 005 - maxMultiple",
    "documentation": {}
  },
  {
    "label": "circleOfNumbers",
    "kind": 2,
    "importPath": "_ALL_PY.Core 006 - circleOfNumbers",
    "description": "_ALL_PY.Core 006 - circleOfNumbers",
    "peekOfCode": "def circleOfNumbers(n, firstNumber):\n    return (firstNumber + (n // 2)) % n",
    "detail": "_ALL_PY.Core 006 - circleOfNumbers",
    "documentation": {}
  },
  {
    "label": "lateRide",
    "kind": 2,
    "importPath": "_ALL_PY.Core 007 - lateRide",
    "description": "_ALL_PY.Core 007 - lateRide",
    "peekOfCode": "def lateRide(n):\n    hours = n // 60\n    minutes = n % 60\n    return (hours // 10) + (hours % 10) + (minutes // 10) + (minutes % 10)",
    "detail": "_ALL_PY.Core 007 - lateRide",
    "documentation": {}
  },
  {
    "label": "phoneCall",
    "kind": 2,
    "importPath": "_ALL_PY.Core 008 - phoneCall",
    "description": "_ALL_PY.Core 008 - phoneCall",
    "peekOfCode": "def phoneCall(min1, min2_10, min11, s):\n    if s < min1:\n        return 0\n    if s == min1:\n        return 1\n    if s <= min1 + (min2_10 * 9):\n        s -= min1\n        return (s // min2_10) + 1\n    s -= min1\n    s -= min2_10 * 9",
    "detail": "_ALL_PY.Core 008 - phoneCall",
    "documentation": {}
  },
  {
    "label": "reachNextLevel",
    "kind": 2,
    "importPath": "_ALL_PY.Core 009 - reachNextLevel",
    "description": "_ALL_PY.Core 009 - reachNextLevel",
    "peekOfCode": "def reachNextLevel(experience, threshold, reward):\n    return experience + reward >= threshold",
    "detail": "_ALL_PY.Core 009 - reachNextLevel",
    "documentation": {}
  },
  {
    "label": "knapsackLight",
    "kind": 2,
    "importPath": "_ALL_PY.Core 010 - knapsackLight",
    "description": "_ALL_PY.Core 010 - knapsackLight",
    "peekOfCode": "def knapsackLight(value1, weight1, value2, weight2, maxW):\n    if weight1 + weight2 <= maxW:\n        return value1 + value2\n    if weight1 <= maxW and weight2 <= maxW:\n        return max(value1, value2)\n    if weight1 <= maxW:\n        return value1\n    if weight2 <= maxW:\n        return value2\n    return 0",
    "detail": "_ALL_PY.Core 010 - knapsackLight",
    "documentation": {}
  },
  {
    "label": "extraNumber",
    "kind": 2,
    "importPath": "_ALL_PY.Core 011 - extraNumber",
    "description": "_ALL_PY.Core 011 - extraNumber",
    "peekOfCode": "def extraNumber(a, b, c):\n    if a == b:\n        return c\n    if a == c:\n        return b\n    return a",
    "detail": "_ALL_PY.Core 011 - extraNumber",
    "documentation": {}
  },
  {
    "label": "isInfiniteProcess",
    "kind": 2,
    "importPath": "_ALL_PY.Core 012 - isInfiniteProcess",
    "description": "_ALL_PY.Core 012 - isInfiniteProcess",
    "peekOfCode": "def isInfiniteProcess(a, b):\n    return a > b or (a % 2 != b % 2)",
    "detail": "_ALL_PY.Core 012 - isInfiniteProcess",
    "documentation": {}
  },
  {
    "label": "arithmeticExpression",
    "kind": 2,
    "importPath": "_ALL_PY.Core 013 - arithmeticExpression",
    "description": "_ALL_PY.Core 013 - arithmeticExpression",
    "peekOfCode": "def arithmeticExpression(a, b, c):\n    return a + b == c or a - b == c or a * b == c or a / b == c",
    "detail": "_ALL_PY.Core 013 - arithmeticExpression",
    "documentation": {}
  },
  {
    "label": "tennisSet",
    "kind": 2,
    "importPath": "_ALL_PY.Core 014 - tennisSet",
    "description": "_ALL_PY.Core 014 - tennisSet",
    "peekOfCode": "def tennisSet(score1, score2):\n    if max(score1, score2) == 6 and min(score1, score2) < 5:\n        return True\n    if 5 <= min(score1, score2) <= 6 and max(score1, score2) == 7:\n        return True\n    return False",
    "detail": "_ALL_PY.Core 014 - tennisSet",
    "documentation": {}
  },
  {
    "label": "willYou",
    "kind": 2,
    "importPath": "_ALL_PY.Core 015 - willYou",
    "description": "_ALL_PY.Core 015 - willYou",
    "peekOfCode": "def willYou(young, beautiful, loved):\n    return (young and beautiful) != loved",
    "detail": "_ALL_PY.Core 015 - willYou",
    "documentation": {}
  },
  {
    "label": "metroCard",
    "kind": 2,
    "importPath": "_ALL_PY.Core 016 - metroCard",
    "description": "_ALL_PY.Core 016 - metroCard",
    "peekOfCode": "def metroCard(lastNumberOfDays):\n    if lastNumberOfDays == 30 or lastNumberOfDays == 28:\n        return [31]\n    return [28, 30, 31]",
    "detail": "_ALL_PY.Core 016 - metroCard",
    "documentation": {}
  },
  {
    "label": "killKthBit",
    "kind": 2,
    "importPath": "_ALL_PY.Core 017 - killKthBit",
    "description": "_ALL_PY.Core 017 - killKthBit",
    "peekOfCode": "def killKthBit(n, k):\n    return n & ~(2 ** (k - 1))",
    "detail": "_ALL_PY.Core 017 - killKthBit",
    "documentation": {}
  },
  {
    "label": "arrayPacking",
    "kind": 2,
    "importPath": "_ALL_PY.Core 018 - arrayPacking",
    "description": "_ALL_PY.Core 018 - arrayPacking",
    "peekOfCode": "def arrayPacking(a):\n    binary_array = [bin(num)[2:].rjust(8, '0') for num in a]\n    out_string = ''.join(binary_array[::-1])\n    return int(out_string, 2)",
    "detail": "_ALL_PY.Core 018 - arrayPacking",
    "documentation": {}
  },
  {
    "label": "rangeBitCount",
    "kind": 2,
    "importPath": "_ALL_PY.Core 019 - rangeBitCount",
    "description": "_ALL_PY.Core 019 - rangeBitCount",
    "peekOfCode": "def rangeBitCount(a, b):\n    array = list(range(a, b + 1))\n    binary_array = [bin(num) for num in array]\n    count_array = [binary.count('1') for binary in binary_array]\n    return sum(count_array)",
    "detail": "_ALL_PY.Core 019 - rangeBitCount",
    "documentation": {}
  },
  {
    "label": "mirrorBits",
    "kind": 2,
    "importPath": "_ALL_PY.Core 020 - mirrorBits",
    "description": "_ALL_PY.Core 020 - mirrorBits",
    "peekOfCode": "def mirrorBits(a):\n    binary = bin(a)[2:]\n    return int(binary[::-1], 2)",
    "detail": "_ALL_PY.Core 020 - mirrorBits",
    "documentation": {}
  },
  {
    "label": "secondRightmostZeroBit",
    "kind": 2,
    "importPath": "_ALL_PY.Core 021 - secondRightmostZeroBit",
    "description": "_ALL_PY.Core 021 - secondRightmostZeroBit",
    "peekOfCode": "def secondRightmostZeroBit(n):\n    return 2 ** bin(n)[::-1].find('0', bin(n)[::-1].find('0') + 1)",
    "detail": "_ALL_PY.Core 021 - secondRightmostZeroBit",
    "documentation": {}
  },
  {
    "label": "swapAdjacentBits",
    "kind": 2,
    "importPath": "_ALL_PY.Core 022 - swapAdjacentBits",
    "description": "_ALL_PY.Core 022 - swapAdjacentBits",
    "peekOfCode": "def swapAdjacentBits(n):\n    return ((n >> 1) & 1431655765) | ((n << 1) & 2863311530)",
    "detail": "_ALL_PY.Core 022 - swapAdjacentBits",
    "documentation": {}
  },
  {
    "label": "differentRightmostBit",
    "kind": 2,
    "importPath": "_ALL_PY.Core 023 - differentRightmostBit",
    "description": "_ALL_PY.Core 023 - differentRightmostBit",
    "peekOfCode": "def differentRightmostBit(n, m):\n    return 2 ** bin((n ^ m))[::-1].find('1')",
    "detail": "_ALL_PY.Core 023 - differentRightmostBit",
    "documentation": {}
  },
  {
    "label": "equalPairOfBits",
    "kind": 2,
    "importPath": "_ALL_PY.Core 024 - equalPairOfBits",
    "description": "_ALL_PY.Core 024 - equalPairOfBits",
    "peekOfCode": "def equalPairOfBits(n, m):\n    return 2 ** bin(~(n ^ m))[::-1].find('1')",
    "detail": "_ALL_PY.Core 024 - equalPairOfBits",
    "documentation": {}
  },
  {
    "label": "leastFactorial",
    "kind": 2,
    "importPath": "_ALL_PY.Core 025 - leastFactorial",
    "description": "_ALL_PY.Core 025 - leastFactorial",
    "peekOfCode": "def leastFactorial(n):\n    factorial = 1\n    index = 1\n    while factorial < n:\n        index += 1\n        factorial *= index\n    return factorial",
    "detail": "_ALL_PY.Core 025 - leastFactorial",
    "documentation": {}
  },
  {
    "label": "countSumOfTwoRepresentations2",
    "kind": 2,
    "importPath": "_ALL_PY.Core 026 - countSumOfTwoRepresentations2",
    "description": "_ALL_PY.Core 026 - countSumOfTwoRepresentations2",
    "peekOfCode": "def countSumOfTwoRepresentations2(n, l, r):\n    count = 0\n    a = max(n - r, l)\n    b = n - a\n    while a <= r and a <= b:\n        count += 1\n        a += 1\n        b -= 1\n    return count",
    "detail": "_ALL_PY.Core 026 - countSumOfTwoRepresentations2",
    "documentation": {}
  },
  {
    "label": "magicalWell",
    "kind": 2,
    "importPath": "_ALL_PY.Core 027 - magicalWell",
    "description": "_ALL_PY.Core 027 - magicalWell",
    "peekOfCode": "def magicalWell(a, b, n):\n    total = 0\n    for i in range(n):\n        total += a * b\n        a += 1\n        b += 1\n    return total",
    "detail": "_ALL_PY.Core 027 - magicalWell",
    "documentation": {}
  },
  {
    "label": "lineUp",
    "kind": 2,
    "importPath": "_ALL_PY.Core 028 - lineUp",
    "description": "_ALL_PY.Core 028 - lineUp",
    "peekOfCode": "def lineUp(commands):\n    count = 0\n    smart_student = 0\n    dumb_student = 0\n    for command in commands:\n        if command == 'L':\n            smart_student = (smart_student - 1) % 4\n            dumb_student = (dumb_student + 1) % 4\n        elif command == 'R':\n            smart_student = (smart_student + 1) % 4",
    "detail": "_ALL_PY.Core 028 - lineUp",
    "documentation": {}
  },
  {
    "label": "additionWithoutCarrying",
    "kind": 2,
    "importPath": "_ALL_PY.Core 029 - additionWithoutCarrying",
    "description": "_ALL_PY.Core 029 - additionWithoutCarrying",
    "peekOfCode": "def additionWithoutCarrying(param1, param2):\n    # Convert numbers to strings\n    str1 = str(param1)\n    str2 = str(param2)\n    # Pad both to the same length with zeroes (to the left of the numbers)\n    length = max(len(str2), len(str1))\n    str1 = str1.rjust(length, '0')\n    str2 = str2.rjust(length, '0')\n    output = []\n    for num1, num2 in zip(str1, str2):",
    "detail": "_ALL_PY.Core 029 - additionWithoutCarrying",
    "documentation": {}
  },
  {
    "label": "appleBoxes",
    "kind": 2,
    "importPath": "_ALL_PY.Core 030 - appleBoxes",
    "description": "_ALL_PY.Core 030 - appleBoxes",
    "peekOfCode": "def appleBoxes(k):\n    red = 0\n    yellow = 0\n    for i in range(1, k + 1, 2):\n        yellow += i * i\n    for i in range(2, k + 1, 2):\n        red += i * i\n    return red - yellow",
    "detail": "_ALL_PY.Core 030 - appleBoxes",
    "documentation": {}
  },
  {
    "label": "increaseNumberRoundness",
    "kind": 2,
    "importPath": "_ALL_PY.Core 031 - increaseNumberRoundness",
    "description": "_ALL_PY.Core 031 - increaseNumberRoundness",
    "peekOfCode": "def increaseNumberRoundness(n):\n    string = str(n)\n    # Check for immediate rejection\n    if '0' not in string or len(string) < 2:\n        return False\n    # Since we know there's a 0, if it's not on\n    # the left, then we know to accept\n    if string[-1] != '0':\n        return True\n    # If there is only one 0, it must be at the end, so reject.",
    "detail": "_ALL_PY.Core 031 - increaseNumberRoundness",
    "documentation": {}
  },
  {
    "label": "rounders",
    "kind": 2,
    "importPath": "_ALL_PY.Core 032 - rounders",
    "description": "_ALL_PY.Core 032 - rounders",
    "peekOfCode": "def rounders(value):\n    length = len(str(value))\n    magnitude = length - 1\n    for i in range(length - 1):\n        value = int((value / 10) + 0.5)\n    return value * (10 ** magnitude)",
    "detail": "_ALL_PY.Core 032 - rounders",
    "documentation": {}
  },
  {
    "label": "candles",
    "kind": 2,
    "importPath": "_ALL_PY.Core 033 - candles",
    "description": "_ALL_PY.Core 033 - candles",
    "peekOfCode": "def candles(candlesNumber, makeNew):\n    totalBurned = 0\n    leftovers = 0\n    while candlesNumber > 0:\n        totalBurned += candlesNumber\n        leftovers += candlesNumber\n        candlesNumber = 0\n        candlesNumber = leftovers // makeNew\n        leftovers = leftovers % makeNew\n    return totalBurned",
    "detail": "_ALL_PY.Core 033 - candles",
    "documentation": {}
  },
  {
    "label": "countBlackCells",
    "kind": 2,
    "importPath": "_ALL_PY.Core 034 - countBlackCells",
    "description": "_ALL_PY.Core 034 - countBlackCells",
    "peekOfCode": "def countBlackCells(n, m):\n    gcd = find_gcd(n, m)\n    line_cells = n + m - gcd\n    line_corner_cells = (gcd - 1) * 2\n    return line_cells + line_corner_cells\ndef find_gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a",
    "detail": "_ALL_PY.Core 034 - countBlackCells",
    "documentation": {}
  },
  {
    "label": "find_gcd",
    "kind": 2,
    "importPath": "_ALL_PY.Core 034 - countBlackCells",
    "description": "_ALL_PY.Core 034 - countBlackCells",
    "peekOfCode": "def find_gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a",
    "detail": "_ALL_PY.Core 034 - countBlackCells",
    "documentation": {}
  },
  {
    "label": "createArray",
    "kind": 2,
    "importPath": "_ALL_PY.Core 035 - createArray",
    "description": "_ALL_PY.Core 035 - createArray",
    "peekOfCode": "def createArray(size):\n    return [1] * size",
    "detail": "_ALL_PY.Core 035 - createArray",
    "documentation": {}
  },
  {
    "label": "arrayReplace",
    "kind": 2,
    "importPath": "_ALL_PY.Core 036 - arrayReplace",
    "description": "_ALL_PY.Core 036 - arrayReplace",
    "peekOfCode": "def arrayReplace(inputArray, elemToReplace, substitutionElem):\n    output = [elem if elem != elemToReplace else substitutionElem for elem in inputArray]\n    return output",
    "detail": "_ALL_PY.Core 036 - arrayReplace",
    "documentation": {}
  },
  {
    "label": "firstReverseTry",
    "kind": 2,
    "importPath": "_ALL_PY.Core 037 - firstReverseTry",
    "description": "_ALL_PY.Core 037 - firstReverseTry",
    "peekOfCode": "def firstReverseTry(arr):\n    if len(arr) < 2:\n        return arr\n    if len(arr) < 4:\n        return arr[::-1]\n    return arr[-1:] + arr[1:-1] + arr[:1]",
    "detail": "_ALL_PY.Core 037 - firstReverseTry",
    "documentation": {}
  },
  {
    "label": "concatenateArrays",
    "kind": 2,
    "importPath": "_ALL_PY.Core 038 - concatenateArrays",
    "description": "_ALL_PY.Core 038 - concatenateArrays",
    "peekOfCode": "def concatenateArrays(a, b):\n    return a + b",
    "detail": "_ALL_PY.Core 038 - concatenateArrays",
    "documentation": {}
  },
  {
    "label": "removeArrayPart",
    "kind": 2,
    "importPath": "_ALL_PY.Core 039 - removeArrayPart",
    "description": "_ALL_PY.Core 039 - removeArrayPart",
    "peekOfCode": "def removeArrayPart(inputArray, l, r):\n    return inputArray[:l] + inputArray[r + 1:]",
    "detail": "_ALL_PY.Core 039 - removeArrayPart",
    "documentation": {}
  },
  {
    "label": "isSmooth",
    "kind": 2,
    "importPath": "_ALL_PY.Core 040 - isSmooth",
    "description": "_ALL_PY.Core 040 - isSmooth",
    "peekOfCode": "def isSmooth(arr):\n    if arr[0] != arr[-1]:\n        return False\n    if len(arr) % 2 == 0:\n        middle = arr[len(arr) // 2] + arr[(len(arr) // 2) - 1]\n    else:\n        middle = arr[len(arr) // 2]\n    return arr[0] == middle",
    "detail": "_ALL_PY.Core 040 - isSmooth",
    "documentation": {}
  },
  {
    "label": "replaceMiddle",
    "kind": 2,
    "importPath": "_ALL_PY.Core 041 - replaceMiddle",
    "description": "_ALL_PY.Core 041 - replaceMiddle",
    "peekOfCode": "def replaceMiddle(arr):\n    if len(arr) % 2 != 0:\n        return arr\n    right_middle = len(arr) // 2\n    middle_value = arr[right_middle] + arr[right_middle - 1]\n    return arr[:right_middle - 1] + [middle_value] + arr[right_middle + 1:]",
    "detail": "_ALL_PY.Core 041 - replaceMiddle",
    "documentation": {}
  },
  {
    "label": "makeArrayConsecutive2",
    "kind": 2,
    "importPath": "_ALL_PY.Core 042 - makeArrayConsecutive2",
    "description": "_ALL_PY.Core 042 - makeArrayConsecutive2",
    "peekOfCode": "def makeArrayConsecutive2(statues):\n    count = 0\n    for i in range(min(statues), max(statues)):\n        if i not in statues:\n            count += 1\n    return count",
    "detail": "_ALL_PY.Core 042 - makeArrayConsecutive2",
    "documentation": {}
  },
  {
    "label": "isPower",
    "kind": 2,
    "importPath": "_ALL_PY.Core 043 - isPower",
    "description": "_ALL_PY.Core 043 - isPower",
    "peekOfCode": "def isPower(n):\n    if n == 1:\n        return True\n    a = 2\n    b = 2\n    while a ** 2 <= n:\n        while a ** b <= n:\n            if a ** b == n:\n                return True\n            b += 1",
    "detail": "_ALL_PY.Core 043 - isPower",
    "documentation": {}
  },
  {
    "label": "isSumOfConsecutive2",
    "kind": 2,
    "importPath": "_ALL_PY.Core 044 - isSumOfConsecutive2",
    "description": "_ALL_PY.Core 044 - isSumOfConsecutive2",
    "peekOfCode": "def isSumOfConsecutive2(n):\n    count = 0\n    right = 2\n    arr = [1, 2]\n    while right <= (n // 2) + 1:\n        total = sum(arr)\n        if total == n:\n            count += 1\n            del arr[0]\n        elif total < n:",
    "detail": "_ALL_PY.Core 044 - isSumOfConsecutive2",
    "documentation": {}
  },
  {
    "label": "squareDigitsSequence",
    "kind": 2,
    "importPath": "_ALL_PY.Core 045 - squareDigitsSequence",
    "description": "_ALL_PY.Core 045 - squareDigitsSequence",
    "peekOfCode": "def squareDigitsSequence(a0):\n    sequence = [a0]\n    while sequence[-1] not in sequence[:-1]:\n        next_value = 0\n        for digit in str(sequence[-1]):\n            next_value += int(digit) ** 2\n        sequence.append(next_value)\n    return len(sequence)",
    "detail": "_ALL_PY.Core 045 - squareDigitsSequence",
    "documentation": {}
  },
  {
    "label": "pagesNumberingWithInk",
    "kind": 2,
    "importPath": "_ALL_PY.Core 046 - pagesNumberingWithInk",
    "description": "_ALL_PY.Core 046 - pagesNumberingWithInk",
    "peekOfCode": "def pagesNumberingWithInk(current, numberOfDigits):\n    numberOfDigits -= len(str(current))\n    next_digits = len(str(current + 1))\n    while numberOfDigits >= next_digits:\n        current += 1\n        numberOfDigits -= next_digits\n        next_digits = len(str(current))\n    return current",
    "detail": "_ALL_PY.Core 046 - pagesNumberingWithInk",
    "documentation": {}
  },
  {
    "label": "comfortableNumbers",
    "kind": 2,
    "importPath": "_ALL_PY.Core 047 - comfortableNumbers",
    "description": "_ALL_PY.Core 047 - comfortableNumbers",
    "peekOfCode": "def comfortableNumbers(l, r):\n    count = 0\n    for a in range(l, r):\n        for b in range(a + 1, r + 1):\n            a_sum = sum(int(digit) for digit in str(a))\n            b_sum = sum(int(digit) for digit in str(b))\n            if b <= a + a_sum and a >= b - b_sum:\n                count += 1\n    return count",
    "detail": "_ALL_PY.Core 047 - comfortableNumbers",
    "documentation": {}
  },
  {
    "label": "weakNumbers",
    "kind": 2,
    "importPath": "_ALL_PY.Core 048 - weakNumbers",
    "description": "_ALL_PY.Core 048 - weakNumbers",
    "peekOfCode": "def weakNumbers(n):\n    all_factors = [count_factors(num) for num in range(1, n+1)]\n    weaknesses = []\n    for num, num_factors in enumerate(all_factors, 1):\n        weakness = 0\n        for factor in all_factors[:num]:\n            if factor > num_factors:\n                weakness += 1\n        weaknesses.append(weakness)\n    weakest = max(weaknesses)",
    "detail": "_ALL_PY.Core 048 - weakNumbers",
    "documentation": {}
  },
  {
    "label": "count_factors",
    "kind": 2,
    "importPath": "_ALL_PY.Core 048 - weakNumbers",
    "description": "_ALL_PY.Core 048 - weakNumbers",
    "peekOfCode": "def count_factors(n):\n    factors = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            factors += 1\n    return factors\nprint(weakNumbers(500))",
    "detail": "_ALL_PY.Core 048 - weakNumbers",
    "documentation": {}
  },
  {
    "label": "rectangleRotation",
    "kind": 2,
    "importPath": "_ALL_PY.Core 049 - rectangleRotation",
    "description": "_ALL_PY.Core 049 - rectangleRotation",
    "peekOfCode": "def rectangleRotation(a, b):\n    n = a / (2 ** 0.5)\n    m = b / (2 ** 0.5)\n    points = (math.floor(n) * math.floor(m)) + (math.ceil(n) * math.ceil(m))\n    if math.floor(n) % 2 != math.floor(m) % 2:\n        points -= 1\n    return points\n# rectangleRotation(6, 4)\nprint(rectangleRotation(8,6))",
    "detail": "_ALL_PY.Core 049 - rectangleRotation",
    "documentation": {}
  },
  {
    "label": "crosswordFormation",
    "kind": 2,
    "importPath": "_ALL_PY.crossword_creator",
    "description": "_ALL_PY.crossword_creator",
    "peekOfCode": "def crosswordFormation(words):\n    possible_crosswords = 0\n    # check case where all the words are the same or have one letter repeated\n    # setup a map charting the word to each letter to a list of the indices of the letters\n    word_map = defaultdict(lambda: defaultdict(list))\n    for word in words:\n        for i in range(len(word)):\n            word_map[word][word[i]].append(i)\n    seen = set()\n    # first, use nested loops to get all combinations of the words (4! = 24)",
    "detail": "_ALL_PY.crossword_creator",
    "documentation": {}
  },
  {
    "label": "isRotated",
    "kind": 2,
    "importPath": "_ALL_PY.crossword_creator",
    "description": "_ALL_PY.crossword_creator",
    "peekOfCode": "def isRotated(a, b):\n    a = list(a)\n    b = list(b)\n    if a[0] == b[1] and a[1] == b[0] and a[2] == b[3] and a[3] == b[2]:\n        return True\n    return False\nwords = [\"aaaaaaaaaaaaaa\", \"aaaaaaaaaaaaab\", \"aaaaaaaaaaaaca\", \"aaaaaaaaaaadaa\"]\nstart = time.clock()\nprint(crosswordFormation(words))\nprint(time.clock() - start)",
    "detail": "_ALL_PY.crossword_creator",
    "documentation": {}
  },
  {
    "label": "words",
    "kind": 5,
    "importPath": "_ALL_PY.crossword_creator",
    "description": "_ALL_PY.crossword_creator",
    "peekOfCode": "words = [\"aaaaaaaaaaaaaa\", \"aaaaaaaaaaaaab\", \"aaaaaaaaaaaaca\", \"aaaaaaaaaaadaa\"]\nstart = time.clock()\nprint(crosswordFormation(words))\nprint(time.clock() - start)",
    "detail": "_ALL_PY.crossword_creator",
    "documentation": {}
  },
  {
    "label": "start",
    "kind": 5,
    "importPath": "_ALL_PY.crossword_creator",
    "description": "_ALL_PY.crossword_creator",
    "peekOfCode": "start = time.clock()\nprint(crosswordFormation(words))\nprint(time.clock() - start)",
    "detail": "_ALL_PY.crossword_creator",
    "documentation": {}
  },
  {
    "label": "cubeVolume",
    "kind": 5,
    "importPath": "_ALL_PY.cubeVolume",
    "description": "_ALL_PY.cubeVolume",
    "peekOfCode": "cubeVolume = lambda n: n ** 3",
    "detail": "_ALL_PY.cubeVolume",
    "documentation": {}
  },
  {
    "label": "digitDegree",
    "kind": 2,
    "importPath": "_ALL_PY.Degree",
    "description": "_ALL_PY.Degree",
    "peekOfCode": "def digitDegree(n):\n    degree = 0\n    while 10 <= n:\n        num = str(n)\n        n = sum(int(i) for i in num)\n        degree += 1\n    return degree",
    "detail": "_ALL_PY.Degree",
    "documentation": {}
  },
  {
    "label": "deleteDigit",
    "kind": 2,
    "importPath": "_ALL_PY.delete_digit",
    "description": "_ALL_PY.delete_digit",
    "peekOfCode": "def deleteDigit(n):\n    digits = str(n)\n    values = []\n    for i in range(len(digits)):\n        value = int(digits[:i] + digits[(i + 1) :])\n        values.append(int(value))\n    return max(values)",
    "detail": "_ALL_PY.delete_digit",
    "documentation": {}
  },
  {
    "label": "depositProfit",
    "kind": 2,
    "importPath": "_ALL_PY.depositProfit",
    "description": "_ALL_PY.depositProfit",
    "peekOfCode": "def depositProfit(deposit, rate, threshold):\n    i = 0\n    while deposit < threshold:\n        deposit += deposit * rate * .01\n        i+=1\n    return i",
    "detail": "_ALL_PY.depositProfit",
    "documentation": {}
  },
  {
    "label": "depositProfit",
    "kind": 2,
    "importPath": "_ALL_PY.deposit_profit",
    "description": "_ALL_PY.deposit_profit",
    "peekOfCode": "def depositProfit(deposit, rate, threshold):\n    years = 0\n    while deposit < threshold:\n        deposit += deposit * (rate / 100)\n        years += 1\n    return years",
    "detail": "_ALL_PY.deposit_profit",
    "documentation": {}
  },
  {
    "label": "differentSquares",
    "kind": 2,
    "importPath": "_ALL_PY.different_squares",
    "description": "_ALL_PY.different_squares",
    "peekOfCode": "def differentSquares(matrix):\n\t\"\"\"\n\tReturn number of DIFFERENT 2 * 2 squares in rectangular matrix.\n    Time Complexity: O(N^2)\n    Space Complexity: O(N)\n\t\"\"\"\n    squares = set()\n    for i in range(len(matrix) - 1):\n        for j in range(len(matrix[i]) - 1):\n            squares.add((matrix[i][j], matrix[i][j + 1], matrix[i + 1][j], matrix[i + 1][j + 1]))",
    "detail": "_ALL_PY.different_squares",
    "documentation": {}
  },
  {
    "label": "differentSymbolsNaive",
    "kind": 2,
    "importPath": "_ALL_PY.different_symbols_is_naive",
    "description": "_ALL_PY.different_symbols_is_naive",
    "peekOfCode": "def differentSymbolsNaive(s):\n    return len(set(s))",
    "detail": "_ALL_PY.different_symbols_is_naive",
    "documentation": {}
  },
  {
    "label": "deleteDigit",
    "kind": 2,
    "importPath": "_ALL_PY.Digit",
    "description": "_ALL_PY.Digit",
    "peekOfCode": "def deleteDigit(n):\n    num = str(n)\n    result = list(int(\"\".join(num[:i] + num[1 + i :])) for i in range(len(num)))\n    return max(result)",
    "detail": "_ALL_PY.Digit",
    "documentation": {}
  },
  {
    "label": "digitRootSort",
    "kind": 2,
    "importPath": "_ALL_PY.digitRootSort",
    "description": "_ALL_PY.digitRootSort",
    "peekOfCode": "def digitRootSort(a):\n    a.sort()\n    a = map(str, a)\n    separados = []\n    for numeros in a:\n        separados.append(list(numeros))\n    totales = []\n    for i in range(len(separados)):\n        sumaElementos = 0\n        for x in range(len(separados[i])):",
    "detail": "_ALL_PY.digitRootSort",
    "documentation": {}
  },
  {
    "label": "main",
    "kind": 2,
    "importPath": "_ALL_PY.digitRootSort",
    "description": "_ALL_PY.digitRootSort",
    "peekOfCode": "def main():\n    lista = [13, 20, 7, 4]\n    digitRootSort(lista)\nif __name__ == '__main__':\n    main()",
    "detail": "_ALL_PY.digitRootSort",
    "documentation": {}
  },
  {
    "label": "evenDigitsOnly",
    "kind": 2,
    "importPath": "_ALL_PY.DigitsOnly",
    "description": "_ALL_PY.DigitsOnly",
    "peekOfCode": "def evenDigitsOnly(n):\n    digits_of_n = []\n    while n > 0:\n        rem = n % 10\n        digits_of_n.append(rem)\n        n = int(n / 10)\n    for i in range(len(digits_of_n)):\n        if digits_of_n[i] % 2 != 0:\n            return False\n    return True",
    "detail": "_ALL_PY.DigitsOnly",
    "documentation": {}
  },
  {
    "label": "longestDigitsPrefix",
    "kind": 2,
    "importPath": "_ALL_PY.DigitsPrefix",
    "description": "_ALL_PY.DigitsPrefix",
    "peekOfCode": "def longestDigitsPrefix(inputString):\n    count = 0\n    for i in range(len(inputString)):\n        if inputString[i].isdigit():\n            count += 1\n        else:\n            return inputString[0:count]\n    return inputString",
    "detail": "_ALL_PY.DigitsPrefix",
    "documentation": {}
  },
  {
    "label": "digitsProduct",
    "kind": 2,
    "importPath": "_ALL_PY.digits_product",
    "description": "_ALL_PY.digits_product",
    "peekOfCode": "def digitsProduct(product):\n    \"\"\"\n    Given an integer product, find the smallest \n    positive (i.e. greater than 0) integer the \n    product of whose digits is equal to product. \n    If there is no such integer, return -1 instead.\n    Time Complexity: O(inf)\n    Space Complexity: O(1)\n    \"\"\"\n    number = 1",
    "detail": "_ALL_PY.digits_product",
    "documentation": {}
  },
  {
    "label": "digitDegree",
    "kind": 2,
    "importPath": "_ALL_PY.digit_degree",
    "description": "_ALL_PY.digit_degree",
    "peekOfCode": "def digitDegree(n):\n    number, degree = str(n), 0\n    while len(number) != 1:\n        number = str(sum([int(digit) for digit in number]))\n        degree += 1\n    return degree",
    "detail": "_ALL_PY.digit_degree",
    "documentation": {}
  },
  {
    "label": "extractEachKth",
    "kind": 2,
    "importPath": "_ALL_PY.EachKth",
    "description": "_ALL_PY.EachKth",
    "peekOfCode": "def extractEachKth(inputArray, k):\n    inp = []\n    for i in range(len(inputArray)):\n        if (i + 1) % k == 0:\n            pass\n        else:\n            inp.append(inputArray[i])\n    return inp",
    "detail": "_ALL_PY.EachKth",
    "documentation": {}
  },
  {
    "label": "electionsWinners",
    "kind": 2,
    "importPath": "_ALL_PY.election_winners",
    "description": "_ALL_PY.election_winners",
    "peekOfCode": "def electionsWinners(votes, k):\n    \"\"\"Find number of candidates that have chance to win election\n    Args:\n        votes(int): List of number of votes given to each candidate so far.\n        k(int): Number of voters who haven't cast their vote yet.\n    Return:\n        Number of candidates that still have chance to win election\n    Raises:\n    \"\"\"\n    highest = max(votes)",
    "detail": "_ALL_PY.election_winners",
    "documentation": {}
  },
  {
    "label": "adjacentElementsProduct",
    "kind": 2,
    "importPath": "_ALL_PY.ElementsProduct",
    "description": "_ALL_PY.ElementsProduct",
    "peekOfCode": "def adjacentElementsProduct(inputArray):\n    # Step 1: Initially, define an empty array where we will store the products of adjacent elements from the input array.\n    ArrayEnd = []\n    # Step 2: Using a for-loop, we go over all entries of the input array, calculating the products of adjacent elements\n    # and appending them to the empty array from step 1.\n    for i in range(len(inputArray) - 1):\n        ArrayEnd.append(inputArray[i] * inputArray[i + 1])\n    # Step 3: We seek the largest entry in \"ArrayEnd\" from step 1, using the max() function.\n    maximum = max(ArrayEnd)\n    return maximum",
    "detail": "_ALL_PY.ElementsProduct",
    "documentation": {}
  },
  {
    "label": "matrixElementsSum",
    "kind": 2,
    "importPath": "_ALL_PY.ElementsSum",
    "description": "_ALL_PY.ElementsSum",
    "peekOfCode": "def matrixElementsSum(matrix):\n    # Step 1: We begin by defining the number of rows and columns inside our given matrix.\n    # You can conceive the number of rows as the number of nested arrays inside the main array and\n    # the number of columns as the number of elements in the first nested array.\n    # Feel free to convince yourself that this is the case by referring to the examples of matrices shown above.\n    rows = len(matrix)\n    cols = len(matrix[0])\n    # Step 2: Furthermore, create a new variable called \"summ\" (from summation) and set it equal to zero.\n    # It will be used in the following for-loop.\n    summ = 0",
    "detail": "_ALL_PY.ElementsSum",
    "documentation": {}
  },
  {
    "label": "matrix",
    "kind": 5,
    "importPath": "_ALL_PY.ElementsSum",
    "description": "_ALL_PY.ElementsSum",
    "peekOfCode": "matrix = [[0, 1, 1, 2],\n          [0, 5, 0, 0],\n          [2, 0, 3, 3]]\nthe output should be matrixElementsSum(matrix) = 9.\nexample 1: There are several haunted rooms, so we'll disregard them as well as any rooms beneath them.\nThus, the answer is 1 + 5 + 1 + 2 = 9. (PICTURE PROVIDED AT:WWW.CODESIGNAL.COM)\nFor\nmatrix = [[1, 1, 1, 0],\n          [0, 5, 0, 1],\n          [2, 1, 3, 10]]",
    "detail": "_ALL_PY.ElementsSum",
    "documentation": {}
  },
  {
    "label": "matrix",
    "kind": 5,
    "importPath": "_ALL_PY.ElementsSum",
    "description": "_ALL_PY.ElementsSum",
    "peekOfCode": "matrix = [[1, 1, 1, 0],\n          [0, 5, 0, 1],\n          [2, 1, 3, 10]]\nthe output should be matrixElementsSum(matrix) = 9.\nexample 2:\nNote that the free room in the final column makes the full column unsuitable for bots (not just the room directly beneath it).\nThus, the answer is 1 + 1 + 1 + 5 + 1 = 9. (PICTURE PROVIDED AT:WWW.CODESIGNAL.COM)\"\"\"\ndef matrixElementsSum(matrix):\n    # Step 1: We begin by defining the number of rows and columns inside our given matrix.\n    # You can conceive the number of rows as the number of nested arrays inside the main array and",
    "detail": "_ALL_PY.ElementsSum",
    "documentation": {}
  },
  {
    "label": "findEmailDomain",
    "kind": 2,
    "importPath": "_ALL_PY.EmailDomain",
    "description": "_ALL_PY.EmailDomain",
    "peekOfCode": "def findEmailDomain(address):\n    address_spl = address.split(\"@\")\n    c = [i for i in address_spl]\n    if len(address_spl) == 2:\n        return c[1]\n    if len(address_spl) == 3:\n        return c[2]",
    "detail": "_ALL_PY.EmailDomain",
    "documentation": {}
  },
  {
    "label": "decodeString",
    "kind": 2,
    "importPath": "_ALL_PY.encoded",
    "description": "_ALL_PY.encoded",
    "peekOfCode": "def decodeString(s):\n    return s[s.find(\"[\")+1:s.find(\"]\")]\ndef main():\n    s = \"z1[y]zzz2[abc]\"\n    #zyzzzabcabc\n    print(decodeString(s))\nif __name__ == '__main__':\n    main()",
    "detail": "_ALL_PY.encoded",
    "documentation": {}
  },
  {
    "label": "main",
    "kind": 2,
    "importPath": "_ALL_PY.encoded",
    "description": "_ALL_PY.encoded",
    "peekOfCode": "def main():\n    s = \"z1[y]zzz2[abc]\"\n    #zyzzzabcabc\n    print(decodeString(s))\nif __name__ == '__main__':\n    main()",
    "detail": "_ALL_PY.encoded",
    "documentation": {}
  },
  {
    "label": "lineEncoding",
    "kind": 2,
    "importPath": "_ALL_PY.Encoding",
    "description": "_ALL_PY.Encoding",
    "peekOfCode": "def lineEncoding(s):\n    s2 = \"\"\n    for k, g in groupby(s):\n        l = len(list(g))\n        if l == 1:\n            s2 += k\n        else:\n            s2 += str(l) + k\n    return s2",
    "detail": "_ALL_PY.Encoding",
    "documentation": {}
  },
  {
    "label": "areEquallyStrong",
    "kind": 2,
    "importPath": "_ALL_PY.EquallyStrong",
    "description": "_ALL_PY.EquallyStrong",
    "peekOfCode": "def areEquallyStrong(yourLeft, yourRight, friendsLeft, friendsRight):\n    personal_max = max(yourLeft, yourRight)\n    friend_max = max(friendsLeft, friendsRight)\n    sum1 = yourLeft + yourRight\n    sum2 = friendsLeft + friendsRight\n    if sum1 == sum2 and personal_max == friend_max:\n        return True\n    return False",
    "detail": "_ALL_PY.EquallyStrong",
    "documentation": {}
  },
  {
    "label": "evenDigitsOnly",
    "kind": 2,
    "importPath": "_ALL_PY.even_digits_only",
    "description": "_ALL_PY.even_digits_only",
    "peekOfCode": "def evenDigitsOnly(n):\n    digits = [int(digit) for digit in str(n)]  # Convert digits to list of strings\n    for digit in digits:\n        if digit % 2 == 1:\n            return False\n    return True",
    "detail": "_ALL_PY.even_digits_only",
    "documentation": {}
  },
  {
    "label": "productExceptSelf",
    "kind": 2,
    "importPath": "_ALL_PY.ExceptSelfProduct",
    "description": "_ALL_PY.ExceptSelfProduct",
    "peekOfCode": "def productExceptSelf(nums, m, first=True):\n    # uses divide and conquer approach from Khan academy!\n    # may need to upgrade with prime factorization\n    # and fast modular exponents using binary!\n    # make map of prime factors and their exponents (number of each factor)\n    # by breaking down individual array items\n    # remove individual values from map for each item in array (reduce number of each factor present in current item)\n    # convert exponent to binary and get modular exponents for each factor (see here: https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/fast-modular-exponentiation)\n    # finally, combine all different prime factors for the number and add to array\n    # reduce array by summing and final mod as shown",
    "detail": "_ALL_PY.ExceptSelfProduct",
    "documentation": {}
  },
  {
    "label": "arr",
    "kind": 5,
    "importPath": "_ALL_PY.ExceptSelfProduct",
    "description": "_ALL_PY.ExceptSelfProduct",
    "peekOfCode": "arr = pd.read_json(\"./test-16.json\").loc[\"nums\", \"input\"]\n# print(arr)\nprint(productExceptSelf(arr, 9999, first=True))\n# works for small cases, need to use divide and conquer according to Khan\n# causes overflow issues\n# #first, get the number of all nums multiplied\n# largest_num = 1\n# for num in nums:\n#     largest_num*=num\n# print(largest_num)",
    "detail": "_ALL_PY.ExceptSelfProduct",
    "documentation": {}
  },
  {
    "label": "main",
    "kind": 2,
    "importPath": "_ALL_PY.experimentando",
    "description": "_ALL_PY.experimentando",
    "peekOfCode": "def main():\n    for i in range(100, 0, -1):\n        print(i)\n    for x in range(1, 100, 3):\n        print(x)\n    pow()\nif __name__ == '__main__':\n    main()",
    "detail": "_ALL_PY.experimentando",
    "documentation": {}
  },
  {
    "label": "extractEachKth",
    "kind": 2,
    "importPath": "_ALL_PY.extract_each_kth",
    "description": "_ALL_PY.extract_each_kth",
    "peekOfCode": "def extractEachKth(inputArray, k):\n    \"\"\"Function to remove each kth element from list of integers\n    Args:\n        inputArray(int): List of integers\n        k(int): position of elements to remove from list\n    Return:\n        The list with kth elements removed\n    Raises:\n    \"\"\"\n    new_list = []",
    "detail": "_ALL_PY.extract_each_kth",
    "documentation": {}
  },
  {
    "label": "extraNumber",
    "kind": 2,
    "importPath": "_ALL_PY.extra_number",
    "description": "_ALL_PY.extra_number",
    "peekOfCode": "def extraNumber(a, b, c):\n    \"\"\"\n    You're given three integers, a, b and c. It is \n    guaranteed that two of these integers are equal \n    to each other. What is the value of the third integer?\n    \"\"\"\n    if a == b:\n        return c\n    elif a == c:\n        return b",
    "detail": "_ALL_PY.extra_number",
    "documentation": {}
  },
  {
    "label": "feedingTime",
    "kind": 2,
    "importPath": "_ALL_PY.feedingTime",
    "description": "_ALL_PY.feedingTime",
    "peekOfCode": "def feedingTime(classes):\n    class_graph = defaultdict(set)\n    animals = defaultdict(set)\n    neg_graph = defaultdict(set)\n    c_size = len(classes)\n    # fully connected graph\n    for i in range(c_size):\n        for j in range(c_size):\n            if not i == j:\n                class_graph[i].add(j)",
    "detail": "_ALL_PY.feedingTime",
    "documentation": {}
  },
  {
    "label": "graph_search",
    "kind": 2,
    "importPath": "_ALL_PY.feedingTime",
    "description": "_ALL_PY.feedingTime",
    "peekOfCode": "def graph_search(vals, class_graph, neg_graph):\n    seen = set()\n    islands = []\n    for i in vals:\n        if i not in seen:\n            queue = [i]\n            seen.add(i)\n            route = set()\n            route.add(i)\n            found_val = False",
    "detail": "_ALL_PY.feedingTime",
    "documentation": {}
  },
  {
    "label": "sort_last",
    "kind": 2,
    "importPath": "_ALL_PY.feedingTime",
    "description": "_ALL_PY.feedingTime",
    "peekOfCode": "def sort_last(tup):\n    return tup[1]",
    "detail": "_ALL_PY.feedingTime",
    "documentation": {}
  },
  {
    "label": "fileNaming",
    "kind": 2,
    "importPath": "_ALL_PY.file_naming",
    "description": "_ALL_PY.file_naming",
    "peekOfCode": "def fileNaming(names):\n    \"\"\"\n    Since two files cannot have equal names, \n    the one which comes later will have an addition \n    to its name in a form of (k), where k is the smallest \n    positive integer such that the obtained name is not \n    used yet. Return an array of names that will be given \n    to the files.\n    \"\"\"\n    new_file_names = []",
    "detail": "_ALL_PY.file_naming",
    "documentation": {}
  },
  {
    "label": "findTheRemainder",
    "kind": 2,
    "importPath": "_ALL_PY.findTheRemainder",
    "description": "_ALL_PY.findTheRemainder",
    "peekOfCode": "def findTheRemainder(a, b):\n    return a % b",
    "detail": "_ALL_PY.findTheRemainder",
    "documentation": {}
  },
  {
    "label": "findEmailDomain",
    "kind": 2,
    "importPath": "_ALL_PY.find_email_domain",
    "description": "_ALL_PY.find_email_domain",
    "peekOfCode": "def findEmailDomain(address):\n    return address.split(\"@\")[-1]",
    "detail": "_ALL_PY.find_email_domain",
    "documentation": {}
  },
  {
    "label": "firstDigit",
    "kind": 2,
    "importPath": "_ALL_PY.first_digit",
    "description": "_ALL_PY.first_digit",
    "peekOfCode": "def firstDigit(inputString):\n    \"\"\"Finds leftmost digit that occurs in a given string\n    Args:\n        inputString(string): input string\n    Return:\n        Leftmost digit occurring in string\n    Raises:\n    \"\"\"\n    for char in inputString:\n        if char.isdigit():",
    "detail": "_ALL_PY.first_digit",
    "documentation": {}
  },
  {
    "label": "firstDuplicate",
    "kind": 2,
    "importPath": "_ALL_PY.first_duplicate",
    "description": "_ALL_PY.first_duplicate",
    "peekOfCode": "def firstDuplicate(a):\n    number_frequencies, number_indices, duplicate_index = {}, {}, {}\n    # Iterate through list and increment frequency count\n    # if number not in dict. Also, note the index asscoiated\n    # with the value\n    for i in range(len(a)):\n        if a[i] not in number_frequencies:\n            number_frequencies[a[i]] = 1\n            number_indices[a[i]] = i\n        elif a[i] in number_frequencies:",
    "detail": "_ALL_PY.first_duplicate",
    "documentation": {}
  },
  {
    "label": "firstNotRepeatingCharacter",
    "kind": 2,
    "importPath": "_ALL_PY.first_not_repeating_character",
    "description": "_ALL_PY.first_not_repeating_character",
    "peekOfCode": "def firstNotRepeatingCharacter(s):\n    character_count, character_index, non_repeat_index = {}, {}, {}\n    # Iterate through string and count\n    # character occurences and note\n    # index of first repetition\n    for i in range(len(s)):\n        if s[i] not in character_count:\n            character_count[s[i]] = 1\n            character_index[s[i]] = i\n        elif s[i] in character_count:",
    "detail": "_ALL_PY.first_not_repeating_character",
    "documentation": {}
  },
  {
    "label": "water_collected",
    "kind": 2,
    "importPath": "_ALL_PY.flooded",
    "description": "_ALL_PY.flooded",
    "peekOfCode": "def water_collected(heights):\n    water_collected = 0\n    left_height = []\n    right_height = []\n    temp_max = heights[0]\n    for height in heights:\n        if (height > temp_max):\n            temp_max = height\n        left_height.append(temp_max)\n    temp_max = heights[-1]",
    "detail": "_ALL_PY.flooded",
    "documentation": {}
  },
  {
    "label": "main",
    "kind": 2,
    "importPath": "_ALL_PY.flooded",
    "description": "_ALL_PY.flooded",
    "peekOfCode": "def main():\n    numberOfTowers = input()\n    sequenceHeights = input()\n    maxVume(numberOfTowers, sequenceHeights)\nif __name__ == '__main__':\n    main()",
    "detail": "_ALL_PY.flooded",
    "documentation": {}
  },
  {
    "label": "areFollowingPatterns",
    "kind": 2,
    "importPath": "_ALL_PY.followingPatterns",
    "description": "_ALL_PY.followingPatterns",
    "peekOfCode": "def areFollowingPatterns(strings, patterns):\n    pattern_to_string = {}\n    string_to_pattern = {}\n    for i in range(len(patterns)):\n        # first, check condition that strings are equal for patterns[i]=patterns[j]\n        this_pattern = patterns[i]\n        if patterns[i] in pattern_to_string:\n            if strings[i] != pattern_to_string[this_pattern]:\n                return False\n        else:",
    "detail": "_ALL_PY.followingPatterns",
    "documentation": {}
  },
  {
    "label": "r",
    "kind": 5,
    "importPath": "_ALL_PY.fractionComparison",
    "description": "_ALL_PY.fractionComparison",
    "peekOfCode": "r = (a * d) / (b * c)\nreturn \"<\" if r < 1 else \">\" if r > 1 else \"=\"\n# 72 chars",
    "detail": "_ALL_PY.fractionComparison",
    "documentation": {}
  },
  {
    "label": "f,",
    "kind": 5,
    "importPath": "_ALL_PY.fractionReducing",
    "description": "_ALL_PY.fractionReducing",
    "peekOfCode": "f, = eval(dir()[0])\nreturn [i / math.gcd(f[0], f[1]) for i in f]",
    "detail": "_ALL_PY.fractionReducing",
    "documentation": {}
  },
  {
    "label": "messageFromBinaryCode",
    "kind": 2,
    "importPath": "_ALL_PY.FromBinaryCode",
    "description": "_ALL_PY.FromBinaryCode",
    "peekOfCode": "def messageFromBinaryCode(code):\n    phrase = \"\"\n    bits = [int(code[i * 8 : i * 8 + 8], 2) for i in range(len(code) // 8)]\n    for j in range(len(bits)):\n        phrase += chr(bits[j])\n    return phrase",
    "detail": "_ALL_PY.FromBinaryCode",
    "documentation": {}
  },
  {
    "label": "centuryFromYear",
    "kind": 2,
    "importPath": "_ALL_PY.FromYear",
    "description": "_ALL_PY.FromYear",
    "peekOfCode": "def centuryFromYear(year):\n    # We begin by getting the INTEGER quotient of the division of the year given by 100.\n    # This will give us the first two digits, which would be the century.\n    cen = int(year / 100)\n    # However, we should keep in mind that we refer to years between e.g. 1701 - 1800\n    # as the \"18th century\". Hence, we implement a while loop, where the condition is\n    # that the year is a positive integer (which is always true). If the remainder of the\n    # division of the year by 100 is 0, then the two first digits of the division represent\n    # the century. Otherwise, if the remainder is non-zero, the century is found by adding 1\n    # to the result of the division (i.e. \"cen\").",
    "detail": "_ALL_PY.FromYear",
    "documentation": {}
  },
  {
    "label": "gasPrediction",
    "kind": 5,
    "importPath": "_ALL_PY.gasPrediction",
    "description": "_ALL_PY.gasPrediction",
    "peekOfCode": "gasPrediction = lambda d, c, a: sum(d) / 12 / a > c",
    "detail": "_ALL_PY.gasPrediction",
    "documentation": {}
  },
  {
    "label": "greetPerson",
    "kind": 5,
    "importPath": "_ALL_PY.greetPerson",
    "description": "_ALL_PY.greetPerson",
    "peekOfCode": "greetPerson = \"Hello, {}\".format",
    "detail": "_ALL_PY.greetPerson",
    "documentation": {}
  },
  {
    "label": "groupAnagrams",
    "kind": 2,
    "importPath": "_ALL_PY.group_anagrams",
    "description": "_ALL_PY.group_anagrams",
    "peekOfCode": "def groupAnagrams(strs):\n    # \"\"\"\n    # TimeComplexity: O(n*K*log(K)) where n is the length of strs and K is the length of the longest string\n    #  in strs\n    # \"\"\"\n    # seen = {}\n    # for s in strs:\n    #     ele = tuple((sorted(s)))\n    #     if ele in seen:\n    #         seen[ele].append(s)",
    "detail": "_ALL_PY.group_anagrams",
    "documentation": {}
  },
  {
    "label": "growingPlant",
    "kind": 2,
    "importPath": "_ALL_PY.growing_plant",
    "description": "_ALL_PY.growing_plant",
    "peekOfCode": "def growingPlant(upSpeed, downSpeed, desiredHeight):\n    height = 0\n    days = 1\n    height += upSpeed\n    while height < desiredHeight:\n        days += 1\n        height -= downSpeed\n        height += upSpeed\n    return days",
    "detail": "_ALL_PY.growing_plant",
    "documentation": {}
  },
  {
    "label": "halvingSum",
    "kind": 2,
    "importPath": "_ALL_PY.halvingSum",
    "description": "_ALL_PY.halvingSum",
    "peekOfCode": "def halvingSum(n):\n    s = 0\n    while n:\n        s += n\n        n //= 2\n    return s\n# s (int) : Sum\n# n (int) : Input number",
    "detail": "_ALL_PY.halvingSum",
    "documentation": {}
  },
  {
    "label": "almostIncreasingSequence",
    "kind": 2,
    "importPath": "_ALL_PY.IncreasingSequence",
    "description": "_ALL_PY.IncreasingSequence",
    "peekOfCode": "def almostIncreasingSequence(sequence):\n    # Step 1: We begin by assigning the length of the given sequence to the variable n.\n    n = len(sequence)\n    # Step 2: By definition, if the sequence contains up to 1 elements, it is considered to be strictly increasing.\n    if n <= 2:\n        return True\n    # Step 3: We set up two counters, namely c1 and c2, so that we count how many elements should be removed.\n    # NOTE THAT c1 refers ONLY to adjacent elements whilst c2 refers to elements just before and just after the i-th element.\n    c1 = 0\n    c2 = 0",
    "detail": "_ALL_PY.IncreasingSequence",
    "documentation": {}
  },
  {
    "label": "reverseInParentheses",
    "kind": 2,
    "importPath": "_ALL_PY.InParentheses",
    "description": "_ALL_PY.InParentheses",
    "peekOfCode": "def reverseInParentheses(inputString):\n    # Step 1: We create a for-loop that goes over all elements of the input string. If element i is an opening bracket, then i\n    # is defined as \"start\". In a similar manner, if element i is a closing bracket, i is defined as \"end\". NOTE THAT\n    # if you write it as \"i = start\" or \"i = end\", an error will pop up (tested) as you would have not defined any variables\n    # under those names, whilst the way that is written now you define as \"start\" and \"end\" elements that are\n    # \"(\" and \")\" respectively.\n    for i in range(len(inputString)):\n        if inputString[i] == \"(\":\n            start = i\n        if inputString[i] == \")\":",
    "detail": "_ALL_PY.InParentheses",
    "documentation": {}
  },
  {
    "label": "isIPv4Address",
    "kind": 2,
    "importPath": "_ALL_PY.IPv4Address",
    "description": "_ALL_PY.IPv4Address",
    "peekOfCode": "def isIPv4Address(inputString):\n    str_split = inputString.split(\".\")\n    count = 0\n    if len(str_split) != 4:\n        return False\n    for i in range(0, 4):\n        if str_split[i] == \"\" or str_split[i] == \"00\" or str_split[i] == \"01\":\n            return False\n        if re.search(\"[a-zA-Z]\", str_split[i]):\n            count += 1",
    "detail": "_ALL_PY.IPv4Address",
    "documentation": {}
  },
  {
    "label": "isAdult",
    "kind": 5,
    "importPath": "_ALL_PY.isAdult",
    "description": "_ALL_PY.isAdult",
    "peekOfCode": "isAdult = lambda a, m: a >= m",
    "detail": "_ALL_PY.isAdult",
    "documentation": {}
  },
  {
    "label": "isDigit",
    "kind": 2,
    "importPath": "_ALL_PY.isDigit",
    "description": "_ALL_PY.isDigit",
    "peekOfCode": "def isDigit(symbol):\n    return symbol.isdigit()",
    "detail": "_ALL_PY.isDigit",
    "documentation": {}
  },
  {
    "label": "isIPv4Address",
    "kind": 2,
    "importPath": "_ALL_PY.isIPv4Address",
    "description": "_ALL_PY.isIPv4Address",
    "peekOfCode": "def isIPv4Address(inputString):\n    try:\n        ip = ipaddress.ip_address(inputString)\n        return True\n    except ValueError:\n        return False",
    "detail": "_ALL_PY.isIPv4Address",
    "documentation": {}
  },
  {
    "label": "isMAC48Address",
    "kind": 2,
    "importPath": "_ALL_PY.isMAC48Address",
    "description": "_ALL_PY.isMAC48Address",
    "peekOfCode": "def isMAC48Address(inputString):\n    \"\"\"Checks if inputString is a valid MAC48 address\n    Args:\n        inputString(string): String to check\n    Return:\n        Boolean indicating if string is valid MAC48 address\n    Raises:\n    \"\"\"\n    if re.match(\n        \"[0-9a-f]{2}([-:])[0-9a-f]{2}(\\\\1[0-9a-f]{2}){4}$\", inputString.lower()",
    "detail": "_ALL_PY.isMAC48Address",
    "documentation": {}
  },
  {
    "label": "isSum",
    "kind": 2,
    "importPath": "_ALL_PY.isSum",
    "description": "_ALL_PY.isSum",
    "peekOfCode": "def isSum(value):\n    s=0\n    for i in range(100):\n        s+=i\n        if s== value:\n            return True",
    "detail": "_ALL_PY.isSum",
    "documentation": {}
  },
  {
    "label": "isSuspiciousRespondent",
    "kind": 2,
    "importPath": "_ALL_PY.isSuspiciousRespondent",
    "description": "_ALL_PY.isSuspiciousRespondent",
    "peekOfCode": "def isSuspiciousRespondent(ans1, ans2, ans3):\n    return ans1 == ans2 == ans3",
    "detail": "_ALL_PY.isSuspiciousRespondent",
    "documentation": {}
  },
  {
    "label": "isBeautifulString",
    "kind": 2,
    "importPath": "_ALL_PY.is_beautiful_string",
    "description": "_ALL_PY.is_beautiful_string",
    "peekOfCode": "def isBeautifulString(inputString):\n    b = dict()\n    for char in inputString:\n        if ord(char) in b:\n            b[ord(char)] += 1\n        else:\n            b[ord(char)] = 1\n    for i in b.keys():\n        if i == 97:\n            continue",
    "detail": "_ALL_PY.is_beautiful_string",
    "documentation": {}
  },
  {
    "label": "isCryptSolution",
    "kind": 2,
    "importPath": "_ALL_PY.is_crypt_solution",
    "description": "_ALL_PY.is_crypt_solution",
    "peekOfCode": "def isCryptSolution(crypt, solution):\n    decoded_words, decoded_word = [], \"\"\n    # Decode the words in the cryptarithm\n    for i in range(len(crypt)):\n        for j in range(len(crypt[i])):\n            for k in range(len(solution)):\n                if crypt[i][j] == solution[k][0]:\n                    decoded_word += solution[k][1]\n        decoded_words.append(decoded_word)\n        decoded_word = \"\"",
    "detail": "_ALL_PY.is_crypt_solution",
    "documentation": {}
  },
  {
    "label": "isInfiniteProcess",
    "kind": 2,
    "importPath": "_ALL_PY.is_infinite_process",
    "description": "_ALL_PY.is_infinite_process",
    "peekOfCode": "def isInfiniteProcess(a, b):\n\t\"\"\"\n\tGiven integers a and b, determine whether the following \n\tpseudocode results in an infinite loop\n\twhile a is not equal to b do\n\t\tincrease a by 1\n\t\tdecrease b by 1\n\tAssume that the program is executed on a virtual machine \n\twhich can store arbitrary long numbers and execute forever.\n\t\"\"\"",
    "detail": "_ALL_PY.is_infinite_process",
    "documentation": {}
  },
  {
    "label": "isLucky",
    "kind": 2,
    "importPath": "_ALL_PY.is_lucky",
    "description": "_ALL_PY.is_lucky",
    "peekOfCode": "def isLucky(n):\n    digits = [int(digit) for digit in str(n)]\n    if len(digits) % 2 == 1:\n        return False\n    else:\n        digits = [int(digit) for digit in str(n)]\n        mid = len(digits) // 2\n        if sum(digits[:mid]) == sum(digits[mid:]):\n            return True\n        else:",
    "detail": "_ALL_PY.is_lucky",
    "documentation": {}
  },
  {
    "label": "knapsackLight",
    "kind": 2,
    "importPath": "_ALL_PY.knapsack_light",
    "description": "_ALL_PY.knapsack_light",
    "peekOfCode": "def knapsackLight(value1, weight1, value2, weight2, maxW):\n    val = 0\n    if value2 > value1:\n        val = value1\n        value1 = value2\n        value2 = val\n        val = weight1\n        weight1 = weight2\n        weight2 = val\n    val = 0",
    "detail": "_ALL_PY.knapsack_light",
    "documentation": {}
  },
  {
    "label": "chessKnight",
    "kind": 2,
    "importPath": "_ALL_PY.Knight",
    "description": "_ALL_PY.Knight",
    "peekOfCode": "def chessKnight(cell):\n    knight_dir = list(t.permutations([1, 2, -1, -2], 2))\n    knight_dir1 = []\n    valid_moves = 0\n    for i in range(len(knight_dir)):\n        if sum(knight_dir[i]) != 0:\n            knight_dir1.append(knight_dir[i])\n    for x, y in knight_dir1:\n        if (97 <= ord(cell[0]) + x <= 104) and (1 <= int(cell[1]) + y <= 8):\n            valid_moves += 1",
    "detail": "_ALL_PY.Knight",
    "documentation": {}
  },
  {
    "label": "largestNumber",
    "kind": 2,
    "importPath": "_ALL_PY.largest_number",
    "description": "_ALL_PY.largest_number",
    "peekOfCode": "def largestNumber(n):\n    return pow(10, n) - 1",
    "detail": "_ALL_PY.largest_number",
    "documentation": {}
  },
  {
    "label": "lateRide",
    "kind": 2,
    "importPath": "_ALL_PY.late_ride",
    "description": "_ALL_PY.late_ride",
    "peekOfCode": "def lateRide(n):\n\t\"\"\"\n\tReturn sum of hours and minutes past 00:00\n\t\"\"\"\n    hours = str(n // 60)\n    minutes = str(n % 60)\n    total = 0\n    for digit in hours:\n        total += int(digit)\n    for digit in minutes:",
    "detail": "_ALL_PY.late_ride",
    "documentation": {}
  },
  {
    "label": "knapsackLight",
    "kind": 2,
    "importPath": "_ALL_PY.Light",
    "description": "_ALL_PY.Light",
    "peekOfCode": "def knapsackLight(value1, weight1, value2, weight2, maxW):\n    if weight1 > maxW and weight2 > maxW and weight1 + weight2 > maxW:\n        return 0\n    if weight1 + weight2 <= maxW:\n        return value1 + value2\n    if value1 < value2:\n        if weight2 > maxW:\n            return value1\n        else:\n            return value2",
    "detail": "_ALL_PY.Light",
    "documentation": {}
  },
  {
    "label": "lineEncoding",
    "kind": 2,
    "importPath": "_ALL_PY.line_encoding",
    "description": "_ALL_PY.line_encoding",
    "peekOfCode": "def lineEncoding(s):\n    encoding, character_count = \"\", 1\n    for i in range(len(s) - 1):\n        if s[i] == s[i + 1]:\n            character_count += 1\n        else:\n            if character_count > 1:\n                encoding += str(character_count) + s[i]  # Add substring to encoding\n                character_count = 1  # Reset character count\n            else:",
    "detail": "_ALL_PY.line_encoding",
    "documentation": {}
  },
  {
    "label": "ListNode",
    "kind": 6,
    "importPath": "_ALL_PY.List",
    "description": "_ALL_PY.List",
    "peekOfCode": "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        get_len = 0\n        current = head\n        while current:\n            get_len += 1",
    "detail": "_ALL_PY.List",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "_ALL_PY.List",
    "description": "_ALL_PY.List",
    "peekOfCode": "class Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        get_len = 0\n        current = head\n        while current:\n            get_len += 1\n            current = current.next\n        mid = get_len // 2\n        current = head\n        while mid > 0:",
    "detail": "_ALL_PY.List",
    "documentation": {}
  },
  {
    "label": "allLongestStrings",
    "kind": 2,
    "importPath": "_ALL_PY.LongestStrings",
    "description": "_ALL_PY.LongestStrings",
    "peekOfCode": "def allLongestStrings(inputArray):\n    # Step 1: We begin by defining an empty array called \"max_arr\", where we will store the longest strings from the given array.\n    max_arr = []\n    # Step 2: The next step is to define the maximum string length inside our given array.\n    # BE CAREFUL: Variable max_len should be defined as follows. If we break it into its components, we can see that:\n    # max(inputArray, key = len) locates ONLY ONE of the strings that satisfies the maximum value in terms of the key parameter\n    # provided (which, in this case, is the string's length) and the outside len() function defines the value of this maximum length.\n    # You are free to test it on a random input array containing various random strings, using a Python compiler online.\n    max_len = len(max(inputArray, key=len))\n    # Step 3: Now, we go over all strings inside the input array checking if their individual length is equal to the",
    "detail": "_ALL_PY.LongestStrings",
    "documentation": {}
  },
  {
    "label": "longestDigitsPrefix",
    "kind": 2,
    "importPath": "_ALL_PY.longest_digits_prefix",
    "description": "_ALL_PY.longest_digits_prefix",
    "peekOfCode": "def longestDigitsPrefix(inputString):\n    for i in range(len(inputString)):\n        if not inputString[i].isdigit():\n            return inputString[:i]\n    return inputString",
    "detail": "_ALL_PY.longest_digits_prefix",
    "documentation": {}
  },
  {
    "label": "longestWord",
    "kind": 2,
    "importPath": "_ALL_PY.longest_word",
    "description": "_ALL_PY.longest_word",
    "peekOfCode": "def longestWord(text):\n\t\"\"\"\n\tReturn longest word in text string\n\tTime Complexity: O(n)\n\tSpace Complexity: O(n)\n\t\"\"\"\n    word, words = '', []\n    for i in range(len(text)):\n        if text[i].isalpha():\n            word += text[i]",
    "detail": "_ALL_PY.longest_word",
    "documentation": {}
  },
  {
    "label": "r",
    "kind": 5,
    "importPath": "_ALL_PY.lrcSubrip",
    "description": "_ALL_PY.lrcSubrip",
    "peekOfCode": "r = []\nc = 1\nt = [[int(s[i:i+2]) for i in [1, 4]] +[s[7:9]] for s in l]\nt = [f\"{x // 60:02d}:{x % 60:02d}:{y:02d},{z.ljust(3, str(0))}\" for x, y, z in t] + [s + ',000'] # if I replace str(0) with '0', this increases to 359 characters wtf\nfor a, b in enumerate(l):\n    r.extend([str(c), t[a] + ' --> ' + t[a+1], b[11:], ''])\n    c += 1\nreturn r[:-1]",
    "detail": "_ALL_PY.lrcSubrip",
    "documentation": {}
  },
  {
    "label": "c",
    "kind": 5,
    "importPath": "_ALL_PY.lrcSubrip",
    "description": "_ALL_PY.lrcSubrip",
    "peekOfCode": "c = 1\nt = [[int(s[i:i+2]) for i in [1, 4]] +[s[7:9]] for s in l]\nt = [f\"{x // 60:02d}:{x % 60:02d}:{y:02d},{z.ljust(3, str(0))}\" for x, y, z in t] + [s + ',000'] # if I replace str(0) with '0', this increases to 359 characters wtf\nfor a, b in enumerate(l):\n    r.extend([str(c), t[a] + ' --> ' + t[a+1], b[11:], ''])\n    c += 1\nreturn r[:-1]",
    "detail": "_ALL_PY.lrcSubrip",
    "documentation": {}
  },
  {
    "label": "t",
    "kind": 5,
    "importPath": "_ALL_PY.lrcSubrip",
    "description": "_ALL_PY.lrcSubrip",
    "peekOfCode": "t = [[int(s[i:i+2]) for i in [1, 4]] +[s[7:9]] for s in l]\nt = [f\"{x // 60:02d}:{x % 60:02d}:{y:02d},{z.ljust(3, str(0))}\" for x, y, z in t] + [s + ',000'] # if I replace str(0) with '0', this increases to 359 characters wtf\nfor a, b in enumerate(l):\n    r.extend([str(c), t[a] + ' --> ' + t[a+1], b[11:], ''])\n    c += 1\nreturn r[:-1]",
    "detail": "_ALL_PY.lrcSubrip",
    "documentation": {}
  },
  {
    "label": "t",
    "kind": 5,
    "importPath": "_ALL_PY.lrcSubrip",
    "description": "_ALL_PY.lrcSubrip",
    "peekOfCode": "t = [f\"{x // 60:02d}:{x % 60:02d}:{y:02d},{z.ljust(3, str(0))}\" for x, y, z in t] + [s + ',000'] # if I replace str(0) with '0', this increases to 359 characters wtf\nfor a, b in enumerate(l):\n    r.extend([str(c), t[a] + ' --> ' + t[a+1], b[11:], ''])\n    c += 1\nreturn r[:-1]",
    "detail": "_ALL_PY.lrcSubrip",
    "documentation": {}
  },
  {
    "label": "isLucky",
    "kind": 2,
    "importPath": "_ALL_PY.Lucky",
    "description": "_ALL_PY.Lucky",
    "peekOfCode": "def isLucky(n):\n    # Step 1: We begin by creating an empty array, called \"digits_of_n\",\n    # where we will store the digits of the given number n, as individual elements.\n    digits_of_n = []\n    # Step 2: We also create a new variable, called \"summ\" (from summation), and set its value to zero.\n    # It will be useful in one of the later steps.\n    summ = 0\n    # Step 3: I have personally seen this while-loop trick being used to split numbers into their individual digits.\n    # As it will take quite a long text to explain this comprehensively, I'd suggest you use the print() function in each\n    # step to see what how each of these steps works. The important thing to mention is the \"appending\" step where each",
    "detail": "_ALL_PY.Lucky",
    "documentation": {}
  },
  {
    "label": "isMAC48Address",
    "kind": 2,
    "importPath": "_ALL_PY.MAC48Address",
    "description": "_ALL_PY.MAC48Address",
    "peekOfCode": "def isMAC48Address(inputString):\n    str_split = inputString.split(\"-\")\n    count = 0\n    if len(inputString) != 17:\n        return False\n    if len(str_split) != 6:\n        return False\n    for i in range(0, 6):\n        if str_split[i] == \"\":\n            return False",
    "detail": "_ALL_PY.MAC48Address",
    "documentation": {}
  },
  {
    "label": "magicalWell",
    "kind": 2,
    "importPath": "_ALL_PY.magicalWell",
    "description": "_ALL_PY.magicalWell",
    "peekOfCode": "def magicalWell(a,b,n):\n    s, m = 0, 0\n    while m < n:\n        s += a * b\n        a += 1\n        b += 1\n        m += 1\n    return s",
    "detail": "_ALL_PY.magicalWell",
    "documentation": {}
  },
  {
    "label": "a,",
    "kind": 5,
    "importPath": "_ALL_PY.makeArrayConsecutive",
    "description": "_ALL_PY.makeArrayConsecutive",
    "peekOfCode": "a, = eval(dir()[0])\nreturn [i for i in range(min(a), max(a)) if i not in a]",
    "detail": "_ALL_PY.makeArrayConsecutive",
    "documentation": {}
  },
  {
    "label": "makeArrayConsecutive2",
    "kind": 2,
    "importPath": "_ALL_PY.make_array_consecutive2",
    "description": "_ALL_PY.make_array_consecutive2",
    "peekOfCode": "def makeArrayConsecutive2(statues):\n    additional_statues = 0\n    sorted_statues = sorted(statues)  # Sort the statues\n    for i in range(len(sorted_statues) - 1):\n        if sorted_statues[i + 1] - sorted_statues[i] != 1:\n            additional_statues += (sorted_statues[i + 1] - sorted_statues[i]) - 1\n    return additional_statues",
    "detail": "_ALL_PY.make_array_consecutive2",
    "documentation": {}
  },
  {
    "label": "mapDecoding",
    "kind": 2,
    "importPath": "_ALL_PY.mapDecoder",
    "description": "_ALL_PY.mapDecoder",
    "peekOfCode": "def mapDecoding(message):\n    counts = [0, 1]\n    size = len(message)\n    # special cases\n    if size == 0:\n        return 1\n    if int(message[0]) == 0:\n        return 0\n    if size == 1:\n        return 1",
    "detail": "_ALL_PY.mapDecoder",
    "documentation": {}
  },
  {
    "label": "matrixElementsSum",
    "kind": 2,
    "importPath": "_ALL_PY.matrix_elements_sum",
    "description": "_ALL_PY.matrix_elements_sum",
    "peekOfCode": "def matrixElementsSum(matrix):\n    runningsum = 0\n    for i in range(len(matrix)):\n        for j in range(len(matrix[i])):\n            if matrix[i][j] == 0 and i + 1 < len(matrix):\n                matrix[i + 1][j] = 0\n            runningsum += matrix[i][j]\n    return runningsum",
    "detail": "_ALL_PY.matrix_elements_sum",
    "documentation": {}
  },
  {
    "label": "arrayMaxConsecutiveSum",
    "kind": 2,
    "importPath": "_ALL_PY.MaxConsecutiveSum",
    "description": "_ALL_PY.MaxConsecutiveSum",
    "peekOfCode": "def arrayMaxConsecutiveSum(inputArray, k):\n    arr = [sum(inputArray[:k])]\n    for i in range(1, len(inputArray) - (k - 1)):\n        arr.append(arr[i - 1] - inputArray[i - 1] + inputArray[i + k - 1])\n    sort_arr = sorted(arr)\n    return sort_arr[-1]",
    "detail": "_ALL_PY.MaxConsecutiveSum",
    "documentation": {}
  },
  {
    "label": "arrayMaximalAdjacentDifference",
    "kind": 2,
    "importPath": "_ALL_PY.MaximalAdjacentDifference",
    "description": "_ALL_PY.MaximalAdjacentDifference",
    "peekOfCode": "def arrayMaximalAdjacentDifference(inputArray):\n    return max(\n        (abs(inputArray[i + 1] - inputArray[i]) for i in range(0, len(inputArray) - 1))\n    )",
    "detail": "_ALL_PY.MaximalAdjacentDifference",
    "documentation": {}
  },
  {
    "label": "maxSubarray",
    "kind": 2,
    "importPath": "_ALL_PY.maxSubarray",
    "description": "_ALL_PY.maxSubarray",
    "peekOfCode": "def maxSubarray(A):\n    # A: inputArray\n    # m: Max\n    # \n    # \n    m = e = 0\n    for i in A:\n        e += i\n        if e < 0:\n            e = 0",
    "detail": "_ALL_PY.maxSubarray",
    "documentation": {}
  },
  {
    "label": "maxMultiple",
    "kind": 2,
    "importPath": "_ALL_PY.max_multiple",
    "description": "_ALL_PY.max_multiple",
    "peekOfCode": "def maxMultiple(divisor, bound):\n\t\"\"\"\n\tReturn number n that is greater than 0, less than\n\tor equal to bound and divisible by divisor\n\t\"\"\"\n    number = 0\n    while number <= bound and number % divisor == 0:\n        number += divisor\n    number -= divisor\n    return number",
    "detail": "_ALL_PY.max_multiple",
    "documentation": {}
  },
  {
    "label": "r",
    "kind": 5,
    "importPath": "_ALL_PY.Meetings",
    "description": "_ALL_PY.Meetings",
    "peekOfCode": "r = -1\nl = len(p)\nfor i in range(l):\n    for j in range(l):\n        c = 0\n        d = p[j] - p[i]\n        f = s[i] - s[j]\n        if d * f < 1:\n            continue\n        for k in range(l):",
    "detail": "_ALL_PY.Meetings",
    "documentation": {}
  },
  {
    "label": "l",
    "kind": 5,
    "importPath": "_ALL_PY.Meetings",
    "description": "_ALL_PY.Meetings",
    "peekOfCode": "l = len(p)\nfor i in range(l):\n    for j in range(l):\n        c = 0\n        d = p[j] - p[i]\n        f = s[i] - s[j]\n        if d * f < 1:\n            continue\n        for k in range(l):\n            if p[k] * f + s[k] * d == p[i] * f + s[i] * d:",
    "detail": "_ALL_PY.Meetings",
    "documentation": {}
  },
  {
    "label": "calculateSubstringsLengthK",
    "kind": 2,
    "importPath": "_ALL_PY.message_from_binary_code",
    "description": "_ALL_PY.message_from_binary_code",
    "peekOfCode": "def calculateSubstringsLengthK(s, k):\n    \"\"\"\n    Return substrings of size k in s\n    \"\"\"\n    substrings, index = [], 0\n    while index + k <= len(s):\n        substrings.append(s[index : index + k])\n        index += k\n    return substrings\ndef messageFromBinaryCode(code):",
    "detail": "_ALL_PY.message_from_binary_code",
    "documentation": {}
  },
  {
    "label": "messageFromBinaryCode",
    "kind": 2,
    "importPath": "_ALL_PY.message_from_binary_code",
    "description": "_ALL_PY.message_from_binary_code",
    "peekOfCode": "def messageFromBinaryCode(code):\n    \"\"\"\n    Return encrypted message from binary code\n    \"\"\"\n    substrings, encrypted_message = calculateSubstringsLengthK(code, 8), \"\"\n    for substring in substrings:\n        ascii_code = int(substring, 2)\n        encrypted_message += chr(ascii_code)\n    return encrypted_message",
    "detail": "_ALL_PY.message_from_binary_code",
    "documentation": {}
  },
  {
    "label": "neighbours",
    "kind": 2,
    "importPath": "_ALL_PY.minesweeper",
    "description": "_ALL_PY.minesweeper",
    "peekOfCode": "def neighbours(matrix, i, j, rows, columns):\n    mines = 0\n    # Top left\n    if i >= 1 and j >= 1:\n        if matrix[i - 1][j - 1]:\n            mines += 1\n    # Top center\n    if i >= 1:\n        if matrix[i - 1][j]:\n            mines += 1",
    "detail": "_ALL_PY.minesweeper",
    "documentation": {}
  },
  {
    "label": "minesweeper",
    "kind": 2,
    "importPath": "_ALL_PY.minesweeper",
    "description": "_ALL_PY.minesweeper",
    "peekOfCode": "def minesweeper(matrix):\n    rows, columns = len(matrix), len(matrix[0])\n    game_setup = []\n    for i in range(rows):\n        game_setup_row = []\n        for j in range(columns):\n            game_setup_row.append(neighbours(matrix, i, j, rows, columns))\n        game_setup.append(game_setup_row)\n    return game_setup",
    "detail": "_ALL_PY.minesweeper",
    "documentation": {}
  },
  {
    "label": "solution",
    "kind": 2,
    "importPath": "_ALL_PY.minInteger",
    "description": "_ALL_PY.minInteger",
    "peekOfCode": "def solution(A):\n    solution.n = 1\n    def getMin(num):\n        if solution.n == num:\n            solution.n += 1\n        return num\n    B = sorted(A, key=getMin)\n    print(solution.n)\n    return solution.n\n# test cases",
    "detail": "_ALL_PY.minInteger",
    "documentation": {}
  },
  {
    "label": "start",
    "kind": 5,
    "importPath": "_ALL_PY.minInteger",
    "description": "_ALL_PY.minInteger",
    "peekOfCode": "start = time.time()\ndef solution(A):\n    solution.n = 1\n    def getMin(num):\n        if solution.n == num:\n            solution.n += 1\n        return num\n    B = sorted(A, key=getMin)\n    print(solution.n)\n    return solution.n",
    "detail": "_ALL_PY.minInteger",
    "documentation": {}
  },
  {
    "label": "end",
    "kind": 5,
    "importPath": "_ALL_PY.minInteger",
    "description": "_ALL_PY.minInteger",
    "peekOfCode": "end = time.time()\nprint(end - start)",
    "detail": "_ALL_PY.minInteger",
    "documentation": {}
  },
  {
    "label": "smallestMultiple",
    "kind": 2,
    "importPath": "_ALL_PY.Multiple",
    "description": "_ALL_PY.Multiple",
    "peekOfCode": "def smallestMultiple(l, r):\n    for i in range(1, 16):\n        for j in range(l, r + 1):\n            while True:\n                if i % j != 0:\n                    break\n            return i",
    "detail": "_ALL_PY.Multiple",
    "documentation": {}
  },
  {
    "label": "mySubstring",
    "kind": 5,
    "importPath": "_ALL_PY.mySubstring",
    "description": "_ALL_PY.mySubstring",
    "peekOfCode": "mySubstring = lambda s, l, r: s[l:r+1]",
    "detail": "_ALL_PY.mySubstring",
    "documentation": {}
  },
  {
    "label": "variableName",
    "kind": 2,
    "importPath": "_ALL_PY.Name",
    "description": "_ALL_PY.Name",
    "peekOfCode": "def variableName(name):\n    str_name = [i for i in str(name)]\n    non_acc_chars = [\n        \" \",\n        \">\",\n        \"<\",\n        \":\",\n        \"-\",\n        \"|\",\n        \".\",",
    "detail": "_ALL_PY.Name",
    "documentation": {}
  },
  {
    "label": "fileNaming",
    "kind": 2,
    "importPath": "_ALL_PY.Naming",
    "description": "_ALL_PY.Naming",
    "peekOfCode": "def fileNaming(names):\n    if names == []:\n        return []\n    new_names = []\n    for name in names:\n        if name not in new_names:\n            new_names.append(name)\n        else:\n            for i in range(1, 1000):\n                new_name = name + \"(\" + str(i) + \")\"",
    "detail": "_ALL_PY.Naming",
    "documentation": {}
  },
  {
    "label": "singleNumber",
    "kind": 2,
    "importPath": "_ALL_PY.Number (2)",
    "description": "_ALL_PY.Number (2)",
    "peekOfCode": "def singleNumber(nums):\n    \"\"\"\n    given a list of integer with every element appears twice and a single number appears once, return the value of the\n    single number\n    \"\"\"\n    count = Counter(nums)\n    for k, v in count.items():\n        if v == 1:\n            return k\nprint(singleNumber([2, 2, 4, 1, 5]))",
    "detail": "_ALL_PY.Number (2)",
    "documentation": {}
  },
  {
    "label": "isHappy",
    "kind": 2,
    "importPath": "_ALL_PY.Number",
    "description": "_ALL_PY.Number",
    "peekOfCode": "def isHappy(n):\n    \"\"\"\n    Is happy takes in a number and returns True if it is a happy number, False otherwise. A happy number\n    is a number defined by the following process: Starting with any positive integer, replace the number by the\n    sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay),\n    or it loops endlessly in a cycle which does not include 1.\n    \"\"\"\n    seen = {n: 1}\n    while True:\n        new_sq = sum([int(d) ** 2 for d in str(n)])",
    "detail": "_ALL_PY.Number",
    "documentation": {}
  },
  {
    "label": "memo",
    "kind": 5,
    "importPath": "_ALL_PY.Number",
    "description": "_ALL_PY.Number",
    "peekOfCode": "memo = {}\ndef isHappy(n):\n    \"\"\"\n    Is happy takes in a number and returns True if it is a happy number, False otherwise. A happy number\n    is a number defined by the following process: Starting with any positive integer, replace the number by the\n    sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay),\n    or it loops endlessly in a cycle which does not include 1.\n    \"\"\"\n    seen = {n: 1}\n    while True:",
    "detail": "_ALL_PY.Number",
    "documentation": {}
  },
  {
    "label": "spiralNumbers",
    "kind": 2,
    "importPath": "_ALL_PY.Numbers",
    "description": "_ALL_PY.Numbers",
    "peekOfCode": "def spiralNumbers(n):\n    dims = n\n    elem = 1\n    matrix = [[0] * n for x in range(n)]\n    while 0 < dims:\n        i = n - dims\n        # you can sub i = n - dims ONLY in the first 2 parts\n        # where n - dims is in the starting parameter of the range\n        for j in range(n - dims, dims):\n            matrix[i][j] = elem",
    "detail": "_ALL_PY.Numbers",
    "documentation": {}
  },
  {
    "label": "avoidObstacles",
    "kind": 2,
    "importPath": "_ALL_PY.Obstacles",
    "description": "_ALL_PY.Obstacles",
    "peekOfCode": "def avoidObstacles(inputArray):\n    for i in range(2, max(inputArray) + 2):\n        if i not in inputArray and all(j % i != 0 for j in inputArray):\n            return i",
    "detail": "_ALL_PY.Obstacles",
    "documentation": {}
  },
  {
    "label": "circleOfNumbers",
    "kind": 2,
    "importPath": "_ALL_PY.OfNumbers",
    "description": "_ALL_PY.OfNumbers",
    "peekOfCode": "def circleOfNumbers(n, firstNumber):\n    return ((n / 2) + firstNumber) % n",
    "detail": "_ALL_PY.OfNumbers",
    "documentation": {}
  },
  {
    "label": "sumOfSquares",
    "kind": 2,
    "importPath": "_ALL_PY.OfSquares",
    "description": "_ALL_PY.OfSquares",
    "peekOfCode": "def sumOfSquares(n):\n    return sum([x ** 2 for x in range(1, n + 1)])",
    "detail": "_ALL_PY.OfSquares",
    "documentation": {}
  },
  {
    "label": "sumOfTheAngles",
    "kind": 5,
    "importPath": "_ALL_PY.OfTheAngles",
    "description": "_ALL_PY.OfTheAngles",
    "peekOfCode": "sumOfTheAngles = lambda n: (n - 2) * 180\n# n = eval(dir()[0])\n# return (n - 2) * 180",
    "detail": "_ALL_PY.OfTheAngles",
    "documentation": {}
  },
  {
    "label": "sumOfTwo",
    "kind": 2,
    "importPath": "_ALL_PY.OfTwo",
    "description": "_ALL_PY.OfTwo",
    "peekOfCode": "def sumOfTwo(a, b, v):\n    b = set(b)\n    return any(v - i in b for i in a)",
    "detail": "_ALL_PY.OfTwo",
    "documentation": {}
  },
  {
    "label": "visitsOnCircularRoad",
    "kind": 2,
    "importPath": "_ALL_PY.OnCircularRoad",
    "description": "_ALL_PY.OnCircularRoad",
    "peekOfCode": "def visitsOnCircularRoad(n, v):\n    c = 1\n    t = 0\n    for i in v:\n        t += min(abs(i - c), abs(n - abs(i - c)))\n        c = i\n    return t\n# v = visitsOrder\n# n = number of houses\n# c = Current position",
    "detail": "_ALL_PY.OnCircularRoad",
    "documentation": {}
  },
  {
    "label": "buildPalindrome",
    "kind": 2,
    "importPath": "_ALL_PY.Palindrome (2)",
    "description": "_ALL_PY.Palindrome (2)",
    "peekOfCode": "def buildPalindrome(st):\n    for i in range(len(st)):\n        sub = st[i : len(st)]\n        if sub[::-1] == sub:\n            missing = st[0:i]\n            return st + missing[::-1]\n    return st",
    "detail": "_ALL_PY.Palindrome (2)",
    "documentation": {}
  },
  {
    "label": "checkPalindrome",
    "kind": 5,
    "importPath": "_ALL_PY.Palindrome (3)",
    "description": "_ALL_PY.Palindrome (3)",
    "peekOfCode": "checkPalindrome = lambda x: x == x[::-1]",
    "detail": "_ALL_PY.Palindrome (3)",
    "documentation": {}
  },
  {
    "label": "check_palindrome",
    "kind": 2,
    "importPath": "_ALL_PY.palindrome",
    "description": "_ALL_PY.palindrome",
    "peekOfCode": "def check_palindrome(input_string: str = '') -> bool:\n    if 1 <= len(input_string) <= 100000:\n        return input_string == input_string[::-1]\n    return False",
    "detail": "_ALL_PY.palindrome",
    "documentation": {}
  },
  {
    "label": "palindromeRearranging",
    "kind": 2,
    "importPath": "_ALL_PY.palindrome_rearranging",
    "description": "_ALL_PY.palindrome_rearranging",
    "peekOfCode": "def palindromeRearranging(inputString):\n    character_count, odd_frequencies = {}, 0\n    # Count character frequencies\n    for i in range(len(inputString)):\n        if inputString[i] not in character_count:\n            character_count[(inputString[i])] = 1\n        elif inputString[i] in character_count:\n            character_count[(inputString[i])] += 1\n    # Count odd character frequencies\n    for char in character_count:",
    "detail": "_ALL_PY.palindrome_rearranging",
    "documentation": {}
  },
  {
    "label": "#passwordCheck",
    "kind": 5,
    "importPath": "_ALL_PY.passwordCheck",
    "description": "_ALL_PY.passwordCheck",
    "peekOfCode": "#passwordCheck = lambda s: (any(i.isdigit()) and any(i.islower()) and any(i.isupper())) for i in s and len(s) > 4\n# Regex:\n#def passwordCheck(s):\n#    return len(s) > 4 and all(re.search(p, s) for p in ('[A-Z]', '\\d', '[a-z]'))\npasswordCheck = lambda s: len(s) > 4 and all(re.search(i, s) for i in ('[A-Z]', '\\d', '[a-z]'))",
    "detail": "_ALL_PY.passwordCheck",
    "documentation": {}
  },
  {
    "label": "passwordCheck",
    "kind": 5,
    "importPath": "_ALL_PY.passwordCheck",
    "description": "_ALL_PY.passwordCheck",
    "peekOfCode": "passwordCheck = lambda s: len(s) > 4 and all(re.search(i, s) for i in ('[A-Z]', '\\d', '[a-z]'))",
    "detail": "_ALL_PY.passwordCheck",
    "documentation": {}
  },
  {
    "label": "greetPerson",
    "kind": 5,
    "importPath": "_ALL_PY.Person",
    "description": "_ALL_PY.Person",
    "peekOfCode": "greetPerson = \"Hello, {}\".format",
    "detail": "_ALL_PY.Person",
    "documentation": {}
  },
  {
    "label": "phoneCall",
    "kind": 2,
    "importPath": "_ALL_PY.phone_call",
    "description": "_ALL_PY.phone_call",
    "peekOfCode": "def phoneCall(min1, min2_10, min11, s):\n    \"\"\"\n    You have s cents on your account before the call. \n    What is the duration of the longest call (in minutes \n    rounded down to the nearest integer) you can have?\n    Time Complexity: O(1)\n    Space Complexity: O(1)\n    \"\"\"\n    # Check if there is enough cents to make\n    # a 1 minutes call",
    "detail": "_ALL_PY.phone_call",
    "documentation": {}
  },
  {
    "label": "growingPlant",
    "kind": 2,
    "importPath": "_ALL_PY.Plant",
    "description": "_ALL_PY.Plant",
    "peekOfCode": "def growingPlant(upSpeed, downSpeed, desiredHeight):\n    day_count = 0\n    height = 0\n    while height <= desiredHeight:\n        height = height + upSpeed\n        day_count += 1\n        if height < desiredHeight:\n            height = height - downSpeed\n        else:\n            return day_count",
    "detail": "_ALL_PY.Plant",
    "documentation": {}
  },
  {
    "label": "twoPointerSum",
    "kind": 2,
    "importPath": "_ALL_PY.PointerSolution",
    "description": "_ALL_PY.PointerSolution",
    "peekOfCode": "def twoPointerSum(nums, target):\n    \"\"\"\n    Given a sorted array of integers, return indices of the two numbers such that they add up to a specific target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    \"\"\"\n    l = 0\n    r = len(nums) - 1\n    while l < r:\n        if nums[l] + nums[r] == target:\n            return [l, r]",
    "detail": "_ALL_PY.PointerSolution",
    "documentation": {}
  },
  {
    "label": "nums",
    "kind": 5,
    "importPath": "_ALL_PY.PointerSolution",
    "description": "_ALL_PY.PointerSolution",
    "peekOfCode": "nums = [5, 25, 75]\ntarget = 100\nprint(twoPointerSum(nums, target))",
    "detail": "_ALL_PY.PointerSolution",
    "documentation": {}
  },
  {
    "label": "target",
    "kind": 5,
    "importPath": "_ALL_PY.PointerSolution",
    "description": "_ALL_PY.PointerSolution",
    "peekOfCode": "target = 100\nprint(twoPointerSum(nums, target))",
    "detail": "_ALL_PY.PointerSolution",
    "documentation": {}
  },
  {
    "label": "possibleSums",
    "kind": 2,
    "importPath": "_ALL_PY.possibleSums",
    "description": "_ALL_PY.possibleSums",
    "peekOfCode": "def possibleSums(coins, quantity):\n    # sum_map = set()\n    # start with brute force\n    # total_arr = [coins[i] for i, q in enumerate(quantity) for l in range(q)]\n    # for i in range(1, len(total_arr)+1):\n    #     combos = itertools.combinations(total_arr, i)\n    #     print(combos)\n    #     for combo in combos:\n    #         sum_map.add(sum(combo))\n    # return len(sum_map)",
    "detail": "_ALL_PY.possibleSums",
    "documentation": {}
  },
  {
    "label": "combine_sets",
    "kind": 2,
    "importPath": "_ALL_PY.possibleSums",
    "description": "_ALL_PY.possibleSums",
    "peekOfCode": "def combine_sets(set1, set2):\n    together_set = set()\n    for item1 in set1:\n        for item2 in set2:\n            together_set.add(item1 + item2)\n        together_set.add(item1)\n    for item2 in set2:\n        together_set.add(item2)\n    return together_set",
    "detail": "_ALL_PY.possibleSums",
    "documentation": {}
  },
  {
    "label": "gasPrediction",
    "kind": 5,
    "importPath": "_ALL_PY.Prediction",
    "description": "_ALL_PY.Prediction",
    "peekOfCode": "gasPrediction = lambda d, c, a: sum(d) / 12 / a > c",
    "detail": "_ALL_PY.Prediction",
    "documentation": {}
  },
  {
    "label": "digitsProduct",
    "kind": 2,
    "importPath": "_ALL_PY.Product",
    "description": "_ALL_PY.Product",
    "peekOfCode": "def digitsProduct(product):\n    if product == 0:\n        return 10\n    if product == 1:\n        return 1\n    for i in range(0, 4000):\n        p = 1\n        for j in str(i):\n            p *= int(j)\n        if p == product:",
    "detail": "_ALL_PY.Product",
    "documentation": {}
  },
  {
    "label": "depositProfit",
    "kind": 2,
    "importPath": "_ALL_PY.Profit (2)",
    "description": "_ALL_PY.Profit (2)",
    "peekOfCode": "def depositProfit(deposit, rate, threshold):\n    i = 0\n    while deposit < threshold:\n        deposit += deposit * rate * 0.01\n        i += 1\n    return i",
    "detail": "_ALL_PY.Profit (2)",
    "documentation": {}
  },
  {
    "label": "depositProfit",
    "kind": 2,
    "importPath": "_ALL_PY.Profit",
    "description": "_ALL_PY.Profit",
    "peekOfCode": "def depositProfit(deposit, rate, threshold):\n    year_count = 0\n    while deposit < threshold:\n        deposit = deposit + (deposit * (rate / 100))\n        year_count += 1\n    return year_count",
    "detail": "_ALL_PY.Profit",
    "documentation": {}
  },
  {
    "label": "partition",
    "kind": 2,
    "importPath": "_ALL_PY.quicksort",
    "description": "_ALL_PY.quicksort",
    "peekOfCode": "def partition(A, lo, hi):\n    pivot = A[lo + (hi - lo) // 2]\n    i = lo - 1\n    j = hi + 1\n    while True:\n        i += 1\n        while A[i] < pivot:\n            i += 1\n        j -= 1    \n        while A[j] > pivot:",
    "detail": "_ALL_PY.quicksort",
    "documentation": {}
  },
  {
    "label": "quicksort",
    "kind": 2,
    "importPath": "_ALL_PY.quicksort",
    "description": "_ALL_PY.quicksort",
    "peekOfCode": "def quicksort(A, lo, hi):\n    if lo < hi:\n        p = partition(A, lo, hi)\n        quicksort(A, lo, p)\n        quicksort(A, p + 1, hi)\n    return A\nif __name__ == \"__main__\":\n    arr = [8, 3, 5, 1, 7, 2]\n    quicksort(arr, 0, len(arr) - 1)\n    # >>> [1, 2, 3, 5, 7, 8]",
    "detail": "_ALL_PY.quicksort",
    "documentation": {}
  },
  {
    "label": "reachNextLevel",
    "kind": 2,
    "importPath": "_ALL_PY.reach_next_level",
    "description": "_ALL_PY.reach_next_level",
    "peekOfCode": "def reachNextLevel(experience, threshold, reward):\n    \"\"\"\n    You are playing an RPG game. Currently your \n    experience points (XP) total is equal to experience. \n    To reach the next level your XP should be at least at \n    threshold. If you kill the monster in front of you, \n    you will gain more experience points in the amount \n    of the reward.\n    Given values experience, threshold and reward, check \n    if you reach the next level after killing the monster.",
    "detail": "_ALL_PY.reach_next_level",
    "documentation": {}
  },
  {
    "label": "stringsRearrangement",
    "kind": 2,
    "importPath": "_ALL_PY.Rearrangement",
    "description": "_ALL_PY.Rearrangement",
    "peekOfCode": "def stringsRearrangement(inputArray):\n    p_list = list(p(inputArray))\n    for i in range(len(p_list)):\n        count1 = 0\n        for j in range(len(p_list[0]) - 1):\n            count2 = 0\n            for k in range(len(p_list[0][0])):\n                if p_list[i][j][k] != p_list[i][j + 1][k]:\n                    count2 += 1\n            if count2 == 1:",
    "detail": "_ALL_PY.Rearrangement",
    "documentation": {}
  },
  {
    "label": "palindromeRearranging",
    "kind": 2,
    "importPath": "_ALL_PY.Rearranging",
    "description": "_ALL_PY.Rearranging",
    "peekOfCode": "def palindromeRearranging(inputString):\n    odd_count = 0\n    char_set = set(inputString)\n    for i in char_set:\n        char_count = inputString.count(i)\n        if char_count % 2 != 0:\n            odd_count += 1\n    if odd_count <= 1:\n        return True\n    return False",
    "detail": "_ALL_PY.Rearranging",
    "documentation": {}
  },
  {
    "label": "f,",
    "kind": 5,
    "importPath": "_ALL_PY.Reducing",
    "description": "_ALL_PY.Reducing",
    "peekOfCode": "f, = eval(dir()[0])\nreturn [i / math.gcd(f[0], f[1]) for i in f]",
    "detail": "_ALL_PY.Reducing",
    "documentation": {}
  },
  {
    "label": "arrayReplace",
    "kind": 2,
    "importPath": "_ALL_PY.Replace",
    "description": "_ALL_PY.Replace",
    "peekOfCode": "def arrayReplace(inputArray, elemToReplace, substitutionElem):\n    new = []\n    for i in range(len(inputArray)):\n        if inputArray[i] == elemToReplace:\n            new.append(substitutionElem)\n        else:\n            new.append(inputArray[i])\n    return new",
    "detail": "_ALL_PY.Replace",
    "documentation": {}
  },
  {
    "label": "returnTwelve",
    "kind": 5,
    "importPath": "_ALL_PY.returnTwelve",
    "description": "_ALL_PY.returnTwelve",
    "peekOfCode": "returnTwelve = lambda n: 12 if n < 12 else n",
    "detail": "_ALL_PY.returnTwelve",
    "documentation": {}
  },
  {
    "label": "reverseInParentheses",
    "kind": 2,
    "importPath": "_ALL_PY.reverse_in_parentheses",
    "description": "_ALL_PY.reverse_in_parentheses",
    "peekOfCode": "def reverseInParentheses(inputString):\n    opening_brackets_indices = []\n    # Iterate through string\n    for i in range(len(inputString)):\n        # Push opening brackets onto the stack\n        if inputString[i] == \"(\":\n            opening_brackets_indices.append(i)\n        # Reverse the substring starting after the\n        # last encountered opening bracket till\n        # the current character",
    "detail": "_ALL_PY.reverse_in_parentheses",
    "documentation": {}
  },
  {
    "label": "rotateImage",
    "kind": 2,
    "importPath": "_ALL_PY.rotateImage",
    "description": "_ALL_PY.rotateImage",
    "peekOfCode": "def rotateImage(a):\n    n = len(a)\n    # reflect about the diagonal\n    for i in range(n):\n        for j in range(i, n):\n            a[i][j], a[j][i] = a[j][i], a[i][j]\n    # now flip the columns about the center\n    for i in range(n):\n        for j in range(n // 2):\n            a[i][j], a[i][n - 1 - j] = a[i][n - 1 - j], a[i][j]",
    "detail": "_ALL_PY.rotateImage",
    "documentation": {}
  },
  {
    "label": "rotateImage",
    "kind": 2,
    "importPath": "_ALL_PY.rotate_image_ninety_degrees_clockwise",
    "description": "_ALL_PY.rotate_image_ninety_degrees_clockwise",
    "peekOfCode": "def rotateImage(a):\n    N = len(a)\n    for i in range(N // 2):\n        for j in range(i, N - 1 - i):\n            temp = a[i][j]\n            a[i][j] = a[N - 1 - j][i]\n            a[N - 1 - j][i] = a[N - 1 - i][N - 1 - j]\n            a[N - 1 - i][N - 1 - j] = a[j][N - 1 - i]\n            a[j][N - 1 - i] = temp\n    return a",
    "detail": "_ALL_PY.rotate_image_ninety_degrees_clockwise",
    "documentation": {}
  },
  {
    "label": "r",
    "kind": 5,
    "importPath": "_ALL_PY.runnersMeetings",
    "description": "_ALL_PY.runnersMeetings",
    "peekOfCode": "r = -1\nl = len(p)\nfor i in range(l):\n    for j in range(l):\n        c = 0\n        d = p[j] - p[i]\n        f = s[i] - s[j]\n        if d * f < 1:\n            continue\n        for k in range(l):",
    "detail": "_ALL_PY.runnersMeetings",
    "documentation": {}
  },
  {
    "label": "l",
    "kind": 5,
    "importPath": "_ALL_PY.runnersMeetings",
    "description": "_ALL_PY.runnersMeetings",
    "peekOfCode": "l = len(p)\nfor i in range(l):\n    for j in range(l):\n        c = 0\n        d = p[j] - p[i]\n        f = s[i] - s[j]\n        if d * f < 1:\n            continue\n        for k in range(l):\n            if p[k] * f + s[k] * d == p[i] * f + s[i] * d:",
    "detail": "_ALL_PY.runnersMeetings",
    "documentation": {}
  },
  {
    "label": "runningWater",
    "kind": 2,
    "importPath": "_ALL_PY.runningWater",
    "description": "_ALL_PY.runningWater",
    "peekOfCode": "def runningWater(cap, volume):\n    max_buckets = cap[::]\n    full_volume = sum(max_buckets)\n    seen_volume = set()\n    seen = set()\n    stack = emptyBuckets(cap, 0, volume)\n    for item in stack:\n        seen_volume.add(full_volume - item[0])\n        seen.add(tuple(item[1]))\n    # need this edge case here to pass all tests!",
    "detail": "_ALL_PY.runningWater",
    "documentation": {}
  },
  {
    "label": "emptyBuckets",
    "kind": 2,
    "importPath": "_ALL_PY.runningWater",
    "description": "_ALL_PY.runningWater",
    "peekOfCode": "def emptyBuckets(buckets, curr_poured, min_volume):\n    output = []\n    for i in range(3):\n        output.append([buckets[i] + curr_poured, []])\n        # print(output)\n        for j in range(3):\n            if j == i:\n                output[i][1].append(0)\n            else:\n                output[i][1].append(buckets[j])",
    "detail": "_ALL_PY.runningWater",
    "documentation": {}
  },
  {
    "label": "pourBuckets",
    "kind": 2,
    "importPath": "_ALL_PY.runningWater",
    "description": "_ALL_PY.runningWater",
    "peekOfCode": "def pourBuckets(buckets, max_buckets, seen):\n    output = []\n    # print(buckets)\n    for i in range(3):\n        for j in range(3):\n            if i == j:\n                continue\n            curr = copy.deepcopy(buckets)\n            # pour buckets into other buckets\n            if curr[1][j] == max_buckets[j]:",
    "detail": "_ALL_PY.runningWater",
    "documentation": {}
  },
  {
    "label": "seatsInTheater",
    "kind": 2,
    "importPath": "_ALL_PY.seats_in_theatre",
    "description": "_ALL_PY.seats_in_theatre",
    "peekOfCode": "def seatsInTheater(nCols, nRows, col, row):\n    \"\"\"\n    Given the total number of rows and columns \n    in the theater (nRows and nCols, respectively), \n    and the row and column you're sitting in, return \n    the number of people who sit strictly behind \n    you and in your column or to the left, assuming \n    all seats are occupied.\n    \"\"\"\n    return (nRows - row) * (nCols - col + 1)",
    "detail": "_ALL_PY.seats_in_theatre",
    "documentation": {}
  },
  {
    "label": "entrada",
    "kind": 5,
    "importPath": "_ALL_PY.serie",
    "description": "_ALL_PY.serie",
    "peekOfCode": "entrada = int(input(\"CUANTAS VECES QUIERES PERRO: \"))\nacumulador = 0\ndenominador = -1\nfor i in range(entrada):\n    denominador += (i*3)\n    acumulador += 1/denominador\nprint(acumulador)",
    "detail": "_ALL_PY.serie",
    "documentation": {}
  },
  {
    "label": "acumulador",
    "kind": 5,
    "importPath": "_ALL_PY.serie",
    "description": "_ALL_PY.serie",
    "peekOfCode": "acumulador = 0\ndenominador = -1\nfor i in range(entrada):\n    denominador += (i*3)\n    acumulador += 1/denominador\nprint(acumulador)",
    "detail": "_ALL_PY.serie",
    "documentation": {}
  },
  {
    "label": "denominador",
    "kind": 5,
    "importPath": "_ALL_PY.serie",
    "description": "_ALL_PY.serie",
    "peekOfCode": "denominador = -1\nfor i in range(entrada):\n    denominador += (i*3)\n    acumulador += 1/denominador\nprint(acumulador)",
    "detail": "_ALL_PY.serie",
    "documentation": {}
  },
  {
    "label": "shape_area",
    "kind": 2,
    "importPath": "_ALL_PY.shape_area",
    "description": "_ALL_PY.shape_area",
    "peekOfCode": "def shape_area(n: int = None) -> int:\n    if n is not None and isinstance(n, int) and 1 <= n <= 10000:\n        return (n - 1) ** 2 + n ** 2\n    return 0",
    "detail": "_ALL_PY.shape_area",
    "documentation": {}
  },
  {
    "label": "alphabeticShift",
    "kind": 2,
    "importPath": "_ALL_PY.Shift",
    "description": "_ALL_PY.Shift",
    "peekOfCode": "def alphabeticShift(inputString):\n    return \"\".join(chr(ord(i) + 1) if i != \"z\" else \"a\" for i in inputString)",
    "detail": "_ALL_PY.Shift",
    "documentation": {}
  },
  {
    "label": "areSimilar",
    "kind": 2,
    "importPath": "_ALL_PY.Similar",
    "description": "_ALL_PY.Similar",
    "peekOfCode": "def areSimilar(a, b):\n    check_a = []\n    check_b = []\n    count = 0\n    for i in range(len(a)):\n        if a[i] != b[i]:\n            count += 1\n            check_a.append(a[i])\n            check_b.append(b[i])\n    if count == 0:",
    "detail": "_ALL_PY.Similar",
    "documentation": {}
  },
  {
    "label": "singlePointOfFailure",
    "kind": 2,
    "importPath": "_ALL_PY.singlePointOfFailure",
    "description": "_ALL_PY.singlePointOfFailure",
    "peekOfCode": "def singlePointOfFailure(connections):\n    size = len(connections)\n    total = 0\n    if size == 1:\n        return total\n    # print(connections)\n    cuttable_nodes = set()\n    cut_segments = {}\n    single_edges = set()\n    while anySingleEdges(connections):",
    "detail": "_ALL_PY.singlePointOfFailure",
    "documentation": {}
  },
  {
    "label": "anySingleEdges",
    "kind": 2,
    "importPath": "_ALL_PY.singlePointOfFailure",
    "description": "_ALL_PY.singlePointOfFailure",
    "peekOfCode": "def anySingleEdges(adj_matrix):\n    for item in adj_matrix:\n        if sum(item) == 1:\n            return True\n    return False\ndef remove_empty_nodes(adj_matrix, nodes):\n    if len(nodes) == 0:\n        return adj_matrix\n    removals = list(nodes)\n    print(removals)",
    "detail": "_ALL_PY.singlePointOfFailure",
    "documentation": {}
  },
  {
    "label": "remove_empty_nodes",
    "kind": 2,
    "importPath": "_ALL_PY.singlePointOfFailure",
    "description": "_ALL_PY.singlePointOfFailure",
    "peekOfCode": "def remove_empty_nodes(adj_matrix, nodes):\n    if len(nodes) == 0:\n        return adj_matrix\n    removals = list(nodes)\n    print(removals)\n    removals.sort()\n    removals.reverse()\n    for item in removals:\n        for i, node in enumerate(adj_matrix):\n            if i == item:",
    "detail": "_ALL_PY.singlePointOfFailure",
    "documentation": {}
  },
  {
    "label": "remove_node",
    "kind": 2,
    "importPath": "_ALL_PY.singlePointOfFailure",
    "description": "_ALL_PY.singlePointOfFailure",
    "peekOfCode": "def remove_node(node, adj_matrix):\n    size = len(adj_matrix)\n    indices = set()\n    for i, a in enumerate(adj_matrix[node]):\n        if a == 1:\n            indices.add(i)\n    output = []\n    for i, item in enumerate(adj_matrix):\n        if i == node:\n            this_row = [0 for l in range(size)]",
    "detail": "_ALL_PY.singlePointOfFailure",
    "documentation": {}
  },
  {
    "label": "adjacency_matrix_BFS",
    "kind": 2,
    "importPath": "_ALL_PY.singlePointOfFailure",
    "description": "_ALL_PY.singlePointOfFailure",
    "peekOfCode": "def adjacency_matrix_BFS(node, adj_matrix):\n    seen = set()\n    seen.add(node)\n    queue = [i for i, a in enumerate(adj_matrix[node]) if a == 1]\n    while queue:\n        curr_node = queue.pop(0)\n        seen.add(curr_node)\n        new_items = [\n            i for i, a in enumerate(adj_matrix[curr_node]) if a == 1 and not i in seen\n        ]",
    "detail": "_ALL_PY.singlePointOfFailure",
    "documentation": {}
  },
  {
    "label": "connections",
    "kind": 5,
    "importPath": "_ALL_PY.singlePointOfFailure",
    "description": "_ALL_PY.singlePointOfFailure",
    "peekOfCode": "connections = [\n    [0, 1, 1, 0, 0, 0, 0],\n    [1, 0, 1, 0, 0, 0, 0],\n    [1, 1, 0, 0, 0, 0, 1],\n    [0, 0, 0, 0, 1, 1, 1],\n    [0, 0, 0, 1, 0, 1, 0],\n    [0, 0, 0, 1, 1, 0, 0],\n    [0, 0, 1, 1, 0, 0, 0],\n]\ntest8 = [",
    "detail": "_ALL_PY.singlePointOfFailure",
    "documentation": {}
  },
  {
    "label": "test8",
    "kind": 5,
    "importPath": "_ALL_PY.singlePointOfFailure",
    "description": "_ALL_PY.singlePointOfFailure",
    "peekOfCode": "test8 = [\n    [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],\n    [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0],\n    [0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0],\n    [0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],",
    "detail": "_ALL_PY.singlePointOfFailure",
    "documentation": {}
  },
  {
    "label": "smallestMultiple",
    "kind": 2,
    "importPath": "_ALL_PY.smallestMultiple",
    "description": "_ALL_PY.smallestMultiple",
    "peekOfCode": "def smallestMultiple(l ,r):\n    for i in range(1, 16):\n        for j in range(l, r+1):\n            while True:\n                if i % j != 0:\n                    break\n            return i",
    "detail": "_ALL_PY.smallestMultiple",
    "documentation": {}
  },
  {
    "label": "drawRectangle",
    "kind": 2,
    "importPath": "_ALL_PY.solution (10)",
    "description": "_ALL_PY.solution (10)",
    "peekOfCode": "def drawRectangle(canvas, r):\n    x, y, x1, y1 = r\n    canvas[x][y], canvas[x][y1 + y], canvas[x1][y], canvas[x1][y + y1] = [\"*\"] * 4\n    for j in range(y + 1, y + y1):\n        canvas[x][j] = \"|\"\n        canvas[x1][j] = \"|\"\n    return canvas\ncanvas = [\n    [\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"],\n    [\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"],",
    "detail": "_ALL_PY.solution (10)",
    "documentation": {}
  },
  {
    "label": "canvas",
    "kind": 5,
    "importPath": "_ALL_PY.solution (10)",
    "description": "_ALL_PY.solution (10)",
    "peekOfCode": "canvas = [\n    [\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"],\n    [\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"],\n    [\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"],\n    [\"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\"],\n    [\"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\"],\n]\nrectangle = [1, 1, 4, 3]\nprint(drawRectangle(canvas, rectangle))",
    "detail": "_ALL_PY.solution (10)",
    "documentation": {}
  },
  {
    "label": "rectangle",
    "kind": 5,
    "importPath": "_ALL_PY.solution (10)",
    "description": "_ALL_PY.solution (10)",
    "peekOfCode": "rectangle = [1, 1, 4, 3]\nprint(drawRectangle(canvas, rectangle))",
    "detail": "_ALL_PY.solution (10)",
    "documentation": {}
  },
  {
    "label": "countPalindromes",
    "kind": 2,
    "importPath": "_ALL_PY.solution (11)",
    "description": "_ALL_PY.solution (11)",
    "peekOfCode": "def countPalindromes(s):\n    \"\"\"\n    countPalindromes(s) takes in a string s and returns the number of palindrome in the string\n    :param s: a string\n    :return: number of palindrome sub strings\n    \"\"\"\n    tot_pal = len(s)\n    for i in range(len(s)):\n        tot_pal += helper(s, i, i + 1)\n        tot_pal += helper(s, i - 1, i + 1)",
    "detail": "_ALL_PY.solution (11)",
    "documentation": {}
  },
  {
    "label": "helper",
    "kind": 2,
    "importPath": "_ALL_PY.solution (11)",
    "description": "_ALL_PY.solution (11)",
    "peekOfCode": "def helper(s, l, r):\n    tot = 0\n    while (l >= 0) and (r < len(s)) and (s[l] == s[r]):\n        tot += 1\n        l -= 1\n        r += 1\n    return tot\nprint(countPalindromes(\"aaa\"))",
    "detail": "_ALL_PY.solution (11)",
    "documentation": {}
  },
  {
    "label": "reverseInParentheses",
    "kind": 2,
    "importPath": "_ALL_PY.solution (12)",
    "description": "_ALL_PY.solution (12)",
    "peekOfCode": "def reverseInParentheses(s):\n    \"\"\"\n    takes in a string that has substrings inside Parentheses, return a string with all substrings inside the Parentheses\n    reversed\n    \"\"\"\n    stack = []\n    for i in s:\n        if i == \")\":\n            ind = len(stack) - 1\n            while stack[ind] != \"(\":",
    "detail": "_ALL_PY.solution (12)",
    "documentation": {}
  },
  {
    "label": "boxBlur",
    "kind": 2,
    "importPath": "_ALL_PY.solution (13)",
    "description": "_ALL_PY.solution (13)",
    "peekOfCode": "def boxBlur(image):\n    out = []\n    for i in range(len(image) - 2):\n        out.append(\n            [\n                (\n                    sum(image[i][j : j + 3])\n                    + sum(image[i + 1][j : j + 3])\n                    + sum(image[i + 2][j : j + 3])\n                )",
    "detail": "_ALL_PY.solution (13)",
    "documentation": {}
  },
  {
    "label": "image",
    "kind": 5,
    "importPath": "_ALL_PY.solution (13)",
    "description": "_ALL_PY.solution (13)",
    "peekOfCode": "image = [[7, 4, 0, 1], [5, 6, 2, 2], [6, 10, 7, 8], [1, 4, 2, 0]]\nprint(boxBlur(image))",
    "detail": "_ALL_PY.solution (13)",
    "documentation": {}
  },
  {
    "label": "twoSum",
    "kind": 2,
    "importPath": "_ALL_PY.solution (14)",
    "description": "_ALL_PY.solution (14)",
    "peekOfCode": "def twoSum(nums, target):\n    \"\"\"\n    Given an array of integers, return indices of the two numbers such that they add up to a specific target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    \"\"\"\n    h = {}\n    for i, v in enumerate(nums):\n        if v in h:\n            return [h[v], i]\n        else:",
    "detail": "_ALL_PY.solution (14)",
    "documentation": {}
  },
  {
    "label": "nums",
    "kind": 5,
    "importPath": "_ALL_PY.solution (14)",
    "description": "_ALL_PY.solution (14)",
    "peekOfCode": "nums = [2, 7, 11, 15]\ntarget = 9\nprint(twoSum(nums, target))",
    "detail": "_ALL_PY.solution (14)",
    "documentation": {}
  },
  {
    "label": "target",
    "kind": 5,
    "importPath": "_ALL_PY.solution (14)",
    "description": "_ALL_PY.solution (14)",
    "peekOfCode": "target = 9\nprint(twoSum(nums, target))",
    "detail": "_ALL_PY.solution (14)",
    "documentation": {}
  },
  {
    "label": "shortestSubstring",
    "kind": 2,
    "importPath": "_ALL_PY.solution (15)",
    "description": "_ALL_PY.solution (15)",
    "peekOfCode": "def shortestSubstring(s):\n    diff_chars, start, big = len(set(s)), 0, len(s)\n    end = diff_chars\n    while end <= len(s):\n        curr = len(set(s[start:end]))\n        if curr == diff_chars:\n            if end - start < big:\n                big = end - start\n            start += 1\n        else:",
    "detail": "_ALL_PY.solution (15)",
    "documentation": {}
  },
  {
    "label": "minX",
    "kind": 2,
    "importPath": "_ALL_PY.solution (16)",
    "description": "_ALL_PY.solution (16)",
    "peekOfCode": "def minX(arr):\n    \"\"\"\n    given an arr, get the min number that can keep the running sum greater than or equal to 1\n    \"\"\"\n    m = min(arr)\n    if m > 0:\n        return (m * -1) + 1\n    else:\n        m = (m * -1) + 1\n    running_sum = m",
    "detail": "_ALL_PY.solution (16)",
    "documentation": {}
  },
  {
    "label": "arr",
    "kind": 5,
    "importPath": "_ALL_PY.solution (16)",
    "description": "_ALL_PY.solution (16)",
    "peekOfCode": "arr = [-5, -2, -4]\nprint(minX(arr))",
    "detail": "_ALL_PY.solution (16)",
    "documentation": {}
  },
  {
    "label": "minimumOnStack",
    "kind": 2,
    "importPath": "_ALL_PY.solution (17)",
    "description": "_ALL_PY.solution (17)",
    "peekOfCode": "def minimumOnStack(operations):\n    l = []\n    out = []\n    for i in operations:\n        if \"push\" in i:\n            l.append(int(i[i.index(\" \") + 1 :]))\n        elif \"pop\" in i:\n            l.pop()\n        else:\n            out.append(min(l))",
    "detail": "_ALL_PY.solution (17)",
    "documentation": {}
  },
  {
    "label": "operations",
    "kind": 5,
    "importPath": "_ALL_PY.solution (17)",
    "description": "_ALL_PY.solution (17)",
    "peekOfCode": "operations = [\n    \"push 10\",\n    \"min\",\n    \"push 5\",\n    \"min\",\n    \"push 8\",\n    \"min\",\n    \"pop\",\n    \"min\",\n    \"pop\",",
    "detail": "_ALL_PY.solution (17)",
    "documentation": {}
  },
  {
    "label": "areFollowingPatterns",
    "kind": 2,
    "importPath": "_ALL_PY.solution (18)",
    "description": "_ALL_PY.solution (18)",
    "peekOfCode": "def areFollowingPatterns(strings, patterns):\n    d = {}\n    for ele in range(len(strings)):\n        if d.get(strings[ele]):\n            if d[strings[ele]] != patterns[ele]:\n                return False\n        elif patterns[ele] in d.values():\n            return False\n        else:\n            d[strings[ele]] = patterns[ele]",
    "detail": "_ALL_PY.solution (18)",
    "documentation": {}
  },
  {
    "label": "strings",
    "kind": 5,
    "importPath": "_ALL_PY.solution (18)",
    "description": "_ALL_PY.solution (18)",
    "peekOfCode": "strings = [\"cat\", \"dog\", \"doggy\"]\npatterns = [\"a\", \"b\", \"b\"]\nprint(areFollowingPatterns(strings, patterns))",
    "detail": "_ALL_PY.solution (18)",
    "documentation": {}
  },
  {
    "label": "patterns",
    "kind": 5,
    "importPath": "_ALL_PY.solution (18)",
    "description": "_ALL_PY.solution (18)",
    "peekOfCode": "patterns = [\"a\", \"b\", \"b\"]\nprint(areFollowingPatterns(strings, patterns))",
    "detail": "_ALL_PY.solution (18)",
    "documentation": {}
  },
  {
    "label": "letter_combinations",
    "kind": 2,
    "importPath": "_ALL_PY.solution (19)",
    "description": "_ALL_PY.solution (19)",
    "peekOfCode": "def letter_combinations(digits):\n    m = {\n        \"2\": \"abc\",\n        \"3\": \"def\",\n        \"4\": \"ghi\",\n        \"5\": \"jkl\",\n        \"6\": \"mno\",\n        \"7\": \"pqrs\",\n        \"8\": \"tuv\",\n        \"9\": \"wxyz\",",
    "detail": "_ALL_PY.solution (19)",
    "documentation": {}
  },
  {
    "label": "sudoku2",
    "kind": 2,
    "importPath": "_ALL_PY.solution (2)",
    "description": "_ALL_PY.solution (2)",
    "peekOfCode": "def sudoku2(grid):\n    \"\"\"\n    check if sudoku board is true by checking that the same number didn't appear more than one in its row, col,\n    surrounding 3*3 sub matrix\n    \"\"\"\n    for i in range(9):\n        for j in range(9):\n            if i % 3 == 0 and j % 3 == 0:\n                l = [\n                    grid[s_i][s_j]",
    "detail": "_ALL_PY.solution (2)",
    "documentation": {}
  },
  {
    "label": "grid",
    "kind": 5,
    "importPath": "_ALL_PY.solution (2)",
    "description": "_ALL_PY.solution (2)",
    "peekOfCode": "grid = [\n    [\".\", \".\", \"5\", \".\", \".\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \"8\", \".\", \".\", \".\", \"3\", \".\"],\n    [\".\", \"5\", \".\", \".\", \"2\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \"9\"],\n    [\".\", \".\", \".\", \".\", \".\", \".\", \"4\", \".\", \".\"],\n    [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \"7\"],\n    [\".\", \"1\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n    [\"2\", \"4\", \".\", \".\", \".\", \".\", \"9\", \".\", \".\"],",
    "detail": "_ALL_PY.solution (2)",
    "documentation": {}
  },
  {
    "label": "almostIncreasingSequence",
    "kind": 2,
    "importPath": "_ALL_PY.solution (20)",
    "description": "_ALL_PY.solution (20)",
    "peekOfCode": "def almostIncreasingSequence(sequence):\n    for ind in range(len(sequence) - 1):\n        if sequence[ind] < sequence[ind + 1]:\n            continue\n        else:\n            if sequence.count(sequence[ind + 1]) > 1:\n                sequence.pop(ind + 1)\n            else:\n                sequence.pop(ind + 1)\n        return sequence == sorted(list(set(sequence)))",
    "detail": "_ALL_PY.solution (20)",
    "documentation": {}
  },
  {
    "label": "sensorsDifferenceSum",
    "kind": 2,
    "importPath": "_ALL_PY.solution (21)",
    "description": "_ALL_PY.solution (21)",
    "peekOfCode": "def sensorsDifferenceSum(sensor_1, sensor_2):\n    \"\"\"\n    given two lists contains the reading of two sensors for the same place, give the total difference between\n    there elements\n    \"\"\"\n    if len(sensor_1) == 0 or len(sensor_2) == 0:\n        return 0\n    return abs(sensor_1[0] - sensor_2[0]) + sensorsDifferenceSum(\n        sensor_1[1:], sensor_2[1:]\n    )",
    "detail": "_ALL_PY.solution (21)",
    "documentation": {}
  },
  {
    "label": "matrix_elements_sum",
    "kind": 2,
    "importPath": "_ALL_PY.solution (22)",
    "description": "_ALL_PY.solution (22)",
    "peekOfCode": "def matrix_elements_sum(matrix):\n    hunted = []\n    total = 0\n    ran = len(matrix[0])\n    for row in matrix:\n        for no in range(ran):\n            if no in hunted:\n                continue\n            elif row[no] == 0:\n                hunted.append(no)",
    "detail": "_ALL_PY.solution (22)",
    "documentation": {}
  },
  {
    "label": "swapDiagonals",
    "kind": 2,
    "importPath": "_ALL_PY.solution (24)",
    "description": "_ALL_PY.solution (24)",
    "peekOfCode": "def swapDiagonals(matrix):\n    j = len(matrix) - 1\n    for i in range(len(matrix) // 2):\n        matrix[i][i], matrix[i][j - i] = matrix[i][j - i], matrix[i][i]\n        matrix[j - i][j - i], matrix[j - i][i] = matrix[j - i][i], matrix[j - i][j - i]\n    return matrix\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(swapDiagonals(matrix))",
    "detail": "_ALL_PY.solution (24)",
    "documentation": {}
  },
  {
    "label": "matrix",
    "kind": 5,
    "importPath": "_ALL_PY.solution (24)",
    "description": "_ALL_PY.solution (24)",
    "peekOfCode": "matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(swapDiagonals(matrix))",
    "detail": "_ALL_PY.solution (24)",
    "documentation": {}
  },
  {
    "label": "binarySearch",
    "kind": 2,
    "importPath": "_ALL_PY.solution (25)",
    "description": "_ALL_PY.solution (25)",
    "peekOfCode": "def binarySearch(arr, searchValue):\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] < searchValue:\n            low = mid + 1\n        elif arr[mid] > searchValue:\n            high = mid - 1\n        else:",
    "detail": "_ALL_PY.solution (25)",
    "documentation": {}
  },
  {
    "label": "binarySearchRec",
    "kind": 2,
    "importPath": "_ALL_PY.solution (25)",
    "description": "_ALL_PY.solution (25)",
    "peekOfCode": "def binarySearchRec(arr, search_value):\n    if len(arr) == 0:\n        return False",
    "detail": "_ALL_PY.solution (25)",
    "documentation": {}
  },
  {
    "label": "check",
    "kind": 2,
    "importPath": "_ALL_PY.solution (26)",
    "description": "_ALL_PY.solution (26)",
    "peekOfCode": "def check(first, second, target):\n    while first < target:\n        first += second\n    return first\ndef isPossible(a, b, c, d):\n    # Write your code here\n    if c < d:\n        a = check(a, b, c)\n        b = check(b, a, d)\n    else:",
    "detail": "_ALL_PY.solution (26)",
    "documentation": {}
  },
  {
    "label": "isPossible",
    "kind": 2,
    "importPath": "_ALL_PY.solution (26)",
    "description": "_ALL_PY.solution (26)",
    "peekOfCode": "def isPossible(a, b, c, d):\n    # Write your code here\n    if c < d:\n        a = check(a, b, c)\n        b = check(b, a, d)\n    else:\n        b = check(b, a, d)\n        a = check(a, b, c)\n    if a != c or b != d:\n        return \"No\"",
    "detail": "_ALL_PY.solution (26)",
    "documentation": {}
  },
  {
    "label": "isLucky",
    "kind": 2,
    "importPath": "_ALL_PY.solution (27)",
    "description": "_ALL_PY.solution (27)",
    "peekOfCode": "def isLucky(n):\n    \"\"\"\n    isLucky takes in an integer and return True if the sum of its right half == sum of the\n     right half\n    :param n:\n    :return:\n    \"\"\"\n    # l = list(map(int, str(n)))\n    # return sum(l[0:len(l) // 2]) == sum(l[len(l) // 2:])\n    s = str(n)",
    "detail": "_ALL_PY.solution (27)",
    "documentation": {}
  },
  {
    "label": "n",
    "kind": 5,
    "importPath": "_ALL_PY.solution (27)",
    "description": "_ALL_PY.solution (27)",
    "peekOfCode": "n = 1230\nprint(isLucky(n))",
    "detail": "_ALL_PY.solution (27)",
    "documentation": {}
  },
  {
    "label": "subarraySum",
    "kind": 2,
    "importPath": "_ALL_PY.solution (28)",
    "description": "_ALL_PY.solution (28)",
    "peekOfCode": "def subarraySum(nums, k):\n    \"\"\"\n    Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.\n    \"\"\"\n    count = 0\n    s = 0\n    for i in range(len(nums)):\n        s += nums[i]\n        if s % k == 0:\n            count += 1",
    "detail": "_ALL_PY.solution (28)",
    "documentation": {}
  },
  {
    "label": "nums",
    "kind": 5,
    "importPath": "_ALL_PY.solution (28)",
    "description": "_ALL_PY.solution (28)",
    "peekOfCode": "nums = [1, 2, 3]\nk = 3\nprint(subarraySum(nums, k))",
    "detail": "_ALL_PY.solution (28)",
    "documentation": {}
  },
  {
    "label": "k",
    "kind": 5,
    "importPath": "_ALL_PY.solution (28)",
    "description": "_ALL_PY.solution (28)",
    "peekOfCode": "k = 3\nprint(subarraySum(nums, k))",
    "detail": "_ALL_PY.solution (28)",
    "documentation": {}
  },
  {
    "label": "beautifulText",
    "kind": 2,
    "importPath": "_ALL_PY.solution (29)",
    "description": "_ALL_PY.solution (29)",
    "peekOfCode": "def beautifulText(inputString, l, r):\n    for w in range(l, r + 1):\n        i = w\n        while i < len(inputString):\n            if inputString[i] != \" \":\n                break\n            i += w + 1\n        if i == len(inputString):\n            return True\n    return False",
    "detail": "_ALL_PY.solution (29)",
    "documentation": {}
  },
  {
    "label": "s",
    "kind": 5,
    "importPath": "_ALL_PY.solution (29)",
    "description": "_ALL_PY.solution (29)",
    "peekOfCode": "s = \"Look at this example of a correct text\"\nprint(beautifulText(s, 5, 15))",
    "detail": "_ALL_PY.solution (29)",
    "documentation": {}
  },
  {
    "label": "onesGroups",
    "kind": 2,
    "importPath": "_ALL_PY.solution (3)",
    "description": "_ALL_PY.solution (3)",
    "peekOfCode": "def onesGroups(grid, quires):\n    # global tot\n    ans = defaultdict(int)\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                # tot = 0\n                tot = dfs(grid, i, j, 0)\n                ans[tot] += 1\n    for i in range(len(quires)):",
    "detail": "_ALL_PY.solution (3)",
    "documentation": {}
  },
  {
    "label": "dfs",
    "kind": 2,
    "importPath": "_ALL_PY.solution (3)",
    "description": "_ALL_PY.solution (3)",
    "peekOfCode": "def dfs(grid, i, j, tot):\n    # using global tot, to not be considered in the recursive stack\n    # global tot\n    if (\n        (i < 0)\n        or (j < 0)\n        or (j >= len(grid[0]))\n        or (i >= len(grid))\n        or (grid[i][j] == 0)\n    ):",
    "detail": "_ALL_PY.solution (3)",
    "documentation": {}
  },
  {
    "label": "grid",
    "kind": 5,
    "importPath": "_ALL_PY.solution (3)",
    "description": "_ALL_PY.solution (3)",
    "peekOfCode": "grid = [[1, 1, 1, 0, 0], [1, 1, 1, 0, 1], [0, 0, 0, 1, 0]]\nquires = [1, 2, 6]\nprint(onesGroups(grid, quires))",
    "detail": "_ALL_PY.solution (3)",
    "documentation": {}
  },
  {
    "label": "quires",
    "kind": 5,
    "importPath": "_ALL_PY.solution (3)",
    "description": "_ALL_PY.solution (3)",
    "peekOfCode": "quires = [1, 2, 6]\nprint(onesGroups(grid, quires))",
    "detail": "_ALL_PY.solution (3)",
    "documentation": {}
  },
  {
    "label": "s",
    "kind": 5,
    "importPath": "_ALL_PY.solution (31)",
    "description": "_ALL_PY.solution (31)",
    "peekOfCode": "s = set()\ns.add(123)\ns.add(123)\nprint(s)",
    "detail": "_ALL_PY.solution (31)",
    "documentation": {}
  },
  {
    "label": "fileNaming",
    "kind": 2,
    "importPath": "_ALL_PY.solution (32)",
    "description": "_ALL_PY.solution (32)",
    "peekOfCode": "def fileNaming(names):\n    for i in range(1, len(names)):\n        temp = names[i]\n        counter = 1\n        while temp in names[0:i]:\n            temp = f\"{names[i]}({counter})\"\n            counter += 1\n        names[i] = temp\n    return names\nprint(fileNaming([\"doc\", \"doc\", \"image\", \"doc(1)\", \"doc\"]))",
    "detail": "_ALL_PY.solution (32)",
    "documentation": {}
  },
  {
    "label": "regularMonths",
    "kind": 2,
    "importPath": "_ALL_PY.solution (33)",
    "description": "_ALL_PY.solution (33)",
    "peekOfCode": "def regularMonths(c):\n    m, y = map(int, c.split(\"-\"))\n    while y:\n        for m in range(m + 1, 12 + 1):\n            if w(y, m, 1) == 0:\n                return f\"{str(m).zfill(2)}-{y}\"\n        m, y = 0, y + 1\nprint(regularMonths(\"07-2024\"))",
    "detail": "_ALL_PY.solution (33)",
    "documentation": {}
  },
  {
    "label": "extractMatrixColumn",
    "kind": 2,
    "importPath": "_ALL_PY.solution (34)",
    "description": "_ALL_PY.solution (34)",
    "peekOfCode": "def extractMatrixColumn(matrix, col):\n    return [matrix[i][col] for i in range(len(matrix))]\nmatrix = [[1, 1, 1, 2], [0, 5, 0, 4], [2, 1, 3, 6]]\nprint(extractMatrixColumn(matrix, 2))",
    "detail": "_ALL_PY.solution (34)",
    "documentation": {}
  },
  {
    "label": "matrix",
    "kind": 5,
    "importPath": "_ALL_PY.solution (34)",
    "description": "_ALL_PY.solution (34)",
    "peekOfCode": "matrix = [[1, 1, 1, 2], [0, 5, 0, 4], [2, 1, 3, 6]]\nprint(extractMatrixColumn(matrix, 2))",
    "detail": "_ALL_PY.solution (34)",
    "documentation": {}
  },
  {
    "label": "rotateImage",
    "kind": 2,
    "importPath": "_ALL_PY.solution (35)",
    "description": "_ALL_PY.solution (35)",
    "peekOfCode": "def rotateImage(a):\n    if a == None:\n        return None\n    a.reverse()\n    for i in range(len(a)):\n        for j in range(i):\n            a[i][j], a[j][i] = a[j][i], a[i][j]\n    return a\nmat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(rotateImage(mat))",
    "detail": "_ALL_PY.solution (35)",
    "documentation": {}
  },
  {
    "label": "mat",
    "kind": 5,
    "importPath": "_ALL_PY.solution (35)",
    "description": "_ALL_PY.solution (35)",
    "peekOfCode": "mat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(rotateImage(mat))",
    "detail": "_ALL_PY.solution (35)",
    "documentation": {}
  },
  {
    "label": "amendTheSentence",
    "kind": 2,
    "importPath": "_ALL_PY.solution (36)",
    "description": "_ALL_PY.solution (36)",
    "peekOfCode": "def amendTheSentence(s):\n    out_s = s[0].lower()\n    for char in s[1:]:\n        if char.islower():\n            out_s += char\n        else:\n            out_s += \" \" + char.lower()\n    return out_s\ns = \"AHMm\"\nprint(amendTheSentence(s))",
    "detail": "_ALL_PY.solution (36)",
    "documentation": {}
  },
  {
    "label": "s",
    "kind": 5,
    "importPath": "_ALL_PY.solution (36)",
    "description": "_ALL_PY.solution (36)",
    "peekOfCode": "s = \"AHMm\"\nprint(amendTheSentence(s))",
    "detail": "_ALL_PY.solution (36)",
    "documentation": {}
  },
  {
    "label": "isSentenceCorrect",
    "kind": 2,
    "importPath": "_ALL_PY.solution (37)",
    "description": "_ALL_PY.solution (37)",
    "peekOfCode": "def isSentenceCorrect(sentence):\n    pattern = \"^[A-Z][^?!.]*[?.!]$\"\n    return re.match(pattern, sentence) is not None\nprint(isSentenceCorrect(\"This is an example of *correct* sentence!\"))",
    "detail": "_ALL_PY.solution (37)",
    "documentation": {}
  },
  {
    "label": "nthNumber",
    "kind": 2,
    "importPath": "_ALL_PY.solution (38)",
    "description": "_ALL_PY.solution (38)",
    "peekOfCode": "def nthNumber(s, n):\n    pattern = rf\"([0-9]+){n}\"\n    return re.match(pattern, s).group(1)\ns = \"8one 003number 201numbers li-000233le number4443\"\nn = 4\nprint(nthNumber(s, n))",
    "detail": "_ALL_PY.solution (38)",
    "documentation": {}
  },
  {
    "label": "s",
    "kind": 5,
    "importPath": "_ALL_PY.solution (38)",
    "description": "_ALL_PY.solution (38)",
    "peekOfCode": "s = \"8one 003number 201numbers li-000233le number4443\"\nn = 4\nprint(nthNumber(s, n))",
    "detail": "_ALL_PY.solution (38)",
    "documentation": {}
  },
  {
    "label": "n",
    "kind": 5,
    "importPath": "_ALL_PY.solution (38)",
    "description": "_ALL_PY.solution (38)",
    "peekOfCode": "n = 4\nprint(nthNumber(s, n))",
    "detail": "_ALL_PY.solution (38)",
    "documentation": {}
  },
  {
    "label": "rodCutting",
    "kind": 2,
    "importPath": "_ALL_PY.solution (39)",
    "description": "_ALL_PY.solution (39)",
    "peekOfCode": "def rodCutting(n, v):\n    a = v\n    for _ in a:\n        a = list(map(max, a, (a[0] + y for y in v)))\n        x = a.pop(0)\n    return x\nn = 4\nv = [0, 2, 4, 7, 7]\nprint(rodCutting(n, v))",
    "detail": "_ALL_PY.solution (39)",
    "documentation": {}
  },
  {
    "label": "n",
    "kind": 5,
    "importPath": "_ALL_PY.solution (39)",
    "description": "_ALL_PY.solution (39)",
    "peekOfCode": "n = 4\nv = [0, 2, 4, 7, 7]\nprint(rodCutting(n, v))",
    "detail": "_ALL_PY.solution (39)",
    "documentation": {}
  },
  {
    "label": "v",
    "kind": 5,
    "importPath": "_ALL_PY.solution (39)",
    "description": "_ALL_PY.solution (39)",
    "peekOfCode": "v = [0, 2, 4, 7, 7]\nprint(rodCutting(n, v))",
    "detail": "_ALL_PY.solution (39)",
    "documentation": {}
  },
  {
    "label": "findLower",
    "kind": 2,
    "importPath": "_ALL_PY.solution (4)",
    "description": "_ALL_PY.solution (4)",
    "peekOfCode": "def findLower(scores, len_score, v):\n    l = 0\n    u = len_score - 1\n    while l <= u:\n        mid = (l + u) // 2\n        if scores[mid] >= v:\n            u = mid - 1\n        else:\n            l = mid + 1\n    return l",
    "detail": "_ALL_PY.solution (4)",
    "documentation": {}
  },
  {
    "label": "findUpper",
    "kind": 2,
    "importPath": "_ALL_PY.solution (4)",
    "description": "_ALL_PY.solution (4)",
    "peekOfCode": "def findUpper(scores, len_score, v):\n    l = 0\n    u = len_score - 1\n    while l <= u:\n        mid = (l + u) // 2\n        if scores[mid] > v:\n            u = mid - 1\n        else:\n            l = mid + 1\n    return u",
    "detail": "_ALL_PY.solution (4)",
    "documentation": {}
  },
  {
    "label": "jobOffers",
    "kind": 2,
    "importPath": "_ALL_PY.solution (4)",
    "description": "_ALL_PY.solution (4)",
    "peekOfCode": "def jobOffers(scores, lowerLimits, upperLimits):\n    scores.sort()\n    n = len(scores)\n    for index in range(len(lowerLimits)):\n        yield findUpper(scores, n, upperLimits[index]) - findLower(\n            scores, n, lowerLimits[index]\n        ) + 1\nfor i in jobOffers([1, 2, 2, 3, 5, 6, 7], [1], [7]):\n    print(i)",
    "detail": "_ALL_PY.solution (4)",
    "documentation": {}
  },
  {
    "label": "powerOfTwo",
    "kind": 2,
    "importPath": "_ALL_PY.solution (40)",
    "description": "_ALL_PY.solution (40)",
    "peekOfCode": "def powerOfTwo(n):\n    if n < 1:\n        return []\n    l = [1]\n    i = 1\n    while i + i <= n:\n        i += i\n        l.append(i)\n    return l\nprint(powerOfTwo(10))",
    "detail": "_ALL_PY.solution (40)",
    "documentation": {}
  },
  {
    "label": "stringPermutations",
    "kind": 2,
    "importPath": "_ALL_PY.solution (41)",
    "description": "_ALL_PY.solution (41)",
    "peekOfCode": "def stringPermutations(s):\n    return sorted(list({\"\".join(itm) for itm in permutations(s)}))\nprint(stringPermutations(\"CDA\"))",
    "detail": "_ALL_PY.solution (41)",
    "documentation": {}
  },
  {
    "label": "rec_bin",
    "kind": 2,
    "importPath": "_ALL_PY.solution (43)",
    "description": "_ALL_PY.solution (43)",
    "peekOfCode": "def rec_bin(n):\n    if n == 0:\n        return \"\"\n    else:\n        return str(n % 2) + rec_bin(n // 2)\nprint(rec_bin(20))\nprint(bin(20)[2:])",
    "detail": "_ALL_PY.solution (43)",
    "documentation": {}
  },
  {
    "label": "swapAdjacentWords",
    "kind": 2,
    "importPath": "_ALL_PY.solution (44)",
    "description": "_ALL_PY.solution (44)",
    "peekOfCode": "def swapAdjacentWords(s):\n    return re.sub(r\"(\\w+) (\\w+)\", r\"\\2 \\1\", s)\ns = \"How are you guys?\"\nprint(swapAdjacentWords(s))",
    "detail": "_ALL_PY.solution (44)",
    "documentation": {}
  },
  {
    "label": "s",
    "kind": 5,
    "importPath": "_ALL_PY.solution (44)",
    "description": "_ALL_PY.solution (44)",
    "peekOfCode": "s = \"How are you guys?\"\nprint(swapAdjacentWords(s))",
    "detail": "_ALL_PY.solution (44)",
    "documentation": {}
  },
  {
    "label": "alternate",
    "kind": 2,
    "importPath": "_ALL_PY.solution (5)",
    "description": "_ALL_PY.solution (5)",
    "peekOfCode": "def alternate(s):\n    d = Counter(s)\n    i = 0\n    # validate that each letter is not duplicate next to itself\n    while i < len(s):\n        if s[i] in d:\n            if i + 1 < len(s) and s[i + 1] == s[i]:\n                del d[s[i]]\n        i += 1\n    occ = d.values()",
    "detail": "_ALL_PY.solution (5)",
    "documentation": {}
  },
  {
    "label": "fib",
    "kind": 2,
    "importPath": "_ALL_PY.solution (6)",
    "description": "_ALL_PY.solution (6)",
    "peekOfCode": "def fib(N):\n    \"\"\"\n    Avoid redoing the something over and over and store any Fib in a dictionary\n    to not do it again\n    Time: o(n)\n    \"\"\"\n    memo = {}\n    if N in memo:\n        return memo[N]\n    if N <= 2:",
    "detail": "_ALL_PY.solution (6)",
    "documentation": {}
  },
  {
    "label": "stepPerms",
    "kind": 2,
    "importPath": "_ALL_PY.solution (7)",
    "description": "_ALL_PY.solution (7)",
    "peekOfCode": "def stepPerms(n):\n    \"\"\"\n    given n number of stairs, determine the total number of ways to climb the\n    stairs if you can take 1, 2, or 3 steps at a time\n    \"\"\"\n    if n < 0:\n        return 0\n    if n == 0:\n        return 1\n    else:",
    "detail": "_ALL_PY.solution (7)",
    "documentation": {}
  },
  {
    "label": "stepPermsDP",
    "kind": 2,
    "importPath": "_ALL_PY.solution (7)",
    "description": "_ALL_PY.solution (7)",
    "peekOfCode": "def stepPermsDP(n):\n    \"\"\"\n    given n number of stairs, determine the total number of ways to climb the\n    stairs if you can take 1, 2, or 3 steps at a time\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    if n < 0:\n        return 0\n    if n == 0:",
    "detail": "_ALL_PY.solution (7)",
    "documentation": {}
  },
  {
    "label": "memo",
    "kind": 5,
    "importPath": "_ALL_PY.solution (7)",
    "description": "_ALL_PY.solution (7)",
    "peekOfCode": "memo = {}\ndef stepPermsDP(n):\n    \"\"\"\n    given n number of stairs, determine the total number of ways to climb the\n    stairs if you can take 1, 2, or 3 steps at a time\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    if n < 0:\n        return 0",
    "detail": "_ALL_PY.solution (7)",
    "documentation": {}
  },
  {
    "label": "getLargestString",
    "kind": 2,
    "importPath": "_ALL_PY.solution (8)",
    "description": "_ALL_PY.solution (8)",
    "peekOfCode": "def getLargestString(s, k):\n    d = Counter(s)\n    ord_s = sorted(d.keys(), reverse=True)\n    out = \"\"\n    l_p = 0\n    while l_p < len(ord_s):\n        if d[ord_s[l_p]] < k:\n            out += ord_s[l_p] * d[ord_s[l_p]]\n            l_p += 1\n            continue",
    "detail": "_ALL_PY.solution (8)",
    "documentation": {}
  },
  {
    "label": "s",
    "kind": 5,
    "importPath": "_ALL_PY.solution (8)",
    "description": "_ALL_PY.solution (8)",
    "peekOfCode": "s = \"xxzzxx\"\nprint(getLargestString(s, 4))",
    "detail": "_ALL_PY.solution (8)",
    "documentation": {}
  },
  {
    "label": "island",
    "kind": 2,
    "importPath": "_ALL_PY.solution (9)",
    "description": "_ALL_PY.solution (9)",
    "peekOfCode": "def island(matrix):\n    \"\"\"\n    given a two by two matrix, get the number of islands in it, an island is a series of 1's connected in a\n    row or a column\n    \"\"\"\n    if (not matrix) or len(matrix) == 0:\n        return 0\n    number_of_islands = 0\n    l = [True] * len(matrix[0])\n    for i in range(len(matrix)):",
    "detail": "_ALL_PY.solution (9)",
    "documentation": {}
  },
  {
    "label": "A,",
    "kind": 5,
    "importPath": "_ALL_PY.sortByHeight",
    "description": "_ALL_PY.sortByHeight",
    "peekOfCode": "A, = numpy.r_[eval(dir()[0])]\nA[A > 0] = sorted(A[A > 0])\nreturn A",
    "detail": "_ALL_PY.sortByHeight",
    "documentation": {}
  },
  {
    "label": "sortByHeight",
    "kind": 2,
    "importPath": "_ALL_PY.sort_by_height",
    "description": "_ALL_PY.sort_by_height",
    "peekOfCode": "def sortByHeight(a):\n    heights = []\n    # Store all the heights in a list\n    for i in range(len(a)):\n        if a[i] != -1:\n            heights.append(a[i])\n    # Sort the heights\n    heights = sorted(heights)\n    # Replace the heights in the original list\n    j = 0",
    "detail": "_ALL_PY.sort_by_height",
    "documentation": {}
  },
  {
    "label": "launchSequenceChecker",
    "kind": 2,
    "importPath": "_ALL_PY.spacex",
    "description": "_ALL_PY.spacex",
    "peekOfCode": "def launchSequenceChecker(systemNames, stepNumbers):",
    "detail": "_ALL_PY.spacex",
    "documentation": {}
  },
  {
    "label": "differentSquares",
    "kind": 2,
    "importPath": "_ALL_PY.Squares",
    "description": "_ALL_PY.Squares",
    "peekOfCode": "def differentSquares(matrix):\n    rows = len(matrix)\n    cols = len(matrix[0])\n    sq_arr = []\n    sq_count = 0\n    for i in range(rows - 1):\n        for j in range(cols - 1):\n            sq_2x2 = [\n                matrix[i][j],\n                matrix[i][j + 1],",
    "detail": "_ALL_PY.Squares",
    "documentation": {}
  },
  {
    "label": "differ_by_one_char",
    "kind": 2,
    "importPath": "_ALL_PY.strings_rearrangement",
    "description": "_ALL_PY.strings_rearrangement",
    "peekOfCode": "def differ_by_one_char(str1, str2):\n    \"\"\"Function to determine if the hamming distance between two strings is 1\n    Args:\n        str1(string): First string.\n        str2(string): Second string.\n    Returns:\n        Boolean indicating if hamming distance is equal to 1.\n    Raises:\n    \"\"\"\n    difference_count = 0",
    "detail": "_ALL_PY.strings_rearrangement",
    "documentation": {}
  },
  {
    "label": "stringsRearrangement",
    "kind": 2,
    "importPath": "_ALL_PY.strings_rearrangement",
    "description": "_ALL_PY.strings_rearrangement",
    "peekOfCode": "def stringsRearrangement(inputArray):\n    \"\"\"Function to check if possible to rearrange order of elements where hamming distance is 1\n    Args:\n        inputArray(string): List containing equal-length strings.\n    Returns:\n        Boolean indicating if it is possible or not.\n    Raises:\n    \"\"\"\n    all_permutation_tuples = permutations(inputArray)\n    for permutation in all_permutation_tuples:",
    "detail": "_ALL_PY.strings_rearrangement",
    "documentation": {}
  },
  {
    "label": "maxSubarray",
    "kind": 2,
    "importPath": "_ALL_PY.Subarray",
    "description": "_ALL_PY.Subarray",
    "peekOfCode": "def maxSubarray(A):\n    # A: inputArray\n    # m: Max\n    #\n    #\n    m = e = 0\n    for i in A:\n        e += i\n        if e < 0:\n            e = 0",
    "detail": "_ALL_PY.Subarray",
    "documentation": {}
  },
  {
    "label": "r",
    "kind": 5,
    "importPath": "_ALL_PY.Subrip",
    "description": "_ALL_PY.Subrip",
    "peekOfCode": "r = []\nc = 1\nt = [[int(s[i : i + 2]) for i in [1, 4]] + [s[7:9]] for s in l]\nt = [f\"{x // 60:02d}:{x % 60:02d}:{y:02d},{z.ljust(3, str(0))}\" for x, y, z in t] + [\n    s + \",000\"\n]  # if I replace str(0) with '0', this increases to 359 characters wtf\nfor a, b in enumerate(l):\n    r.extend([str(c), t[a] + \" --> \" + t[a + 1], b[11:], \"\"])\n    c += 1\nreturn r[:-1]",
    "detail": "_ALL_PY.Subrip",
    "documentation": {}
  },
  {
    "label": "c",
    "kind": 5,
    "importPath": "_ALL_PY.Subrip",
    "description": "_ALL_PY.Subrip",
    "peekOfCode": "c = 1\nt = [[int(s[i : i + 2]) for i in [1, 4]] + [s[7:9]] for s in l]\nt = [f\"{x // 60:02d}:{x % 60:02d}:{y:02d},{z.ljust(3, str(0))}\" for x, y, z in t] + [\n    s + \",000\"\n]  # if I replace str(0) with '0', this increases to 359 characters wtf\nfor a, b in enumerate(l):\n    r.extend([str(c), t[a] + \" --> \" + t[a + 1], b[11:], \"\"])\n    c += 1\nreturn r[:-1]",
    "detail": "_ALL_PY.Subrip",
    "documentation": {}
  },
  {
    "label": "t",
    "kind": 5,
    "importPath": "_ALL_PY.Subrip",
    "description": "_ALL_PY.Subrip",
    "peekOfCode": "t = [[int(s[i : i + 2]) for i in [1, 4]] + [s[7:9]] for s in l]\nt = [f\"{x // 60:02d}:{x % 60:02d}:{y:02d},{z.ljust(3, str(0))}\" for x, y, z in t] + [\n    s + \",000\"\n]  # if I replace str(0) with '0', this increases to 359 characters wtf\nfor a, b in enumerate(l):\n    r.extend([str(c), t[a] + \" --> \" + t[a + 1], b[11:], \"\"])\n    c += 1\nreturn r[:-1]",
    "detail": "_ALL_PY.Subrip",
    "documentation": {}
  },
  {
    "label": "t",
    "kind": 5,
    "importPath": "_ALL_PY.Subrip",
    "description": "_ALL_PY.Subrip",
    "peekOfCode": "t = [f\"{x // 60:02d}:{x % 60:02d}:{y:02d},{z.ljust(3, str(0))}\" for x, y, z in t] + [\n    s + \",000\"\n]  # if I replace str(0) with '0', this increases to 359 characters wtf\nfor a, b in enumerate(l):\n    r.extend([str(c), t[a] + \" --> \" + t[a + 1], b[11:], \"\"])\n    c += 1\nreturn r[:-1]",
    "detail": "_ALL_PY.Subrip",
    "documentation": {}
  },
  {
    "label": "mySubstring",
    "kind": 5,
    "importPath": "_ALL_PY.Substring",
    "description": "_ALL_PY.Substring",
    "peekOfCode": "mySubstring = lambda s, l, r: s[l : r + 1]",
    "detail": "_ALL_PY.Substring",
    "documentation": {}
  },
  {
    "label": "sudoku",
    "kind": 2,
    "importPath": "_ALL_PY.sudoku",
    "description": "_ALL_PY.sudoku",
    "peekOfCode": "def sudoku(grid):\n\t\"\"\"\n\tReturn boolean indicating if Sudoku is valid.\n\t\"\"\"\n    seen = set()\n    # Iterate through grid\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            current_value = grid[i][j]\n            if current_value != '.':",
    "detail": "_ALL_PY.sudoku",
    "documentation": {}
  },
  {
    "label": "line_is_valid",
    "kind": 2,
    "importPath": "_ALL_PY.sudoku2",
    "description": "_ALL_PY.sudoku2",
    "peekOfCode": "def line_is_valid(row):\n    tmp_dict = {}\n    valid = True\n    if len(row) > 0:\n        # print(row)\n        for r in row:\n            if r in tmp_dict:\n                tmp_dict[r] += 1\n            else:\n                tmp_dict[r] = 1",
    "detail": "_ALL_PY.sudoku2",
    "documentation": {}
  },
  {
    "label": "grid_is_valid",
    "kind": 2,
    "importPath": "_ALL_PY.sudoku2",
    "description": "_ALL_PY.sudoku2",
    "peekOfCode": "def grid_is_valid(grid):\n    valid = True\n    for i in range(len(grid)):\n        row = [int(x) for x in grid[i] if x != \".\"]\n        # print(row)\n        valid = line_is_valid(row)\n        if not valid:\n            break\n    return valid\ndef sudoku2(grid):",
    "detail": "_ALL_PY.sudoku2",
    "documentation": {}
  },
  {
    "label": "sudoku2",
    "kind": 2,
    "importPath": "_ALL_PY.sudoku2",
    "description": "_ALL_PY.sudoku2",
    "peekOfCode": "def sudoku2(grid):\n    result = False\n    # check rows:\n    rows_valid = grid_is_valid(grid)\n    # check columns:\n    col_valid = grid_is_valid(list(zip(*grid)))\n    # check 3x3 grids:\n    grid3x3_valid = True\n    for i in range(0, len(grid), 3):\n        if not grid3x3_valid:",
    "detail": "_ALL_PY.sudoku2",
    "documentation": {}
  },
  {
    "label": "sulkyBoy",
    "kind": 5,
    "importPath": "_ALL_PY.sulkyBoy",
    "description": "_ALL_PY.sulkyBoy",
    "peekOfCode": "sulkyBoy = lambda x: not x",
    "detail": "_ALL_PY.sulkyBoy",
    "documentation": {}
  },
  {
    "label": "isSum",
    "kind": 2,
    "importPath": "_ALL_PY.Sum",
    "description": "_ALL_PY.Sum",
    "peekOfCode": "def isSum(value):\n    s = 0\n    for i in range(100):\n        s += i\n        if s == value:\n            return True",
    "detail": "_ALL_PY.Sum",
    "documentation": {}
  },
  {
    "label": "sumOfSquares",
    "kind": 2,
    "importPath": "_ALL_PY.sumOfSquares",
    "description": "_ALL_PY.sumOfSquares",
    "peekOfCode": "def sumOfSquares(n):\n    return sum([x**2 for x in range(1, n+1)])",
    "detail": "_ALL_PY.sumOfSquares",
    "documentation": {}
  },
  {
    "label": "sumOfTheAngles",
    "kind": 5,
    "importPath": "_ALL_PY.sumOfTheAngles",
    "description": "_ALL_PY.sumOfTheAngles",
    "peekOfCode": "sumOfTheAngles = lambda n: (n - 2) * 180\n#n = eval(dir()[0])\n#return (n - 2) * 180",
    "detail": "_ALL_PY.sumOfTheAngles",
    "documentation": {}
  },
  {
    "label": "#n",
    "kind": 5,
    "importPath": "_ALL_PY.sumOfTheAngles",
    "description": "_ALL_PY.sumOfTheAngles",
    "peekOfCode": "#n = eval(dir()[0])\n#return (n - 2) * 180",
    "detail": "_ALL_PY.sumOfTheAngles",
    "documentation": {}
  },
  {
    "label": "sumOfTwo",
    "kind": 2,
    "importPath": "_ALL_PY.sumOfTwo",
    "description": "_ALL_PY.sumOfTwo",
    "peekOfCode": "def sumOfTwo(a, b, v):\n    b = set(b)\n    return any(v - i in b for i in a)",
    "detail": "_ALL_PY.sumOfTwo",
    "documentation": {}
  },
  {
    "label": "alternatingSums",
    "kind": 2,
    "importPath": "_ALL_PY.Sums",
    "description": "_ALL_PY.Sums",
    "peekOfCode": "def alternatingSums(a):\n    # Step 1: We begin by creating an array, called \"alt_sum\", that includes only two elements of value 0.\n    alt_sum = [0, 0]\n    # Step 2: Moreover, we define the variable \"length\", which is the numerical value of the length of input array a.\n    length = len(a)\n    # Step 3: Starting from the first element of input array \"a\" and working all the way through its length,\n    # we check whether the element's index is even or odd. If the element i is even, we add its value to the\n    # first element of the \"alt_sum\" array, whilst if it is odd we add it to the second element.\n    for i in range(0, length):\n        if i % 2 == 0:",
    "detail": "_ALL_PY.Sums",
    "documentation": {}
  },
  {
    "label": "sumUpNumbers",
    "kind": 2,
    "importPath": "_ALL_PY.sum_up_numbers",
    "description": "_ALL_PY.sum_up_numbers",
    "peekOfCode": "def sumUpNumbers(inputString):\n\t\"\"\"\n\tReturn the sum of the numbers in the inputString\n\tTime Complexity: O(n)\n\tSpace Complexity: O(1)\n\t\"\"\"\n    runningsum, number = 0, ''\n    for i in range(len(inputString)):\n        if inputString[i].isdigit():\n            number += inputString[i]",
    "detail": "_ALL_PY.sum_up_numbers",
    "documentation": {}
  },
  {
    "label": "isSuspiciousRespondent",
    "kind": 2,
    "importPath": "_ALL_PY.SuspiciousRespondent",
    "description": "_ALL_PY.SuspiciousRespondent",
    "peekOfCode": "def isSuspiciousRespondent(ans1, ans2, ans3):\n    return ans1 == ans2 == ans3",
    "detail": "_ALL_PY.SuspiciousRespondent",
    "documentation": {}
  },
  {
    "label": "differentSymbolsNaive",
    "kind": 2,
    "importPath": "_ALL_PY.SymbolsNaive",
    "description": "_ALL_PY.SymbolsNaive",
    "peekOfCode": "def differentSymbolsNaive(s):\n    return len(set(s))",
    "detail": "_ALL_PY.SymbolsNaive",
    "documentation": {}
  },
  {
    "label": "tennisSet",
    "kind": 2,
    "importPath": "_ALL_PY.tennis_set",
    "description": "_ALL_PY.tennis_set",
    "peekOfCode": "def tennisSet(score1, score2):\n    return (\n        True\n        if score1 == 6\n        and score2 < 5\n        or score1 < 5\n        and score2 == 6\n        or score1 == 7\n        and 5 <= score2 < 7\n        or score2 == 7",
    "detail": "_ALL_PY.tennis_set",
    "documentation": {}
  },
  {
    "label": "possibilities",
    "kind": 5,
    "importPath": "_ALL_PY.test (2)",
    "description": "_ALL_PY.test (2)",
    "peekOfCode": "possibilities = [\"ab\", \"cd\"]\nfor i in it.product(*possibilities):\n    if i:\n        print(\"\".join(i))",
    "detail": "_ALL_PY.test (2)",
    "documentation": {}
  },
  {
    "label": "TestAdd",
    "kind": 6,
    "importPath": "_ALL_PY.test_add",
    "description": "_ALL_PY.test_add",
    "peekOfCode": "class TestAdd(unittest.TestCase):\n    @data(\n        (6, 5, 11),\n        (0, 1000, 1000),\n        (-2, 4, 2),\n        (-100, 100, 0),\n        (-100, 89, -11),\n        (-1000, -999, -1999),\n    )\n    @unpack",
    "detail": "_ALL_PY.test_add",
    "documentation": {}
  },
  {
    "label": "TestAdjacentElementsProduct",
    "kind": 6,
    "importPath": "_ALL_PY.test_adjacent_elements_product",
    "description": "_ALL_PY.test_adjacent_elements_product",
    "peekOfCode": "class TestAdjacentElementsProduct(unittest.TestCase):\n    @data(\n        ([3, 6, -2, -5, 7, 3], 21),\n        ([-2, -2], 4),\n        ([5, 1, 2, 3, 1, 4], 6),\n        ([2, 3, 0], 6),\n        ([9, 5, 10, 2, 24, -1, -48], 50),\n        ([10, 13, 5, 1000], 5000),\n        ([45, 3, -1, -1000], 1000),\n    )",
    "detail": "_ALL_PY.test_adjacent_elements_product",
    "documentation": {}
  },
  {
    "label": "TestCenturyFromYear",
    "kind": 6,
    "importPath": "_ALL_PY.test_century_from_year",
    "description": "_ALL_PY.test_century_from_year",
    "peekOfCode": "class TestCenturyFromYear(unittest.TestCase):\n    @data((1988, 20), (1, 1), (2001, 21), (2000, 20))\n    @unpack\n    def test_positive(self, year, century) -> None:\n        self.assertEqual(func.century_from_year(year), century)\n    @data((\"abcd\", 0), (None, 0), (0, 0), (2010, 0), (-5, 0))\n    @unpack\n    def test_negative(self, year, century) -> None:\n        if year is None:\n            self.assertEqual(func.century_from_year(), century)",
    "detail": "_ALL_PY.test_century_from_year",
    "documentation": {}
  },
  {
    "label": "TestPalindrome",
    "kind": 6,
    "importPath": "_ALL_PY.test_palindrome",
    "description": "_ALL_PY.test_palindrome",
    "peekOfCode": "class TestPalindrome(unittest.TestCase):\n    @data(\n        (\"aabaa\", True),\n        (\"abac\", False),\n        (\"c\", True),\n        (\"testmeplease\", False),\n        (\"hlbeeykoqqqokyeeblh\", True),\n    )\n    @unpack\n    def test_positive(self, input_string, result) -> None:",
    "detail": "_ALL_PY.test_palindrome",
    "documentation": {}
  },
  {
    "label": "TestShapeArea",
    "kind": 6,
    "importPath": "_ALL_PY.test_shape_area",
    "description": "_ALL_PY.test_shape_area",
    "peekOfCode": "class TestShapeArea(unittest.TestCase):\n    @data((2, 5), (3, 13), (1, 1), (5, 41), (7000, 97986001))\n    @unpack\n    def test_positive(self, number, result) -> None:\n        self.assertEqual(func.shape_area(number), result)\n    @data((0, 0), (None, 0), (10001, 0), (-10, 0), (\"a\", 0))\n    @unpack\n    def test_negative(self, number, result) -> None:\n        if number is None:\n            self.assertEqual(func.shape_area(), result)",
    "detail": "_ALL_PY.test_shape_area",
    "documentation": {}
  },
  {
    "label": "findTheRemainder",
    "kind": 2,
    "importPath": "_ALL_PY.TheRemainder",
    "description": "_ALL_PY.TheRemainder",
    "peekOfCode": "def findTheRemainder(a, b):\n    return a % b",
    "detail": "_ALL_PY.TheRemainder",
    "documentation": {}
  },
  {
    "label": "validTime",
    "kind": 2,
    "importPath": "_ALL_PY.Time",
    "description": "_ALL_PY.Time",
    "peekOfCode": "def validTime(time):\n    time_split = time.split(\":\")\n    if 00 <= int(time_split[0]) <= 23 and 00 <= int(time_split[1]) <= 59:\n        return True\n    return False",
    "detail": "_ALL_PY.Time",
    "documentation": {}
  },
  {
    "label": "n,",
    "kind": 5,
    "importPath": "_ALL_PY.Title",
    "description": "_ALL_PY.Title",
    "peekOfCode": "n, = eval(dir()[0])\nr = \"\"\nwhile n:\n    n -= 1\n    r = chr(n % 26 + 65) + r\n    n //= 26\nreturn r",
    "detail": "_ALL_PY.Title",
    "documentation": {}
  },
  {
    "label": "r",
    "kind": 5,
    "importPath": "_ALL_PY.Title",
    "description": "_ALL_PY.Title",
    "peekOfCode": "r = \"\"\nwhile n:\n    n -= 1\n    r = chr(n % 26 + 65) + r\n    n //= 26\nreturn r",
    "detail": "_ALL_PY.Title",
    "documentation": {}
  },
  {
    "label": "testTreeLine",
    "kind": 2,
    "importPath": "_ALL_PY.treeCutter",
    "description": "_ALL_PY.treeCutter",
    "peekOfCode": "def testTreeLine(A):\n    if A == sorted(A):\n        return True\n    else:\n        return False\n# check if solution is possible\ndef impossible(A):\n    maxIndex = A.index(max(A))\n    maxBefore = max(A[0:maxIndex])\n    minAfter = min(A[maxIndex:])",
    "detail": "_ALL_PY.treeCutter",
    "documentation": {}
  },
  {
    "label": "impossible",
    "kind": 2,
    "importPath": "_ALL_PY.treeCutter",
    "description": "_ALL_PY.treeCutter",
    "peekOfCode": "def impossible(A):\n    maxIndex = A.index(max(A))\n    maxBefore = max(A[0:maxIndex])\n    minAfter = min(A[maxIndex:])\n    if A[maxIndex] != A[len(A) - 1]:\n        if minAfter <= (maxBefore - 2) and len(A[maxIndex + 1 :]) > 1:\n            return True\n        else:\n            return False\n# function to see how many trees can be cut down",
    "detail": "_ALL_PY.treeCutter",
    "documentation": {}
  },
  {
    "label": "numCutTrees",
    "kind": 2,
    "importPath": "_ALL_PY.treeCutter",
    "description": "_ALL_PY.treeCutter",
    "peekOfCode": "def numCutTrees(A):\n    n = 0\n    # check case where no solutions possible\n    # for faster result\n    if impossible(A):\n        return n\n    for l in range(len(A)):\n        elem = A.pop(l)\n        if testTreeLine(A):\n            n = n + 1",
    "detail": "_ALL_PY.treeCutter",
    "documentation": {}
  },
  {
    "label": "N",
    "kind": 5,
    "importPath": "_ALL_PY.treeCutter",
    "description": "_ALL_PY.treeCutter",
    "peekOfCode": "N = [1, 2, 3, 4, 4]  # 5\nL = [1, 4, 2, 3]  # 1\nC = [1, 3, 5, 3]  # 2\nD = [1, 4, 3, 5, 3]  # 0\nE = [1, 2, 3, 4, 1]  # 1\nprint(numCutTrees(N))\nprint(numCutTrees(L))\nprint(numCutTrees(C))\nprint(numCutTrees(D))\nprint(numCutTrees(E))",
    "detail": "_ALL_PY.treeCutter",
    "documentation": {}
  },
  {
    "label": "L",
    "kind": 5,
    "importPath": "_ALL_PY.treeCutter",
    "description": "_ALL_PY.treeCutter",
    "peekOfCode": "L = [1, 4, 2, 3]  # 1\nC = [1, 3, 5, 3]  # 2\nD = [1, 4, 3, 5, 3]  # 0\nE = [1, 2, 3, 4, 1]  # 1\nprint(numCutTrees(N))\nprint(numCutTrees(L))\nprint(numCutTrees(C))\nprint(numCutTrees(D))\nprint(numCutTrees(E))",
    "detail": "_ALL_PY.treeCutter",
    "documentation": {}
  },
  {
    "label": "C",
    "kind": 5,
    "importPath": "_ALL_PY.treeCutter",
    "description": "_ALL_PY.treeCutter",
    "peekOfCode": "C = [1, 3, 5, 3]  # 2\nD = [1, 4, 3, 5, 3]  # 0\nE = [1, 2, 3, 4, 1]  # 1\nprint(numCutTrees(N))\nprint(numCutTrees(L))\nprint(numCutTrees(C))\nprint(numCutTrees(D))\nprint(numCutTrees(E))",
    "detail": "_ALL_PY.treeCutter",
    "documentation": {}
  },
  {
    "label": "D",
    "kind": 5,
    "importPath": "_ALL_PY.treeCutter",
    "description": "_ALL_PY.treeCutter",
    "peekOfCode": "D = [1, 4, 3, 5, 3]  # 0\nE = [1, 2, 3, 4, 1]  # 1\nprint(numCutTrees(N))\nprint(numCutTrees(L))\nprint(numCutTrees(C))\nprint(numCutTrees(D))\nprint(numCutTrees(E))",
    "detail": "_ALL_PY.treeCutter",
    "documentation": {}
  },
  {
    "label": "E",
    "kind": 5,
    "importPath": "_ALL_PY.treeCutter",
    "description": "_ALL_PY.treeCutter",
    "peekOfCode": "E = [1, 2, 3, 4, 1]  # 1\nprint(numCutTrees(N))\nprint(numCutTrees(L))\nprint(numCutTrees(C))\nprint(numCutTrees(D))\nprint(numCutTrees(E))",
    "detail": "_ALL_PY.treeCutter",
    "documentation": {}
  },
  {
    "label": "returnTwelve",
    "kind": 5,
    "importPath": "_ALL_PY.Twelve",
    "description": "_ALL_PY.Twelve",
    "peekOfCode": "returnTwelve = lambda n: 12 if n < 12 else n",
    "detail": "_ALL_PY.Twelve",
    "documentation": {}
  },
  {
    "label": "addTwoDigits",
    "kind": 5,
    "importPath": "_ALL_PY.TwoDigits",
    "description": "_ALL_PY.TwoDigits",
    "peekOfCode": "addTwoDigits = lambda n: n % 10 + n // 10\n# return sum(int(i) for i in str(n))",
    "detail": "_ALL_PY.TwoDigits",
    "documentation": {}
  },
  {
    "label": "caseUnification",
    "kind": 2,
    "importPath": "_ALL_PY.Unification",
    "description": "_ALL_PY.Unification",
    "peekOfCode": "def caseUnification(s):\n    u = sum(1 for x in s if x.isupper())\n    if u > (len(s) / 2):\n        return s.upper()\n    else:\n        return s.lower()",
    "detail": "_ALL_PY.Unification",
    "documentation": {}
  },
  {
    "label": "sumUpNumbers",
    "kind": 2,
    "importPath": "_ALL_PY.UpNumbers",
    "description": "_ALL_PY.UpNumbers",
    "peekOfCode": "def sumUpNumbers(inputString):\n    def getNumbers(str):\n        nums = re.findall(r\"[0-9]+\", str)\n        return nums\n    numbers = getNumbers(inputString)\n    total = 0\n    for i in numbers:\n        total += int(i)\n    return total",
    "detail": "_ALL_PY.UpNumbers",
    "documentation": {}
  },
  {
    "label": "validTime",
    "kind": 2,
    "importPath": "_ALL_PY.valid_time",
    "description": "_ALL_PY.valid_time",
    "peekOfCode": "def validTime(time):\n\t\"\"\"\n\tBoolean indicating if time is in valid 24hr format\n\t\"\"\"\n    tokens = time.split(':')\n    hours = int(tokens[0])\n    minutes = int(tokens[1])\n    return not (hours > 23 or minutes > 59)",
    "detail": "_ALL_PY.valid_time",
    "documentation": {}
  },
  {
    "label": "absoluteValuesSumMinimization",
    "kind": 2,
    "importPath": "_ALL_PY.ValuesSumMinimization",
    "description": "_ALL_PY.ValuesSumMinimization",
    "peekOfCode": "def absoluteValuesSumMinimization(a):\n    sums = []\n    for i in range(len(a)):\n        sum = 0\n        for j in range(len(a)):\n            sum += abs(a[i] - a[j])\n        sums.append(sum)\n    return a[sums.index(min(sums))]",
    "detail": "_ALL_PY.ValuesSumMinimization",
    "documentation": {}
  },
  {
    "label": "variableName",
    "kind": 2,
    "importPath": "_ALL_PY.variable_name",
    "description": "_ALL_PY.variable_name",
    "peekOfCode": "def variableName(name):\n    if name[0].isdigit():\n        return False\n    for i in range(len(name)):\n        if not name[i].isalnum() and not name[i] == \"_\":\n            return False\n    return True",
    "detail": "_ALL_PY.variable_name",
    "documentation": {}
  },
  {
    "label": "visitsOnCircularRoad",
    "kind": 2,
    "importPath": "_ALL_PY.visitsOnCircularRoad",
    "description": "_ALL_PY.visitsOnCircularRoad",
    "peekOfCode": "def visitsOnCircularRoad(n, v):\n    c = 1\n    t = 0\n    for i in v :\n        t += min(abs(i - c), abs(n - abs(i - c)))\n        c = i\n    return t\n# v = visitsOrder\n# n = number of houses\n# c = Current position",
    "detail": "_ALL_PY.visitsOnCircularRoad",
    "documentation": {}
  },
  {
    "label": "cubeVolume",
    "kind": 5,
    "importPath": "_ALL_PY.Volume",
    "description": "_ALL_PY.Volume",
    "peekOfCode": "cubeVolume = lambda n: n ** 3",
    "detail": "_ALL_PY.Volume",
    "documentation": {}
  },
  {
    "label": "magicalWell",
    "kind": 2,
    "importPath": "_ALL_PY.Well",
    "description": "_ALL_PY.Well",
    "peekOfCode": "def magicalWell(a, b, n):\n    s, m = 0, 0\n    while m < n:\n        s += a * b\n        a += 1\n        b += 1\n        m += 1\n    return s",
    "detail": "_ALL_PY.Well",
    "documentation": {}
  },
  {
    "label": "electionsWinners",
    "kind": 2,
    "importPath": "_ALL_PY.Winners",
    "description": "_ALL_PY.Winners",
    "peekOfCode": "def electionsWinners(votes, k):\n    max_vote = max(votes)\n    len_vote = len(votes)\n    if k == 0 and votes.count(max_vote) == 1:\n        return 1\n    return len([i for i in range(len_vote) if votes[i] + k > max_vote])",
    "detail": "_ALL_PY.Winners",
    "documentation": {}
  },
  {
    "label": "longestWord",
    "kind": 2,
    "importPath": "_ALL_PY.Word",
    "description": "_ALL_PY.Word",
    "peekOfCode": "def longestWord(text):\n    word_split = re.findall(r\"[\\w']+\", text)\n    longest_word = \"\"\n    for word in word_split:\n        if len(word) > len(longest_word) and word.isalpha():\n            longest_word = word\n    return longest_word",
    "detail": "_ALL_PY.Word",
    "documentation": {}
  },
  {
    "label": "zigzags",
    "kind": 2,
    "importPath": "_ALL_PY.zigzag",
    "description": "_ALL_PY.zigzag",
    "peekOfCode": "def zigzags(input):\n    input = iter(input)\n    stack = None\n    try:\n        stack = [next(input)]\n        while True:\n            if len(stack) < 2:\n                stack.append(next(input))\n            else:\n                stack = stack[-2:]",
    "detail": "_ALL_PY.zigzag",
    "documentation": {}
  },
  {
    "label": "zigzag",
    "kind": 2,
    "importPath": "_ALL_PY.zigzag",
    "description": "_ALL_PY.zigzag",
    "peekOfCode": "def zigzag(input):\n    item = max(zigzags(input), key=len)\n    print len(item), item",
    "detail": "_ALL_PY.zigzag",
    "documentation": {}
  },
  {
    "label": "absolute_value_sum",
    "kind": 2,
    "importPath": "absolute_values_sum_minimization",
    "description": "absolute_values_sum_minimization",
    "peekOfCode": "def absolute_value_sum(mylist, x):\n    running_sum = 0\n    for number in mylist:\n        running_sum += abs(number - x)\n    return running_sum\ndef absoluteValuesSumMinimization(a):\n    mydict = {}\n    for i in range(len(a)):\n        mydict[a[i]] = absolute_value_sum(a, a[i])\n    return min(mydict, key=mydict.get)",
    "detail": "absolute_values_sum_minimization",
    "documentation": {}
  },
  {
    "label": "absoluteValuesSumMinimization",
    "kind": 2,
    "importPath": "absolute_values_sum_minimization",
    "description": "absolute_values_sum_minimization",
    "peekOfCode": "def absoluteValuesSumMinimization(a):\n    mydict = {}\n    for i in range(len(a)):\n        mydict[a[i]] = absolute_value_sum(a, a[i])\n    return min(mydict, key=mydict.get)",
    "detail": "absolute_values_sum_minimization",
    "documentation": {}
  },
  {
    "label": "add",
    "kind": 2,
    "importPath": "add (2)",
    "description": "add (2)",
    "peekOfCode": "def add(param1, param2):\n    return param1 + param2",
    "detail": "add (2)",
    "documentation": {}
  },
  {
    "label": "add",
    "kind": 2,
    "importPath": "add",
    "description": "add",
    "peekOfCode": "def add(param1: int = 0, param2: int = 0) -> int:\n    if isinstance(param1, int) \\\n            and isinstance(param2, int) \\\n            and -1000 <= param1 <= 1000 \\\n            and -1000 <= param2 <= 1000:\n        return param1 + param2\n    return 0",
    "detail": "add",
    "documentation": {}
  },
  {
    "label": "addBorder",
    "kind": 2,
    "importPath": "add_border",
    "description": "add_border",
    "peekOfCode": "def addBorder(picture):\n    picture_with_border = []\n    for i in range(len(picture)):\n        # Add the main border to the picture\n        if i == 0:\n            picture_with_border.append(\"*\" * (len(picture[i]) + 2))\n        picture_with_border.append(\"*\" + \"\".join(picture[i]) + \"*\")\n        # Add the main border to the picture\n        if i == len(picture) - 1:\n            picture_with_border.append(\"*\" * (len(picture[i]) + 2))",
    "detail": "add_border",
    "documentation": {}
  },
  {
    "label": "addTwoDigits",
    "kind": 2,
    "importPath": "add_two_digits",
    "description": "add_two_digits",
    "peekOfCode": "def addTwoDigits(n):\n\t\"\"\"\n\tReturn sum of the two digits in n\n\t\"\"\"\n    digits = str(n)\n    return sum([int(digit) for digit in digits])",
    "detail": "add_two_digits",
    "documentation": {}
  },
  {
    "label": "adjacent_elements_product",
    "kind": 2,
    "importPath": "adjacent_elements_product",
    "description": "adjacent_elements_product",
    "peekOfCode": "def adjacent_elements_product(inputArray: list = None) -> int:\n    if inputArray is None:\n        return 0\n    if isinstance(inputArray, list) and 2 <= len(inputArray) <= 10:\n        adjacent = inputArray[0] * inputArray[1]\n        for i in range(len(inputArray) - 1):\n            if -1000 <= inputArray[i] <= 1000 and -1000 <= inputArray[i + 1] <= 1000:\n                tmp = inputArray[i] * inputArray[i + 1]\n                if tmp > adjacent:\n                    adjacent = tmp",
    "detail": "adjacent_elements_product",
    "documentation": {}
  },
  {
    "label": "isAdult",
    "kind": 5,
    "importPath": "Adult",
    "description": "Adult",
    "peekOfCode": "isAdult = lambda a, m: a >= m",
    "detail": "Adult",
    "documentation": {}
  },
  {
    "label": "allLongestStrings",
    "kind": 2,
    "importPath": "all_longest_strings",
    "description": "all_longest_strings",
    "peekOfCode": "def allLongestStrings(inputArray):\n    # sortedList = sorted(inputArray, key=len, reverse=True)\n    max_string_length, longest_strings = max(inputArray, key=len), []\n    for i in range(len(inputArray)):\n        if len(inputArray[i]) == len(max_string_length):\n            longest_strings.append(inputArray[i])\n    return longest_strings",
    "detail": "all_longest_strings",
    "documentation": {}
  },
  {
    "label": "is_increasing_sequence",
    "kind": 2,
    "importPath": "almost_increasing_sequence",
    "description": "almost_increasing_sequence",
    "peekOfCode": "def is_increasing_sequence(sequence):\n    for i in range(len(sequence) - 1):\n        if sequence[i] >= sequence[i + 1]:\n            return i\n    return -1\ndef almostIncreasingSequence(sequence):\n    j = is_increasing_sequence(sequence)\n    if j == -1:\n        return True\n    if is_increasing_sequence(sequence[j - 1 : j] + sequence[j + 1 :]) == -1:",
    "detail": "almost_increasing_sequence",
    "documentation": {}
  },
  {
    "label": "almostIncreasingSequence",
    "kind": 2,
    "importPath": "almost_increasing_sequence",
    "description": "almost_increasing_sequence",
    "peekOfCode": "def almostIncreasingSequence(sequence):\n    j = is_increasing_sequence(sequence)\n    if j == -1:\n        return True\n    if is_increasing_sequence(sequence[j - 1 : j] + sequence[j + 1 :]) == -1:\n        return True  # Deleting earlier element makes it increasing\n    if is_increasing_sequence(sequence[j : j + 1] + sequence[j + 2 :]) == -1:\n        return True  # Deleting later element makes it increasing\n    return False",
    "detail": "almost_increasing_sequence",
    "documentation": {}
  },
  {
    "label": "alphabeticShift",
    "kind": 2,
    "importPath": "alphabetic_shift",
    "description": "alphabetic_shift",
    "peekOfCode": "def alphabeticShift(inputString):\n    outputString = \"\"\n    for i in range(len(inputString)):\n        outputString += chr((ord(inputString[i]) + 1 - 97) % 26 + 97)\n    return outputString",
    "detail": "alphabetic_shift",
    "documentation": {}
  },
  {
    "label": "alternatingSums",
    "kind": 2,
    "importPath": "alternating_sums",
    "description": "alternating_sums",
    "peekOfCode": "def alternatingSums(a):\n    team1, team2 = [], []\n    for i in range(len(a)):\n        if i % 2 == 0:\n            team1.append(a[i])\n        else:\n            team2.append(a[i])\n    return [sum(team1), sum(team2)]",
    "detail": "alternating_sums",
    "documentation": {}
  },
  {
    "label": "bishopAndPawn",
    "kind": 2,
    "importPath": "AndPawn",
    "description": "AndPawn",
    "peekOfCode": "def bishopAndPawn(bishop, pawn):\n    if ord(bishop[0]) == ord(pawn[0]):\n        return False\n    else:\n        bishop_elm = ord(bishop[0]) + int(bishop[1])\n        pawn_elm = ord(pawn[0]) + int(pawn[1])\n        return (bishop_elm + pawn_elm) % 2 == 0",
    "detail": "AndPawn",
    "documentation": {}
  },
  {
    "label": "shapeArea",
    "kind": 2,
    "importPath": "Area",
    "description": "Area",
    "peekOfCode": "def shapeArea(n):\n    # Case 1: If the polygon is 0-interesting, it has an area equal to zero.\n    if n == 0:\n        return None\n    # Case 2: If the polygon is 1-interesting, it has an area equal to one.\n    elif n == 1:\n        return 1\n    # Case 3: If the polygon is n-interesting, it has an area equal to the sum of the square of n\n    # and the square of n-1. A way that I thought of it (based on the picture provided) is the following:\n    # - n**2: Counted the number of the blue squares from the middle line upwards (INCLUDING the blue squares of the middle line).",
    "detail": "Area",
    "documentation": {}
  },
  {
    "label": "areEquallyStrong",
    "kind": 2,
    "importPath": "are_equally_strong",
    "description": "are_equally_strong",
    "peekOfCode": "def areEquallyStrong(yourLeft, yourRight, friendsLeft, friendsRight):\n    myStrongestArm = max(yourLeft, yourRight)\n    myWeakestArm = min(yourLeft, yourRight)\n    friendStrongestArm = max(friendsLeft, friendsRight)\n    friendWeakestArm = min(friendsLeft, friendsRight)\n    if myStrongestArm == friendStrongestArm and myWeakestArm == friendWeakestArm:\n        return True\n    else:\n        return False",
    "detail": "are_equally_strong",
    "documentation": {}
  },
  {
    "label": "areSimilar",
    "kind": 2,
    "importPath": "are_similar",
    "description": "are_similar",
    "peekOfCode": "def areSimilar(a, b):\n    for i in range(len(a)):\n        sorted_a, sorted_b = sorted(a), sorted(b)\n        if sorted_a != sorted_b:\n            return False\n        inversions = 0\n        for i in range(len(a)):\n            if a[i] != b[i]:\n                inversions += 1\n        return inversions == 2 or inversions == 0",
    "detail": "are_similar",
    "documentation": {}
  },
  {
    "label": "arithmeticExpression",
    "kind": 2,
    "importPath": "arithmetic_expression",
    "description": "arithmetic_expression",
    "peekOfCode": "def arithmeticExpression(a, b, c):\n    \"\"\"\n    Consider an arithmetic expression of the form a#b=c. \n    Check whether it is possible to replace # with one of \n    the four signs: +, -, * or / to obtain a correct\n    \"\"\"\n    return (\n        True if (a + b == c) or (a - b == c) or (a * b == c) or (a / b == c) else False\n    )",
    "detail": "arithmetic_expression",
    "documentation": {}
  },
  {
    "label": "makeArrayConsecutive2",
    "kind": 2,
    "importPath": "ArrayConsecutive2",
    "description": "ArrayConsecutive2",
    "peekOfCode": "def makeArrayConsecutive2(statues):\n    # Step 1: We begin by creating a new array called \"stat_arr\", which will accommodate the sorted version of the original \"statues\" array.\n    stat_arr = sorted(statues)\n    # Step 2: Furthermore, we use the first element of the sorted array as our index (that will be used in the following steps).\n    i = stat_arr[0]\n    # Step 3: We create an empty list called \"result\" to store our (numbered) missing statues.\n    result = list()\n    # Step 4: We initiate a while-loop with the condition that the index from Step 2 is not equal to the last (hence largest) entry of\n    # the stat_arr. You must make sure that you add the \"incrementation by 1\" part to make the while loop proceed to the next element.\n    while i != stat_arr[-1]:",
    "detail": "ArrayConsecutive2",
    "documentation": {}
  },
  {
    "label": "arrayChange",
    "kind": 2,
    "importPath": "array_change",
    "description": "array_change",
    "peekOfCode": "def arrayChange(inputArray):\n    moves = 0\n    current = inputArray[0]\n    for number in inputArray[1:]:\n        if number <= current:\n            moves += current - number + 1\n            current += 1\n        else:\n            current = number\n    return moves",
    "detail": "array_change",
    "documentation": {}
  },
  {
    "label": "arrayMaximalAdjacentDifference",
    "kind": 2,
    "importPath": "array_maximal_adjacent_abs_difference",
    "description": "array_maximal_adjacent_abs_difference",
    "peekOfCode": "def arrayMaximalAdjacentDifference(inputArray):\n    max_diff = -15\n    for i in range(len(inputArray) - 1):\n        max_diff = max(abs(inputArray[i] - inputArray[i + 1]), max_diff)\n    return max_diff",
    "detail": "array_maximal_adjacent_abs_difference",
    "documentation": {}
  },
  {
    "label": "maxSum",
    "kind": 2,
    "importPath": "array_max_consecutive_sum",
    "description": "array_max_consecutive_sum",
    "peekOfCode": "def maxSum(arr, n, k):\n    # k must be greater\n    if n < k:\n        print(\"Invalid\")\n        return -1\n    # Compute sum of first\n    # window of size k\n    res = 0\n    for i in range(k):\n        res += arr[i]",
    "detail": "array_max_consecutive_sum",
    "documentation": {}
  },
  {
    "label": "arrayMaxConsecutiveSum",
    "kind": 2,
    "importPath": "array_max_consecutive_sum",
    "description": "array_max_consecutive_sum",
    "peekOfCode": "def arrayMaxConsecutiveSum(inputArray, k):\n    \"\"\"Find maximal possible sum of k consecutive elements in list of integers\n    Args:\n        intputArray(int): List of integers\n        k(int): Number of consecutive elements\n    Return\n        Maximum sum of k consecutive elements\n    Raises:\n    \"\"\"\n    return maxSum(inputArray, len(inputArray), k)",
    "detail": "array_max_consecutive_sum",
    "documentation": {}
  },
  {
    "label": "arrayReplace",
    "kind": 2,
    "importPath": "array_replace",
    "description": "array_replace",
    "peekOfCode": "def arrayReplace(inputArray, elemToReplace, substitutionElem):\n    for i in range(len(inputArray)):\n        if inputArray[i] == elemToReplace:\n            inputArray[i] = substitutionElem\n    return inputArray",
    "detail": "array_replace",
    "documentation": {}
  },
  {
    "label": "avoidObstacles",
    "kind": 2,
    "importPath": "avoid_obstacles",
    "description": "avoid_obstacles",
    "peekOfCode": "def avoidObstacles(inputArray):\n    sortedlist = sorted(inputArray)  # Sort list in ascending order\n    jump_dist = 1  # Set jump distance to 1 initially\n    obstacle_hit = True  # Flag to check if current jump distance hit an obstacle\n    while obstacle_hit:\n        obstacle_hit = False  # Set flag to false as we check next jump distance\n        jump_dist += (\n            1\n        )  # Increment jump distance as we check if next value hits no obstacles\n        # Check if jumping with current length hits an obstacle",
    "detail": "avoid_obstacles",
    "documentation": {}
  },
  {
    "label": "isBeautifulString",
    "kind": 2,
    "importPath": "BeautifulString",
    "description": "BeautifulString",
    "peekOfCode": "def isBeautifulString(inputString):\n    counter = [inputString.count(i) for i in string.ascii_lowercase]\n    return counter[::-1] == sorted(counter)",
    "detail": "BeautifulString",
    "documentation": {}
  },
  {
    "label": "bishopAndPawn",
    "kind": 2,
    "importPath": "bishop_and_pawn",
    "description": "bishop_and_pawn",
    "peekOfCode": "def bishopAndPawn(bishop, pawn):\n    x = \"abcdefgh\"\n    return abs(int(x.index(bishop[0])) - int(x.index(pawn[0]))) == abs(\n        int(bishop[1]) - int(pawn[1])\n    )",
    "detail": "bishop_and_pawn",
    "documentation": {}
  },
  {
    "label": "boxBlur",
    "kind": 2,
    "importPath": "Blur",
    "description": "Blur",
    "peekOfCode": "def boxBlur(image):\n    def pixels(matrix, i, j):\n        summ = 0\n        for x in range(i - 1, i + 2):\n            for y in range(j - 1, j + 2):\n                summ += matrix[x][y]\n                mean = summ // 9\n        return mean\n    output = []\n    row = len(image)",
    "detail": "Blur",
    "documentation": {}
  },
  {
    "label": "chessBoardCellColor",
    "kind": 2,
    "importPath": "BoardCellColor",
    "description": "BoardCellColor",
    "peekOfCode": "def chessBoardCellColor(cell1, cell2):\n    cell1_elm = ord(cell1[0]) + int(cell1[1])\n    cell2_elm = ord(cell2[0]) + int(cell2[1])\n    return (cell1_elm + cell2_elm) % 2 == 0",
    "detail": "BoardCellColor",
    "documentation": {}
  },
  {
    "label": "addBorder",
    "kind": 2,
    "importPath": "Border",
    "description": "Border",
    "peekOfCode": "def addBorder(picture):\n    new_pic = []\n    border = \"\"\n    pic_len = len(picture)\n    for i in range(0, len(picture[0]) + 2):\n        border += \"*\"\n    new_pic.append(border)\n    for i in range(0, pic_len):\n        new_pic.append(\"*\" + picture[i] + \"*\")\n    new_pic.append(border)",
    "detail": "Border",
    "documentation": {}
  },
  {
    "label": "square_matrix",
    "kind": 2,
    "importPath": "box_blur_algortihm",
    "description": "box_blur_algortihm",
    "peekOfCode": "def square_matrix(square):\n    # Calculate sum of all the pixels in 3 * 3 matrix\n    tot_sum = 0\n    for i in range(3):\n        for j in range(3):\n            tot_sum += square[i][j]\n    return tot_sum // 9  # return the average of the sum of pixels\ndef boxBlur(image):\n    square = []  # This will store the 3 * 3 matrix\n    # which will be used to find its blurred pixel",
    "detail": "box_blur_algortihm",
    "documentation": {}
  },
  {
    "label": "boxBlur",
    "kind": 2,
    "importPath": "box_blur_algortihm",
    "description": "box_blur_algortihm",
    "peekOfCode": "def boxBlur(image):\n    square = []  # This will store the 3 * 3 matrix\n    # which will be used to find its blurred pixel\n    square_row = []  # This will store one row of a 3 * 3 matrix and\n    # will be appended in square\n    blur_row = []  # Here we will store the resulting blurred\n    # pixels possible in one row\n    # and will append this in the blur_img\n    blur_img = []  # This is the resulting blurred image\n    # number of rows in the given image",
    "detail": "box_blur_algortihm",
    "documentation": {}
  },
  {
    "label": "sulkyBoy",
    "kind": 5,
    "importPath": "Boy",
    "description": "Boy",
    "peekOfCode": "sulkyBoy = lambda x: not x",
    "detail": "Boy",
    "documentation": {}
  },
  {
    "label": "TreeNode",
    "kind": 6,
    "importPath": "BST_from_preorder",
    "description": "BST_from_preorder",
    "peekOfCode": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\nclass Solution:\n    def bstFromPreorder(self, preorder):\n        if not preorder:\n            return None\n        root = TreeNode(preorder[0])",
    "detail": "BST_from_preorder",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "BST_from_preorder",
    "description": "BST_from_preorder",
    "peekOfCode": "class Solution:\n    def bstFromPreorder(self, preorder):\n        if not preorder:\n            return None\n        root = TreeNode(preorder[0])\n        i = 1\n        while i < len(preorder) and preorder[i] < root.val:\n            i += 1\n        root.left = self.bstFromPreorder(preorder[1:i])\n        root.right = self.bstFromPreorder(preorder[i:])",
    "detail": "BST_from_preorder",
    "documentation": {}
  },
  {
    "label": "preorder",
    "kind": 5,
    "importPath": "BST_from_preorder",
    "description": "BST_from_preorder",
    "peekOfCode": "preorder = [19, 4, 8, 11]\nbst = Solution()\nbst.bstFromPreorder(preorder)",
    "detail": "BST_from_preorder",
    "documentation": {}
  },
  {
    "label": "bst",
    "kind": 5,
    "importPath": "BST_from_preorder",
    "description": "BST_from_preorder",
    "peekOfCode": "bst = Solution()\nbst.bstFromPreorder(preorder)",
    "detail": "BST_from_preorder",
    "documentation": {}
  },
  {
    "label": "isPalindrome",
    "kind": 2,
    "importPath": "build_palindrome",
    "description": "build_palindrome",
    "peekOfCode": "def isPalindrome(st):\n    for i in range(len(st) // 2):\n        if st[i] != st[len(st) - 1 - i]:\n            return False\n    return True\ndef buildPalindrome(st):\n    for i in range(len(st)):\n        substring = st[i : len(st)]\n        if isPalindrome(substring):\n            non_palindrome_part = st[0:i]",
    "detail": "build_palindrome",
    "documentation": {}
  },
  {
    "label": "buildPalindrome",
    "kind": 2,
    "importPath": "build_palindrome",
    "description": "build_palindrome",
    "peekOfCode": "def buildPalindrome(st):\n    for i in range(len(st)):\n        substring = st[i : len(st)]\n        if isPalindrome(substring):\n            non_palindrome_part = st[0:i]\n            return st + non_palindrome_part[::-1]\n    return \"String not found\"",
    "detail": "build_palindrome",
    "documentation": {}
  },
  {
    "label": "maxProfit",
    "kind": 2,
    "importPath": "Buy_and_Sell_Stock",
    "description": "Buy_and_Sell_Stock",
    "peekOfCode": "def maxProfit(prices):\n    i = 0\n    max_profit = 0\n    while i < len(prices) - 1:\n        while i < len(prices) - 1 and prices[i] >= prices[i + 1]:\n            i += 1\n        min_pri = prices[i]\n        while i < len(prices) - 1 and prices[i] <= prices[i + 1]:\n            i += 1\n        max_pri = prices[i]",
    "detail": "Buy_and_Sell_Stock",
    "documentation": {}
  },
  {
    "label": "A,",
    "kind": 5,
    "importPath": "ByHeight (2)",
    "description": "ByHeight (2)",
    "peekOfCode": "A, = numpy.r_[eval(dir()[0])]\nA[A > 0] = sorted(A[A > 0])\nreturn A",
    "detail": "ByHeight (2)",
    "documentation": {}
  },
  {
    "label": "sortByHeight",
    "kind": 2,
    "importPath": "ByHeight",
    "description": "ByHeight",
    "peekOfCode": "def sortByHeight(a):\n    # Step 1: We begin by creating a counter, starting from 0, that will be used in the subsequent for-loop.\n    j = 0\n    # Step 2: We also create a new array, called \"a_sort\", where we sort (in ascending order) all elements of the given array \"a\"\n    # that are not \"trees\" (i.e. do not have a value of -1).\n    a_sort = sorted([i for i in a if i != -1])\n    # Step 3: By implementing a for-loop, we investigate all elements of the given array \"a\" (NOT a_sort!) and check:\n    # if the element i in array \"a\" is equal to -1, the for-loop continues. Otherwise, the element i in array \"a\" should be\n    # the same as element j in array \"a_sort\" (starting from 0 index, as defined in step 1).\n    # You can think of it as working through elements of array \"a\", disregarding the \"trees\" (-1s) and sorting the rest",
    "detail": "ByHeight",
    "documentation": {}
  },
  {
    "label": "candies",
    "kind": 2,
    "importPath": "candies",
    "description": "candies",
    "peekOfCode": "def candies(n, m):\n    return (m // n) * n",
    "detail": "candies",
    "documentation": {}
  },
  {
    "label": "century_from_year",
    "kind": 2,
    "importPath": "century_from_year",
    "description": "century_from_year",
    "peekOfCode": "def century_from_year(year: int = 0) -> int:\n    if isinstance(year, int) and 1 <= year <= 2005:\n        century = year // 100\n        if year % 100 == 0:\n            return century\n        else:\n            return century + 1\n    return 0",
    "detail": "century_from_year",
    "documentation": {}
  },
  {
    "label": "arrayChange",
    "kind": 2,
    "importPath": "Change",
    "description": "Change",
    "peekOfCode": "def arrayChange(inputArray):\n    first = inputArray[0]\n    count = 0\n    for i in inputArray[1:]:\n        if i <= first:\n            count += first - i + 1\n            first = first + 1\n        else:\n            first = i\n    return count",
    "detail": "Change",
    "documentation": {}
  },
  {
    "label": "commonCharacterCount",
    "kind": 2,
    "importPath": "CharacterCount",
    "description": "CharacterCount",
    "peekOfCode": "def commonCharacterCount(s1, s2):\n    # Step 1: We create two lists, namely s1_l and s2_l, where we store the characters of strings s1 and s2 respectively.\n    s1_l = list(s1)\n    s2_l = list(s2)\n    # Step 2: We also create an empty list, where we are going to store all common characters.\n    common = []\n    # Step 3: Using a for-loop, we investigate the list of the first string, element by element.\n    for i in s1_l:\n        # Step 4: If the i-th element from the list of the first string is also present in the list of the second string,\n        # we append it to the common array. BE CAREFUL: We must implement the s2_l.remove(i) to avoid double-counting.",
    "detail": "CharacterCount",
    "documentation": {}
  },
  {
    "label": "passwordCheck",
    "kind": 5,
    "importPath": "Check",
    "description": "Check",
    "peekOfCode": "passwordCheck = lambda s: len(s) > 4 and all(\n    re.search(i, s) for i in (\"[A-Z]\", \"\\d\", \"[a-z]\")\n)",
    "detail": "Check",
    "documentation": {}
  },
  {
    "label": "checkPalindrome",
    "kind": 2,
    "importPath": "check_palindrome",
    "description": "check_palindrome",
    "peekOfCode": "def checkPalindrome(inputString):\n    for i in range(len(inputString) // 2):\n        if inputString[i] != inputString[len(inputString) - 1 - i]:\n            return False\n    return True",
    "detail": "check_palindrome",
    "documentation": {}
  },
  {
    "label": "chessBoardCellColor",
    "kind": 2,
    "importPath": "chess_board_cell_color",
    "description": "chess_board_cell_color",
    "peekOfCode": "def chessBoardCellColor(cell1, cell2):\n    mydict = {\"A\": 1, \"B\": 2, \"C\": 3, \"D\": 4, \"E\": 5, \"F\": 6, \"G\": 7, \"H\": 8}\n    if (mydict[cell1[0]] + int(cell1[1])) % 2 == (mydict[cell2[0]] + int(cell2[1])) % 2:\n        return True\n    else:\n        return False",
    "detail": "chess_board_cell_color",
    "documentation": {}
  },
  {
    "label": "chessKnight",
    "kind": 2,
    "importPath": "chess_knight",
    "description": "chess_knight",
    "peekOfCode": "def chessKnight(cell):\n    valid_count = 0\n    # All possible moves for knight\n    dirs = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    # For each move of knight, check if it's valid\n    for x, y in dirs:\n        if (97 <= ord(cell[0]) + x <= 104) and (1 <= int(cell[1]) + y <= 8):\n            valid_count += 1\n    return valid_count",
    "detail": "chess_knight",
    "documentation": {}
  },
  {
    "label": "circleOfNumbers",
    "kind": 2,
    "importPath": "circle_of_numbers",
    "description": "circle_of_numbers",
    "peekOfCode": "def circleOfNumbers(n, firstNumber):\n\t\"\"\"\n\tReturn number that is radially opposite firstNumber\n\tin circle from 1 to n\n\t\"\"\"\n    return (firstNumber + (n / 2)) % n",
    "detail": "circle_of_numbers",
    "documentation": {}
  },
  {
    "label": "commonCharacterCount",
    "kind": 2,
    "importPath": "common_character_count",
    "description": "common_character_count",
    "peekOfCode": "def commonCharacterCount(s1, s2):\n    # To store the frequencies of characters\n    # of string s1 and s2\n    freq1 = [0] * 26\n    freq2 = [0] * 26\n    # To store the count of valid pairs\n    count = 0\n    # Update the frequencies of\n    # the characters of string s1\n    for i in range(len(s1)):",
    "detail": "common_character_count",
    "documentation": {}
  },
  {
    "label": "r",
    "kind": 5,
    "importPath": "Comparison",
    "description": "Comparison",
    "peekOfCode": "r = (a * d) / (b * c)\nreturn \"<\" if r < 1 else \">\" if r > 1 else \"=\"\n# 72 chars",
    "detail": "Comparison",
    "documentation": {}
  },
  {
    "label": "L,",
    "kind": 5,
    "importPath": "Consecutive",
    "description": "Consecutive",
    "peekOfCode": "L, = eval(dir()[0])\ns = 0\nwhile len(L) > 1:\n    L = (\n        numpy.add(L[:-1:2], L[1::2])\n        if s % 2 == 0\n        else numpy.multiply(L[:-1:2], L[1::2])\n    )\n    s += 1\nreturn L[0]",
    "detail": "Consecutive",
    "documentation": {}
  },
  {
    "label": "s",
    "kind": 5,
    "importPath": "Consecutive",
    "description": "Consecutive",
    "peekOfCode": "s = 0\nwhile len(L) > 1:\n    L = (\n        numpy.add(L[:-1:2], L[1::2])\n        if s % 2 == 0\n        else numpy.multiply(L[:-1:2], L[1::2])\n    )\n    s += 1\nreturn L[0]",
    "detail": "Consecutive",
    "documentation": {}
  },
  {
    "label": "L,",
    "kind": 5,
    "importPath": "Conversion",
    "description": "Conversion",
    "peekOfCode": "L, = eval(dir()[0])\ns = 0\nwhile len(L) > 1:\n    L = (\n        numpy.add(L[:-1:2], L[1::2])\n        if s % 2 == 0\n        else numpy.multiply(L[:-1:2], L[1::2])\n    )\n    s += 1\nreturn L[0]",
    "detail": "Conversion",
    "documentation": {}
  },
  {
    "label": "s",
    "kind": 5,
    "importPath": "Conversion",
    "description": "Conversion",
    "peekOfCode": "s = 0\nwhile len(L) > 1:\n    L = (\n        numpy.add(L[:-1:2], L[1::2])\n        if s % 2 == 0\n        else numpy.multiply(L[:-1:2], L[1::2])\n    )\n    s += 1\nreturn L[0]",
    "detail": "Conversion",
    "documentation": {}
  },
  {
    "label": "digitDegree",
    "kind": 2,
    "importPath": "Degree",
    "description": "Degree",
    "peekOfCode": "def digitDegree(n):\n    degree = 0\n    while 10 <= n:\n        num = str(n)\n        n = sum(int(i) for i in num)\n        degree += 1\n    return degree",
    "detail": "Degree",
    "documentation": {}
  },
  {
    "label": "deleteDigit",
    "kind": 2,
    "importPath": "delete_digit",
    "description": "delete_digit",
    "peekOfCode": "def deleteDigit(n):\n    digits = str(n)\n    values = []\n    for i in range(len(digits)):\n        value = int(digits[:i] + digits[(i + 1) :])\n        values.append(int(value))\n    return max(values)",
    "detail": "delete_digit",
    "documentation": {}
  },
  {
    "label": "depositProfit",
    "kind": 2,
    "importPath": "deposit_profit",
    "description": "deposit_profit",
    "peekOfCode": "def depositProfit(deposit, rate, threshold):\n    years = 0\n    while deposit < threshold:\n        deposit += deposit * (rate / 100)\n        years += 1\n    return years",
    "detail": "deposit_profit",
    "documentation": {}
  },
  {
    "label": "differentSquares",
    "kind": 2,
    "importPath": "different_squares",
    "description": "different_squares",
    "peekOfCode": "def differentSquares(matrix):\n\t\"\"\"\n\tReturn number of DIFFERENT 2 * 2 squares in rectangular matrix.\n    Time Complexity: O(N^2)\n    Space Complexity: O(N)\n\t\"\"\"\n    squares = set()\n    for i in range(len(matrix) - 1):\n        for j in range(len(matrix[i]) - 1):\n            squares.add((matrix[i][j], matrix[i][j + 1], matrix[i + 1][j], matrix[i + 1][j + 1]))",
    "detail": "different_squares",
    "documentation": {}
  },
  {
    "label": "differentSymbolsNaive",
    "kind": 2,
    "importPath": "different_symbols_is_naive",
    "description": "different_symbols_is_naive",
    "peekOfCode": "def differentSymbolsNaive(s):\n    return len(set(s))",
    "detail": "different_symbols_is_naive",
    "documentation": {}
  },
  {
    "label": "deleteDigit",
    "kind": 2,
    "importPath": "Digit",
    "description": "Digit",
    "peekOfCode": "def deleteDigit(n):\n    num = str(n)\n    result = list(int(\"\".join(num[:i] + num[1 + i :])) for i in range(len(num)))\n    return max(result)",
    "detail": "Digit",
    "documentation": {}
  },
  {
    "label": "evenDigitsOnly",
    "kind": 2,
    "importPath": "DigitsOnly",
    "description": "DigitsOnly",
    "peekOfCode": "def evenDigitsOnly(n):\n    digits_of_n = []\n    while n > 0:\n        rem = n % 10\n        digits_of_n.append(rem)\n        n = int(n / 10)\n    for i in range(len(digits_of_n)):\n        if digits_of_n[i] % 2 != 0:\n            return False\n    return True",
    "detail": "DigitsOnly",
    "documentation": {}
  },
  {
    "label": "longestDigitsPrefix",
    "kind": 2,
    "importPath": "DigitsPrefix",
    "description": "DigitsPrefix",
    "peekOfCode": "def longestDigitsPrefix(inputString):\n    count = 0\n    for i in range(len(inputString)):\n        if inputString[i].isdigit():\n            count += 1\n        else:\n            return inputString[0:count]\n    return inputString",
    "detail": "DigitsPrefix",
    "documentation": {}
  },
  {
    "label": "digitsProduct",
    "kind": 2,
    "importPath": "digits_product",
    "description": "digits_product",
    "peekOfCode": "def digitsProduct(product):\n    \"\"\"\n    Given an integer product, find the smallest \n    positive (i.e. greater than 0) integer the \n    product of whose digits is equal to product. \n    If there is no such integer, return -1 instead.\n    Time Complexity: O(inf)\n    Space Complexity: O(1)\n    \"\"\"\n    number = 1",
    "detail": "digits_product",
    "documentation": {}
  },
  {
    "label": "digitDegree",
    "kind": 2,
    "importPath": "digit_degree",
    "description": "digit_degree",
    "peekOfCode": "def digitDegree(n):\n    number, degree = str(n), 0\n    while len(number) != 1:\n        number = str(sum([int(digit) for digit in number]))\n        degree += 1\n    return degree",
    "detail": "digit_degree",
    "documentation": {}
  },
  {
    "label": "extractEachKth",
    "kind": 2,
    "importPath": "EachKth",
    "description": "EachKth",
    "peekOfCode": "def extractEachKth(inputArray, k):\n    inp = []\n    for i in range(len(inputArray)):\n        if (i + 1) % k == 0:\n            pass\n        else:\n            inp.append(inputArray[i])\n    return inp",
    "detail": "EachKth",
    "documentation": {}
  },
  {
    "label": "electionsWinners",
    "kind": 2,
    "importPath": "election_winners",
    "description": "election_winners",
    "peekOfCode": "def electionsWinners(votes, k):\n    \"\"\"Find number of candidates that have chance to win election\n    Args:\n        votes(int): List of number of votes given to each candidate so far.\n        k(int): Number of voters who haven't cast their vote yet.\n    Return:\n        Number of candidates that still have chance to win election\n    Raises:\n    \"\"\"\n    highest = max(votes)",
    "detail": "election_winners",
    "documentation": {}
  },
  {
    "label": "adjacentElementsProduct",
    "kind": 2,
    "importPath": "ElementsProduct",
    "description": "ElementsProduct",
    "peekOfCode": "def adjacentElementsProduct(inputArray):\n    # Step 1: Initially, define an empty array where we will store the products of adjacent elements from the input array.\n    ArrayEnd = []\n    # Step 2: Using a for-loop, we go over all entries of the input array, calculating the products of adjacent elements\n    # and appending them to the empty array from step 1.\n    for i in range(len(inputArray) - 1):\n        ArrayEnd.append(inputArray[i] * inputArray[i + 1])\n    # Step 3: We seek the largest entry in \"ArrayEnd\" from step 1, using the max() function.\n    maximum = max(ArrayEnd)\n    return maximum",
    "detail": "ElementsProduct",
    "documentation": {}
  },
  {
    "label": "matrixElementsSum",
    "kind": 2,
    "importPath": "ElementsSum",
    "description": "ElementsSum",
    "peekOfCode": "def matrixElementsSum(matrix):\n    # Step 1: We begin by defining the number of rows and columns inside our given matrix.\n    # You can conceive the number of rows as the number of nested arrays inside the main array and\n    # the number of columns as the number of elements in the first nested array.\n    # Feel free to convince yourself that this is the case by referring to the examples of matrices shown above.\n    rows = len(matrix)\n    cols = len(matrix[0])\n    # Step 2: Furthermore, create a new variable called \"summ\" (from summation) and set it equal to zero.\n    # It will be used in the following for-loop.\n    summ = 0",
    "detail": "ElementsSum",
    "documentation": {}
  },
  {
    "label": "matrix",
    "kind": 5,
    "importPath": "ElementsSum",
    "description": "ElementsSum",
    "peekOfCode": "matrix = [[0, 1, 1, 2],\n          [0, 5, 0, 0],\n          [2, 0, 3, 3]]\nthe output should be matrixElementsSum(matrix) = 9.\nexample 1: There are several haunted rooms, so we'll disregard them as well as any rooms beneath them.\nThus, the answer is 1 + 5 + 1 + 2 = 9. (PICTURE PROVIDED AT:WWW.CODESIGNAL.COM)\nFor\nmatrix = [[1, 1, 1, 0],\n          [0, 5, 0, 1],\n          [2, 1, 3, 10]]",
    "detail": "ElementsSum",
    "documentation": {}
  },
  {
    "label": "matrix",
    "kind": 5,
    "importPath": "ElementsSum",
    "description": "ElementsSum",
    "peekOfCode": "matrix = [[1, 1, 1, 0],\n          [0, 5, 0, 1],\n          [2, 1, 3, 10]]\nthe output should be matrixElementsSum(matrix) = 9.\nexample 2:\nNote that the free room in the final column makes the full column unsuitable for bots (not just the room directly beneath it).\nThus, the answer is 1 + 1 + 1 + 5 + 1 = 9. (PICTURE PROVIDED AT:WWW.CODESIGNAL.COM)\"\"\"\ndef matrixElementsSum(matrix):\n    # Step 1: We begin by defining the number of rows and columns inside our given matrix.\n    # You can conceive the number of rows as the number of nested arrays inside the main array and",
    "detail": "ElementsSum",
    "documentation": {}
  },
  {
    "label": "findEmailDomain",
    "kind": 2,
    "importPath": "EmailDomain",
    "description": "EmailDomain",
    "peekOfCode": "def findEmailDomain(address):\n    address_spl = address.split(\"@\")\n    c = [i for i in address_spl]\n    if len(address_spl) == 2:\n        return c[1]\n    if len(address_spl) == 3:\n        return c[2]",
    "detail": "EmailDomain",
    "documentation": {}
  },
  {
    "label": "lineEncoding",
    "kind": 2,
    "importPath": "Encoding",
    "description": "Encoding",
    "peekOfCode": "def lineEncoding(s):\n    s2 = \"\"\n    for k, g in groupby(s):\n        l = len(list(g))\n        if l == 1:\n            s2 += k\n        else:\n            s2 += str(l) + k\n    return s2",
    "detail": "Encoding",
    "documentation": {}
  },
  {
    "label": "areEquallyStrong",
    "kind": 2,
    "importPath": "EquallyStrong",
    "description": "EquallyStrong",
    "peekOfCode": "def areEquallyStrong(yourLeft, yourRight, friendsLeft, friendsRight):\n    personal_max = max(yourLeft, yourRight)\n    friend_max = max(friendsLeft, friendsRight)\n    sum1 = yourLeft + yourRight\n    sum2 = friendsLeft + friendsRight\n    if sum1 == sum2 and personal_max == friend_max:\n        return True\n    return False",
    "detail": "EquallyStrong",
    "documentation": {}
  },
  {
    "label": "evenDigitsOnly",
    "kind": 2,
    "importPath": "even_digits_only",
    "description": "even_digits_only",
    "peekOfCode": "def evenDigitsOnly(n):\n    digits = [int(digit) for digit in str(n)]  # Convert digits to list of strings\n    for digit in digits:\n        if digit % 2 == 1:\n            return False\n    return True",
    "detail": "even_digits_only",
    "documentation": {}
  },
  {
    "label": "extractEachKth",
    "kind": 2,
    "importPath": "extract_each_kth",
    "description": "extract_each_kth",
    "peekOfCode": "def extractEachKth(inputArray, k):\n    \"\"\"Function to remove each kth element from list of integers\n    Args:\n        inputArray(int): List of integers\n        k(int): position of elements to remove from list\n    Return:\n        The list with kth elements removed\n    Raises:\n    \"\"\"\n    new_list = []",
    "detail": "extract_each_kth",
    "documentation": {}
  },
  {
    "label": "extraNumber",
    "kind": 2,
    "importPath": "extra_number",
    "description": "extra_number",
    "peekOfCode": "def extraNumber(a, b, c):\n    \"\"\"\n    You're given three integers, a, b and c. It is \n    guaranteed that two of these integers are equal \n    to each other. What is the value of the third integer?\n    \"\"\"\n    if a == b:\n        return c\n    elif a == c:\n        return b",
    "detail": "extra_number",
    "documentation": {}
  },
  {
    "label": "fileNaming",
    "kind": 2,
    "importPath": "file_naming",
    "description": "file_naming",
    "peekOfCode": "def fileNaming(names):\n    \"\"\"\n    Since two files cannot have equal names, \n    the one which comes later will have an addition \n    to its name in a form of (k), where k is the smallest \n    positive integer such that the obtained name is not \n    used yet. Return an array of names that will be given \n    to the files.\n    \"\"\"\n    new_file_names = []",
    "detail": "file_naming",
    "documentation": {}
  },
  {
    "label": "findEmailDomain",
    "kind": 2,
    "importPath": "find_email_domain",
    "description": "find_email_domain",
    "peekOfCode": "def findEmailDomain(address):\n    return address.split(\"@\")[-1]",
    "detail": "find_email_domain",
    "documentation": {}
  },
  {
    "label": "firstDigit",
    "kind": 2,
    "importPath": "first_digit",
    "description": "first_digit",
    "peekOfCode": "def firstDigit(inputString):\n    \"\"\"Finds leftmost digit that occurs in a given string\n    Args:\n        inputString(string): input string\n    Return:\n        Leftmost digit occurring in string\n    Raises:\n    \"\"\"\n    for char in inputString:\n        if char.isdigit():",
    "detail": "first_digit",
    "documentation": {}
  },
  {
    "label": "firstDuplicate",
    "kind": 2,
    "importPath": "first_duplicate",
    "description": "first_duplicate",
    "peekOfCode": "def firstDuplicate(a):\n    number_frequencies, number_indices, duplicate_index = {}, {}, {}\n    # Iterate through list and increment frequency count\n    # if number not in dict. Also, note the index asscoiated\n    # with the value\n    for i in range(len(a)):\n        if a[i] not in number_frequencies:\n            number_frequencies[a[i]] = 1\n            number_indices[a[i]] = i\n        elif a[i] in number_frequencies:",
    "detail": "first_duplicate",
    "documentation": {}
  },
  {
    "label": "firstNotRepeatingCharacter",
    "kind": 2,
    "importPath": "first_not_repeating_character",
    "description": "first_not_repeating_character",
    "peekOfCode": "def firstNotRepeatingCharacter(s):\n    character_count, character_index, non_repeat_index = {}, {}, {}\n    # Iterate through string and count\n    # character occurences and note\n    # index of first repetition\n    for i in range(len(s)):\n        if s[i] not in character_count:\n            character_count[s[i]] = 1\n            character_index[s[i]] = i\n        elif s[i] in character_count:",
    "detail": "first_not_repeating_character",
    "documentation": {}
  },
  {
    "label": "messageFromBinaryCode",
    "kind": 2,
    "importPath": "FromBinaryCode",
    "description": "FromBinaryCode",
    "peekOfCode": "def messageFromBinaryCode(code):\n    phrase = \"\"\n    bits = [int(code[i * 8 : i * 8 + 8], 2) for i in range(len(code) // 8)]\n    for j in range(len(bits)):\n        phrase += chr(bits[j])\n    return phrase",
    "detail": "FromBinaryCode",
    "documentation": {}
  },
  {
    "label": "centuryFromYear",
    "kind": 2,
    "importPath": "FromYear",
    "description": "FromYear",
    "peekOfCode": "def centuryFromYear(year):\n    # We begin by getting the INTEGER quotient of the division of the year given by 100.\n    # This will give us the first two digits, which would be the century.\n    cen = int(year / 100)\n    # However, we should keep in mind that we refer to years between e.g. 1701 - 1800\n    # as the \"18th century\". Hence, we implement a while loop, where the condition is\n    # that the year is a positive integer (which is always true). If the remainder of the\n    # division of the year by 100 is 0, then the two first digits of the division represent\n    # the century. Otherwise, if the remainder is non-zero, the century is found by adding 1\n    # to the result of the division (i.e. \"cen\").",
    "detail": "FromYear",
    "documentation": {}
  },
  {
    "label": "groupAnagrams",
    "kind": 2,
    "importPath": "group_anagrams",
    "description": "group_anagrams",
    "peekOfCode": "def groupAnagrams(strs):\n    # \"\"\"\n    # TimeComplexity: O(n*K*log(K)) where n is the length of strs and K is the length of the longest string\n    #  in strs\n    # \"\"\"\n    # seen = {}\n    # for s in strs:\n    #     ele = tuple((sorted(s)))\n    #     if ele in seen:\n    #         seen[ele].append(s)",
    "detail": "group_anagrams",
    "documentation": {}
  },
  {
    "label": "growingPlant",
    "kind": 2,
    "importPath": "growing_plant",
    "description": "growing_plant",
    "peekOfCode": "def growingPlant(upSpeed, downSpeed, desiredHeight):\n    height = 0\n    days = 1\n    height += upSpeed\n    while height < desiredHeight:\n        days += 1\n        height -= downSpeed\n        height += upSpeed\n    return days",
    "detail": "growing_plant",
    "documentation": {}
  },
  {
    "label": "almostIncreasingSequence",
    "kind": 2,
    "importPath": "IncreasingSequence",
    "description": "IncreasingSequence",
    "peekOfCode": "def almostIncreasingSequence(sequence):\n    # Step 1: We begin by assigning the length of the given sequence to the variable n.\n    n = len(sequence)\n    # Step 2: By definition, if the sequence contains up to 1 elements, it is considered to be strictly increasing.\n    if n <= 2:\n        return True\n    # Step 3: We set up two counters, namely c1 and c2, so that we count how many elements should be removed.\n    # NOTE THAT c1 refers ONLY to adjacent elements whilst c2 refers to elements just before and just after the i-th element.\n    c1 = 0\n    c2 = 0",
    "detail": "IncreasingSequence",
    "documentation": {}
  },
  {
    "label": "reverseInParentheses",
    "kind": 2,
    "importPath": "InParentheses",
    "description": "InParentheses",
    "peekOfCode": "def reverseInParentheses(inputString):\n    # Step 1: We create a for-loop that goes over all elements of the input string. If element i is an opening bracket, then i\n    # is defined as \"start\". In a similar manner, if element i is a closing bracket, i is defined as \"end\". NOTE THAT\n    # if you write it as \"i = start\" or \"i = end\", an error will pop up (tested) as you would have not defined any variables\n    # under those names, whilst the way that is written now you define as \"start\" and \"end\" elements that are\n    # \"(\" and \")\" respectively.\n    for i in range(len(inputString)):\n        if inputString[i] == \"(\":\n            start = i\n        if inputString[i] == \")\":",
    "detail": "InParentheses",
    "documentation": {}
  },
  {
    "label": "isIPv4Address",
    "kind": 2,
    "importPath": "IPv4Address",
    "description": "IPv4Address",
    "peekOfCode": "def isIPv4Address(inputString):\n    str_split = inputString.split(\".\")\n    count = 0\n    if len(str_split) != 4:\n        return False\n    for i in range(0, 4):\n        if str_split[i] == \"\" or str_split[i] == \"00\" or str_split[i] == \"01\":\n            return False\n        if re.search(\"[a-zA-Z]\", str_split[i]):\n            count += 1",
    "detail": "IPv4Address",
    "documentation": {}
  },
  {
    "label": "isDigit",
    "kind": 2,
    "importPath": "isDigit",
    "description": "isDigit",
    "peekOfCode": "def isDigit(symbol):\n    return symbol.isdigit()",
    "detail": "isDigit",
    "documentation": {}
  },
  {
    "label": "isIPv4Address",
    "kind": 2,
    "importPath": "isIPv4Address",
    "description": "isIPv4Address",
    "peekOfCode": "def isIPv4Address(inputString):\n    try:\n        ip = ipaddress.ip_address(inputString)\n        return True\n    except ValueError:\n        return False",
    "detail": "isIPv4Address",
    "documentation": {}
  },
  {
    "label": "isMAC48Address",
    "kind": 2,
    "importPath": "isMAC48Address",
    "description": "isMAC48Address",
    "peekOfCode": "def isMAC48Address(inputString):\n    \"\"\"Checks if inputString is a valid MAC48 address\n    Args:\n        inputString(string): String to check\n    Return:\n        Boolean indicating if string is valid MAC48 address\n    Raises:\n    \"\"\"\n    if re.match(\n        \"[0-9a-f]{2}([-:])[0-9a-f]{2}(\\\\1[0-9a-f]{2}){4}$\", inputString.lower()",
    "detail": "isMAC48Address",
    "documentation": {}
  },
  {
    "label": "isBeautifulString",
    "kind": 2,
    "importPath": "is_beautiful_string",
    "description": "is_beautiful_string",
    "peekOfCode": "def isBeautifulString(inputString):\n    b = dict()\n    for char in inputString:\n        if ord(char) in b:\n            b[ord(char)] += 1\n        else:\n            b[ord(char)] = 1\n    for i in b.keys():\n        if i == 97:\n            continue",
    "detail": "is_beautiful_string",
    "documentation": {}
  },
  {
    "label": "isCryptSolution",
    "kind": 2,
    "importPath": "is_crypt_solution",
    "description": "is_crypt_solution",
    "peekOfCode": "def isCryptSolution(crypt, solution):\n    decoded_words, decoded_word = [], \"\"\n    # Decode the words in the cryptarithm\n    for i in range(len(crypt)):\n        for j in range(len(crypt[i])):\n            for k in range(len(solution)):\n                if crypt[i][j] == solution[k][0]:\n                    decoded_word += solution[k][1]\n        decoded_words.append(decoded_word)\n        decoded_word = \"\"",
    "detail": "is_crypt_solution",
    "documentation": {}
  },
  {
    "label": "isInfiniteProcess",
    "kind": 2,
    "importPath": "is_infinite_process",
    "description": "is_infinite_process",
    "peekOfCode": "def isInfiniteProcess(a, b):\n\t\"\"\"\n\tGiven integers a and b, determine whether the following \n\tpseudocode results in an infinite loop\n\twhile a is not equal to b do\n\t\tincrease a by 1\n\t\tdecrease b by 1\n\tAssume that the program is executed on a virtual machine \n\twhich can store arbitrary long numbers and execute forever.\n\t\"\"\"",
    "detail": "is_infinite_process",
    "documentation": {}
  },
  {
    "label": "isLucky",
    "kind": 2,
    "importPath": "is_lucky",
    "description": "is_lucky",
    "peekOfCode": "def isLucky(n):\n    digits = [int(digit) for digit in str(n)]\n    if len(digits) % 2 == 1:\n        return False\n    else:\n        digits = [int(digit) for digit in str(n)]\n        mid = len(digits) // 2\n        if sum(digits[:mid]) == sum(digits[mid:]):\n            return True\n        else:",
    "detail": "is_lucky",
    "documentation": {}
  },
  {
    "label": "knapsackLight",
    "kind": 2,
    "importPath": "knapsack_light",
    "description": "knapsack_light",
    "peekOfCode": "def knapsackLight(value1, weight1, value2, weight2, maxW):\n    val = 0\n    if value2 > value1:\n        val = value1\n        value1 = value2\n        value2 = val\n        val = weight1\n        weight1 = weight2\n        weight2 = val\n    val = 0",
    "detail": "knapsack_light",
    "documentation": {}
  },
  {
    "label": "chessKnight",
    "kind": 2,
    "importPath": "Knight",
    "description": "Knight",
    "peekOfCode": "def chessKnight(cell):\n    knight_dir = list(t.permutations([1, 2, -1, -2], 2))\n    knight_dir1 = []\n    valid_moves = 0\n    for i in range(len(knight_dir)):\n        if sum(knight_dir[i]) != 0:\n            knight_dir1.append(knight_dir[i])\n    for x, y in knight_dir1:\n        if (97 <= ord(cell[0]) + x <= 104) and (1 <= int(cell[1]) + y <= 8):\n            valid_moves += 1",
    "detail": "Knight",
    "documentation": {}
  },
  {
    "label": "largestNumber",
    "kind": 2,
    "importPath": "largest_number",
    "description": "largest_number",
    "peekOfCode": "def largestNumber(n):\n    return pow(10, n) - 1",
    "detail": "largest_number",
    "documentation": {}
  },
  {
    "label": "lateRide",
    "kind": 2,
    "importPath": "late_ride",
    "description": "late_ride",
    "peekOfCode": "def lateRide(n):\n\t\"\"\"\n\tReturn sum of hours and minutes past 00:00\n\t\"\"\"\n    hours = str(n // 60)\n    minutes = str(n % 60)\n    total = 0\n    for digit in hours:\n        total += int(digit)\n    for digit in minutes:",
    "detail": "late_ride",
    "documentation": {}
  },
  {
    "label": "knapsackLight",
    "kind": 2,
    "importPath": "Light",
    "description": "Light",
    "peekOfCode": "def knapsackLight(value1, weight1, value2, weight2, maxW):\n    if weight1 > maxW and weight2 > maxW and weight1 + weight2 > maxW:\n        return 0\n    if weight1 + weight2 <= maxW:\n        return value1 + value2\n    if value1 < value2:\n        if weight2 > maxW:\n            return value1\n        else:\n            return value2",
    "detail": "Light",
    "documentation": {}
  },
  {
    "label": "lineEncoding",
    "kind": 2,
    "importPath": "line_encoding",
    "description": "line_encoding",
    "peekOfCode": "def lineEncoding(s):\n    encoding, character_count = \"\", 1\n    for i in range(len(s) - 1):\n        if s[i] == s[i + 1]:\n            character_count += 1\n        else:\n            if character_count > 1:\n                encoding += str(character_count) + s[i]  # Add substring to encoding\n                character_count = 1  # Reset character count\n            else:",
    "detail": "line_encoding",
    "documentation": {}
  },
  {
    "label": "ListNode",
    "kind": 6,
    "importPath": "List",
    "description": "List",
    "peekOfCode": "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        get_len = 0\n        current = head\n        while current:\n            get_len += 1",
    "detail": "List",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "List",
    "description": "List",
    "peekOfCode": "class Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        get_len = 0\n        current = head\n        while current:\n            get_len += 1\n            current = current.next\n        mid = get_len // 2\n        current = head\n        while mid > 0:",
    "detail": "List",
    "documentation": {}
  },
  {
    "label": "allLongestStrings",
    "kind": 2,
    "importPath": "LongestStrings",
    "description": "LongestStrings",
    "peekOfCode": "def allLongestStrings(inputArray):\n    # Step 1: We begin by defining an empty array called \"max_arr\", where we will store the longest strings from the given array.\n    max_arr = []\n    # Step 2: The next step is to define the maximum string length inside our given array.\n    # BE CAREFUL: Variable max_len should be defined as follows. If we break it into its components, we can see that:\n    # max(inputArray, key = len) locates ONLY ONE of the strings that satisfies the maximum value in terms of the key parameter\n    # provided (which, in this case, is the string's length) and the outside len() function defines the value of this maximum length.\n    # You are free to test it on a random input array containing various random strings, using a Python compiler online.\n    max_len = len(max(inputArray, key=len))\n    # Step 3: Now, we go over all strings inside the input array checking if their individual length is equal to the",
    "detail": "LongestStrings",
    "documentation": {}
  },
  {
    "label": "longestDigitsPrefix",
    "kind": 2,
    "importPath": "longest_digits_prefix",
    "description": "longest_digits_prefix",
    "peekOfCode": "def longestDigitsPrefix(inputString):\n    for i in range(len(inputString)):\n        if not inputString[i].isdigit():\n            return inputString[:i]\n    return inputString",
    "detail": "longest_digits_prefix",
    "documentation": {}
  },
  {
    "label": "longestWord",
    "kind": 2,
    "importPath": "longest_word",
    "description": "longest_word",
    "peekOfCode": "def longestWord(text):\n\t\"\"\"\n\tReturn longest word in text string\n\tTime Complexity: O(n)\n\tSpace Complexity: O(n)\n\t\"\"\"\n    word, words = '', []\n    for i in range(len(text)):\n        if text[i].isalpha():\n            word += text[i]",
    "detail": "longest_word",
    "documentation": {}
  },
  {
    "label": "isLucky",
    "kind": 2,
    "importPath": "Lucky",
    "description": "Lucky",
    "peekOfCode": "def isLucky(n):\n    # Step 1: We begin by creating an empty array, called \"digits_of_n\",\n    # where we will store the digits of the given number n, as individual elements.\n    digits_of_n = []\n    # Step 2: We also create a new variable, called \"summ\" (from summation), and set its value to zero.\n    # It will be useful in one of the later steps.\n    summ = 0\n    # Step 3: I have personally seen this while-loop trick being used to split numbers into their individual digits.\n    # As it will take quite a long text to explain this comprehensively, I'd suggest you use the print() function in each\n    # step to see what how each of these steps works. The important thing to mention is the \"appending\" step where each",
    "detail": "Lucky",
    "documentation": {}
  },
  {
    "label": "isMAC48Address",
    "kind": 2,
    "importPath": "MAC48Address",
    "description": "MAC48Address",
    "peekOfCode": "def isMAC48Address(inputString):\n    str_split = inputString.split(\"-\")\n    count = 0\n    if len(inputString) != 17:\n        return False\n    if len(str_split) != 6:\n        return False\n    for i in range(0, 6):\n        if str_split[i] == \"\":\n            return False",
    "detail": "MAC48Address",
    "documentation": {}
  },
  {
    "label": "makeArrayConsecutive2",
    "kind": 2,
    "importPath": "make_array_consecutive2",
    "description": "make_array_consecutive2",
    "peekOfCode": "def makeArrayConsecutive2(statues):\n    additional_statues = 0\n    sorted_statues = sorted(statues)  # Sort the statues\n    for i in range(len(sorted_statues) - 1):\n        if sorted_statues[i + 1] - sorted_statues[i] != 1:\n            additional_statues += (sorted_statues[i + 1] - sorted_statues[i]) - 1\n    return additional_statues",
    "detail": "make_array_consecutive2",
    "documentation": {}
  },
  {
    "label": "matrixElementsSum",
    "kind": 2,
    "importPath": "matrix_elements_sum",
    "description": "matrix_elements_sum",
    "peekOfCode": "def matrixElementsSum(matrix):\n    runningsum = 0\n    for i in range(len(matrix)):\n        for j in range(len(matrix[i])):\n            if matrix[i][j] == 0 and i + 1 < len(matrix):\n                matrix[i + 1][j] = 0\n            runningsum += matrix[i][j]\n    return runningsum",
    "detail": "matrix_elements_sum",
    "documentation": {}
  },
  {
    "label": "arrayMaxConsecutiveSum",
    "kind": 2,
    "importPath": "MaxConsecutiveSum",
    "description": "MaxConsecutiveSum",
    "peekOfCode": "def arrayMaxConsecutiveSum(inputArray, k):\n    arr = [sum(inputArray[:k])]\n    for i in range(1, len(inputArray) - (k - 1)):\n        arr.append(arr[i - 1] - inputArray[i - 1] + inputArray[i + k - 1])\n    sort_arr = sorted(arr)\n    return sort_arr[-1]",
    "detail": "MaxConsecutiveSum",
    "documentation": {}
  },
  {
    "label": "arrayMaximalAdjacentDifference",
    "kind": 2,
    "importPath": "MaximalAdjacentDifference",
    "description": "MaximalAdjacentDifference",
    "peekOfCode": "def arrayMaximalAdjacentDifference(inputArray):\n    return max(\n        (abs(inputArray[i + 1] - inputArray[i]) for i in range(0, len(inputArray) - 1))\n    )",
    "detail": "MaximalAdjacentDifference",
    "documentation": {}
  },
  {
    "label": "maxMultiple",
    "kind": 2,
    "importPath": "max_multiple",
    "description": "max_multiple",
    "peekOfCode": "def maxMultiple(divisor, bound):\n\t\"\"\"\n\tReturn number n that is greater than 0, less than\n\tor equal to bound and divisible by divisor\n\t\"\"\"\n    number = 0\n    while number <= bound and number % divisor == 0:\n        number += divisor\n    number -= divisor\n    return number",
    "detail": "max_multiple",
    "documentation": {}
  },
  {
    "label": "r",
    "kind": 5,
    "importPath": "Meetings",
    "description": "Meetings",
    "peekOfCode": "r = -1\nl = len(p)\nfor i in range(l):\n    for j in range(l):\n        c = 0\n        d = p[j] - p[i]\n        f = s[i] - s[j]\n        if d * f < 1:\n            continue\n        for k in range(l):",
    "detail": "Meetings",
    "documentation": {}
  },
  {
    "label": "l",
    "kind": 5,
    "importPath": "Meetings",
    "description": "Meetings",
    "peekOfCode": "l = len(p)\nfor i in range(l):\n    for j in range(l):\n        c = 0\n        d = p[j] - p[i]\n        f = s[i] - s[j]\n        if d * f < 1:\n            continue\n        for k in range(l):\n            if p[k] * f + s[k] * d == p[i] * f + s[i] * d:",
    "detail": "Meetings",
    "documentation": {}
  },
  {
    "label": "calculateSubstringsLengthK",
    "kind": 2,
    "importPath": "message_from_binary_code",
    "description": "message_from_binary_code",
    "peekOfCode": "def calculateSubstringsLengthK(s, k):\n    \"\"\"\n    Return substrings of size k in s\n    \"\"\"\n    substrings, index = [], 0\n    while index + k <= len(s):\n        substrings.append(s[index : index + k])\n        index += k\n    return substrings\ndef messageFromBinaryCode(code):",
    "detail": "message_from_binary_code",
    "documentation": {}
  },
  {
    "label": "messageFromBinaryCode",
    "kind": 2,
    "importPath": "message_from_binary_code",
    "description": "message_from_binary_code",
    "peekOfCode": "def messageFromBinaryCode(code):\n    \"\"\"\n    Return encrypted message from binary code\n    \"\"\"\n    substrings, encrypted_message = calculateSubstringsLengthK(code, 8), \"\"\n    for substring in substrings:\n        ascii_code = int(substring, 2)\n        encrypted_message += chr(ascii_code)\n    return encrypted_message",
    "detail": "message_from_binary_code",
    "documentation": {}
  },
  {
    "label": "neighbours",
    "kind": 2,
    "importPath": "minesweeper",
    "description": "minesweeper",
    "peekOfCode": "def neighbours(matrix, i, j, rows, columns):\n    mines = 0\n    # Top left\n    if i >= 1 and j >= 1:\n        if matrix[i - 1][j - 1]:\n            mines += 1\n    # Top center\n    if i >= 1:\n        if matrix[i - 1][j]:\n            mines += 1",
    "detail": "minesweeper",
    "documentation": {}
  },
  {
    "label": "minesweeper",
    "kind": 2,
    "importPath": "minesweeper",
    "description": "minesweeper",
    "peekOfCode": "def minesweeper(matrix):\n    rows, columns = len(matrix), len(matrix[0])\n    game_setup = []\n    for i in range(rows):\n        game_setup_row = []\n        for j in range(columns):\n            game_setup_row.append(neighbours(matrix, i, j, rows, columns))\n        game_setup.append(game_setup_row)\n    return game_setup",
    "detail": "minesweeper",
    "documentation": {}
  },
  {
    "label": "smallestMultiple",
    "kind": 2,
    "importPath": "Multiple",
    "description": "Multiple",
    "peekOfCode": "def smallestMultiple(l, r):\n    for i in range(1, 16):\n        for j in range(l, r + 1):\n            while True:\n                if i % j != 0:\n                    break\n            return i",
    "detail": "Multiple",
    "documentation": {}
  },
  {
    "label": "variableName",
    "kind": 2,
    "importPath": "Name",
    "description": "Name",
    "peekOfCode": "def variableName(name):\n    str_name = [i for i in str(name)]\n    non_acc_chars = [\n        \" \",\n        \">\",\n        \"<\",\n        \":\",\n        \"-\",\n        \"|\",\n        \".\",",
    "detail": "Name",
    "documentation": {}
  },
  {
    "label": "fileNaming",
    "kind": 2,
    "importPath": "Naming",
    "description": "Naming",
    "peekOfCode": "def fileNaming(names):\n    if names == []:\n        return []\n    new_names = []\n    for name in names:\n        if name not in new_names:\n            new_names.append(name)\n        else:\n            for i in range(1, 1000):\n                new_name = name + \"(\" + str(i) + \")\"",
    "detail": "Naming",
    "documentation": {}
  },
  {
    "label": "singleNumber",
    "kind": 2,
    "importPath": "Number (2)",
    "description": "Number (2)",
    "peekOfCode": "def singleNumber(nums):\n    \"\"\"\n    given a list of integer with every element appears twice and a single number appears once, return the value of the\n    single number\n    \"\"\"\n    count = Counter(nums)\n    for k, v in count.items():\n        if v == 1:\n            return k\nprint(singleNumber([2, 2, 4, 1, 5]))",
    "detail": "Number (2)",
    "documentation": {}
  },
  {
    "label": "isHappy",
    "kind": 2,
    "importPath": "Number",
    "description": "Number",
    "peekOfCode": "def isHappy(n):\n    \"\"\"\n    Is happy takes in a number and returns True if it is a happy number, False otherwise. A happy number\n    is a number defined by the following process: Starting with any positive integer, replace the number by the\n    sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay),\n    or it loops endlessly in a cycle which does not include 1.\n    \"\"\"\n    seen = {n: 1}\n    while True:\n        new_sq = sum([int(d) ** 2 for d in str(n)])",
    "detail": "Number",
    "documentation": {}
  },
  {
    "label": "memo",
    "kind": 5,
    "importPath": "Number",
    "description": "Number",
    "peekOfCode": "memo = {}\ndef isHappy(n):\n    \"\"\"\n    Is happy takes in a number and returns True if it is a happy number, False otherwise. A happy number\n    is a number defined by the following process: Starting with any positive integer, replace the number by the\n    sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay),\n    or it loops endlessly in a cycle which does not include 1.\n    \"\"\"\n    seen = {n: 1}\n    while True:",
    "detail": "Number",
    "documentation": {}
  },
  {
    "label": "spiralNumbers",
    "kind": 2,
    "importPath": "Numbers",
    "description": "Numbers",
    "peekOfCode": "def spiralNumbers(n):\n    dims = n\n    elem = 1\n    matrix = [[0] * n for x in range(n)]\n    while 0 < dims:\n        i = n - dims\n        # you can sub i = n - dims ONLY in the first 2 parts\n        # where n - dims is in the starting parameter of the range\n        for j in range(n - dims, dims):\n            matrix[i][j] = elem",
    "detail": "Numbers",
    "documentation": {}
  },
  {
    "label": "avoidObstacles",
    "kind": 2,
    "importPath": "Obstacles",
    "description": "Obstacles",
    "peekOfCode": "def avoidObstacles(inputArray):\n    for i in range(2, max(inputArray) + 2):\n        if i not in inputArray and all(j % i != 0 for j in inputArray):\n            return i",
    "detail": "Obstacles",
    "documentation": {}
  },
  {
    "label": "circleOfNumbers",
    "kind": 2,
    "importPath": "OfNumbers",
    "description": "OfNumbers",
    "peekOfCode": "def circleOfNumbers(n, firstNumber):\n    return ((n / 2) + firstNumber) % n",
    "detail": "OfNumbers",
    "documentation": {}
  },
  {
    "label": "sumOfSquares",
    "kind": 2,
    "importPath": "OfSquares",
    "description": "OfSquares",
    "peekOfCode": "def sumOfSquares(n):\n    return sum([x ** 2 for x in range(1, n + 1)])",
    "detail": "OfSquares",
    "documentation": {}
  },
  {
    "label": "sumOfTheAngles",
    "kind": 5,
    "importPath": "OfTheAngles",
    "description": "OfTheAngles",
    "peekOfCode": "sumOfTheAngles = lambda n: (n - 2) * 180\n# n = eval(dir()[0])\n# return (n - 2) * 180",
    "detail": "OfTheAngles",
    "documentation": {}
  },
  {
    "label": "sumOfTwo",
    "kind": 2,
    "importPath": "OfTwo",
    "description": "OfTwo",
    "peekOfCode": "def sumOfTwo(a, b, v):\n    b = set(b)\n    return any(v - i in b for i in a)",
    "detail": "OfTwo",
    "documentation": {}
  },
  {
    "label": "visitsOnCircularRoad",
    "kind": 2,
    "importPath": "OnCircularRoad",
    "description": "OnCircularRoad",
    "peekOfCode": "def visitsOnCircularRoad(n, v):\n    c = 1\n    t = 0\n    for i in v:\n        t += min(abs(i - c), abs(n - abs(i - c)))\n        c = i\n    return t\n# v = visitsOrder\n# n = number of houses\n# c = Current position",
    "detail": "OnCircularRoad",
    "documentation": {}
  },
  {
    "label": "buildPalindrome",
    "kind": 2,
    "importPath": "Palindrome (2)",
    "description": "Palindrome (2)",
    "peekOfCode": "def buildPalindrome(st):\n    for i in range(len(st)):\n        sub = st[i : len(st)]\n        if sub[::-1] == sub:\n            missing = st[0:i]\n            return st + missing[::-1]\n    return st",
    "detail": "Palindrome (2)",
    "documentation": {}
  },
  {
    "label": "checkPalindrome",
    "kind": 5,
    "importPath": "Palindrome (3)",
    "description": "Palindrome (3)",
    "peekOfCode": "checkPalindrome = lambda x: x == x[::-1]",
    "detail": "Palindrome (3)",
    "documentation": {}
  },
  {
    "label": "check_palindrome",
    "kind": 2,
    "importPath": "palindrome",
    "description": "palindrome",
    "peekOfCode": "def check_palindrome(input_string: str = '') -> bool:\n    if 1 <= len(input_string) <= 100000:\n        return input_string == input_string[::-1]\n    return False",
    "detail": "palindrome",
    "documentation": {}
  },
  {
    "label": "palindromeRearranging",
    "kind": 2,
    "importPath": "palindrome_rearranging",
    "description": "palindrome_rearranging",
    "peekOfCode": "def palindromeRearranging(inputString):\n    character_count, odd_frequencies = {}, 0\n    # Count character frequencies\n    for i in range(len(inputString)):\n        if inputString[i] not in character_count:\n            character_count[(inputString[i])] = 1\n        elif inputString[i] in character_count:\n            character_count[(inputString[i])] += 1\n    # Count odd character frequencies\n    for char in character_count:",
    "detail": "palindrome_rearranging",
    "documentation": {}
  },
  {
    "label": "greetPerson",
    "kind": 5,
    "importPath": "Person",
    "description": "Person",
    "peekOfCode": "greetPerson = \"Hello, {}\".format",
    "detail": "Person",
    "documentation": {}
  },
  {
    "label": "phoneCall",
    "kind": 2,
    "importPath": "phone_call",
    "description": "phone_call",
    "peekOfCode": "def phoneCall(min1, min2_10, min11, s):\n    \"\"\"\n    You have s cents on your account before the call. \n    What is the duration of the longest call (in minutes \n    rounded down to the nearest integer) you can have?\n    Time Complexity: O(1)\n    Space Complexity: O(1)\n    \"\"\"\n    # Check if there is enough cents to make\n    # a 1 minutes call",
    "detail": "phone_call",
    "documentation": {}
  },
  {
    "label": "growingPlant",
    "kind": 2,
    "importPath": "Plant",
    "description": "Plant",
    "peekOfCode": "def growingPlant(upSpeed, downSpeed, desiredHeight):\n    day_count = 0\n    height = 0\n    while height <= desiredHeight:\n        height = height + upSpeed\n        day_count += 1\n        if height < desiredHeight:\n            height = height - downSpeed\n        else:\n            return day_count",
    "detail": "Plant",
    "documentation": {}
  },
  {
    "label": "twoPointerSum",
    "kind": 2,
    "importPath": "PointerSolution",
    "description": "PointerSolution",
    "peekOfCode": "def twoPointerSum(nums, target):\n    \"\"\"\n    Given a sorted array of integers, return indices of the two numbers such that they add up to a specific target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    \"\"\"\n    l = 0\n    r = len(nums) - 1\n    while l < r:\n        if nums[l] + nums[r] == target:\n            return [l, r]",
    "detail": "PointerSolution",
    "documentation": {}
  },
  {
    "label": "nums",
    "kind": 5,
    "importPath": "PointerSolution",
    "description": "PointerSolution",
    "peekOfCode": "nums = [5, 25, 75]\ntarget = 100\nprint(twoPointerSum(nums, target))",
    "detail": "PointerSolution",
    "documentation": {}
  },
  {
    "label": "target",
    "kind": 5,
    "importPath": "PointerSolution",
    "description": "PointerSolution",
    "peekOfCode": "target = 100\nprint(twoPointerSum(nums, target))",
    "detail": "PointerSolution",
    "documentation": {}
  },
  {
    "label": "gasPrediction",
    "kind": 5,
    "importPath": "Prediction",
    "description": "Prediction",
    "peekOfCode": "gasPrediction = lambda d, c, a: sum(d) / 12 / a > c",
    "detail": "Prediction",
    "documentation": {}
  },
  {
    "label": "digitsProduct",
    "kind": 2,
    "importPath": "Product",
    "description": "Product",
    "peekOfCode": "def digitsProduct(product):\n    if product == 0:\n        return 10\n    if product == 1:\n        return 1\n    for i in range(0, 4000):\n        p = 1\n        for j in str(i):\n            p *= int(j)\n        if p == product:",
    "detail": "Product",
    "documentation": {}
  },
  {
    "label": "depositProfit",
    "kind": 2,
    "importPath": "Profit (2)",
    "description": "Profit (2)",
    "peekOfCode": "def depositProfit(deposit, rate, threshold):\n    i = 0\n    while deposit < threshold:\n        deposit += deposit * rate * 0.01\n        i += 1\n    return i",
    "detail": "Profit (2)",
    "documentation": {}
  },
  {
    "label": "depositProfit",
    "kind": 2,
    "importPath": "Profit",
    "description": "Profit",
    "peekOfCode": "def depositProfit(deposit, rate, threshold):\n    year_count = 0\n    while deposit < threshold:\n        deposit = deposit + (deposit * (rate / 100))\n        year_count += 1\n    return year_count",
    "detail": "Profit",
    "documentation": {}
  },
  {
    "label": "reachNextLevel",
    "kind": 2,
    "importPath": "reach_next_level",
    "description": "reach_next_level",
    "peekOfCode": "def reachNextLevel(experience, threshold, reward):\n    \"\"\"\n    You are playing an RPG game. Currently your \n    experience points (XP) total is equal to experience. \n    To reach the next level your XP should be at least at \n    threshold. If you kill the monster in front of you, \n    you will gain more experience points in the amount \n    of the reward.\n    Given values experience, threshold and reward, check \n    if you reach the next level after killing the monster.",
    "detail": "reach_next_level",
    "documentation": {}
  },
  {
    "label": "stringsRearrangement",
    "kind": 2,
    "importPath": "Rearrangement",
    "description": "Rearrangement",
    "peekOfCode": "def stringsRearrangement(inputArray):\n    p_list = list(p(inputArray))\n    for i in range(len(p_list)):\n        count1 = 0\n        for j in range(len(p_list[0]) - 1):\n            count2 = 0\n            for k in range(len(p_list[0][0])):\n                if p_list[i][j][k] != p_list[i][j + 1][k]:\n                    count2 += 1\n            if count2 == 1:",
    "detail": "Rearrangement",
    "documentation": {}
  },
  {
    "label": "palindromeRearranging",
    "kind": 2,
    "importPath": "Rearranging",
    "description": "Rearranging",
    "peekOfCode": "def palindromeRearranging(inputString):\n    odd_count = 0\n    char_set = set(inputString)\n    for i in char_set:\n        char_count = inputString.count(i)\n        if char_count % 2 != 0:\n            odd_count += 1\n    if odd_count <= 1:\n        return True\n    return False",
    "detail": "Rearranging",
    "documentation": {}
  },
  {
    "label": "f,",
    "kind": 5,
    "importPath": "Reducing",
    "description": "Reducing",
    "peekOfCode": "f, = eval(dir()[0])\nreturn [i / math.gcd(f[0], f[1]) for i in f]",
    "detail": "Reducing",
    "documentation": {}
  },
  {
    "label": "arrayReplace",
    "kind": 2,
    "importPath": "Replace",
    "description": "Replace",
    "peekOfCode": "def arrayReplace(inputArray, elemToReplace, substitutionElem):\n    new = []\n    for i in range(len(inputArray)):\n        if inputArray[i] == elemToReplace:\n            new.append(substitutionElem)\n        else:\n            new.append(inputArray[i])\n    return new",
    "detail": "Replace",
    "documentation": {}
  },
  {
    "label": "reverseInParentheses",
    "kind": 2,
    "importPath": "reverse_in_parentheses",
    "description": "reverse_in_parentheses",
    "peekOfCode": "def reverseInParentheses(inputString):\n    opening_brackets_indices = []\n    # Iterate through string\n    for i in range(len(inputString)):\n        # Push opening brackets onto the stack\n        if inputString[i] == \"(\":\n            opening_brackets_indices.append(i)\n        # Reverse the substring starting after the\n        # last encountered opening bracket till\n        # the current character",
    "detail": "reverse_in_parentheses",
    "documentation": {}
  },
  {
    "label": "rotateImage",
    "kind": 2,
    "importPath": "rotate_image_ninety_degrees_clockwise",
    "description": "rotate_image_ninety_degrees_clockwise",
    "peekOfCode": "def rotateImage(a):\n    N = len(a)\n    for i in range(N // 2):\n        for j in range(i, N - 1 - i):\n            temp = a[i][j]\n            a[i][j] = a[N - 1 - j][i]\n            a[N - 1 - j][i] = a[N - 1 - i][N - 1 - j]\n            a[N - 1 - i][N - 1 - j] = a[j][N - 1 - i]\n            a[j][N - 1 - i] = temp\n    return a",
    "detail": "rotate_image_ninety_degrees_clockwise",
    "documentation": {}
  },
  {
    "label": "runningWater",
    "kind": 2,
    "importPath": "runningWater",
    "description": "runningWater",
    "peekOfCode": "def runningWater(cap, volume):\n    max_buckets = cap[::]\n    full_volume = sum(max_buckets)\n    seen_volume = set()\n    seen = set()\n    stack = emptyBuckets(cap, 0, volume)\n    for item in stack:\n        seen_volume.add(full_volume - item[0])\n        seen.add(tuple(item[1]))\n    # need this edge case here to pass all tests!",
    "detail": "runningWater",
    "documentation": {}
  },
  {
    "label": "emptyBuckets",
    "kind": 2,
    "importPath": "runningWater",
    "description": "runningWater",
    "peekOfCode": "def emptyBuckets(buckets, curr_poured, min_volume):\n    output = []\n    for i in range(3):\n        output.append([buckets[i] + curr_poured, []])\n        # print(output)\n        for j in range(3):\n            if j == i:\n                output[i][1].append(0)\n            else:\n                output[i][1].append(buckets[j])",
    "detail": "runningWater",
    "documentation": {}
  },
  {
    "label": "pourBuckets",
    "kind": 2,
    "importPath": "runningWater",
    "description": "runningWater",
    "peekOfCode": "def pourBuckets(buckets, max_buckets, seen):\n    output = []\n    # print(buckets)\n    for i in range(3):\n        for j in range(3):\n            if i == j:\n                continue\n            curr = copy.deepcopy(buckets)\n            # pour buckets into other buckets\n            if curr[1][j] == max_buckets[j]:",
    "detail": "runningWater",
    "documentation": {}
  },
  {
    "label": "seatsInTheater",
    "kind": 2,
    "importPath": "seats_in_theatre",
    "description": "seats_in_theatre",
    "peekOfCode": "def seatsInTheater(nCols, nRows, col, row):\n    \"\"\"\n    Given the total number of rows and columns \n    in the theater (nRows and nCols, respectively), \n    and the row and column you're sitting in, return \n    the number of people who sit strictly behind \n    you and in your column or to the left, assuming \n    all seats are occupied.\n    \"\"\"\n    return (nRows - row) * (nCols - col + 1)",
    "detail": "seats_in_theatre",
    "documentation": {}
  },
  {
    "label": "shape_area",
    "kind": 2,
    "importPath": "shape_area",
    "description": "shape_area",
    "peekOfCode": "def shape_area(n: int = None) -> int:\n    if n is not None and isinstance(n, int) and 1 <= n <= 10000:\n        return (n - 1) ** 2 + n ** 2\n    return 0",
    "detail": "shape_area",
    "documentation": {}
  },
  {
    "label": "alphabeticShift",
    "kind": 2,
    "importPath": "Shift",
    "description": "Shift",
    "peekOfCode": "def alphabeticShift(inputString):\n    return \"\".join(chr(ord(i) + 1) if i != \"z\" else \"a\" for i in inputString)",
    "detail": "Shift",
    "documentation": {}
  },
  {
    "label": "areSimilar",
    "kind": 2,
    "importPath": "Similar",
    "description": "Similar",
    "peekOfCode": "def areSimilar(a, b):\n    check_a = []\n    check_b = []\n    count = 0\n    for i in range(len(a)):\n        if a[i] != b[i]:\n            count += 1\n            check_a.append(a[i])\n            check_b.append(b[i])\n    if count == 0:",
    "detail": "Similar",
    "documentation": {}
  },
  {
    "label": "drawRectangle",
    "kind": 2,
    "importPath": "solution (10)",
    "description": "solution (10)",
    "peekOfCode": "def drawRectangle(canvas, r):\n    x, y, x1, y1 = r\n    canvas[x][y], canvas[x][y1 + y], canvas[x1][y], canvas[x1][y + y1] = [\"*\"] * 4\n    for j in range(y + 1, y + y1):\n        canvas[x][j] = \"|\"\n        canvas[x1][j] = \"|\"\n    return canvas\ncanvas = [\n    [\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"],\n    [\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"],",
    "detail": "solution (10)",
    "documentation": {}
  },
  {
    "label": "canvas",
    "kind": 5,
    "importPath": "solution (10)",
    "description": "solution (10)",
    "peekOfCode": "canvas = [\n    [\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"],\n    [\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"],\n    [\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"],\n    [\"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\"],\n    [\"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\"],\n]\nrectangle = [1, 1, 4, 3]\nprint(drawRectangle(canvas, rectangle))",
    "detail": "solution (10)",
    "documentation": {}
  },
  {
    "label": "rectangle",
    "kind": 5,
    "importPath": "solution (10)",
    "description": "solution (10)",
    "peekOfCode": "rectangle = [1, 1, 4, 3]\nprint(drawRectangle(canvas, rectangle))",
    "detail": "solution (10)",
    "documentation": {}
  },
  {
    "label": "countPalindromes",
    "kind": 2,
    "importPath": "solution (11)",
    "description": "solution (11)",
    "peekOfCode": "def countPalindromes(s):\n    \"\"\"\n    countPalindromes(s) takes in a string s and returns the number of palindrome in the string\n    :param s: a string\n    :return: number of palindrome sub strings\n    \"\"\"\n    tot_pal = len(s)\n    for i in range(len(s)):\n        tot_pal += helper(s, i, i + 1)\n        tot_pal += helper(s, i - 1, i + 1)",
    "detail": "solution (11)",
    "documentation": {}
  },
  {
    "label": "helper",
    "kind": 2,
    "importPath": "solution (11)",
    "description": "solution (11)",
    "peekOfCode": "def helper(s, l, r):\n    tot = 0\n    while (l >= 0) and (r < len(s)) and (s[l] == s[r]):\n        tot += 1\n        l -= 1\n        r += 1\n    return tot\nprint(countPalindromes(\"aaa\"))",
    "detail": "solution (11)",
    "documentation": {}
  },
  {
    "label": "reverseInParentheses",
    "kind": 2,
    "importPath": "solution (12)",
    "description": "solution (12)",
    "peekOfCode": "def reverseInParentheses(s):\n    \"\"\"\n    takes in a string that has substrings inside Parentheses, return a string with all substrings inside the Parentheses\n    reversed\n    \"\"\"\n    stack = []\n    for i in s:\n        if i == \")\":\n            ind = len(stack) - 1\n            while stack[ind] != \"(\":",
    "detail": "solution (12)",
    "documentation": {}
  },
  {
    "label": "boxBlur",
    "kind": 2,
    "importPath": "solution (13)",
    "description": "solution (13)",
    "peekOfCode": "def boxBlur(image):\n    out = []\n    for i in range(len(image) - 2):\n        out.append(\n            [\n                (\n                    sum(image[i][j : j + 3])\n                    + sum(image[i + 1][j : j + 3])\n                    + sum(image[i + 2][j : j + 3])\n                )",
    "detail": "solution (13)",
    "documentation": {}
  },
  {
    "label": "image",
    "kind": 5,
    "importPath": "solution (13)",
    "description": "solution (13)",
    "peekOfCode": "image = [[7, 4, 0, 1], [5, 6, 2, 2], [6, 10, 7, 8], [1, 4, 2, 0]]\nprint(boxBlur(image))",
    "detail": "solution (13)",
    "documentation": {}
  },
  {
    "label": "twoSum",
    "kind": 2,
    "importPath": "solution (14)",
    "description": "solution (14)",
    "peekOfCode": "def twoSum(nums, target):\n    \"\"\"\n    Given an array of integers, return indices of the two numbers such that they add up to a specific target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    \"\"\"\n    h = {}\n    for i, v in enumerate(nums):\n        if v in h:\n            return [h[v], i]\n        else:",
    "detail": "solution (14)",
    "documentation": {}
  },
  {
    "label": "nums",
    "kind": 5,
    "importPath": "solution (14)",
    "description": "solution (14)",
    "peekOfCode": "nums = [2, 7, 11, 15]\ntarget = 9\nprint(twoSum(nums, target))",
    "detail": "solution (14)",
    "documentation": {}
  },
  {
    "label": "target",
    "kind": 5,
    "importPath": "solution (14)",
    "description": "solution (14)",
    "peekOfCode": "target = 9\nprint(twoSum(nums, target))",
    "detail": "solution (14)",
    "documentation": {}
  },
  {
    "label": "shortestSubstring",
    "kind": 2,
    "importPath": "solution (15)",
    "description": "solution (15)",
    "peekOfCode": "def shortestSubstring(s):\n    diff_chars, start, big = len(set(s)), 0, len(s)\n    end = diff_chars\n    while end <= len(s):\n        curr = len(set(s[start:end]))\n        if curr == diff_chars:\n            if end - start < big:\n                big = end - start\n            start += 1\n        else:",
    "detail": "solution (15)",
    "documentation": {}
  },
  {
    "label": "minX",
    "kind": 2,
    "importPath": "solution (16)",
    "description": "solution (16)",
    "peekOfCode": "def minX(arr):\n    \"\"\"\n    given an arr, get the min number that can keep the running sum greater than or equal to 1\n    \"\"\"\n    m = min(arr)\n    if m > 0:\n        return (m * -1) + 1\n    else:\n        m = (m * -1) + 1\n    running_sum = m",
    "detail": "solution (16)",
    "documentation": {}
  },
  {
    "label": "arr",
    "kind": 5,
    "importPath": "solution (16)",
    "description": "solution (16)",
    "peekOfCode": "arr = [-5, -2, -4]\nprint(minX(arr))",
    "detail": "solution (16)",
    "documentation": {}
  },
  {
    "label": "minimumOnStack",
    "kind": 2,
    "importPath": "solution (17)",
    "description": "solution (17)",
    "peekOfCode": "def minimumOnStack(operations):\n    l = []\n    out = []\n    for i in operations:\n        if \"push\" in i:\n            l.append(int(i[i.index(\" \") + 1 :]))\n        elif \"pop\" in i:\n            l.pop()\n        else:\n            out.append(min(l))",
    "detail": "solution (17)",
    "documentation": {}
  },
  {
    "label": "operations",
    "kind": 5,
    "importPath": "solution (17)",
    "description": "solution (17)",
    "peekOfCode": "operations = [\n    \"push 10\",\n    \"min\",\n    \"push 5\",\n    \"min\",\n    \"push 8\",\n    \"min\",\n    \"pop\",\n    \"min\",\n    \"pop\",",
    "detail": "solution (17)",
    "documentation": {}
  },
  {
    "label": "areFollowingPatterns",
    "kind": 2,
    "importPath": "solution (18)",
    "description": "solution (18)",
    "peekOfCode": "def areFollowingPatterns(strings, patterns):\n    d = {}\n    for ele in range(len(strings)):\n        if d.get(strings[ele]):\n            if d[strings[ele]] != patterns[ele]:\n                return False\n        elif patterns[ele] in d.values():\n            return False\n        else:\n            d[strings[ele]] = patterns[ele]",
    "detail": "solution (18)",
    "documentation": {}
  },
  {
    "label": "strings",
    "kind": 5,
    "importPath": "solution (18)",
    "description": "solution (18)",
    "peekOfCode": "strings = [\"cat\", \"dog\", \"doggy\"]\npatterns = [\"a\", \"b\", \"b\"]\nprint(areFollowingPatterns(strings, patterns))",
    "detail": "solution (18)",
    "documentation": {}
  },
  {
    "label": "patterns",
    "kind": 5,
    "importPath": "solution (18)",
    "description": "solution (18)",
    "peekOfCode": "patterns = [\"a\", \"b\", \"b\"]\nprint(areFollowingPatterns(strings, patterns))",
    "detail": "solution (18)",
    "documentation": {}
  },
  {
    "label": "letter_combinations",
    "kind": 2,
    "importPath": "solution (19)",
    "description": "solution (19)",
    "peekOfCode": "def letter_combinations(digits):\n    m = {\n        \"2\": \"abc\",\n        \"3\": \"def\",\n        \"4\": \"ghi\",\n        \"5\": \"jkl\",\n        \"6\": \"mno\",\n        \"7\": \"pqrs\",\n        \"8\": \"tuv\",\n        \"9\": \"wxyz\",",
    "detail": "solution (19)",
    "documentation": {}
  },
  {
    "label": "sudoku2",
    "kind": 2,
    "importPath": "solution (2)",
    "description": "solution (2)",
    "peekOfCode": "def sudoku2(grid):\n    \"\"\"\n    check if sudoku board is true by checking that the same number didn't appear more than one in its row, col,\n    surrounding 3*3 sub matrix\n    \"\"\"\n    for i in range(9):\n        for j in range(9):\n            if i % 3 == 0 and j % 3 == 0:\n                l = [\n                    grid[s_i][s_j]",
    "detail": "solution (2)",
    "documentation": {}
  },
  {
    "label": "grid",
    "kind": 5,
    "importPath": "solution (2)",
    "description": "solution (2)",
    "peekOfCode": "grid = [\n    [\".\", \".\", \"5\", \".\", \".\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \"8\", \".\", \".\", \".\", \"3\", \".\"],\n    [\".\", \"5\", \".\", \".\", \"2\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \"9\"],\n    [\".\", \".\", \".\", \".\", \".\", \".\", \"4\", \".\", \".\"],\n    [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \"7\"],\n    [\".\", \"1\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n    [\"2\", \"4\", \".\", \".\", \".\", \".\", \"9\", \".\", \".\"],",
    "detail": "solution (2)",
    "documentation": {}
  },
  {
    "label": "almostIncreasingSequence",
    "kind": 2,
    "importPath": "solution (20)",
    "description": "solution (20)",
    "peekOfCode": "def almostIncreasingSequence(sequence):\n    for ind in range(len(sequence) - 1):\n        if sequence[ind] < sequence[ind + 1]:\n            continue\n        else:\n            if sequence.count(sequence[ind + 1]) > 1:\n                sequence.pop(ind + 1)\n            else:\n                sequence.pop(ind + 1)\n        return sequence == sorted(list(set(sequence)))",
    "detail": "solution (20)",
    "documentation": {}
  },
  {
    "label": "sensorsDifferenceSum",
    "kind": 2,
    "importPath": "solution (21)",
    "description": "solution (21)",
    "peekOfCode": "def sensorsDifferenceSum(sensor_1, sensor_2):\n    \"\"\"\n    given two lists contains the reading of two sensors for the same place, give the total difference between\n    there elements\n    \"\"\"\n    if len(sensor_1) == 0 or len(sensor_2) == 0:\n        return 0\n    return abs(sensor_1[0] - sensor_2[0]) + sensorsDifferenceSum(\n        sensor_1[1:], sensor_2[1:]\n    )",
    "detail": "solution (21)",
    "documentation": {}
  },
  {
    "label": "matrix_elements_sum",
    "kind": 2,
    "importPath": "solution (22)",
    "description": "solution (22)",
    "peekOfCode": "def matrix_elements_sum(matrix):\n    hunted = []\n    total = 0\n    ran = len(matrix[0])\n    for row in matrix:\n        for no in range(ran):\n            if no in hunted:\n                continue\n            elif row[no] == 0:\n                hunted.append(no)",
    "detail": "solution (22)",
    "documentation": {}
  },
  {
    "label": "swapDiagonals",
    "kind": 2,
    "importPath": "solution (24)",
    "description": "solution (24)",
    "peekOfCode": "def swapDiagonals(matrix):\n    j = len(matrix) - 1\n    for i in range(len(matrix) // 2):\n        matrix[i][i], matrix[i][j - i] = matrix[i][j - i], matrix[i][i]\n        matrix[j - i][j - i], matrix[j - i][i] = matrix[j - i][i], matrix[j - i][j - i]\n    return matrix\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(swapDiagonals(matrix))",
    "detail": "solution (24)",
    "documentation": {}
  },
  {
    "label": "matrix",
    "kind": 5,
    "importPath": "solution (24)",
    "description": "solution (24)",
    "peekOfCode": "matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(swapDiagonals(matrix))",
    "detail": "solution (24)",
    "documentation": {}
  },
  {
    "label": "binarySearch",
    "kind": 2,
    "importPath": "solution (25)",
    "description": "solution (25)",
    "peekOfCode": "def binarySearch(arr, searchValue):\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] < searchValue:\n            low = mid + 1\n        elif arr[mid] > searchValue:\n            high = mid - 1\n        else:",
    "detail": "solution (25)",
    "documentation": {}
  },
  {
    "label": "binarySearchRec",
    "kind": 2,
    "importPath": "solution (25)",
    "description": "solution (25)",
    "peekOfCode": "def binarySearchRec(arr, search_value):\n    if len(arr) == 0:\n        return False",
    "detail": "solution (25)",
    "documentation": {}
  },
  {
    "label": "check",
    "kind": 2,
    "importPath": "solution (26)",
    "description": "solution (26)",
    "peekOfCode": "def check(first, second, target):\n    while first < target:\n        first += second\n    return first\ndef isPossible(a, b, c, d):\n    # Write your code here\n    if c < d:\n        a = check(a, b, c)\n        b = check(b, a, d)\n    else:",
    "detail": "solution (26)",
    "documentation": {}
  },
  {
    "label": "isPossible",
    "kind": 2,
    "importPath": "solution (26)",
    "description": "solution (26)",
    "peekOfCode": "def isPossible(a, b, c, d):\n    # Write your code here\n    if c < d:\n        a = check(a, b, c)\n        b = check(b, a, d)\n    else:\n        b = check(b, a, d)\n        a = check(a, b, c)\n    if a != c or b != d:\n        return \"No\"",
    "detail": "solution (26)",
    "documentation": {}
  },
  {
    "label": "isLucky",
    "kind": 2,
    "importPath": "solution (27)",
    "description": "solution (27)",
    "peekOfCode": "def isLucky(n):\n    \"\"\"\n    isLucky takes in an integer and return True if the sum of its right half == sum of the\n     right half\n    :param n:\n    :return:\n    \"\"\"\n    # l = list(map(int, str(n)))\n    # return sum(l[0:len(l) // 2]) == sum(l[len(l) // 2:])\n    s = str(n)",
    "detail": "solution (27)",
    "documentation": {}
  },
  {
    "label": "n",
    "kind": 5,
    "importPath": "solution (27)",
    "description": "solution (27)",
    "peekOfCode": "n = 1230\nprint(isLucky(n))",
    "detail": "solution (27)",
    "documentation": {}
  },
  {
    "label": "subarraySum",
    "kind": 2,
    "importPath": "solution (28)",
    "description": "solution (28)",
    "peekOfCode": "def subarraySum(nums, k):\n    \"\"\"\n    Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.\n    \"\"\"\n    count = 0\n    s = 0\n    for i in range(len(nums)):\n        s += nums[i]\n        if s % k == 0:\n            count += 1",
    "detail": "solution (28)",
    "documentation": {}
  },
  {
    "label": "nums",
    "kind": 5,
    "importPath": "solution (28)",
    "description": "solution (28)",
    "peekOfCode": "nums = [1, 2, 3]\nk = 3\nprint(subarraySum(nums, k))",
    "detail": "solution (28)",
    "documentation": {}
  },
  {
    "label": "k",
    "kind": 5,
    "importPath": "solution (28)",
    "description": "solution (28)",
    "peekOfCode": "k = 3\nprint(subarraySum(nums, k))",
    "detail": "solution (28)",
    "documentation": {}
  },
  {
    "label": "beautifulText",
    "kind": 2,
    "importPath": "solution (29)",
    "description": "solution (29)",
    "peekOfCode": "def beautifulText(inputString, l, r):\n    for w in range(l, r + 1):\n        i = w\n        while i < len(inputString):\n            if inputString[i] != \" \":\n                break\n            i += w + 1\n        if i == len(inputString):\n            return True\n    return False",
    "detail": "solution (29)",
    "documentation": {}
  },
  {
    "label": "s",
    "kind": 5,
    "importPath": "solution (29)",
    "description": "solution (29)",
    "peekOfCode": "s = \"Look at this example of a correct text\"\nprint(beautifulText(s, 5, 15))",
    "detail": "solution (29)",
    "documentation": {}
  },
  {
    "label": "onesGroups",
    "kind": 2,
    "importPath": "solution (3)",
    "description": "solution (3)",
    "peekOfCode": "def onesGroups(grid, quires):\n    # global tot\n    ans = defaultdict(int)\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                # tot = 0\n                tot = dfs(grid, i, j, 0)\n                ans[tot] += 1\n    for i in range(len(quires)):",
    "detail": "solution (3)",
    "documentation": {}
  },
  {
    "label": "dfs",
    "kind": 2,
    "importPath": "solution (3)",
    "description": "solution (3)",
    "peekOfCode": "def dfs(grid, i, j, tot):\n    # using global tot, to not be considered in the recursive stack\n    # global tot\n    if (\n        (i < 0)\n        or (j < 0)\n        or (j >= len(grid[0]))\n        or (i >= len(grid))\n        or (grid[i][j] == 0)\n    ):",
    "detail": "solution (3)",
    "documentation": {}
  },
  {
    "label": "grid",
    "kind": 5,
    "importPath": "solution (3)",
    "description": "solution (3)",
    "peekOfCode": "grid = [[1, 1, 1, 0, 0], [1, 1, 1, 0, 1], [0, 0, 0, 1, 0]]\nquires = [1, 2, 6]\nprint(onesGroups(grid, quires))",
    "detail": "solution (3)",
    "documentation": {}
  },
  {
    "label": "quires",
    "kind": 5,
    "importPath": "solution (3)",
    "description": "solution (3)",
    "peekOfCode": "quires = [1, 2, 6]\nprint(onesGroups(grid, quires))",
    "detail": "solution (3)",
    "documentation": {}
  },
  {
    "label": "s",
    "kind": 5,
    "importPath": "solution (31)",
    "description": "solution (31)",
    "peekOfCode": "s = set()\ns.add(123)\ns.add(123)\nprint(s)",
    "detail": "solution (31)",
    "documentation": {}
  },
  {
    "label": "fileNaming",
    "kind": 2,
    "importPath": "solution (32)",
    "description": "solution (32)",
    "peekOfCode": "def fileNaming(names):\n    for i in range(1, len(names)):\n        temp = names[i]\n        counter = 1\n        while temp in names[0:i]:\n            temp = f\"{names[i]}({counter})\"\n            counter += 1\n        names[i] = temp\n    return names\nprint(fileNaming([\"doc\", \"doc\", \"image\", \"doc(1)\", \"doc\"]))",
    "detail": "solution (32)",
    "documentation": {}
  },
  {
    "label": "regularMonths",
    "kind": 2,
    "importPath": "solution (33)",
    "description": "solution (33)",
    "peekOfCode": "def regularMonths(c):\n    m, y = map(int, c.split(\"-\"))\n    while y:\n        for m in range(m + 1, 12 + 1):\n            if w(y, m, 1) == 0:\n                return f\"{str(m).zfill(2)}-{y}\"\n        m, y = 0, y + 1\nprint(regularMonths(\"07-2024\"))",
    "detail": "solution (33)",
    "documentation": {}
  },
  {
    "label": "extractMatrixColumn",
    "kind": 2,
    "importPath": "solution (34)",
    "description": "solution (34)",
    "peekOfCode": "def extractMatrixColumn(matrix, col):\n    return [matrix[i][col] for i in range(len(matrix))]\nmatrix = [[1, 1, 1, 2], [0, 5, 0, 4], [2, 1, 3, 6]]\nprint(extractMatrixColumn(matrix, 2))",
    "detail": "solution (34)",
    "documentation": {}
  },
  {
    "label": "matrix",
    "kind": 5,
    "importPath": "solution (34)",
    "description": "solution (34)",
    "peekOfCode": "matrix = [[1, 1, 1, 2], [0, 5, 0, 4], [2, 1, 3, 6]]\nprint(extractMatrixColumn(matrix, 2))",
    "detail": "solution (34)",
    "documentation": {}
  },
  {
    "label": "rotateImage",
    "kind": 2,
    "importPath": "solution (35)",
    "description": "solution (35)",
    "peekOfCode": "def rotateImage(a):\n    if a == None:\n        return None\n    a.reverse()\n    for i in range(len(a)):\n        for j in range(i):\n            a[i][j], a[j][i] = a[j][i], a[i][j]\n    return a\nmat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(rotateImage(mat))",
    "detail": "solution (35)",
    "documentation": {}
  },
  {
    "label": "mat",
    "kind": 5,
    "importPath": "solution (35)",
    "description": "solution (35)",
    "peekOfCode": "mat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(rotateImage(mat))",
    "detail": "solution (35)",
    "documentation": {}
  },
  {
    "label": "amendTheSentence",
    "kind": 2,
    "importPath": "solution (36)",
    "description": "solution (36)",
    "peekOfCode": "def amendTheSentence(s):\n    out_s = s[0].lower()\n    for char in s[1:]:\n        if char.islower():\n            out_s += char\n        else:\n            out_s += \" \" + char.lower()\n    return out_s\ns = \"AHMm\"\nprint(amendTheSentence(s))",
    "detail": "solution (36)",
    "documentation": {}
  },
  {
    "label": "s",
    "kind": 5,
    "importPath": "solution (36)",
    "description": "solution (36)",
    "peekOfCode": "s = \"AHMm\"\nprint(amendTheSentence(s))",
    "detail": "solution (36)",
    "documentation": {}
  },
  {
    "label": "isSentenceCorrect",
    "kind": 2,
    "importPath": "solution (37)",
    "description": "solution (37)",
    "peekOfCode": "def isSentenceCorrect(sentence):\n    pattern = \"^[A-Z][^?!.]*[?.!]$\"\n    return re.match(pattern, sentence) is not None\nprint(isSentenceCorrect(\"This is an example of *correct* sentence!\"))",
    "detail": "solution (37)",
    "documentation": {}
  },
  {
    "label": "nthNumber",
    "kind": 2,
    "importPath": "solution (38)",
    "description": "solution (38)",
    "peekOfCode": "def nthNumber(s, n):\n    pattern = rf\"([0-9]+){n}\"\n    return re.match(pattern, s).group(1)\ns = \"8one 003number 201numbers li-000233le number4443\"\nn = 4\nprint(nthNumber(s, n))",
    "detail": "solution (38)",
    "documentation": {}
  },
  {
    "label": "s",
    "kind": 5,
    "importPath": "solution (38)",
    "description": "solution (38)",
    "peekOfCode": "s = \"8one 003number 201numbers li-000233le number4443\"\nn = 4\nprint(nthNumber(s, n))",
    "detail": "solution (38)",
    "documentation": {}
  },
  {
    "label": "n",
    "kind": 5,
    "importPath": "solution (38)",
    "description": "solution (38)",
    "peekOfCode": "n = 4\nprint(nthNumber(s, n))",
    "detail": "solution (38)",
    "documentation": {}
  },
  {
    "label": "rodCutting",
    "kind": 2,
    "importPath": "solution (39)",
    "description": "solution (39)",
    "peekOfCode": "def rodCutting(n, v):\n    a = v\n    for _ in a:\n        a = list(map(max, a, (a[0] + y for y in v)))\n        x = a.pop(0)\n    return x\nn = 4\nv = [0, 2, 4, 7, 7]\nprint(rodCutting(n, v))",
    "detail": "solution (39)",
    "documentation": {}
  },
  {
    "label": "n",
    "kind": 5,
    "importPath": "solution (39)",
    "description": "solution (39)",
    "peekOfCode": "n = 4\nv = [0, 2, 4, 7, 7]\nprint(rodCutting(n, v))",
    "detail": "solution (39)",
    "documentation": {}
  },
  {
    "label": "v",
    "kind": 5,
    "importPath": "solution (39)",
    "description": "solution (39)",
    "peekOfCode": "v = [0, 2, 4, 7, 7]\nprint(rodCutting(n, v))",
    "detail": "solution (39)",
    "documentation": {}
  },
  {
    "label": "findLower",
    "kind": 2,
    "importPath": "solution (4)",
    "description": "solution (4)",
    "peekOfCode": "def findLower(scores, len_score, v):\n    l = 0\n    u = len_score - 1\n    while l <= u:\n        mid = (l + u) // 2\n        if scores[mid] >= v:\n            u = mid - 1\n        else:\n            l = mid + 1\n    return l",
    "detail": "solution (4)",
    "documentation": {}
  },
  {
    "label": "findUpper",
    "kind": 2,
    "importPath": "solution (4)",
    "description": "solution (4)",
    "peekOfCode": "def findUpper(scores, len_score, v):\n    l = 0\n    u = len_score - 1\n    while l <= u:\n        mid = (l + u) // 2\n        if scores[mid] > v:\n            u = mid - 1\n        else:\n            l = mid + 1\n    return u",
    "detail": "solution (4)",
    "documentation": {}
  },
  {
    "label": "jobOffers",
    "kind": 2,
    "importPath": "solution (4)",
    "description": "solution (4)",
    "peekOfCode": "def jobOffers(scores, lowerLimits, upperLimits):\n    scores.sort()\n    n = len(scores)\n    for index in range(len(lowerLimits)):\n        yield findUpper(scores, n, upperLimits[index]) - findLower(\n            scores, n, lowerLimits[index]\n        ) + 1\nfor i in jobOffers([1, 2, 2, 3, 5, 6, 7], [1], [7]):\n    print(i)",
    "detail": "solution (4)",
    "documentation": {}
  },
  {
    "label": "powerOfTwo",
    "kind": 2,
    "importPath": "solution (40)",
    "description": "solution (40)",
    "peekOfCode": "def powerOfTwo(n):\n    if n < 1:\n        return []\n    l = [1]\n    i = 1\n    while i + i <= n:\n        i += i\n        l.append(i)\n    return l\nprint(powerOfTwo(10))",
    "detail": "solution (40)",
    "documentation": {}
  },
  {
    "label": "stringPermutations",
    "kind": 2,
    "importPath": "solution (41)",
    "description": "solution (41)",
    "peekOfCode": "def stringPermutations(s):\n    return sorted(list({\"\".join(itm) for itm in permutations(s)}))\nprint(stringPermutations(\"CDA\"))",
    "detail": "solution (41)",
    "documentation": {}
  },
  {
    "label": "rec_bin",
    "kind": 2,
    "importPath": "solution (43)",
    "description": "solution (43)",
    "peekOfCode": "def rec_bin(n):\n    if n == 0:\n        return \"\"\n    else:\n        return str(n % 2) + rec_bin(n // 2)\nprint(rec_bin(20))\nprint(bin(20)[2:])",
    "detail": "solution (43)",
    "documentation": {}
  },
  {
    "label": "swapAdjacentWords",
    "kind": 2,
    "importPath": "solution (44)",
    "description": "solution (44)",
    "peekOfCode": "def swapAdjacentWords(s):\n    return re.sub(r\"(\\w+) (\\w+)\", r\"\\2 \\1\", s)\ns = \"How are you guys?\"\nprint(swapAdjacentWords(s))",
    "detail": "solution (44)",
    "documentation": {}
  },
  {
    "label": "s",
    "kind": 5,
    "importPath": "solution (44)",
    "description": "solution (44)",
    "peekOfCode": "s = \"How are you guys?\"\nprint(swapAdjacentWords(s))",
    "detail": "solution (44)",
    "documentation": {}
  },
  {
    "label": "alternate",
    "kind": 2,
    "importPath": "solution (5)",
    "description": "solution (5)",
    "peekOfCode": "def alternate(s):\n    d = Counter(s)\n    i = 0\n    # validate that each letter is not duplicate next to itself\n    while i < len(s):\n        if s[i] in d:\n            if i + 1 < len(s) and s[i + 1] == s[i]:\n                del d[s[i]]\n        i += 1\n    occ = d.values()",
    "detail": "solution (5)",
    "documentation": {}
  },
  {
    "label": "fib",
    "kind": 2,
    "importPath": "solution (6)",
    "description": "solution (6)",
    "peekOfCode": "def fib(N):\n    \"\"\"\n    Avoid redoing the something over and over and store any Fib in a dictionary\n    to not do it again\n    Time: o(n)\n    \"\"\"\n    memo = {}\n    if N in memo:\n        return memo[N]\n    if N <= 2:",
    "detail": "solution (6)",
    "documentation": {}
  },
  {
    "label": "stepPerms",
    "kind": 2,
    "importPath": "solution (7)",
    "description": "solution (7)",
    "peekOfCode": "def stepPerms(n):\n    \"\"\"\n    given n number of stairs, determine the total number of ways to climb the\n    stairs if you can take 1, 2, or 3 steps at a time\n    \"\"\"\n    if n < 0:\n        return 0\n    if n == 0:\n        return 1\n    else:",
    "detail": "solution (7)",
    "documentation": {}
  },
  {
    "label": "stepPermsDP",
    "kind": 2,
    "importPath": "solution (7)",
    "description": "solution (7)",
    "peekOfCode": "def stepPermsDP(n):\n    \"\"\"\n    given n number of stairs, determine the total number of ways to climb the\n    stairs if you can take 1, 2, or 3 steps at a time\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    if n < 0:\n        return 0\n    if n == 0:",
    "detail": "solution (7)",
    "documentation": {}
  },
  {
    "label": "memo",
    "kind": 5,
    "importPath": "solution (7)",
    "description": "solution (7)",
    "peekOfCode": "memo = {}\ndef stepPermsDP(n):\n    \"\"\"\n    given n number of stairs, determine the total number of ways to climb the\n    stairs if you can take 1, 2, or 3 steps at a time\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    if n < 0:\n        return 0",
    "detail": "solution (7)",
    "documentation": {}
  },
  {
    "label": "getLargestString",
    "kind": 2,
    "importPath": "solution (8)",
    "description": "solution (8)",
    "peekOfCode": "def getLargestString(s, k):\n    d = Counter(s)\n    ord_s = sorted(d.keys(), reverse=True)\n    out = \"\"\n    l_p = 0\n    while l_p < len(ord_s):\n        if d[ord_s[l_p]] < k:\n            out += ord_s[l_p] * d[ord_s[l_p]]\n            l_p += 1\n            continue",
    "detail": "solution (8)",
    "documentation": {}
  },
  {
    "label": "s",
    "kind": 5,
    "importPath": "solution (8)",
    "description": "solution (8)",
    "peekOfCode": "s = \"xxzzxx\"\nprint(getLargestString(s, 4))",
    "detail": "solution (8)",
    "documentation": {}
  },
  {
    "label": "island",
    "kind": 2,
    "importPath": "solution (9)",
    "description": "solution (9)",
    "peekOfCode": "def island(matrix):\n    \"\"\"\n    given a two by two matrix, get the number of islands in it, an island is a series of 1's connected in a\n    row or a column\n    \"\"\"\n    if (not matrix) or len(matrix) == 0:\n        return 0\n    number_of_islands = 0\n    l = [True] * len(matrix[0])\n    for i in range(len(matrix)):",
    "detail": "solution (9)",
    "documentation": {}
  },
  {
    "label": "sortByHeight",
    "kind": 2,
    "importPath": "sort_by_height",
    "description": "sort_by_height",
    "peekOfCode": "def sortByHeight(a):\n    heights = []\n    # Store all the heights in a list\n    for i in range(len(a)):\n        if a[i] != -1:\n            heights.append(a[i])\n    # Sort the heights\n    heights = sorted(heights)\n    # Replace the heights in the original list\n    j = 0",
    "detail": "sort_by_height",
    "documentation": {}
  },
  {
    "label": "differentSquares",
    "kind": 2,
    "importPath": "Squares",
    "description": "Squares",
    "peekOfCode": "def differentSquares(matrix):\n    rows = len(matrix)\n    cols = len(matrix[0])\n    sq_arr = []\n    sq_count = 0\n    for i in range(rows - 1):\n        for j in range(cols - 1):\n            sq_2x2 = [\n                matrix[i][j],\n                matrix[i][j + 1],",
    "detail": "Squares",
    "documentation": {}
  },
  {
    "label": "differ_by_one_char",
    "kind": 2,
    "importPath": "strings_rearrangement",
    "description": "strings_rearrangement",
    "peekOfCode": "def differ_by_one_char(str1, str2):\n    \"\"\"Function to determine if the hamming distance between two strings is 1\n    Args:\n        str1(string): First string.\n        str2(string): Second string.\n    Returns:\n        Boolean indicating if hamming distance is equal to 1.\n    Raises:\n    \"\"\"\n    difference_count = 0",
    "detail": "strings_rearrangement",
    "documentation": {}
  },
  {
    "label": "stringsRearrangement",
    "kind": 2,
    "importPath": "strings_rearrangement",
    "description": "strings_rearrangement",
    "peekOfCode": "def stringsRearrangement(inputArray):\n    \"\"\"Function to check if possible to rearrange order of elements where hamming distance is 1\n    Args:\n        inputArray(string): List containing equal-length strings.\n    Returns:\n        Boolean indicating if it is possible or not.\n    Raises:\n    \"\"\"\n    all_permutation_tuples = permutations(inputArray)\n    for permutation in all_permutation_tuples:",
    "detail": "strings_rearrangement",
    "documentation": {}
  },
  {
    "label": "maxSubarray",
    "kind": 2,
    "importPath": "Subarray",
    "description": "Subarray",
    "peekOfCode": "def maxSubarray(A):\n    # A: inputArray\n    # m: Max\n    #\n    #\n    m = e = 0\n    for i in A:\n        e += i\n        if e < 0:\n            e = 0",
    "detail": "Subarray",
    "documentation": {}
  },
  {
    "label": "r",
    "kind": 5,
    "importPath": "Subrip",
    "description": "Subrip",
    "peekOfCode": "r = []\nc = 1\nt = [[int(s[i : i + 2]) for i in [1, 4]] + [s[7:9]] for s in l]\nt = [f\"{x // 60:02d}:{x % 60:02d}:{y:02d},{z.ljust(3, str(0))}\" for x, y, z in t] + [\n    s + \",000\"\n]  # if I replace str(0) with '0', this increases to 359 characters wtf\nfor a, b in enumerate(l):\n    r.extend([str(c), t[a] + \" --> \" + t[a + 1], b[11:], \"\"])\n    c += 1\nreturn r[:-1]",
    "detail": "Subrip",
    "documentation": {}
  },
  {
    "label": "c",
    "kind": 5,
    "importPath": "Subrip",
    "description": "Subrip",
    "peekOfCode": "c = 1\nt = [[int(s[i : i + 2]) for i in [1, 4]] + [s[7:9]] for s in l]\nt = [f\"{x // 60:02d}:{x % 60:02d}:{y:02d},{z.ljust(3, str(0))}\" for x, y, z in t] + [\n    s + \",000\"\n]  # if I replace str(0) with '0', this increases to 359 characters wtf\nfor a, b in enumerate(l):\n    r.extend([str(c), t[a] + \" --> \" + t[a + 1], b[11:], \"\"])\n    c += 1\nreturn r[:-1]",
    "detail": "Subrip",
    "documentation": {}
  },
  {
    "label": "t",
    "kind": 5,
    "importPath": "Subrip",
    "description": "Subrip",
    "peekOfCode": "t = [[int(s[i : i + 2]) for i in [1, 4]] + [s[7:9]] for s in l]\nt = [f\"{x // 60:02d}:{x % 60:02d}:{y:02d},{z.ljust(3, str(0))}\" for x, y, z in t] + [\n    s + \",000\"\n]  # if I replace str(0) with '0', this increases to 359 characters wtf\nfor a, b in enumerate(l):\n    r.extend([str(c), t[a] + \" --> \" + t[a + 1], b[11:], \"\"])\n    c += 1\nreturn r[:-1]",
    "detail": "Subrip",
    "documentation": {}
  },
  {
    "label": "t",
    "kind": 5,
    "importPath": "Subrip",
    "description": "Subrip",
    "peekOfCode": "t = [f\"{x // 60:02d}:{x % 60:02d}:{y:02d},{z.ljust(3, str(0))}\" for x, y, z in t] + [\n    s + \",000\"\n]  # if I replace str(0) with '0', this increases to 359 characters wtf\nfor a, b in enumerate(l):\n    r.extend([str(c), t[a] + \" --> \" + t[a + 1], b[11:], \"\"])\n    c += 1\nreturn r[:-1]",
    "detail": "Subrip",
    "documentation": {}
  },
  {
    "label": "mySubstring",
    "kind": 5,
    "importPath": "Substring",
    "description": "Substring",
    "peekOfCode": "mySubstring = lambda s, l, r: s[l : r + 1]",
    "detail": "Substring",
    "documentation": {}
  },
  {
    "label": "sudoku",
    "kind": 2,
    "importPath": "sudoku",
    "description": "sudoku",
    "peekOfCode": "def sudoku(grid):\n\t\"\"\"\n\tReturn boolean indicating if Sudoku is valid.\n\t\"\"\"\n    seen = set()\n    # Iterate through grid\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            current_value = grid[i][j]\n            if current_value != '.':",
    "detail": "sudoku",
    "documentation": {}
  },
  {
    "label": "sudoku2",
    "kind": 2,
    "importPath": "sudoku2",
    "description": "sudoku2",
    "peekOfCode": "def sudoku2(grid):\n    seen = set()\n    # Iterate through grid\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            current_value = grid[i][j]\n            if current_value != \".\":\n                if (\n                    (current_value + \" found in row \" + str(i)) in seen\n                    or (current_value + \" found in column \" + str(j)) in seen",
    "detail": "sudoku2",
    "documentation": {}
  },
  {
    "label": "isSum",
    "kind": 2,
    "importPath": "Sum",
    "description": "Sum",
    "peekOfCode": "def isSum(value):\n    s = 0\n    for i in range(100):\n        s += i\n        if s == value:\n            return True",
    "detail": "Sum",
    "documentation": {}
  },
  {
    "label": "alternatingSums",
    "kind": 2,
    "importPath": "Sums",
    "description": "Sums",
    "peekOfCode": "def alternatingSums(a):\n    # Step 1: We begin by creating an array, called \"alt_sum\", that includes only two elements of value 0.\n    alt_sum = [0, 0]\n    # Step 2: Moreover, we define the variable \"length\", which is the numerical value of the length of input array a.\n    length = len(a)\n    # Step 3: Starting from the first element of input array \"a\" and working all the way through its length,\n    # we check whether the element's index is even or odd. If the element i is even, we add its value to the\n    # first element of the \"alt_sum\" array, whilst if it is odd we add it to the second element.\n    for i in range(0, length):\n        if i % 2 == 0:",
    "detail": "Sums",
    "documentation": {}
  },
  {
    "label": "sumUpNumbers",
    "kind": 2,
    "importPath": "sum_up_numbers",
    "description": "sum_up_numbers",
    "peekOfCode": "def sumUpNumbers(inputString):\n\t\"\"\"\n\tReturn the sum of the numbers in the inputString\n\tTime Complexity: O(n)\n\tSpace Complexity: O(1)\n\t\"\"\"\n    runningsum, number = 0, ''\n    for i in range(len(inputString)):\n        if inputString[i].isdigit():\n            number += inputString[i]",
    "detail": "sum_up_numbers",
    "documentation": {}
  },
  {
    "label": "isSuspiciousRespondent",
    "kind": 2,
    "importPath": "SuspiciousRespondent",
    "description": "SuspiciousRespondent",
    "peekOfCode": "def isSuspiciousRespondent(ans1, ans2, ans3):\n    return ans1 == ans2 == ans3",
    "detail": "SuspiciousRespondent",
    "documentation": {}
  },
  {
    "label": "differentSymbolsNaive",
    "kind": 2,
    "importPath": "SymbolsNaive",
    "description": "SymbolsNaive",
    "peekOfCode": "def differentSymbolsNaive(s):\n    return len(set(s))",
    "detail": "SymbolsNaive",
    "documentation": {}
  },
  {
    "label": "tennisSet",
    "kind": 2,
    "importPath": "tennis_set",
    "description": "tennis_set",
    "peekOfCode": "def tennisSet(score1, score2):\n    return (\n        True\n        if score1 == 6\n        and score2 < 5\n        or score1 < 5\n        and score2 == 6\n        or score1 == 7\n        and 5 <= score2 < 7\n        or score2 == 7",
    "detail": "tennis_set",
    "documentation": {}
  },
  {
    "label": "possibilities",
    "kind": 5,
    "importPath": "test (2)",
    "description": "test (2)",
    "peekOfCode": "possibilities = [\"ab\", \"cd\"]\nfor i in it.product(*possibilities):\n    if i:\n        print(\"\".join(i))",
    "detail": "test (2)",
    "documentation": {}
  },
  {
    "label": "TestAdd",
    "kind": 6,
    "importPath": "test_add",
    "description": "test_add",
    "peekOfCode": "class TestAdd(unittest.TestCase):\n    @data(\n        (6, 5, 11),\n        (0, 1000, 1000),\n        (-2, 4, 2),\n        (-100, 100, 0),\n        (-100, 89, -11),\n        (-1000, -999, -1999),\n    )\n    @unpack",
    "detail": "test_add",
    "documentation": {}
  },
  {
    "label": "TestAdjacentElementsProduct",
    "kind": 6,
    "importPath": "test_adjacent_elements_product",
    "description": "test_adjacent_elements_product",
    "peekOfCode": "class TestAdjacentElementsProduct(unittest.TestCase):\n    @data(\n        ([3, 6, -2, -5, 7, 3], 21),\n        ([-2, -2], 4),\n        ([5, 1, 2, 3, 1, 4], 6),\n        ([2, 3, 0], 6),\n        ([9, 5, 10, 2, 24, -1, -48], 50),\n        ([10, 13, 5, 1000], 5000),\n        ([45, 3, -1, -1000], 1000),\n    )",
    "detail": "test_adjacent_elements_product",
    "documentation": {}
  },
  {
    "label": "TestCenturyFromYear",
    "kind": 6,
    "importPath": "test_century_from_year",
    "description": "test_century_from_year",
    "peekOfCode": "class TestCenturyFromYear(unittest.TestCase):\n    @data((1988, 20), (1, 1), (2001, 21), (2000, 20))\n    @unpack\n    def test_positive(self, year, century) -> None:\n        self.assertEqual(func.century_from_year(year), century)\n    @data((\"abcd\", 0), (None, 0), (0, 0), (2010, 0), (-5, 0))\n    @unpack\n    def test_negative(self, year, century) -> None:\n        if year is None:\n            self.assertEqual(func.century_from_year(), century)",
    "detail": "test_century_from_year",
    "documentation": {}
  },
  {
    "label": "TestPalindrome",
    "kind": 6,
    "importPath": "test_palindrome",
    "description": "test_palindrome",
    "peekOfCode": "class TestPalindrome(unittest.TestCase):\n    @data(\n        (\"aabaa\", True),\n        (\"abac\", False),\n        (\"c\", True),\n        (\"testmeplease\", False),\n        (\"hlbeeykoqqqokyeeblh\", True),\n    )\n    @unpack\n    def test_positive(self, input_string, result) -> None:",
    "detail": "test_palindrome",
    "documentation": {}
  },
  {
    "label": "TestShapeArea",
    "kind": 6,
    "importPath": "test_shape_area",
    "description": "test_shape_area",
    "peekOfCode": "class TestShapeArea(unittest.TestCase):\n    @data((2, 5), (3, 13), (1, 1), (5, 41), (7000, 97986001))\n    @unpack\n    def test_positive(self, number, result) -> None:\n        self.assertEqual(func.shape_area(number), result)\n    @data((0, 0), (None, 0), (10001, 0), (-10, 0), (\"a\", 0))\n    @unpack\n    def test_negative(self, number, result) -> None:\n        if number is None:\n            self.assertEqual(func.shape_area(), result)",
    "detail": "test_shape_area",
    "documentation": {}
  },
  {
    "label": "findTheRemainder",
    "kind": 2,
    "importPath": "TheRemainder",
    "description": "TheRemainder",
    "peekOfCode": "def findTheRemainder(a, b):\n    return a % b",
    "detail": "TheRemainder",
    "documentation": {}
  },
  {
    "label": "validTime",
    "kind": 2,
    "importPath": "Time",
    "description": "Time",
    "peekOfCode": "def validTime(time):\n    time_split = time.split(\":\")\n    if 00 <= int(time_split[0]) <= 23 and 00 <= int(time_split[1]) <= 59:\n        return True\n    return False",
    "detail": "Time",
    "documentation": {}
  },
  {
    "label": "n,",
    "kind": 5,
    "importPath": "Title",
    "description": "Title",
    "peekOfCode": "n, = eval(dir()[0])\nr = \"\"\nwhile n:\n    n -= 1\n    r = chr(n % 26 + 65) + r\n    n //= 26\nreturn r",
    "detail": "Title",
    "documentation": {}
  },
  {
    "label": "r",
    "kind": 5,
    "importPath": "Title",
    "description": "Title",
    "peekOfCode": "r = \"\"\nwhile n:\n    n -= 1\n    r = chr(n % 26 + 65) + r\n    n //= 26\nreturn r",
    "detail": "Title",
    "documentation": {}
  },
  {
    "label": "returnTwelve",
    "kind": 5,
    "importPath": "Twelve",
    "description": "Twelve",
    "peekOfCode": "returnTwelve = lambda n: 12 if n < 12 else n",
    "detail": "Twelve",
    "documentation": {}
  },
  {
    "label": "addTwoDigits",
    "kind": 5,
    "importPath": "TwoDigits",
    "description": "TwoDigits",
    "peekOfCode": "addTwoDigits = lambda n: n % 10 + n // 10\n# return sum(int(i) for i in str(n))",
    "detail": "TwoDigits",
    "documentation": {}
  },
  {
    "label": "caseUnification",
    "kind": 2,
    "importPath": "Unification",
    "description": "Unification",
    "peekOfCode": "def caseUnification(s):\n    u = sum(1 for x in s if x.isupper())\n    if u > (len(s) / 2):\n        return s.upper()\n    else:\n        return s.lower()",
    "detail": "Unification",
    "documentation": {}
  },
  {
    "label": "sumUpNumbers",
    "kind": 2,
    "importPath": "UpNumbers",
    "description": "UpNumbers",
    "peekOfCode": "def sumUpNumbers(inputString):\n    def getNumbers(str):\n        nums = re.findall(r\"[0-9]+\", str)\n        return nums\n    numbers = getNumbers(inputString)\n    total = 0\n    for i in numbers:\n        total += int(i)\n    return total",
    "detail": "UpNumbers",
    "documentation": {}
  },
  {
    "label": "validTime",
    "kind": 2,
    "importPath": "valid_time",
    "description": "valid_time",
    "peekOfCode": "def validTime(time):\n\t\"\"\"\n\tBoolean indicating if time is in valid 24hr format\n\t\"\"\"\n    tokens = time.split(':')\n    hours = int(tokens[0])\n    minutes = int(tokens[1])\n    return not (hours > 23 or minutes > 59)",
    "detail": "valid_time",
    "documentation": {}
  },
  {
    "label": "absoluteValuesSumMinimization",
    "kind": 2,
    "importPath": "ValuesSumMinimization",
    "description": "ValuesSumMinimization",
    "peekOfCode": "def absoluteValuesSumMinimization(a):\n    sums = []\n    for i in range(len(a)):\n        sum = 0\n        for j in range(len(a)):\n            sum += abs(a[i] - a[j])\n        sums.append(sum)\n    return a[sums.index(min(sums))]",
    "detail": "ValuesSumMinimization",
    "documentation": {}
  },
  {
    "label": "variableName",
    "kind": 2,
    "importPath": "variable_name",
    "description": "variable_name",
    "peekOfCode": "def variableName(name):\n    if name[0].isdigit():\n        return False\n    for i in range(len(name)):\n        if not name[i].isalnum() and not name[i] == \"_\":\n            return False\n    return True",
    "detail": "variable_name",
    "documentation": {}
  },
  {
    "label": "cubeVolume",
    "kind": 5,
    "importPath": "Volume",
    "description": "Volume",
    "peekOfCode": "cubeVolume = lambda n: n ** 3",
    "detail": "Volume",
    "documentation": {}
  },
  {
    "label": "magicalWell",
    "kind": 2,
    "importPath": "Well",
    "description": "Well",
    "peekOfCode": "def magicalWell(a, b, n):\n    s, m = 0, 0\n    while m < n:\n        s += a * b\n        a += 1\n        b += 1\n        m += 1\n    return s",
    "detail": "Well",
    "documentation": {}
  },
  {
    "label": "electionsWinners",
    "kind": 2,
    "importPath": "Winners",
    "description": "Winners",
    "peekOfCode": "def electionsWinners(votes, k):\n    max_vote = max(votes)\n    len_vote = len(votes)\n    if k == 0 and votes.count(max_vote) == 1:\n        return 1\n    return len([i for i in range(len_vote) if votes[i] + k > max_vote])",
    "detail": "Winners",
    "documentation": {}
  },
  {
    "label": "longestWord",
    "kind": 2,
    "importPath": "Word",
    "description": "Word",
    "peekOfCode": "def longestWord(text):\n    word_split = re.findall(r\"[\\w']+\", text)\n    longest_word = \"\"\n    for word in word_split:\n        if len(word) > len(longest_word) and word.isalpha():\n            longest_word = word\n    return longest_word",
    "detail": "Word",
    "documentation": {}
  }
]
